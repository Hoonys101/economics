# 보고서: 타입 안정성 및 DTO 계약 감사

## Executive Summary

코드베이스는 에이전트 및 시스템 간 데이터 통신에서 타입 안정성이 심각하게 저하되어 있습니다. `Any` 타입의 남용, DTO(Data Transfer Object) 계약의 비일관적인 사용, 다른 객체의 상태를 직접 조작하는 패턴이 다수 발견되어 유지보수성을 저해하고 런타임 오류 발생 위험을 높이고 있습니다.

## Detailed Analysis

### 1. 핵심 컴포넌트의 약한 타입 정의 (`Any` 타입 남용)

- **상태**: ❌ 만연함
- **문제점**: 시뮬레이션, 설정, 에이전트 등 핵심 객체들이 `Any` 타입으로 전달되어 정적 분석의 이점을 무력화하고, 의존성을 파악하기 어렵게 만듭니다.
- **증거**:
  - `modules/finance/saga_handler.py:L21`: `__init__(self, simulation: Any)` -> 시뮬레이션의 전체 상태에 대한 타입 정보가 없습니다.
  - `modules/analysis/fiscal_monitor.py:L7`: `get_debt_to_gdp_ratio(self, government_dto: Any, world_dto: Any)` -> 정부와 월드 상태가 `Any`로 정의되어 `getattr`을 통한 불안정한 접근을 유발합니다.
  - `modules/government/taxation/system.py:L114`: `calculate_tax_intents(self, transaction: Any, buyer: Any, seller: Any, government: Any, ...)` -> 트랜잭션의 모든 참여자가 `Any` 타입으로 정의되어 있습니다.
  - `modules/finance/credit_scoring.py:L16`: `__init__(self, config_module: Any)` -> 설정 객체가 `Any`로 주입되어 타입 안정성이 없습니다.
- **개선 가이드**:
  - `Any`를 명시적인 `Protocol`로 대체하십시오. 예를 들어, `simulation: Any`는 `ISimulationState` (`modules/simulation/api.py`) 프로토콜을 사용해야 합니다.
  - `government: Any`는 `IGovernment` (`modules/government/api.py`) 또는 `IFinancialEntity` (`modules/finance/api.py`) 프로토콜을 사용해야 합니다.
  - 필요한 인터페이스가 없다면 새 프로토콜을 `api.py`에 정의하여 의존성을 명확히 하십시오.

### 2. 비일관적인 데이터 전송 방식 (Dictionary vs. DTO)

- **상태**: ⚠️ 부분적으로 준수
- **문제점**: `api.py`에 명시적인 `dataclass`나 `TypedDict` DTO가 있음에도 불구하고, 일반 `dict`를 사용해 데이터를 주고받는 경우가 많습니다. 이는 데이터 계약을 모호하게 만들고 `KeyError` 발생 위험을 높입니다.
- **증거**:
  - `modules/analysis/crisis_monitor.py:L57`: `monitor` 메서드가 `Dict[str, int]`를 반환합니다. `CrisisDistributionDTO`와 같은 명시적인 DTO로 정의해야 합니다.
  - `modules/analysis/phenomena_analyzer.py:L53`: `sim_state.get_market_snapshot()`의 반환 값을 `snapshot.get('gdp', 0.0)`처럼 딕셔너리로 취급합니다. `system/api.py`에 정의된 `MarketSnapshotDTO` 데이터클래스는 `gdp` 필드를 직접 포함하지 않으므로, 이는 레거시 `TypedDict`와의 혼용으로 인한 혼란을 야기합니다.
  - `modules/analytics/loader.py:L111`: `load_fiscal_history`가 JSON 파일에서 `list of dicts`를 로드합니다. 각 딕셔너리는 `TaxHistoryItemDTO`와 같은 DTO로 구조화되어야 합니다.
- **개선 가이드**:
  - 모든 컴포넌트 간 데이터 교환에는 `api.py`에 정의된 `dataclass` 또는 `TypedDict` DTO를 일관되게 사용하십시오.
  - `MarketSnapshotDTO`와 같이 여러 정의가 혼용되는 경우, `modules/system/api.py`의 `dataclass` 버전을 표준으로 삼고 코드베이스 전체를 통일하십시오.
  - `dict`를 반환하는 모든 함수를 DTO를 반환하도록 리팩토링하십시오.

### 3. 캡슐화 원칙 위반 (직접적인 상태 조작)

- **상태**: ❌ 만연함
- **문제점**: 하나의 객체가 다른 객체의 내부 상태(특히 `_`로 시작하는 비공개 변수)에 직접 접근하여 수정합니다. 이는 강한 결합을 유발하여 코드를 취약하게 만듭니다.
- **증거**:
  - `modules/market/handlers/housing_transaction_handler.py:L70`: `buyer_assets = buyer._econ_state.assets` -> `buyer` 객체의 내부 상태인 `_econ_state`에 직접 접근합니다.
  - `modules/market/handlers/housing_transaction_handler.py:L268`: `unit.owner_id = buyer.id`, `seller._econ_state.owned_properties.remove(unit_id)` -> 핸들러가 `unit`, `seller` 등 다른 객체의 상태를 직접 변경합니다.
  - `modules/finance/system.py:L316`: `firm.total_debt += amount` -> `FinanceSystem`이 `Firm` 객체의 부채를 직접 증가시킵니다.
- **개선 가이드**:
  - 객체의 상태는 해당 객체의 공개 메서드를 통해서만 변경되어야 합니다. 예를 들어, `firm.add_debt(amount)`와 같은 메서드를 호출해야 합니다.
  - 다른 객체의 데이터는 `Protocol`에 정의된 공개 프로퍼티(`@property`)를 통해 읽기 전용으로 접근해야 합니다. (예: `buyer.assets`)
  - 내부 상태 객체(`_econ_state` 등)는 외부로 노출되어서는 안 됩니다.

## Risk Assessment

- **런타임 오류**: 현재 구조는 `AttributeError`, `KeyError`, `TypeError`와 같은 런타임 오류에 매우 취약합니다.
- **유지보수 비용 증가**: 데이터 계약이 명확하지 않아 새로운 기능을 추가하거나 기존 코드를 리팩토링하기가 매우 어렵고 위험합니다.
- **신규 개발자 적응 문제**: 코드의 동작 방식을 이해하기 위해 여러 파일의 구현부를 넘나들며 실제 데이터 구조를 추측해야 하므로 생산성이 저하됩니다.

## Conclusion

안정적이고 확장 가능한 시스템을 구축하기 위해 코드베이스 전반에 걸쳐 DTO 및 프로토콜 계약을 강제하는 체계적인 리팩토링이 시급합니다. `Any` 타입을 제거하고, DTO 사용을 일관되게 적용하며, 캡슐화 원칙을 준수하도록 코드를 수정하는 것이 최우선 과제입니다.
