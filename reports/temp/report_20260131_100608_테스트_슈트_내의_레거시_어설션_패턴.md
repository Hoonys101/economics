# Report: Legacy Assertion Migration Guide (TD-165)

## Executive Summary
A comprehensive review of the test suite reveals a significant number of legacy tests (over 15 identified) that are either skipped or rely on deprecated assertion patterns. These tests often verify internal implementation details rather than public API contracts, making them brittle and reducing their effectiveness as regression guards. This guide outlines a strategy to migrate these tests to a modern, robust, behavior-driven assertion model, aligning them with the project's DTO-centric, "Purity Gate" architecture.

## Detailed Analysis

This section details the primary legacy patterns and provides a clear migration path for each. The core principle is to **test the behavior (the "what"), not the implementation (the "how").** For decision engines, this means verifying the `orders` and `actions` they return, not the internal methods they call.

### 1. Pattern: Asserting Internal State Mutation
- **Problem**: Tests directly check for changes in an object's internal attributes (e.g., `firm.marketing_budget_rate`) after a method call. This creates tight coupling between the test and the implementation. If the internal structure of the class changes (e.g., the attribute is moved to a sub-component), the test will fail even if the observable behavior is correct.
- **Solution**: Test the public API contract. For decision engines and managers, this means verifying the returned list of `Order` or `Transaction` objects that represent the intended state change.
- **Migration Example**:
    - **Legacy**:
      ```python
      # Asserts that the firm's internal attribute was changed
      firm._adjust_marketing_budget()
      self.assertAlmostEqual(firm.marketing_budget_rate, 0.055)
      ```
    - **Modern**:
      ```python
      # Asserts that the engine *intends* to change the budget
      orders, _ = engine.make_decisions(context)
      set_budget_order = find_order_by_type(orders, "SET_BUDGET") # Helper function
      assert set_budget_order is not None
      assert set_budget_order.quantity == 0.055
      ```

### 2. Pattern: Asserting Mocked Internal Method Calls
- **Problem**: Tests verify that a specific internal method on a mocked dependency was called (e.g., `firm.sales.post_ask.assert_called_once()`). This validates *how* a method works, not *what* it achieves.
- **Solution**: The System Under Test (SUT) should return a data structure (like an `Order`) representing its decision. The test asserts that the correct decision is returned. It is the responsibility of the *caller* (e.g., the main simulation loop) to interpret this decision and execute the corresponding action (e.g., call a market's `place_order` method).
- **Migration Example**:
    - **Legacy**:
      ```python
      # Asserts an internal component's method was called
      engine.make_decisions(context)
      mock_firm.sales.post_ask.assert_called_once_with(...)
      ```
    - **Modern**:
      ```python
      # Asserts a SELL order was generated with the correct parameters
      orders, _ = engine.make_decisions(context)
      sell_order = find_order_by_type(orders, "SELL")
      assert sell_order is not None
      assert sell_order.price < 10.0
      ```

### 3. Pattern: Testing Obsolete or Private Methods
- **Problem**: Numerous tests are skipped with `pytest.mark.skip` because they target private methods (e.g., `_get_consumption_candidates`) or methods from a "non-existent rule_based_engine". These tests are dead code and provide no regression coverage.
- **Solution**: Delete the obsolete tests. Create new tests targeting the current public API (e.g., `make_decisions`). These new tests should construct a specific `DecisionContext` to create the conditions necessary to exercise the logic previously covered by the old test.
- **Migration Example**:
    - **Legacy**:
      ```python
      @pytest.mark.skip(reason="tests private method on non-existent engine")
      def test_get_consumption_candidates(...):
          pass
      ```
    - **Modern**:
      ```python
      def test_make_decisions_chooses_best_utility_good():
          # Setup context with multiple goods having different prices/utilities
          context = create_multi_good_scenario_context(...)
          orders, _ = engine.make_decisions(context)
          # Assert that the returned order is for the good with the highest utility/price ratio
          assert orders[0].item_id == "best_value_good"
      ```

### 4. Pattern: Inconsistent or Missing DTO Usage
- **Problem**: Some tests pass full `MagicMock` agents into functions that now require a `DecisionContext` containing a `StateDTO`. This violates the "Purity Gate" principle (TD-168) and leads to brittle tests that can't guarantee the engine works with the actual data contract.
- **Solution**: Refactor all decision engine tests to use a `DecisionContext`. Populate `context.state` with a properly instantiated `HouseholdStateDTO` or `FirmStateDTO`. Use helper factories (e.g., `tests/unit/factories.py`) to simplify DTO creation.
- **Migration Example**:
    - **Legacy**:
      ```python
      # Passing a raw mock object
      engine.make_decisions(mock_household, markets, ...)
      ```
    - **Modern**:
      ```python
      # Passing a DTO within a standard context
      from tests.utils.factories import create_household_dto
      dto = create_household_dto(assets=100.0, needs={"survival": 0.8})
      context = DecisionContext(state=dto, config=..., market_data=...)
      engine.make_decisions(context)
      ```

## Target Migration List

The following files and tests are primary candidates for migration, categorized by the patterns described above.

### High Priority (Skipped / Incorrect Contract)
- **`tests/unit/test_firm_decision_engine_new.py`**
    - **Pattern**: #2 (Asserting Mock Calls)
    - **Tests**: `test_make_decisions_price_adjusts_overstock`, `test_make_decisions_price_adjusts_understock`, `test_make_decisions_sell_order_details`, `test_make_decisions_fires_excess_labor`, `test_sales_aggressiveness_impact_on_price`, `test_rd_investment`, `test_capex_investment`, `test_dividend_setting`
    - **Action**: Implement assertions that check the properties of the returned `Order` objects.
- **`tests/unit/test_household_decision_engine_multi_good.py`**
    - **Pattern**: #3 (Obsolete/Private Methods)
    - **Tests**: All skipped tests (`test_get_consumption_candidates`, `test_calculate_utility_gain_*`, `test_find_optimal_consumption_bundle_*`).
    - **Action**: Delete skipped tests. Write new tests for `make_decisions` that validate multi-good choice logic by inspecting the returned orders.
- **`tests/unit/test_marketing_roi.py`**
    - **Pattern**: #1 (Internal State Mutation)
    - **Tests**: All skipped tests (`test_budget_increase_on_high_efficiency`, `test_budget_decrease_on_low_efficiency`, `test_first_tick_skip`).
    - **Action**: Refactor to test the public decision-making method and assert that the correct `SET_MARKETING_BUDGET` order is (or is not) generated.

### Medium Priority (Modernization & DTO Purity)
- **`tests/integration/scenarios/verify_vanity_society.py`**
    - **Pattern**: #4 (Inconsistent DTO Usage)
    - **Test**: `test_veblen_demand` passes a `household` kwarg to `DecisionContext` instead of using `state`.
    - **Action**: Update the `DecisionContext` instantiation to use `state=household_dto` and refactor the SUT (`AIDrivenHouseholdDecisionEngine`) to only accept `context.state`.
- **`tests/unit/modules/government/components/test_fiscal_policy_manager.py`**
    - **Pattern**: General Review
    - **Action**: While the tests are reasonable, they test the *components* of policy. Ensure there is also integration test coverage verifying that the main `Government.make_policy_decision` method correctly uses these components and produces the expected final output (e.g., `SET_TAX_RATE` orders).

## Conclusion
Migrating the test suite to modern assertion patterns is critical for maintaining code quality and developer velocity. This effort will decouple tests from implementation, improve regression detection, and ensure all components adhere to the project's architectural principles. The highest priority is to address the currently skipped tests, as they represent a significant gap in test coverage.
