# SPECIFICATION: Phase 3 - Value Preservation & Recovery (SPEC_ANIMAL_PHASE3_RECOVERY)

**Objective**: To introduce a system-level `Public Manager` that prevents the destruction of economic value following an agent's bankruptcy. This entity will take ownership of a defunct agent's assets and liquidate them in an orderly fashion, ensuring the proceeds are retained within the simulation to maintain zero-sum integrity.

---

## 1. System Architecture: The Public Manager

The `PublicManager` is a core system service responsible for asset recovery and liquidation.

- **Location**: `modules.system.execution.public_manager.PublicManager`
- **Type**: System-level service, **NOT** an agent. It does not have needs, assets, or other agent properties.
- **Interface**: Implements the `IAssetRecoverySystem` protocol defined in `modules.system.api.py`.
- **Identity**: All market orders generated by this manager will use the special `agent_id`: `"PUBLIC_MANAGER"`. The market module must be able to process orders with this ID.

## 2. Simulation Engine Modification: Phase 4.5

To ensure strict operational order and prevent circular dependencies, a new phase is inserted into the main simulation loop.

### 2.1. Updated Simulation Tick Flow

The `Simulation.run_tick()` method will be modified as follows:

```python
# In Simulation.run_tick()

# ... (Previous phases: Market updates, etc.)

# Phase 4: Agent Decisions & Lifecycle
# Agents make decisions. Bankrupt agents are identified here.
bankrupt_agents = self.lifecycle_module.process_agents(self.agents)

for agent in bankrupt_agents:
    # Generate the bankruptcy event DTO
    event = self.create_bankruptcy_event_dto(agent)
    
    # The Public Manager immediately takes custody of the assets
    self.public_manager.process_bankruptcy_event(event)
    
    # Mark agent for removal
    self.agents.remove(agent)

# --- NEW Phase 4.5: Systemic Liquidation ---
# This phase runs AFTER all agents have decided and BEFORE the market matches orders.

# 1. Get a snapshot of the current market state for pricing decisions.
market_signals = self.system_monitor.get_market_signals() 

# 2. The Public Manager generates sell orders for its managed inventory.
liquidation_orders = self.public_manager.generate_liquidation_orders(market_signals)

# 3. Place these system-level orders into the market.
for order in liquidation_orders:
    self.market.place_order(order, self.current_time)

# Phase 5: Market Matching (Previously Phase 2/5)
# The market now resolves all open orders, including the new liquidation orders.
transactions = self.market.match_orders()

# Post-transaction: Handle revenue from Public Manager sales
for tx in transactions:
    if tx.seller_id == "PUBLIC_MANAGER":
        self.public_manager.deposit_revenue(tx.price * tx.quantity)

# ... (Remaining phases: Production, Consumption, etc.)
```

## 3. Detailed Logic: `PublicManager`

### 3.1. Initialization

The `PublicManager` maintains its own inventory and a treasury to hold liquidation proceeds, ensuring value is not destroyed.

```python
# In modules.system.execution.public_manager.PublicManager

class PublicManager(IAssetRecoverySystem):
    def __init__(self, config):
        self.config = config # System-level configuration
        self.managed_inventory: Dict[str, float] = defaultdict(float)
        self.system_treasury: float = 0.0
        self.logger = get_logger("PublicManager")
        # Other asset stores (e.g., for durables, property) can be added here
```

### 3.2. Asset Recovery (Pseudo-code)

This method is a pure, value-preserving transfer of assets from the bankrupt agent to the manager's custody.

```python
# In PublicManager

def process_bankruptcy_event(self, event: AgentBankruptcyEventDTO) -> None:
    """Takes ownership of a defunct agent's inventory."""
    self.logger.warning(
        f"Processing bankruptcy for Agent {event.agent_id} at tick {event.tick}. "
        f"Recovering inventory."
    )
    for item_id, quantity in event.inventory.items():
        if quantity > 0:
            self.managed_inventory[item_id] += quantity
            self.logger.info(f"Recovered {quantity} of {item_id}.")
    
    # Logic to recover other asset types (durables, shares) would go here.
```

### 3.3. Orderly Liquidation (Pseudo-code)

This method generates sell orders based on market conditions, designed to avoid market crashes.

```python
# In PublicManager

def generate_liquidation_orders(self, market_signals: Dict[str, MarketSignalDTO]) -> List["Order"]:
    """Generates non-disruptive SELL orders for managed assets."""
    orders = []
    items_to_liquidate = list(self.managed_inventory.items()) # Create a copy to iterate over

    for item_id, quantity in items_to_liquidate:
        if quantity <= 0:
            continue

        market_signal = market_signals.get(item_id)
        if not market_signal or market_signal.best_ask is None:
            self.logger.info(f"No market signal for {item_id}, will not liquidate this tick.")
            continue

        # Strategy: Sell a fraction of inventory at a slight discount to the best ask.
        sell_quantity = min(quantity, quantity * self.config.liquidation_sell_rate)
        
        # Undercut the best ask price to increase chance of sale, but don't start a race to the bottom.
        sell_price = market_signal.best_ask * (1 - self.config.liquidation_ask_undercut)
        
        if sell_price <= 0 or sell_quantity <= 0:
            continue

        order = Order(
            agent_id="PUBLIC_MANAGER", # Special system ID
            item_id=item_id,
            order_type="SELL",
            quantity=sell_quantity,
            price=sell_price
        )
        orders.append(order)

        # Tentatively decrement inventory. This will be confirmed upon successful transaction.
        self.managed_inventory[item_id] -= sell_quantity
        self.logger.info(f"Generated liquidation order for {sell_quantity} of {item_id} at {sell_price}.")
        
    return orders
```

## 4. Zero-Sum Integrity Mechanism

The complete lifecycle of a recovered asset and its monetary value is as follows:

1.  **Bankruptcy**: An agent's assets fall below zero. A `AgentBankruptcyEventDTO` is created.
2.  **Custody Transfer**: `PublicManager.process_bankruptcy_event` is called. The agent's inventory is moved to `self.managed_inventory`. **No value has been created or destroyed.** The assets simply changed hands at the system level.
3.  **Liquidation Order**: `PublicManager.generate_liquidation_orders` places a SELL order on the market.
4.  **Transaction**: The market matches the order. A `Transaction` object is created.
5.  **Revenue Capture**: The `Simulation` loop identifies the transaction's seller is `"PUBLIC_MANAGER"`. Instead of trying to credit an agent, it calls `PublicManager.deposit_revenue(value)`.
6.  **Treasury Deposit**: The `PublicManager` increases `self.system_treasury` by the revenue amount. **Value that left the market as goods re-enters as currency.**
7.  **Verification**: The `scripts/trace_leak.py` script will be updated to include the `PublicManager.system_treasury` in its total system money supply calculation, ensuring the zero-sum principle is upheld.

## 5. API & DTO Definitions

The following contracts will be defined in `modules/system/api.py`.

-   **`AgentBankruptcyEventDTO`**: Broadcast when an agent fails. Contains `agent_id`, `tick`, and `inventory`.
-   **`PublicManagerReportDTO`**: Summarizes the manager's activities each tick (`newly_recovered_assets`, `liquidation_revenue`, etc.).
-   **`IAssetRecoverySystem` (Protocol)**: Defines the manager's public methods:
    -   `process_bankruptcy_event(event: AgentBankruptcyEventDTO) -> None`
    -   `generate_liquidation_orders(market_signals: Dict[str, MarketSignalDTO]) -> List["Order"]`
    -   `deposit_revenue(amount: float) -> None`
    -   `get_status_report() -> PublicManagerReportDTO`

## 6. Verification Plan & Impact Analysis

-   **Unit Tests**:
    -   `TestPublicManager.test_asset_recovery`: Verify that a bankruptcy event correctly transfers inventory to the manager.
    -   `TestPublicManager.test_order_generation`: Provide market signals and verify the manager creates correctly priced, non-disruptive sell orders.
    -   `TestPublicManager.test_treasury_deposit`: Simulate a successful sale and verify the revenue is deposited into the `system_treasury`.
-   **Integration Test**:
    -   `TestSimulation.test_zero_sum_with_bankruptcy`: Run a multi-tick simulation where an agent goes bankrupt. Run `scripts/trace_leak.py`'s core logic at the end to confirm the system's total money supply (including the `PublicManager`'s treasury) remains constant.
-   **ðŸš¨ Critical: Widespread Test Invalidation**: The introduction of a systemic asset liquidator will fundamentally change market equilibrium and simulation outcomes. **This change invalidates most existing economic outcome tests.**
    -   **Mandatory Action**: A full review and regeneration of golden test fixtures using `scripts/fixture_harvester.py` is a required and significant part of this implementation. This is not an optional step.

## 7. Risk & Impact Audit (Compliance Statement)

This specification is designed to comply with all architectural constraints identified in the `[AUTO-AUDIT FINDINGS]`.

1.  **Strict Execution Phasing**: Addressed by the introduction of the dedicated **`Phase 4.5: Systemic Liquidation`** in the simulation loop, ensuring a clean separation of concerns.
2.  **Zero-Sum Integrity**: Addressed by the creation of the `system_treasury` within the `PublicManager` and the `deposit_revenue` mechanism. The entire value lifecycle is accounted for and verifiable.
3.  **System-Level Operation**: Addressed by designing the `PublicManager` as a non-agent service and using the `"PUBLIC_MANAGER"` special ID for all its transactions.
4.  **Test Invalidation**: The risk is acknowledged, and the **Verification Plan (Section 6)** explicitly makes the regeneration of golden fixtures a mandatory task for the implementation team.
