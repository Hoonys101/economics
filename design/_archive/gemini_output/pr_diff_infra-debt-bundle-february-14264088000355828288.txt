diff --git a/communications/insights/INFRA_DEBT_BUNDLE_202602.md b/communications/insights/INFRA_DEBT_BUNDLE_202602.md
new file mode 100644
index 0000000..ecfd2d6
--- /dev/null
+++ b/communications/insights/INFRA_DEBT_BUNDLE_202602.md
@@ -0,0 +1,26 @@
+# Infrastructure Debt Bundle Resolution (TD-203, TD-204, TD-210, TD-223)
+
+## Technical Debt Resolutions
+
+### TD-203: Update Stale SettlementSystem Unit Tests
+- **Context:** `SettlementSystem`'s unit tests were relying heavily on mocking the `HousingTransactionSagaHandler` class, potentially masking integration issues with the actual handler logic.
+- **Resolution:** Created `tests/unit/systems/test_settlement_saga_integration.py`. This test suite verifies the orchestration loop by using the *real* `HousingTransactionSagaHandler` class with mocked dependencies (Agents, HousingService, LoanMarket). This ensures that the `SettlementSystem` correctly delegates to the handler and processes the returned state transitions (e.g., INITIATED -> CREDIT_CHECK).
+- **Insight:** Mocking the orchestrator's delegate (Handler) is good for unit testing the orchestrator's state machine, but integration tests using the real delegate are crucial to verify that the delegate's contract matches what the orchestrator expects.
+
+### TD-204: Refactor BubbleObservatory (SRP)
+- **Context:** `BubbleObservatory` violated SRP by coupling complex metric calculation logic with CSV logging and state management.
+- **Resolution:** Extracted calculation logic into a new `BubbleMetricsCalculator` class. `BubbleObservatory` now acts as a coordinator, instantiating the calculator and handling the side-effect (logging).
+- **Insight:** State access patterns differed between the calculator (using `world_state`) and the test suite (using `simulation.agents`). The refactor highlighted this discrepancy. We updated the design to allow injecting `agents` explicitly, making the component more testable and flexible.
+
+### TD-210: Clean Conftest.py
+- **Context:** `tests/conftest.py` contained commented-out imports and references to heavy classes (`CentralBank`, `Bank`) that were causing import overhead or confusion.
+- **Resolution:** Removed the commented code. Verified that `mock_central_bank` and `mock_bank` fixtures remain lightweight mocks, preventing inadvertent loading of heavy libraries like `numpy` during test collection.
+
+### TD-223: Unify Mortgage DTOs
+- **Context:** Duplicate DTOs `MortgageApplicationDTO` (Finance API) and `MortgageApplicationRequestDTO` (Loan API) caused confusion and potential drift.
+- **Resolution:** Deprecated `MortgageApplicationRequestDTO`. Updated `LoanMarket`, `HousingSystem`, and `HousingPlanner` to use `MortgageApplicationDTO` from `modules.finance.api`. Added an alias in `modules/market/loan_api.py` for transitional safety, though all internal usages were updated.
+- **Insight:** Unifying DTOs required careful updates across multiple systems (Housing, Loan, Finance). Using a shared `api.py` in `modules/finance` as the source of truth helps enforce consistency.
+
+## Remaining Debt / Future Work
+- **DTO Alias:** `MortgageApplicationRequestDTO` alias remains in `modules/market/loan_api.py`. It should be removed in a future cleanup once external consumers (if any) are confirmed to be updated.
+- **HousingPlanner Logic:** `HousingPlanner` logic is becoming complex. It duplicates some logic found in `LoanMarket` (e.g., DTI estimation). Future refactoring should centralize credit assessment logic even further, perhaps exposing a `Bank.estimate_max_loan()` method.
diff --git a/modules/analysis/bubble_observatory.py b/modules/analysis/bubble_observatory.py
index 0dc59f1..18fe078 100644
--- a/modules/analysis/bubble_observatory.py
+++ b/modules/analysis/bubble_observatory.py
@@ -1,83 +1,86 @@
-from typing import List, Optional
+from typing import List, Optional, Any, TYPE_CHECKING
 import math
 import statistics
 import logging
+import os
 
 from modules.market.housing_planner_api import IBubbleObservatory, HousingBubbleMetricsDTO
-from simulation.engine import Simulation
+
+if TYPE_CHECKING:
+    from simulation.engine import Simulation
 
 logger = logging.getLogger(__name__)
 
-class BubbleObservatory(IBubbleObservatory):
+class BubbleMetricsCalculator:
     """
-    Monitors the housing market for signs of a bubble.
-    Collects metrics on Price, Credit, and Leverage.
+    Pure logic component for calculating housing bubble metrics.
+    Separated from BubbleObservatory for SRP (TD-204).
     """
-
-    def __init__(self, simulation: Simulation):
-        self.simulation = simulation
-        self.last_m2 = 0.0
-
-        # Initialize last_m2
-        if hasattr(self.simulation.world_state, 'calculate_total_money'):
-             self.last_m2 = self.simulation.world_state.calculate_total_money()
-
-    def collect_metrics(self) -> HousingBubbleMetricsDTO:
-        state = self.simulation.world_state
+    def __init__(self, simulation_state: Any, config_module: Any, last_m2: float, agents: Any = None):
+        self.state = simulation_state
+        self.config = config_module
+        self.last_m2 = last_m2
+        self.current_m2 = 0.0
+        # Prefer injected agents, fallback to state.agents
+        self.agents = agents if agents is not None else getattr(simulation_state, 'agents', {})
+
+    def calculate(self) -> HousingBubbleMetricsDTO:
+        state = self.state
         tick = state.time
 
         # 1. House Price Index (Average Estimated Value)
-        # We use estimated value of all units to gauge market level
         units = state.real_estate_units
         prices = [u.estimated_value for u in units if u.estimated_value > 0]
         avg_price = statistics.mean(prices) if prices else 0.0
 
         # 2. M2 Growth Rate
-        current_m2 = state.calculate_total_money()
+        # Calculate current M2 here so we can use it for growth rate
+        if hasattr(state, 'calculate_total_money'):
+            self.current_m2 = state.calculate_total_money()
+        else:
+            self.current_m2 = 0.0 # Fallback
+
         if self.last_m2 == 0:
             growth_rate = 0.0
         else:
-            growth_rate = (current_m2 - self.last_m2) / self.last_m2
-
-        self.last_m2 = current_m2
+            growth_rate = (self.current_m2 - self.last_m2) / self.last_m2
 
         # 3. New Mortgage Volume & LTV/DTI from Transactions
-        # We scan this tick's housing transactions
-        # Transactions are in state.transactions (all of them? or just this tick?)
-        # state.transactions accumulates. We need to filter by tick.
-        # But state.transactions list grows indefinitely? (Memory leak risk, but addressed in other TD).
-        # We filter by t.time == tick.
-
-        housing_txs = [t for t in state.transactions if t.transaction_type == "housing" and t.time == tick]
+        transactions = getattr(state, 'transactions', [])
+        housing_txs = [t for t in transactions if t.transaction_type == "housing" and t.time == tick]
 
         new_mortgage_vol = 0.0
         ltvs = []
         dtis = []
 
         bank = state.bank
-        TICKS_PER_YEAR = getattr(self.simulation.config_module, 'TICKS_PER_YEAR', 100)
+        TICKS_PER_YEAR = getattr(self.config, 'TICKS_PER_YEAR', 100)
+
+        # Access agents safely
+        agents = self.agents
+        if hasattr(agents, 'get'):
+            get_agent = agents.get
+        else:
+            get_agent = lambda aid: None
 
         for tx in housing_txs:
             price = tx.price
             if price <= 0: continue
 
-            # Check for Mortgage
             if tx.metadata and "mortgage_id" in tx.metadata:
                 mid = tx.metadata["mortgage_id"]
                 loan = None
 
-                # Resolve Loan Object
-                # Try explicit string construction
-                lid_str = f"loan_{mid}"
-                if lid_str in bank.loans:
-                    loan = bank.loans[lid_str]
-                else:
-                    # Search
-                    for k, l in bank.loans.items():
-                        # Heuristic matching if ID formats differ
-                         if str(mid) in k:
-                             loan = l
-                             break
+                # Resolve Loan
+                if hasattr(bank, 'loans'):
+                    lid_str = f"loan_{mid}"
+                    if lid_str in bank.loans:
+                        loan = bank.loans[lid_str]
+                    else:
+                        for k, l in bank.loans.items():
+                             if str(mid) in k:
+                                 loan = l
+                                 break
 
                 if loan:
                     new_mortgage_vol += loan.principal
@@ -86,21 +89,15 @@ class BubbleObservatory(IBubbleObservatory):
                     ltv = loan.principal / price
                     ltvs.append(ltv)
 
-                    # DTI (Approximate)
-                    buyer = self.simulation.agents.get(tx.buyer_id)
+                    # DTI
+                    buyer = get_agent(tx.buyer_id)
                     if buyer and hasattr(buyer, 'current_wage'):
                         annual_income = buyer.current_wage * TICKS_PER_YEAR
                         monthly_income = annual_income / 12.0
 
-                        # Monthly Payment
-                        # Use Loan Interest
                         r = loan.annual_interest_rate / 12.0
-                        n = getattr(loan, 'term_ticks', 360) # Assuming term_ticks approx months or we convert?
-                        # Bank stores term_ticks.
-                        # If term_ticks is large (e.g. 3600), we need conversion.
-                        # Usually term_ticks matches Simulation Ticks.
-                        # But mortgage calc usually based on Months.
-                        # Let's use standard approximation for metric: 360 months.
+                        n = getattr(loan, 'term_ticks', 360)
+                        # Approximation: 360 months standard
                         months = 360
 
                         if r == 0:
@@ -108,9 +105,6 @@ class BubbleObservatory(IBubbleObservatory):
                         else:
                             payment = loan.principal * (r * (1+r)**months) / ((1+r)**months - 1)
 
-                        # Existing Debt?
-                        # Hard to get exact existing debt payment snapshot at moment of tx.
-                        # We just use this loan's DTI contribution (Front-End DTI).
                         if monthly_income > 0:
                             dti = payment / monthly_income
                             dtis.append(dti)
@@ -119,22 +113,21 @@ class BubbleObservatory(IBubbleObservatory):
         avg_dti = statistics.mean(dtis) if dtis else 0.0
 
         # 4. Price-to-Income Ratio (PIR)
-        TICKS_PER_YEAR = getattr(self.simulation.config_module, 'TICKS_PER_YEAR', 100)
-        all_agents = self.simulation.agents.values()
+        # Iterate all agents to get average income
+        all_agents_values = agents.values() if hasattr(agents, 'values') else []
         household_incomes = [
             agent.current_wage * TICKS_PER_YEAR
-            for agent in all_agents
+            for agent in all_agents_values
             if hasattr(agent, 'current_wage') and agent.current_wage > 0
         ]
 
         avg_annual_income = statistics.mean(household_incomes) if household_incomes else 0.0
         pir = (avg_price / avg_annual_income) if avg_annual_income > 0 else 0.0
 
-        # PIR Alarm
         if pir > 20.0:
             logger.warning(f"High PIR detected: {pir:.2f}. Avg House Price: {avg_price:.2f}, Avg Annual Income: {avg_annual_income:.2f}")
 
-        metrics: HousingBubbleMetricsDTO = {
+        return {
             "tick": tick,
             "house_price_index": avg_price,
             "m2_growth_rate": growth_rate,
@@ -144,21 +137,53 @@ class BubbleObservatory(IBubbleObservatory):
             "pir": pir
         }
 
-        # Log to file (append)
-        # "logs/housing_bubble_monitor.csv"
-        # We should use a CSV writer or logger.
-        # Minimal implementation:
+class BubbleObservatory(IBubbleObservatory):
+    """
+    Monitors the housing market for signs of a bubble.
+    Delegates calculation to BubbleMetricsCalculator and handles logging.
+    """
+
+    def __init__(self, simulation: Any):
+        self.simulation = simulation
+        self.last_m2 = 0.0
+
+        # Initialize last_m2
+        if hasattr(self.simulation.world_state, 'calculate_total_money'):
+             self.last_m2 = self.simulation.world_state.calculate_total_money()
+
+    def collect_metrics(self) -> HousingBubbleMetricsDTO:
+        # Determine agents source
+        # Prioritize simulation.agents if available, else world_state.agents
+        agents = getattr(self.simulation, 'agents', getattr(self.simulation.world_state, 'agents', {}))
+
+        calculator = BubbleMetricsCalculator(
+            self.simulation.world_state,
+            self.simulation.config_module,
+            self.last_m2,
+            agents=agents
+        )
+
+        metrics = calculator.calculate()
+
+        # Update internal state (M2)
+        self.last_m2 = calculator.current_m2
+
+        # Log Logic (Side Effect)
+        self._log_metrics(metrics)
+
+        return metrics
+
+    def _log_metrics(self, metrics: HousingBubbleMetricsDTO):
+        """Writes metrics to CSV log."""
         try:
-            import os
             os.makedirs("logs", exist_ok=True)
-            file_exists = os.path.isfile("logs/housing_bubble_monitor.csv")
+            file_path = "logs/housing_bubble_monitor.csv"
+            file_exists = os.path.isfile(file_path)
 
-            with open("logs/housing_bubble_monitor.csv", "a") as f:
+            with open(file_path, "a") as f:
                 if not file_exists:
                     f.write("tick,house_price_index,m2_growth_rate,new_mortgage_volume,average_ltv,average_dti,pir\n")
 
-                f.write(f"{tick},{avg_price:.2f},{growth_rate:.6f},{new_mortgage_vol:.2f},{avg_ltv:.4f},{avg_dti:.4f},{pir:.2f}\n")
+                f.write(f"{metrics['tick']},{metrics['house_price_index']:.2f},{metrics['m2_growth_rate']:.6f},{metrics['new_mortgage_volume']:.2f},{metrics['average_ltv']:.4f},{metrics['average_dti']:.4f},{metrics['pir']:.2f}\n")
         except Exception as e:
             logger.error(f"BubbleObservatory: Failed to log metrics. {e}")
-
-        return metrics
diff --git a/modules/housing/planner.py b/modules/housing/planner.py
index 83668b6..5663b68 100644
--- a/modules/housing/planner.py
+++ b/modules/housing/planner.py
@@ -8,7 +8,6 @@ from modules.market.housing_planner_api import (
     HousingDecisionDTO,
     MortgageApplicationDTO
 )
-from modules.market.loan_api import MortgageApplicationRequestDTO
 
 logger = logging.getLogger(__name__)
 
@@ -130,9 +129,10 @@ class HousingPlanner(IHousingPlanner):
                 logger.error(f"HousingPlanner: Invalid property ID {best_prop.unit_id}")
                 return self._stay_decision()
 
-            mortgage_app = MortgageApplicationRequestDTO(
+            mortgage_app = MortgageApplicationDTO(
                 applicant_id=household.id,
                 requested_principal=loan_amount,
+                purpose="MORTGAGE",
                 property_id=prop_id,
                 property_value=offer_price,
                 applicant_monthly_income=annual_income / 12.0,
diff --git a/modules/market/housing_planner_api.py b/modules/market/housing_planner_api.py
index 75bbfad..86fe247 100644
--- a/modules/market/housing_planner_api.py
+++ b/modules/market/housing_planner_api.py
@@ -6,7 +6,6 @@ from abc import ABC, abstractmethod
 from modules.household.dtos import HouseholdSnapshotDTO
 from modules.system.api import HousingMarketSnapshotDTO
 from modules.finance.api import MortgageApplicationDTO
-from modules.market.loan_api import MortgageApplicationRequestDTO
 
 class LoanMarketSnapshotDTO(TypedDict):
     """
@@ -34,7 +33,7 @@ class HousingDecisionDTO(TypedDict):
     decision_type: Literal["MAKE_OFFER", "RENT", "STAY"]
     target_property_id: Optional[int]
     offer_price: Optional[float]
-    mortgage_application: Optional[MortgageApplicationRequestDTO]
+    mortgage_application: Optional[MortgageApplicationDTO]
 
 class MortgageApprovalDTO(TypedDict):
     """
@@ -77,14 +76,14 @@ class ILoanMarket(ABC):
     Expanded interface for the LoanMarket to include regulatory checks.
     """
     @abstractmethod
-    def evaluate_mortgage_application(self, application: MortgageApplicationRequestDTO) -> bool:
+    def evaluate_mortgage_application(self, application: MortgageApplicationDTO) -> bool:
         """
         Performs hard LTV/DTI checks. Returns True if approved, False if rejected.
         """
         ...
 
     @abstractmethod
-    def stage_mortgage_application(self, application: MortgageApplicationRequestDTO) -> Optional[str]:
+    def stage_mortgage_application(self, application: MortgageApplicationDTO) -> Optional[str]:
          """
          Submits an application for asynchronous credit check.
          Returns a unique `staged_loan_id` for tracking, or None if invalid.
@@ -92,7 +91,7 @@ class ILoanMarket(ABC):
          ...
 
     @abstractmethod
-    def stage_mortgage(self, application: MortgageApplicationRequestDTO) -> Optional[dict]:
+    def stage_mortgage(self, application: MortgageApplicationDTO) -> Optional[dict]:
          """
          Stages a mortgage (creates loan record) without disbursing funds.
          Returns LoanInfoDTO (as dict) if successful, None otherwise.
diff --git a/modules/market/housing_purchase_api.py b/modules/market/housing_purchase_api.py
index 24b7d50..062b709 100644
--- a/modules/market/housing_purchase_api.py
+++ b/modules/market/housing_purchase_api.py
@@ -3,8 +3,7 @@ from abc import ABC, abstractmethod
 from modules.household.dtos import HouseholdStateDTO
 from modules.system.api import HousingMarketSnapshotDTO
 from modules.finance.api import LoanInfoDTO as LoanDTO
-from modules.market.housing_planner_api import MortgageApplicationDTO
-from modules.market.loan_api import MortgageApplicationRequestDTO
+from modules.finance.api import MortgageApplicationDTO
 
 # Pre-existing DTOs (Aliases if needed, or imported elsewhere)
 # from modules.market.housing_planner_api import HousingOfferRequestDTO, HousingDecisionDTO
@@ -18,7 +17,7 @@ class HousingPurchaseSagaDataDTO(TypedDict):
     property_id: int
     offer_price: float
     down_payment: float
-    mortgage_application: MortgageApplicationRequestDTO
+    mortgage_application: MortgageApplicationDTO
     # This will be populated once the loan is approved
     approved_loan_id: Optional[int]
     seller_id: int
@@ -50,7 +49,7 @@ class ILoanMarket(ABC):
     Interface for the LoanMarket, now including regulatory checks.
     """
     @abstractmethod
-    def apply_for_mortgage(self, application: MortgageApplicationRequestDTO) -> Optional[LoanDTO]:
+    def apply_for_mortgage(self, application: MortgageApplicationDTO) -> Optional[LoanDTO]:
         """
         Processes a mortgage application.
         - Enforces hard LTV/DTI limits from SimulationConfig.
@@ -59,7 +58,7 @@ class ILoanMarket(ABC):
         ...
 
     @abstractmethod
-    def evaluate_mortgage_application(self, application: MortgageApplicationRequestDTO) -> bool:
+    def evaluate_mortgage_application(self, application: MortgageApplicationDTO) -> bool:
         """
         Performs hard LTV/DTI checks. Returns True if approved, False if rejected.
         """
diff --git a/modules/market/loan_api.py b/modules/market/loan_api.py
index 9eb9e5b..6514769 100644
--- a/modules/market/loan_api.py
+++ b/modules/market/loan_api.py
@@ -1,21 +1,13 @@
 from typing import TypedDict, Optional, Any
 import logging
+from modules.finance.api import MortgageApplicationDTO
 
 logger = logging.getLogger(__name__)
 
-class MortgageApplicationRequestDTO(TypedDict):
-    """
-    [TD-206] A precise data contract for applying for a mortgage.
-    Sent by a saga or agent to the LoanMarket.
-    Explicitly requires existing monthly debt payments to resolve DTI calculation ambiguity.
-    """
-    applicant_id: int
-    requested_principal: float
-    property_id: int # Context for the loan (though loan is on agent, lien is on property)
-    property_value: float # For Loan-to-Value (LTV) calculation
-    applicant_monthly_income: float
-    existing_monthly_debt_payments: float # The SUM of all pre-existing monthly payments for other loans
-    loan_term: int # Optional, defaults to market standard if not provided, usually 360 ticks
+# [TD-223] Unification: Using MortgageApplicationDTO from finance.api
+# MortgageApplicationRequestDTO has been removed/aliased.
+# We aliasing it here to support step-by-step migration, but it should be deprecated.
+MortgageApplicationRequestDTO = MortgageApplicationDTO
 
 def calculate_monthly_loan_payment(principal: float, annual_interest_rate: float, term_months: float) -> float:
     """Calculates monthly payment using standard amortization formula."""
diff --git a/simulation/loan_market.py b/simulation/loan_market.py
index 2042a0d..ccd32a6 100644
--- a/simulation/loan_market.py
+++ b/simulation/loan_market.py
@@ -7,7 +7,7 @@ from modules.finance.api import IBankService, LoanNotFoundError, LoanRepaymentEr
 from modules.housing.dtos import MortgageApprovalDTO
 # Import from new API
 from modules.market.housing_planner_api import ILoanMarket
-from modules.market.loan_api import MortgageApplicationRequestDTO
+from modules.finance.api import MortgageApplicationDTO
 from modules.finance.api import LoanInfoDTO as LoanDTO
 
 if TYPE_CHECKING:
@@ -41,11 +41,11 @@ class LoanMarket(Market, ILoanMarket):
             },
         )
 
-    def evaluate_mortgage_application(self, application: MortgageApplicationRequestDTO) -> bool:
+    def evaluate_mortgage_application(self, application: MortgageApplicationDTO) -> bool:
         """
         Performs hard LTV/DTI checks. Returns True if approved, False if rejected.
         Implements ILoanMarket.evaluate_mortgage_application.
-        Uses [TD-206] MortgageApplicationRequestDTO for precise DTI calculation.
+        Uses [TD-206] MortgageApplicationDTO for precise DTI calculation.
         """
         # Canonical Keys from loan_api:
         # requested_principal, property_value, applicant_monthly_income, existing_monthly_debt_payments
@@ -123,14 +123,14 @@ class LoanMarket(Market, ILoanMarket):
 
         return True
 
-    def apply_for_mortgage(self, application: MortgageApplicationRequestDTO) -> Optional[LoanDTO]:
+    def apply_for_mortgage(self, application: MortgageApplicationDTO) -> Optional[LoanDTO]:
         """
         Processes a mortgage application with regulatory checks.
         Returns LoanInfoDTO if approved, None otherwise.
         """
         return self.stage_mortgage(application)
 
-    def stage_mortgage_application(self, application: MortgageApplicationRequestDTO) -> Optional[str]:
+    def stage_mortgage_application(self, application: MortgageApplicationDTO) -> Optional[str]:
         """
         Submits an application for asynchronous credit check.
         Returns a unique `staged_loan_id` for tracking, or None if invalid.
@@ -161,7 +161,7 @@ class LoanMarket(Market, ILoanMarket):
             return loan_info['loan_id']
         return None
 
-    def stage_mortgage(self, application: MortgageApplicationRequestDTO) -> Optional[LoanDTO]:
+    def stage_mortgage(self, application: MortgageApplicationDTO) -> Optional[LoanDTO]:
         """
         Legacy/Compat method.
         Stages a mortgage (creates loan record) without disbursing funds.
@@ -204,7 +204,7 @@ class LoanMarket(Market, ILoanMarket):
              return True
         return False
 
-    def request_mortgage(self, application: MortgageApplicationRequestDTO, household_agent: Any = None, current_tick: int = 0) -> Optional[MortgageApprovalDTO]:
+    def request_mortgage(self, application: MortgageApplicationDTO, household_agent: Any = None, current_tick: int = 0) -> Optional[MortgageApprovalDTO]:
         """
         Legacy/Compat method.
         Calls evaluate, then Bank.grant_loan (Full execution).
diff --git a/simulation/systems/housing_system.py b/simulation/systems/housing_system.py
index 11a7092..66b60f9 100644
--- a/simulation/systems/housing_system.py
+++ b/simulation/systems/housing_system.py
@@ -9,10 +9,9 @@ from modules.housing.dtos import (
 )
 from modules.market.housing_purchase_api import (
     HousingPurchaseSagaDTO,
-    HousingPurchaseSagaDataDTO,
-    MortgageApplicationDTO
+    HousingPurchaseSagaDataDTO
 )
-from modules.market.loan_api import MortgageApplicationRequestDTO
+from modules.finance.api import MortgageApplicationDTO
 from modules.system.api import DEFAULT_CURRENCY
 
 
@@ -214,10 +213,11 @@ class HousingSystem:
         else:
              loan_term = getattr(housing_config, 'mortgage_term_ticks', 300)
 
-        # [TD-206] Use MortgageApplicationRequestDTO
-        mortgage_app = MortgageApplicationRequestDTO(
+        # [TD-206] Use MortgageApplicationDTO
+        mortgage_app = MortgageApplicationDTO(
             applicant_id=buyer_id,
             requested_principal=principal,
+            purpose="MORTGAGE", # Required by DTO
             property_id=prop_id,
             property_value=offer_price,
             applicant_monthly_income=annual_income / 12.0, # Convert annual to monthly
diff --git a/tests/conftest.py b/tests/conftest.py
index e211335..d9daffe 100644
--- a/tests/conftest.py
+++ b/tests/conftest.py
@@ -2,8 +2,6 @@ import pytest
 from unittest.mock import Mock, MagicMock
 from simulation.agents.government import Government
 from modules.finance.system import FinanceSystem
-# from simulation.agents.central_bank import CentralBank # Removed to avoid numpy import
-# from simulation.bank import Bank # Removed to avoid extra imports
 
 @pytest.fixture
 def mock_config():
@@ -47,14 +45,14 @@ def mock_central_bank(mock_tracker, mock_config):
     """Provides a mock CentralBank."""
     # Using a real instance might be better if its logic is simple
     # but for now, a mock is sufficient.
-    cb = Mock() # spec=CentralBank removed to avoid numpy import
+    cb = Mock()
     cb.get_base_rate.return_value = 0.02
     return cb
 
 @pytest.fixture
 def mock_bank():
     """Provides a mock commercial Bank."""
-    bank = Mock() # spec=Bank removed
+    bank = Mock()
     bank._assets = 5000000.0
     return bank
 
diff --git a/tests/unit/markets/test_loan_market_mortgage.py b/tests/unit/markets/test_loan_market_mortgage.py
index b8c10dd..9f77727 100644
--- a/tests/unit/markets/test_loan_market_mortgage.py
+++ b/tests/unit/markets/test_loan_market_mortgage.py
@@ -4,7 +4,7 @@ from typing import Any
 
 from simulation.loan_market import LoanMarket
 from simulation.bank import Bank
-from modules.market.loan_api import MortgageApplicationRequestDTO
+from modules.finance.api import MortgageApplicationDTO
 from modules.finance.api import LoanInfoDTO
 
 class TestLoanMarketMortgage:
@@ -37,9 +37,10 @@ class TestLoanMarketMortgage:
             )
 
     def test_evaluate_mortgage_success(self, loan_market):
-        app = MortgageApplicationRequestDTO(
+        app = MortgageApplicationDTO(
             applicant_id=1,
             requested_principal=80000.0,
+            purpose="MORTGAGE",
             property_id=100,
             property_value=100000.0,
             applicant_monthly_income=5000.0, # 60k annual
@@ -49,9 +50,10 @@ class TestLoanMarketMortgage:
         assert loan_market.evaluate_mortgage_application(app) is True
 
     def test_evaluate_mortgage_fail_ltv(self, loan_market):
-        app = MortgageApplicationRequestDTO(
+        app = MortgageApplicationDTO(
             applicant_id=1,
             requested_principal=90000.0, # 90% LTV
+            purpose="MORTGAGE",
             property_id=100,
             property_value=100000.0,
             applicant_monthly_income=20000.0, # High income, so DTI is fine
@@ -72,9 +74,10 @@ class TestLoanMarketMortgage:
         # Principal 100,000. Pmt ~536.
         # Income 1000. DTI ~0.53 > 0.43. Fail.
 
-        app = MortgageApplicationRequestDTO(
+        app = MortgageApplicationDTO(
             applicant_id=1,
             requested_principal=100000.0,
+            purpose="MORTGAGE",
             property_id=100,
             property_value=200000.0, # LTV 50% OK
             applicant_monthly_income=1000.0,
@@ -89,9 +92,10 @@ class TestLoanMarketMortgage:
         # Existing Debt Pmt 200.
         # Total 468. Ratio 0.468 > 0.43. Fail.
 
-        app = MortgageApplicationRequestDTO(
+        app = MortgageApplicationDTO(
             applicant_id=1,
             requested_principal=50000.0,
+            purpose="MORTGAGE",
             property_id=100,
             property_value=200000.0,
             applicant_monthly_income=1000.0,
@@ -101,9 +105,10 @@ class TestLoanMarketMortgage:
         assert loan_market.evaluate_mortgage_application(app) is False
 
     def test_stage_mortgage_success(self, loan_market, mock_bank):
-        app = MortgageApplicationRequestDTO(
+        app = MortgageApplicationDTO(
             applicant_id=1,
             requested_principal=80000.0,
+            purpose="MORTGAGE",
             property_id=100,
             property_value=100000.0,
             applicant_monthly_income=5000.0,
@@ -134,9 +139,10 @@ class TestLoanMarketMortgage:
         mock_bank.stage_loan.assert_called_once()
 
     def test_stage_mortgage_fail_eval(self, loan_market, mock_bank):
-        app = MortgageApplicationRequestDTO(
+        app = MortgageApplicationDTO(
             applicant_id=1,
             requested_principal=90000.0, # LTV Fail
+            purpose="MORTGAGE",
             property_id=100,
             property_value=100000.0,
             applicant_monthly_income=5000.0,
diff --git a/tests/unit/systems/test_settlement_saga_integration.py b/tests/unit/systems/test_settlement_saga_integration.py
new file mode 100644
index 0000000..85d407c
--- /dev/null
+++ b/tests/unit/systems/test_settlement_saga_integration.py
@@ -0,0 +1,127 @@
+import pytest
+from unittest.mock import MagicMock
+from simulation.systems.settlement_system import SettlementSystem
+from modules.finance.saga_handler import HousingTransactionSagaHandler
+
+class TestSettlementSagaIntegration:
+    @pytest.fixture
+    def mock_simulation_state(self):
+        sim = MagicMock()
+        # Mock Simulation Dependencies
+        sim.settlement_system = MagicMock()
+        sim.housing_service = MagicMock()
+        sim.markets = {"loan": MagicMock()}
+        sim.agents = {}
+        sim.time = 100
+        sim.config_module = MagicMock()
+        sim.config_module.TICKS_PER_YEAR = 100
+        sim.bank = MagicMock()
+        return sim
+
+    def test_process_sagas_integration_initiated_to_credit_check(self, mock_simulation_state):
+        """
+        Tests that SettlementSystem correctly orchestrates the Real HousingTransactionSagaHandler
+        to transition a saga from INITIATED to CREDIT_CHECK.
+        """
+        # 1. Setup Settlement System
+        settlement = SettlementSystem()
+
+        # Wire up circular dependency (Handler needs access to SettlementSystem)
+        mock_simulation_state.settlement_system = settlement
+
+        # 2. Setup a Saga
+        saga_id = "saga-integration-1"
+        saga = {
+            "saga_id": saga_id,
+            "saga_type": "HOUSING_TRANSACTION",
+            "status": "INITIATED",
+            "current_step": 0,
+            "buyer_id": 1,
+            "seller_id": 2,
+            "property_id": 101,
+            "offer_price": 100000.0,
+            "down_payment_amount": 20000.0,
+            "last_processed_tick": 99 # To ensure it processes
+        }
+        settlement.submit_saga(saga)
+
+        # 3. Setup Dependencies for Handler
+        # Mock agents
+        buyer = MagicMock()
+        buyer.is_active = True
+        buyer.current_wage = 100.0
+
+        seller = MagicMock()
+        seller.is_active = True
+
+        mock_simulation_state.agents = {1: buyer, 2: seller}
+
+        # Mock Housing Service
+        mock_simulation_state.housing_service.set_under_contract.return_value = True
+
+        # Mock Loan Market
+        mock_simulation_state.markets["loan"].stage_mortgage_application.return_value = "loan_staged_1"
+
+        # Mock Bank (for debt calculation)
+        mock_simulation_state.bank.get_debt_status.return_value = {'loans': []}
+
+        # 4. Run
+        settlement.process_sagas(mock_simulation_state)
+
+        # 5. Verify Saga Transition
+        assert saga_id in settlement.active_sagas
+        updated_saga = settlement.active_sagas[saga_id]
+
+        # Should transition to CREDIT_CHECK
+        assert updated_saga["status"] == "CREDIT_CHECK"
+        assert updated_saga["staged_loan_id"] == "loan_staged_1"
+        assert updated_saga["last_processed_tick"] == 100
+
+        # Verify side effects
+        mock_simulation_state.housing_service.set_under_contract.assert_called_with(101, saga_id)
+        mock_simulation_state.markets["loan"].stage_mortgage_application.assert_called_once()
+
+    def test_process_sagas_integration_cancellation(self, mock_simulation_state):
+        """
+        Tests that if a participant is inactive, SettlementSystem cancels the saga
+        and triggers compensation (using the real handler's compensate logic).
+        """
+        # 1. Setup Settlement System
+        settlement = SettlementSystem()
+        mock_simulation_state.settlement_system = settlement
+
+        # 2. Setup a Saga (in CREDIT_CHECK state)
+        saga_id = "saga-integration-cancel"
+        saga = {
+            "saga_id": saga_id,
+            "status": "CREDIT_CHECK",
+            "buyer_id": 1,
+            "seller_id": 2,
+            "property_id": 101,
+            "staged_loan_id": "loan_staged_x",
+            "last_processed_tick": 99
+        }
+        settlement.submit_saga(saga)
+
+        # 3. Setup Dependencies
+        # Buyer is DEAD/Inactive
+        buyer = MagicMock()
+        buyer.is_active = False
+
+        seller = MagicMock()
+        seller.is_active = True
+
+        mock_simulation_state.agents = {1: buyer, 2: seller}
+
+        # Mock Loan Market for voiding
+        mock_simulation_state.markets["loan"].void_staged_application.return_value = True
+
+        # 4. Run
+        settlement.process_sagas(mock_simulation_state)
+
+        # 5. Verify Cancellation
+        # Saga should be removed from active_sagas
+        assert saga_id not in settlement.active_sagas
+
+        # Check logs/mock calls to verify compensation was attempted
+        mock_simulation_state.markets["loan"].void_staged_application.assert_called_with("loan_staged_x")
