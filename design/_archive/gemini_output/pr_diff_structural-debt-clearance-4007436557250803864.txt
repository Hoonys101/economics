diff --git a/PROJECT_STATUS.md b/PROJECT_STATUS.md
index 7e087225..f82873b2 100644
--- a/PROJECT_STATUS.md
+++ b/PROJECT_STATUS.md
@@ -84,4 +84,9 @@
 
 ## 5. Technical Debt Management
 
-Technical debt is now managed via the [Technical Debt Ledger](./design/2_operations/ledgers/TECH_DEBT_LEDGER.md). Phase 4 established critical new debts (TD-226~229) focused on government module decoupling.
\ No newline at end of file
+Technical debt is now managed via the [Technical Debt Ledger](./design/2_operations/ledgers/TECH_DEBT_LEDGER.md). Phase 4 established critical new debts (TD-226~229) focused on government module decoupling.
+
+**Recent Clearance (Track 3)**:
+- **TD-254**: Hardened `SettlementSystem` against abstraction leaks (removed `hasattr`).
+- **TD-035**: Generalized Political AI parameters to `economy_params.yaml`.
+- **TD-188**: Audited and synced configuration documentation.
\ No newline at end of file
diff --git a/communications/insights/structural_debt_clearance.md b/communications/insights/structural_debt_clearance.md
new file mode 100644
index 00000000..7415028e
--- /dev/null
+++ b/communications/insights/structural_debt_clearance.md
@@ -0,0 +1,47 @@
+# Insight Report: Structural Debt Clearance (Track 3)
+
+## 1. Problem Phenomenon
+The `SettlementSystem`â€”the financial backbone of the simulationâ€”was exhibiting signs of "Abstraction Leakage" (TD-254). Specifically:
+- **Brittle Duck Typing**: The code relied on `hasattr(agent, 'id')`, `hasattr(agent, 'agent_type')`, and string matching (`str(recipient.id).upper() == "GOVERNMENT"`) to identify transaction participants.
+- **Runtime Risk**: These loose checks meant that if an agent class was refactored or a mock object in tests didn't exactly match the ad-hoc schema, the system would fail silently (logging an error but not halting) or crash unexpectedly.
+- **Maintenance Overhead**: Every time a new agent type was introduced (e.g., a new Mock for testing), `SettlementSystem` logic had to be inspected or patched to accommodate it.
+
+Additionally, the `AdaptiveGovPolicy` (TD-035) contained **Hardcoded Heuristics**:
+- Magic numbers for tax limits (`0.05`, `0.6`) and welfare multipliers (`0.1`, `2.0`) were buried in the code.
+- This made economic tuning impossible without code deployment, violating the "Configurable Economy" principle.
+
+## 2. Root Cause Analysis
+- **Rapid Prototyping Legacy**: The `hasattr` checks were likely introduced during early development to support heterogeneous objects (dictionaries vs. classes) without defining formal interfaces.
+- **Lack of Protocol Enforcement**: While protocols like `IFinancialEntity` existed, they were not strictly enforced or `runtime_checkable`, leading developers to fall back on Python's dynamic nature excessively.
+- **Missing Configuration Abstraction**: The `AdaptiveGovPolicy` was implemented with "sensible defaults" hardcoded to speed up Phase 4 delivery, deferring parameterization to a later phase (which is now).
+
+## 3. Solution Implementation Details
+
+### A. Settlement System Hardening (TD-254)
+We transitioned `SettlementSystem` from ad-hoc duck typing to strict Protocol-based polymorphism:
+1.  **Protocol Upgrades**: Added `@runtime_checkable` to `IGovernment` and `ICentralBank` in `modules/simulation/api.py`.
+2.  **Strict Typing**:
+    - Replaced `hasattr(recipient, 'agent_type') ...` with `isinstance(recipient, IGovernment)`.
+    - Replaced `hasattr(agent, 'id')` with direct `agent.id` access, asserting that all participants must adhere to `IFinancialEntity`.
+    - Replaced custom Central Bank detection with `isinstance(agent, ICentralBank)` or strict ID constant checks.
+3.  **Test Updates**: Updated unit tests (`test_settlement_system.py`) to use `MockGovernment` objects that properly implement the `IGovernment` protocol, ensuring tests validate the contract, not just the implementation quirks.
+
+### B. Political AI Generalization (TD-035)
+We externalized policy bounds to the configuration system:
+1.  **Config Schema**: Added `adaptive_policy` section to `config/economy_params.yaml` defining `welfare_bounds` and `tax_bounds`.
+2.  **Code Adaptation**: Refactored `AdaptiveGovPolicy._execute_action` to fetch these bounds dynamically from the config object, with safe fallbacks to the original defaults if the config is missing.
+
+### C. Documentation Sync (TD-188)
+- Audited `PROJECT_STATUS.md` and `TECH_DEBT_LEDGER.md`.
+- Updated `TECH_DEBT_LEDGER.md` to mark TD-254, TD-035, and TD-188 as RESOLVED.
+- Added a summary of these clearances to `PROJECT_STATUS.md`.
+
+## 4. Lessons Learned & Technical Debt Identified
+
+### Lessons Learned
+- **Protocols over Attributes**: Using `@runtime_checkable` Protocols is a powerful way to enforce architectural boundaries in Python without inheriting from a monolithic base class. It allows for flexible but safe polymorphism.
+- **Config-First Design**: Hardcoding parameters "for now" almost always results in technical debt. Defining a config schema early saves time during tuning phases.
+
+### Remaining/New Technical Debt
+- **Mock Fragility**: The need to update `MockAgent` to `MockGovernment` highlights that our test mocks are manually constructed. A Factory or Builder pattern for test doubles could reduce this friction (Potential TD Item).
+- **Config Access Pattern**: The `self.config` object in policies has an ambiguous structure (sometimes dict, sometimes object). Standardizing this access pattern (e.g., a typed `ConfigWrapper`) would prevent future "try/except" blocks for config reading.
diff --git a/config/economy_params.yaml b/config/economy_params.yaml
index 48c10e91..c69608f6 100644
--- a/config/economy_params.yaml
+++ b/config/economy_params.yaml
@@ -120,3 +120,10 @@ demographics:
   fallback_survival_cost: 10.0
 ai_housing:
   housing_annual_maintenance_rate: 0.01
+
+# ----------------------------------------------------------------------
+# Adaptive Gov Policy (TD-035)
+# ----------------------------------------------------------------------
+adaptive_policy:
+  welfare_bounds: [0.1, 2.0]
+  tax_bounds: [0.05, 0.6]
diff --git a/design/2_operations/ledgers/TECH_DEBT_LEDGER.md b/design/2_operations/ledgers/TECH_DEBT_LEDGER.md
index b5b6eb00..af9f30c1 100644
--- a/design/2_operations/ledgers/TECH_DEBT_LEDGER.md
+++ b/design/2_operations/ledgers/TECH_DEBT_LEDGER.md
@@ -19,7 +19,7 @@
 
 | ID | Date | Description | Impact | Status |
 |---|---|---|---|---|
-| TD-035 | 2026-02-06 | Hardcoded Political AI Heuristics | Model Inflexibility / Magic Numbers | [Parity Audit](../../3_work_artifacts/reports/inbound/parity-wo-6-audit-10828950733294323302_audit_parity_WO-6-AUDIT.md) | **ACTIVE** |
+| (No Active Items) | | | | | |
 
 ## ðŸ’¹ 4. MARKETS & ECONOMICS
 
@@ -35,7 +35,7 @@
 |---|---|---|---|---|---|
 | (No Active Items) | | | | | |
 | TD-253 | 2026-02-06 | SettlementSystem God Class (785 lines) | High Coupling / Maintenance Risk | [Structural Audit](../../3_work_artifacts/reports/inbound/structural-god-class-check-2584000745385775058_audit_structural_001.md) | **HIGH** |
-| TD-254 | 2026-02-06 | Settlement Abstraction Leak (hasattr) | Violation of Open/Closed Principle | [Structural Audit](../../3_work_artifacts/reports/inbound/structural-god-class-check-2584000745385775058_audit_structural_001.md) | **HIGH** |
+| (No Active Items) | | | | | |
 | TD-255 | 2026-02-06 | Housing Saga DTO Purity Breach | Raw Agent Mutation Leaks | [Structural Audit](../../3_work_artifacts/reports/inbound/structural-god-class-check-2584000745385775058_audit_structural_001.md) | **MEDIUM** |
 | TD-256 | 2026-02-06 | Lack of Inventory Abstraction (Direct Mutation) | Goods Transfer Atomicity Risks | [Economic Audit](../../3_work_artifacts/reports/inbound/economic-jules-001-12984982393375704591_audit_economic_JULES_001.md) | **MEDIUM** |
 | TD-258 | 2026-02-06 | Manual Transaction Injection in Saga | Bypass of Transaction Pipeline | [Review](../../_archive/gemini_output/pr_review_pulse-integrity-fix-5507545585466336807.md) | **LOW** |
@@ -59,7 +59,7 @@
 | ID | Date | Description | Impact | Refs | Status |
 |---|---|---|---|---|---|
 | (No Active Items) | | | | | |
-| TD-188 | 2026-02-04 | Config Path Doc Drift | `PROJECT_STATUS.md` stale | **ACTIVE** |
+| (No Active Items) | | | | | |
 | (No Active Items) | | | | | |
 | (No Active Items) | | | | | |
 | (No Active Items) | | | | | |
@@ -87,6 +87,10 @@
 | TD-193 | 2026-02-04 | Fragmented Politics Sync | [Spec](../../3_work_artifacts/specs/WO-4.5_Adaptive_Brain.md) | - |
 | TD-238 | 2026-02-05 | Phases.py Decomposition | [Structural Audit](../../3_work_artifacts/reports/inbound/structural-structural-001-15007860028193717728_audit_structural_STRUCTURAL-001.md) | [Insight](../../communications/insights/Bundle_C_System_Integrity.md) |
 
+| TD-035 | 2026-02-06 | Hardcoded Political AI Heuristics | [Spec](../../config/economy_params.yaml) | [Insight](../../communications/insights/structural_debt_clearance.md) |
+| TD-254 | 2026-02-06 | Settlement Abstraction Leak (hasattr) | - | [Insight](../../communications/insights/structural_debt_clearance.md) |
+| TD-188 | 2026-02-06 | Config Path Doc Drift | - | [Insight](../../communications/insights/structural_debt_clearance.md) |
+
 | TD-250 | 2026-02-06 | Sales Tax & Inheritance Atomicity | [Audit](../../3_work_artifacts/reports/inbound/economic-jules-001-12984982393375704591_audit_economic_JULES_001.md) | [Insight](../../communications/insights/mission_report_economic_integrity.md) |
 | TD-015 | 2026-02-05 | Divergent Metric Calculation (M0/M1/M2) | [Review](../../_archive/gemini_output/pr_review_watchtower-backend-6136124806422059806.md) | [Insight](../../communications/insights/PH6_STABILIZATION_REPORT.md) |
 | TD-125 | 2026-02-05 | Watchtower Backend Refactor (DTO Sync) | [Review](../../_archive/gemini_output/pr_review_watchtower-backend-6136124806422059806.md) | [Insight](../../communications/insights/PH6_STABILIZATION_REPORT.md) |
diff --git a/modules/simulation/api.py b/modules/simulation/api.py
index 165d8257..11ffa936 100644
--- a/modules/simulation/api.py
+++ b/modules/simulation/api.py
@@ -1,6 +1,6 @@
 from __future__ import annotations
 from dataclasses import dataclass
-from typing import Protocol, TypedDict, Any, List, Dict, TYPE_CHECKING
+from typing import Protocol, TypedDict, Any, List, Dict, TYPE_CHECKING, runtime_checkable
 
 if TYPE_CHECKING:
     from simulation.finance.api import ISettlementSystem
@@ -50,9 +50,11 @@ class IFirm(IAgent, Protocol):
 class IHousehold(IAgent, Protocol):
     inventory: Dict[str, float]
 
+@runtime_checkable
 class ICentralBank(Protocol):
     base_rate: float
 
+@runtime_checkable
 class IGovernment(Protocol):
     expenditure_this_tick: float
     revenue_this_tick: float
diff --git a/simulation/policies/adaptive_gov_policy.py b/simulation/policies/adaptive_gov_policy.py
index 8efc7bfe..03b2b624 100644
--- a/simulation/policies/adaptive_gov_policy.py
+++ b/simulation/policies/adaptive_gov_policy.py
@@ -65,21 +65,44 @@ class AdaptiveGovPolicy(IGovernmentPolicy):
          # Action Interpretation
          # action.action_type, action.params
 
+         # TD-035: Generalized bounds from config
+         welfare_min, welfare_max = 0.1, 2.0
+         tax_min, tax_max = 0.05, 0.6
+
+         # Try to resolve bounds from config
+         try:
+             # Check for object-style access (most likely based on codebase patterns)
+             if hasattr(self.config, 'adaptive_policy'):
+                 ap = self.config.adaptive_policy
+                 if isinstance(ap, dict):
+                     welfare_min, welfare_max = ap.get('welfare_bounds', [0.1, 2.0])
+                     tax_min, tax_max = ap.get('tax_bounds', [0.05, 0.6])
+                 else:
+                     welfare_min, welfare_max = getattr(ap, 'welfare_bounds', [0.1, 2.0])
+                     tax_min, tax_max = getattr(ap, 'tax_bounds', [0.05, 0.6])
+             # Check for dict-style access
+             elif isinstance(self.config, dict) and 'adaptive_policy' in self.config:
+                 ap = self.config['adaptive_policy']
+                 welfare_min, welfare_max = ap.get('welfare_bounds', [0.1, 2.0])
+                 tax_min, tax_max = ap.get('tax_bounds', [0.05, 0.6])
+         except Exception as e:
+             logger.warning(f"Failed to load adaptive policy bounds from config: {e}. Using defaults.")
+
          if action.action_type == "ADJUST_WELFARE":
              delta = action.params.get("multiplier_delta", 0.0)
              government.welfare_budget_multiplier += delta
              # Clamp
-             government.welfare_budget_multiplier = max(0.1, min(2.0, government.welfare_budget_multiplier))
+             government.welfare_budget_multiplier = max(welfare_min, min(welfare_max, government.welfare_budget_multiplier))
 
          elif action.action_type == "ADJUST_CORP_TAX":
              delta = action.params.get("rate_delta", 0.0)
              government.corporate_tax_rate += delta
-             government.corporate_tax_rate = max(0.05, min(0.6, government.corporate_tax_rate))
+             government.corporate_tax_rate = max(tax_min, min(tax_max, government.corporate_tax_rate))
 
          elif action.action_type == "ADJUST_INCOME_TAX":
              delta = action.params.get("rate_delta", 0.0)
              government.income_tax_rate += delta
-             government.income_tax_rate = max(0.05, min(0.6, government.income_tax_rate))
+             government.income_tax_rate = max(tax_min, min(tax_max, government.income_tax_rate))
 
          elif action.action_type == "FIRE_ADVISOR":
              # For now, default to firing the Keynesian advisor as they advocate for spending/intervention
diff --git a/simulation/systems/settlement_system.py b/simulation/systems/settlement_system.py
index b246e5cd..fe9d910f 100644
--- a/simulation/systems/settlement_system.py
+++ b/simulation/systems/settlement_system.py
@@ -12,6 +12,7 @@ from modules.system.api import DEFAULT_CURRENCY, CurrencyCode, ICurrencyHolder
 from modules.system.constants import ID_CENTRAL_BANK
 from modules.market.housing_planner_api import MortgageApplicationDTO
 from simulation.models import Transaction
+from modules.simulation.api import IGovernment, ICentralBank
 
 if TYPE_CHECKING:
     from simulation.firms import Firm
@@ -121,16 +122,14 @@ class SettlementSystem(ISettlementSystem):
             for recipient, _, _, _ in distribution_plan:
                 # Check for Government (Escheatment)
                 if account.is_escheatment:
-                    # Heuristic: Check for Government class or ID
-                    if (hasattr(recipient, 'agent_type') and recipient.agent_type == 'government') or \
-                       (hasattr(recipient, 'id') and str(recipient.id).upper() == "GOVERNMENT") or \
-                       (recipient.__class__.__name__ == "Government"):
+                    # Heuristic: Check for Government protocol
+                    if isinstance(recipient, IGovernment):
                         recipient_candidate = recipient
                         break
 
                 # Check for Heir
                 else:
-                    if hasattr(recipient, 'id') and recipient.id == account.heir_id:
+                    if recipient.id == account.heir_id:
                         recipient_candidate = recipient
                         break
 
@@ -171,7 +170,7 @@ class SettlementSystem(ISettlementSystem):
 
                 # Create Receipt
                 tx = self._create_transaction_record(
-                    buyer_id=recipient.id if hasattr(recipient, 'id') else 0, # Recipient
+                    buyer_id=recipient.id, # Recipient
                     seller_id=account.deceased_agent_id, # Deceased
                     amount=amount,
                     memo=memo,
@@ -265,7 +264,7 @@ class SettlementSystem(ISettlementSystem):
 
         self.total_liquidation_losses += loss_amount
 
-        agent_id = agent.id if hasattr(agent, 'id') else "UNKNOWN"
+        agent_id = agent.id
         self.logger.info(
             f"LIQUIDATION: Agent {agent_id} liquidated. "
             f"Inventory: {inventory_value:.2f}, Capital: {capital_value:.2f}, Recovered: {recovered_cash:.2f}. "
@@ -299,11 +298,7 @@ class SettlementSystem(ISettlementSystem):
             self.logger.error(f"SETTLEMENT_FAIL | Debit agent is None. Memo: {memo}")
             return False
 
-        is_central_bank = False
-        if hasattr(agent, "id") and agent.id == ID_CENTRAL_BANK:
-             is_central_bank = True
-        elif hasattr(agent, "__class__") and agent.__class__.__name__ == "CentralBank":
-             is_central_bank = True
+        is_central_bank = isinstance(agent, ICentralBank) or (agent.id == ID_CENTRAL_BANK)
 
         if is_central_bank:
              try:
@@ -320,18 +315,15 @@ class SettlementSystem(ISettlementSystem):
         elif isinstance(agent, ICurrencyHolder):
             current_cash = agent.get_assets_by_currency().get(currency, 0.0)
         else:
-            # Attempt Duck Typing for legacy/mock support if ICurrencyHolder not explicitly inherited
-            if hasattr(agent, 'get_assets_by_currency'):
-                 current_cash = agent.get_assets_by_currency().get(currency, 0.0)
-            elif hasattr(agent, 'assets') and isinstance(agent.assets, dict):
-                 current_cash = agent.assets.get(currency, 0.0)
+            # Fallback for strict mode
+            pass
 
         if current_cash < amount:
             # Seamless Check (Only for DEFAULT_CURRENCY for now, assume Bank uses DEFAULT_CURRENCY)
             if self.bank and currency == DEFAULT_CURRENCY:
                 needed_from_bank = amount - current_cash
                 # Bank balance check using str(agent.id)
-                agent_id_str = str(agent.id) if hasattr(agent, 'id') else "0"
+                agent_id_str = str(agent.id)
                 bank_balance = self.bank.get_balance(agent_id_str)
 
                 if (current_cash + bank_balance) < amount:
@@ -413,8 +405,8 @@ class SettlementSystem(ISettlementSystem):
             if tx:
                 completed_transfers.append((debit, credit, amount))
             else:
-                d_id = debit.id if hasattr(debit,'id') else '?'
-                c_id = credit.id if hasattr(credit,'id') else '?'
+                d_id = debit.id
+                c_id = credit.id
                 self.logger.warning(
                     f"MULTIPARTY_FAIL | Transfer {i} failed ({d_id} -> {c_id}). Rolling back {len(completed_transfers)} previous transfers."
                 )
@@ -424,8 +416,8 @@ class SettlementSystem(ISettlementSystem):
                     # Reverse: r_credit pays back r_debit
                     rb_tx = self.transfer(r_credit, r_debit, r_amount, f"rollback_multiparty_{i}", tick=tick)
                     if not rb_tx:
-                         rc_id = r_credit.id if hasattr(r_credit,'id') else '?'
-                         rd_id = r_debit.id if hasattr(r_debit,'id') else '?'
+                         rc_id = r_credit.id
+                         rd_id = r_debit.id
                          self.logger.critical(
                              f"MULTIPARTY_FATAL | Rollback failed for {r_amount} from {rc_id} to {rd_id}."
                          )
@@ -514,8 +506,8 @@ class SettlementSystem(ISettlementSystem):
             self.logger.warning(f"Transfer of non-positive amount ({amount}) attempted. Memo: {memo}")
             # Consider this a success logic-wise (no-op) but log it.
             return self._create_transaction_record(
-                debit_agent.id if hasattr(debit_agent, 'id') else 0,
-                credit_agent.id if hasattr(credit_agent, 'id') else 0,
+                debit_agent.id,
+                credit_agent.id,
                 amount, memo, tick
             )
 
@@ -587,11 +579,7 @@ class SettlementSystem(ISettlementSystem):
         if amount <= 0:
             return None
 
-        is_central_bank = False
-        if hasattr(source_authority, "__class__") and source_authority.__class__.__name__ == "CentralBank":
-            is_central_bank = True
-        elif hasattr(source_authority, "id") and source_authority.id == ID_CENTRAL_BANK:
-            is_central_bank = True
+        is_central_bank = isinstance(source_authority, ICentralBank) or (source_authority.id == ID_CENTRAL_BANK)
 
         if is_central_bank:
             # Minting logic: Just credit destination. Source (CB) is assumed to have infinite capacity.
@@ -630,11 +618,7 @@ class SettlementSystem(ISettlementSystem):
         if amount <= 0:
             return None
 
-        is_central_bank = False
-        if hasattr(sink_authority, "__class__") and sink_authority.__class__.__name__ == "CentralBank":
-            is_central_bank = True
-        elif hasattr(sink_authority, "id") and sink_authority.id == ID_CENTRAL_BANK:
-            is_central_bank = True
+        is_central_bank = isinstance(sink_authority, ICentralBank) or (sink_authority.id == ID_CENTRAL_BANK)
 
         if is_central_bank:
             # Burning logic: Just debit source. Sink (CB) absorbs it (removed from circulation).
diff --git a/tests/unit/systems/test_settlement_system.py b/tests/unit/systems/test_settlement_system.py
index 55830fcc..94ebc407 100644
--- a/tests/unit/systems/test_settlement_system.py
+++ b/tests/unit/systems/test_settlement_system.py
@@ -402,8 +402,15 @@ def test_escheatment_portfolio_transfer(settlement_system):
     deceased = MockAgent(100, 0.0, heir_id=None) # No heir
     deceased.portfolio.assets.append(PortfolioAsset(asset_type="bond", asset_id="GOV_TEST", quantity=5))
 
-    gov = MockAgent("GOVERNMENT", 0.0)
-    # MockAgent doesn't have agent_type="government", but id="GOVERNMENT" matches heuristic in settlement_system.py
+    # Mock Government with required IGovernment fields
+    class MockGovernment(MockAgent):
+        def __init__(self, agent_id, assets=0.0):
+            super().__init__(agent_id, assets)
+            self.expenditure_this_tick = 0.0
+            self.revenue_this_tick = 0.0
+            self.total_debt = 0.0
+
+    gov = MockGovernment("GOVERNMENT", 0.0)
 
     # 1. Create
     account = settlement_system.create_settlement(deceased, 1)
