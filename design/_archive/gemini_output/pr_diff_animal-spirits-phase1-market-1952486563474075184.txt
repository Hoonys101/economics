diff --git a/communications/insights/SPEC_ANIMAL_PHASE1_MARKET.md b/communications/insights/SPEC_ANIMAL_PHASE1_MARKET.md
new file mode 100644
index 0000000..34739c5
--- /dev/null
+++ b/communications/insights/SPEC_ANIMAL_PHASE1_MARKET.md
@@ -0,0 +1,36 @@
+# Insight Report: Phase 1 - Market Infrastructure & Signals
+
+**ID**: `SPEC_ANIMAL_PHASE1_MARKET`
+**Date**: 2026-05-22
+**Author**: Jules (AI Agent)
+**Status**: **ACTIVE** (Breaking Changes Introduced)
+
+## 1. Context
+This report documents the architectural shift and technical debt introduced during Phase 1 of the 'Animal Spirits' initiative. The goal was to establish clean, reliable market signals by introducing a `MarketSignalObserver` and redefining the `MarketSnapshotDTO`.
+
+## 2. Technical Debt Introduced (Intentional)
+
+### 2.1. Breaking Change: `MarketSnapshotDTO`
+- **What**: The `MarketSnapshotDTO` has been converted from a `@dataclass` (containing `prices`, `volumes`, etc.) to a `TypedDict` (containing `market_signals` and legacy `market_data`).
+- **Impact**: This change **invalidates all existing agent decision engines** that rely on the old `MarketSnapshotDTO` structure (e.g., `agent.make_decision(market_snapshot=...)`).
+- **Remediation**: All agent decision logic must be updated to parse the new `market_signals` structure. This is scheduled for subsequent implementation phases.
+
+### 2.2. Golden Fixture Invalidation
+- **What**: The relaxation of the circuit breaker mechanism (`get_dynamic_price_bounds` returning infinite bounds for sparse history) alters the fundamental price discovery dynamics at the start of the simulation.
+- **Impact**: **All existing economic outcome tests and golden fixtures are invalid.** They rely on the previous, stricter circuit breaker logic.
+- **Remediation**: A dedicated task must be created to perform a full review and regeneration of all golden fixtures using `scripts/fixture_harvester.py` after the full feature set is implemented.
+
+## 3. Architectural Insights
+
+### 3.1. System-Level Observation
+- The introduction of `MarketSignalObserver` (DTOs implemented) represents a shift towards a "System Observer" pattern.
+- **Lesson**: Isolating signal calculation prevents circular dependencies and ensures data purity for agents. Agents now consume pre-calculated signals rather than raw market state.
+
+### 3.2. Configuration Dependency
+- `OrderBookMarket` now relies on `config_module.CIRCUIT_BREAKER_MIN_HISTORY`.
+- **Insight**: This dependency on the global config module within the market entity suggests a need for stricter configuration injection or a dedicated `MarketConfigDTO` to avoid tight coupling with the monolithic config.
+
+## 4. Verification Status
+- **DTO Definitions**: Verified via static analysis.
+- **Market Logic**: Verified via unit tests (`tests/unit/markets/test_circuit_breaker_relaxation.py`).
+- **Simulation Integrity**: **BROKEN** (Known State). The simulation will not run until Phase 2 updates the agents.
diff --git a/modules/system/__init__.py b/modules/system/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/modules/system/api.py b/modules/system/api.py
new file mode 100644
index 0000000..ba27b0b
--- /dev/null
+++ b/modules/system/api.py
@@ -0,0 +1,33 @@
+from __future__ import annotations
+from typing import TypedDict, List, Dict, Optional, Any
+
+# --- DTOs for Market Stability Signals ---
+
+class MarketSignalDTO(TypedDict):
+    """
+    Provides agents with essential, pre-calculated signals about a specific market's state.
+    This is generated by the MarketSignalObserver after each trading round to ensure data purity
+    for the next decision-making phase.
+    """
+    market_id: str
+    item_id: str
+    best_bid: Optional[float]
+    best_ask: Optional[float]
+    last_traded_price: Optional[float]
+    price_history_7d: List[float]  # Rolling 7-tick price history
+    volatility_7d: float  # Standard deviation of price_history_7d
+    order_book_depth_buy: int  # Number of outstanding buy orders
+    order_book_depth_sell: int  # Number of outstanding sell orders
+    is_frozen: bool  # True if circuit breaker is active or no trades have occurred recently
+
+# --- Modifications to Existing Core DTOs ---
+
+class MarketSnapshotDTO(TypedDict):
+    """
+    [MODIFIED] A snapshot of all relevant market data for a given tick.
+    This is a breaking change. The snapshot now contains a structured dictionary
+    of market signals instead of raw, unstructured data.
+    """
+    tick: int
+    market_signals: Dict[str, MarketSignalDTO]  # item_id -> signal_dto
+    market_data: Dict[str, Any]  # [DEPRECATED] For legacy compatibility during transition.
diff --git a/simulation/dtos/api.py b/simulation/dtos/api.py
index e87ec61..1f2457f 100644
--- a/simulation/dtos/api.py
+++ b/simulation/dtos/api.py
@@ -123,18 +123,9 @@ class OrderDTO:
     quantity: float
     price: float
 
-@dataclass
-class MarketSnapshotDTO:
-    """A pure-data snapshot of the state of all markets at a point in time."""
-    prices: Dict[str, float]
-    volumes: Dict[str, float]
-    asks: Dict[str, List[OrderDTO]]
-    best_asks: Dict[str, float]
-    # WO-146: Macro indicators for Monetary Policy
-    inflation_rate: Optional[float] = 0.0
-    unemployment_rate: Optional[float] = 0.0
-    nominal_gdp: Optional[float] = 0.0
-    potential_gdp: Optional[float] = 0.0
+# Phase 1: MarketSnapshotDTO moved to modules.system.api and converted to TypedDict
+# This is a breaking change for existing agents.
+from modules.system.api import MarketSnapshotDTO
 
 @dataclass
 class GovernmentPolicyDTO:
diff --git a/simulation/markets/order_book_market.py b/simulation/markets/order_book_market.py
index 2a6911d..9c241a2 100644
--- a/simulation/markets/order_book_market.py
+++ b/simulation/markets/order_book_market.py
@@ -60,7 +60,11 @@ class OrderBookMarket(Market):
         Formula: Bounds = Mean * (1 Â± (Base_Limit * Volatility_Adj))
         Volatility_Adj = 1 + (StdDev / Mean)
         """
-        if item_id not in self.price_history or len(self.price_history[item_id]) < 2:
+        # Phase 1: Relax circuit breakers for price discovery
+        min_history_len = getattr(self.config_module, "CIRCUIT_BREAKER_MIN_HISTORY", 7) if self.config_module else 7
+
+        if item_id not in self.price_history or len(self.price_history[item_id]) < min_history_len:
+            self.logger.debug(f"History-Free Discovery: Widening bounds for {item_id}.")
             return 0.0, float('inf') # No bounds yet
 
         history = list(self.price_history[item_id])
diff --git a/tests/unit/markets/test_circuit_breaker_relaxation.py b/tests/unit/markets/test_circuit_breaker_relaxation.py
new file mode 100644
index 0000000..d237ce5
--- /dev/null
+++ b/tests/unit/markets/test_circuit_breaker_relaxation.py
@@ -0,0 +1,59 @@
+import pytest
+from unittest.mock import MagicMock
+from simulation.markets.order_book_market import OrderBookMarket
+from collections import deque
+
+class TestCircuitBreakerRelaxation:
+    @pytest.fixture
+    def market(self):
+        config_mock = MagicMock()
+        config_mock.CIRCUIT_BREAKER_MIN_HISTORY = 5
+        config_mock.MARKET_CIRCUIT_BREAKER_BASE_LIMIT = 0.15
+
+        market = OrderBookMarket(market_id="test_market", config_module=config_mock, logger=MagicMock())
+        return market
+
+    def test_sparse_history_returns_infinite_bounds(self, market):
+        # Setup sparse history (e.g. 2 items, less than 5)
+        item_id = "apple"
+        market._update_price_history(item_id, 10.0)
+        market._update_price_history(item_id, 11.0)
+
+        # Verify
+        min_p, max_p = market.get_dynamic_price_bounds(item_id)
+        assert min_p == 0.0
+        assert max_p == float('inf')
+
+    def test_sufficient_history_returns_finite_bounds(self, market):
+        # Setup sufficient history (e.g. 5 items)
+        item_id = "apple"
+        for p in [10.0, 10.5, 9.5, 10.0, 10.0]:
+            market._update_price_history(item_id, p)
+
+        # Verify
+        min_p, max_p = market.get_dynamic_price_bounds(item_id)
+        assert max_p < float('inf')
+        assert min_p >= 0.0
+
+    def test_no_history_returns_infinite_bounds(self, market):
+        item_id = "unknown"
+        min_p, max_p = market.get_dynamic_price_bounds(item_id)
+        assert min_p == 0.0
+        assert max_p == float('inf')
+
+    def test_default_config_fallback(self):
+        # Test without config module
+        market = OrderBookMarket(market_id="test_market", config_module=None, logger=MagicMock())
+        item_id = "apple"
+
+        # Default is 7. Add 6 items.
+        for _ in range(6):
+            market._update_price_history(item_id, 10.0)
+
+        min_p, max_p = market.get_dynamic_price_bounds(item_id)
+        assert max_p == float('inf') # Should still be infinite (6 < 7)
+
+        # Add 7th item
+        market._update_price_history(item_id, 10.0)
+        min_p, max_p = market.get_dynamic_price_bounds(item_id)
+        assert max_p < float('inf') # Should be finite now (7 >= 7)
