diff --git a/communications/insights/REF-001_Stateless_Policy_Engines.md b/communications/insights/REF-001_Stateless_Policy_Engines.md
new file mode 100644
index 00000000..9919f187
--- /dev/null
+++ b/communications/insights/REF-001_Stateless_Policy_Engines.md
@@ -0,0 +1,26 @@
+# REF-001 Stateless Policy Engines: Implementation Insights
+
+## Overview
+This refactoring successfully extracted `FiscalEngine` and `MonetaryEngine` from `Government` and `CentralBank` agents, enforcing DTO-based communication and removing key abstraction leaks.
+
+## Technical Debt & Trade-offs
+
+1.  **Hardcoded Profit in Bailout Logic**:
+    -   In `Government.provide_firm_bailout`, we construct `FirmFinancialsDTO` with `profit: 0.0` because accessing firm profit history requires deep inspection of the `firm` object (which we are trying to avoid leaking) or a new interface on `Firm`.
+    -   **Impact**: Currently, `FiscalEngine` only checks `is_solvent` for bailouts, so this is benign. If future logic requires profit metrics, `Firm` must expose a DTO method like `get_financial_snapshot()`.
+
+2.  **Shared DTO Definitions**:
+    -   `MarketSnapshotDTO` is defined in `modules/finance/engines/api.py` and imported by `modules/government/engines/api.py`. Ideally, shared DTOs should be in a common `modules/system` or `modules/common` package to avoid coupling between `finance` and `government`.
+    -   **Recommendation**: Move `MarketSnapshotDTO` to `modules/system/api.py` in a future refactor.
+
+3.  **AI Policy Support**:
+    -   The previous `GovernmentDecisionEngine` supported `AI_ADAPTIVE` mode via `AdaptiveGovBrain`. The new `FiscalEngine` currently only implements the Taylor Rule logic.
+    -   **Status**: `AI_ADAPTIVE` is temporarily bypassed/simplified to Taylor Rule logic within the new Engine structure. The AI brain needs to be integrated into `FiscalEngine` or `FiscalEngine` needs to support strategy injection similar to how `GovernmentDecisionEngine` did, but strictly using DTOs.
+
+4.  **Strategy Overrides in Monetary Engine**:
+    -   `CentralBank` previously applied strategy overrides (scenarios) directly. We moved this logic into `MonetaryEngine` by passing optional override fields in `MonetaryStateDTO`.
+    -   **Insight**: This keeps the engine stateless but leaks "scenario" concepts into the engine's input state. This is an acceptable trade-off for now to keep the engine pure.
+
+## Verification
+-   Unit tests for both engines verify core logic (Taylor Rule, Bailout eligibility).
+-   Integration tests confirm `Government` agent correctly orchestrates the new `FiscalEngine`.
diff --git a/modules/finance/engines/__init__.py b/modules/finance/engines/__init__.py
new file mode 100644
index 00000000..e69de29b
diff --git a/modules/finance/engines/api.py b/modules/finance/engines/api.py
new file mode 100644
index 00000000..1f036de7
--- /dev/null
+++ b/modules/finance/engines/api.py
@@ -0,0 +1,33 @@
+from typing import TypedDict, Protocol, runtime_checkable, Optional
+
+class MonetaryStateDTO(TypedDict):
+    """Input state from CentralBank agent."""
+    tick: int
+    current_base_rate: float
+    potential_gdp: float # Calculated and owned by the agent
+    inflation_target: float
+    # Optional Strategy Overrides (WO-136)
+    override_target_rate: Optional[float]
+    rate_multiplier: Optional[float]
+
+class MarketSnapshotDTO(TypedDict):
+    """Shared market data for both engines."""
+    tick: int
+    inflation_rate_annual: float
+    current_gdp: float
+
+class MonetaryDecisionDTO(TypedDict):
+    """Output decision from the MonetaryEngine."""
+    new_base_rate: float
+
+@runtime_checkable
+class IMonetaryEngine(Protocol):
+    def calculate_rate(
+        self,
+        state: MonetaryStateDTO,
+        market: MarketSnapshotDTO
+    ) -> MonetaryDecisionDTO:
+        """
+        Calculates the new target base interest rate.
+        """
+        ...
diff --git a/modules/finance/engines/monetary_engine.py b/modules/finance/engines/monetary_engine.py
new file mode 100644
index 00000000..b04fa894
--- /dev/null
+++ b/modules/finance/engines/monetary_engine.py
@@ -0,0 +1,68 @@
+from typing import Any
+import logging
+from modules.finance.engines.api import (
+    IMonetaryEngine,
+    MonetaryStateDTO,
+    MarketSnapshotDTO,
+    MonetaryDecisionDTO
+)
+
+logger = logging.getLogger(__name__)
+
+class MonetaryEngine(IMonetaryEngine):
+    """
+    Stateless engine that calculates monetary policy (interest rates).
+    Implements Taylor Rule.
+    """
+
+    def __init__(self, config_module: Any = None):
+        self.config = config_module
+        self.alpha = getattr(config_module, "CB_TAYLOR_ALPHA", 1.5)
+        self.beta = getattr(config_module, "CB_TAYLOR_BETA", 0.5)
+
+    def calculate_rate(
+        self,
+        state: MonetaryStateDTO,
+        market: MarketSnapshotDTO
+    ) -> MonetaryDecisionDTO:
+
+        current_gdp = market["current_gdp"]
+        potential_gdp = state["potential_gdp"]
+        inflation_rate = market["inflation_rate_annual"]
+        inflation_target = state["inflation_target"]
+        current_base_rate = state["current_base_rate"]
+
+        # 1. Calculate Output Gap
+        output_gap = 0.0
+        if potential_gdp > 0:
+            output_gap = (current_gdp - potential_gdp) / potential_gdp
+
+        # 2. Taylor Rule
+        # r* (Neutral Rate) assumed 2%
+        neutral_rate = 0.02
+
+        # i = r* + pi + alpha(pi - pi*) + beta(y)
+        taylor_rate = neutral_rate + inflation_rate + \
+                      self.alpha * (inflation_rate - inflation_target) + \
+                      self.beta * output_gap
+
+        # 3. Apply Strategy Overrides (WO-136)
+        if state.get("override_target_rate") is not None:
+             taylor_rate = state["override_target_rate"]
+
+        if state.get("rate_multiplier") is not None:
+             taylor_rate *= state["rate_multiplier"]
+
+        # 4. ZLB (Zero Lower Bound)
+        target_rate = max(0.0, taylor_rate)
+
+        # 5. Smoothing
+        max_change = 0.0025
+        delta = target_rate - current_base_rate
+
+        if abs(delta) > max_change:
+            target_rate = current_base_rate + (max_change * (1.0 if delta > 0 else -1.0))
+
+        return MonetaryDecisionDTO(
+            new_base_rate=target_rate
+        )
diff --git a/modules/government/engines/api.py b/modules/government/engines/api.py
new file mode 100644
index 00000000..b8f794f3
--- /dev/null
+++ b/modules/government/engines/api.py
@@ -0,0 +1,55 @@
+from typing import TypedDict, List, Dict, Optional, Protocol, runtime_checkable
+from modules.system.api import CurrencyCode
+from modules.finance.engines.api import MarketSnapshotDTO
+
+class FiscalStateDTO(TypedDict):
+    """Input state from Government agent."""
+    tick: int
+    assets: Dict[CurrencyCode, float]
+    total_debt: float
+    income_tax_rate: float
+    corporate_tax_rate: float
+    approval_rating: float
+    welfare_budget_multiplier: float
+    potential_gdp: float
+
+class FirmFinancialsDTO(TypedDict):
+    """A snapshot of a firm's health, NOT the live object."""
+    assets: float
+    profit: float
+    is_solvent: bool
+
+class FirmBailoutRequestDTO(TypedDict):
+    firm_id: int
+    requested_amount: float
+    firm_financials: FirmFinancialsDTO
+
+class FiscalRequestDTO(TypedDict): # Union of all possible requests
+    bailout_request: Optional[FirmBailoutRequestDTO]
+    # ... other request types in the future
+
+class GrantedBailoutDTO(TypedDict):
+    firm_id: int
+    amount: float
+    interest_rate: float
+    term: int
+
+class FiscalDecisionDTO(TypedDict):
+    """Output decisions from the FiscalEngine."""
+    new_income_tax_rate: Optional[float]
+    new_corporate_tax_rate: Optional[float]
+    new_welfare_budget_multiplier: Optional[float]
+    bailouts_to_grant: List[GrantedBailoutDTO]
+
+@runtime_checkable
+class IFiscalEngine(Protocol):
+    def decide(
+        self,
+        state: FiscalStateDTO,
+        market: MarketSnapshotDTO,
+        requests: List[FiscalRequestDTO]
+    ) -> FiscalDecisionDTO:
+        """
+        Calculates the next set of fiscal actions based on current state.
+        """
+        ...
diff --git a/modules/government/engines/decision_engine.py b/modules/government/engines/decision_engine.py
index 98a06774..cd12143a 100644
--- a/modules/government/engines/decision_engine.py
+++ b/modules/government/engines/decision_engine.py
@@ -8,13 +8,17 @@ from modules.government.policies.adaptive_gov_brain import AdaptiveGovBrain
 
 logger = logging.getLogger(__name__)
 
+import warnings
+
 class GovernmentDecisionEngine(IGovernmentDecisionEngine):
     """
-    Stateless engine that decides on government policy actions.
+    [DEPRECATED] Stateless engine that decides on government policy actions.
+    Replaced by FiscalEngine for Fiscal Policy.
     It delegates the specific logic to a strategy (e.g., Taylor Rule, AI).
     """
 
     def __init__(self, config_module: Any, strategy_mode: str = "TAYLOR_RULE"):
+        warnings.warn("GovernmentDecisionEngine is deprecated. Use FiscalEngine instead.", DeprecationWarning, stacklevel=2)
         self.config = config_module
         self.strategy_mode = strategy_mode
         self.brain = AdaptiveGovBrain(config_module)
diff --git a/modules/government/engines/fiscal_engine.py b/modules/government/engines/fiscal_engine.py
new file mode 100644
index 00000000..6ffaf58e
--- /dev/null
+++ b/modules/government/engines/fiscal_engine.py
@@ -0,0 +1,99 @@
+from typing import List, Any
+import logging
+from modules.government.engines.api import (
+    IFiscalEngine,
+    FiscalStateDTO,
+    FiscalRequestDTO,
+    FiscalDecisionDTO,
+    GrantedBailoutDTO
+)
+from modules.finance.engines.api import MarketSnapshotDTO
+from modules.system.api import CurrencyCode
+
+logger = logging.getLogger(__name__)
+
+class FiscalEngine(IFiscalEngine):
+    """
+    Stateless engine that decides on government fiscal policy actions.
+    Implements Taylor Rule for tax adjustments and evaluates bailout requests.
+    """
+
+    def __init__(self, config_module: Any = None):
+        self.config = config_module
+
+    def decide(
+        self,
+        state: FiscalStateDTO,
+        market: MarketSnapshotDTO,
+        requests: List[FiscalRequestDTO]
+    ) -> FiscalDecisionDTO:
+
+        # 1. Calculate Fiscal Stance (Tax Rates)
+        new_income_tax_rate, new_corporate_tax_rate, fiscal_stance = self._calculate_tax_rates(state, market)
+
+        # 2. Evaluate Bailout Requests
+        bailouts_to_grant = self._evaluate_bailouts(requests)
+
+        # 3. Construct Decision
+        decision = FiscalDecisionDTO(
+            new_income_tax_rate=new_income_tax_rate,
+            new_corporate_tax_rate=new_corporate_tax_rate,
+            new_welfare_budget_multiplier=state["welfare_budget_multiplier"],
+            bailouts_to_grant=bailouts_to_grant
+        )
+
+        return decision
+
+    def _calculate_tax_rates(self, state: FiscalStateDTO, market: MarketSnapshotDTO):
+        current_gdp = market["current_gdp"]
+        potential_gdp = state["potential_gdp"]
+
+        # Default fallback
+        new_income_tax_rate = state["income_tax_rate"]
+        new_corporate_tax_rate = state["corporate_tax_rate"]
+        fiscal_stance = 0.0
+
+        if potential_gdp > 0:
+            gdp_gap = (current_gdp - potential_gdp) / potential_gdp
+
+            # Counter-Cyclical Logic
+            auto_cyclical = getattr(self.config, "AUTO_COUNTER_CYCLICAL_ENABLED", True)
+
+            if auto_cyclical:
+                sensitivity = getattr(self.config, "FISCAL_SENSITIVITY_ALPHA", 0.5)
+                base_income_tax = getattr(self.config, "INCOME_TAX_RATE", 0.1)
+                base_corp_tax = getattr(self.config, "CORPORATE_TAX_RATE", 0.2)
+
+                fiscal_stance = -sensitivity * gdp_gap
+
+                # Adjust Income Tax
+                # If stance > 0 (Expansionary), lower tax.
+                # If stance < 0 (Contractionary), raise tax.
+                # Formula: rate = base * (1 - stance)
+                new_income_tax_rate = base_income_tax * (1.0 - fiscal_stance)
+                new_corporate_tax_rate = base_corp_tax * (1.0 - fiscal_stance)
+
+                # Clamp values
+                new_income_tax_rate = max(0.05, min(0.6, new_income_tax_rate))
+                new_corporate_tax_rate = max(0.05, min(0.6, new_corporate_tax_rate))
+
+        return new_income_tax_rate, new_corporate_tax_rate, fiscal_stance
+
+    def _evaluate_bailouts(self, requests: List[FiscalRequestDTO]) -> List[GrantedBailoutDTO]:
+        granted = []
+        for req in requests:
+            if req.get("bailout_request"):
+                bailout_req = req["bailout_request"]
+
+                financials = bailout_req["firm_financials"]
+                is_solvent = financials["is_solvent"]
+
+                if is_solvent:
+                    # Grant bailout
+                    granted.append(GrantedBailoutDTO(
+                        firm_id=bailout_req["firm_id"],
+                        amount=bailout_req["requested_amount"],
+                        interest_rate=0.05, # Default term
+                        term=50 # Default term ticks
+                    ))
+        return granted
diff --git a/simulation/agents/central_bank.py b/simulation/agents/central_bank.py
index 556e48c1..68f44701 100644
--- a/simulation/agents/central_bank.py
+++ b/simulation/agents/central_bank.py
@@ -6,6 +6,8 @@ from modules.finance.wallet.wallet import Wallet
 from modules.finance.wallet.api import IWallet
 from modules.system.api import ICurrencyHolder, CurrencyCode, DEFAULT_CURRENCY
 from modules.system.constants import ID_CENTRAL_BANK
+from modules.finance.engines.monetary_engine import MonetaryEngine
+from modules.finance.engines.api import MonetaryStateDTO, MarketSnapshotDTO
 
 if TYPE_CHECKING:
     from modules.memory.api import MemoryV2Interface
@@ -46,6 +48,8 @@ class CentralBank(ICurrencyHolder):
         self.potential_gdp = 0.0
         self.gdp_ema_alpha = 0.05 # Smoothing factor for Potential GDP (slow moving)
 
+        self.monetary_engine = MonetaryEngine(config_module)
+
         logger.info(
             f"CENTRAL_BANK_INIT | Rate: {self.base_rate:.2%}, Target Infl: {self.inflation_target:.2%}",
             extra={"tick": 0, "tags": ["central_bank", "init"]}
@@ -108,83 +112,55 @@ class CentralBank(ICurrencyHolder):
 
     def calculate_rate(self, current_tick: int, current_gdp: float):
         """
-        Implements Taylor Rule:
-        i_t = r* + pi_t + alpha * (pi_t - pi*) + beta * y_t
-
-        Where:
-        - r*: Real neutral rate (assumed 2% or 0.02)
-        - pi_t: Current inflation rate
-        - pi*: Inflation target
-        - y_t: Output gap ((GDP - Potential) / Potential)
+        Calculates interest rate using MonetaryEngine (Taylor Rule).
         """
         # A. Calculate Inflation
-        # We need inflation rate. Tracker usually has 'avg_goods_price'.
-        # Calculate % change from history.
         price_history = self.tracker.metrics.get("avg_goods_price", [])
-
-        # Use simple period-over-period inflation (since last update)
-        # Check price 'update_interval' ticks ago.
         inflation_rate = 0.0
         if len(price_history) > self.update_interval:
             p_current = price_history[-1]
             p_prev = price_history[-self.update_interval]
             if p_prev > 0:
-                # Annualize it?
-                # Taylor rule usually uses annual inflation.
-                # If interval is 10 ticks and year is 100 ticks, this is 0.1 year.
-                # inflation_period = (p_current - p_prev) / p_prev
-                # inflation_annual = inflation_period * (TICKS_PER_YEAR / update_interval)
-                # Let's keep it simple: just period change for now, or annualize.
-                # Standard Taylor Rule uses annual rates.
-
                 ticks_per_year = getattr(self.config_module, "TICKS_PER_YEAR", 100)
                 period_inflation = (p_current - p_prev) / p_prev
                 inflation_rate = period_inflation * (ticks_per_year / self.update_interval)
 
-        # B. Calculate Output Gap
+        # B. Prepare Strategy Overrides
+        override_target_rate = None
+        rate_multiplier = None
+        if self.strategy and self.strategy.is_active:
+             override_target_rate = self.strategy.monetary_shock_target_rate
+             rate_multiplier = self.strategy.base_interest_rate_multiplier
+
+        # C. Construct DTOs
+        state: MonetaryStateDTO = {
+            "tick": current_tick,
+            "current_base_rate": self.base_rate,
+            "potential_gdp": self.potential_gdp,
+            "inflation_target": self.inflation_target,
+            "override_target_rate": override_target_rate,
+            "rate_multiplier": rate_multiplier
+        }
+
+        snapshot: MarketSnapshotDTO = {
+            "tick": current_tick,
+            "inflation_rate_annual": inflation_rate,
+            "current_gdp": current_gdp
+        }
+
+        # D. Call Engine
+        decision = self.monetary_engine.calculate_rate(state, snapshot)
+
+        # E. Apply Decision
+        old_rate = self.base_rate
+        self.base_rate = decision["new_base_rate"]
+
+        # Logging (retained for consistency)
+        # Re-calc output gap for logging only
         output_gap = 0.0
         if self.potential_gdp > 0:
             output_gap = (current_gdp - self.potential_gdp) / self.potential_gdp
 
-        # C. Taylor Rule
-        # Assumed Neutral Real Rate (r*) = 0.02 (2%)
-        neutral_rate = 0.02
-
-        # Taylor Rule Formula
-        # i = r* + pi + alpha(pi - pi*) + beta(y)
-        # Wait, standard formula: i = pi + r* + alpha(pi - pi*) + beta(y)
-        # Rearranged: i = r* + pi(1 + alpha) - alpha*pi* + beta*y
-        # Using alpha=0.5 (standard) means 1.5 response to inflation.
-        # My config has ALPHA=1.5. I should assume config ALPHA is the coefficient for (pi - pi*).
-        # Formula: i = neutral_rate + inflation_rate + alpha * (inflation_rate - target) + beta * output_gap
-
-        taylor_rate = neutral_rate + inflation_rate + \
-                      self.alpha * (inflation_rate - self.inflation_target) + \
-                      self.beta * output_gap
-
-        # D. Apply Strategy Overrides (WO-136)
-        if self.strategy and self.strategy.is_active:
-             # Scenario 4: Fixed Target Rate
-             if self.strategy.monetary_shock_target_rate is not None:
-                 taylor_rate = self.strategy.monetary_shock_target_rate
-
-             # Multiplier
-             if self.strategy.base_interest_rate_multiplier is not None:
-                 taylor_rate *= self.strategy.base_interest_rate_multiplier
-
-        # E. Zero Lower Bound (ZLB) and Smoothing
-        # ZLB
-        target_rate = max(0.0, taylor_rate)
-
-        # Smoothing (Limit max change to 0.25% per update)
-        max_change = 0.0025
-        delta = target_rate - self.base_rate
-        if abs(delta) > max_change:
-            target_rate = self.base_rate + (max_change * (1 if delta > 0 else -1))
-
-        old_rate = self.base_rate
-        self.base_rate = target_rate
-
         old_rate_val = old_rate if isinstance(old_rate, (int, float)) else 0.0
         new_rate_val = self.base_rate if isinstance(self.base_rate, (int, float)) else 0.0
         infl_val = inflation_rate if isinstance(inflation_rate, (int, float)) else 0.0
diff --git a/simulation/agents/government.py b/simulation/agents/government.py
index 19db6e10..b828f312 100644
--- a/simulation/agents/government.py
+++ b/simulation/agents/government.py
@@ -39,8 +39,9 @@ from modules.finance.wallet.api import IWallet
 from modules.simulation.api import ISensoryDataProvider, AgentSensorySnapshotDTO
 
 # New Engines
-from modules.government.engines.decision_engine import GovernmentDecisionEngine
 from modules.government.engines.execution_engine import PolicyExecutionEngine
+from modules.government.engines.fiscal_engine import FiscalEngine
+from modules.government.engines.api import FiscalStateDTO, FiscalRequestDTO, FirmBailoutRequestDTO, FirmFinancialsDTO
 
 if TYPE_CHECKING:
     from simulation.finance.api import ISettlementSystem
@@ -82,7 +83,7 @@ class Government(ICurrencyHolder, IFinancialEntity, IFinancialAgent, ISensoryDat
 
         # Initialize engines
         policy_mode = getattr(config_module, "GOVERNMENT_POLICY_MODE", "TAYLOR_RULE")
-        self.decision_engine = GovernmentDecisionEngine(config_module, strategy_mode=policy_mode)
+        self.fiscal_engine = FiscalEngine(config_module)
         self.execution_engine = PolicyExecutionEngine()
 
         # Initialize default fiscal policy
@@ -296,39 +297,55 @@ class Government(ICurrencyHolder, IFinancialEntity, IFinancialAgent, ISensoryDat
             self.fiscal_policy.corporate_tax_rate = self.corporate_tax_rate
             self.fiscal_policy.income_tax_rate = self.income_tax_rate
 
+        # Update Potential GDP (Agent Logic)
+        current_gdp = market_data.get("total_production", 0.0)
+        if current_gdp == 0.0 and self.sensory_data:
+             current_gdp = self.sensory_data.current_gdp
+
+        if self.potential_gdp == 0.0:
+            self.potential_gdp = current_gdp
+        else:
+            alpha = 0.01
+            self.potential_gdp = (alpha * current_gdp) + ((1-alpha) * self.potential_gdp)
+
         # 1. Gather State into DTO
-        current_state_dto = self._get_state_dto(current_tick)
+        fiscal_state: FiscalStateDTO = {
+            "tick": current_tick,
+            "assets": self.wallet.get_all_balances(),
+            "total_debt": self.total_debt,
+            "income_tax_rate": self.income_tax_rate,
+            "corporate_tax_rate": self.corporate_tax_rate,
+            "approval_rating": self.approval_rating,
+            "welfare_budget_multiplier": self.welfare_budget_multiplier,
+            "potential_gdp": self.potential_gdp
+        }
 
-        market_snapshot = MarketSnapshotDTO(
-            tick=current_tick,
-            market_signals={},
-            market_data=market_data
-        )
+        # Prepare Market Snapshot DTO (TypedDict for Engines)
+        # Note: existing MarketSnapshotDTO is dataclass. We need dictionary for TypedDict?
+        # Or implementation handles it. The engine expects TypedDict.
+        # I'll construct the dict as expected by engine.
+        engine_market_snapshot = {
+            "tick": current_tick,
+            "inflation_rate_annual": self.sensory_data.inflation_sma if self.sensory_data else 0.0,
+            "current_gdp": current_gdp
+        }
 
-        # 2. Call Decision Engine
-        policy_decision = self.decision_engine.decide(current_state_dto, market_snapshot, central_bank)
+        # 2. Call Fiscal Engine
+        decision = self.fiscal_engine.decide(fiscal_state, engine_market_snapshot, [])
 
-        # 3. Prepare Execution Context
-        exec_context = self._get_execution_context()
+        # 3. Apply Changes
+        if decision["new_income_tax_rate"] is not None:
+            self.income_tax_rate = decision["new_income_tax_rate"]
+        if decision["new_corporate_tax_rate"] is not None:
+            self.corporate_tax_rate = decision["new_corporate_tax_rate"]
+        if decision["new_welfare_budget_multiplier"] is not None:
+            self.welfare_budget_multiplier = decision["new_welfare_budget_multiplier"]
 
-        # 4. Call Execution Engine
-        execution_result = self.execution_engine.execute(
-            policy_decision,
-            current_state_dto,
-            [], # No agents list available here
-            market_data,
-            exec_context
+        logger.debug(
+            f"FISCAL_POLICY_EXECUTED | Tick: {current_tick} | IncomeTax: {self.income_tax_rate:.2f} | CorpTax: {self.corporate_tax_rate:.2f}",
+            extra={"tick": current_tick, "agent_id": self.id}
         )
 
-        # 5. Process Results (State Updates)
-        self._apply_state_updates(execution_result.state_updates)
-        
-        if policy_decision.status == "EXECUTED":
-             logger.debug(
-                f"POLICY_EXECUTED | Tick: {current_tick} | Action: {policy_decision.action_tag}",
-                extra={"tick": current_tick, "agent_id": self.id}
-            )
-
         # Legacy Shadow Logging (Keep for verification parity)
         self._log_shadow_metrics(market_data, current_tick, central_bank)
 
@@ -455,36 +472,70 @@ class Government(ICurrencyHolder, IFinancialEntity, IFinancialAgent, ISensoryDat
 
     def provide_firm_bailout(self, firm: Any, amount: float, current_tick: int) -> Tuple[Optional["BailoutLoanDTO"], List[Transaction]]:
         """Provides a bailout loan to a firm if it's eligible. Returns (LoanDTO, Transactions)."""
-        decision = PolicyDecisionDTO(
-            action_tag=PolicyActionTag.FIRM_BAILOUT,
-            parameters={"firm_id": firm.id, "amount": amount},
-            status="EXECUTED"
-        )
 
-        current_state_dto = self._get_state_dto(current_tick)
-        context = self._get_execution_context()
+        # 1. Create Request DTO
+        # Check solvency locally or via WelfareManager helper if needed, but Engine needs FinancialsDTO.
+        # Assuming we can get is_solvent from FinanceSystem or WelfareManager logic.
+        # For now, using WelfareManager logic if possible, or FinanceSystem.
+        # WelfareManager.provide_firm_bailout used 'is_solvent' passed in.
+        # Legacy code called: is_solvent = context.finance_system.evaluate_solvency(firm, state.tick)
 
-        result = self.execution_engine.execute(
-            decision, current_state_dto, [firm], {}, context
-        )
+        is_solvent = False
+        if self.finance_system:
+             is_solvent = self.finance_system.evaluate_solvency(firm, current_tick)
+
+        financials: FirmFinancialsDTO = {
+            "assets": firm.assets if hasattr(firm, 'assets') else 0.0,
+            "profit": 0.0, # Not easily available without deep inspection
+            "is_solvent": is_solvent
+        }
+
+        bailout_req: FirmBailoutRequestDTO = {
+            "firm_id": firm.id,
+            "requested_amount": amount,
+            "firm_financials": financials
+        }
+
+        request: FiscalRequestDTO = {"bailout_request": bailout_req}
+
+        # 2. Call Engine
+        # Need state and market dummy
+        fiscal_state: FiscalStateDTO = {
+            "tick": current_tick,
+            "assets": self.wallet.get_all_balances(),
+            "total_debt": self.total_debt,
+            "income_tax_rate": self.income_tax_rate,
+            "corporate_tax_rate": self.corporate_tax_rate,
+            "approval_rating": self.approval_rating,
+            "welfare_budget_multiplier": self.welfare_budget_multiplier,
+            "potential_gdp": self.potential_gdp
+        }
+        market_snapshot = {
+            "tick": current_tick,
+            "inflation_rate_annual": 0.0, # Not needed for bailout check usually
+            "current_gdp": 0.0
+        }
+
+        decision = self.fiscal_engine.decide(fiscal_state, market_snapshot, [request])
+
+        # 3. Execute Decision
+        if decision["bailouts_to_grant"]:
+            grant = decision["bailouts_to_grant"][0]
+
+            # Execute loan via FinanceSystem
+            # Reusing WelfareManager logic or direct FinanceSystem call?
+            # Legacy used WelfareManager.provide_firm_bailout to get DTO, then FinanceSystem to grant.
+            # Now we have grant details.
+
+            if self.finance_system:
+                loan, txs = self.finance_system.grant_bailout_loan(firm, grant["amount"], current_tick)
 
-        # Refactored: Use executed loans/transactions from Engine result
-        if result.bailout_results:
-            loans = result.executed_loans
-            txs = result.transactions
-
-            # Process expenditures for statistics
-            for loan in loans:
-                # Assuming loan has 'amount' or we infer from request.
-                # The engine called grant_bailout_loan(firm, amount...)
-                # We can use the 'amount' from the decision parameters
-                amt = decision.parameters.get("amount", 0.0)
-                cur = getattr(loan, 'currency', DEFAULT_CURRENCY)
+                # Track expenditure
+                cur = DEFAULT_CURRENCY
                 if cur not in self.expenditure_this_tick: self.expenditure_this_tick[cur] = 0.0
-                self.expenditure_this_tick[cur] += amt
+                self.expenditure_this_tick[cur] += grant["amount"]
 
-            # Return first loan and all txs (Legacy Signature limitation)
-            return (loans[0] if loans else None), txs
+                return loan, txs
 
         return None, []
 
diff --git a/tests/modules/finance/engines/test_monetary_engine.py b/tests/modules/finance/engines/test_monetary_engine.py
new file mode 100644
index 00000000..371c6a42
--- /dev/null
+++ b/tests/modules/finance/engines/test_monetary_engine.py
@@ -0,0 +1,134 @@
+import pytest
+from unittest.mock import MagicMock
+from modules.finance.engines.monetary_engine import MonetaryEngine
+from modules.finance.engines.api import MonetaryStateDTO, MarketSnapshotDTO
+
+@pytest.fixture
+def mock_config():
+    config = MagicMock()
+    config.CB_TAYLOR_ALPHA = 1.5
+    config.CB_TAYLOR_BETA = 0.5
+    return config
+
+@pytest.fixture
+def monetary_engine(mock_config):
+    return MonetaryEngine(mock_config)
+
+class TestMonetaryEngine:
+    def test_calculate_rate_neutral(self, monetary_engine):
+        # Neutral: Inflation = Target, Gap = 0
+        # Rate should be r* + pi = 0.02 + 0.02 = 0.04
+
+        state: MonetaryStateDTO = {
+            "tick": 100,
+            "current_base_rate": 0.04,
+            "potential_gdp": 1000.0,
+            "inflation_target": 0.02
+        }
+
+        market: MarketSnapshotDTO = {
+            "tick": 100,
+            "inflation_rate_annual": 0.02,
+            "current_gdp": 1000.0
+        }
+
+        decision = monetary_engine.calculate_rate(state, market)
+
+        assert decision["new_base_rate"] == pytest.approx(0.04)
+
+    def test_calculate_rate_high_inflation(self, monetary_engine):
+        # Inflation 4% (>2%), Gap 0
+        # Taylor = 0.02 + 0.04 + 1.5*(0.04-0.02) + 0.5*0
+        #        = 0.06 + 1.5*0.02
+        #        = 0.06 + 0.03 = 0.09
+
+        state: MonetaryStateDTO = {
+            "tick": 100,
+            "current_base_rate": 0.04,
+            "potential_gdp": 1000.0,
+            "inflation_target": 0.02
+        }
+
+        market: MarketSnapshotDTO = {
+            "tick": 100,
+            "inflation_rate_annual": 0.04,
+            "current_gdp": 1000.0
+        }
+
+        decision = monetary_engine.calculate_rate(state, market)
+
+        # Should be smoothed. Target 0.09. Current 0.04. Delta 0.05. Max change 0.0025.
+        # Result 0.04 + 0.0025 = 0.0425
+
+        assert decision["new_base_rate"] == pytest.approx(0.0425)
+
+    def test_calculate_rate_recession(self, monetary_engine):
+        # Inflation 2%, Gap -10% (-0.1)
+        # Taylor = 0.02 + 0.02 + 1.5*0 + 0.5*-0.1
+        #        = 0.04 - 0.05 = -0.01
+        # ZLB -> 0.0
+
+        state: MonetaryStateDTO = {
+            "tick": 100,
+            "current_base_rate": 0.04,
+            "potential_gdp": 1000.0,
+            "inflation_target": 0.02
+        }
+
+        market: MarketSnapshotDTO = {
+            "tick": 100,
+            "inflation_rate_annual": 0.02,
+            "current_gdp": 900.0
+        }
+
+        decision = monetary_engine.calculate_rate(state, market)
+
+        # Target 0.0. Current 0.04. Delta -0.04.
+        # Result 0.04 - 0.0025 = 0.0375
+
+        assert decision["new_base_rate"] == pytest.approx(0.0375)
+
+    def test_strategy_override(self, monetary_engine):
+        state: MonetaryStateDTO = {
+            "tick": 100,
+            "current_base_rate": 0.05,
+            "potential_gdp": 1000.0,
+            "inflation_target": 0.02,
+            "override_target_rate": 0.10
+        }
+
+        market: MarketSnapshotDTO = {
+            "tick": 100,
+            "inflation_rate_annual": 0.02,
+            "current_gdp": 1000.0
+        }
+
+        decision = monetary_engine.calculate_rate(state, market)
+
+        # Target overridden to 0.10. Current 0.05.
+        # Smoothing applies. 0.05 + 0.0025 = 0.0525
+
+        assert decision["new_base_rate"] == pytest.approx(0.0525)
+
+    def test_rate_multiplier(self, monetary_engine):
+        # Normal Taylor = 0.04 (Neutral). Multiplier 2.0 -> 0.08.
+        state: MonetaryStateDTO = {
+            "tick": 100,
+            "current_base_rate": 0.04,
+            "potential_gdp": 1000.0,
+            "inflation_target": 0.02,
+            "rate_multiplier": 2.0
+        }
+
+        market: MarketSnapshotDTO = {
+            "tick": 100,
+            "inflation_rate_annual": 0.02,
+            "current_gdp": 1000.0
+        }
+
+        decision = monetary_engine.calculate_rate(state, market)
+
+        # Target 0.08. Current 0.04.
+        # Smoothed -> 0.0425
+
+        assert decision["new_base_rate"] == pytest.approx(0.0425)
diff --git a/tests/modules/government/engines/test_fiscal_engine.py b/tests/modules/government/engines/test_fiscal_engine.py
new file mode 100644
index 00000000..09f1ef72
--- /dev/null
+++ b/tests/modules/government/engines/test_fiscal_engine.py
@@ -0,0 +1,139 @@
+import pytest
+from unittest.mock import MagicMock
+from modules.government.engines.fiscal_engine import FiscalEngine
+from modules.government.engines.api import FiscalStateDTO, FiscalRequestDTO, FirmBailoutRequestDTO, FirmFinancialsDTO
+from modules.finance.engines.api import MarketSnapshotDTO
+from modules.system.api import DEFAULT_CURRENCY
+
+@pytest.fixture
+def mock_config():
+    config = MagicMock()
+    config.AUTO_COUNTER_CYCLICAL_ENABLED = True
+    config.FISCAL_SENSITIVITY_ALPHA = 0.5
+    config.INCOME_TAX_RATE = 0.1
+    config.CORPORATE_TAX_RATE = 0.2
+    config.TICKS_PER_YEAR = 100
+    return config
+
+@pytest.fixture
+def fiscal_engine(mock_config):
+    return FiscalEngine(mock_config)
+
+class TestFiscalEngine:
+    def test_decide_expansionary(self, fiscal_engine):
+        # Case: GDP < Potential (Recession) -> Should lower tax
+        state: FiscalStateDTO = {
+            "tick": 100,
+            "assets": {DEFAULT_CURRENCY: 1000.0},
+            "total_debt": 0.0,
+            "income_tax_rate": 0.1,
+            "corporate_tax_rate": 0.2,
+            "approval_rating": 0.5,
+            "welfare_budget_multiplier": 1.0,
+            "potential_gdp": 1000.0
+        }
+
+        market: MarketSnapshotDTO = {
+            "tick": 100,
+            "inflation_rate_annual": 0.02,
+            "current_gdp": 900.0 # Gap = (900-1000)/1000 = -0.1
+        }
+
+        requests = []
+
+        decision = fiscal_engine.decide(state, market, requests)
+
+        # Stance = -0.5 * -0.1 = 0.05
+        # New Tax = 0.1 * (1 - 0.05) = 0.095
+
+        assert decision["new_income_tax_rate"] < 0.1
+        assert decision["new_corporate_tax_rate"] < 0.2
+        assert decision["new_income_tax_rate"] == pytest.approx(0.095)
+
+    def test_decide_contractionary(self, fiscal_engine):
+        # Case: GDP > Potential (Boom) -> Should raise tax
+        state: FiscalStateDTO = {
+            "tick": 100,
+            "assets": {DEFAULT_CURRENCY: 1000.0},
+            "total_debt": 0.0,
+            "income_tax_rate": 0.1,
+            "corporate_tax_rate": 0.2,
+            "approval_rating": 0.5,
+            "welfare_budget_multiplier": 1.0,
+            "potential_gdp": 1000.0
+        }
+
+        market: MarketSnapshotDTO = {
+            "tick": 100,
+            "inflation_rate_annual": 0.02,
+            "current_gdp": 1100.0 # Gap = 0.1
+        }
+
+        decision = fiscal_engine.decide(state, market, [])
+
+        # Stance = -0.5 * 0.1 = -0.05
+        # New Tax = 0.1 * (1 - (-0.05)) = 0.105
+
+        assert decision["new_income_tax_rate"] > 0.1
+        assert decision["new_income_tax_rate"] == pytest.approx(0.105)
+
+    def test_evaluate_bailout_solvent(self, fiscal_engine):
+        state: FiscalStateDTO = {
+            "tick": 100,
+            "assets": {},
+            "total_debt": 0.0,
+            "income_tax_rate": 0.1,
+            "corporate_tax_rate": 0.2,
+            "approval_rating": 0.5,
+            "welfare_budget_multiplier": 1.0,
+            "potential_gdp": 1000.0
+        }
+        market = {"tick": 100, "current_gdp": 1000.0, "inflation_rate_annual": 0.0}
+
+        req: FiscalRequestDTO = {
+            "bailout_request": {
+                "firm_id": 101,
+                "requested_amount": 500.0,
+                "firm_financials": {
+                    "assets": 1000.0,
+                    "profit": -100.0,
+                    "is_solvent": True
+                }
+            }
+        }
+
+        decision = fiscal_engine.decide(state, market, [req])
+
+        assert len(decision["bailouts_to_grant"]) == 1
+        grant = decision["bailouts_to_grant"][0]
+        assert grant["firm_id"] == 101
+        assert grant["amount"] == 500.0
+
+    def test_evaluate_bailout_insolvent(self, fiscal_engine):
+        state: FiscalStateDTO = {
+            "tick": 100,
+            "assets": {},
+            "total_debt": 0.0,
+            "income_tax_rate": 0.1,
+            "corporate_tax_rate": 0.2,
+            "approval_rating": 0.5,
+            "welfare_budget_multiplier": 1.0,
+            "potential_gdp": 1000.0
+        }
+        market = {"tick": 100, "current_gdp": 1000.0, "inflation_rate_annual": 0.0}
+
+        req: FiscalRequestDTO = {
+            "bailout_request": {
+                "firm_id": 102,
+                "requested_amount": 500.0,
+                "firm_financials": {
+                    "assets": 0.0,
+                    "profit": -100.0,
+                    "is_solvent": False
+                }
+            }
+        }
+
+        decision = fiscal_engine.decide(state, market, [req])
+
+        assert len(decision["bailouts_to_grant"]) == 0
diff --git a/tests/modules/government/test_government_integration.py b/tests/modules/government/test_government_integration.py
index fd00887c..857f81ec 100644
--- a/tests/modules/government/test_government_integration.py
+++ b/tests/modules/government/test_government_integration.py
@@ -15,6 +15,12 @@ def mock_config():
     config.HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK = 1.0
     config.GOODS_INITIAL_PRICE = {"basic_food": 10.0}
     config.STIMULUS_TRIGGER_GDP_DROP = -0.1
+    # Fiscal Engine Configs
+    config.INCOME_TAX_RATE = 0.1
+    config.CORPORATE_TAX_RATE = 0.2
+    config.AUTO_COUNTER_CYCLICAL_ENABLED = True
+    config.FISCAL_SENSITIVITY_ALPHA = 0.5
+    config.CB_INFLATION_TARGET = 0.02
     return config
 
 def test_execute_social_policy_integration(mock_config):
@@ -122,3 +128,37 @@ def test_execute_social_policy_tax_and_welfare(mock_config):
             assert args[3] == "welfare_support_unemployment"
             welfare_found = True
     assert welfare_found
+
+def test_make_policy_decision_integration(mock_config):
+    # Setup
+    gov = Government(id=1, initial_assets=10000.0, config_module=mock_config)
+
+    # Mock Sensory Data
+    gov.sensory_data = MagicMock()
+    gov.sensory_data.inflation_sma = 0.02
+    gov.sensory_data.gdp_growth_sma = 0.02 # Add growth
+    gov.sensory_data.current_gdp = 1000.0
+    gov.potential_gdp = 1000.0 # Match GDP
+
+    # Market Data
+    market_data = {
+        "total_production": 1000.0
+    }
+
+    central_bank = MagicMock() # Mock central bank
+
+    # Execution
+    # Initial tax rate from config (mocked)
+    gov.income_tax_rate = 0.1
+    gov.corporate_tax_rate = 0.2
+
+    # Run with recession data
+    market_data["total_production"] = 900.0 # GDP < Potential -> Expansionary
+    gov.sensory_data.current_gdp = 900.0 # Ensure consistency for logic that might use sensory data
+
+    gov.make_policy_decision(market_data, current_tick=200, central_bank=central_bank)
+
+    # Verification
+    # Should lower tax rates
+    assert gov.income_tax_rate < 0.1
+    assert gov.corporate_tax_rate < 0.2
