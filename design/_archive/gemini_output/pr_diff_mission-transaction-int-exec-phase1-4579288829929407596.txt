diff --git a/communications/insights/MISSION_TRANSACTION_INT_EXEC_PHASE1.md b/communications/insights/MISSION_TRANSACTION_INT_EXEC_PHASE1.md
new file mode 100644
index 00000000..364c29b8
--- /dev/null
+++ b/communications/insights/MISSION_TRANSACTION_INT_EXEC_PHASE1.md
@@ -0,0 +1,52 @@
+# MISSION_TRANSACTION_INT_EXEC_PHASE1 Insights Report
+
+## [Architectural Insights]
+
+### Technical Debt Identified
+1.  **Public Manager Handling:** The `TransactionProcessor` contained hardcoded logic for "Public Manager" transactions within its main execution loop. This violated the Single Responsibility Principle and made the loop hard to read.
+2.  **Error Handling in Processor:** The `TransactionProcessor` loop did not adequately handle exceptions raised by handlers, potentially causing the entire tick to crash on a single malformed transaction.
+3.  **Legacy Price vs Total Pennies:** The `TransactionProcessor` had logic to calculate `amount` from `price * quantity` if `total_pennies` was missing, which is a legacy fallback. The refactored code prioritizes `total_pennies` as the Single Source of Truth (SSoT) for settlement.
+4.  **Rollback Robustness:** The `TransactionEngine` rollback mechanism relied on creating new `TransactionDTO`s and executing them. While functional, it needed robust error handling to prevent "critical failure" scenarios where money could be destroyed if rollback failed.
+
+### Architectural Decisions Made
+1.  **Refactoring `_handle_public_manager`:** Extracted the Public Manager logic into a dedicated private method `_handle_public_manager` in `TransactionProcessor`. This improves encapsulation and readability.
+2.  **Robust Error Handling:** Wrapped handler execution in `try-except` blocks within `TransactionProcessor` to ensure system stability. Exceptions are logged, and the transaction is marked as failed without crashing the simulation.
+3.  **Strict Integer Validation:** Enforced strict integer validation for `TransactionDTO.amount` in `TransactionValidator` to prevent floating-point errors in financial transactions.
+4.  **Critical Rollback Logging:** Enhanced `TransactionEngine` and `TransactionExecutor` to log `CRITICAL` errors if a rollback operation fails, signaling a potential violation of Zero-Sum Integrity.
+5.  **Context Logger Usage:** Updated `TransactionProcessor` to consistently use `context.logger` (simulation logger) instead of a mixed approach, ensuring logs are correctly routed.
+
+## [Test Evidence]
+
+```
+tests/modules/finance/transaction/test_engine.py::test_validator_success PASSED [  5%]
+tests/modules/finance/transaction/test_engine.py::test_validator_negative_amount PASSED [ 10%]
+tests/modules/finance/transaction/test_engine.py::test_validator_invalid_type PASSED [ 15%]
+tests/modules/finance/transaction/test_engine.py::test_validator_account_not_exists PASSED [ 21%]
+tests/modules/finance/transaction/test_engine.py::test_validator_insufficient_funds PASSED [ 26%]
+tests/modules/finance/transaction/test_engine.py::test_executor_success PASSED [ 31%]
+tests/modules/finance/transaction/test_engine.py::test_executor_rollback_success
+-------------------------------- live log call ---------------------------------
+WARNING  modules.finance.transaction.engine:engine.py:91 Deposit failed for B. Rolling back withdrawal from A. Error: Deposit Failed
+PASSED                                                                   [ 36%]
+tests/modules/finance/transaction/test_engine.py::test_executor_critical_rollback_failure
+-------------------------------- live log call ---------------------------------
+WARNING  modules.finance.transaction.engine:engine.py:91 Deposit failed for B. Rolling back withdrawal from A. Error: Deposit Failed
+CRITICAL modules.finance.transaction.engine:engine.py:106 CRITICAL: Rollback failed! 100 USD lost from A. Original Error: Deposit Failed. Rollback Error: Rollback Failed
+PASSED                                                                   [ 42%]
+tests/modules/finance/transaction/test_engine.py::test_process_transaction_success PASSED [ 47%]
+tests/modules/finance/transaction/test_engine.py::test_process_transaction_validation_fail PASSED [ 52%]
+tests/modules/finance/transaction/test_engine.py::test_process_batch_atomicity PASSED [ 57%]
+tests/modules/finance/transaction/test_engine.py::test_process_batch_rollback_failure
+-------------------------------- live log call ---------------------------------
+CRITICAL root:engine.py:323 BATCH ROLLBACK FAILED for tx1. System State Inconsistent! Error: Rollback Fail
+PASSED                                                                   [ 63%]
+tests/modules/finance/transaction/test_processor.py::test_processor_dispatch_success PASSED [ 68%]
+tests/modules/finance/transaction/test_processor.py::test_processor_dispatch_legacy_price PASSED [ 73%]
+tests/modules/finance/transaction/test_processor.py::test_processor_handler_failure PASSED [ 78%]
+tests/modules/finance/transaction/test_processor.py::test_processor_handler_exception PASSED [ 84%]
+tests/modules/finance/transaction/test_processor.py::test_processor_public_manager PASSED [ 89%]
+tests/modules/finance/transaction/test_processor.py::test_processor_public_manager_fail_missing_buyer PASSED [ 94%]
+tests/modules/finance/transaction/test_processor.py::test_processor_public_manager_exception PASSED [100%]
+
+======================== 19 passed, 2 warnings in 0.32s ========================
+```
diff --git a/modules/finance/transaction/engine.py b/modules/finance/transaction/engine.py
index bda131f1..416dce3c 100644
--- a/modules/finance/transaction/engine.py
+++ b/modules/finance/transaction/engine.py
@@ -28,12 +28,14 @@ class TransactionValidator(ITransactionValidator):
         self.account_accessor = account_accessor
 
     def validate(self, transaction: TransactionDTO) -> None:
-        if transaction.amount <= 0:
-            raise NegativeAmountError(f"Transaction amount must be positive. Got: {transaction.amount}")
-
+        # Strict Type Check
         if not isinstance(transaction.amount, int):
              raise ValidationError(f"Transaction amount must be integer (pennies). Got: {type(transaction.amount)}")
 
+        if transaction.amount <= 0:
+            raise NegativeAmountError(f"Transaction amount must be positive. Got: {transaction.amount}")
+
+        # Account Existence Checks
         if not self.account_accessor.exists(transaction.source_account_id):
             raise InvalidAccountError(f"Source account does not exist: {transaction.source_account_id}")
 
@@ -85,7 +87,7 @@ class TransactionExecutor(ITransactionExecutor):
                     memo=f"Transfer from {transaction.source_account_id}: {transaction.description}"
                 )
             except Exception as e:
-                # ROLLBACK
+                # ROLLBACK: Attempt to return funds to source
                 self.logger.warning(
                     f"Deposit failed for {transaction.destination_account_id}. Rolling back withdrawal from {transaction.source_account_id}. Error: {e}"
                 )
@@ -96,11 +98,13 @@ class TransactionExecutor(ITransactionExecutor):
                         memo=f"ROLLBACK: Failed transfer to {transaction.destination_account_id}"
                     )
                 except Exception as rb_error:
-                    # CRITICAL: Money destroyed
-                    raise ExecutionError(
+                    # CRITICAL: Money destroyed (Withdrawn but not Returned)
+                    msg = (
                         f"CRITICAL: Rollback failed! {transaction.amount} {transaction.currency} lost from {transaction.source_account_id}. "
                         f"Original Error: {e}. Rollback Error: {rb_error}"
-                    ) from rb_error
+                    )
+                    self.logger.critical(msg)
+                    raise ExecutionError(msg) from rb_error
 
                 # Re-raise original error wrapped in ExecutionError (since transaction failed)
                 raise ExecutionError(f"Deposit failed: {e}. Rollback successful.") from e
@@ -270,14 +274,23 @@ class TransactionEngine(ITransactionEngine):
                 self._rollback_batch(successful_transactions)
 
                 # Return failure for all
-                failed_results = [
-                     TransactionResultDTO(
+                # Mark executed ones as failed (rolled back) and the failing one as failed.
+                failed_results = []
+                for t in transactions:
+                    msg = fail_msg
+                    status = 'FAILED'
+                    if t == tx:
+                        status = 'CRITICAL_FAILURE' # Execution failed
+                    elif t in successful_transactions:
+                         msg = f"Rolled back due to batch failure: {fail_msg}"
+
+                    failed_results.append(TransactionResultDTO(
                          transaction=t,
-                         status='FAILED' if t != tx else 'CRITICAL_FAILURE', # Mark the one that failed as critical? Or just FAILED batch
-                         message=fail_msg,
+                         status=status,
+                         message=msg,
                          timestamp=self._get_timestamp()
-                     ) for t in transactions
-                 ]
+                     ))
+
                 for fr in failed_results:
                      self.ledger.record(fr)
                 return failed_results
diff --git a/simulation/systems/transaction_processor.py b/simulation/systems/transaction_processor.py
index bf2af929..7a4646f8 100644
--- a/simulation/systems/transaction_processor.py
+++ b/simulation/systems/transaction_processor.py
@@ -37,6 +37,53 @@ class TransactionProcessor(SystemInterface):
         """Registers a handler for Public Manager transactions (seller check)."""
         self._public_manager_handler = handler
 
+    def _handle_public_manager(self, tx: Transaction, context: TransactionContext) -> Optional[SettlementResultDTO]:
+        """
+        Handles transactions where the seller is the Public Manager.
+        Returns a SettlementResultDTO if handled, or None if not applicable.
+        """
+        # 1. Check if it is a PM transaction
+        is_pm_seller = (
+            tx.seller_id == "PUBLIC_MANAGER"
+            or tx.seller_id == 999999
+            or tx.seller_id == -1
+        )
+        is_systemic = tx.transaction_type in [
+            "inheritance_distribution",
+            "escheatment",
+        ]
+
+        if is_pm_seller and not is_systemic and self._public_manager_handler:
+            buyer = context.agents.get(tx.buyer_id) or context.inactive_agents.get(
+                tx.buyer_id
+            )
+            if buyer:
+                try:
+                    success = self._public_manager_handler.handle(
+                        tx, buyer, None, context
+                    )
+
+                    amount = 0.0
+                    if success:
+                        if getattr(tx, 'total_pennies', 0) > 0:
+                            amount = float(tx.total_pennies)
+                        else:
+                            amount = tx.quantity * tx.price
+
+                    return SettlementResultDTO(
+                        original_transaction=tx,
+                        success=success,
+                        amount_settled=amount,
+                    )
+                except Exception as e:
+                    context.logger.error(f"Public Manager Handler Failed for {tx.item_id}: {e}", exc_info=True)
+                    return SettlementResultDTO(
+                        original_transaction=tx,
+                        success=False,
+                        amount_settled=0.0
+                    )
+        return None
+
     def execute(
         self,
         state: SimulationState,
@@ -108,34 +155,9 @@ class TransactionProcessor(SystemInterface):
                 continue
 
             # 1. Special Routing: Public Manager (Seller)
-            # Hijack if seller is explicitly PUBLIC_MANAGER or system placeholder,
-            # BUT only if it's not a specialized systemic distribution (Inheritance/Escheatment)
-            is_pm_seller = (
-                tx.seller_id == "PUBLIC_MANAGER"
-                or tx.seller_id == 999999
-                or tx.seller_id == -1
-            )
-            is_systemic = tx.transaction_type in [
-                "inheritance_distribution",
-                "escheatment",
-            ]
-
-            if is_pm_seller and not is_systemic and self._public_manager_handler:
-                buyer = context.agents.get(tx.buyer_id) or context.inactive_agents.get(
-                    tx.buyer_id
-                )
-                if buyer:
-                    success = self._public_manager_handler.handle(
-                        tx, buyer, None, context
-                    )
-                    amount = tx.quantity * tx.price if success else 0.0
-                    results.append(
-                        SettlementResultDTO(
-                            original_transaction=tx,
-                            success=success,
-                            amount_settled=amount,
-                        )
-                    )
+            pm_result = self._handle_public_manager(tx, context)
+            if pm_result:
+                results.append(pm_result)
                 continue
 
             # 2. Standard Dispatch
@@ -158,6 +180,9 @@ class TransactionProcessor(SystemInterface):
                     continue
 
             # Resolve Agents
+            # Note: We resolve them outside try-except because if this fails,
+            # something is structurally wrong with the simulation state (missing agent).
+            # However, for robustness, we could wrap this too. But usually we want to crash early on corrupted state.
             buyer = context.agents.get(tx.buyer_id) or context.inactive_agents.get(
                 tx.buyer_id
             )
@@ -165,28 +190,37 @@ class TransactionProcessor(SystemInterface):
                 tx.seller_id
             )
 
-            # Dispatch
-            success = handler.handle(tx, buyer, seller, context)
+            try:
+                # Dispatch
+                success = handler.handle(tx, buyer, seller, context)
 
-            # Record Result
-            if success:
-                # TD-MKT-FLOAT-MATCH: total_pennies is the SSoT for settlement
-                if getattr(tx, 'total_pennies', 0) > 0:
-                    amount = float(tx.total_pennies)
-                else:
-                    amount = tx.quantity * tx.price
-            else:
+                # Record Result
                 amount = 0.0
+                if success:
+                    # TD-MKT-FLOAT-MATCH: total_pennies is the SSoT for settlement
+                    if getattr(tx, 'total_pennies', 0) > 0:
+                        amount = float(tx.total_pennies)
+                    else:
+                        amount = tx.quantity * tx.price
 
-            results.append(
-                SettlementResultDTO(
-                    original_transaction=tx, success=success, amount_settled=amount
+                results.append(
+                    SettlementResultDTO(
+                        original_transaction=tx, success=success, amount_settled=amount
+                    )
                 )
-            )
 
-            # Post-processing
-            if success and tx.metadata and tx.metadata.get("triggers_effect"):
-                state.effects_queue.append(tx.metadata)
+                # Post-processing
+                if success and tx.metadata and tx.metadata.get("triggers_effect"):
+                    state.effects_queue.append(tx.metadata)
+
+            except Exception as e:
+                # Catch-all for handler failures to prevent crashing the entire tick
+                state.logger.error(f"Transaction Handler Failed for {tx.transaction_type} (ID: {getattr(tx, 'id', 'unknown')}): {e}", exc_info=True)
+                results.append(
+                    SettlementResultDTO(
+                        original_transaction=tx, success=False, amount_settled=0.0
+                    )
+                )
 
         # Append queued transactions from context to state (e.g. credit creation from loans)
         if context.transaction_queue:
diff --git a/tests/modules/finance/transaction/test_engine.py b/tests/modules/finance/transaction/test_engine.py
new file mode 100644
index 00000000..cf2ea994
--- /dev/null
+++ b/tests/modules/finance/transaction/test_engine.py
@@ -0,0 +1,242 @@
+import pytest
+from unittest.mock import MagicMock, call, ANY
+from typing import List
+
+from modules.finance.transaction.engine import (
+    TransactionEngine,
+    TransactionValidator,
+    TransactionExecutor,
+    SimpleTransactionLedger
+)
+from modules.finance.transaction.api import (
+    TransactionDTO,
+    TransactionResultDTO,
+    IAccountAccessor,
+    ITransactionParticipant,
+    InvalidAccountError,
+    InsufficientFundsError,
+    NegativeAmountError,
+    ExecutionError,
+    ValidationError
+)
+from modules.system.api import DEFAULT_CURRENCY
+
+@pytest.fixture
+def mock_accessor():
+    return MagicMock(spec=IAccountAccessor)
+
+@pytest.fixture
+def mock_ledger():
+    return MagicMock(spec=SimpleTransactionLedger)
+
+@pytest.fixture
+def mock_clock():
+    return MagicMock(return_value=123.0)
+
+@pytest.fixture
+def validator(mock_accessor):
+    return TransactionValidator(mock_accessor)
+
+@pytest.fixture
+def executor(mock_accessor):
+    return TransactionExecutor(mock_accessor)
+
+@pytest.fixture
+def engine(validator, executor, mock_ledger, mock_clock):
+    return TransactionEngine(validator, executor, mock_ledger, mock_clock)
+
+# ==============================================================================
+# Validator Tests
+# ==============================================================================
+
+def test_validator_success(validator, mock_accessor):
+    tx = TransactionDTO("tx1", "A", "B", 100, DEFAULT_CURRENCY, "test")
+
+    mock_accessor.exists.return_value = True
+    participant_a = MagicMock(spec=ITransactionParticipant)
+    participant_a.get_balance.return_value = 200
+    mock_accessor.get_participant.return_value = participant_a
+
+    validator.validate(tx)
+    # Should not raise
+
+def test_validator_negative_amount(validator):
+    tx = TransactionDTO("tx1", "A", "B", -10, DEFAULT_CURRENCY, "test")
+    with pytest.raises(NegativeAmountError):
+        validator.validate(tx)
+
+def test_validator_invalid_type(validator):
+    tx = TransactionDTO("tx1", "A", "B", 10.5, DEFAULT_CURRENCY, "test") # Float!
+    with pytest.raises(ValidationError):
+        validator.validate(tx)
+
+def test_validator_account_not_exists(validator, mock_accessor):
+    tx = TransactionDTO("tx1", "A", "B", 100, DEFAULT_CURRENCY, "test")
+    mock_accessor.exists.side_effect = [True, False] # B doesn't exist
+
+    with pytest.raises(InvalidAccountError):
+        validator.validate(tx)
+
+def test_validator_insufficient_funds(validator, mock_accessor):
+    tx = TransactionDTO("tx1", "A", "B", 100, DEFAULT_CURRENCY, "test")
+
+    mock_accessor.exists.return_value = True
+    participant_a = MagicMock(spec=ITransactionParticipant)
+    participant_a.get_balance.return_value = 50
+    participant_a.allows_overdraft = False
+    mock_accessor.get_participant.return_value = participant_a
+
+    with pytest.raises(InsufficientFundsError):
+        validator.validate(tx)
+
+# ==============================================================================
+# Executor Tests
+# ==============================================================================
+
+def test_executor_success(executor, mock_accessor):
+    tx = TransactionDTO("tx1", "A", "B", 100, DEFAULT_CURRENCY, "test")
+
+    participant_a = MagicMock(spec=ITransactionParticipant)
+    participant_b = MagicMock(spec=ITransactionParticipant)
+
+    def get_participant(account_id):
+        if account_id == "A": return participant_a
+        if account_id == "B": return participant_b
+        return None
+    mock_accessor.get_participant.side_effect = get_participant
+
+    executor.execute(tx)
+
+    participant_a.withdraw.assert_called_once_with(100, DEFAULT_CURRENCY, memo=ANY)
+    participant_b.deposit.assert_called_once_with(100, DEFAULT_CURRENCY, memo=ANY)
+
+def test_executor_rollback_success(executor, mock_accessor):
+    """Test that if deposit fails, withdrawal is rolled back."""
+    tx = TransactionDTO("tx1", "A", "B", 100, DEFAULT_CURRENCY, "test")
+
+    participant_a = MagicMock(spec=ITransactionParticipant)
+    participant_b = MagicMock(spec=ITransactionParticipant)
+    participant_b.deposit.side_effect = Exception("Deposit Failed")
+
+    def get_participant(account_id):
+        if account_id == "A": return participant_a
+        if account_id == "B": return participant_b
+        return None
+    mock_accessor.get_participant.side_effect = get_participant
+
+    with pytest.raises(ExecutionError, match="Deposit failed"):
+        executor.execute(tx)
+
+    participant_a.withdraw.assert_called_once()
+    participant_b.deposit.assert_called_once()
+    participant_a.deposit.assert_called_once_with(100, DEFAULT_CURRENCY, memo=ANY) # Rollback
+
+def test_executor_critical_rollback_failure(executor, mock_accessor):
+    """Test critical failure if rollback also fails."""
+    tx = TransactionDTO("tx1", "A", "B", 100, DEFAULT_CURRENCY, "test")
+
+    participant_a = MagicMock(spec=ITransactionParticipant)
+    participant_b = MagicMock(spec=ITransactionParticipant)
+    participant_b.deposit.side_effect = Exception("Deposit Failed")
+    participant_a.deposit.side_effect = Exception("Rollback Failed") # Rollback fails!
+
+    def get_participant(account_id):
+        if account_id == "A": return participant_a
+        if account_id == "B": return participant_b
+        return None
+    mock_accessor.get_participant.side_effect = get_participant
+
+    with pytest.raises(ExecutionError, match="CRITICAL: Rollback failed"):
+        executor.execute(tx)
+
+# ==============================================================================
+# Engine Tests
+# ==============================================================================
+
+def test_process_transaction_success(engine, mock_ledger, mock_accessor):
+    # Setup Accessor for validation
+    mock_accessor.exists.return_value = True
+    participant = MagicMock()
+    participant.get_balance.return_value = 1000 # Sufficient funds
+    participant.allows_overdraft = False
+    mock_accessor.get_participant.return_value = participant
+
+    tx_result = engine.process_transaction("A", "B", 100, DEFAULT_CURRENCY, "test")
+
+    assert tx_result.status == 'COMPLETED', f"Failed with message: {tx_result.message}"
+    assert tx_result.timestamp == 123.0
+    mock_ledger.record.assert_called_once()
+
+def test_process_transaction_validation_fail(engine, mock_ledger, validator):
+    validator.validate = MagicMock(side_effect=ValidationError("Invalid"))
+
+    tx_result = engine.process_transaction("A", "B", 100, DEFAULT_CURRENCY, "test")
+
+    assert tx_result.status == 'FAILED'
+    assert "Invalid" in tx_result.message
+    mock_ledger.record.assert_called_once()
+
+def test_process_batch_atomicity(engine, mock_ledger, executor):
+    """Test that if 2nd transaction fails, 1st is rolled back."""
+    tx1 = TransactionDTO("tx1", "A", "B", 100, DEFAULT_CURRENCY, "test1")
+    tx2 = TransactionDTO("tx2", "C", "D", 100, DEFAULT_CURRENCY, "test2") # Will fail
+
+    # Mock executor: tx1 succeeds, tx2 fails
+    def execute_side_effect(tx):
+        if tx.transaction_id == "tx1": return
+        if tx.transaction_id == "tx2": raise ExecutionError("Exec Fail")
+        if "rollback" in tx.transaction_id: return # Rollback succeeds
+        raise ValueError(f"Unknown tx: {tx.transaction_id}")
+
+    executor.execute = MagicMock(side_effect=execute_side_effect)
+    # Re-assign executor to engine because we mocked the instance method
+    engine.executor = executor
+
+    # Validation passes for all
+    engine.validator.validate = MagicMock()
+
+    results = engine.process_batch([tx1, tx2])
+
+    assert len(results) == 2
+    assert results[0].status == 'FAILED' # Was rolled back
+    assert "Rolled back" in results[0].message
+    assert results[1].status == 'CRITICAL_FAILURE' # Execution failed
+    assert "Exec Fail" in results[1].message
+
+    # Check calls
+    # Execute tx1
+    # Execute tx2 -> Fail
+    # Execute rollback_tx1
+    executor.execute.assert_has_calls([
+        call(tx1),
+        call(tx2),
+        call(ANY) # Rollback call
+    ])
+    assert "rollback_tx1" in executor.execute.call_args_list[2][0][0].transaction_id
+
+def test_process_batch_rollback_failure(engine, mock_ledger, executor):
+    """Test critical log if rollback fails during batch failure."""
+    tx1 = TransactionDTO("tx1", "A", "B", 100, DEFAULT_CURRENCY, "test1")
+    tx2 = TransactionDTO("tx2", "C", "D", 100, DEFAULT_CURRENCY, "test2")
+
+    # Mock executor: tx1 succeeds, tx2 fails, rollback_tx1 fails
+    def execute_side_effect(tx):
+        if tx.transaction_id == "tx1": return
+        if tx.transaction_id == "tx2": raise ExecutionError("Exec Fail")
+        if "rollback" in tx.transaction_id: raise ExecutionError("Rollback Fail")
+        raise ValueError(f"Unknown tx: {tx.transaction_id}")
+
+    executor.execute = MagicMock(side_effect=execute_side_effect)
+    engine.executor = executor
+    engine.validator.validate = MagicMock()
+
+    # We expect this to run but log CRITICAL.
+    # The result status should still reflect failure.
+    results = engine.process_batch([tx1, tx2])
+
+    assert len(results) == 2
+    assert results[0].status == 'FAILED'
+    assert results[1].status == 'CRITICAL_FAILURE'
+
+    # Verify rollback was attempted
+    assert executor.execute.call_count == 3
diff --git a/tests/modules/finance/transaction/test_processor.py b/tests/modules/finance/transaction/test_processor.py
new file mode 100644
index 00000000..1592647d
--- /dev/null
+++ b/tests/modules/finance/transaction/test_processor.py
@@ -0,0 +1,210 @@
+import pytest
+from unittest.mock import MagicMock, patch
+from dataclasses import dataclass
+from typing import List
+
+from simulation.systems.transaction_processor import TransactionProcessor
+from simulation.systems.api import ITransactionHandler, TransactionContext
+from simulation.models import Transaction
+from simulation.dtos.settlement_dtos import SettlementResultDTO
+from modules.system.api import DEFAULT_CURRENCY
+
+# ==============================================================================
+# Mocks & Fixtures
+# ==============================================================================
+
+@dataclass
+class MockState:
+    transactions: List[Transaction]
+    agents: dict
+    inactive_agents: dict
+    government: MagicMock
+    settlement_system: MagicMock
+    taxation_system: MagicMock
+    stock_market: MagicMock
+    real_estate_units: list
+    market_data: dict
+    logger: MagicMock
+    time: int
+    bank: MagicMock
+    central_bank: MagicMock
+    shareholder_registry: MagicMock
+    effects_queue: list
+
+@pytest.fixture
+def mock_handler():
+    handler = MagicMock(spec=ITransactionHandler)
+    handler.handle.return_value = True
+    return handler
+
+@pytest.fixture
+def processor():
+    config = MagicMock()
+    return TransactionProcessor(config)
+
+@pytest.fixture
+def state():
+    return MockState(
+        transactions=[],
+        agents={},
+        inactive_agents={},
+        government=MagicMock(),
+        settlement_system=MagicMock(),
+        taxation_system=MagicMock(),
+        stock_market=MagicMock(),
+        real_estate_units=[],
+        market_data={},
+        logger=MagicMock(),
+        time=1,
+        bank=MagicMock(),
+        central_bank=MagicMock(),
+        shareholder_registry=MagicMock(),
+        effects_queue=[]
+    )
+
+# ==============================================================================
+# Tests
+# ==============================================================================
+
+def test_processor_dispatch_success(processor, state, mock_handler):
+    # Setup
+    tx = Transaction(
+        buyer_id=1, seller_id=2, item_id="apple", quantity=1, price=10.0,
+        market_id="goods", transaction_type="goods", time=1,
+        total_pennies=1000
+    )
+    state.transactions = [tx]
+    state.agents = {1: MagicMock(), 2: MagicMock()}
+
+    processor.register_handler("goods", mock_handler)
+
+    # Execute
+    results = processor.execute(state)
+
+    # Verify
+    assert len(results) == 1
+    assert results[0].success is True
+    assert results[0].amount_settled == 1000.0 # total_pennies
+
+    mock_handler.handle.assert_called_once()
+    args, _ = mock_handler.handle.call_args
+    assert args[0] == tx # tx passed correctly
+
+def test_processor_dispatch_legacy_price(processor, state, mock_handler):
+    """Test fallback to quantity * price if total_pennies is 0."""
+    tx = Transaction(
+        buyer_id=1, seller_id=2, item_id="apple", quantity=2, price=10.0,
+        market_id="goods", transaction_type="goods", time=1,
+        total_pennies=0 # Legacy case
+    )
+    state.transactions = [tx]
+    state.agents = {1: MagicMock(), 2: MagicMock()}
+
+    processor.register_handler("goods", mock_handler)
+
+    results = processor.execute(state)
+
+    assert len(results) == 1
+    assert results[0].success is True
+    assert results[0].amount_settled == 20.0 # 2 * 10.0
+
+def test_processor_handler_failure(processor, state, mock_handler):
+    """Test that if handler returns False, result is failure."""
+    tx = Transaction(
+        buyer_id=1, seller_id=2, item_id="apple", quantity=1, price=10.0,
+        market_id="goods", transaction_type="goods", time=1
+    )
+    state.transactions = [tx]
+    state.agents = {1: MagicMock(), 2: MagicMock()}
+
+    mock_handler.handle.return_value = False
+    processor.register_handler("goods", mock_handler)
+
+    results = processor.execute(state)
+
+    assert len(results) == 1
+    assert results[0].success is False
+    assert results[0].amount_settled == 0.0
+
+def test_processor_handler_exception(processor, state, mock_handler):
+    """Test that if handler raises exception, it is caught and result is failure."""
+    tx = Transaction(
+        buyer_id=1, seller_id=2, item_id="apple", quantity=1, price=10.0,
+        market_id="goods", transaction_type="goods", time=1
+    )
+    state.transactions = [tx]
+    state.agents = {1: MagicMock(), 2: MagicMock()}
+
+    mock_handler.handle.side_effect = Exception("Boom")
+    processor.register_handler("goods", mock_handler)
+
+    results = processor.execute(state)
+
+    assert len(results) == 1
+    assert results[0].success is False
+    # Should log error
+    state.logger.error.assert_called_once()
+    assert "Boom" in str(state.logger.error.call_args)
+
+def test_processor_public_manager(processor, state):
+    """Test Public Manager routing."""
+    tx = Transaction(
+        buyer_id=1, seller_id="PUBLIC_MANAGER", item_id="apple", quantity=1, price=10.0,
+        market_id="goods", transaction_type="goods", time=1,
+        total_pennies=500
+    )
+    state.transactions = [tx]
+    state.agents = {1: MagicMock()} # Buyer exists
+
+    pm_handler = MagicMock(spec=ITransactionHandler)
+    pm_handler.handle.return_value = True
+    processor.register_public_manager_handler(pm_handler)
+
+    results = processor.execute(state)
+
+    assert len(results) == 1
+    assert results[0].success is True
+    assert results[0].amount_settled == 500.0
+
+    pm_handler.handle.assert_called_once()
+
+def test_processor_public_manager_fail_missing_buyer(processor, state):
+    """Test Public Manager routing fails/skips if buyer missing."""
+    tx = Transaction(
+        buyer_id=999, seller_id="PUBLIC_MANAGER", item_id="apple", quantity=1, price=10.0,
+        market_id="goods", transaction_type="goods", time=1
+    )
+    state.transactions = [tx]
+    state.agents = {} # Buyer missing
+
+    pm_handler = MagicMock(spec=ITransactionHandler)
+    processor.register_public_manager_handler(pm_handler)
+
+    # Fallback to standard dispatch because _handle_public_manager returns None
+    # No standard handler -> Warning
+    results = processor.execute(state)
+
+    assert len(results) == 0 # No result appended because skipped or warned
+    state.logger.warning.assert_called_once_with("No handler for tx type: goods")
+    pm_handler.handle.assert_not_called()
+
+def test_processor_public_manager_exception(processor, state):
+    """Test exception handling in PM handler."""
+    tx = Transaction(
+        buyer_id=1, seller_id="PUBLIC_MANAGER", item_id="apple", quantity=1, price=10.0,
+        market_id="goods", transaction_type="goods", time=1
+    )
+    state.transactions = [tx]
+    state.agents = {1: MagicMock()}
+
+    pm_handler = MagicMock(spec=ITransactionHandler)
+    pm_handler.handle.side_effect = Exception("PM Boom")
+    processor.register_public_manager_handler(pm_handler)
+
+    results = processor.execute(state)
+
+    assert len(results) == 1
+    assert results[0].success is False
+    # Since we use context.logger (which is state.logger), we can verify the call
+    state.logger.error.assert_called_once()
+    assert "PM Boom" in str(state.logger.error.call_args)
