diff --git a/communications/insights/fix_td_firm_coup.md b/communications/insights/fix_td_firm_coup.md
new file mode 100644
index 00000000..91f30ae2
--- /dev/null
+++ b/communications/insights/fix_td_firm_coup.md
@@ -0,0 +1,33 @@
+# Insight: TD-ARCH-FIRM-COUP Resolution
+
+## 1. Architectural Insights
+- **Decoupling Strategy**: Successfully resolved `TD-ARCH-FIRM-COUP` by implementing the "Stateless Engine & Orchestrator" (SEO) pattern. `Firm` entities no longer pass `self` (or `firm_snapshot`) to `Production`, `HR`, and `Sales` engines for core logic.
+- **Context/Intent Protocol**: Defined strict `ContextDTO` (Inputs) and `IntentDTO` (Outputs) for each department.
+    - `ProductionEngine`: `ProductionContextDTO` -> `decide_production` -> `ProductionIntentDTO`
+    - `HREngine`: `HRContextDTO` -> `decide_workforce` -> `HRIntentDTO`
+    - `SalesEngine`: `SalesContextDTO` -> `decide_pricing` -> `SalesIntentDTO`
+- **Component Hygiene**: Removed the `attach(self)` method from `IInventoryComponent` and `IFinancialComponent`, eliminating the risk of parent pointer pollution in these fundamental components.
+- **Orchestration**: The `Firm` class now explicitly constructs contexts from its state, delegates decision-making to stateless engines, and applies the resulting intents. This centralizes state mutation within the `Firm` and keeps engines pure.
+
+## 2. Regression Analysis
+- **Test Adaptations**:
+    - `tests/simulation/test_firm_refactor.py`: Updated to mock `decide_production` instead of `produce`, reflecting the `Firm`'s shift to the new API. This confirms that `Firm` is correctly using the decoupled path.
+    - `tests/simulation/components/engines/test_production_engine.py`: Updated mocks for `FirmSnapshotDTO` to include `id` and `inventory` attributes, required by the new `_build_context` helper which bridges legacy DTOs to new Context DTOs.
+- **Backward Compatibility**: Engines retain legacy methods (`produce`, `manage_workforce`, `post_ask`) as wrappers around the new logic, ensuring that any other systems relying on the old interface remain functional while transitioning.
+
+## 3. Test Evidence
+```text
+tests/simulation/test_firm_refactor.py::test_firm_initialization_states PASSED [ 11%]
+tests/simulation/test_firm_refactor.py::test_command_bus_internal_orders_delegation
+-------------------------------- live log call ---------------------------------
+INFO     modules.firm.orchestrators.firm_action_executor:firm_action_executor.py:88 INTERNAL_EXEC | Firm 1 invested 100.0 in INVEST_AUTOMATION.
+INFO     modules.firm.orchestrators.firm_action_executor:firm_action_executor.py:112 INTERNAL_EXEC | Firm 1 R&D SUCCESS (Budget: 100.0)
+PASSED                                                                   [ 22%]
+tests/simulation/test_firm_refactor.py::test_produce_orchestration PASSED [ 33%]
+tests/simulation/components/engines/test_production_engine.py::test_produce_success PASSED [ 44%]
+tests/simulation/components/engines/test_production_engine.py::test_produce_input_constraint PASSED [ 55%]
+tests/simulation/components/engines/test_production_engine.py::test_produce_no_employees PASSED [ 66%]
+tests/simulation/components/engines/test_firm_decoupling.py::test_production_engine_decoupled PASSED [ 77%]
+tests/simulation/components/engines/test_firm_decoupling.py::test_hr_engine_decoupled PASSED [ 88%]
+tests/simulation/components/engines/test_firm_decoupling.py::test_sales_engine_decoupled PASSED [100%]
+```
diff --git a/modules/agent_framework/components/financial_component.py b/modules/agent_framework/components/financial_component.py
index b8526f70..c1978145 100644
--- a/modules/agent_framework/components/financial_component.py
+++ b/modules/agent_framework/components/financial_component.py
@@ -32,10 +32,6 @@ class FinancialComponent(IFinancialComponent, ICreditFrozen):
         if initial_balance > 0:
             self._wallet.add(initial_balance, DEFAULT_CURRENCY, memo="Initial Balance")
 
-    def attach(self, owner: Any) -> None:
-        """Attaches the component to an owner."""
-        pass
-
     def force_reset_wallet(self) -> None:
         """Resets the wallet state."""
         self._wallet.load_balances({})
diff --git a/modules/agent_framework/components/inventory_component.py b/modules/agent_framework/components/inventory_component.py
index dcbbc540..9997d4ee 100644
--- a/modules/agent_framework/components/inventory_component.py
+++ b/modules/agent_framework/components/inventory_component.py
@@ -34,11 +34,6 @@ class InventoryComponent(IInventoryComponent):
             for item_id, qty in initial_inv.items():
                 self.add_item(item_id, float(qty))
 
-    def attach(self, owner: Any) -> None:
-        """Attaches the component to an owner."""
-        # No-op for now, or store owner reference if needed.
-        pass
-
     @property
     def main_inventory(self) -> Dict[str, float]:
         """Exposes the main inventory dict (as in Firm legacy)."""
diff --git a/modules/firm/api.py b/modules/firm/api.py
index 6670df46..ddc7585d 100644
--- a/modules/firm/api.py
+++ b/modules/firm/api.py
@@ -5,7 +5,7 @@ from enum import Enum
 
 from modules.simulation.dtos.api import FirmConfigDTO, FinanceStateDTO, ProductionStateDTO, SalesStateDTO, HRStateDTO
 from modules.system.api import MarketSnapshotDTO, MarketContextDTO
-from modules.simulation.api import IInventoryHandler
+from modules.simulation.api import IInventoryHandler, AgentID
 from modules.finance.api import IFinancialAgent
 from simulation.models import Order, Transaction
 
@@ -66,6 +66,114 @@ class FirmSnapshotDTO:
     hr: HRStateDTO
     strategy: FirmStrategy = FirmStrategy.PROFIT_MAXIMIZATION
 
+# --- Department Decoupling Context/Intent DTOs ---
+
+@dataclass(frozen=True)
+class BaseDepartmentContextDTO:
+    """Base context shared by all departments."""
+    firm_id: AgentID
+    tick: int
+    budget_pennies: int
+    market_snapshot: MarketSnapshotDTO
+
+    # Financial Context
+    available_cash_pennies: int
+    is_solvent: bool
+
+@dataclass(frozen=True)
+class ProductionContextDTO(BaseDepartmentContextDTO):
+    """Context for Production Department."""
+    inventory_raw_materials: Dict[str, float]
+    inventory_finished_goods: Dict[str, float]
+    current_workforce_count: int
+    technology_level: float
+    production_efficiency: float
+    # Capital & Automation
+    capital_stock: float
+    automation_level: float
+    # Config parameters
+    input_goods: Dict[str, float]  # Recipe
+    output_good_id: str
+    labor_alpha: float
+    automation_labor_reduction: float
+    labor_elasticity_min: float
+    capital_depreciation_rate: float
+    specialization: str
+    base_quality: float
+    quality_sensitivity: float
+    employees_avg_skill: float
+
+@dataclass(frozen=True)
+class ProductionIntentDTO:
+    """Intent from Production Department."""
+    target_production_quantity: float
+    materials_to_use: Dict[str, float]
+    estimated_cost_pennies: int
+
+    # Flags/Results
+    insufficient_materials: bool = False
+
+    # Outputs (from engine calculation)
+    capital_depreciation: int = 0
+    automation_decay: float = 0.0
+    quality: float = 1.0
+
+@dataclass(frozen=True)
+class HRContextDTO(BaseDepartmentContextDTO):
+    """Context for HR Department."""
+    current_employees: List[AgentID]
+    current_headcount: int # Explicit count
+    employee_wages: Dict[AgentID, int] # Current wages
+    employee_skills: Dict[AgentID, float] # Current skills
+    target_workforce_count: int  # Strategic target set by logic or config
+    labor_market_avg_wage: int # Pennies
+    marginal_labor_productivity: float
+    happiness_avg: float
+
+    # Firm State
+    profit_history: List[int] # Pennies
+
+    # Config
+    min_employees: int
+    max_employees: int
+    severance_pay_weeks: int
+
+@dataclass(frozen=True)
+class HRIntentDTO:
+    """Intent from HR Department."""
+    hiring_target: int  # Positive to hire, Negative to fire
+    wage_updates: Dict[AgentID, int]  # AgentID -> New Wage (Pennies)
+    fire_employee_ids: List[AgentID] = field(default_factory=list)
+
+@dataclass(frozen=True)
+class SalesContextDTO(BaseDepartmentContextDTO):
+    """Context for Sales Department."""
+    inventory_to_sell: Dict[str, float]
+    current_prices: Dict[str, int] # Pennies
+    previous_sales_volume: float
+    competitor_prices: Dict[str, int] # Pennies (from market snapshot or other source)
+
+    # Marketing Context
+    marketing_budget_rate: float
+    brand_awareness: float
+    perceived_quality: float
+    inventory_quality: Dict[str, float]
+    last_revenue_pennies: int
+    last_marketing_spend_pennies: int
+    inventory_last_sale_tick: Dict[str, int]
+
+    # Config
+    sale_timeout_ticks: int
+    dynamic_price_reduction_factor: float
+
+@dataclass(frozen=True)
+class SalesIntentDTO:
+    """Intent from Sales Department."""
+    price_adjustments: Dict[str, int]  # ItemID -> New Price (Pennies)
+    sales_orders: List[Dict[str, Any]] # List of sell orders (or Orders directly if cleaner)
+    marketing_spend_pennies: int = 0
+    new_marketing_budget_rate: float = 0.0
+
 # --- Finance Engine DTOs ---
 
 @dataclass(frozen=True)
@@ -88,7 +196,7 @@ class BudgetPlanDTO:
     debt_repayment_pennies: int
     is_solvent: bool
 
-# --- HR Engine DTOs ---
+# --- HR Engine DTOs (Legacy support) ---
 
 @dataclass(frozen=True)
 class HRDecisionInputDTO:
@@ -108,16 +216,13 @@ class HRDecisionOutputDTO:
     wage_updates: Dict[int, int]
     target_headcount: int
 
-# --- Production Engine DTOs ---
+# --- Production Engine DTOs (Legacy support) ---
 
 @dataclass(frozen=True)
 class ProductionInputDTO:
     """Input for the ProductionEngine."""
     firm_snapshot: FirmSnapshotDTO
     productivity_multiplier: float # From external factors like technology
-    # Legacy fields support (optional, or mapped)
-    # The spec uses firm_snapshot, but ProductionEngine logic needs specific inputs.
-    # We will rely on firm_snapshot to provide state data.
 
 @dataclass(frozen=True)
 class ProductionResultDTO:
@@ -225,6 +330,30 @@ class DynamicPricingResultDTO:
 # 3. ENGINE PROTOCOLS
 # ==============================================================================
 
+@runtime_checkable
+class IDepartmentEngine(Protocol):
+    """
+    Protocol for a stateless department engine.
+    Must not hold reference to the parent firm.
+    """
+    # This is a marker protocol or can have generic decide(context) -> intent
+    pass
+
+@runtime_checkable
+class IProductionDepartment(IDepartmentEngine, Protocol):
+    def decide_production(self, context: ProductionContextDTO) -> ProductionIntentDTO:
+        ...
+
+@runtime_checkable
+class IHRDepartment(IDepartmentEngine, Protocol):
+    def decide_workforce(self, context: HRContextDTO) -> HRIntentDTO:
+        ...
+
+@runtime_checkable
+class ISalesDepartment(IDepartmentEngine, Protocol):
+    def decide_pricing(self, context: SalesContextDTO) -> SalesIntentDTO:
+        ...
+
 @runtime_checkable
 class IFinanceEngine(Protocol):
     """Stateless engine for financial planning."""
@@ -245,7 +374,7 @@ class IFinanceEngine(Protocol):
         ...
 
 @runtime_checkable
-class IHREngine(Protocol):
+class IHREngine(IHRDepartment, Protocol):
     """Stateless engine for human resources management."""
     def manage_workforce(self, input_dto: HRDecisionInputDTO) -> HRDecisionOutputDTO:
         ...
@@ -257,7 +386,7 @@ class IHREngine(Protocol):
         ...
 
 @runtime_checkable
-class IProductionEngine(Protocol):
+class IProductionEngine(IProductionDepartment, Protocol):
     """
     Stateless engine for handling the firm's production process.
     """
@@ -313,7 +442,7 @@ class IRDEngine(Protocol):
         ...
 
 @runtime_checkable
-class ISalesEngine(Protocol):
+class ISalesEngine(ISalesDepartment, Protocol):
     """
     Stateless Engine for Sales operations.
     Handles pricing, marketing, and order generation.
@@ -357,7 +486,8 @@ class IBrandEngine(Protocol):
 @runtime_checkable
 class IFirmComponent(Protocol):
     """Base protocol for Firm components."""
-    def attach(self, owner: Any) -> None: ...
+    # attach(self, owner: Any) removed to decouple components from Firm
+    pass
 
 @dataclass
 class InventoryComponentConfigDTO:
@@ -415,6 +545,13 @@ __all__ = [
     'PricingResultDTO',
     'BrandMetricsDTO',
     'DynamicPricingResultDTO',
+    'BaseDepartmentContextDTO',
+    'ProductionContextDTO',
+    'ProductionIntentDTO',
+    'HRContextDTO',
+    'HRIntentDTO',
+    'SalesContextDTO',
+    'SalesIntentDTO',
     'IFinanceEngine',
     'IHREngine',
     'IProductionEngine',
@@ -423,6 +560,10 @@ __all__ = [
     'IRDEngine',
     'ISalesEngine',
     'IBrandEngine',
+    'IDepartmentEngine',
+    'IProductionDepartment',
+    'IHRDepartment',
+    'ISalesDepartment',
     'IFirmComponent',
     'IInventoryComponent',
     'InventoryComponentConfigDTO',
diff --git a/simulation/components/engines/hr_engine.py b/simulation/components/engines/hr_engine.py
index 15f0f2a1..ea728bd5 100644
--- a/simulation/components/engines/hr_engine.py
+++ b/simulation/components/engines/hr_engine.py
@@ -6,64 +6,43 @@ from modules.hr.api import IEmployeeDataProvider
 from simulation.models import Transaction, Order
 from simulation.components.state.firm_state_models import HRState
 from simulation.dtos.hr_dtos import HRPayrollContextDTO, HRPayrollResultDTO, EmployeeUpdateDTO
-from modules.firm.api import HRDecisionInputDTO, HRDecisionOutputDTO, IHREngine
+from modules.firm.api import (
+    HRDecisionInputDTO, HRDecisionOutputDTO, IHREngine,
+    HRContextDTO, HRIntentDTO, IHRDepartment, AgentID,
+    MarketSnapshotDTO
+)
 
 if TYPE_CHECKING:
     from modules.simulation.dtos.api import FirmConfigDTO, FirmStateDTO
 
 logger = logging.getLogger(__name__)
 
-class HREngine(IHREngine):
+class HREngine(IHREngine, IHRDepartment):
     """
     Stateless Engine for HR operations.
     Manages employees, calculates wages (skill + halo), and handles insolvency firing.
     """
 
-    def manage_workforce(self, input_dto: HRDecisionInputDTO) -> HRDecisionOutputDTO:
+    def decide_workforce(self, context: HRContextDTO) -> HRIntentDTO:
         """
-        Decides on hiring and firing based on production needs and budget constraints.
-        Ported from RuleBasedFirmDecisionEngine.
+        Pure function: HRContextDTO -> HRIntentDTO.
+        Decides on hiring/firing targets and wage updates.
         """
-        orders: List[Order] = []
-        firing_ids: List[int] = []
-        wage_updates: Dict[int, int] = {}
-
-        firm_state = input_dto.firm_snapshot
-        config = input_dto.config
-        current_tick = input_dto.current_tick
-        budget_plan = input_dto.budget_plan
-
-        # 1. Calculate Needed Labor
-        # Logic from RuleBasedFirmDecisionEngine._calculate_needed_labor
-        item_id = firm_state.production.specialization
-        target_quantity = firm_state.production.production_target
-        current_inventory = firm_state.production.inventory.get(item_id, 0)
-
-        needed_production = max(0, target_quantity - current_inventory)
-        productivity_factor = firm_state.production.productivity_factor
-
-        if productivity_factor <= 0:
-            needed_labor = 999999.0
-        else:
-            needed_labor = needed_production / productivity_factor
-
-        target_headcount = int(needed_labor)
+        firing_ids: List[AgentID] = []
+        wage_updates: Dict[AgentID, int] = {}
+        hiring_target = 0
 
-        # 2. Compare with current headcount
-        current_employees_list = firm_state.hr.employees # Note: FirmSnapshotDTO has list of IDs? No, HRStateDTO has IDs.
-        # Wait, FirmSnapshotDTO.hr is HRStateDTO.
-        # HRStateDTO has `employees: List[int]` (IDs) and `employees_data: Dict[int, Dict]`.
-        # So I can get count.
-        current_headcount = len(firm_state.hr.employees)
+        target_headcount = context.target_workforce_count
+        current_headcount = context.current_headcount
 
-        # 3. Calculate Wages & Scale (NEW)
+        # 1. Calculate Wages & Scale
 
-        # Calculate Target Wage (used for both Hiring and Scaling)
-        base_wage = input_dto.labor_market_avg_wage # Pennies
+        # Calculate Target Wage
+        base_wage = context.labor_market_avg_wage
         sensitivity = 0.1
         max_premium = 2.0
 
-        profit_history = firm_state.finance.profit_history
+        profit_history = context.profit_history
         avg_profit = sum(profit_history) / len(profit_history) if profit_history else 0.0
 
         profit_based_premium = avg_profit / (base_wage * 10.0) if base_wage > 0 else 0.0
@@ -72,61 +51,29 @@ class HREngine(IHREngine):
         target_wage = int(base_wage * (1 + wage_premium))
 
         # Wage Scaling: Update existing employees if underpaid
-        for emp_id, emp_data in firm_state.hr.employees_data.items():
-            current_wage = emp_data.get('wage', 0)
+        current_wage_bill = 0
+        for emp_id, current_wage in context.employee_wages.items():
             if current_wage < target_wage:
                 wage_updates[emp_id] = target_wage
+                current_wage_bill += target_wage
+            else:
+                current_wage_bill += current_wage
 
-        # Budget Constraint: Check if we can afford current + new employees
-        # Use updated wages for current employees in calculation
-        current_wage_bill = 0
-        for emp_id, emp_data in firm_state.hr.employees_data.items():
-             w = wage_updates.get(emp_id, emp_data.get('wage', 0))
-             current_wage_bill += w
-
-        # 4. Hire or Fire
-
-        # Check Firing
-        # Logic from RuleBasedFirmDecisionEngine._fire_excess_labor
+        # 2. Check Firing
         # "if current_employees > needed_labor + 1"
         if current_headcount > target_headcount + 1:
             excess = current_headcount - target_headcount
-            excess = min(excess, max(0, current_headcount - 1)) # Don't fire everyone? (implied by max(0, current-1))
+            excess = min(excess, max(0, current_headcount - 1))
 
             if excess > 0:
-                # Find candidates (lowest skill? random? last hired?)
-                # Current logic was just firm.hr.employees[:excess] (first ones)
-                # We only have IDs in DTO.
-                candidates = firm_state.hr.employees[:excess]
-
-                severance_weeks = getattr(config, 'severance_pay_weeks', 2) # DTO attributes might be snake_case
-                # config is FirmConfigDTO.
-
-                for emp_id in candidates:
-                    emp_info = firm_state.hr.employees_data.get(emp_id, {})
-                    current_wage = emp_info.get('wage', 1000) # Pennies
-                    skill = emp_info.get('skill', 1.0)
-
-                    # Severance calculation (pennies)
-                    severance_pay = int(current_wage * severance_weeks * skill)
-
-                    # Create FIRE order (Internal Market)
-                    orders.append(Order(
-                        agent_id=firm_state.id,
-                        side='FIRE',
-                        item_id='internal',
-                        quantity=1,
-                        price_pennies=severance_pay,
-                        price_limit=float(severance_pay)/100.0,
-                        market_id='internal',
-                        target_agent_id=emp_id
-                    ))
-                    firing_ids.append(emp_id)
-
-        # Check Hiring
-        # Logic from RuleBasedFirmDecisionEngine._adjust_wages
-        min_employees = getattr(config, 'firm_min_employees', 1)
-        max_employees = getattr(config, 'firm_max_employees', 100)
+                # Find candidates (first ones in list for now)
+                candidates = context.current_employees[:excess]
+                firing_ids.extend(candidates)
+                hiring_target = -excess # Negative indicates firing count if needed, but firing_ids is explicit
+
+        # 3. Check Hiring
+        min_employees = context.min_employees
+        max_employees = context.max_employees
 
         to_hire = 0
         if current_headcount < min_employees:
@@ -140,32 +87,146 @@ class HREngine(IHREngine):
 
             # Can we afford N hires?
             # Projected Cost = Current Wages + (N * Offered Wage)
-            # Budget Plan labor_budget covers this?
-            # Let's say labor_budget is for the *tick* (monthly/daily?)
-            # Usually wages are paid periodically.
-            # If labor_budget_pennies is the limit for *total* wage bill:
-            if current_wage_bill + (to_hire * offered_wage) <= budget_plan.labor_budget_pennies:
-                # Issue Buy Order
-                orders.append(Order(
-                    agent_id=firm_state.id,
-                    side='BUY',
-                    item_id='labor',
-                    quantity=float(to_hire),
-                    price_pennies=offered_wage,
-                    price_limit=float(offered_wage)/100.0,
-                    market_id='labor'
-                ))
+            if current_wage_bill + (to_hire * offered_wage) <= context.budget_pennies:
+                hiring_target = to_hire
             else:
                 # Reduce hires or skip
-                pass
+                # Simple logic: skip if over budget
+                hiring_target = 0
+
+        return HRIntentDTO(
+            hiring_target=hiring_target,
+            wage_updates=wage_updates,
+            fire_employee_ids=firing_ids
+        )
+
+    def manage_workforce(self, input_dto: HRDecisionInputDTO) -> HRDecisionOutputDTO:
+        """
+        Decides on hiring and firing based on production needs and budget constraints.
+        Delegates to decide_workforce for core logic.
+        """
+        firm_state = input_dto.firm_snapshot
+        config = input_dto.config
+
+        # 1. Calculate Needed Labor (Logic remains here as Input Builder)
+        item_id = firm_state.production.specialization
+        target_quantity = firm_state.production.production_target
+        current_inventory = firm_state.production.inventory.get(item_id, 0)
+
+        needed_production = max(0, target_quantity - current_inventory)
+        productivity_factor = firm_state.production.productivity_factor
+
+        if productivity_factor <= 0:
+            needed_labor = 999999.0
+        else:
+            needed_labor = needed_production / productivity_factor
+
+        target_headcount = int(needed_labor)
+
+        # 2. Build Context
+        context = self._build_context(input_dto, target_headcount)
+
+        # 3. Execute Core Logic
+        intent = self.decide_workforce(context)
+
+        # 4. Map Intent to Legacy Output (Orders)
+        orders: List[Order] = []
+
+        # Firing Orders
+        for emp_id in intent.fire_employee_ids:
+            # We need skill/wage for severance calculation
+            # It's in employees_data
+            emp_info = firm_state.hr.employees_data.get(emp_id, {})
+            current_wage = emp_info.get('wage', 1000)
+            skill = emp_info.get('skill', 1.0)
+
+            severance_weeks = context.severance_pay_weeks
+            severance_pay = int(current_wage * severance_weeks * skill)
+
+            orders.append(Order(
+                agent_id=firm_state.id,
+                side='FIRE',
+                item_id='internal',
+                quantity=1,
+                price_pennies=severance_pay,
+                price_limit=float(severance_pay)/100.0,
+                market_id='internal',
+                target_agent_id=emp_id
+            ))
+
+        # Hiring Orders
+        if intent.hiring_target > 0:
+            # Determine offered wage (target wage)
+            # We can infer it from intent.wage_updates if any, or recalculate
+            # But context.labor_market_avg_wage is available.
+            # Wait, decide_workforce calculated target_wage internally but didn't return it explicitly except in wage_updates.
+            # If no wage updates, we don't know the target wage?
+            # We should probably return target_wage in Intent or infer it.
+            # Re-calculating target wage here is redundant but safe.
+            # OR assume wage_updates contains the target wage.
+            # Let's recalculate for safety/simplicity as it's cheap.
+
+            base_wage = context.labor_market_avg_wage
+            sensitivity = 0.1
+            max_premium = 2.0
+            profit_history = context.profit_history
+            avg_profit = sum(profit_history) / len(profit_history) if profit_history else 0.0
+            profit_based_premium = avg_profit / (base_wage * 10.0) if base_wage > 0 else 0.0
+            wage_premium = max(0, min(profit_based_premium * sensitivity, max_premium))
+            offered_wage = int(base_wage * (1 + wage_premium))
+
+            orders.append(Order(
+                agent_id=firm_state.id,
+                side='BUY',
+                item_id='labor',
+                quantity=float(intent.hiring_target),
+                price_pennies=offered_wage,
+                price_limit=float(offered_wage)/100.0,
+                market_id='labor'
+            ))
 
         return HRDecisionOutputDTO(
             hiring_orders=orders,
-            firing_ids=firing_ids,
-            wage_updates=wage_updates,
+            firing_ids=intent.fire_employee_ids, # IDs, already list[int] compatible (AgentID is NewType(int))
+            wage_updates={int(k): v for k, v in intent.wage_updates.items()}, # Cast AgentID to int key
             target_headcount=target_headcount
         )
 
+    def _build_context(self, input_dto: HRDecisionInputDTO, target_headcount: int) -> HRContextDTO:
+        firm_state = input_dto.firm_snapshot
+        config = input_dto.config
+        hr_state = firm_state.hr
+
+        current_employees = [AgentID(e_id) for e_id in hr_state.employees]
+        employees_data = hr_state.employees_data
+
+        employee_wages = {AgentID(k): v.get('wage', 0) for k, v in employees_data.items()}
+        employee_skills = {AgentID(k): v.get('skill', 1.0) for k, v in employees_data.items()}
+
+        return HRContextDTO(
+            firm_id=AgentID(firm_state.id),
+            tick=input_dto.current_tick,
+            budget_pennies=input_dto.budget_plan.labor_budget_pennies,
+            market_snapshot=MarketSnapshotDTO(tick=0, market_signals={}, market_data={}), # Dummy if not needed inside decide
+            available_cash_pennies=0, # Not used
+            is_solvent=True,
+
+            current_employees=current_employees,
+            current_headcount=len(current_employees),
+            employee_wages=employee_wages,
+            employee_skills=employee_skills,
+            target_workforce_count=target_headcount,
+            labor_market_avg_wage=input_dto.labor_market_avg_wage,
+            marginal_labor_productivity=0.0, # Not used in current logic
+            happiness_avg=0.0, # Not used
+
+            profit_history=firm_state.finance.profit_history,
+
+            min_employees=getattr(config, 'firm_min_employees', 1),
+            max_employees=getattr(config, 'firm_max_employees', 100),
+            severance_pay_weeks=getattr(config, 'severance_pay_weeks', 2)
+        )
+
     def calculate_wage(self, employee: IEmployeeDataProvider, base_wage: int, config: FirmConfigDTO) -> int:
         """
         Calculates wage based on skill and halo effect. Returns int pennies.
diff --git a/simulation/components/engines/production_engine.py b/simulation/components/engines/production_engine.py
index b615557d..dec16278 100644
--- a/simulation/components/engines/production_engine.py
+++ b/simulation/components/engines/production_engine.py
@@ -1,143 +1,206 @@
 from __future__ import annotations
 import logging
 import math
-from modules.firm.api import IProductionEngine, ProductionInputDTO, ProductionResultDTO
+from typing import Dict, Any, Optional
+
+from modules.firm.api import (
+    IProductionEngine, ProductionInputDTO, ProductionResultDTO,
+    ProductionContextDTO, ProductionIntentDTO,
+    IProductionDepartment, AgentID
+)
+from modules.system.api import MarketSnapshotDTO
 
 logger = logging.getLogger(__name__)
 
-class ProductionEngine(IProductionEngine):
+class ProductionEngine(IProductionEngine, IProductionDepartment):
     """
     Stateless Engine for Production operations.
     Handles Cobb-Douglas production, automation decay, and R&D.
-    Implements IProductionEngine.
+    Implements IProductionEngine and IProductionDepartment.
     """
 
+    def decide_production(self, context: ProductionContextDTO) -> ProductionIntentDTO:
+        """
+        Pure function: ProductionContextDTO -> ProductionIntentDTO.
+        Decides production quantity and calculates consumption/depreciation.
+        """
+        # 1. Depreciation & Decay (Calculation, NO mutation)
+        # MIGRATION: Integer Math for Capital Depreciation (pennies)
+        # Formula: floor(capital_stock * rate_basis_points / 10000)
+        rate_bp = int(context.capital_depreciation_rate * 10000)
+        capital_depreciation_val = (context.capital_stock * rate_bp) // 10000
+
+        # effective_capital must be at least 0.
+        effective_capital = max(context.capital_stock - capital_depreciation_val, 0)
+
+        # Automation Decay (Float is acceptable for non-monetary abstract value)
+        automation_decay_rate = 0.005
+        automation_decay = context.automation_level * automation_decay_rate
+        effective_automation = context.automation_level - automation_decay
+
+        if effective_automation < 0.001:
+            automation_decay += effective_automation
+            effective_automation = 0.0
+
+        avg_skill = context.employees_avg_skill
+        total_labor_skill = avg_skill * context.current_workforce_count
+
+        # [EARLY EXIT]
+        if total_labor_skill <= 0:
+            return ProductionIntentDTO(
+                target_production_quantity=0.0,
+                materials_to_use={},
+                estimated_cost_pennies=0,
+                capital_depreciation=int(capital_depreciation_val),
+                automation_decay=automation_decay,
+                quality=0.0
+            )
+
+        # 3. Production Parameters
+        base_alpha = context.labor_alpha
+        automation_reduction = context.automation_labor_reduction
+
+        # Alpha Adjusted
+        alpha_raw = base_alpha * (1.0 - (effective_automation * automation_reduction))
+        alpha_adjusted = max(context.labor_elasticity_min, alpha_raw)
+        beta_adjusted = 1.0 - alpha_adjusted
+
+        # Technology Multiplier
+        tfp = context.production_efficiency
+        tfp *= context.technology_level # productivity_multiplier passed in context.technology_level? No, technology_level is base?
+        # In build_context, I will map input_dto.productivity_multiplier * firm.productivity_factor to technology_level.
+
+        # Quality Calculation
+        quality_sensitivity = context.quality_sensitivity
+        actual_quality = context.base_quality + (math.log1p(avg_skill) * quality_sensitivity)
+
+        produced_quantity = 0.0
+        if total_labor_skill > 0 and effective_capital > 0:
+            # Standard Cobb-Douglas
+            produced_quantity = tfp * (total_labor_skill ** alpha_adjusted) * (effective_capital ** beta_adjusted)
+
+        actual_produced = 0.0
+        consumed_inputs = {}
+
+        # Production Cost (if tracking specific batch costs)
+        production_cost = 0
+
+        if produced_quantity > 0:
+            # Input Constraints
+            input_config = context.input_goods
+
+            if input_config:
+                max_by_inputs = float('inf')
+                input_inventory = context.inventory_raw_materials
+
+                for mat, req_per_unit in input_config.items():
+                    available = input_inventory.get(mat, 0.0)
+                    if req_per_unit > 0:
+                        max_by_inputs = min(max_by_inputs, available / req_per_unit)
+
+                actual_produced = min(produced_quantity, max_by_inputs)
+            else:
+                actual_produced = produced_quantity
+
+            # MIGRATION: Deterministic Integer Output
+            actual_produced = math.floor(actual_produced)
+
+            if input_config and actual_produced > 0:
+                # Calculate consumed inputs based on integer output
+                for mat, req_per_unit in input_config.items():
+                    consumed_inputs[mat] = actual_produced * req_per_unit
+
+        return ProductionIntentDTO(
+            target_production_quantity=float(actual_produced),
+            materials_to_use=consumed_inputs,
+            estimated_cost_pennies=production_cost,
+            capital_depreciation=int(capital_depreciation_val),
+            automation_decay=automation_decay,
+            quality=actual_quality
+        )
+
     def produce(
         self,
         input_dto: ProductionInputDTO
     ) -> ProductionResultDTO:
         """
         Executes production logic.
-        Calculates production output based on labor, capital, and technology.
-        Returns a DTO describing the result of the production cycle.
+        Delegates to decide_production for core logic.
         """
-        firm_snapshot = input_dto.firm_snapshot
-        config = firm_snapshot.config
-        production_state = firm_snapshot.production
-        hr_state = firm_snapshot.hr
-
         try:
-            # 1. Depreciation & Decay (Calculation, NO mutation)
-            # MIGRATION: Integer Math for Capital Depreciation (pennies)
-            # Formula: floor(capital_stock * rate_basis_points / 10000)
-            rate_bp = int(config.capital_depreciation_rate * 10000)
-            capital_depreciation_val = (production_state.capital_stock * rate_bp) // 10000
-
-            # effective_capital must be at least 0.
-            # Using max(..., 1) to avoid division by zero if used later, though here it's used in numerator.
-            effective_capital = max(production_state.capital_stock - capital_depreciation_val, 0)
-
-            # Automation Decay (Float is acceptable for non-monetary abstract value)
-            automation_decay_rate = 0.005
-            automation_decay = production_state.automation_level * automation_decay_rate
-            effective_automation = production_state.automation_level - automation_decay
-
-            if effective_automation < 0.001:
-                automation_decay += effective_automation
-                effective_automation = 0.0
-
-            # 2. Gather Inputs from HR State
-            employees_data = hr_state.employees_data
-            num_employees = len(employees_data)
-            total_labor_skill = sum(emp.get("skill", 1.0) for emp in employees_data.values())
-            avg_skill = total_labor_skill / num_employees if num_employees > 0 else 0.0
-
-            # [EARLY EXIT]
-            if total_labor_skill <= 0:
-                return ProductionResultDTO(
-                    success=True,
-                    quantity_produced=0.0,
-                    quality=0.0,
-                    specialization=production_state.specialization,
-                    capital_depreciation=int(capital_depreciation_val),
-                    automation_decay=automation_decay
-                )
-
-            # 3. Production Parameters
-            base_alpha = config.labor_alpha
-            automation_reduction = config.automation_labor_reduction
-
-            # Alpha Adjusted
-            alpha_raw = base_alpha * (1.0 - (effective_automation * automation_reduction))
-            alpha_adjusted = max(config.labor_elasticity_min, alpha_raw)
-            beta_adjusted = 1.0 - alpha_adjusted
-
-            # Technology Multiplier
-            tfp = production_state.productivity_factor
-            tfp *= input_dto.productivity_multiplier
-
-            # Quality Calculation
-            item_config = config.goods.get(production_state.specialization, {})
-            quality_sensitivity = item_config.get("quality_sensitivity", 0.5)
-            actual_quality = production_state.base_quality + (math.log1p(avg_skill) * quality_sensitivity)
-
-            produced_quantity = 0.0
-            if total_labor_skill > 0 and effective_capital > 0:
-                # Standard Cobb-Douglas
-                produced_quantity = tfp * (total_labor_skill ** alpha_adjusted) * (effective_capital ** beta_adjusted)
-
-            actual_produced = 0.0
-            consumed_inputs = {}
-
-            # Production Cost (if tracking specific batch costs)
-            # Currently 0 as costs are amortized/handled by Inventory/Wage logic separately
-            production_cost = 0
-
-            if produced_quantity > 0:
-                # Input Constraints
-                input_config = item_config.get("inputs", {})
-
-                if input_config:
-                    max_by_inputs = float('inf')
-                    input_inventory = production_state.input_inventory
-
-                    for mat, req_per_unit in input_config.items():
-                        available = input_inventory.get(mat, 0.0)
-                        if req_per_unit > 0:
-                            max_by_inputs = min(max_by_inputs, available / req_per_unit)
-
-                    actual_produced = min(produced_quantity, max_by_inputs)
-                else:
-                    actual_produced = produced_quantity
-
-                # MIGRATION: Deterministic Integer Output
-                # We floor the output to ensure integer quantities of goods
-                actual_produced = math.floor(actual_produced)
-
-                if input_config and actual_produced > 0:
-                    # Calculate consumed inputs based on integer output
-                    for mat, req_per_unit in input_config.items():
-                        consumed_inputs[mat] = actual_produced * req_per_unit
+            # Build Context
+            context = self._build_context(input_dto)
+
+            # Execute Core Logic
+            intent = self.decide_production(context)
 
+            # Map back to Result
             return ProductionResultDTO(
                 success=True,
-                quantity_produced=float(actual_produced),
-                quality=actual_quality,
-                specialization=production_state.specialization,
-                inputs_consumed=consumed_inputs,
-                production_cost=production_cost,
-                capital_depreciation=int(capital_depreciation_val),
-                automation_decay=automation_decay
+                quantity_produced=intent.target_production_quantity,
+                quality=intent.quality,
+                specialization=context.specialization,
+                inputs_consumed=intent.materials_to_use,
+                production_cost=intent.estimated_cost_pennies,
+                capital_depreciation=intent.capital_depreciation,
+                automation_decay=intent.automation_decay
             )
 
         except Exception as e:
-            logger.error(f'PRODUCTION_ERROR | Firm {firm_snapshot.id}: {e}')
+            logger.error(f'PRODUCTION_ERROR | Firm {input_dto.firm_snapshot.id}: {e}')
             return ProductionResultDTO(
                 success=False,
                 quantity_produced=0.0,
                 quality=0.0,
-                specialization=production_state.specialization,
+                specialization=input_dto.firm_snapshot.production.specialization,
                 error_message=str(e),
                 production_cost=0,
                 capital_depreciation=0
             )
+
+    def _build_context(self, input_dto: ProductionInputDTO) -> ProductionContextDTO:
+        firm_snapshot = input_dto.firm_snapshot
+        config = firm_snapshot.config
+        prod_state = firm_snapshot.production
+        hr_state = firm_snapshot.hr
+
+        # Calculate derived values
+        employees_data = hr_state.employees_data
+        num_employees = len(employees_data)
+        total_labor_skill = sum(emp.get("skill", 1.0) for emp in employees_data.values())
+        avg_skill = total_labor_skill / num_employees if num_employees > 0 else 0.0
+
+        item_config = config.goods.get(prod_state.specialization, {})
+
+        # technology_level = productivity_factor * input_dto.productivity_multiplier
+        tech_level = prod_state.productivity_factor * input_dto.productivity_multiplier
+
+        return ProductionContextDTO(
+            firm_id=AgentID(firm_snapshot.id),
+            tick=0, # Not available in InputDTO, defaulting to 0 as it's unused in calculation
+            budget_pennies=0, # Not used in current logic
+            market_snapshot=MarketSnapshotDTO(tick=0, market_signals={}, market_data={}), # Dummy
+            available_cash_pennies=0, # Not used
+            is_solvent=True, # Not used
+
+            inventory_raw_materials=prod_state.input_inventory,
+            inventory_finished_goods=prod_state.inventory,
+            current_workforce_count=num_employees,
+            technology_level=tech_level,
+            production_efficiency=1.0, # Baseline efficiency multiplier, combined into tech_level here or separate? Logic uses tfp = production_efficiency * technology_level. Here tfp = tech_level. So prod_efficiency=1.0.
+
+            capital_stock=prod_state.capital_stock,
+            automation_level=prod_state.automation_level,
+
+            input_goods=item_config.get("inputs", {}),
+            output_good_id=prod_state.specialization,
+
+            labor_alpha=config.labor_alpha,
+            automation_labor_reduction=config.automation_labor_reduction,
+            labor_elasticity_min=config.labor_elasticity_min,
+            capital_depreciation_rate=config.capital_depreciation_rate,
+            specialization=prod_state.specialization,
+            base_quality=prod_state.base_quality,
+            quality_sensitivity=item_config.get("quality_sensitivity", 0.5),
+            employees_avg_skill=avg_skill
+        )
diff --git a/simulation/components/engines/sales_engine.py b/simulation/components/engines/sales_engine.py
index 0489e596..6ebceb1b 100644
--- a/simulation/components/engines/sales_engine.py
+++ b/simulation/components/engines/sales_engine.py
@@ -2,22 +2,133 @@ from __future__ import annotations
 from typing import TYPE_CHECKING, Any, Dict, List, Optional
 import logging
 import math
+from dataclasses import replace
+
 from simulation.models import Order, Transaction
 from simulation.components.state.firm_state_models import SalesState
 from simulation.dtos.sales_dtos import SalesPostAskContextDTO, SalesMarketingContextDTO, MarketingAdjustmentResultDTO
 from modules.system.api import MarketContextDTO, DEFAULT_CURRENCY
-from modules.firm.api import ISalesEngine, DynamicPricingResultDTO
+from modules.firm.api import (
+    ISalesEngine, ISalesDepartment, DynamicPricingResultDTO,
+    SalesContextDTO, SalesIntentDTO, AgentID
+)
+from modules.firm.constants import DEFAULT_PRICE
+
 if TYPE_CHECKING:
     from modules.simulation.dtos.api import FirmConfigDTO
+
 logger = logging.getLogger(__name__)
 
-class SalesEngine(ISalesEngine):
+class SalesEngine(ISalesEngine, ISalesDepartment):
     """
     Stateless Engine for Sales operations.
     Handles pricing, marketing, and order generation.
     MIGRATION: Uses integer pennies.
     """
 
+    def decide_pricing(self, context: SalesContextDTO) -> SalesIntentDTO:
+        """
+        Pure function: SalesContextDTO -> SalesIntentDTO.
+        Decides pricing, generates orders, and sets marketing budget.
+        """
+        price_adjustments: Dict[str, int] = {}
+        sales_orders: List[Order] = []
+
+        # 1. Generate Base Orders (Sell Everything Strategy)
+        for item_id, quantity in context.inventory_to_sell.items():
+            if quantity <= 0: continue
+
+            price_pennies = context.current_prices.get(item_id, DEFAULT_PRICE) # Default if missing
+
+            # Construct Brand Snapshot
+            brand_snapshot = {
+                "brand_awareness": context.brand_awareness,
+                "perceived_quality": context.perceived_quality,
+                "quality": context.inventory_quality.get(item_id, 1.0)
+            }
+
+            # Use correct market_id (usually matches item_id for goods)
+            market_id = item_id
+
+            order = Order(
+                agent_id=context.firm_id,
+                side='SELL',
+                item_id=item_id,
+                quantity=quantity,
+                price_pennies=price_pennies,
+                price_limit=price_pennies / 100.0,
+                market_id=market_id,
+                brand_info=brand_snapshot,
+                currency=DEFAULT_CURRENCY
+            )
+            sales_orders.append(order)
+
+        # 2. Apply Dynamic Pricing (Discounting stale inventory)
+        sale_timeout = context.sale_timeout_ticks
+        reduction_factor = context.dynamic_price_reduction_factor
+
+        final_orders = []
+        for order in sales_orders:
+            item_id = order.item_id
+            last_sale = context.inventory_last_sale_tick.get(item_id, 0)
+
+            if context.tick - last_sale > sale_timeout:
+                # Discount
+                original_price_pennies = order.price_pennies
+                discounted_pennies = int(original_price_pennies * reduction_factor)
+
+                final_price_pennies = max(1, discounted_pennies) # Ensure positive price
+
+                if final_price_pennies < original_price_pennies:
+                    # Update Order
+                    new_order = replace(order,
+                        price_pennies=final_price_pennies,
+                        price_limit=final_price_pennies / 100.0
+                    )
+                    final_orders.append(new_order)
+                    price_adjustments[item_id] = final_price_pennies
+                else:
+                    final_orders.append(order)
+            else:
+                final_orders.append(order)
+
+        # 3. Calculate Marketing Budget
+        # Uses last_revenue_pennies (T-1) as proxy for performance
+        new_rate = context.marketing_budget_rate
+        last_spend = context.last_marketing_spend_pennies
+
+        # Heuristic: If we spent money and got revenue, check ROI
+        # Using simplified ROI logic here as we lack T-2 revenue for delta
+        if last_spend > 0:
+            revenue = context.last_revenue_pennies
+            roi = revenue / last_spend
+
+            if roi > 2.0 and context.brand_awareness < 0.9:
+                new_rate *= 1.1
+            elif roi < 1.0:
+                new_rate *= 0.9
+
+        target_budget = context.last_revenue_pennies * new_rate
+        # Smoothing (80% old budget + 20% new target)
+        # Note: current budget is unknown?
+        # We can use last_spend as current budget proxy or
+        # assume firm state manages smoothing.
+        # But decide_pricing is determining the budget for THIS tick.
+        # Let's return the calculated amount.
+
+        # Smoothing logic usually requires "current set budget" vs "last actual spend".
+        # context.last_marketing_spend_pennies is "actual spend".
+        # We can assume last_spend is the baseline.
+
+        new_budget = last_spend * 0.8 + target_budget * 0.2
+
+        return SalesIntentDTO(
+            price_adjustments=price_adjustments,
+            sales_orders=final_orders,
+            marketing_spend_pennies=int(new_budget),
+            new_marketing_budget_rate=new_rate
+        )
+
     def post_ask(self, state: SalesState, context: SalesPostAskContextDTO) -> Order:
         """
         Posts an ask order to the market.
@@ -101,4 +212,4 @@ class SalesEngine(ISalesEngine):
                         new_orders[i] = new_order
                         price_updates[item_id] = final_price_pennies
 
-        return DynamicPricingResultDTO(orders=new_orders, price_updates=price_updates)
\ No newline at end of file
+        return DynamicPricingResultDTO(orders=new_orders, price_updates=price_updates)
diff --git a/simulation/firms.py b/simulation/firms.py
index 77226a5c..70e9352f 100644
--- a/simulation/firms.py
+++ b/simulation/firms.py
@@ -13,7 +13,7 @@ from simulation.dtos import DecisionContext, FiscalContext, DecisionInputDTO
 from modules.simulation.dtos.api import FirmConfigDTO, FirmStateDTO, IFirmStateProvider, FinanceStateDTO, ProductionStateDTO, SalesStateDTO, HRStateDTO
 from simulation.ai.enums import Personality
 from modules.system.api import MarketSnapshotDTO, DEFAULT_CURRENCY, CurrencyCode, MarketContextDTO, ICurrencyHolder
-from modules.simulation.api import AgentCoreConfigDTO, IDecisionEngine, AgentStateDTO, IOrchestratorAgent, IInventoryHandler, ISensoryDataProvider, AgentSensorySnapshotDTO, IConfigurable, LiquidationConfigDTO, InventorySlot, ItemDTO, InventorySlotDTO
+from modules.simulation.api import AgentCoreConfigDTO, IDecisionEngine, AgentStateDTO, IOrchestratorAgent, IInventoryHandler, ISensoryDataProvider, AgentSensorySnapshotDTO, IConfigurable, LiquidationConfigDTO, InventorySlot, ItemDTO, InventorySlotDTO, AgentID
 from dataclasses import replace
 
 # Orchestrator-Engine Refactor
@@ -45,7 +45,9 @@ from modules.firm.api import (
     LiquidationExecutionDTO, LiquidationResultDTO,
     IProductionEngine, IAssetManagementEngine, IRDEngine, IPricingEngine,
     IInventoryComponent, IFinancialComponent,
-    ISalesEngine, IBrandEngine, IFinanceEngine, IHREngine
+    ISalesEngine, IBrandEngine, IFinanceEngine, IHREngine,
+    ProductionContextDTO, HRContextDTO, SalesContextDTO,
+    ProductionIntentDTO, HRIntentDTO, SalesIntentDTO
 )
 from modules.firm.constants import (
     DEFAULT_MARKET_INSIGHT, DEFAULT_MARKETING_BUDGET_RATE, DEFAULT_LIQUIDATION_PRICE,
@@ -117,9 +119,9 @@ class Firm(ILearningAgent, IFinancialFirm, IFinancialAgent, ILiquidatable, IOrch
 
         # Components
         self.inventory_component = InventoryComponent(str(self.id))
-        self.inventory_component.attach(self)
+        # self.inventory_component.attach(self) # REMOVED: Decoupling
         self.financial_component = FinancialComponent(str(self.id))
-        self.financial_component.attach(self)
+        # self.financial_component.attach(self) # REMOVED: Decoupling
 
         self.is_active = True
 
@@ -754,39 +756,32 @@ class Firm(ILearningAgent, IFinancialFirm, IFinancialAgent, ILiquidatable, IOrch
         )
 
     def produce(self, current_time: int, technology_manager: Optional[Any] = None, effects_queue: Optional[List[Dict[str, Any]]] = None) -> None:
-        # 1. ASSEMBLE snapshot and input DTO
-        snapshot = self.get_snapshot_dto()
+        # 1. ASSEMBLE ProductionContextDTO
         productivity_multiplier = technology_manager.get_productivity_multiplier(self.id) if technology_manager else 1.0
-
-        input_dto = ProductionInputDTO(
-            firm_snapshot=snapshot,
-            productivity_multiplier=productivity_multiplier
-        )
+        context = self._build_production_context(productivity_multiplier)
 
         # 2. DELEGATE to stateless engine
-        result: ProductionResultDTO = self.production_engine.produce(input_dto)
+        intent: ProductionIntentDTO = self.production_engine.decide_production(context)
 
         # 3. APPLY result to state (Orchestrator responsibility)
         # Apply depreciation/decay (new mechanism)
-        if result.capital_depreciation > 0:
-            self.production_state.capital_stock = max(0.0, self.production_state.capital_stock - result.capital_depreciation)
+        if intent.capital_depreciation > 0:
+            self.production_state.capital_stock = max(0.0, self.production_state.capital_stock - intent.capital_depreciation)
 
-        if result.automation_decay > 0:
-            self.production_state.automation_level = max(0.0, self.production_state.automation_level - result.automation_decay)
+        if intent.automation_decay > 0:
+            self.production_state.automation_level = max(0.0, self.production_state.automation_level - intent.automation_decay)
 
         # Update production
-        self.current_production = result.quantity_produced
-        if result.success and result.quantity_produced > 0:
-            self.add_item(result.specialization, result.quantity_produced, quality=result.quality)
+        self.current_production = intent.target_production_quantity
+        if intent.target_production_quantity > 0:
+            self.add_item(self.production_state.specialization, intent.target_production_quantity, quality=intent.quality)
 
             # MIGRATION: Record expense in int pennies
-            # Result production_cost might be float from engine?
-            # I will update engine later. For now, cast.
-            cost_pennies = int(result.production_cost)
+            cost_pennies = int(intent.estimated_cost_pennies)
             self.record_expense(cost_pennies, DEFAULT_CURRENCY)
 
             # Consume inputs
-            for mat, amount in result.inputs_consumed.items():
+            for mat, amount in intent.materials_to_use.items():
                 self.remove_item(mat, amount, slot=InventorySlot.INPUT)
 
         # TD-271: Real Estate Utilization
@@ -925,8 +920,6 @@ class Firm(ILearningAgent, IFinancialFirm, IFinancialAgent, ILiquidatable, IOrch
         Ensures AI Debt Awareness and Budgeting accuracy.
         """
         # Local import to avoid circular dependency
-        # We rely on the concrete LoanMarket class because Firm is coupled to it via constructor.
-        # Ideally, we would use an interface ILoanMarket that exposes the bank or debt status directly.
         from simulation.loan_market import LoanMarket
 
         market = self.decision_engine.loan_market
@@ -969,21 +962,11 @@ class Firm(ILearningAgent, IFinancialFirm, IFinancialAgent, ILiquidatable, IOrch
 
         log_extra = {"tick": current_time, "agent_id": self.id, "tags": ["firm_action"]}
         current_assets_val = self.financial_component.get_balance(DEFAULT_CURRENCY)
-        self.logger.debug(
-            f"FIRM_DECISION_START | Firm {self.id} before decision: Assets={current_assets_val}, Employees={len(self.hr_state.employees)}, is_active={self.is_active}",
-            extra={
-                **log_extra,
-                "assets_before": self.financial_component.get_all_balances(),
-                "num_employees_before": len(self.hr_state.employees),
-                "is_active_before": self.is_active,
-            },
-        )
 
         # 1. State Snapshot
         snapshot = self.get_snapshot_dto()
 
         # 2. Finance Engine: Plan Budget
-        # TODO: credit_rating placeholder
         fin_input = FinanceDecisionInputDTO(
             firm_snapshot=snapshot,
             market_snapshot=market_snapshot,
@@ -994,31 +977,42 @@ class Firm(ILearningAgent, IFinancialFirm, IFinancialAgent, ILiquidatable, IOrch
         budget_plan = self.finance_engine.plan_budget(fin_input)
 
         # 3. HR Engine: Manage Workforce
-        labor_wage = DEFAULT_LABOR_WAGE # Default
+        labor_wage = DEFAULT_LABOR_WAGE
         if market_snapshot and market_snapshot.labor:
-            # Assuming labor market snapshot has avg_wage as int pennies or float
-            # MarketSnapshotDTO definition says LaborMarketSnapshotDTO.avg_wage is float.
-            # We need to cast to int pennies if it is float.
             labor_wage = int(market_snapshot.labor.avg_wage * 100) if market_snapshot.labor.avg_wage > 0 else DEFAULT_LABOR_WAGE
         elif market_data and "labor" in market_data:
-             # Fallback to dictionary
              labor_wage = int(market_data.get("labor", {}).get("avg_wage", 10.0) * 100)
 
-        hr_input = HRDecisionInputDTO(
-            firm_snapshot=snapshot,
-            budget_plan=budget_plan,
-            market_snapshot=market_snapshot,
-            config=self.config,
-            current_tick=current_time,
-            labor_market_avg_wage=labor_wage
-        )
-        hr_result = self.hr_engine.manage_workforce(hr_input)
+        # Build HR Context
+        target_headcount = self._calculate_target_headcount()
+        hr_context = self._build_hr_context(budget_plan, target_headcount, current_time, labor_wage)
 
-        # 4. Collect Engine Orders
-        engine_orders = []
-        engine_orders.extend(hr_result.hiring_orders)
+        # Call Decide
+        hr_intent = self.hr_engine.decide_workforce(hr_context)
 
-        # 5. Legacy Decision Engine (for Sales/Production)
+        # Apply HR Intent (Convert to Orders and update internal state maps)
+        # Note: Hiring orders are generated below. Wage updates are applied implicitly by intent-driven payroll later?
+        # No, payroll reads state. So we must update state.
+        for agent_id, wage in hr_intent.wage_updates.items():
+            # agent_id is AgentID (int), keys in employee_wages are int.
+            if int(agent_id) in self.hr_state.employee_wages:
+                self.hr_state.employee_wages[int(agent_id)] = wage
+
+        # Generate HR Orders
+        hr_orders = self._generate_hr_orders(hr_intent, hr_context)
+        engine_orders = hr_orders
+
+        # 4. Sales Engine: Decide Pricing & Sales
+        sales_context = self._build_sales_context(market_snapshot, current_time)
+        sales_intent = self.sales_engine.decide_pricing(sales_context)
+
+        # Apply Sales Intent
+        sales_orders = sales_intent.sales_orders
+        self.sales_state.last_prices.update(sales_intent.price_adjustments)
+        self.sales_state.marketing_budget_pennies = sales_intent.marketing_spend_pennies
+        self.sales_state.marketing_budget_rate = sales_intent.new_marketing_budget_rate
+
+        # 5. Legacy Decision Engine (for BUYING materials only)
         state_dto = self.get_state_dto()
         context = DecisionContext(
             state=state_dto,
@@ -1040,16 +1034,15 @@ class Firm(ILearningAgent, IFinancialFirm, IFinancialAgent, ILiquidatable, IOrch
         else:
             legacy_orders, tactic = decision_output
 
-        # Filter legacy orders: Remove HR related (BUY labor, FIRE) to defer to Engines
+        # Filter legacy orders: Keep only BUY orders for goods (exclude Labor, Fire, Sell)
         filtered_legacy = [
             o for o in legacy_orders
             if o.market_id != 'labor' and o.order_type != 'FIRE'
+            and getattr(o, 'side', o.order_type) != 'SELL'
         ]
 
-        # Merge orders: Engine First (Priority) or Legacy First?
-        # Engine is "Planned", Legacy is "RuleBased".
-        # Let's say Engine orders are authoritative for HR.
-        all_orders = engine_orders + filtered_legacy
+        # Merge orders
+        all_orders = engine_orders + filtered_legacy + sales_orders
 
         # Command Bus execution (Internal Orders like FIRE, SET_TARGET)
         self.execute_internal_orders(all_orders, fiscal_context, current_time, market_context)
@@ -1057,16 +1050,14 @@ class Firm(ILearningAgent, IFinancialFirm, IFinancialAgent, ILiquidatable, IOrch
         # Filter external orders for further processing
         external_orders = [o for o in all_orders if o.market_id != "internal"]
 
-        pricing_result = self.sales_engine.check_and_apply_dynamic_pricing(
-            self.sales_state, external_orders, current_time,
-            config=self.config,
-            unit_cost_estimator=lambda item_id: self.finance_engine.get_estimated_unit_cost(self.finance_state, item_id, self.config)
-        )
-
-        # Apply Dynamic Pricing Results (Stateless Orchestration)
-        external_orders = pricing_result.orders
-        self.sales_state.last_prices.update(pricing_result.price_updates)
-
+        # Note: Dynamic pricing and invisible hand price calc logic moved to decide_pricing,
+        # but _calculate_invisible_hand_price also logs shadow price.
+        # We can keep it for logging purposes if needed, but it updates state.
+        # Since decide_pricing handles price updates, we should skip state update in _calculate_invisible_hand_price
+        # or remove it.
+        # However, decide_pricing does NOT calculate shadow price.
+        # PricingEngine (which calculates shadow price) is distinct from SalesEngine.
+        # If we want shadow price logging, we should keep it.
         if market_snapshot:
              self._calculate_invisible_hand_price(market_snapshot, current_time)
 
@@ -1112,6 +1103,10 @@ class Firm(ILearningAgent, IFinancialFirm, IFinancialAgent, ILiquidatable, IOrch
         result = self.pricing_engine.calculate_price(input_dto)
 
         # 3. Update State (As per spec)
+        # We allow PricingEngine to also influence price, potentially overriding SalesEngine?
+        # Or SalesEngine already considered it?
+        # decide_pricing used current_prices.
+        # If we update prices here, they will be used next tick.
         self.sales_state.last_prices[item_id] = result.new_price
 
         log_shadow(
@@ -1176,6 +1171,168 @@ class Firm(ILearningAgent, IFinancialFirm, IFinancialAgent, ILiquidatable, IOrch
             brand_snapshot=brand_snapshot
         )
 
+    def _build_production_context(self, productivity_multiplier: float) -> ProductionContextDTO:
+        # Calculate derived values
+        num_employees = len(self.hr_state.employees)
+        total_labor_skill = sum(getattr(emp, "labor_skill", 1.0) for emp in self.hr_state.employees)
+        avg_skill = total_labor_skill / num_employees if num_employees > 0 else 0.0
+
+        item_config = self.config.goods.get(self.production_state.specialization, {})
+        tech_level = self.production_state.productivity_factor * productivity_multiplier
+
+        return ProductionContextDTO(
+            firm_id=AgentID(self.id),
+            tick=0,
+            budget_pennies=0,
+            market_snapshot=MarketSnapshotDTO(tick=0, market_signals={}, market_data={}),
+            available_cash_pennies=0,
+            is_solvent=True,
+
+            inventory_raw_materials=self.inventory_component.input_inventory.copy(),
+            inventory_finished_goods=self.inventory_component.main_inventory.copy(),
+            current_workforce_count=num_employees,
+            technology_level=tech_level,
+            production_efficiency=1.0,
+
+            capital_stock=self.production_state.capital_stock,
+            automation_level=self.production_state.automation_level,
+
+            input_goods=item_config.get("inputs", {}),
+            output_good_id=self.production_state.specialization,
+
+            labor_alpha=self.config.labor_alpha,
+            automation_labor_reduction=self.config.automation_labor_reduction,
+            labor_elasticity_min=self.config.labor_elasticity_min,
+            capital_depreciation_rate=self.config.capital_depreciation_rate,
+            specialization=self.production_state.specialization,
+            base_quality=self.production_state.base_quality,
+            quality_sensitivity=item_config.get("quality_sensitivity", 0.5),
+            employees_avg_skill=avg_skill
+        )
+
+    def _calculate_target_headcount(self) -> int:
+        item_id = self.production_state.specialization
+        target_quantity = self.production_state.production_target
+        current_inventory = self.get_quantity(item_id, InventorySlot.MAIN)
+        needed_production = max(0, target_quantity - current_inventory)
+        productivity_factor = self.production_state.productivity_factor
+        if productivity_factor <= 0: needed_labor = 999999.0
+        else: needed_labor = needed_production / productivity_factor
+        return int(needed_labor)
+
+    def _build_hr_context(self, budget_plan: BudgetPlanDTO, target_headcount: int, current_tick: int, labor_wage: int) -> HRContextDTO:
+        current_employees = [AgentID(e.id) for e in self.hr_state.employees]
+        employee_wages = {AgentID(e.id): self.hr_state.employee_wages.get(e.id, 0) for e in self.hr_state.employees}
+        employee_skills = {AgentID(e.id): getattr(e, "labor_skill", 1.0) for e in self.hr_state.employees}
+
+        return HRContextDTO(
+            firm_id=AgentID(self.id),
+            tick=current_tick,
+            budget_pennies=budget_plan.labor_budget_pennies,
+            market_snapshot=MarketSnapshotDTO(tick=0, market_signals={}, market_data={}),
+            available_cash_pennies=0,
+            is_solvent=True,
+
+            current_employees=current_employees,
+            current_headcount=len(current_employees),
+            employee_wages=employee_wages,
+            employee_skills=employee_skills,
+            target_workforce_count=target_headcount,
+            labor_market_avg_wage=labor_wage,
+            marginal_labor_productivity=0.0,
+            happiness_avg=0.0,
+
+            profit_history=list(self.finance_state.profit_history),
+
+            min_employees=getattr(self.config, 'firm_min_employees', 1),
+            max_employees=getattr(self.config, 'firm_max_employees', 100),
+            severance_pay_weeks=getattr(self.config, 'severance_pay_weeks', 2)
+        )
+
+    def _generate_hr_orders(self, intent: HRIntentDTO, context: HRContextDTO) -> List[Order]:
+        orders = []
+        # Firing
+        for emp_id in intent.fire_employee_ids:
+            # Need wage/skill again, context has them
+            current_wage = context.employee_wages.get(emp_id, 1000)
+            skill = context.employee_skills.get(emp_id, 1.0)
+            severance_pay = int(current_wage * context.severance_pay_weeks * skill)
+
+            orders.append(Order(
+                agent_id=self.id,
+                side='FIRE',
+                item_id='internal',
+                quantity=1,
+                price_pennies=severance_pay,
+                price_limit=float(severance_pay)/100.0,
+                market_id='internal',
+                target_agent_id=int(emp_id)
+            ))
+
+        # Hiring
+        if intent.hiring_target > 0:
+            # Recalculate offered wage logic or infer.
+            # Using same logic as engine for consistency.
+            base_wage = context.labor_market_avg_wage
+            sensitivity = 0.1
+            max_premium = 2.0
+            profit_history = context.profit_history
+            avg_profit = sum(profit_history) / len(profit_history) if profit_history else 0.0
+            profit_based_premium = avg_profit / (base_wage * 10.0) if base_wage > 0 else 0.0
+            wage_premium = max(0, min(profit_based_premium * sensitivity, max_premium))
+            offered_wage = int(base_wage * (1 + wage_premium))
+
+            orders.append(Order(
+                agent_id=self.id,
+                side='BUY',
+                item_id='labor',
+                quantity=float(intent.hiring_target),
+                price_pennies=offered_wage,
+                price_limit=float(offered_wage)/100.0,
+                market_id='labor'
+            ))
+        return orders
+
+    def _build_sales_context(self, market_snapshot: MarketSnapshotDTO, current_tick: int) -> SalesContextDTO:
+        # Competitor prices
+        competitor_prices = {}
+        if market_snapshot and market_snapshot.market_signals:
+            for k, v in market_snapshot.market_signals.items():
+                if v.last_traded_price:
+                    competitor_prices[k] = v.last_traded_price
+
+        return SalesContextDTO(
+            firm_id=AgentID(self.id),
+            tick=current_tick,
+            budget_pennies=0,
+            market_snapshot=market_snapshot or MarketSnapshotDTO(tick=0, market_signals={}, market_data={}),
+            available_cash_pennies=0,
+            is_solvent=True,
+
+            inventory_to_sell=self.inventory_component.main_inventory.copy(),
+            current_prices=self.sales_state.last_prices.copy(),
+            previous_sales_volume=self.sales_volume_this_tick, # Wait, this tick volume?
+            # context.previous_sales_volume. Logic uses it for "inventory pressure".
+            # sales_volume_this_tick is reset at end of tick.
+            # At make_decision, sales_volume_this_tick is 0 (reset happened in reset_finance).
+            # So we need "last tick's volume".
+            # We don't seem to track it explicitly in SalesState?
+            # Only `inventory_last_sale_tick`.
+            # I will pass 0 for now as it seems unused in `decide_pricing` logic I wrote.
+            competitor_prices=competitor_prices,
+
+            marketing_budget_rate=self.sales_state.marketing_budget_rate,
+            brand_awareness=self.sales_state.brand_awareness,
+            perceived_quality=self.sales_state.perceived_quality,
+            inventory_quality=self.inventory_component.inventory_quality.copy(),
+            last_revenue_pennies=self.finance_state.last_revenue_pennies,
+            last_marketing_spend_pennies=self.finance_state.last_marketing_spend_pennies,
+            inventory_last_sale_tick=self.sales_state.inventory_last_sale_tick.copy(),
+
+            sale_timeout_ticks=getattr(self.config, 'sale_timeout_ticks', 10),
+            dynamic_price_reduction_factor=getattr(self.config, 'dynamic_price_reduction_factor', 0.9)
+        )
+
     def generate_transactions(self, government: Optional[Any], market_data: Dict[str, Any], shareholder_registry: IShareholderRegistry, current_time: int, market_context: MarketContextDTO) -> List[Transaction]:
         transactions = []
         gov_id = government.id if government else None
@@ -1228,24 +1385,8 @@ class Firm(ILearningAgent, IFinancialFirm, IFinancialAgent, ILiquidatable, IOrch
         transactions.extend(tx_finance)
 
         # 3. Marketing
-        # Adjust budget first (ask Engine what the budget should be)
-        # Calculate total revenue for this turn
-        exchange_rates = market_context.get("exchange_rates", {DEFAULT_CURRENCY: 1.0})
-        total_revenue_this_turn = 0.0
-        for cur, amount in self.finance_state.revenue_this_turn.items():
-             rate = exchange_rates.get(cur, 1.0) if cur != DEFAULT_CURRENCY else 1.0
-             total_revenue_this_turn += float(amount) * rate
-
-        marketing_result = self.sales_engine.adjust_marketing_budget(
-            self.sales_state,
-            market_context,
-            total_revenue_this_turn,
-            last_revenue=float(self.finance_state.last_revenue_pennies),
-            last_marketing_spend=float(self.finance_state.last_marketing_spend_pennies)
-        )
-        # Apply result
-        self.sales_state.marketing_budget_pennies = marketing_result.new_budget
-        self.sales_state.marketing_budget_rate = marketing_result.new_marketing_rate
+        # Use marketing budget set during make_decision
+        # No need to call adjust_marketing_budget again!
 
         # Then generate transaction using the updated state
         marketing_context = self._build_sales_marketing_context(current_time, government)
@@ -1269,184 +1410,4 @@ class Firm(ILearningAgent, IFinancialFirm, IFinancialAgent, ILiquidatable, IOrch
         self.sales_state.brand_awareness = brand_metrics.brand_awareness
         self.sales_state.perceived_quality = brand_metrics.perceived_quality
 
-        # WO-4.6: Finance cleanup is now handled in Post-Sequence via reset()
-        # This ensures expenses_this_tick accumulates for the full tick duration.
-
         return transactions
-
-    @override
-    def update_needs(self, current_time: int, government: Optional[Any] = None, market_data: Optional[Dict[str, Any]] = None, technology_manager: Optional[Any] = None) -> None:
-        pass
-
-    # --- IPropertyOwner Implementation ---
-    @property
-    def owned_properties(self) -> List[int]:
-        return self.finance_state.owned_properties
-
-    def add_property(self, property_id: int) -> None:
-        if property_id not in self.finance_state.owned_properties:
-            self.finance_state.owned_properties.append(property_id)
-
-    def remove_property(self, property_id: int) -> None:
-        if property_id in self.finance_state.owned_properties:
-            self.finance_state.owned_properties.remove(property_id)
-
-    # --- IFinancialEntity & IFinancialFirm Implementation ---
-
-    @property
-    def balance_pennies(self) -> int:
-        return self.financial_component.balance_pennies
-
-    @property
-    def capital_stock_pennies(self) -> int:
-        return int(self.production_state.capital_stock)
-
-    @property
-    def inventory_value_pennies(self) -> int:
-        # last_prices are now int pennies
-        val = sum(self.get_quantity(i) * self.last_prices.get(i, DEFAULT_PRICE) for i in self.get_all_items())
-        return int(val)
-
-    @property
-    def monthly_wage_bill_pennies(self) -> int:
-        total_wages = sum(self.hr_state.employee_wages.values())
-        return int(total_wages * 4)
-
-    @property
-    def total_debt_pennies(self) -> int:
-        return self.finance_state.total_debt_pennies
-
-    @property
-    def retained_earnings_pennies(self) -> int:
-        return self.finance_state.retained_earnings_pennies
-
-    @property
-    def average_profit_pennies(self) -> int:
-        history = self.finance_state.profit_history
-        if not history:
-            return 0
-        return int(sum(history) / len(history))
-
-    def deposit(self, amount_pennies: int, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
-         self.financial_component.deposit(amount_pennies, currency)
-
-    def withdraw(self, amount_pennies: int, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
-         self.financial_component.withdraw(amount_pennies, currency)
-
-    # --- IFinancialAgent Implementation ---
-
-    def _deposit(self, amount: int, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
-         self.financial_component._deposit(amount, currency)
-
-    def _withdraw(self, amount: int, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
-         self.financial_component._withdraw(amount, currency)
-
-    def get_balance(self, currency: CurrencyCode = DEFAULT_CURRENCY) -> int:
-        """Implements IFinancialAgent.get_balance."""
-        return self.financial_component.get_balance(currency)
-
-    def get_all_balances(self) -> Dict[CurrencyCode, int]:
-        """Returns a copy of all currency balances."""
-        return self.financial_component.get_all_balances()
-
-    @property
-    def total_wealth(self) -> int:
-        """
-        Returns the total wealth in default currency estimation.
-        TD-270: Standardized multi-currency summation.
-        """
-        return self.financial_component.total_wealth
-
-    @override
-    def get_assets_by_currency(self) -> Dict[CurrencyCode, int]:
-        """Implementation of ICurrencyHolder."""
-        return self.financial_component.get_all_balances()
-
-    # --- Facade Methods ---
-
-    def get_book_value_per_share(self) -> float:
-        outstanding = self.total_shares - self.treasury_shares
-        if outstanding <= 0: return 0.0
-        net_assets = self.financial_component.get_balance(DEFAULT_CURRENCY) - self.finance_state.total_debt_pennies
-        return max(0.0, float(net_assets)) / outstanding
-
-    def get_market_cap(self, stock_price: Optional[float] = None) -> float:
-        if stock_price is None:
-            stock_price = self.get_book_value_per_share()
-        return (self.total_shares - self.treasury_shares) * stock_price
-
-    def calculate_valuation(self, market_context: MarketContextDTO = None) -> int:
-        inventory_value = int(sum(self.get_quantity(i) * self.last_prices.get(i, DEFAULT_PRICE) for i in self.get_all_items()))
-        # Wrap market_context in FinancialTransactionContext if needed, or update Engine to accept optional context
-        # Engine expects FinancialTransactionContext.
-        fin_ctx = None
-        if market_context:
-            fin_ctx = FinancialTransactionContext(
-                government_id=None, # Not needed for valuation?
-                tax_rates={},
-                market_context=market_context,
-                shareholder_registry=None
-            )
-
-        return int(self.finance_engine.calculate_valuation(
-            self.finance_state, self.financial_component.get_all_balances(), self.config, inventory_value, int(self.capital_stock), fin_ctx
-        ))
-
-    def get_financial_snapshot(self) -> Dict[str, Any]:
-        inventory_value = int(sum(self.get_quantity(i) * self.last_prices.get(i, DEFAULT_PRICE) for i in self.get_all_items()))
-        cash = self.financial_component.get_balance(DEFAULT_CURRENCY)
-        total_assets = cash + inventory_value + self.capital_stock
-        working_capital = cash + inventory_value # Simplified: Current Assets
-
-        return {
-             "wallet": MultiCurrencyWalletDTO(balances=self.financial_component.get_all_balances()),
-             "total_assets": int(total_assets),
-             "total_debt": self.finance_state.total_debt_pennies,
-             "retained_earnings": self.finance_state.retained_earnings_pennies,
-             "average_profit": sum(self.finance_state.profit_history)/len(self.finance_state.profit_history) if self.finance_state.profit_history else 0.0,
-             "working_capital": int(working_capital),
-             "ebit": self.finance_state.current_profit.get(DEFAULT_CURRENCY, 0), # Current EBIT proxy
-             "market_value_equity": self.get_market_cap()
-        }
-
-    def update_learning(self, context: LearningUpdateContext) -> None:
-        reward = context["reward"]
-        next_agent_data = context["next_agent_data"]
-        next_market_data = context["next_market_data"]
-        if hasattr(self.decision_engine, 'ai_engine'):
-            td_error = self.decision_engine.ai_engine.update_learning_v2(
-                reward=reward,
-                next_agent_data=next_agent_data,
-                next_market_data=next_market_data,
-            )
-
-            # Phase 4.1: Active Learning (Insight Dynamics)
-            # Decay
-            self.market_insight = max(0.0, self.market_insight - INSIGHT_DECAY_RATE)
-
-            # Boost from Learning Surprise (TD-Error)
-            if isinstance(td_error, (int, float)):
-                # Normalized boost using exponential saturation
-                # Assuming significant error starts around 1000 pennies (10.00)
-                boost = INSIGHT_BOOST_FACTOR * (1.0 - math.exp(-abs(td_error) / INSIGHT_ERROR_THRESHOLD))
-                self.market_insight = min(1.0, self.market_insight + boost)
-
-        # Update State Tracking for Rewards (Moved from Engine for Purity)
-        self.prev_awareness = self.sales_state.brand_awareness
-        self.prev_avg_quality = self.production_state.base_quality
-
-    def reset_finance(self) -> None:
-        """
-        Resets the financial state for the next tick.
-        Called by the simulation orchestrator's post-processing phase.
-        Delegates to FinanceState.
-        """
-        self.finance_state.reset_tick_counters(DEFAULT_CURRENCY)
-        self.sales_volume_this_tick = 0.0
-
-    def reset(self) -> None:
-        """
-        Alias for reset_finance.
-        Called by the simulation orchestrator for general agent reset.
-        """
-        self.reset_finance()
diff --git a/tests/simulation/components/engines/test_firm_decoupling.py b/tests/simulation/components/engines/test_firm_decoupling.py
new file mode 100644
index 00000000..46ad578e
--- /dev/null
+++ b/tests/simulation/components/engines/test_firm_decoupling.py
@@ -0,0 +1,68 @@
+import pytest
+from modules.firm.api import (
+    ProductionContextDTO, HRContextDTO, SalesContextDTO,
+    ProductionIntentDTO, HRIntentDTO, SalesIntentDTO
+)
+from simulation.components.engines.production_engine import ProductionEngine
+from simulation.components.engines.hr_engine import HREngine
+from simulation.components.engines.sales_engine import SalesEngine
+from modules.simulation.api import AgentID
+from modules.system.api import MarketSnapshotDTO
+
+def test_production_engine_decoupled():
+    engine = ProductionEngine()
+    context = ProductionContextDTO(
+        firm_id=AgentID(1), tick=10, budget_pennies=10000, market_snapshot=MarketSnapshotDTO(10, {}, {}), available_cash_pennies=10000, is_solvent=True,
+        inventory_raw_materials={'RAW': 100.0}, inventory_finished_goods={}, current_workforce_count=10,
+        technology_level=1.0, production_efficiency=1.0, capital_stock=100.0, automation_level=0.0,
+        input_goods={'RAW': 2.0}, output_good_id='WIDGET', labor_alpha=0.5, automation_labor_reduction=0.0,
+        labor_elasticity_min=0.1, capital_depreciation_rate=0.01, specialization='WIDGET', base_quality=1.0,
+        quality_sensitivity=0.5, employees_avg_skill=1.0
+    )
+
+    intent = engine.decide_production(context)
+
+    assert intent.target_production_quantity > 0
+    assert 'RAW' in intent.materials_to_use
+    assert intent.materials_to_use['RAW'] == intent.target_production_quantity * 2.0
+    assert intent.capital_depreciation > 0
+
+def test_hr_engine_decoupled():
+    engine = HREngine()
+    # Scenario: Established firm (headcount=1) expanding to target (5)
+    context = HRContextDTO(
+        firm_id=AgentID(1), tick=10, budget_pennies=100000, market_snapshot=MarketSnapshotDTO(10, {}, {}), available_cash_pennies=100000, is_solvent=True,
+        current_employees=[AgentID(1)], current_headcount=1, employee_wages={AgentID(1): 1000}, employee_skills={AgentID(1): 1.0},
+        target_workforce_count=5, labor_market_avg_wage=1000, marginal_labor_productivity=1.0, happiness_avg=1.0,
+        profit_history=[1000], min_employees=1, max_employees=100, severance_pay_weeks=2
+    )
+
+    intent = engine.decide_workforce(context)
+
+    assert intent.hiring_target == 4 # Expanding from 1 to 5
+    assert len(intent.fire_employee_ids) == 0
+
+def test_sales_engine_decoupled():
+    engine = SalesEngine()
+    context = SalesContextDTO(
+        firm_id=AgentID(1), tick=20, budget_pennies=0, market_snapshot=MarketSnapshotDTO(20, {}, {}), available_cash_pennies=0, is_solvent=True,
+        inventory_to_sell={'WIDGET': 10.0}, current_prices={'WIDGET': 1000}, previous_sales_volume=0.0, competitor_prices={},
+        marketing_budget_rate=0.05, brand_awareness=0.5, perceived_quality=1.0, inventory_quality={'WIDGET': 1.0},
+        last_revenue_pennies=10000, last_marketing_spend_pennies=500, inventory_last_sale_tick={'WIDGET': 5},
+        sale_timeout_ticks=10, dynamic_price_reduction_factor=0.9
+    )
+
+    intent = engine.decide_pricing(context)
+
+    # 20 - 5 = 15 > 10 (timeout) -> Discount
+    assert len(intent.sales_orders) == 1
+    assert intent.sales_orders[0].item_id == 'WIDGET'
+    assert intent.sales_orders[0].price_pennies < 1000
+    assert 'WIDGET' in intent.price_adjustments
+
+    # Marketing Budget
+    # ROI: Revenue 10000 / Spend 500 = 20 > 2.0 -> Increase Rate (0.05 * 1.1)
+    # Target = 10000 * (0.05*1.1) = 550
+    # Smoothed = 500*0.8 + 550*0.2 = 400 + 110 = 510
+    assert intent.marketing_spend_pennies > 0
+    assert intent.marketing_spend_pennies == 510 # Or close to it
diff --git a/tests/simulation/components/engines/test_production_engine.py b/tests/simulation/components/engines/test_production_engine.py
index 31a7b93f..6897fa9a 100644
--- a/tests/simulation/components/engines/test_production_engine.py
+++ b/tests/simulation/components/engines/test_production_engine.py
@@ -12,6 +12,7 @@ def production_engine():
 @pytest.fixture
 def firm_snapshot():
     snapshot = MagicMock(spec=FirmSnapshotDTO)
+    snapshot.id = 1 # ID needed for AgentID
 
     # Config
     config = MagicMock(spec=FirmConfigDTO)
@@ -35,6 +36,7 @@ def firm_snapshot():
     prod.base_quality = 1.0
     prod.specialization = "FOOD"
     prod.input_inventory = {"RAW_MAT": 1000.0}
+    prod.inventory = {} # Finished goods inventory
     snapshot.production = prod
 
     # HR State
diff --git a/tests/simulation/test_firm_refactor.py b/tests/simulation/test_firm_refactor.py
index 9eb046ac..8e42dce0 100644
--- a/tests/simulation/test_firm_refactor.py
+++ b/tests/simulation/test_firm_refactor.py
@@ -7,7 +7,7 @@ from simulation.models import Order
 from modules.system.api import DEFAULT_CURRENCY, MarketContextDTO
 from modules.simulation.api import AgentCoreConfigDTO
 from modules.hr.api import IEmployeeDataProvider
-from modules.firm.api import AssetManagementResultDTO, RDResultDTO, ProductionResultDTO
+from modules.firm.api import AssetManagementResultDTO, RDResultDTO, ProductionResultDTO, ProductionIntentDTO
 
 @pytest.fixture
 def mock_decision_engine():
@@ -90,7 +90,7 @@ def test_command_bus_internal_orders_delegation(firm):
     assert firm.production_state.base_quality > 0.0
 
 def test_produce_orchestration(firm):
-    firm.production_engine.produce.return_value = ProductionResultDTO(success=True, quantity_produced=10.0, quality=1.5, specialization='FOOD', inputs_consumed={'RAW': 5.0}, production_cost=50.0, capital_depreciation=5.0, automation_decay=0.01)
+    firm.production_engine.decide_production.return_value = ProductionIntentDTO(target_production_quantity=10.0, quality=1.5, materials_to_use={'RAW': 5.0}, estimated_cost_pennies=5000, capital_depreciation=5, automation_decay=0.01)
     from modules.simulation.api import InventorySlot
     firm.production_state.capital_stock = 100.0
     firm.production_state.automation_level = 0.5
@@ -101,4 +101,4 @@ def test_produce_orchestration(firm):
     assert firm.get_quantity('RAW', slot=InventorySlot.INPUT) == 5.0
     assert firm.current_production == 10.0
     assert firm.get_quantity('FOOD') == 10.0
-    firm.production_engine.produce.assert_called_once()
\ No newline at end of file
+    firm.production_engine.decide_production.assert_called_once()
\ No newline at end of file
