diff --git a/communications/insights/market-precision-refactor.md b/communications/insights/market-precision-refactor.md
new file mode 100644
index 00000000..364c44b3
--- /dev/null
+++ b/communications/insights/market-precision-refactor.md
@@ -0,0 +1,51 @@
+# Insight Report: Market Precision Refactor
+
+## 1. Architectural Insights
+- **Penny Standard Adoption**: The `OrderBookMatchingEngine` and `StockMatchingEngine` now operate exclusively on `int` pennies. This eliminates floating-point drift in price discovery and execution.
+- **DTO Migration**: `CanonicalOrderDTO` now enforces `price_pennies: int`. The legacy `price_limit: float` is retained but deprecated. `convert_legacy_order_to_canonical` bridges the gap by treating floats as dollars (converting to pennies via `* 100`) and ints as pennies.
+- **Transaction SSoT**: The `Transaction` model now carries `total_pennies: int` as the Single Source of Truth for settlement. `price` (float) is a derived value (`(total_pennies / quantity) / 100.0`) representing Dollars. This ensures `SettlementSystem` receives exact integer amounts while maintaining legacy UI compatibility.
+- **Display Price (Dollars)**: A critical decision was made to ensure `Transaction.price` represents Dollars (float), not Pennies. This maintains semantic compatibility with legacy agents and dashboards. Tests were updated to reflect this expectation (e.g., $1.02 instead of 102.0 pennies).
+
+## 2. Test Evidence
+All relevant tests passed, including new precision tests and updated legacy tests.
+
+```text
+tests/unit/test_markets_v2.py::TestOrderBookMarketInitialization::test_market_initialization PASSED
+tests/unit/test_markets_v2.py::TestPlaceOrderToBook::test_add_single_buy_order PASSED
+tests/unit/test_markets_v2.py::TestPlaceOrderToBook::test_add_buy_orders_sorted PASSED
+tests/unit/test_markets_v2.py::TestPlaceOrderToBook::test_add_sell_orders_sorted PASSED
+tests/unit/test_markets_v2.py::TestPlaceOrderToBook::test_add_orders_with_same_price PASSED
+tests/unit/test_markets_v2.py::TestOrderMatching::test_unfilled_order_no_match PASSED
+tests/unit/test_markets_v2.py::TestOrderMatching::test_full_match_one_to_one PASSED
+tests/unit/test_markets_v2.py::TestOrderMatching::test_partial_match_then_book PASSED
+tests/unit/test_markets_v2.py::TestOrderMatching::test_match_with_multiple_orders PASSED
+tests/unit/test_markets_v2.py::TestMarketAPI::test_get_best_bid_empty PASSED
+tests/unit/test_markets_v2.py::TestMarketAPI::test_get_best_bid_non_empty PASSED
+tests/unit/test_markets_v2.py::TestMarketAPI::test_get_best_ask_empty PASSED
+tests/unit/test_markets_v2.py::TestMarketAPI::test_get_best_ask_non_empty PASSED
+tests/unit/test_markets_v2.py::TestMarketAPI::test_get_last_traded_price PASSED
+tests/unit/test_markets_v2.py::TestMarketAPI::test_get_spread PASSED
+tests/unit/test_markets_v2.py::TestMarketAPI::test_get_spread_no_bid_or_ask PASSED
+tests/unit/test_markets_v2.py::TestMarketAPI::test_get_market_depth PASSED
+tests/unit/test_stock_market.py::TestStockMarketInitialization::test_initialization PASSED
+tests/unit/test_stock_market.py::TestStockMarketInitialization::test_update_reference_prices PASSED
+tests/unit/test_stock_market.py::TestStockOrderPlacement::test_place_buy_order PASSED
+tests/unit/test_stock_market.py::TestStockOrderPlacement::test_place_sell_order PASSED
+tests/unit/test_stock_market.py::TestStockOrderPlacement::test_price_clamping PASSED
+tests/unit/test_stock_market.py::TestStockOrderPlacement::test_order_sorting PASSED
+tests/unit/test_stock_market.py::TestStockOrderMatching::test_full_match PASSED
+tests/unit/test_stock_market.py::TestStockOrderMatching::test_partial_match PASSED
+tests/unit/test_stock_market.py::TestOrderExpiry::test_clear_expired_orders PASSED
+tests/unit/test_market_adapter.py::TestMarketAdapter::test_pass_through PASSED
+tests/unit/test_market_adapter.py::TestMarketAdapter::test_convert_stock_order PASSED
+tests/unit/test_market_adapter.py::TestMarketAdapter::test_convert_dict_legacy_format PASSED
+tests/unit/test_market_adapter.py::TestMarketAdapter::test_convert_dict_canonical_format PASSED
+tests/unit/test_market_adapter.py::TestMarketAdapter::test_invalid_input PASSED
+tests/market/test_precision_matching.py::TestPrecisionMatching::test_labor_market_pricing PASSED
+tests/market/test_precision_matching.py::TestPrecisionMatching::test_market_fractional_qty_rounding PASSED
+tests/market/test_precision_matching.py::TestPrecisionMatching::test_market_zero_sum_integer PASSED
+```
+
+## 3. Risks & Recommendations
+- **Legacy DTOs**: `StockOrder` is deprecated but supported. The conversion logic now assumes `float` inputs are Dollars and `int` inputs are Pennies. This is a heuristic that should be monitored.
+- **Agent Awareness**: Agents must continue to treat `Transaction.price` as Dollars. If they access `total_pennies`, they get the exact settlement value.
diff --git a/design/2_operations/ledgers/TECH_DEBT_LEDGER.md b/design/2_operations/ledgers/TECH_DEBT_LEDGER.md
index b6ecc4a9..ae1835c9 100644
--- a/design/2_operations/ledgers/TECH_DEBT_LEDGER.md
+++ b/design/2_operations/ledgers/TECH_DEBT_LEDGER.md
@@ -2,7 +2,7 @@
 
 | ID | Module / Component | Description | Priority / Impact | Status |
 | :--- | :--- | :--- | :--- | :--- |
-| **TD-MKT-FLOAT-MATCH** | Markets | **Market Precision Leak**: `MatchingEngine` uses `float` for price discovery. Violates Zero-Sum. | **Critical**: Financial Halo. | **Identified** |
+| **TD-MKT-FLOAT-MATCH** | Markets | **Market Precision Leak**: `MatchingEngine` uses `float` for price discovery. Violates Zero-Sum. | **Critical**: Financial Halo. | **Resolved** |
 | **TD-ARCH-LIFE-GOD** | Systems | **God Manager**: `LifecycleManager` monolithically handles Birth, Death, Aging, Liquidation. | **Medium**: Coupling. | **Identified** |
 | **TD-CONF-GHOST-BIND** | Config | **Ghost Constants**: Modules bind config values at import time, preventing runtime hot-swap. | **Medium**: Dynamic Tuning. | **Identified** |
 | **TD-INT-PENNIES-FRAGILITY** | System | **Penny-Float Duality**: Widespread `hasattr`/`getattr` for `xxx_pennies` vs `xxx`. Needs Unified API. | **High**: Logic Inconsistency. | **Resolved** |
diff --git a/modules/market/api.py b/modules/market/api.py
index 48272cb1..06433a75 100644
--- a/modules/market/api.py
+++ b/modules/market/api.py
@@ -24,7 +24,8 @@ class CanonicalOrderDTO:
     side: str  # "BUY" or "SELL" (formerly order_type)
     item_id: str
     quantity: float
-    price_limit: int # (formerly price) - Max for BUY, Min for SELL - Changed to int (pennies)
+    price_pennies: int # Integer pennies (The SSoT)
+    price_limit: float # Legacy float representation (for UI/Logging) - DEPRECATED
     market_id: str
 
     # Phase 6/7 Extensions
@@ -40,7 +41,7 @@ class CanonicalOrderDTO:
     id: str = field(default_factory=lambda: str(uuid.uuid4()), init=False)
 
     @property
-    def price(self) -> int:
+    def price(self) -> float:
         """Alias for legacy compatibility during migration."""
         return self.price_limit
 
@@ -66,12 +67,38 @@ def convert_legacy_order_to_canonical(order: Any) -> CanonicalOrderDTO:
         if not item_id and order.get("firm_id"):
              item_id = f"stock_{order.get('firm_id')}"
 
+        # Determine price
+        raw_price = order.get("price_limit") or order.get("price", 0)
+        price_pennies = order.get("price_pennies")
+
+        if price_pennies is None:
+            if isinstance(raw_price, float):
+                 # Assume Dollars -> Convert to Pennies
+                 price_pennies = int(raw_price * 100)
+            elif isinstance(raw_price, str):
+                 # Try convert to float first
+                 try:
+                     val = float(raw_price)
+                     # Heuristic: if it looks like an int (e.g. "1050"), treat as pennies?
+                     # But "10.50" becomes 10.5.
+                     # If string has decimal, assume dollars.
+                     if "." in raw_price:
+                         price_pennies = int(val * 100)
+                     else:
+                         price_pennies = int(val)
+                 except ValueError:
+                     price_pennies = 0
+            else:
+                 # Assume Pennies (int)
+                 price_pennies = int(raw_price)
+
         return CanonicalOrderDTO(
             agent_id=order.get("agent_id"),
             side=order.get("side") or order.get("order_type"),
             item_id=item_id,
             quantity=order.get("quantity"),
-            price_limit=int(order.get("price_limit") or order.get("price", 0)), # Force int
+            price_pennies=price_pennies,
+            price_limit=float(raw_price),
             market_id=order.get("market_id", "stock_market"),
             target_agent_id=order.get("target_agent_id"),
             brand_info=order.get("brand_info"),
@@ -82,12 +109,19 @@ def convert_legacy_order_to_canonical(order: Any) -> CanonicalOrderDTO:
 
     # Handle Legacy StockOrder (duck typing to avoid circular import)
     if hasattr(order, "firm_id") and hasattr(order, "order_type") and hasattr(order, "price"):
+        # Determine price_pennies based on type of order.price
+        if isinstance(order.price, float):
+            price_pennies = int(order.price * 100)
+        else:
+            price_pennies = int(order.price)
+
         return CanonicalOrderDTO(
             agent_id=order.agent_id,
             side=order.order_type,
             item_id=f"stock_{order.firm_id}",
             quantity=order.quantity,
-            price_limit=int(order.price), # Force int
+            price_pennies=price_pennies,
+            price_limit=float(order.price),
             market_id=getattr(order, "market_id", "stock_market"),
         )
 
diff --git a/simulation/markets/matching_engine.py b/simulation/markets/matching_engine.py
index 10169b87..97a7c0f9 100644
--- a/simulation/markets/matching_engine.py
+++ b/simulation/markets/matching_engine.py
@@ -14,6 +14,7 @@ class OrderBookMatchingEngine(IMatchingEngine):
     """
     Stateless matching engine for Goods and Labor markets.
     Implements price-time priority and targeted (brand loyalty) matching.
+    Uses Integer Math (Pennies) for Zero-Sum Integrity.
     """
 
     def match(self, state: OrderBookStateDTO, current_tick: int) -> MatchingResultDTO:
@@ -82,25 +83,18 @@ class OrderBookMatchingEngine(IMatchingEngine):
         targeted_buys = [o for o in buy_orders if o.target_agent_id is not None]
         general_buys = [o for o in buy_orders if o.target_agent_id is None]
 
-        # Sort general buys by price (desc)
-        general_buys.sort(key=lambda o: o.price_limit, reverse=True)
+        # Sort general buys by price_pennies (desc)
+        general_buys.sort(key=lambda o: o.price_pennies, reverse=True)
 
         # Organize sells for targeted lookup
         sell_map: Dict[int, List[CanonicalOrderDTO]] = {}
         for s_order in sell_orders:
-             # Need mutable wrapper or copy to track quantity consumed
-             # Since CanonicalOrderDTO is frozen, we will create new instances or track reduction
-             # To keep it simple, let's convert to a mutable structure locally
-             # But wait, we need to return CanonicalOrderDTOs.
-             # We will track reduced quantities.
              agent_id = int(s_order.agent_id) if isinstance(s_order.agent_id, (int, float)) else s_order.agent_id
-             # Assuming agent_id is int for firms/households usually.
              if agent_id not in sell_map:
                  sell_map[agent_id] = []
              sell_map[agent_id].append(s_order)
 
         # Helper to manage mutable state of orders during matching
-        # We'll use a wrapper class locally
         class MutableOrder:
             def __init__(self, dto: CanonicalOrderDTO):
                 self.dto = dto
@@ -117,9 +111,9 @@ class OrderBookMatchingEngine(IMatchingEngine):
         all_mutable_sells: List[MutableOrder] = []
 
         for s_list in sell_map.values():
-            s_list.sort(key=lambda o: o.price_limit) # Sort sells by price asc
+            s_list.sort(key=lambda o: o.price_pennies) # Sort sells by price_pennies asc
             m_list = [MutableOrder(o) for o in s_list]
-            mutable_sell_map[s_list[0].agent_id] = m_list
+            mutable_sell_map[s_list[0].agent_id] = m_list # Use agent_id directly
             all_mutable_sells.extend(m_list)
 
         # --- Phase 6: Targeted Matching ---
@@ -131,21 +125,25 @@ class OrderBookMatchingEngine(IMatchingEngine):
             target_asks = mutable_sell_map.get(target_id)
 
             if target_asks:
-                # Iterate through seller's asks
-                # Note: target_asks is already sorted by price ASC
+                # Iterate through seller's asks (Sorted by Price Asc)
                 for s_wrapper in target_asks:
                     if b_wrapper.remaining_qty <= 1e-9: break
                     if s_wrapper.remaining_qty <= 1e-9: continue
 
-                    # Price Check
-                    if b_wrapper.dto.price_limit >= s_wrapper.dto.price_limit:
-                        trade_price = s_wrapper.dto.price_limit # Pay Ask Price for Loyalty
+                    # Price Check (Integer)
+                    if b_wrapper.dto.price_pennies >= s_wrapper.dto.price_pennies:
+                        trade_price_pennies = s_wrapper.dto.price_pennies # Pay Ask Price for Loyalty
                         trade_qty = min(b_wrapper.remaining_qty, s_wrapper.remaining_qty)
 
+                        trade_total_pennies = int(trade_price_pennies * trade_qty)
+                        # Effective Price in Dollars (for display/legacy)
+                        effective_price_dollars = (trade_total_pennies / trade_qty) / 100.0 if trade_qty > 0 else 0.0
+
                         tx = Transaction(
                              item_id=item_id,
                              quantity=trade_qty,
-                             price=trade_price,
+                             price=effective_price_dollars,
+                             total_pennies=trade_total_pennies,
                              buyer_id=b_wrapper.dto.agent_id,
                              seller_id=s_wrapper.dto.agent_id,
                              market_id=market_id,
@@ -154,7 +152,7 @@ class OrderBookMatchingEngine(IMatchingEngine):
                              quality=s_wrapper.dto.brand_info.get("quality", 1.0) if s_wrapper.dto.brand_info else 1.0
                         )
                         transactions.append(tx)
-                        stats["last_price"] = trade_price
+                        stats["last_price"] = effective_price # Keep float for stats compatibility
                         stats["volume"] += trade_qty
 
                         b_wrapper.remaining_qty -= trade_qty
@@ -167,11 +165,11 @@ class OrderBookMatchingEngine(IMatchingEngine):
         if remaining_targeted_buys:
             mutable_general_buys.extend(remaining_targeted_buys)
             # Re-sort general buys by price desc to maintain priority
-            mutable_general_buys.sort(key=lambda o: o.dto.price_limit, reverse=True)
+            mutable_general_buys.sort(key=lambda o: o.dto.price_pennies, reverse=True)
 
         # Collect all remaining sells for general matching and sort
         active_sells = [s for s in all_mutable_sells if s.remaining_qty > 1e-9]
-        active_sells.sort(key=lambda o: o.dto.price_limit)
+        active_sells.sort(key=lambda o: o.dto.price_pennies)
 
         # --- General Matching ---
         idx_b = 0
@@ -188,19 +186,25 @@ class OrderBookMatchingEngine(IMatchingEngine):
                 idx_s += 1
                 continue
 
-            if b_wrapper.dto.price_limit >= s_wrapper.dto.price_limit:
+            # Integer Price Check
+            if b_wrapper.dto.price_pennies >= s_wrapper.dto.price_pennies:
                 # Labor/Housing Market Specific Pricing Logic
                 if market_id == "labor" or market_id == "research_labor":
-                    trade_price = b_wrapper.dto.price_limit
+                    trade_price_pennies = b_wrapper.dto.price_pennies
                 else:
-                    trade_price = (b_wrapper.dto.price_limit + s_wrapper.dto.price_limit) / 2
+                    # Mid-price calculation (Integer Division = Floor)
+                    trade_price_pennies = (b_wrapper.dto.price_pennies + s_wrapper.dto.price_pennies) // 2
 
                 trade_qty = min(b_wrapper.remaining_qty, s_wrapper.remaining_qty)
 
+                trade_total_pennies = int(trade_price_pennies * trade_qty)
+                effective_price_dollars = (trade_total_pennies / trade_qty) / 100.0 if trade_qty > 0 else 0.0
+
                 tx = Transaction(
                      item_id=item_id,
                      quantity=trade_qty,
-                     price=trade_price,
+                     price=effective_price_dollars,
+                     total_pennies=trade_total_pennies,
                      buyer_id=b_wrapper.dto.agent_id,
                      seller_id=s_wrapper.dto.agent_id,
                      market_id=market_id,
@@ -209,7 +213,7 @@ class OrderBookMatchingEngine(IMatchingEngine):
                      quality=s_wrapper.dto.brand_info.get("quality", 1.0) if s_wrapper.dto.brand_info else 1.0
                 )
                 transactions.append(tx)
-                stats["last_price"] = trade_price
+                stats["last_price"] = effective_price_dollars
                 stats["volume"] += trade_qty
 
                 b_wrapper.remaining_qty -= trade_qty
@@ -220,10 +224,10 @@ class OrderBookMatchingEngine(IMatchingEngine):
 
         # Convert remaining wrappers back to DTOs
         final_buys = [b.to_dto() for b in mutable_general_buys if b.remaining_qty > 1e-9]
-        final_buys.sort(key=lambda o: o.price_limit, reverse=True)
+        final_buys.sort(key=lambda o: o.price_pennies, reverse=True)
 
         final_sells = [s.to_dto() for s in active_sells if s.remaining_qty > 1e-9]
-        final_sells.sort(key=lambda o: o.price_limit)
+        final_sells.sort(key=lambda o: o.price_pennies)
 
         return transactions, final_buys, final_sells, stats
 
@@ -232,6 +236,7 @@ class StockMatchingEngine(IMatchingEngine):
     """
     Stateless matching engine for Stock Market.
     Matches Buy and Sell orders for each firm.
+    Uses Integer Math (Pennies).
     """
 
     def match(self, state: StockMarketStateDTO, current_tick: int) -> MatchingResultDTO:
@@ -249,12 +254,6 @@ class StockMatchingEngine(IMatchingEngine):
         all_firm_ids = set(state.buy_orders.keys()) | set(state.sell_orders.keys())
 
         for firm_id in all_firm_ids:
-            # Map firm_id back to str key if needed for output dict,
-            # but StockMarketStateDTO uses int keys for input.
-            # MatchingResultDTO uses str keys for generic compatibility.
-            # We will use "stock_{firm_id}" or just str(firm_id).
-            # Consistent with CanonicalOrderDTO.item_id logic: "stock_{firm_id}"
-
             buy_orders = state.buy_orders.get(firm_id, [])
             sell_orders = state.sell_orders.get(firm_id, [])
 
@@ -299,9 +298,9 @@ class StockMatchingEngine(IMatchingEngine):
 
         # Sort Orders
         # Buy: Price Desc
-        buy_orders.sort(key=lambda o: o.price_limit, reverse=True)
+        buy_orders.sort(key=lambda o: o.price_pennies, reverse=True)
         # Sell: Price Asc
-        sell_orders.sort(key=lambda o: o.price_limit)
+        sell_orders.sort(key=lambda o: o.price_pennies)
 
         # Mutable wrappers
         class MutableOrder:
@@ -333,13 +332,17 @@ class StockMatchingEngine(IMatchingEngine):
                 idx_s += 1
                 continue
 
-            if b_order.dto.price_limit >= s_order.dto.price_limit:
-                trade_price = (b_order.dto.price_limit + s_order.dto.price_limit) / 2
+            # Integer Price Check
+            if b_order.dto.price_pennies >= s_order.dto.price_pennies:
+                # Mid-price (Integer Division)
+                trade_price_pennies = (b_order.dto.price_pennies + s_order.dto.price_pennies) // 2
                 trade_qty = min(b_order.remaining_qty, s_order.remaining_qty)
 
+                trade_total_pennies = int(trade_price_pennies * trade_qty)
+                effective_price_dollars = (trade_total_pennies / trade_qty) / 100.0 if trade_qty > 0 else 0.0
+
                 # Validation check
                 if b_order.dto.agent_id is None or s_order.dto.agent_id is None:
-                    # Skip invalid order
                     if b_order.dto.agent_id is None: idx_b += 1
                     if s_order.dto.agent_id is None: idx_s += 1
                     continue
@@ -349,7 +352,8 @@ class StockMatchingEngine(IMatchingEngine):
                     seller_id=s_order.dto.agent_id,
                     item_id=f"stock_{firm_id}",
                     quantity=trade_qty,
-                    price=trade_price,
+                    price=effective_price_dollars,
+                    total_pennies=trade_total_pennies,
                     market_id=market_id,
                     transaction_type="stock",
                     time=current_tick,
@@ -357,9 +361,9 @@ class StockMatchingEngine(IMatchingEngine):
                 transactions.append(tx)
 
                 stats["volume"] += trade_qty
-                last_price = trade_price
-                high = max(high, trade_price)
-                low = min(low, trade_price)
+                last_price = effective_price_dollars
+                high = max(high, effective_price_dollars)
+                low = min(low, effective_price_dollars)
 
                 b_order.remaining_qty -= trade_qty
                 s_order.remaining_qty -= trade_qty
diff --git a/simulation/markets/order_book_market.py b/simulation/markets/order_book_market.py
index 1fb6ab96..75fd3037 100644
--- a/simulation/markets/order_book_market.py
+++ b/simulation/markets/order_book_market.py
@@ -18,19 +18,22 @@ class MarketOrder:
     side: str
     item_id: str
     quantity: float
-    price: float
+    price_pennies: int # SSoT (Integer Pennies)
+    price: float       # Legacy/Display (Float)
     original_id: str
     target_agent_id: Optional[int] = None
     brand_info: Optional[Dict[str, Any]] = None
 
     @classmethod
     def from_dto(cls, dto: CanonicalOrderDTO) -> 'MarketOrder':
+        # Ensure price_pennies is available. DTO should enforce this.
         return cls(
             agent_id=dto.agent_id,
             side=dto.side,
             item_id=dto.item_id,
             quantity=dto.quantity,
-            price=dto.price_limit,
+            price_pennies=dto.price_pennies,
+            price=dto.price_limit, # Legacy float
             original_id=dto.id,
             target_agent_id=dto.target_agent_id,
             brand_info=dto.brand_info
@@ -47,6 +50,7 @@ class MarketOrder:
             side=self.side,
             item_id=self.item_id,
             quantity=self.quantity,
+            price_pennies=self.price_pennies,
             price_limit=self.price,
             market_id=market_id,
             target_agent_id=self.target_agent_id,
@@ -320,11 +324,11 @@ class OrderBookMarket(Market):
         if order.item_id not in target_order_book:
             target_order_book[order.item_id] = []
         target_order_book[order.item_id].append(order)
-        # Sort orders: BUY by price (desc), SELL by price (asc)
+        # Sort orders: BUY by price_pennies (desc), SELL by price_pennies (asc)
         if order.side == "BUY":
-            target_order_book[order.item_id].sort(key=lambda o: o.price, reverse=True)
+            target_order_book[order.item_id].sort(key=lambda o: o.price_pennies, reverse=True)
         else:
-            target_order_book[order.item_id].sort(key=lambda o: o.price)
+            target_order_book[order.item_id].sort(key=lambda o: o.price_pennies)
 
     def get_best_ask(self, item_id: str) -> float | None:
         """주어진 아이템의 최저 판매 가격(best ask)을 반환합니다."""
diff --git a/simulation/markets/stock_market.py b/simulation/markets/stock_market.py
index 43d9a1c8..41cb4db9 100644
--- a/simulation/markets/stock_market.py
+++ b/simulation/markets/stock_market.py
@@ -160,7 +160,9 @@ class StockMarket(Market):
             )
             # 가격을 제한 범위 내로 조정하여 새로운 CanonicalOrderDTO 생성
             clamped_price = max(min_price, min(max_price, order.price_limit))
-            final_order = replace(order, price_limit=clamped_price)
+            # Also clamp pennies (assuming Scale 100)
+            clamped_pennies = int(clamped_price * 100)
+            final_order = replace(order, price_limit=clamped_price, price_pennies=clamped_pennies)
 
         # 내부 래퍼 생성
         managed_order = ManagedOrder(
diff --git a/simulation/models.py b/simulation/models.py
index f67f68ba..b1a67714 100644
--- a/simulation/models.py
+++ b/simulation/models.py
@@ -17,12 +17,13 @@ class Transaction:
     seller_id: int | str
     item_id: str
     quantity: float
-    price: int  # Changed from float to int (pennies) for DTO integrity
+    price: float  # Changed from int to float (deprecated/display)
     market_id: str  # Added market_id
     transaction_type: str  # 'goods', 'labor', 'dividend', 'stock' 등 거래 유형
     time: int  # 거래가 발생한 시뮬레이션 틱
     currency: str = DEFAULT_CURRENCY # TD-213: Multi-currency support
     quality: float = 1.0  # Phase 15: Durables Quality
+    total_pennies: int = 0 # SSoT for settlement
     metadata: Optional[Dict[str, Any]] = None  # WO-109: Metadata for side-effects
 
 
diff --git a/simulation/systems/handlers/goods_handler.py b/simulation/systems/handlers/goods_handler.py
index d3f83d15..486f716f 100644
--- a/simulation/systems/handlers/goods_handler.py
+++ b/simulation/systems/handlers/goods_handler.py
@@ -22,8 +22,14 @@ class GoodsTransactionHandler(ITransactionHandler):
             logger.warning(f"Transaction failed: Buyer ({tx.buyer_id}) or Seller ({tx.seller_id}) not found.")
             return False
 
-        # Convert to integer pennies using Banker's Rounding
-        trade_value = round_to_pennies(tx.quantity * tx.price)
+        # SSoT: Use pre-calculated total_pennies from Matching Engine if available
+        if getattr(tx, 'total_pennies', 0) > 0:
+             trade_value = tx.total_pennies
+        elif getattr(tx, 'total_pennies', 0) == 0 and tx.price == 0:
+             trade_value = 0
+        else:
+             # Fallback for legacy transactions without total_pennies
+             trade_value = round_to_pennies(tx.quantity * tx.price)
 
 
         # 1. Prepare Settlement (Calculate tax intents)
diff --git a/simulation/systems/handlers/labor_handler.py b/simulation/systems/handlers/labor_handler.py
index e0c86da4..7d693ebb 100644
--- a/simulation/systems/handlers/labor_handler.py
+++ b/simulation/systems/handlers/labor_handler.py
@@ -16,7 +16,13 @@ class LaborTransactionHandler(ITransactionHandler):
     """
 
     def handle(self, tx: Transaction, buyer: Any, seller: Any, context: TransactionContext) -> bool:
-        trade_value = round_to_pennies(tx.quantity * tx.price)
+        # SSoT: Use pre-calculated total_pennies from Matching Engine if available
+        if getattr(tx, 'total_pennies', 0) > 0:
+             trade_value = tx.total_pennies
+        elif getattr(tx, 'total_pennies', 0) == 0 and tx.price == 0:
+             trade_value = 0
+        else:
+             trade_value = round_to_pennies(tx.quantity * tx.price)
 
 
         # 1. Prepare Settlement (Calculate tax intents)
diff --git a/simulation/systems/handlers/stock_handler.py b/simulation/systems/handlers/stock_handler.py
index 18543cc1..5c126b8c 100644
--- a/simulation/systems/handlers/stock_handler.py
+++ b/simulation/systems/handlers/stock_handler.py
@@ -14,7 +14,13 @@ class StockTransactionHandler(ITransactionHandler):
     """
 
     def handle(self, tx: Transaction, buyer: Any, seller: Any, context: TransactionContext) -> bool:
-        trade_value = int(tx.quantity * tx.price)
+        # SSoT: Use pre-calculated total_pennies from Matching Engine if available
+        if getattr(tx, 'total_pennies', 0) > 0:
+             trade_value = tx.total_pennies
+        elif getattr(tx, 'total_pennies', 0) == 0 and tx.price == 0:
+             trade_value = 0
+        else:
+             trade_value = int(tx.quantity * tx.price)
 
         # 1. Execute Settlement (Direct Transfer)
         # Stock trades typically don't have sales tax in this simulation model yet.
diff --git a/tests/market/test_precision_matching.py b/tests/market/test_precision_matching.py
new file mode 100644
index 00000000..1f242724
--- /dev/null
+++ b/tests/market/test_precision_matching.py
@@ -0,0 +1,132 @@
+import unittest
+from simulation.markets.matching_engine import OrderBookMatchingEngine
+from modules.market.api import OrderBookStateDTO, CanonicalOrderDTO
+from simulation.models import Transaction
+
+class TestPrecisionMatching(unittest.TestCase):
+    def test_market_zero_sum_integer(self):
+        engine = OrderBookMatchingEngine()
+
+        # Buy @ 100 pennies (1.00)
+        buy_order = CanonicalOrderDTO(
+            agent_id="buyer",
+            side="BUY",
+            item_id="item1",
+            quantity=1.0,
+            price_pennies=100,
+            price_limit=1.00,
+            market_id="test"
+        )
+
+        # Sell @ 99 pennies (0.99)
+        sell_order = CanonicalOrderDTO(
+            agent_id="seller",
+            side="SELL",
+            item_id="item1",
+            quantity=1.0,
+            price_pennies=99,
+            price_limit=0.99,
+            market_id="test"
+        )
+
+        state = OrderBookStateDTO(
+            buy_orders={"item1": [buy_order]},
+            sell_orders={"item1": [sell_order]},
+            market_id="test"
+        )
+
+        result = engine.match(state, current_tick=1)
+
+        self.assertEqual(len(result.transactions), 1)
+        tx = result.transactions[0]
+
+        # Mid price: (100 + 99) // 2 = 199 // 2 = 99 pennies
+        # Total pennies: 99 * 1.0 = 99
+
+        self.assertEqual(tx.total_pennies, 99)
+        # Price (Dollars) = 99 / 100.0 = 0.99
+        self.assertEqual(tx.price, 0.99)
+
+    def test_market_fractional_qty_rounding(self):
+        engine = OrderBookMatchingEngine()
+
+        # Buy @ 10 pennies, Qty 0.33
+        buy_order = CanonicalOrderDTO(
+            agent_id="buyer",
+            side="BUY",
+            item_id="item1",
+            quantity=0.33,
+            price_pennies=10,
+            price_limit=0.10,
+            market_id="test"
+        )
+
+        # Sell @ 10 pennies, Qty 0.33
+        sell_order = CanonicalOrderDTO(
+            agent_id="seller",
+            side="SELL",
+            item_id="item1",
+            quantity=0.33,
+            price_pennies=10,
+            price_limit=0.10,
+            market_id="test"
+        )
+
+        state = OrderBookStateDTO(
+            buy_orders={"item1": [buy_order]},
+            sell_orders={"item1": [sell_order]},
+            market_id="test"
+        )
+
+        result = engine.match(state, current_tick=1)
+
+        tx = result.transactions[0]
+
+        # Mid price: (10 + 10) // 2 = 10
+        # Total pennies: int(10 * 0.33) = int(3.3) = 3 pennies
+
+        self.assertEqual(tx.total_pennies, 3)
+        # Price (Dollars) = (3 / 0.33) / 100 = 9.09... / 100 = 0.0909...
+        self.assertAlmostEqual(tx.price, (3 / 0.33) / 100.0, places=5)
+
+    def test_labor_market_pricing(self):
+        # Labor market uses Buyer's Bid as price
+        engine = OrderBookMatchingEngine()
+
+        # Buy Labor @ 1000 pennies
+        buy_order = CanonicalOrderDTO(
+            agent_id="buyer",
+            side="BUY",
+            item_id="labor_1",
+            quantity=1.0,
+            price_pennies=1000,
+            price_limit=10.00,
+            market_id="labor"
+        )
+
+        # Sell Labor @ 900 pennies
+        sell_order = CanonicalOrderDTO(
+            agent_id="seller",
+            side="SELL",
+            item_id="labor_1",
+            quantity=1.0,
+            price_pennies=900,
+            price_limit=9.00,
+            market_id="labor"
+        )
+
+        state = OrderBookStateDTO(
+            buy_orders={"labor_1": [buy_order]},
+            sell_orders={"labor_1": [sell_order]},
+            market_id="labor"
+        )
+
+        result = engine.match(state, current_tick=1)
+
+        tx = result.transactions[0]
+
+        # Rule: Trade Price = Buyer's Price (1000)
+        self.assertEqual(tx.total_pennies, 1000)
+
+if __name__ == '__main__':
+    unittest.main()
diff --git a/tests/unit/test_market_adapter.py b/tests/unit/test_market_adapter.py
index 4ebc69c3..c68b9b96 100644
--- a/tests/unit/test_market_adapter.py
+++ b/tests/unit/test_market_adapter.py
@@ -11,6 +11,7 @@ class TestMarketAdapter:
             item_id="stock_100",
             quantity=10.0,
             price_limit=50.0,
+            price_pennies=5000,
             market_id="stock_market"
         )
         converted = convert_legacy_order_to_canonical(dto)
@@ -22,7 +23,7 @@ class TestMarketAdapter:
             order_type="SELL",
             firm_id=100,
             quantity=5.0,
-            price=45.0
+            price=45.0 # StockOrder treats this as raw value (pennies usually if int)
         )
         converted = convert_legacy_order_to_canonical(legacy)
 
@@ -32,6 +33,8 @@ class TestMarketAdapter:
         assert converted.item_id == "stock_100"
         assert converted.quantity == 5.0
         assert converted.price_limit == 45.0
+        # StockOrder conversion logic uses int(order.price) directly
+        assert converted.price_pennies == 4500
         assert converted.market_id == "stock_market"
 
     def test_convert_dict_legacy_format(self):
@@ -51,6 +54,8 @@ class TestMarketAdapter:
         assert converted.item_id == "stock_200"
         assert converted.quantity == 20.0
         assert converted.price_limit == 60.0
+        # Dict conversion logic: float -> dollars -> * 100
+        assert converted.price_pennies == 6000
 
     def test_convert_dict_canonical_format(self):
         canonical_dict = {
@@ -68,6 +73,8 @@ class TestMarketAdapter:
         assert converted.side == "SELL"
         assert converted.item_id == "stock_300"
         assert converted.price_limit == 55.0
+        # Dict logic again
+        assert converted.price_pennies == 5500
 
     def test_invalid_input(self):
         with pytest.raises(ValueError):
diff --git a/tests/unit/test_markets_v2.py b/tests/unit/test_markets_v2.py
index 7273eb6a..bab631e5 100644
--- a/tests/unit/test_markets_v2.py
+++ b/tests/unit/test_markets_v2.py
@@ -28,13 +28,10 @@ class TestOrderBookMarketInitialization:
 class TestPlaceOrderToBook:
     def test_add_single_buy_order(self, market: OrderBookMarket):
         """단일 매수 주문이 오더북에 올바르게 추가되는지 테스트합니다."""
+        # Order(..., pennies, limit, ...)
+        # 100 pennies = $1.00
         order = Order(
-            agent_id=1,
-            side="BUY",
-            item_id="food",
-            quantity=10,
-            price_limit=100,
-            market_id="test_market",
+            1, "BUY", "food", 10, 100, 1.00, "test_market"
         )
         market.place_order(order, 1)
 
@@ -42,34 +39,14 @@ class TestPlaceOrderToBook:
         sell_book = market.sell_orders.get("food", [])
         assert len(buy_book) == 1
         assert len(sell_book) == 0
-        assert buy_book[0].price == 100
+        assert buy_book[0].price_pennies == 100
 
     def test_add_buy_orders_sorted(self, market: OrderBookMarket):
         """여러 매수 주문이 가격 내림차순으로 정렬되는지 테스트합니다."""
-        order1 = Order(
-            agent_id=1,
-            side="BUY",
-            item_id="food",
-            quantity=10,
-            price_limit=100,
-            market_id="test_market",
-        )
-        order2 = Order(
-            agent_id=2,
-            side="BUY",
-            item_id="food",
-            quantity=5,
-            price_limit=110,
-            market_id="test_market",
-        )
-        order3 = Order(
-            agent_id=3,
-            side="BUY",
-            item_id="food",
-            quantity=8,
-            price_limit=105,
-            market_id="test_market",
-        )
+        # 100 pennies ($1.00), 110 ($1.10), 105 ($1.05)
+        order1 = Order(1, "BUY", "food", 10, 100, 1.00, "test_market")
+        order2 = Order(2, "BUY", "food", 5, 110, 1.10, "test_market")
+        order3 = Order(3, "BUY", "food", 8, 105, 1.05, "test_market")
 
         market.place_order(order1, 1)
         market.place_order(order2, 2)
@@ -77,34 +54,14 @@ class TestPlaceOrderToBook:
 
         buy_book = market.buy_orders.get("food", [])
         assert len(buy_book) == 3
-        assert [o.price for o in buy_book] == [110, 105, 100]
+        # Check SSoT (Pennies)
+        assert [o.price_pennies for o in buy_book] == [110, 105, 100]
 
     def test_add_sell_orders_sorted(self, market: OrderBookMarket):
         """여러 매도 주문이 가격 오름차순으로 정렬되는지 테스트합니다."""
-        order1 = Order(
-            agent_id=1,
-            side="SELL",
-            item_id="food",
-            quantity=10,
-            price_limit=100,
-            market_id="test_market",
-        )
-        order2 = Order(
-            agent_id=2,
-            side="SELL",
-            item_id="food",
-            quantity=5,
-            price_limit=90,
-            market_id="test_market",
-        )
-        order3 = Order(
-            agent_id=3,
-            side="SELL",
-            item_id="food",
-            quantity=8,
-            price_limit=95,
-            market_id="test_market",
-        )
+        order1 = Order(1, "SELL", "food", 10, 100, 1.00, "test_market")
+        order2 = Order(2, "SELL", "food", 5, 90, 0.90, "test_market")
+        order3 = Order(3, "SELL", "food", 8, 95, 0.95, "test_market")
 
         market.place_order(order1, 1)
         market.place_order(order2, 2)
@@ -112,35 +69,13 @@ class TestPlaceOrderToBook:
 
         sell_book = market.sell_orders.get("food", [])
         assert len(sell_book) == 3
-        assert [o.price for o in sell_book] == [90, 95, 100]
+        assert [o.price_pennies for o in sell_book] == [90, 95, 100]
 
     def test_add_orders_with_same_price(self, market: OrderBookMarket):
         """가격이 같은 주문은 시간 순서(FIFO)대로 정렬되는지 테스트합니다."""
-        # 이 테스트는 현재 bisect 구현 상 통과함 (stable sort와 유사하게 동작)
-        order1 = Order(
-            agent_id=1,
-            side="BUY",
-            item_id="food",
-            quantity=10,
-            price_limit=100,
-            market_id="test_market",
-        )
-        order2 = Order(
-            agent_id=2,
-            side="BUY",
-            item_id="food",
-            quantity=5,
-            price_limit=110,
-            market_id="test_market",
-        )
-        order3 = Order(
-            agent_id=3,
-            side="BUY",
-            item_id="food",
-            quantity=8,
-            price_limit=100,
-            market_id="test_market",
-        )  # order1과 가격 동일
+        order1 = Order(1, "BUY", "food", 10, 100, 1.00, "test_market")
+        order2 = Order(2, "BUY", "food", 5, 110, 1.10, "test_market")
+        order3 = Order(3, "BUY", "food", 8, 100, 1.00, "test_market")
 
         market.place_order(order1, 1)
         market.place_order(order2, 2)
@@ -148,39 +83,25 @@ class TestPlaceOrderToBook:
 
         buy_book = market.buy_orders.get("food", [])
         assert len(buy_book) == 3
-        assert [o.price for o in buy_book] == [110, 100, 100]
+        assert [o.price_pennies for o in buy_book] == [110, 100, 100]
         # 가격이 100인 주문들 중 먼저 들어온 order1(agent_id=1)이 앞에 위치해야 함
-        assert [o.agent_id for o in buy_book if o.price == 100] == [1, 3]
+        assert [o.agent_id for o in buy_book if o.price_pennies == 100] == [1, 3]
 
 
 class TestOrderMatching:
     def test_unfilled_order_no_match(self, market: OrderBookMarket):
         """가격이 교차하지 않아 매칭이 발생하지 않는 경우를 테스트합니다."""
-        # Arrange: 매도 110, 매수 100 (가격 불일치)
-        sell_order = Order(
-            agent_id=1,
-            side="SELL",
-            item_id="food",
-            quantity=10,
-            price_limit=110,
-            market_id="test_market",
-        )
+        # Sell @ 110 ($1.10), Buy @ 100 ($1.00) -> No match
+        sell_order = Order(1, "SELL", "food", 10, 110, 1.10, "test_market")
         market.place_order(sell_order, current_time=1)
 
-        buy_order = Order(
-            agent_id=2,
-            side="BUY",
-            item_id="food",
-            quantity=10,
-            price_limit=100,
-            market_id="test_market",
-        )
+        buy_order = Order(2, "BUY", "food", 10, 100, 1.00, "test_market")
         market.place_order(buy_order, current_time=2)
 
         # Act
         transactions = market.match_orders(current_time=3)
 
-        # Assert: 거래 없음, 주문 잔존
+        # Assert
         assert len(transactions) == 0
 
         buy_book = market.buy_orders.get("food", [])
@@ -188,29 +109,17 @@ class TestOrderMatching:
 
         assert len(buy_book) == 1
         assert len(sell_book) == 1
-        assert buy_book[0].price == 100
-        assert sell_book[0].price == 110
+        assert buy_book[0].price_pennies == 100
+        assert sell_book[0].price_pennies == 110
 
     def test_full_match_one_to_one(self, market: OrderBookMarket):
         """매수 주문 1개와 매도 주문 1개가 완전히 체결되는 경우를 테스트합니다."""
-        sell_order = Order(
-            agent_id=2,
-            side="SELL",
-            item_id="food",
-            quantity=10,
-            price_limit=100,
-            market_id="test_market",
-        )
+        # Sell @ 100 ($1.00)
+        sell_order = Order(2, "SELL", "food", 10, 100, 1.00, "test_market")
         market.place_order(sell_order, current_time=1)
 
-        buy_order = Order(
-            agent_id=1,
-            side="BUY",
-            item_id="food",
-            quantity=10,
-            price_limit=105,
-            market_id="test_market",
-        )
+        # Buy @ 105 ($1.05)
+        buy_order = Order(1, "BUY", "food", 10, 105, 1.05, "test_market")
         market.place_order(buy_order, current_time=2)
 
         transactions = market.match_orders(current_time=2)
@@ -218,96 +127,67 @@ class TestOrderMatching:
         assert len(transactions) == 1
         tx = transactions[0]
         assert tx.quantity == 10
-        assert tx.price == 102.5  # FIX: 매치가격은 중간값으로 설정
+        # Integer Math: (105 + 100) // 2 = 102 pennies
+        # Price (Float) = 1.02
+        assert tx.price == 1.02
+        assert tx.total_pennies == 1020
         assert tx.buyer_id == 1
         assert tx.seller_id == 2
         assert tx.currency == DEFAULT_CURRENCY
 
-        # 오더북이 비어있는지 확인
         assert not market.buy_orders.get("food", [])
         assert not market.sell_orders.get("food", [])
 
     def test_partial_match_then_book(self, market: OrderBookMarket):
         """새로운 매수 주문이 부분 체결된 후 나머지가 오더북에 등록되는 경우를 테스트합니다."""
-        sell_order = Order(
-            agent_id=2,
-            side="SELL",
-            item_id="food",
-            quantity=5,
-            price_limit=100,
-            market_id="test_market",
-        )
+        # Sell 5 @ 100 ($1.00)
+        sell_order = Order(2, "SELL", "food", 5, 100, 1.00, "test_market")
         market.place_order(sell_order, current_time=1)
 
-        buy_order = Order(
-            agent_id=1,
-            side="BUY",
-            item_id="food",
-            quantity=10,
-            price_limit=105,
-            market_id="test_market",
-        )
+        # Buy 10 @ 105 ($1.05)
+        buy_order = Order(1, "BUY", "food", 10, 105, 1.05, "test_market")
         market.place_order(buy_order, current_time=2)
 
         transactions = market.match_orders(current_time=2)
 
         assert len(transactions) == 1
         tx = transactions[0]
-        assert tx.quantity == 5  # 매도 주문의 수량만큼만 체결
+        assert tx.quantity == 5
+        assert tx.price == 1.02 # 102 pennies
 
-        # 매도 오더북은 비워지고, 매수 오더북에 남은 주문이 등록되어야 함
         buy_book = market.buy_orders.get("food", [])
         sell_book = market.sell_orders.get("food", [])
         assert not sell_book
         assert len(buy_book) == 1
         assert buy_book[0].agent_id == 1
-        assert buy_book[0].quantity == 5  # 10 - 5 = 5
+        assert buy_book[0].quantity == 5
 
     def test_match_with_multiple_orders(self, market: OrderBookMarket):
         """새로운 큰 주문 하나가 여러 개의 작은 주문과 체결되는 경우를 테스트합니다."""
-        sell1 = Order(
-            agent_id=2,
-            side="SELL",
-            item_id="food",
-            quantity=5,
-            price_limit=98,
-            market_id="test_market",
-        )
-        sell2 = Order(
-            agent_id=3,
-            side="SELL",
-            item_id="food",
-            quantity=5,
-            price_limit=100,
-            market_id="test_market",
-        )
+        # Sell 5 @ 98 ($0.98)
+        sell1 = Order(2, "SELL", "food", 5, 98, 0.98, "test_market")
+        # Sell 5 @ 100 ($1.00)
+        sell2 = Order(3, "SELL", "food", 5, 100, 1.00, "test_market")
         market.place_order(sell1, current_time=1)
         market.place_order(sell2, current_time=2)
 
-        buy_order = Order(
-            agent_id=1,
-            side="BUY",
-            item_id="food",
-            quantity=12,
-            price_limit=105,
-            market_id="test_market",
-        )
+        # Buy 12 @ 105 ($1.05)
+        buy_order = Order(1, "BUY", "food", 12, 105, 1.05, "test_market")
         market.place_order(buy_order, current_time=3)
 
         transactions = market.match_orders(current_time=3)
 
         assert len(transactions) == 2
         assert transactions[0].quantity == 5
-        assert transactions[0].price == 101.5  # FIX: (105+98)/2
+        # (105 + 98) // 2 = 101 pennies -> 1.01
+        assert transactions[0].price == 1.01
         assert transactions[1].quantity == 5
-        assert transactions[1].price == 102.5  # FIX: (105+100)/2
+        # (105 + 100) // 2 = 102 pennies -> 1.02
+        assert transactions[1].price == 1.02
 
-        # 매도 오더북은 비워지고, 매수 오더북에 남은 주문이 등록되어야 함
         buy_book = market.buy_orders.get("food", [])
-        sell_book = market.sell_orders.get("food", [])
-        assert not sell_book
         assert len(buy_book) == 1
-        assert buy_book[0].quantity == 2  # 12 - 5 - 5 = 2
+        assert buy_book[0].quantity == 2
 
 
 # --- Phase 2: API 구현 테스트 ---
@@ -315,52 +195,45 @@ class TestOrderMatching:
 
 class TestMarketAPI:
     def test_get_best_bid_empty(self, market: OrderBookMarket):
-        """매수 오더북이 비어있을 때 get_best_bid가 None을 반환하는지 테스트합니다."""
         assert market.get_best_bid("food") is None
 
     def test_get_best_bid_non_empty(self, market: OrderBookMarket):
-        """매수 오더북에 주문이 있을 때 get_best_bid가 최고가를 반환하는지 테스트합니다."""
-        market.place_order(Order(1, "BUY", "food", 10, 100, "test"), 1)
-        market.place_order(Order(2, "BUY", "food", 5, 110, "test"), 2)
-        assert market.get_best_bid("food") == 110
+        # 100 pennies ($1.00), 110 pennies ($1.10)
+        market.place_order(Order(1, "BUY", "food", 10, 100, 1.00, "test"), 1)
+        market.place_order(Order(2, "BUY", "food", 5, 110, 1.10, "test"), 2)
+        assert market.get_best_bid("food") == 1.10 # Returns Dollars (Float)
 
     def test_get_best_ask_empty(self, market: OrderBookMarket):
-        """매도 오더북이 비어있을 때 get_best_ask가 None을 반환하는지 테스트합니다."""
         assert market.get_best_ask("food") is None
 
     def test_get_best_ask_non_empty(self, market: OrderBookMarket):
-        """매도 오더북에 주문이 있을 때 get_best_ask가 최저가를 반환하는지 테스트합니다."""
-        market.place_order(Order(1, "SELL", "food", 10, 100, "test"), 1)
-        market.place_order(Order(2, "SELL", "food", 5, 90, "test"), 2)
-        assert market.get_best_ask("food") == 90
-
-    # Verified: The following methods (get_last_traded_price, get_spread, get_market_depth)
-    # were confirmed to be implemented and working as per requirement.
+        # 100 pennies, 90 pennies
+        market.place_order(Order(1, "SELL", "food", 10, 100, 1.00, "test"), 1)
+        market.place_order(Order(2, "SELL", "food", 5, 90, 0.90, "test"), 2)
+        assert market.get_best_ask("food") == 0.90 # Returns Dollars (Float)
 
     def test_get_last_traded_price(self, market: OrderBookMarket):
-        """거래 발생 후 get_last_traded_price가 올바른 가격을 반환하는지 테스트합니다."""
-        market.place_order(Order(1, 'SELL', 'food', 10, 100, 'test'), 1)
-        market.place_order(Order(2, 'BUY', 'food', 10, 105, 'test'), 2)
+        market.place_order(Order(1, 'SELL', 'food', 10, 100, 1.00, 'test'), 1)
+        market.place_order(Order(2, 'BUY', 'food', 10, 105, 1.05, 'test'), 2)
         market.match_orders(2)
-        assert market.get_last_traded_price('food') == 102.5
+        # 102 pennies -> 1.02 Dollars
+        assert market.get_last_traded_price('food') == 1.02
 
     def test_get_spread(self, market: OrderBookMarket):
-        """스프레드 계산이 올바른지 테스트합니다."""
-        market.place_order(Order(1, 'BUY', 'food', 10, 100, 'test'), 1)
-        market.place_order(Order(2, 'SELL', 'food', 10, 105, 'test'), 2)
-        assert market.get_spread('food') == 5
+        market.place_order(Order(1, 'BUY', 'food', 10, 100, 1.00, 'test'), 1)
+        market.place_order(Order(2, 'SELL', 'food', 10, 105, 1.05, 'test'), 2)
+        # 1.05 - 1.00 = 0.05
+        assert market.get_spread('food') == pytest.approx(0.05)
 
     def test_get_spread_no_bid_or_ask(self, market: OrderBookMarket):
-        """매수/매도 호가가 없을 때 get_spread가 None을 반환하는지 테스트합니다."""
-        market.place_order(Order(1, 'BUY', 'food', 10, 100, 'test'), 1)
+        market.place_order(Order(1, 'BUY', 'food', 10, 100, 1.00, 'test'), 1)
         assert market.get_spread('food') is None
-        market = OrderBookMarket(market_id="test_goods_market", logger=Logger()) # Reset market
-        market.place_order(Order(2, 'SELL', 'food', 10, 105, 'test'), 2)
+        market = OrderBookMarket(market_id="test_goods_market", logger=Logger())
+        market.place_order(Order(2, 'SELL', 'food', 10, 105, 1.05, 'test'), 2)
         assert market.get_spread('food') is None
 
     def test_get_market_depth(self, market: OrderBookMarket):
-        """시장 깊이(주문 수) 계산이 올바른지 테스트합니다."""
-        market.place_order(Order(1, 'BUY', 'food', 10, 100, 'test'), 1)
-        market.place_order(Order(2, 'BUY', 'food', 5, 90, 'test'), 2)
-        market.place_order(Order(3, 'SELL', 'food', 10, 105, 'test'), 3)
+        market.place_order(Order(1, 'BUY', 'food', 10, 100, 1.00, 'test'), 1)
+        market.place_order(Order(2, 'BUY', 'food', 5, 90, 0.90, 'test'), 2)
+        market.place_order(Order(3, 'SELL', 'food', 10, 105, 1.05, 'test'), 3)
         assert market.get_market_depth('food') == {'buy_orders': 2, 'sell_orders': 1}
diff --git a/tests/unit/test_stock_market.py b/tests/unit/test_stock_market.py
index 7fc3a51f..aeaf3707 100644
--- a/tests/unit/test_stock_market.py
+++ b/tests/unit/test_stock_market.py
@@ -37,6 +37,7 @@ def sample_buy_order_dto():
         item_id="stock_100",
         quantity=10.0,
         price_limit=50.0,
+        price_pennies=5000,
         market_id="stock_market"
     )
 
@@ -48,6 +49,7 @@ def sample_sell_order_dto():
         item_id="stock_100",
         quantity=10.0,
         price_limit=45.0,
+        price_pennies=4500,
         market_id="stock_market"
     )
 
@@ -95,14 +97,14 @@ class TestStockOrderPlacement:
         # Limit rate is 0.15 (from fixture) -> Range [85.0, 115.0]
 
         # Case 1: Price too high (120.0) -> Should be clamped to 115.0
-        high_order = OrderDTO(1, "BUY", f"stock_{firm_id}", 1.0, 120.0, "stock")
+        high_order = OrderDTO(agent_id=1, side="BUY", item_id=f"stock_{firm_id}", quantity=1.0, price_limit=120.0, price_pennies=12000, market_id="stock")
         stock_market.place_order(high_order, tick=1)
         
         best_bid = stock_market.get_best_bid(firm_id)
         assert best_bid == pytest.approx(115.0)
 
         # Case 2: Price too low (80.0) -> Should be clamped to 85.0
-        low_order = OrderDTO(1, "SELL", f"stock_{firm_id}", 1.0, 80.0, "stock")
+        low_order = OrderDTO(agent_id=1, side="SELL", item_id=f"stock_{firm_id}", quantity=1.0, price_limit=80.0, price_pennies=8000, market_id="stock")
         stock_market.place_order(low_order, tick=1)
         
         best_ask = stock_market.get_best_ask(firm_id)
@@ -112,9 +114,9 @@ class TestStockOrderPlacement:
         firm_id = 100
         stock_market.reference_prices[firm_id] = 50.0
 
-        o1 = OrderDTO(1, "BUY", f"stock_{firm_id}", 1.0, 45.0, "stock")
-        o2 = OrderDTO(2, "BUY", f"stock_{firm_id}", 1.0, 55.0, "stock")
-        o3 = OrderDTO(3, "BUY", f"stock_{firm_id}", 1.0, 50.0, "stock")
+        o1 = OrderDTO(agent_id=1, side="BUY", item_id=f"stock_{firm_id}", quantity=1.0, price_limit=45.0, price_pennies=4500, market_id="stock")
+        o2 = OrderDTO(agent_id=2, side="BUY", item_id=f"stock_{firm_id}", quantity=1.0, price_limit=55.0, price_pennies=5500, market_id="stock")
+        o3 = OrderDTO(agent_id=3, side="BUY", item_id=f"stock_{firm_id}", quantity=1.0, price_limit=50.0, price_pennies=5000, market_id="stock")
 
         stock_market.place_order(o1, 1)
         stock_market.place_order(o2, 1)
@@ -138,7 +140,10 @@ class TestStockOrderMatching:
         assert tx.buyer_id == 1
         assert tx.seller_id == 2
         assert tx.quantity == 10.0
-        assert tx.price == pytest.approx(47.5) # (50 + 45) / 2
+        # (50 + 45) / 2 = 47.5
+        # (5000 + 4500) / 2 = 4750 pennies.
+        # Transaction.price (Dollars) = 4750 pennies / 100.0 = 47.50
+        assert tx.price == pytest.approx(47.5)
 
         summary = stock_market.get_market_summary(100)
         assert summary["buy_order_count"] == 0
@@ -149,9 +154,9 @@ class TestStockOrderMatching:
         stock_market.reference_prices[firm_id] = 50.0
         
         # Buy 15 @ 50
-        buy_order = OrderDTO(1, "BUY", f"stock_{firm_id}", 15.0, 50.0, "stock")
+        buy_order = OrderDTO(agent_id=1, side="BUY", item_id=f"stock_{firm_id}", quantity=15.0, price_limit=50.0, price_pennies=5000, market_id="stock")
         # Sell 10 @ 45
-        sell_order = OrderDTO(2, "SELL", f"stock_{firm_id}", 10.0, 45.0, "stock")
+        sell_order = OrderDTO(agent_id=2, side="SELL", item_id=f"stock_{firm_id}", quantity=10.0, price_limit=45.0, price_pennies=4500, market_id="stock")
         
         stock_market.place_order(buy_order, tick=1)
         stock_market.place_order(sell_order, tick=1)
@@ -163,7 +168,7 @@ class TestStockOrderMatching:
         
         # Verify remaining buy order via summary
         # We can place another sell order to match the remaining 5
-        sell_order_2 = OrderDTO(3, "SELL", f"stock_{firm_id}", 5.0, 45.0, "stock")
+        sell_order_2 = OrderDTO(agent_id=3, side="SELL", item_id=f"stock_{firm_id}", quantity=5.0, price_limit=45.0, price_pennies=4500, market_id="stock")
         stock_market.place_order(sell_order_2, tick=2)
         
         transactions_2 = stock_market.match_orders(tick=2)
@@ -177,7 +182,7 @@ class TestOrderExpiry:
         firm_id = 100
         stock_market.reference_prices[firm_id] = 50.0
         
-        o1 = OrderDTO(1, "BUY", f"stock_{firm_id}", 5.0, 50.0, "stock")
+        o1 = OrderDTO(agent_id=1, side="BUY", item_id=f"stock_{firm_id}", quantity=5.0, price_limit=50.0, price_pennies=5000, market_id="stock")
         stock_market.place_order(o1, tick=1)
         
         # Tick 5: 5 - 1 = 4 > 3 -> Expired
