diff --git a/communications/insights/WO-4.0.md b/communications/insights/WO-4.0.md
new file mode 100644
index 0000000..08bf537
--- /dev/null
+++ b/communications/insights/WO-4.0.md
@@ -0,0 +1,21 @@
+# WO-4.0: Household Decomposition Insights
+
+## Technical Debt & Observations
+
+1.  **Implicit Dependencies in Mixins**:
+    The created mixins (`HouseholdPropertiesMixin`, `HouseholdFinancialsMixin`, etc.) implicitly rely on the existence of specific attributes on `self` (e.g., `_econ_state`, `_bio_state`, `config`, `logger`). While this is standard for mixins, it creates hidden coupling. Future refactoring should consider defining a `HouseholdProtocol` that these mixins can type-hint against to make requirements explicit.
+
+2.  **Circular Import Challenges**:
+    The `HouseholdReproductionMixin.clone` method requires instantiating a new `Household`. Since `Household` inherits from this mixin, a circular dependency exists. This was resolved using a local import inside the method, but it points to a tight coupling between the mixin and the class it enhances.
+
+3.  **Dual Asset State**:
+    `Household` overrides `BaseAgent.assets` to redirect to `_econ_state.assets`. However, `BaseAgent` still maintains its own `_assets` attribute, and the setter in `HouseholdPropertiesMixin` tries to keep them in sync (`self._assets = value`). This dual source of truth is a potential bug source if `_assets` is accessed directly by base class methods (though `BaseAgent` methods use `_internal_add_assets` which we overrode).
+
+4.  **Orchestration Complexity**:
+    While method implementations were moved to mixins, `Household.__init__` and `Household.make_decision` remain complex. `make_decision` acts as a high-level orchestrator calling various components. This suggests that `Household` is still acting as a Facade/Controller. Moving `make_decision` logic to a dedicated `AgentBrain` or `DecisionOrchestrator` could be a future step.
+
+5.  **Legacy DTO Usage**:
+    `HouseholdStateDTO` is deprecated but still instantiated in `make_decision` for backward compatibility with `DecisionContext`. Migration to `HouseholdSnapshotDTO` across all systems (DecisionEngine, etc.) is incomplete.
+
+## Refactoring Impact
+The decomposition successfully reduced the lines of code in `simulation/core_agents.py` by offloading property accessors and domain-specific logic to mixins. The public API remains unchanged, ensuring compatibility with existing tests and systems.
diff --git a/modules/household/mixins/_financials.py b/modules/household/mixins/_financials.py
new file mode 100644
index 0000000..4c3a54a
--- /dev/null
+++ b/modules/household/mixins/_financials.py
@@ -0,0 +1,180 @@
+from __future__ import annotations
+from typing import List, Dict, Optional, Any, TYPE_CHECKING, override
+from logging import Logger
+
+from modules.system.api import DEFAULT_CURRENCY, CurrencyCode
+from modules.finance.api import PortfolioDTO, PortfolioAsset
+from simulation.models import Order
+from simulation.portfolio import Portfolio
+
+if TYPE_CHECKING:
+    from modules.household.dtos import EconStateDTO
+    from simulation.dtos.config_dtos import HouseholdConfigDTO
+
+class HouseholdFinancialsMixin:
+    """
+    Mixin for Household financial operations.
+    Handles assets, inventory, portfolio, and employment termination.
+    """
+
+    # Type hints for properties expected on self
+    id: int
+    logger: Logger
+    config: "HouseholdConfigDTO"
+    _econ_state: "EconStateDTO"
+    _assets: Dict[CurrencyCode, float]
+
+    @override
+    def _internal_add_assets(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
+        if currency not in self._econ_state.assets:
+            self._econ_state.assets[currency] = 0.0
+        self._econ_state.assets[currency] += amount
+        self._assets = self._econ_state.assets
+
+    @override
+    def _internal_sub_assets(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
+        if currency not in self._econ_state.assets:
+            self._econ_state.assets[currency] = 0.0
+        self._econ_state.assets[currency] -= amount
+        self._assets = self._econ_state.assets
+
+    @override
+    def adjust_assets(self, delta: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
+        """
+        Adjusts assets by delta (positive or negative).
+        """
+        if currency not in self._econ_state.assets:
+            self._econ_state.assets[currency] = 0.0
+        self._econ_state.assets[currency] += delta
+        self._assets = self._econ_state.assets
+
+    def modify_inventory(self, item_id: str, quantity: float) -> None:
+        if item_id not in self._econ_state.inventory:
+            self._econ_state.inventory[item_id] = 0
+        self._econ_state.inventory[item_id] += quantity
+
+    def add_property(self, property_id: int) -> None:
+        """Safely adds a property to the owned list."""
+        if property_id not in self._econ_state.owned_properties:
+            self._econ_state.owned_properties.append(property_id)
+
+    def remove_property(self, property_id: int) -> None:
+        """Safely removes a property from the owned list."""
+        if property_id in self._econ_state.owned_properties:
+            self._econ_state.owned_properties.remove(property_id)
+
+    def quit(self) -> None:
+        if self._econ_state.is_employed:
+            self.logger.info(f"Household {self.id} is quitting from Firm {self._econ_state.employer_id}")
+            self._econ_state.is_employed = False
+            self._econ_state.employer_id = None
+            self._econ_state.current_wage = 0.0
+
+    def trigger_emergency_liquidation(self) -> List[Any]:
+        """
+        WO-167: Generates emergency sell orders for all inventory items and stocks.
+        Returns mixed list of Order and StockOrder.
+        """
+        orders = []
+
+        # 1. Liquidate Inventory
+        for good, qty in self._econ_state.inventory.items():
+            if qty <= 0:
+                continue
+
+            price = self._econ_state.perceived_avg_prices.get(good, 10.0)
+            liquidation_price = price * self.config.emergency_liquidation_discount
+
+            order = Order(
+                agent_id=self.id,
+                side="SELL",
+                item_id=good,
+                quantity=qty,
+                price_limit=liquidation_price,
+                market_id=good
+            )
+            orders.append(order)
+
+        # 2. Liquidate Stocks
+        for firm_id, holding in self._econ_state.portfolio.holdings.items():
+            shares = holding.quantity
+            if shares <= 0:
+                continue
+
+            # Heuristic price for stock: we don't have access to stock market price here easily
+            # without checking markets. We'll use a very low price to ensure sale (market order effectively)
+            # or rely on the market to match.
+            price = self.config.emergency_stock_liquidation_fallback_price
+
+            order = Order(
+                agent_id=self.id,
+                side="SELL",
+                item_id=f"stock_{firm_id}",
+                quantity=shares,
+                price_limit=price,
+                market_id="stock_market"
+            )
+            orders.append(order)
+
+        if orders:
+            self.logger.warning(
+                f"GRACE_PROTOCOL | Household {self.id} triggering emergency liquidation. Generated {len(orders)} orders.",
+                extra={"agent_id": self.id, "tags": ["grace_protocol", "liquidation"]}
+            )
+
+        return orders
+
+    def add_labor_income(self, income: float) -> None:
+        self._econ_state.labor_income_this_tick += income
+
+    def get_desired_wage(self) -> float:
+        if self._econ_state.assets.get(DEFAULT_CURRENCY, 0.0) < self.config.household_low_asset_threshold:
+            return self.config.household_low_asset_wage
+        return self.config.household_default_wage
+
+    def reset_consumption_counters(self) -> None:
+        """
+        Resets consumption counters for the new tick.
+        Used by TickScheduler.
+        """
+        self._econ_state.current_consumption = 0.0
+        self._econ_state.current_food_consumption = 0.0
+        self._econ_state.labor_income_this_tick = 0.0
+        self._econ_state.capital_income_this_tick = 0.0
+
+    def record_consumption(self, quantity: float, is_food: bool = False) -> None:
+        """
+        Updates consumption counters.
+        Used by Registry during transaction processing.
+        """
+        self._econ_state.current_consumption += quantity
+        if is_food:
+            self._econ_state.current_food_consumption += quantity
+
+    # --- IPortfolioHandler Implementation ---
+
+    def get_portfolio(self) -> PortfolioDTO:
+        assets = []
+        for firm_id, share in self._econ_state.portfolio.holdings.items():
+            assets.append(PortfolioAsset(
+                asset_type="stock",
+                asset_id=str(firm_id),
+                quantity=share.quantity
+            ))
+        return PortfolioDTO(assets=assets)
+
+    def receive_portfolio(self, portfolio: PortfolioDTO) -> None:
+        for asset in portfolio.assets:
+            if asset.asset_type == "stock":
+                try:
+                    firm_id = int(asset.asset_id)
+                    # TD-160: Inherited assets are integrated.
+                    # We use 0.0 acquisition price as default for inheritance if not specified.
+                    self._econ_state.portfolio.add(firm_id, asset.quantity, 0.0)
+                except ValueError:
+                    self.logger.error(f"Invalid firm_id in portfolio receive: {asset.asset_id}")
+            else:
+                self.logger.warning(f"Household received unhandled asset type: {asset.asset_type} (ID: {asset.asset_id})")
+
+    def clear_portfolio(self) -> None:
+        self._econ_state.portfolio.holdings.clear()
diff --git a/modules/household/mixins/_lifecycle.py b/modules/household/mixins/_lifecycle.py
new file mode 100644
index 0000000..6c6f043
--- /dev/null
+++ b/modules/household/mixins/_lifecycle.py
@@ -0,0 +1,171 @@
+from __future__ import annotations
+from typing import List, Dict, Optional, Any, TYPE_CHECKING, override
+from logging import Logger
+
+from simulation.dtos import ConsumptionResult, LeisureEffectDTO
+from simulation.dtos.scenario import StressScenarioConfig
+from simulation.ai.api import Personality
+from simulation.systems.api import LearningUpdateContext
+
+if TYPE_CHECKING:
+    from modules.household.dtos import BioStateDTO, EconStateDTO, SocialStateDTO
+    from simulation.dtos.config_dtos import HouseholdConfigDTO
+    from modules.household.consumption_manager import ConsumptionManager
+    from modules.household.bio_component import BioComponent
+    from modules.household.econ_component import EconComponent
+    from modules.household.social_component import SocialComponent
+    from simulation.decisions.base_decision_engine import BaseDecisionEngine
+
+class HouseholdLifecycleMixin:
+    """
+    Mixin for Household lifecycle and consumption logic.
+    Handles needs updates, consumption, leisure, and aging.
+    """
+
+    # Type hints for properties expected on self
+    id: int
+    logger: Logger
+    config: "HouseholdConfigDTO"
+    _bio_state: "BioStateDTO"
+    _econ_state: "EconStateDTO"
+    _social_state: "SocialStateDTO"
+    goods_info_map: Dict[str, Any]
+    distress_tick_counter: int
+
+    # Components
+    consumption_manager: "ConsumptionManager"
+    bio_component: "BioComponent"
+    econ_component: "EconComponent"
+    social_component: "SocialComponent"
+    decision_engine: "BaseDecisionEngine"
+
+    def consume(self, item_id: str, quantity: float, current_time: int) -> ConsumptionResult:
+        # Delegate to ConsumptionManager
+        self._econ_state, new_needs, result = self.consumption_manager.consume(
+            self._econ_state,
+            self._bio_state.needs,
+            item_id,
+            quantity,
+            current_time,
+            self.goods_info_map.get(item_id, {}),
+            self.config
+        )
+        self._bio_state.needs = new_needs
+        return result
+
+    @override
+    def update_needs(self, current_tick: int, market_data: Optional[Dict[str, Any]] = None):
+        """
+        Updates agent needs and lifecycle (Bio, Social, Econ-Work).
+        Replaces legacy AgentLifecycleComponent.
+        """
+        if not self._bio_state.is_active:
+            return
+
+        # 1. Work (Econ)
+        if self._econ_state.is_employed:
+            self._econ_state, labor_res = self.econ_component.work(
+                self._econ_state, 8.0, self.config
+            )
+            # We could log labor_res if needed
+
+        # 2. Update Psychology/Social (Needs & Death Check)
+        self._social_state, new_needs, new_durable_assets, is_active = self.social_component.update_psychology(
+            self._social_state,
+            self._bio_state.needs,
+            self._econ_state.assets,
+            self._econ_state.durable_assets,
+            self.goods_info_map,
+            self.config,
+            current_tick,
+            market_data
+        )
+        self._bio_state.needs = new_needs
+        self._econ_state.durable_assets = new_durable_assets
+
+        # WO-167: Grace Protocol - Override death if in distress grace period
+        if not is_active:
+            self.distress_tick_counter += 1
+            if self.distress_tick_counter <= getattr(self.config, "distress_grace_period_ticks", 10):
+                is_active = True
+                self.logger.info(
+                    f"GRACE_PROTOCOL_SAVE | Household {self.id} saved from death. Distress tick {self.distress_tick_counter}",
+                    extra={"agent_id": self.id, "tags": ["grace_protocol", "survival"]}
+                )
+        else:
+            self.distress_tick_counter = 0
+
+        self._bio_state.is_active = is_active
+
+        # 3. Update Political Opinion
+        self._social_state = self.social_component.update_political_opinion(
+            self._social_state, self._bio_state.needs.get("survival", 0.0)
+        )
+
+        # 4. Aging (Bio) - Also checks natural death
+        self._bio_state = self.bio_component.age_one_tick(
+            self._bio_state, self.config, current_tick
+        )
+
+        # 5. Skill Updates
+        self._econ_state = self.econ_component.update_skills(self._econ_state, self.config)
+
+    def apply_leisure_effect(self, leisure_hours: float, consumed_items: Dict[str, float]) -> LeisureEffectDTO:
+        self._social_state, self._econ_state.labor_skill, result = self.social_component.apply_leisure_effect(
+            self._social_state,
+            self._econ_state.labor_skill,
+            len(self._bio_state.children_ids),
+            leisure_hours,
+            consumed_items,
+            self.config
+        )
+        return result
+
+    @override
+    def update_perceived_prices(self, market_data: Dict[str, Any], stress_scenario_config: Optional[StressScenarioConfig] = None) -> None:
+        self._econ_state = self.econ_component.update_perceived_prices(
+            self._econ_state, market_data, self.goods_info_map, stress_scenario_config, self.config
+        )
+
+    def initialize_demographics(
+        self,
+        age: float,
+        gender: str,
+        parent_id: Optional[int],
+        generation: int,
+        spouse_id: Optional[int] = None
+    ) -> None:
+        """
+        Explicitly initializes demographic state.
+        Used by DemographicManager during agent creation.
+        """
+        self._bio_state.age = age
+        self._bio_state.gender = gender
+        self._bio_state.parent_id = parent_id
+        self._bio_state.generation = generation
+        self._bio_state.spouse_id = spouse_id
+
+    def initialize_personality(self, personality: Personality, desire_weights: Dict[str, float]) -> None:
+        """
+        Explicitly initializes personality and desire weights.
+        Used by DemographicManager and AITrainingManager (during brain inheritance).
+        """
+        self._social_state.personality = personality
+        self._social_state.desire_weights = desire_weights
+
+    def update_learning(self, context: LearningUpdateContext) -> None:
+        reward = context["reward"]
+        next_agent_data = context["next_agent_data"]
+        next_market_data = context["next_market_data"]
+
+        self.decision_engine.ai_engine.update_learning_v2(
+            reward=reward,
+            next_agent_data=next_agent_data,
+            next_market_data=next_market_data,
+        )
+
+    def add_education_xp(self, xp: float) -> None:
+        self._econ_state.education_xp += xp
+
+    def add_durable_asset(self, asset: Dict[str, Any]) -> None:
+        self._econ_state.durable_assets.append(asset)
diff --git a/modules/household/mixins/_properties.py b/modules/household/mixins/_properties.py
new file mode 100644
index 0000000..f3680c1
--- /dev/null
+++ b/modules/household/mixins/_properties.py
@@ -0,0 +1,166 @@
+from __future__ import annotations
+from typing import List, Dict, Optional, TYPE_CHECKING, override
+
+from modules.system.api import DEFAULT_CURRENCY, CurrencyCode
+from simulation.models import Skill, Talent
+from simulation.portfolio import Portfolio
+
+if TYPE_CHECKING:
+    from modules.household.dtos import BioStateDTO, EconStateDTO
+
+class HouseholdPropertiesMixin:
+    """
+    Mixin for Household properties (Getters/Setters).
+    Manages access to internal DTO states (Bio, Econ).
+    """
+
+    # Type hints for properties expected on self
+    _econ_state: "EconStateDTO"
+    _bio_state: "BioStateDTO"
+    _assets: Dict[CurrencyCode, float] # BaseAgent attribute
+
+    @property
+    @override
+    def assets(self) -> Dict[CurrencyCode, float]:
+        return self._econ_state.assets
+
+    @assets.setter
+    def assets(self, value: Dict[CurrencyCode, float]) -> None:
+        self._econ_state.assets = value
+        self._assets = value
+
+    @property
+    @override
+    def inventory(self) -> Dict[str, float]:
+        return self._econ_state.inventory
+
+    @inventory.setter
+    def inventory(self, value: Dict[str, float]) -> None:
+        self._econ_state.inventory = value
+
+    @property
+    def inventory_quality(self) -> Dict[str, float]:
+        return self._econ_state.inventory_quality
+
+    @inventory_quality.setter
+    def inventory_quality(self, value: Dict[str, float]) -> None:
+        self._econ_state.inventory_quality = value
+
+    @property
+    @override
+    def needs(self) -> Dict[str, float]:
+        return self._bio_state.needs
+
+    @needs.setter
+    def needs(self, value: Dict[str, float]) -> None:
+        self._bio_state.needs = value
+
+    @property
+    def is_active(self) -> bool:
+        return self._bio_state.is_active
+
+    @is_active.setter
+    def is_active(self, value: bool) -> None:
+        self._bio_state.is_active = value
+
+    @property
+    def age(self) -> float:
+        return self._bio_state.age
+
+    @age.setter
+    def age(self, value: float) -> None:
+        self._bio_state.age = value
+
+    @property
+    def children_ids(self) -> List[int]:
+        return self._bio_state.children_ids
+
+    @children_ids.setter
+    def children_ids(self, value: List[int]) -> None:
+        self._bio_state.children_ids = value
+
+    @property
+    def is_homeless(self) -> bool:
+        return self._econ_state.is_homeless
+
+    @is_homeless.setter
+    def is_homeless(self, value: bool) -> None:
+        self._econ_state.is_homeless = value
+
+    @property
+    def residing_property_id(self) -> Optional[int]:
+        return self._econ_state.residing_property_id
+
+    @residing_property_id.setter
+    def residing_property_id(self, value: Optional[int]) -> None:
+        self._econ_state.residing_property_id = value
+
+    @property
+    def owned_properties(self) -> List[int]:
+        return self._econ_state.owned_properties
+
+    @owned_properties.setter
+    def owned_properties(self, value: List[int]) -> None:
+        self._econ_state.owned_properties = value
+
+    @property
+    def current_wage(self) -> float:
+        return self._econ_state.current_wage
+
+    @current_wage.setter
+    def current_wage(self, value: float) -> None:
+        self._econ_state.current_wage = value
+
+    @property
+    def is_employed(self) -> bool:
+        return self._econ_state.is_employed
+
+    @is_employed.setter
+    def is_employed(self, value: bool) -> None:
+        self._econ_state.is_employed = value
+
+    @property
+    def employer_id(self) -> Optional[int]:
+        return self._econ_state.employer_id
+
+    @employer_id.setter
+    def employer_id(self, value: Optional[int]) -> None:
+        self._econ_state.employer_id = value
+
+    @property
+    def skills(self) -> Dict[str, Skill]:
+        """[TD-162] Backward compat: Exposes _econ_state.skills."""
+        return self._econ_state.skills
+
+    @skills.setter
+    def skills(self, value: Dict[str, Skill]) -> None:
+        self._econ_state.skills = value
+
+    @property
+    def portfolio(self) -> Portfolio:
+        """[TD-162] Backward compat: Exposes _econ_state.portfolio."""
+        return self._econ_state.portfolio
+
+    @portfolio.setter
+    def portfolio(self, value: Portfolio) -> None:
+        self._econ_state.portfolio = value
+
+    @property
+    def gender(self) -> str:
+        """Exposes gender from bio_state."""
+        return self._bio_state.gender
+
+    @property
+    def home_quality_score(self) -> float:
+        """Exposes home_quality_score from econ_state."""
+        return self._econ_state.home_quality_score
+
+    @property
+    def talent(self) -> Talent:
+        """Exposes talent from econ_state."""
+        return self._econ_state.talent
+
+    @property
+    def demographics(self) -> BioStateDTO:
+        """[Legacy] Exposes bio_state as demographics."""
+        return self._bio_state
diff --git a/modules/household/mixins/_reproduction.py b/modules/household/mixins/_reproduction.py
new file mode 100644
index 0000000..878dbf4
--- /dev/null
+++ b/modules/household/mixins/_reproduction.py
@@ -0,0 +1,126 @@
+from __future__ import annotations
+from typing import Optional, TYPE_CHECKING, override
+
+from simulation.ai.household_ai import HouseholdAI
+from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
+
+if TYPE_CHECKING:
+    from simulation.core_agents import Household
+    from modules.household.dtos import BioStateDTO, EconStateDTO, SocialStateDTO
+    from simulation.dtos.config_dtos import HouseholdConfigDTO
+    from modules.household.bio_component import BioComponent
+    from modules.household.econ_component import EconComponent
+    from simulation.decisions.base_decision_engine import BaseDecisionEngine
+    from logging import Logger
+
+class HouseholdReproductionMixin:
+    """
+    Mixin for Household reproduction and inheritance logic.
+    Handles cloning (child creation) and heir designation.
+    """
+
+    # Type hints for properties expected on self
+    id: int
+    logger: Logger
+    config: "HouseholdConfigDTO"
+    _bio_state: "BioStateDTO"
+    _econ_state: "EconStateDTO"
+    _social_state: "SocialStateDTO"
+    goods_info_map: dict
+    decision_engine: "BaseDecisionEngine"
+    value_orientation: str
+    risk_aversion: float
+
+    # Components
+    bio_component: "BioComponent"
+    econ_component: "EconComponent"
+
+    @override
+    def clone(self, new_id: int, initial_assets_from_parent: float, current_tick: int) -> "Household":
+        """
+        Clones the household. Orchestrates Bio and Econ cloning logic.
+        """
+        from simulation.core_agents import Household
+
+        # 1. Bio Cloning (Demographics)
+        offspring_demo = self.bio_component.create_offspring_demographics(
+            self._bio_state, new_id, current_tick, self.config
+        )
+
+        # 2. Econ Cloning (Inheritance)
+        # We need parent skills.
+        econ_inheritance = self.econ_component.prepare_clone_state(
+            self._econ_state, self._econ_state.skills, self.config
+        )
+
+        # 3. Create Decision Engine
+        new_decision_engine = self._create_new_decision_engine(new_id)
+
+        # 4. Instantiate New Household
+        # Combine args
+        cloned_household = Household(
+            id=new_id,
+            talent=self._econ_state.talent, # Copied reference
+            goods_data=[g for g in self.goods_info_map.values()],
+            initial_assets=initial_assets_from_parent,
+            initial_needs=self._bio_state.needs.copy(), # Inherit current needs or reset? Usually reset.
+            # BioComponent.create_offspring_demographics didn't return initial needs.
+            # We'll use copy of parent needs as per original logic.
+
+            decision_engine=new_decision_engine,
+            value_orientation=self.value_orientation,
+            personality=self._social_state.personality, # Inherit personality
+            config_dto=self.config,
+            loan_market=self.decision_engine.loan_market,
+            risk_aversion=self.risk_aversion,
+            logger=None,
+
+            # Demographics from Bio
+            initial_age=offspring_demo["initial_age"],
+            gender=offspring_demo["gender"],
+            parent_id=offspring_demo["parent_id"],
+            generation=offspring_demo["generation"]
+        )
+
+        # 5. Apply Econ Inheritance
+        cloned_household._econ_state.skills = econ_inheritance["skills"]
+        cloned_household._econ_state.education_level = econ_inheritance["education_level"]
+        cloned_household._econ_state.expected_wage = econ_inheritance["expected_wage"]
+        cloned_household._econ_state.labor_skill = econ_inheritance["labor_skill"]
+        if "aptitude" in econ_inheritance:
+             cloned_household._econ_state.aptitude = econ_inheritance["aptitude"]
+
+        return cloned_household
+
+    def _create_new_decision_engine(self, new_id: int) -> AIDrivenHouseholdDecisionEngine:
+        shared_ai_engine = self.decision_engine.ai_engine.ai_decision_engine
+        new_ai_engine = HouseholdAI(
+            agent_id=str(new_id),
+            ai_decision_engine=shared_ai_engine,
+            gamma=self.decision_engine.ai_engine.gamma,
+            epsilon=self.decision_engine.ai_engine.action_selector.epsilon,
+            base_alpha=self.decision_engine.ai_engine.base_alpha,
+            learning_focus=self.decision_engine.ai_engine.learning_focus
+        )
+        return AIDrivenHouseholdDecisionEngine(
+            ai_engine=new_ai_engine,
+            config_module=self.config,
+            logger=self.logger
+        )
+
+    def get_generational_similarity(self, other: "Household") -> float:
+        talent_diff = abs(self._econ_state.talent.base_learning_rate - other._econ_state.talent.base_learning_rate)
+        similarity = max(0.0, 1.0 - talent_diff)
+        return similarity
+
+    # --- IHeirProvider Implementation ---
+
+    def get_heir(self) -> Optional[int]:
+        """
+        Returns the ID of the designated heir (Spouse -> Oldest Child -> None).
+        """
+        if self._bio_state.spouse_id is not None:
+            return self._bio_state.spouse_id
+        if self._bio_state.children_ids:
+            return self._bio_state.children_ids[0]
+        return None
diff --git a/modules/household/mixins/_state_access.py b/modules/household/mixins/_state_access.py
new file mode 100644
index 0000000..0796715
--- /dev/null
+++ b/modules/household/mixins/_state_access.py
@@ -0,0 +1,113 @@
+from __future__ import annotations
+from typing import Dict, Any, TYPE_CHECKING
+import copy
+
+from modules.system.api import DEFAULT_CURRENCY
+from modules.household.dtos import HouseholdStateDTO, HouseholdSnapshotDTO
+from modules.household.services import HouseholdSnapshotAssembler
+
+if TYPE_CHECKING:
+    from modules.household.dtos import BioStateDTO, EconStateDTO, SocialStateDTO
+    from simulation.dtos.config_dtos import HouseholdConfigDTO
+
+class HouseholdStateAccessMixin:
+    """
+    Mixin for accessing Household state.
+    Provides methods to create DTOs and snapshots.
+    """
+
+    # Type hints for properties expected on self
+    id: int
+    config: "HouseholdConfigDTO"
+    _bio_state: "BioStateDTO"
+    _econ_state: "EconStateDTO"
+    _social_state: "SocialStateDTO"
+    preference_asset: float
+    preference_social: float
+    preference_growth: float
+    risk_aversion: float
+
+    def get_bio_state(self) -> "BioStateDTO":
+        """Returns the biological state DTO."""
+        return self._bio_state
+
+    def get_econ_state(self) -> "EconStateDTO":
+        """Returns the economic state DTO."""
+        return self._econ_state
+
+    def get_social_state(self) -> "SocialStateDTO":
+        """Returns the social state DTO."""
+        return self._social_state
+
+    def create_snapshot_dto(self) -> HouseholdSnapshotDTO:
+        """
+        Creates a structured snapshot of the household's current state.
+        Uses HouseholdSnapshotAssembler to ensure deep copies of component states.
+        """
+        # We need to pass 'self' to assemble, but 'self' here is the mixin instance,
+        # which will be the Household instance at runtime.
+        return HouseholdSnapshotAssembler.assemble(self)
+
+    def create_state_dto(self) -> HouseholdStateDTO:
+        """
+        [DEPRECATED] Use create_snapshot_dto instead.
+        Creates a comprehensive DTO of the household's current state (Adapter).
+        """
+        return HouseholdStateDTO(
+            id=self.id,
+            assets=self._econ_state.assets,
+            inventory=self._econ_state.inventory.copy(),
+            needs=self._bio_state.needs.copy(),
+            preference_asset=self.preference_asset,
+            preference_social=self.preference_social,
+            preference_growth=self.preference_growth,
+            personality=self._social_state.personality,
+            durable_assets=[d.copy() for d in self._econ_state.durable_assets],
+            expected_inflation=self._econ_state.expected_inflation.copy(),
+            is_employed=self._econ_state.is_employed,
+            current_wage=self._econ_state.current_wage,
+            wage_modifier=self._econ_state.wage_modifier,
+            is_homeless=self._econ_state.is_homeless,
+            residing_property_id=self._econ_state.residing_property_id,
+            owned_properties=list(self._econ_state.owned_properties),
+            portfolio_holdings={k: copy.copy(v) for k, v in self._econ_state.portfolio.holdings.items()},
+            risk_aversion=self.risk_aversion,
+            agent_data=self.get_agent_data(),
+            conformity=self._social_state.conformity,
+            social_rank=self._social_state.social_rank,
+            approval_rating=self._social_state.approval_rating,
+            optimism=self._social_state.optimism,
+            ambition=self._social_state.ambition,
+            perceived_fair_price=self._econ_state.perceived_avg_prices.copy(),
+            sentiment_index=self._social_state.optimism,
+            perceived_prices=self._econ_state.perceived_avg_prices.copy(),
+            demand_elasticity=getattr(self._social_state, 'demand_elasticity', 1.0)
+        )
+
+    def get_agent_data(self) -> Dict[str, Any]:
+        """Adapter for AI learning data."""
+        return {
+            "assets": self._econ_state.assets.get(DEFAULT_CURRENCY, 0.0),
+            "assets_dict": self._econ_state.assets.copy(), # Keep full dict available just in case
+            "needs": self._bio_state.needs.copy(),
+            "is_active": self._bio_state.is_active,
+            "is_employed": self._econ_state.is_employed,
+            "current_wage": self._econ_state.current_wage,
+            "employer_id": self._econ_state.employer_id,
+            "social_status": self._social_state.social_status,
+            "credit_frozen_until_tick": self._econ_state.credit_frozen_until_tick,
+            "is_homeless": self._econ_state.is_homeless,
+            "owned_properties_count": len(self._econ_state.owned_properties),
+            "residing_property_id": self._econ_state.residing_property_id,
+            "social_rank": self._social_state.social_rank,
+            "conformity": self._social_state.conformity,
+            "approval_rating": self._social_state.approval_rating,
+            "age": self._bio_state.age,
+            "education_level": self._econ_state.education_level,
+            "children_count": len(self._bio_state.children_ids),
+            "expected_wage": self._econ_state.expected_wage,
+            "gender": self._bio_state.gender,
+            "home_quality_score": self._econ_state.home_quality_score,
+            "spouse_id": self._bio_state.spouse_id,
+            "aptitude": self._econ_state.aptitude,
+        }
diff --git a/modules/household/services.py b/modules/household/services.py
index 1081929..22e8b21 100644
--- a/modules/household/services.py
+++ b/modules/household/services.py
@@ -19,12 +19,10 @@ class HouseholdSnapshotAssembler:
         # We assume the household components expose their state DTOs
         # and that we should copy them for the snapshot to be immutable.
 
-        # Access internal states directly from the agent facade as it exposes them
-        # (The Household class in core_agents.py stores them in _bio_state, _econ_state, _social_state)
-
-        bio_state_copy = household._bio_state.copy()
-        econ_state_copy = household._econ_state.copy()
-        social_state_copy = household._social_state.copy()
+        # Access internal states via public accessors (TD-217)
+        bio_state_copy = household.get_bio_state().copy()
+        econ_state_copy = household.get_econ_state().copy()
+        social_state_copy = household.get_social_state().copy()
 
         return HouseholdSnapshotDTO(
             id=household.id,
diff --git a/modules/market/housing_planner.py b/modules/market/housing_planner.py
index c2cb838..2eb1e23 100644
--- a/modules/market/housing_planner.py
+++ b/modules/market/housing_planner.py
@@ -10,6 +10,7 @@ from modules.housing.dtos import (
     HousingRentalDecisionDTO,
     HousingStayDecisionDTO
 )
+from modules.system.api import DEFAULT_CURRENCY
 
 logger = logging.getLogger(__name__)
 
@@ -27,7 +28,13 @@ class HousingPlanner(IHousingPlanner):
 
         # 1. Evaluate "Buy" Option
         # Use simple affordability metric: Price <= Assets / DownPaymentPct
-        max_price = household.econ_state.assets / self.DEFAULT_DOWN_PAYMENT_PCT
+        assets = household.econ_state.assets
+        if isinstance(assets, dict):
+            assets = assets.get(DEFAULT_CURRENCY, 0.0)
+        else:
+            assets = float(assets)
+
+        max_price = assets / self.DEFAULT_DOWN_PAYMENT_PCT
 
         affordable_properties = []
         if market.for_sale_units:
@@ -87,7 +94,13 @@ class HousingPlanner(IHousingPlanner):
         required_down = offer_price * self.DEFAULT_DOWN_PAYMENT_PCT
 
         # Ensure household has enough for down payment (already checked by max_price but good to be safe)
-        if household.econ_state.assets < required_down:
+        assets = household.econ_state.assets
+        if isinstance(assets, dict):
+            assets = assets.get(DEFAULT_CURRENCY, 0.0)
+        else:
+            assets = float(assets)
+
+        if assets < required_down:
              # Fallback: Can't afford down payment despite max_price check (maybe floating point or rounding)
              pass
 
diff --git a/simulation/core_agents.py b/simulation/core_agents.py
index 737a0ff..5a1ba62 100644
--- a/simulation/core_agents.py
+++ b/simulation/core_agents.py
@@ -8,18 +8,16 @@ import copy
 
 from simulation.base_agent import BaseAgent
 from simulation.decisions.base_decision_engine import BaseDecisionEngine
-from simulation.models import Order, StockOrder, Skill, Talent
+from simulation.models import Order, Skill, Talent
 from simulation.ai.api import (
     Personality,
     Tactic,
     Aggressiveness,
 )
-from simulation.core_markets import Market
-from simulation.interfaces.market_interface import IMarket
-from simulation.dtos import DecisionContext, FiscalContext, LeisureEffectDTO, LeisureType, MacroFinancialContext, ConsumptionResult, DecisionInputDTO
+from simulation.dtos import DecisionContext, FiscalContext, MacroFinancialContext, DecisionInputDTO
+
 from simulation.dtos.config_dtos import HouseholdConfigDTO
 from simulation.portfolio import Portfolio
-from modules.finance.api import IPortfolioHandler, IHeirProvider, PortfolioDTO, PortfolioAsset
 
 from simulation.ai.household_ai import HouseholdAI
 from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
@@ -41,18 +39,31 @@ from modules.household.dtos import (
 )
 from modules.household.services import HouseholdSnapshotAssembler
 from modules.household.api import (
-    HousingMarketUnitDTO, HousingMarketSnapshotDTO,
-    LoanMarketSnapshotDTO, LaborMarketSnapshotDTO,
-    MarketSnapshotDTO, OrchestrationContextDTO
+    OrchestrationContextDTO
 )
 
+# Mixins
+from modules.household.mixins._properties import HouseholdPropertiesMixin
+from modules.household.mixins._financials import HouseholdFinancialsMixin
+from modules.household.mixins._lifecycle import HouseholdLifecycleMixin
+from modules.household.mixins._reproduction import HouseholdReproductionMixin
+from modules.household.mixins._state_access import HouseholdStateAccessMixin
+
 if TYPE_CHECKING:
     from simulation.loan_market import LoanMarket
     from simulation.dtos.scenario import StressScenarioConfig
 
 logger = logging.getLogger(__name__)
 
-class Household(BaseAgent, ILearningAgent):
+class Household(
+    HouseholdPropertiesMixin,
+    HouseholdFinancialsMixin,
+    HouseholdLifecycleMixin,
+    HouseholdReproductionMixin,
+    HouseholdStateAccessMixin,
+    BaseAgent,
+    ILearningAgent
+):
     """
     Household Agent (Facade).
     Delegates Bio/Econ/Social logic to specialized stateless components.
@@ -270,240 +281,6 @@ class Household(BaseAgent, ILearningAgent):
             extra={"tags": ["household_init"]}
         )
 
-    # --- Property Overrides (BaseAgent & Compatibility) ---
-
-    @property
-    @override
-    def assets(self) -> Dict[CurrencyCode, float]:
-        return self._econ_state.assets
-
-    @assets.setter
-    def assets(self, value: Dict[CurrencyCode, float]) -> None:
-        self._econ_state.assets = value
-        self._assets = value
-
-    @property
-    @override
-    def inventory(self) -> Dict[str, float]:
-        return self._econ_state.inventory
-
-    @inventory.setter
-    def inventory(self, value: Dict[str, float]) -> None:
-        self._econ_state.inventory = value
-
-    @property
-    def inventory_quality(self) -> Dict[str, float]:
-        return self._econ_state.inventory_quality
-
-    @inventory_quality.setter
-    def inventory_quality(self, value: Dict[str, float]) -> None:
-        self._econ_state.inventory_quality = value
-
-    @property
-    @override
-    def needs(self) -> Dict[str, float]:
-        return self._bio_state.needs
-
-    @needs.setter
-    def needs(self, value: Dict[str, float]) -> None:
-        self._bio_state.needs = value
-
-    @property
-    def is_active(self) -> bool:
-        return self._bio_state.is_active
-
-    @is_active.setter
-    def is_active(self, value: bool) -> None:
-        self._bio_state.is_active = value
-
-    @property
-    def age(self) -> float:
-        return self._bio_state.age
-
-    @age.setter
-    def age(self, value: float) -> None:
-        self._bio_state.age = value
-
-    @property
-    def children_ids(self) -> List[int]:
-        return self._bio_state.children_ids
-
-    @children_ids.setter
-    def children_ids(self, value: List[int]) -> None:
-        self._bio_state.children_ids = value
-
-    @property
-    def is_homeless(self) -> bool:
-        return self._econ_state.is_homeless
-
-    @is_homeless.setter
-    def is_homeless(self, value: bool) -> None:
-        self._econ_state.is_homeless = value
-
-    @property
-    def residing_property_id(self) -> Optional[int]:
-        return self._econ_state.residing_property_id
-
-    @residing_property_id.setter
-    def residing_property_id(self, value: Optional[int]) -> None:
-        self._econ_state.residing_property_id = value
-
-    @property
-    def owned_properties(self) -> List[int]:
-        return self._econ_state.owned_properties
-
-    @owned_properties.setter
-    def owned_properties(self, value: List[int]) -> None:
-        self._econ_state.owned_properties = value
-
-    @property
-    def current_wage(self) -> float:
-        return self._econ_state.current_wage
-
-    @current_wage.setter
-    def current_wage(self, value: float) -> None:
-        self._econ_state.current_wage = value
-
-    @property
-    def is_employed(self) -> bool:
-        return self._econ_state.is_employed
-
-    @is_employed.setter
-    def is_employed(self, value: bool) -> None:
-        self._econ_state.is_employed = value
-
-    @property
-    def employer_id(self) -> Optional[int]:
-        return self._econ_state.employer_id
-
-    @employer_id.setter
-    def employer_id(self, value: Optional[int]) -> None:
-        self._econ_state.employer_id = value
-
-    @property
-    def skills(self) -> Dict[str, "Skill"]:
-        """[TD-162] Backward compat: Exposes _econ_state.skills."""
-        return self._econ_state.skills
-
-    @skills.setter
-    def skills(self, value: Dict[str, "Skill"]) -> None:
-        self._econ_state.skills = value
-
-    @property
-    def portfolio(self) -> "Portfolio":
-        """[TD-162] Backward compat: Exposes _econ_state.portfolio."""
-        return self._econ_state.portfolio
-
-    @portfolio.setter
-    def portfolio(self, value: "Portfolio") -> None:
-        self._econ_state.portfolio = value
-
-    @override
-    def _internal_add_assets(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
-        if currency not in self._econ_state.assets:
-            self._econ_state.assets[currency] = 0.0
-        self._econ_state.assets[currency] += amount
-        self._assets = self._econ_state.assets
-
-    @override
-    def _internal_sub_assets(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
-        if currency not in self._econ_state.assets:
-            self._econ_state.assets[currency] = 0.0
-        self._econ_state.assets[currency] -= amount
-        self._assets = self._econ_state.assets
-
-    @property
-    def gender(self) -> str:
-        """Exposes gender from bio_state."""
-        return self._bio_state.gender
-
-    @property
-    def home_quality_score(self) -> float:
-        """Exposes home_quality_score from econ_state."""
-        return self._econ_state.home_quality_score
-
-    @property
-    def talent(self) -> "Talent":
-        """Exposes talent from econ_state."""
-        return self._econ_state.talent
-
-    @property
-    def demographics(self) -> "BioStateDTO":
-        """[Legacy] Exposes bio_state as demographics."""
-        return self._bio_state
-
-    # --- Methods ---
-
-    def create_snapshot_dto(self) -> HouseholdSnapshotDTO:
-        """
-        Creates a structured snapshot of the household's current state.
-        Uses HouseholdSnapshotAssembler to ensure deep copies of component states.
-        """
-        return HouseholdSnapshotAssembler.assemble(self)
-
-    def create_state_dto(self) -> HouseholdStateDTO:
-        """
-        [DEPRECATED] Use create_snapshot_dto instead.
-        Creates a comprehensive DTO of the household's current state (Adapter).
-        """
-        return HouseholdStateDTO(
-            id=self.id,
-            assets=self._econ_state.assets,
-            inventory=self._econ_state.inventory.copy(),
-            needs=self._bio_state.needs.copy(),
-            preference_asset=self.preference_asset,
-            preference_social=self.preference_social,
-            preference_growth=self.preference_growth,
-            personality=self._social_state.personality,
-            durable_assets=[d.copy() for d in self._econ_state.durable_assets],
-            expected_inflation=self._econ_state.expected_inflation.copy(),
-            is_employed=self._econ_state.is_employed,
-            current_wage=self._econ_state.current_wage,
-            wage_modifier=self._econ_state.wage_modifier,
-            is_homeless=self._econ_state.is_homeless,
-            residing_property_id=self._econ_state.residing_property_id,
-            owned_properties=list(self._econ_state.owned_properties),
-            portfolio_holdings={k: copy.copy(v) for k, v in self._econ_state.portfolio.holdings.items()},
-            risk_aversion=self.risk_aversion,
-            agent_data=self.get_agent_data(),
-            conformity=self._social_state.conformity,
-            social_rank=self._social_state.social_rank,
-            approval_rating=self._social_state.approval_rating,
-            optimism=self._social_state.optimism,
-            ambition=self._social_state.ambition,
-            perceived_fair_price=self._econ_state.perceived_avg_prices.copy(),
-            sentiment_index=self._social_state.optimism,
-            perceived_prices=self._econ_state.perceived_avg_prices.copy(),
-            demand_elasticity=getattr(self._social_state, 'demand_elasticity', 1.0)
-        )
-
-    def get_agent_data(self) -> Dict[str, Any]:
-        """Adapter for AI learning data."""
-        return {
-            "assets": self._econ_state.assets,
-            "needs": self._bio_state.needs.copy(),
-            "is_active": self._bio_state.is_active,
-            "is_employed": self._econ_state.is_employed,
-            "current_wage": self._econ_state.current_wage,
-            "employer_id": self._econ_state.employer_id,
-            "social_status": self._social_state.social_status,
-            "credit_frozen_until_tick": self._econ_state.credit_frozen_until_tick,
-            "is_homeless": self._econ_state.is_homeless,
-            "owned_properties_count": len(self._econ_state.owned_properties),
-            "residing_property_id": self._econ_state.residing_property_id,
-            "social_rank": self._social_state.social_rank,
-            "conformity": self._social_state.conformity,
-            "approval_rating": self._social_state.approval_rating,
-            "age": self._bio_state.age,
-            "education_level": self._econ_state.education_level,
-            "children_count": len(self._bio_state.children_ids),
-            "expected_wage": self._econ_state.expected_wage,
-            "gender": self._bio_state.gender,
-            "home_quality_score": self._econ_state.home_quality_score,
-            "spouse_id": self._bio_state.spouse_id,
-            "aptitude": self._econ_state.aptitude,
-        }
-
     @override
     def make_decision(
         self,
@@ -547,9 +324,6 @@ class Household(BaseAgent, ILearningAgent):
         # We can construct it from snapshot if needed, or pass snapshot if engine is updated.
         # Ideally engines should be updated, but for now we might need to pass legacy DTO to context
         # if DecisionContext expects it.
-        # Checking DecisionContext definition... it likely expects HouseholdStateDTO.
-        # But we are deprecating it.
-        # Let's create legacy DTO for the legacy context, but use Snapshot for Orchestration.
         legacy_state_dto = self.create_state_dto()
 
         context = DecisionContext(
@@ -594,383 +368,3 @@ class Household(BaseAgent, ILearningAgent):
         )
 
         return refined_orders, chosen_tactic_tuple
-
-    def adjust_assets(self, delta: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
-        if currency not in self._econ_state.assets:
-            self._econ_state.assets[currency] = 0.0
-        self._econ_state.assets[currency] += delta
-
-    def modify_inventory(self, item_id: str, quantity: float) -> None:
-        if item_id not in self._econ_state.inventory:
-            self._econ_state.inventory[item_id] = 0
-        self._econ_state.inventory[item_id] += quantity
-
-    def add_property(self, property_id: int) -> None:
-        """Safely adds a property to the owned list."""
-        if property_id not in self._econ_state.owned_properties:
-            self._econ_state.owned_properties.append(property_id)
-
-    def remove_property(self, property_id: int) -> None:
-        """Safely removes a property from the owned list."""
-        if property_id in self._econ_state.owned_properties:
-            self._econ_state.owned_properties.remove(property_id)
-
-    def quit(self) -> None:
-        if self._econ_state.is_employed:
-            self.logger.info(f"Household {self.id} is quitting from Firm {self._econ_state.employer_id}")
-            self._econ_state.is_employed = False
-            self._econ_state.employer_id = None
-            self._econ_state.current_wage = 0.0
-
-    def consume(self, item_id: str, quantity: float, current_time: int) -> "ConsumptionResult":
-        # Delegate to ConsumptionManager
-        self._econ_state, new_needs, result = self.consumption_manager.consume(
-            self._econ_state,
-            self._bio_state.needs,
-            item_id,
-            quantity,
-            current_time,
-            self.goods_info_map.get(item_id, {}),
-            self.config
-        )
-        self._bio_state.needs = new_needs
-        return result
-
-    def trigger_emergency_liquidation(self) -> List[Any]:
-        """
-        WO-167: Generates emergency sell orders for all inventory items and stocks.
-        Returns mixed list of Order and StockOrder.
-        """
-        orders = []
-
-        # 1. Liquidate Inventory
-        for good, qty in self._econ_state.inventory.items():
-            if qty <= 0:
-                continue
-
-            price = self._econ_state.perceived_avg_prices.get(good, 10.0)
-            liquidation_price = price * self.config.emergency_liquidation_discount
-
-            order = Order(
-                agent_id=self.id,
-                side="SELL",
-                item_id=good,
-                quantity=qty,
-                price_limit=liquidation_price,
-                market_id=good
-            )
-            orders.append(order)
-
-        # 2. Liquidate Stocks
-        for firm_id, holding in self._econ_state.portfolio.holdings.items():
-            shares = holding.quantity
-            if shares <= 0:
-                continue
-
-            # Heuristic price for stock: we don't have access to stock market price here easily
-            # without checking markets. We'll use a very low price to ensure sale (market order effectively)
-            # or rely on the market to match.
-            # Ideally we check market data if passed, but here we assume desperation.
-            # We will use 1.0 or 0.1 as a "market sell" signal if the market supports it,
-            # but OrderBookMarket matches based on price.
-            # If we set price too low, we might crash the market.
-            # Let's try to be somewhat reasonable: 10.0 (default fallback) * 0.8 = 8.0
-            price = self.config.emergency_stock_liquidation_fallback_price
-
-            order = Order(
-                agent_id=self.id,
-                side="SELL",
-                item_id=f"stock_{firm_id}",
-                quantity=shares,
-                price_limit=price,
-                market_id="stock_market"
-            )
-            orders.append(order)
-
-        if orders:
-            self.logger.warning(
-                f"GRACE_PROTOCOL | Household {self.id} triggering emergency liquidation. Generated {len(orders)} orders.",
-                extra={"agent_id": self.id, "tags": ["grace_protocol", "liquidation"]}
-            )
-
-        return orders
-
-    @override
-    def update_needs(self, current_tick: int, market_data: Optional[Dict[str, Any]] = None):
-        """
-        Updates agent needs and lifecycle (Bio, Social, Econ-Work).
-        Replaces legacy AgentLifecycleComponent.
-        """
-        if not self._bio_state.is_active:
-            return
-
-        # 1. Work (Econ)
-        if self._econ_state.is_employed:
-            self._econ_state, labor_res = self.econ_component.work(
-                self._econ_state, 8.0, self.config
-            )
-            # We could log labor_res if needed
-
-        # 2. Update Psychology/Social (Needs & Death Check)
-        self._social_state, new_needs, new_durable_assets, is_active = self.social_component.update_psychology(
-            self._social_state,
-            self._bio_state.needs,
-            self._econ_state.assets,
-            self._econ_state.durable_assets,
-            self.goods_info_map,
-            self.config,
-            current_tick,
-            market_data
-        )
-        self._bio_state.needs = new_needs
-        self._econ_state.durable_assets = new_durable_assets
-
-        # WO-167: Grace Protocol - Override death if in distress grace period
-        if not is_active:
-            self.distress_tick_counter += 1
-            if self.distress_tick_counter <= getattr(self.config, "distress_grace_period_ticks", 10):
-                is_active = True
-                self.logger.info(
-                    f"GRACE_PROTOCOL_SAVE | Household {self.id} saved from death. Distress tick {self.distress_tick_counter}",
-                    extra={"agent_id": self.id, "tags": ["grace_protocol", "survival"]}
-                )
-        else:
-            self.distress_tick_counter = 0
-
-        self._bio_state.is_active = is_active
-
-        # 3. Update Political Opinion
-        self._social_state = self.social_component.update_political_opinion(
-            self._social_state, self._bio_state.needs.get("survival", 0.0)
-        )
-
-        # 4. Aging (Bio) - Also checks natural death
-        self._bio_state = self.bio_component.age_one_tick(
-            self._bio_state, self.config, current_tick
-        )
-
-        # 5. Skill Updates
-        self._econ_state = self.econ_component.update_skills(self._econ_state, self.config)
-
-    def apply_leisure_effect(self, leisure_hours: float, consumed_items: Dict[str, float]) -> LeisureEffectDTO:
-        self._social_state, self._econ_state.labor_skill, result = self.social_component.apply_leisure_effect(
-            self._social_state,
-            self._econ_state.labor_skill,
-            len(self._bio_state.children_ids),
-            leisure_hours,
-            consumed_items,
-            self.config
-        )
-        return result
-
-    @override
-    def update_perceived_prices(self, market_data: Dict[str, Any], stress_scenario_config: Optional["StressScenarioConfig"] = None) -> None:
-        self._econ_state = self.econ_component.update_perceived_prices(
-            self._econ_state, market_data, self.goods_info_map, stress_scenario_config, self.config
-        )
-
-    @override
-    def clone(self, new_id: int, initial_assets_from_parent: float, current_tick: int) -> "Household":
-        """
-        Clones the household. Orchestrates Bio and Econ cloning logic.
-        """
-        # 1. Bio Cloning (Demographics)
-        offspring_demo = self.bio_component.create_offspring_demographics(
-            self._bio_state, new_id, current_tick, self.config
-        )
-
-        # 2. Econ Cloning (Inheritance)
-        # We need parent skills.
-        econ_inheritance = self.econ_component.prepare_clone_state(
-            self._econ_state, self._econ_state.skills, self.config
-        )
-
-        # 3. Create Decision Engine
-        new_decision_engine = self._create_new_decision_engine(new_id)
-
-        # 4. Instantiate New Household
-        # Combine args
-        cloned_household = Household(
-            id=new_id,
-            talent=self._econ_state.talent, # Copied reference
-            goods_data=[g for g in self.goods_info_map.values()],
-            initial_assets=initial_assets_from_parent,
-            initial_needs=self._bio_state.needs.copy(), # Inherit current needs or reset? Usually reset.
-            # BioComponent.create_offspring_demographics didn't return initial needs.
-            # We'll use copy of parent needs as per original logic.
-
-            decision_engine=new_decision_engine,
-            value_orientation=self.value_orientation,
-            personality=self._social_state.personality, # Inherit personality
-            config_dto=self.config,
-            loan_market=self.decision_engine.loan_market,
-            risk_aversion=self.risk_aversion,
-            logger=None,
-
-            # Demographics from Bio
-            initial_age=offspring_demo["initial_age"],
-            gender=offspring_demo["gender"],
-            parent_id=offspring_demo["parent_id"],
-            generation=offspring_demo["generation"]
-        )
-
-        # 5. Apply Econ Inheritance
-        cloned_household._econ_state.skills = econ_inheritance["skills"]
-        cloned_household._econ_state.education_level = econ_inheritance["education_level"]
-        cloned_household._econ_state.expected_wage = econ_inheritance["expected_wage"]
-        cloned_household._econ_state.labor_skill = econ_inheritance["labor_skill"]
-        if "aptitude" in econ_inheritance:
-             cloned_household._econ_state.aptitude = econ_inheritance["aptitude"]
-
-        return cloned_household
-
-    def _create_new_decision_engine(self, new_id: int) -> AIDrivenHouseholdDecisionEngine:
-        shared_ai_engine = self.decision_engine.ai_engine.ai_decision_engine
-        new_ai_engine = HouseholdAI(
-            agent_id=str(new_id),
-            ai_decision_engine=shared_ai_engine,
-            gamma=self.decision_engine.ai_engine.gamma,
-            epsilon=self.decision_engine.ai_engine.action_selector.epsilon,
-            base_alpha=self.decision_engine.ai_engine.base_alpha,
-            learning_focus=self.decision_engine.ai_engine.learning_focus
-        )
-        return AIDrivenHouseholdDecisionEngine(
-            ai_engine=new_ai_engine,
-            config_module=self.config,
-            logger=self.logger
-        )
-
-    def get_generational_similarity(self, other: "Household") -> float:
-        talent_diff = abs(self._econ_state.talent.base_learning_rate - other._econ_state.talent.base_learning_rate)
-        similarity = max(0.0, 1.0 - talent_diff)
-        return similarity
-
-    def update_learning(self, context: LearningUpdateContext) -> None:
-        reward = context["reward"]
-        next_agent_data = context["next_agent_data"]
-        next_market_data = context["next_market_data"]
-
-        self.decision_engine.ai_engine.update_learning_v2(
-            reward=reward,
-            next_agent_data=next_agent_data,
-            next_market_data=next_market_data,
-        )
-
-    # Legacy method support
-    def add_education_xp(self, xp: float) -> None:
-        self._econ_state.education_xp += xp
-
-    def add_durable_asset(self, asset: Dict[str, Any]) -> None:
-        self._econ_state.durable_assets.append(asset)
-
-    def add_labor_income(self, income: float) -> None:
-        self._econ_state.labor_income_this_tick += income
-
-    def get_desired_wage(self) -> float:
-        if self._econ_state.assets < self.config.household_low_asset_threshold:
-            return self.config.household_low_asset_wage
-        return self.config.household_default_wage
-
-    def initialize_demographics(
-        self,
-        age: float,
-        gender: str,
-        parent_id: Optional[int],
-        generation: int,
-        spouse_id: Optional[int] = None
-    ) -> None:
-        """
-        Explicitly initializes demographic state.
-        Used by DemographicManager during agent creation.
-        """
-        self._bio_state.age = age
-        self._bio_state.gender = gender
-        self._bio_state.parent_id = parent_id
-        self._bio_state.generation = generation
-        self._bio_state.spouse_id = spouse_id
-
-    def initialize_personality(self, personality: Personality, desire_weights: Dict[str, float]) -> None:
-        """
-        Explicitly initializes personality and desire weights.
-        Used by DemographicManager and AITrainingManager (during brain inheritance).
-        """
-        self._social_state.personality = personality
-        self._social_state.desire_weights = desire_weights
-
-    def record_consumption(self, quantity: float, is_food: bool = False) -> None:
-        """
-        Updates consumption counters.
-        Used by Registry during transaction processing.
-        """
-        self._econ_state.current_consumption += quantity
-        if is_food:
-            self._econ_state.current_food_consumption += quantity
-
-    def reset_consumption_counters(self) -> None:
-        """
-        Resets consumption counters for the new tick.
-        Used by TickScheduler.
-        """
-        self._econ_state.current_consumption = 0.0
-        self._econ_state.current_food_consumption = 0.0
-        self._econ_state.labor_income_this_tick = 0.0
-        self._econ_state.capital_income_this_tick = 0.0
-
-    # Redundant methods removed/renamed to match BaseAgent
-    # The definitions above are sufficient if they are the only ones.
-    # But wait, there were two definitions in the file?
-    # I will verify if I need to replace the second block or if it was just me scrolling.
-    # The file content showed a second block near line 570.
-    # I will replace it as well to be safe or delete it if it is duplicate.
-    # Assuming valid python file, overriding twice is legal but weird.
-
-    @override
-    def adjust_assets(self, delta: float) -> None:
-        """
-        Adjusts assets by delta (positive or negative).
-        Delegates to _internal_add_assets or _internal_sub_assets to ensure validation and hooks run.
-        """
-        if delta >= 0:
-            self._internal_add_assets(delta)
-        else:
-            self._internal_sub_assets(abs(delta))
-
-    # --- IPortfolioHandler Implementation ---
-
-    def get_portfolio(self) -> PortfolioDTO:
-        assets = []
-        for firm_id, share in self._econ_state.portfolio.holdings.items():
-            assets.append(PortfolioAsset(
-                asset_type="stock",
-                asset_id=str(firm_id),
-                quantity=share.quantity
-            ))
-        return PortfolioDTO(assets=assets)
-
-    def receive_portfolio(self, portfolio: PortfolioDTO) -> None:
-        for asset in portfolio.assets:
-            if asset.asset_type == "stock":
-                try:
-                    firm_id = int(asset.asset_id)
-                    # TD-160: Inherited assets are integrated.
-                    # We use 0.0 acquisition price as default for inheritance if not specified.
-                    self._econ_state.portfolio.add(firm_id, asset.quantity, 0.0)
-                except ValueError:
-                    self.logger.error(f"Invalid firm_id in portfolio receive: {asset.asset_id}")
-            else:
-                self.logger.warning(f"Household received unhandled asset type: {asset.asset_type} (ID: {asset.asset_id})")
-
-    def clear_portfolio(self) -> None:
-        self._econ_state.portfolio.holdings.clear()
-
-    # --- IHeirProvider Implementation ---
-
-    def get_heir(self) -> Optional[int]:
-        """
-        Returns the ID of the designated heir (Spouse -> Oldest Child -> None).
-        """
-        if self._bio_state.spouse_id is not None:
-            return self._bio_state.spouse_id
-        if self._bio_state.children_ids:
-            return self._bio_state.children_ids[0]
-        return None
diff --git a/simulation/decisions/household/asset_manager.py b/simulation/decisions/household/asset_manager.py
index 2f08bd2..77544aa 100644
--- a/simulation/decisions/household/asset_manager.py
+++ b/simulation/decisions/household/asset_manager.py
@@ -5,6 +5,7 @@ from simulation.decisions.household.api import AssetManagementContext
 from simulation.decisions.portfolio_manager import PortfolioManager
 from simulation.decisions.household.stock_trader import StockTrader
 from simulation.ai.api import Personality
+from modules.system.api import DEFAULT_CURRENCY
 
 class AssetManager:
     """
@@ -15,6 +16,12 @@ class AssetManager:
     def __init__(self):
         self.stock_trader = StockTrader()
 
+    def _get_assets_value(self, household: Any) -> float:
+        assets = household.assets
+        if isinstance(assets, dict):
+            return assets.get(DEFAULT_CURRENCY, 0.0)
+        return float(assets)
+
     def decide_investments(self, context: AssetManagementContext) -> List[Order]:
         orders = []
         household = context.household
@@ -46,9 +53,10 @@ class AssetManager:
             cap_ratio = config.debt_repayment_cap
             liquidity_ratio = config.debt_liquidity_ratio
 
-            repay_amount = household.assets * base_ratio * stress_config.debt_aversion_multiplier
+            household_assets = self._get_assets_value(household)
+            repay_amount = household_assets * base_ratio * stress_config.debt_aversion_multiplier
             repay_amount = min(repay_amount, principal * cap_ratio)
-            repay_amount = min(repay_amount, household.assets * liquidity_ratio)
+            repay_amount = min(repay_amount, household_assets * liquidity_ratio)
 
             if repay_amount > 1.0:
                  orders.append(Order(
@@ -66,7 +74,7 @@ class AssetManager:
         # Logic for Portfolio Management vs Emergency Liquidity
         if current_time % 30 == 0:
             # Immutability Fix: Calculate effective cash instead of modifying DTO
-            effective_cash = household.assets
+            effective_cash = self._get_assets_value(household)
             if is_debt_aversion_mode and repay_amount > 0:
                 effective_cash -= repay_amount
 
@@ -105,7 +113,7 @@ class AssetManager:
     def get_debt_penalty(self, household: Any, market_data: Dict[str, Any], config: Any) -> float:
         debt_data = market_data.get("debt_data", {}).get(household.id, {})
         daily_interest_burden = debt_data.get("daily_interest_burden", 0.0)
-        income_proxy = max(household.current_wage, household.assets * 0.01)
+        income_proxy = max(household.current_wage, self._get_assets_value(household) * 0.01)
         dsr = daily_interest_burden / (income_proxy + 1e-9)
 
         debt_penalty = 1.0
@@ -203,7 +211,7 @@ class AssetManager:
         household = context.household
         market_data = context.market_data
 
-        if household.assets < 10.0:
+        if self._get_assets_value(household) < 10.0:
             deposit_data = market_data.get("deposit_data", {})
             deposit_balance = deposit_data.get(household.id, 0.0)
 
@@ -235,7 +243,7 @@ class AssetManager:
         if market_snapshot is None:
             return stock_orders
 
-        if household.assets < config.household_min_assets_for_investment:
+        if self._get_assets_value(household) < config.household_min_assets_for_investment:
             return stock_orders
 
         avg_dividend_yield = market_data.get("avg_dividend_yield", 0.05)
@@ -252,7 +260,7 @@ class AssetManager:
         risk_aversion = self._get_risk_aversion(household.personality)
 
         target_cash, target_deposit, target_equity = PortfolioManager.optimize_portfolio(
-            total_liquid_assets=household.assets,
+            total_liquid_assets=self._get_assets_value(household),
             risk_aversion=risk_aversion,
             risk_free_rate=risk_free_rate,
             equity_return_proxy=avg_dividend_yield,
diff --git a/simulation/decisions/household/consumption_manager.py b/simulation/decisions/household/consumption_manager.py
index 246e6e1..8fd0a38 100644
--- a/simulation/decisions/household/consumption_manager.py
+++ b/simulation/decisions/household/consumption_manager.py
@@ -2,6 +2,7 @@ from typing import List, Any, Optional, Tuple
 import random
 from simulation.models import Order
 from simulation.decisions.household.api import ConsumptionContext
+from modules.system.api import DEFAULT_CURRENCY
 from simulation.schemas import HouseholdActionVector
 
 class ConsumptionManager:
@@ -53,7 +54,13 @@ class ConsumptionManager:
             # If ask_price was found and is valid
             if ask_price is not None:
                 # Affordability Check
-                if household.assets >= ask_price:
+                household_assets = household.assets
+                if isinstance(household_assets, dict):
+                    household_assets = household_assets.get(DEFAULT_CURRENCY, 0.0)
+                else:
+                    household_assets = float(household_assets)
+
+                if household_assets >= ask_price:
                      premium = getattr(config, 'survival_bid_premium', 0.1)
                      if not isinstance(premium, (int, float)):
                          premium = 0.1
@@ -167,9 +174,15 @@ class ConsumptionManager:
                     quantity_to_buy *= (1.0 + 0.2 * conformity)
 
             # 5. Budget Constraint (Zero-Sum Integrity)
-            budget_limit = household.assets * config.budget_limit_normal_ratio
+            household_assets = household.assets
+            if isinstance(household_assets, dict):
+                household_assets = household_assets.get(DEFAULT_CURRENCY, 0.0)
+            else:
+                household_assets = float(household_assets)
+
+            budget_limit = household_assets * config.budget_limit_normal_ratio
             if max_need_value > config.budget_limit_urgent_need:
-                budget_limit = household.assets * config.budget_limit_urgent_ratio
+                budget_limit = household_assets * config.budget_limit_urgent_ratio
 
             # Determine Bid Price First
             # WO-157: Bid slightly above avg_price to ensure execution if urgent, capped at max_affordable_price.
diff --git a/simulation/decisions/household/labor_manager.py b/simulation/decisions/household/labor_manager.py
index a3a53ff..5d1e5f7 100644
--- a/simulation/decisions/household/labor_manager.py
+++ b/simulation/decisions/household/labor_manager.py
@@ -2,6 +2,7 @@ from typing import List
 import random
 from simulation.models import Order
 from simulation.decisions.household.api import LaborContext
+from modules.system.api import DEFAULT_CURRENCY
 
 class LaborManager:
     """
@@ -67,7 +68,13 @@ class LaborManager:
             food_price = market_data.get("goods_market", {}).get("basic_food_avg_traded_price", 10.0)
             if food_price <= 0: food_price = 10.0
 
-            survival_days = food_inventory + (household.assets / food_price)
+            household_assets = household.assets
+            if isinstance(household_assets, dict):
+                household_assets = household_assets.get(DEFAULT_CURRENCY, 0.0)
+            else:
+                household_assets = float(household_assets)
+
+            survival_days = food_inventory + (household_assets / food_price)
             critical_turns = getattr(config, "survival_critical_turns", 5)
 
             is_panic = False
diff --git a/tests/unit/household/test_snapshot_assembler.py b/tests/unit/household/test_snapshot_assembler.py
index a7f2053..49ad14d 100644
--- a/tests/unit/household/test_snapshot_assembler.py
+++ b/tests/unit/household/test_snapshot_assembler.py
@@ -20,6 +20,7 @@ class TestHouseholdSnapshotAssembler:
             children_ids=[1, 2]
         )
         household._bio_state = bio_state
+        household.get_bio_state.return_value = bio_state
 
         # Mock Econ State
         econ_state = EconStateDTO(
@@ -34,6 +35,7 @@ class TestHouseholdSnapshotAssembler:
             labor_income_this_tick=0, capital_income_this_tick=0
         )
         household._econ_state = econ_state
+        household.get_econ_state.return_value = econ_state
 
         # Mock Social State
         social_state = SocialStateDTO(
@@ -42,6 +44,7 @@ class TestHouseholdSnapshotAssembler:
             patience=0.5, optimism=0.5, ambition=0.5, last_leisure_type="IDLE"
         )
         household._social_state = social_state
+        household.get_social_state.return_value = social_state
 
         return household
 
diff --git a/tests/unit/test_household_ai.py b/tests/unit/test_household_ai.py
index e428f40..4e8ba58 100644
--- a/tests/unit/test_household_ai.py
+++ b/tests/unit/test_household_ai.py
@@ -64,7 +64,7 @@ def ai_engine_setup():
     return ai_engine_registry, value_orientation
 
 def create_mock_snapshot(market_data):
-    housing_snapshot = HousingMarketSnapshotDTO(for_sale_units=[], avg_rent_price=100.0, avg_sale_price=24000.0)
+    housing_snapshot = HousingMarketSnapshotDTO(for_sale_units=[], units_for_rent=[], avg_rent_price=100.0, avg_sale_price=24000.0)
     loan_snapshot = LoanMarketSnapshotDTO(interest_rate=0.05)
     labor_snapshot = LaborMarketSnapshotDTO(avg_wage=0.0)
 
