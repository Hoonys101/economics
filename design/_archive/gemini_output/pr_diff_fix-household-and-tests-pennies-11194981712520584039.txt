diff --git a/communications/insights/mission_household_fix.md b/communications/insights/mission_household_fix.md
new file mode 100644
index 00000000..14f7742a
--- /dev/null
+++ b/communications/insights/mission_household_fix.md
@@ -0,0 +1,39 @@
+# Mission Insights: Household Fixes & Integer Precision
+
+## Overview
+This mission focused on resolving failures in Household modules and Scenario diagnostics, primarily driven by the migration to integer pennies (`int`) for currency values and DTO field updates.
+
+## Key Changes & Fixes
+
+### 1. DTO Field Updates
+- **`EconStateDTO`**: Replaced `labor_income_this_tick` (float) with `labor_income_this_tick_pennies` (int).
+- **`HouseholdSnapshotDTO`**: Added `monthly_income_pennies` and `monthly_debt_payments_pennies`.
+- **`HouseholdSnapshotAssembler`**: Updated to accept integer arguments matching the new DTO fields.
+
+### 2. Integer Precision in Transaction Logic
+- **`TransactionManager`**:
+    - Identified a critical bug where `trade_value` (float) was passed to `SettlementSystem` via `government.collect_tax` or direct transfer logic for `labor` transactions.
+    - Updated `TransactionManager` to explicitly use `round_to_pennies` for `trade_value` calculation.
+    - Updated `execute` logic to convert `trade_value` (pennies) to dollars (float) before invoking `government.calculate_income_tax`, which still operates on floats (dollars).
+    - Converted the float result from `calculate_income_tax` back to integer pennies using `round_to_pennies(tax * 100)`.
+
+### 3. Tax Service & Fiscal Policy
+- **`TaxService`**:
+    - Discovered that `calculate_tax_liability` was returning `int(raw_liability)`, causing truncation of tax amounts (e.g., 16.25 -> 16).
+    - Updated `calculate_tax_liability` to return `float` (dollars), preserving precision for the caller (TransactionManager) to handle rounding/conversion.
+- **`FiscalPolicyManager`**:
+    - Verified that tax brackets are absolute values based on `survival_cost` calculated at initialization.
+    - Note: `survival_cost` depends on `HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK` (2.0) and initial `basic_food` price (5.0 or 10.0 depending on data availability).
+
+### 4. Test Corrections
+- **Wallet Float Usages**: Fixed multiple tests (`test_stress_scenarios.py`, `test_phase20_scaffolding.py`, `test_td194_integration.py`, `test_government.py`, `test_tax_incidence.py`) passing float values to `wallet.add` or `deposit`. Converted these inputs to integer pennies (e.g., `1000.0` -> `100000`).
+- **Assertion Updates**: Updated test assertions to expect integer values (pennies) or adjusted expectations based on corrected tax calculations.
+- **Mock Adjustments**: Updated mocks for `EconStateDTO` to include `shadow_reservation_wage_pennies` and `current_wage_pennies`.
+
+## Technical Debt & Insights
+- **Unit Mismatch**: There is persistent friction between `TransactionManager` (handling pennies for settlement) and `TaxService`/`Government` methods (expecting dollars for calculation). The explicit conversion in `TransactionManager` is a bridge, but a full migration of `TaxService` to pennies would be cleaner.
+- **Mock Consistency**: Many unit tests use `MagicMock` without full spec compliance or with legacy attribute names (`assets` as float instead of `wallet`). This requires careful updating when underlying contracts change.
+- **Configuration Ambiguity**: Config values like `TAX_BRACKETS` or `WEALTH_TAX_THRESHOLD` are implicitly dollars, requiring conversion when comparing against penny-based state. This implicit assumption is a source of bugs.
+
+## Conclusion
+The fixes enforce strict integer precision for settlement while maintaining the logic of progressive tax calculations (which require float precision for brackets). The `Household` and `Scenario` modules are now aligned with the new architectural guardrails.
diff --git a/modules/government/tax/service.py b/modules/government/tax/service.py
index 9ea439e2..b338ce12 100644
--- a/modules/government/tax/service.py
+++ b/modules/government/tax/service.py
@@ -48,7 +48,7 @@ class TaxService(ITaxService):
         """Determines the current fiscal policy based on market conditions."""
         return self.fiscal_policy_manager.determine_fiscal_stance(snapshot)
 
-    def calculate_tax_liability(self, policy: FiscalPolicyDTO, income: float) -> int:
+    def calculate_tax_liability(self, policy: FiscalPolicyDTO, income: float) -> float:
         """Calculates the tax amount for a given income and fiscal policy."""
         # Income is likely float from legacy or int pennies from new system.
         # Policy rate is float.
@@ -60,9 +60,9 @@ class TaxService(ITaxService):
         # Legacy manager might return float dollars. We need to handle this.
         # If `FiscalPolicyManager` is untouched, it just does `income * rate`.
         # int * float = float.
-        # We just round it.
+        # We return float to maintain precision (e.g. 16.25 dollars), allowing caller to round.
         raw_liability = self.fiscal_policy_manager.calculate_tax_liability(policy, income)
-        return int(raw_liability) # round_to_pennies handles Decimal but here it's simple mul.
+        return raw_liability
 
     def calculate_corporate_tax(self, profit: float, rate: float) -> int:
         """Calculates corporate tax based on profit and a flat rate."""
diff --git a/modules/household/services.py b/modules/household/services.py
index 50350684..a84df4e9 100644
--- a/modules/household/services.py
+++ b/modules/household/services.py
@@ -13,8 +13,8 @@ class HouseholdSnapshotAssembler:
     @staticmethod
     def assemble(
         household: "Household",
-        monthly_income: float = 0.0,
-        monthly_debt_payments: float = 0.0
+        monthly_income_pennies: int = 0,
+        monthly_debt_payments_pennies: int = 0
     ) -> HouseholdSnapshotDTO:
         """
         Creates a snapshot DTO from a household agent instance.
@@ -33,6 +33,6 @@ class HouseholdSnapshotAssembler:
             bio_state=bio_state_copy,
             econ_state=econ_state_copy,
             social_state=social_state_copy,
-            monthly_income=monthly_income,
-            monthly_debt_payments=monthly_debt_payments
+            monthly_income_pennies=monthly_income_pennies,
+            monthly_debt_payments_pennies=monthly_debt_payments_pennies
         )
diff --git a/modules/market/housing_planner.py b/modules/market/housing_planner.py
index 2eb1e23f..fcc37d72 100644
--- a/modules/market/housing_planner.py
+++ b/modules/market/housing_planner.py
@@ -51,7 +51,8 @@ class HousingPlanner(IHousingPlanner):
         # 2. Evaluate "Rent" Option
         best_rent_option = None
         if market.units_for_rent:
-             income = household.econ_state.current_wage
+             income_pennies = getattr(household.econ_state, 'current_wage_pennies', 0)
+             income = income_pennies / 100.0
              max_rent = income * 0.3
              affordable_rentals = [u for u in market.units_for_rent if (u.rent_price or 0) <= max_rent]
 
diff --git a/simulation/metrics/economic_tracker.py b/simulation/metrics/economic_tracker.py
index 1c08e91d..d4f6044e 100644
--- a/simulation/metrics/economic_tracker.py
+++ b/simulation/metrics/economic_tracker.py
@@ -354,11 +354,13 @@ class EconomicIndicatorTracker:
 
         # --- WO-043: Comprehensive Metrics ---
         # 1. Labor Share
-        total_labor_income = sum(
-            h._econ_state.labor_income_this_tick
+        # Sum labor income (pennies) and convert to dollars for reporting parity
+        total_labor_income_pennies = sum(
+            h._econ_state.labor_income_this_tick_pennies
             for h in households
             if h._bio_state.is_active
         )
+        total_labor_income = total_labor_income_pennies / 100.0
         record["total_labor_income"] = total_labor_income
 
         # Sales Volume
diff --git a/simulation/systems/demographic_manager.py b/simulation/systems/demographic_manager.py
index af5720fc..99343946 100644
--- a/simulation/systems/demographic_manager.py
+++ b/simulation/systems/demographic_manager.py
@@ -103,16 +103,16 @@ class DemographicManager:
             simulation.next_agent_id += 1
 
             # Asset Transfer calculation
-            parent_assets = 0.0
+            parent_assets = 0
             if hasattr(parent, 'wallet'):
                 parent_assets = parent.wallet.get_balance(DEFAULT_CURRENCY)
             elif hasattr(parent, 'assets') and isinstance(parent.assets, dict):
-                parent_assets = parent.assets.get(DEFAULT_CURRENCY, 0.0)
+                parent_assets = int(parent.assets.get(DEFAULT_CURRENCY, 0))
             elif hasattr(parent, 'assets'):
-                parent_assets = float(parent.assets)
+                parent_assets = int(parent.assets)
 
-            # TD-233: Round to 2 decimals to prevent floating point leaks
-            initial_gift = round(max(0.0, min(parent_assets * 0.1, parent_assets)), 2)
+            # TD-233: Calculate gift in pennies (10%)
+            initial_gift_pennies = int(max(0, min(parent_assets * 0.1, parent_assets)))
 
             try:
                 # Use Factory for creation
@@ -123,18 +123,18 @@ class DemographicManager:
                 new_children.append(child)
 
                 # WO-124: Transfer Birth Gift via SettlementSystem
-                if initial_gift > 0:
+                if initial_gift_pennies > 0:
                     # Prefer injected settlement_system, fallback to simulation object for compatibility
                     settlement = self.settlement_system or getattr(simulation, "settlement_system", None)
 
                     if settlement:
-                         settlement.transfer(parent, child, initial_gift, "BIRTH_GIFT")
+                         settlement.transfer(parent, child, initial_gift_pennies, "BIRTH_GIFT")
                     else:
                          self.logger.error("BIRTH_ERROR | SettlementSystem not found. Cannot transfer birth gift.")
 
                 self.logger.info(
                     f"BIRTH | Parent {parent.id} ({parent.age:.1f}y) -> Child {child.id}. "
-                    f"Assets: {initial_gift:.2f}",
+                    f"Assets: {initial_gift_pennies}",
                     extra={"parent_id": parent.id, "child_id": child.id, "tick": simulation.time}
                 )
             except Exception as e:
@@ -174,16 +174,18 @@ class DemographicManager:
             return
 
         # Calculate Tax
+        # Assets are in pennies if they came from wallet
+        total_assets_pennies = int(total_assets)
         tax_rate = getattr(self.config_module, "INHERITANCE_TAX_RATE", 0.0)
-        tax_amount = total_assets * tax_rate
-        net_estate = total_assets - tax_amount
+        tax_amount_pennies = int(total_assets_pennies * tax_rate)
+        net_estate_pennies = total_assets_pennies - tax_amount_pennies
 
         # Transfer Tax
-        if tax_amount > 0:
+        if tax_amount_pennies > 0:
             simulation.settlement_system.transfer(
                 deceased_agent,
                 simulation.government,
-                tax_amount,
+                tax_amount_pennies,
                 "inheritance_tax",
                 tick=simulation.time
             )
@@ -193,10 +195,9 @@ class DemographicManager:
 
         if heirs:
             # FIX: Use integer arithmetic (cents) to prevent floating point rounding errors and leaks
-            net_estate_cents = int(round(net_estate * 100))
             num_heirs = len(heirs)
-            share_cents = net_estate_cents // num_heirs
-            remainder_cents = net_estate_cents % num_heirs
+            share_cents = net_estate_pennies // num_heirs
+            remainder_cents = net_estate_pennies % num_heirs
 
             # Distribute shares
             for i, heir in enumerate(heirs):
@@ -205,27 +206,25 @@ class DemographicManager:
                 if i == num_heirs - 1:
                     amount_cents += remainder_cents
 
-                amount_to_send = amount_cents / 100.0
-
-                if amount_to_send > 0:
+                if amount_cents > 0:
                     simulation.settlement_system.transfer(
                         deceased_agent,
                         heir,
-                        amount_to_send,
+                        amount_cents,
                         "inheritance_distribution",
                         tick=simulation.time
                     )
 
                     self.logger.info(
-                        f"INHERITANCE | Heir {heir.id} received {amount_to_send:.2f} from {deceased_agent.id}.",
-                        extra={"heir_id": heir.id, "deceased_id": deceased_agent.id, "amount": amount_to_send}
+                        f"INHERITANCE | Heir {heir.id} received {amount_cents} from {deceased_agent.id}.",
+                        extra={"heir_id": heir.id, "deceased_id": deceased_agent.id, "amount": amount_cents}
                     )
         else:
             # No heirs: Escheatment to State
             simulation.settlement_system.transfer(
                 deceased_agent,
                 simulation.government,
-                net_estate,
+                net_estate_pennies,
                 "escheatment",
                 tick=simulation.time
             )
diff --git a/simulation/systems/handlers/inheritance_handler.py b/simulation/systems/handlers/inheritance_handler.py
index aa86591a..4b9911b2 100644
--- a/simulation/systems/handlers/inheritance_handler.py
+++ b/simulation/systems/handlers/inheritance_handler.py
@@ -25,20 +25,16 @@ class InheritanceHandler(ITransactionHandler):
 
         heir_ids = tx.metadata.get("heir_ids", []) if tx.metadata else []
 
-        # Round total cash to 2 decimals to prevent floating point dust propagation.
-        assets_val = 0.0
+        # Assets are in pennies (integer)
+        assets_val = 0
         if hasattr(deceased_agent, 'wallet'):
             assets_val = deceased_agent.wallet.get_balance(DEFAULT_CURRENCY)
         elif hasattr(deceased_agent, 'assets') and isinstance(deceased_agent.assets, dict):
-            assets_val = deceased_agent.assets.get(DEFAULT_CURRENCY, 0.0)
+            assets_val = int(deceased_agent.assets.get(DEFAULT_CURRENCY, 0))
         elif hasattr(deceased_agent, 'assets'):
-            assets_val = float(deceased_agent.assets)
+            assets_val = int(deceased_agent.assets)
 
-        # TD-233: Use floor to ensure we don't distribute non-existent rounded-up cents
-        total_cash = math.floor(assets_val * 100) / 100.0
-        dust = assets_val - total_cash
-
-        if total_cash <= 0 and dust <= 1e-9:
+        if assets_val <= 0:
             context.logger.info(f"INHERITANCE_SKIP | Agent {deceased_agent.id} has no assets ({assets_val}).")
             return True
 
@@ -49,11 +45,11 @@ class InheritanceHandler(ITransactionHandler):
              return True
 
         count = len(heir_ids)
-        # Calculate amount per heir, avoiding float precision issues (floor to cent)
-        base_amount = math.floor((total_cash / count) * 100) / 100.0
+        # Calculate amount per heir (integer division)
+        base_amount = assets_val // count
 
-        credits: List[Tuple[Any, float, str]] = []
-        distributed_sum = 0.0
+        credits: List[Tuple[Any, int, str]] = []
+        distributed_sum = 0
 
         agents = context.agents # SimulationState has agents dict
 
@@ -65,25 +61,21 @@ class InheritanceHandler(ITransactionHandler):
                 credits.append((heir, base_amount, "inheritance_distribution"))
                 distributed_sum += base_amount
 
-        # Last heir gets the remainder to ensure zero-sum of the rounded total
+        # Last heir gets the remainder to ensure zero-sum
         last_heir_id = heir_ids[-1]
         last_heir = agents.get(last_heir_id)
         if last_heir:
-            remaining_amount = round(total_cash - distributed_sum, 2)
-            # Ensure we don't transfer negative amounts or dust if something went wrong
+            remaining_amount = assets_val - distributed_sum
+            # Ensure we don't transfer negative amounts
             if remaining_amount > 0:
                 credits.append((last_heir, remaining_amount, "inheritance_distribution_final"))
 
-        # TD-233: Sweep fractional dust to Government to ensure Zero Leak (Agent balance -> 0.0)
-        if dust > 1e-9 and context.government:
-             credits.append((context.government, dust, "inheritance_dust_sweep"))
-
         # Atomic Settlement
         if credits:
             success = context.settlement_system.settle_atomic(deceased_agent, credits, context.time)
 
             if success:
-                 context.logger.info(f"INHERITANCE_SUCCESS | Distributed {total_cash} from {deceased_agent.id} to {count} heirs. Swept {dust:.4f} dust.")
+                 context.logger.info(f"INHERITANCE_SUCCESS | Distributed {assets_val} from {deceased_agent.id} to {count} heirs.")
             else:
                  context.logger.error(f"INHERITANCE_FAIL | Atomic settlement failed for {deceased_agent.id}.")
 
diff --git a/simulation/systems/transaction_manager.py b/simulation/systems/transaction_manager.py
index c2fee13a..0d3f2235 100644
--- a/simulation/systems/transaction_manager.py
+++ b/simulation/systems/transaction_manager.py
@@ -12,6 +12,7 @@ from simulation.dtos.api import SimulationState
 from simulation.models import Transaction
 from simulation.core_agents import Household
 from simulation.firms import Firm
+from modules.finance.utils.currency_math import round_to_pennies
 
 logger = logging.getLogger(__name__)
 
@@ -95,7 +96,7 @@ class TransactionManager(SystemInterface):
             if not buyer and not seller:
                 continue
 
-            trade_value = tx.quantity * tx.price
+            trade_value = round_to_pennies(tx.quantity * tx.price)
             tax_amount = 0.0
             success = False
 
@@ -249,7 +250,9 @@ class TransactionManager(SystemInterface):
 
                 # Calculate Tax (Standardized method call on Gov)
                 # Note: calculate_income_tax is on Government agent.
-                tax_amount = government.calculate_income_tax(trade_value, survival_cost)
+                # TaxService logic likely expects dollars (float)
+                tax_amount_float = government.calculate_income_tax(trade_value / 100.0, survival_cost)
+                tax_amount = round_to_pennies(tax_amount_float * 100)
 
                 if tax_payer == "FIRM":
                     # Firm pays Wage to Household
diff --git a/tests/integration/scenarios/test_stress_scenarios.py b/tests/integration/scenarios/test_stress_scenarios.py
index 3567d3bd..1c1c2767 100644
--- a/tests/integration/scenarios/test_stress_scenarios.py
+++ b/tests/integration/scenarios/test_stress_scenarios.py
@@ -279,7 +279,7 @@ class TestPhase28StressScenarios:
         config_dto.wage_decay_rate = 0.01
         config_dto.reservation_wage_floor = 1.0
         config_dto.household_min_wage_demand = 1.0
-        config_dto.panic_selling_asset_threshold = 500.0
+        config_dto.panic_selling_asset_threshold = 50000
         config_dto.initial_household_age_range = (20, 50)
         config_dto.initial_aptitude_distribution = (0.5, 0.1)
 
@@ -301,11 +301,11 @@ class TestPhase28StressScenarios:
             engine=MagicMock(),
             talent=MagicMock(),
             goods_data=[],
-            initial_assets_record=400.0, # Below threshold
+            initial_assets_record=40000, # Below threshold
             personality=Personality.CONSERVATIVE,
             config_dto=config_dto, # Pass DTO
         )
-        household.deposit(400.0, DEFAULT_CURRENCY)
+        household.deposit(40000, DEFAULT_CURRENCY)
         household._econ_state.portfolio = MagicMock()
         share_mock = MagicMock(spec=Share)
         share_mock.quantity = 10.0
diff --git a/tests/integration/test_phase20_scaffolding.py b/tests/integration/test_phase20_scaffolding.py
index 593308f8..ac32c5d2 100644
--- a/tests/integration/test_phase20_scaffolding.py
+++ b/tests/integration/test_phase20_scaffolding.py
@@ -35,7 +35,7 @@ class TestPhase20Scaffolding(unittest.TestCase):
             config_dto=create_household_config_dto(),
             loan_market=self.mock_loan_market
         )
-        h.deposit(initial_assets)
+        h.deposit(int(initial_assets * 100))
         return h
 
     def test_household_attributes_initialization(self):
diff --git a/tests/integration/test_td194_integration.py b/tests/integration/test_td194_integration.py
index 0b3a62e1..7864180d 100644
--- a/tests/integration/test_td194_integration.py
+++ b/tests/integration/test_td194_integration.py
@@ -38,7 +38,7 @@ class TestTD194Integration:
             personality=Personality.BALANCED,
             config_dto=config
         )
-        household.deposit(1000.0)
+        household.deposit(100000)
 
         # 2. Setup Input DTO
         market_snapshot = MarketSnapshotDTO(
@@ -91,7 +91,7 @@ class TestTD194Integration:
             productivity_factor=1.0,
             config_dto=config
         )
-        firm.deposit(10000.0)
+        firm.deposit(1000000)
 
         # 2. Setup Input DTO
         signals = {
diff --git a/tests/modules/household/engines/test_budget.py b/tests/modules/household/engines/test_budget.py
index ef4f97ea..09d0dee2 100644
--- a/tests/modules/household/engines/test_budget.py
+++ b/tests/modules/household/engines/test_budget.py
@@ -22,16 +22,16 @@ def mock_config():
 @pytest.fixture
 def econ_state():
     wallet = MagicMock()
-    wallet.get_balance.return_value = 100.0
+    wallet.get_balance.return_value = 10000 # 100.00
     wallet.owner_id = 1
 
     state = MagicMock(spec=EconStateDTO)
     state.wallet = wallet
     state.is_employed = False
-    state.shadow_reservation_wage = 10.0
+    state.shadow_reservation_wage_pennies = 1000
     state.market_wage_history = []
     state.is_homeless = True
-    state.current_wage = 0.0
+    state.current_wage_pennies = 0
     state.residing_property_id = None
     state.copy.return_value = state
     return state
@@ -58,7 +58,7 @@ def test_allocate_budget_creates_orders_for_needs(budget_engine, econ_state, moc
     output = budget_engine.allocate_budget(input_dto)
 
     assert "food" in output.budget_plan.allocations
-    assert output.budget_plan.allocations["food"] == 50.0
+    assert output.budget_plan.allocations["food"] == 5000 # 50.00
 
     # Verify Order creation
     assert len(output.budget_plan.orders) == 1
diff --git a/tests/system/test_audit_integrity.py b/tests/system/test_audit_integrity.py
index 0cf6fcdb..1434d6cd 100644
--- a/tests/system/test_audit_integrity.py
+++ b/tests/system/test_audit_integrity.py
@@ -33,13 +33,20 @@ class TestEconomicIntegrityAudit(unittest.TestCase):
         self.government = MagicMock()
         self.government.id = 1
 
+    @patch('simulation.factories.agent_factory.HouseholdFactory')
     @patch('simulation.systems.demographic_manager.Household')
     @patch('simulation.systems.demographic_manager.create_config_dto')
-    def test_birth_gift_rounding(self, mock_create_config, mock_household_cls):
+    def test_birth_gift_rounding(self, mock_create_config, mock_household_cls, mock_factory_cls):
         """
-        Verify that birth gift is rounded to 2 decimal places.
+        Verify that birth gift is calculated in pennies (integer).
         """
         dm = DemographicManager(config_module=self.config)
+
+        # Inject mock factory into the instance if needed, or rely on patch
+        # Since dm.__init__ instantiates HouseholdFactory, we mock the class before init or patch it.
+        # Here we patched the class, so dm.household_factory will be a Mock.
+        mock_factory_instance = mock_factory_cls.return_value
+
         dm.settlement_system = self.settlement_system
         dm.logger = self.logger
 
@@ -51,19 +58,19 @@ class TestEconomicIntegrityAudit(unittest.TestCase):
         simulation.goods_data = {}
         simulation.agents = {}
 
-        # Mock Household Instance
+        # Mock Child creation
         mock_child = MagicMock()
         mock_child.id = 100
         mock_child.gender = "Female"
-        mock_household_cls.return_value = mock_child
+        mock_factory_instance.create_newborn.return_value = mock_child
 
-        # Parent with fractional assets
+        # Parent with integer assets (10000 pennies = 100.00 dollars)
         parent = MagicMock()
         parent.id = 10
         parent.age = 30
-        parent.assets = 100.005 # Fractional
+        parent.assets = 10000
         parent.wallet = MagicMock()
-        parent.wallet.get_balance.return_value = 100.005
+        parent.wallet.get_balance.return_value = 10000
         parent.talent = MagicMock()
         parent.personality = MagicMock()
         parent.value_orientation = "NEUTRAL"
@@ -76,28 +83,27 @@ class TestEconomicIntegrityAudit(unittest.TestCase):
         # Execute
         dm.process_births(simulation, birth_requests)
 
-        # Expected Gift: 10% of 100.005 = 10.0005 -> Rounded to 10.00
-
+        # Expected Gift: 10% of 10000 = 1000 pennies
         args = self.settlement_system.transfer.call_args
         if args:
             # args[0] are positional args: (debit, credit, amount, memo)
             amount = args[0][2]
-            self.assertAlmostEqual(amount, 10.00, places=2)
-            self.assertNotEqual(amount, 10.0005, "Birth gift should be rounded")
+            self.assertEqual(amount, 1000)
+            self.assertIsInstance(amount, int)
         else:
             self.fail("No transfer call detected")
 
-    def test_inheritance_dust_sweep(self):
+    def test_inheritance_distribution(self):
         """
-        Verify that inheritance distribution sweeps dust to government.
+        Verify that inheritance distribution transfers full amount to heir (no dust sweep).
         """
         handler = InheritanceHandler()
 
         deceased = MagicMock()
         deceased.id = 99
-        deceased.assets = 100.005 # Fractional assets (100.00 + 0.005 dust)
+        deceased.assets = 10005 # 100.05 dollars
         deceased.wallet = MagicMock()
-        deceased.wallet.get_balance.return_value = 100.005
+        deceased.wallet.get_balance.return_value = 10005
 
         heir = MagicMock()
         heir.id = 101
@@ -107,7 +113,7 @@ class TestEconomicIntegrityAudit(unittest.TestCase):
             seller_id=-1,
             item_id="estate_distribution",
             quantity=1.0,
-            price=100.00,
+            price=10000,
             market_id="system",
             transaction_type="inheritance_distribution",
             time=0,
@@ -147,18 +153,16 @@ class TestEconomicIntegrityAudit(unittest.TestCase):
         credits = call_args[0][1]
 
         # Expect:
-        # 1. Heir gets 100.00
-        # 2. Government gets 0.005 (dust)
+        # 1. Heir gets 10005 (Full amount)
+        # 2. No dust sweep to government
 
         heir_credit = next((c for c in credits if c[0] == heir), None)
         gov_credit = next((c for c in credits if c[0] == self.government), None)
 
         self.assertIsNotNone(heir_credit)
-        self.assertAlmostEqual(heir_credit[1], 100.00)
+        self.assertEqual(heir_credit[1], 10005)
 
-        self.assertIsNotNone(gov_credit)
-        self.assertAlmostEqual(gov_credit[1], 0.005)
-        self.assertEqual(gov_credit[2], "inheritance_dust_sweep")
+        self.assertIsNone(gov_credit, "No dust sweep expected for single heir")
 
     def test_public_manager_tax_atomicity(self):
         """
@@ -177,7 +181,7 @@ class TestEconomicIntegrityAudit(unittest.TestCase):
             seller_id=pm.id,
             item_id="basic_food",
             quantity=10,
-            price=5.0, # Total 50.0
+            price=500, # Total 5000 pennies
             market_id="system",
             transaction_type="goods", # Taxable
             time=0
@@ -203,7 +207,7 @@ class TestEconomicIntegrityAudit(unittest.TestCase):
 
         # Setup tax calculation
         mock_intent = MagicMock()
-        mock_intent.amount = 2.5 # 5% of 50
+        mock_intent.amount = 250 # 5% of 5000
         mock_intent.reason = "sales_tax"
         mock_intent.payer_id = buyer.id
         self.taxation_system.calculate_tax_intents.return_value = [mock_intent]
@@ -222,10 +226,10 @@ class TestEconomicIntegrityAudit(unittest.TestCase):
         gov_credit = next((c for c in credits if c[0] == self.government), None)
 
         self.assertIsNotNone(pm_credit)
-        self.assertEqual(pm_credit[1], 50.0)
+        self.assertEqual(pm_credit[1], 5000)
 
         self.assertIsNotNone(gov_credit)
-        self.assertEqual(gov_credit[1], 2.5)
+        self.assertEqual(gov_credit[1], 250)
 
 if __name__ == '__main__':
     unittest.main()
diff --git a/tests/unit/agents/test_government.py b/tests/unit/agents/test_government.py
index f2d83ba3..37f9663e 100644
--- a/tests/unit/agents/test_government.py
+++ b/tests/unit/agents/test_government.py
@@ -162,12 +162,12 @@ def test_deficit_spending_allowed_within_limit(deficit_government_setup):
     # Asset is 1000. Request 500. No bonds needed.
     # We want to force bonds.
     # Set assets (Wallet) to low.
-    government.wallet._balances[DEFAULT_CURRENCY] = 100.0
+    government.wallet._balances[DEFAULT_CURRENCY] = 10000
 
     mock_finance = government.finance_system
 
     def issue_bonds_side_effect(amount, tick):
-        government.wallet.add(amount, DEFAULT_CURRENCY)
+        government.wallet.add(int(amount), DEFAULT_CURRENCY)
         return (["bond"], [Mock(transaction_type='bond_issuance')])
 
     mock_finance.issue_treasury_bonds.side_effect = issue_bonds_side_effect
@@ -175,13 +175,13 @@ def test_deficit_spending_allowed_within_limit(deficit_government_setup):
     target_agent = Mock()
     target_agent.id = "target_1"
 
-    txs = government.provide_household_support(target_agent, 500, current_tick=1)
+    txs = government.provide_household_support(target_agent, 50000, current_tick=1)
 
     # Needed 400. Bonds issued.
     # Should have welfare tx (500) and bond txs.
     assert len(txs) >= 1
     welfare_tx = [tx for tx in txs if tx.transaction_type == 'welfare'][0]
-    assert welfare_tx.price == 500
+    assert welfare_tx.price == 50000
 
     # Verify bond issuance requested
     mock_finance.issue_treasury_bonds.assert_called()
diff --git a/tests/unit/household/test_snapshot_assembler.py b/tests/unit/household/test_snapshot_assembler.py
index 01250ce4..aa41738b 100644
--- a/tests/unit/household/test_snapshot_assembler.py
+++ b/tests/unit/household/test_snapshot_assembler.py
@@ -17,7 +17,7 @@ class TestHouseholdSnapshotAssembler:
             gender="F",
             generation=1,
             initial_needs={"survival": 50},
-            assets=1000.0,
+            assets=100000,
             personality=Personality.CONSERVATIVE,
         )
         # Customize state for specific test requirements
@@ -26,7 +26,7 @@ class TestHouseholdSnapshotAssembler:
         household._econ_state.inventory = {"food": 10}
         household._econ_state.is_employed = True
         household._econ_state.employer_id = 5
-        household._econ_state.current_wage = 100
+        household._econ_state.current_wage_pennies = 10000
         # ... other econ state overrides if needed for specific assertions
 
         return household
@@ -42,18 +42,18 @@ class TestHouseholdSnapshotAssembler:
         # Verify Content Matches
         assert snapshot.bio_state.age == 30
         from modules.system.api import DEFAULT_CURRENCY
-        assert snapshot.econ_state.wallet.get_balance(DEFAULT_CURRENCY) == 1000.0
+        assert snapshot.econ_state.wallet.get_balance(DEFAULT_CURRENCY) == 100000
         assert snapshot.social_state.personality == Personality.CONSERVATIVE
 
         # Verify Independence (Copy Check)
         # Modify the original household state
         mock_household._bio_state.age = 31
-        mock_household.deposit(1000.0) # 1000 + 1000 = 2000
+        mock_household.deposit(100000) # 1000 + 1000 = 2000 (represented as pennies)
         mock_household._bio_state.children_ids.append(3)
 
         # Snapshot should remain unchanged
         assert snapshot.bio_state.age == 30
-        assert snapshot.econ_state.wallet.get_balance(DEFAULT_CURRENCY) == 1000.0
+        assert snapshot.econ_state.wallet.get_balance(DEFAULT_CURRENCY) == 100000
         assert len(snapshot.bio_state.children_ids) == 2
 
     def test_assemble_nested_structures(self, mock_household):
diff --git a/tests/unit/test_tax_collection.py b/tests/unit/test_tax_collection.py
index 639c35d6..41d50a7b 100644
--- a/tests/unit/test_tax_collection.py
+++ b/tests/unit/test_tax_collection.py
@@ -66,20 +66,22 @@ def test_atomic_wealth_tax_collection_success():
     # Household with assets > threshold (1000)
     # Assets = 2000. Taxable = 1000.
     # Rate per tick = 0.02 / 100 = 0.0002
-    # Tax = 1000 * 0.0002 = 0.2
-    household = MockAgent(id="HH1", assets=2000.0)
+    # Tax = 1000 * 0.0002 = 0.2 dollars = 20 pennies
+    # Assets = 2000.00 -> 200000 pennies
+    household = MockAgent(id="HH1", assets=200000)
 
     market_data = {"goods_market": {"basic_food_current_sell_price": 10.0}}
 
     txs = gov.run_welfare_check([household], market_data, current_tick=1)
 
     # Check assets transferred
-    assert household.assets == 2000.0 - 0.2
-    assert gov.assets == 0.2
+    # 200000 - 20 = 199980
+    assert household.assets == 199980
+    assert gov.assets == 20
 
     # Check stats
-    assert gov.total_collected_tax[DEFAULT_CURRENCY] == 0.2
-    assert gov.tax_revenue["wealth_tax"] == 0.2
+    assert gov.total_collected_tax[DEFAULT_CURRENCY] == 20
+    assert gov.tax_revenue["wealth_tax"] == 20
 
     # Check transactions: NO transaction objects for tax should be returned
     tax_txs = [t for t in txs if t.transaction_type == "tax"]
@@ -94,7 +96,7 @@ def test_atomic_wealth_tax_collection_insufficient_funds():
     # This scenario is hard to hit because logic is min(tax, assets).
     # So let's force a situation where transfer fails by mocking settlement to fail
 
-    household = MockAgent(id="HH1", assets=2000.0)
+    household = MockAgent(id="HH1", assets=200000)
 
     # Override settlement to always fail
     settlement.transfer = MagicMock(return_value=False)
@@ -104,7 +106,7 @@ def test_atomic_wealth_tax_collection_insufficient_funds():
     gov.run_welfare_check([household], market_data, current_tick=1)
 
     # Assets unchanged
-    assert household.assets == 2000.0
+    assert household.assets == 200000
     assert gov.assets == 0.0
 
     # Stats unchanged
@@ -117,17 +119,17 @@ def test_government_collect_tax_adapter_success():
     settlement = MockSettlementSystem()
     gov.settlement_system = settlement
 
-    payer = MockAgent(id="PAYER", assets=100.0)
-    amount = 10.0
+    payer = MockAgent(id="PAYER", assets=10000)
+    amount = 1000
 
     collected = gov.collect_tax(amount, "test_tax", payer, current_tick=1)
 
-    assert collected['amount_collected'] == 10.0
+    assert collected['amount_collected'] == 1000
     assert collected['success'] is True
-    assert payer.assets == 90.0
-    assert gov.assets == 10.0
-    assert gov.total_collected_tax[DEFAULT_CURRENCY] == 10.0
-    assert gov.tax_revenue["test_tax"] == 10.0
+    assert payer.assets == 9000
+    assert gov.assets == 1000
+    assert gov.total_collected_tax[DEFAULT_CURRENCY] == 1000
+    assert gov.tax_revenue["test_tax"] == 1000
 
 def test_government_collect_tax_adapter_failure():
     config = MockConfig()
@@ -135,14 +137,14 @@ def test_government_collect_tax_adapter_failure():
     settlement = MockSettlementSystem()
     gov.settlement_system = settlement
 
-    payer = MockAgent(id="PAYER", assets=5.0) # Less than 10
-    amount = 10.0
+    payer = MockAgent(id="PAYER", assets=500) # Less than 1000
+    amount = 1000
 
     collected = gov.collect_tax(amount, "test_tax", payer, current_tick=1)
 
     assert collected['amount_collected'] == 0.0
     assert collected['success'] is False
-    assert payer.assets == 5.0
+    assert payer.assets == 500
     assert gov.assets == 0.0
     assert gov.total_collected_tax[DEFAULT_CURRENCY] == 0.0
     assert "test_tax" not in gov.tax_revenue
diff --git a/tests/unit/test_tax_incidence.py b/tests/unit/test_tax_incidence.py
index 6d8a4a58..cd55c63b 100644
--- a/tests/unit/test_tax_incidence.py
+++ b/tests/unit/test_tax_incidence.py
@@ -63,7 +63,7 @@ class TestTaxIncidence(unittest.TestCase):
         )
         # Manually deposit initial assets as per new Household behavior
         if assets > 0:
-            h.deposit(assets, DEFAULT_CURRENCY)
+            h.deposit(int(assets * 100), DEFAULT_CURRENCY)
         return h
 
     def _create_firm(self, id: int, assets: float):
@@ -86,7 +86,7 @@ class TestTaxIncidence(unittest.TestCase):
             personality=Personality.BALANCED
         )
         if assets > 0:
-            f.deposit(assets, DEFAULT_CURRENCY)
+            f.deposit(int(assets * 100), DEFAULT_CURRENCY)
         return f
 
     def _setup_simulation(self, h, f):
@@ -149,16 +149,16 @@ class TestTaxIncidence(unittest.TestCase):
         f = self._create_firm(101, 5000.0)
         sim = self._setup_simulation(h, f)
         
-        # 100원 매칭 (노동 거래)
+        # 100원 매칭 (노동 거래). Price 10000 pennies (100.00 dollars)
         from simulation.models import Transaction
-        tx = Transaction(buyer_id=101, seller_id=1, item_id="labor", quantity=1.0, price=100.0, market_id="labor", transaction_type="labor", time=1)
+        tx = Transaction(buyer_id=101, seller_id=1, item_id="labor", quantity=1.0, price=10000, market_id="labor", transaction_type="labor", time=1)
         sim._process_transactions([tx])
         
-        # 가계: 1000 + (100 - 16.25) = 1083.75 (Progressive Tax)
-        # 기업: 5000 - 100 = 4900
-        self.assertEqual(h.assets, 1083.75)
-        self.assertEqual(f.assets, 4900.0)
-        self.assertEqual(sim.government.assets, 16.25)
+        # 가계: 100000 + (10000 - 1625) = 108375
+        # 기업: 500000 - 10000 = 490000
+        self.assertEqual(h.assets, 108375)
+        self.assertEqual(f.assets, 490000)
+        self.assertEqual(sim.government.assets, 1625)
         print("✓ Household Payer (Withholding): Agent Assets Correct")
 
     def test_firm_payer_scenario(self):
@@ -168,16 +168,16 @@ class TestTaxIncidence(unittest.TestCase):
         f = self._create_firm(101, 5000.0)
         sim = self._setup_simulation(h, f)
         
-        # 100원 매칭 (노동 거래)
+        # 100원 매칭 (노동 거래). Price 10000 pennies
         from simulation.models import Transaction
-        tx = Transaction(buyer_id=101, seller_id=1, item_id="labor", quantity=1.0, price=100.0, market_id="labor", transaction_type="labor", time=1)
+        tx = Transaction(buyer_id=101, seller_id=1, item_id="labor", quantity=1.0, price=10000, market_id="labor", transaction_type="labor", time=1)
         sim._process_transactions([tx])
         
-        # 가계: 1000 + 100 = 1100
-        # 기업: 5000 - (100 + 16.25) = 4883.75
-        self.assertEqual(h.assets, 1100.0)
-        self.assertEqual(f.assets, 4883.75)
-        self.assertEqual(sim.government.assets, 16.25)
+        # 가계: 100000 + 10000 = 110000
+        # 기업: 500000 - (10000 + 1625) = 488375
+        self.assertEqual(h.assets, 110000)
+        self.assertEqual(f.assets, 488375)
+        self.assertEqual(sim.government.assets, 1625)
         print("✓ Firm Payer (Extra Tax): Agent Assets Correct")
 
 if __name__ == "__main__":
