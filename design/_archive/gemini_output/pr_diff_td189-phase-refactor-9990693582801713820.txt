diff --git a/communications/insights/TD-189_Phase_Refactor.md b/communications/insights/TD-189_Phase_Refactor.md
new file mode 100644
index 0000000..4dc43df
--- /dev/null
+++ b/communications/insights/TD-189_Phase_Refactor.md
@@ -0,0 +1,20 @@
+# Technical Debt & Insights: Phase 1 Refactoring (TD-189)
+
+## Overview
+This refactoring successfully decomposed the "God Method" `Phase1_Decision.execute` into `MarketSignalFactory` and `DecisionInputFactory`, significantly improving modularity and testability.
+
+## Technical Debt Addressed
+- **God Method**: `Phase1_Decision.execute` was stripped of complex DTO assembly and market signal calculation logic.
+- **Entangled Responsibilities**: Market signal generation and Input DTO construction are now separated into dedicated factories.
+- **Testability**: New factories can be tested in isolation (see `tests/unit/test_factories.py`).
+
+## Discoveries & Insights
+1.  **ActionProcessor Bug**: During verification, it was discovered that `ActionProcessor` was not passing `settlement_system` to the transient `SimulationState` it creates for transaction processing. This caused integration tests to fail (AttributeError on `settlement_system.settle_atomic`). This was fixed in `simulation/action_processor.py` by retrieving `settlement_system` from `world_state`.
+2.  **Legacy Code in Tests**: Existing integration tests (`tests/integration/test_engine.py`) rely heavily on mocks and specific configuration states. Some tests failed due to logic unrelated to Phase 1 (e.g., TaxationSystem assuming buyer object existence), indicating fragility in the test suite regarding "invalid agent" scenarios.
+3.  **Commerce System Return Type**: The `CommerceSystem.plan_consumption_and_leisure` method returns a tuple, but mocks in tests need to be explicitly configured to return a tuple to avoid unpacking errors.
+4.  **Dataclass Replacement**: `dataclasses.replace` strictly requires dataclass instances. Mocks used in tests must be replaced with real DTOs when passing them to code that uses `replace`.
+
+## Recommendations
+- **Audit ActionProcessor**: The `ActionProcessor` creates a transient `SimulationState`. This pattern is risky as it requires manual synchronization of fields between `WorldState` (or `Simulation`) and `SimulationState`. Consider a factory or a method on `WorldState` to generate a snapshot `SimulationState`.
+- **TaxationSystem Robustness**: `TaxationSystem` should handle cases where `buyer` or `seller` are None or invalid more gracefully, or `TransactionProcessor` should validate agents before calling handlers.
+- **Test Suite Modernization**: `test_engine.py` seems to carry a lot of legacy setup. Breaking it down into smaller, focused integration tests would be beneficial.
diff --git a/simulation/action_processor.py b/simulation/action_processor.py
index 1214407..c5fc6c8 100644
--- a/simulation/action_processor.py
+++ b/simulation/action_processor.py
@@ -57,6 +57,7 @@ class ActionProcessor:
                 logger=self.world_state.logger,
                 ai_training_manager=getattr(self.world_state, "ai_training_manager", None),
                 ai_trainer=getattr(self.world_state, "ai_trainer", None),
+                settlement_system=getattr(self.world_state, "settlement_system", None),
                 next_agent_id=self.world_state.next_agent_id,
                 real_estate_units=self.world_state.real_estate_units,
                 transactions=transactions
diff --git a/simulation/orchestration/api.py b/simulation/orchestration/api.py
index 4384d49..01169df 100644
--- a/simulation/orchestration/api.py
+++ b/simulation/orchestration/api.py
@@ -1,8 +1,11 @@
 from __future__ import annotations
-from typing import Protocol, TYPE_CHECKING
+from typing import Protocol, TYPE_CHECKING, Dict, Any
 
 if TYPE_CHECKING:
-    from simulation.dtos.api import SimulationState
+    from simulation.dtos.api import SimulationState, DecisionInputDTO
+    from modules.system.api import MarketSignalDTO, MarketSnapshotDTO
+    from simulation.world_state import WorldState
+
 
 class IPhaseStrategy(Protocol):
     """Interface for a single phase of the simulation tick."""
@@ -18,3 +21,42 @@ class IPhaseStrategy(Protocol):
             The potentially modified simulation state DTO.
         """
         ...
+
+
+class IMarketSignalFactory(Protocol):
+    """Defines the contract for creating market signals from the current market state."""
+    def create_market_signals(self, markets: Dict[str, Any]) -> Dict[str, MarketSignalDTO]:
+        """
+        Iterates through markets and generates a comprehensive dictionary of MarketSignalDTOs.
+
+        Args:
+            markets: The dictionary of all market objects from the SimulationState.
+
+        Returns:
+            A dictionary mapping item_id to its corresponding MarketSignalDTO.
+        """
+        ...
+
+
+class IDecisionInputFactory(Protocol):
+    """Defines the contract for assembling the main DecisionInputDTO for agents."""
+    def create_decision_input(
+        self,
+        state: SimulationState,
+        world_state: WorldState,
+        market_snapshot: MarketSnapshotDTO
+    ) -> DecisionInputDTO:
+        """
+        Constructs the primary input DTO used for all agent decisions in the phase.
+        This encapsulates the creation of various financial and governmental contexts.
+
+        Args:
+            state: The current SimulationState DTO.
+            world_state: The simulation's WorldState object, required for accessing systems
+                         and state not present in the SimulationState DTO (e.g., trackers).
+            market_snapshot: The snapshot of market signals for the current tick.
+
+        Returns:
+            A fully populated DecisionInputDTO.
+        """
+        ...
diff --git a/simulation/orchestration/factories.py b/simulation/orchestration/factories.py
new file mode 100644
index 0000000..b34a5d2
--- /dev/null
+++ b/simulation/orchestration/factories.py
@@ -0,0 +1,120 @@
+from __future__ import annotations
+from typing import Dict, Any, TYPE_CHECKING
+import math
+import logging
+
+from simulation.markets.order_book_market import OrderBookMarket
+from modules.system.api import MarketSignalDTO, MarketSnapshotDTO
+from simulation.dtos.api import (
+    SimulationState, DecisionInputDTO, GovernmentPolicyDTO, MacroFinancialContext,
+    FiscalContext
+)
+from modules.government.proxy import GovernmentFiscalProxy
+
+if TYPE_CHECKING:
+    from simulation.world_state import WorldState
+
+logger = logging.getLogger(__name__)
+
+class MarketSignalFactory:
+    def create_market_signals(self, markets: Dict[str, Any]) -> Dict[str, MarketSignalDTO]:
+        market_signals: Dict[str, MarketSignalDTO] = {}
+
+        for m_id, market in markets.items():
+            # Only process OrderBookMarkets that have items
+            if isinstance(market, OrderBookMarket):
+                # Identify all unique items in this market (buy or sell side)
+                all_items = set(market.buy_orders.keys()) | set(market.sell_orders.keys()) | set(market.last_traded_prices.keys())
+
+                for item_id in all_items:
+                     price_history = list(market.price_history.get(item_id, []))
+                     # Take last 7 ticks or less
+                     history_7d = price_history[-7:]
+
+                     # Volatility Calculation
+                     volatility = 0.0
+                     if len(history_7d) > 1:
+                         mean = sum(history_7d) / len(history_7d)
+                         variance = sum((p - mean) ** 2 for p in history_7d) / len(history_7d)
+                         volatility = math.sqrt(variance)
+
+                     # Check frozen status
+                     # min_p, max_p = market.get_dynamic_price_bounds(item_id)
+                     # Treat as frozen if price is inf or circuit breaker active (heuristic)
+                     # Since we don't have explicit state, we assume False unless proven otherwise.
+                     is_frozen = False
+
+                     signal = MarketSignalDTO(
+                         market_id=m_id,
+                         item_id=item_id,
+                         best_bid=market.get_best_bid(item_id),
+                         best_ask=market.get_best_ask(item_id),
+                         last_traded_price=market.get_last_traded_price(item_id),
+                         last_trade_tick=market.get_last_trade_tick(item_id) or -1,
+                         price_history_7d=history_7d,
+                         volatility_7d=volatility,
+                         order_book_depth_buy=len(market.buy_orders.get(item_id, [])),
+                         order_book_depth_sell=len(market.sell_orders.get(item_id, [])),
+                         is_frozen=is_frozen
+                     )
+                     market_signals[item_id] = signal
+        return market_signals
+
+class DecisionInputFactory:
+    def create_decision_input(
+        self,
+        state: SimulationState,
+        world_state: WorldState,
+        market_snapshot: MarketSnapshotDTO
+    ) -> DecisionInputDTO:
+
+        gov = state.government
+        bank = state.bank
+        gov_policy = GovernmentPolicyDTO(
+             income_tax_rate=getattr(gov, "income_tax_rate", 0.1),
+             sales_tax_rate=getattr(state.config_module, "SALES_TAX_RATE", 0.05),
+             corporate_tax_rate=getattr(gov, "corporate_tax_rate", 0.2),
+             base_interest_rate=getattr(bank, "base_rate", 0.05) if bank else 0.05
+        )
+
+        # Create Fiscal Context
+        gov_proxy = GovernmentFiscalProxy(gov) if gov else None
+        fiscal_context = FiscalContext(government=gov_proxy) if gov_proxy else None
+
+        macro_financial_context = None
+        if getattr(state.config_module, "MACRO_PORTFOLIO_ADJUSTMENT_ENABLED", False):
+            interest_rate_trend = 0.0
+            if bank:
+                interest_rate_trend = bank.base_rate - world_state.last_interest_rate
+                world_state.last_interest_rate = bank.base_rate
+
+            market_volatility = world_state.stock_tracker.get_market_volatility() if world_state.stock_tracker else 0.0
+
+            macro_financial_context = MacroFinancialContext(
+                inflation_rate=0.0, # Placeholder as per original
+                gdp_growth_rate=0.0, # Placeholder as per original
+                market_volatility=market_volatility,
+                interest_rate_trend=interest_rate_trend
+            )
+
+        # Prepare Agent Registry (WO-138)
+        agent_registry = {}
+        if state.government:
+            agent_registry["GOVERNMENT"] = state.government.id
+        if state.central_bank:
+            agent_registry["CENTRAL_BANK"] = state.central_bank.id
+        if state.bank:
+             agent_registry["BANK"] = state.bank.id
+
+        return DecisionInputDTO(
+             markets=state.markets,
+             goods_data=state.goods_data,
+             market_data=state.market_data,
+             current_time=state.time,
+             fiscal_context=fiscal_context,
+             market_snapshot=market_snapshot,
+             government_policy=gov_policy,
+             agent_registry=agent_registry,
+             stress_scenario_config=world_state.stress_scenario_config,
+             macro_context=macro_financial_context
+        )
diff --git a/simulation/orchestration/phases.py b/simulation/orchestration/phases.py
index 42e1ef7..e9f0cc8 100644
--- a/simulation/orchestration/phases.py
+++ b/simulation/orchestration/phases.py
@@ -24,6 +24,9 @@ from modules.government.components.monetary_policy_manager import MonetaryPolicy
 from simulation.orchestration.utils import prepare_market_data
 from modules.government.proxy import GovernmentFiscalProxy
 
+# NEW
+from simulation.orchestration.factories import MarketSignalFactory, DecisionInputFactory
+
 
 if TYPE_CHECKING:
     from simulation.world_state import WorldState
@@ -196,269 +199,175 @@ class Phase_Production(IPhaseStrategy):
 class Phase1_Decision(IPhaseStrategy):
     def __init__(self, world_state: WorldState):
         self.world_state = world_state
+        # TD-189: Use factories
+        self.signal_factory = MarketSignalFactory()
+        self.input_factory = DecisionInputFactory()
 
     def execute(self, state: SimulationState) -> SimulationState:
         # Snapshot agents for learning (Pre-state)
-        for f in state.firms:
-            if f.is_active: f.pre_state_snapshot = f.get_agent_data()
-        for h in state.households:
-            if h.is_active: h.pre_state_snapshot = h.get_agent_data()
+        self._snapshot_agent_pre_states(state)
 
         # Prepare Market Data
         market_data = prepare_market_data(state)
         state.market_data = market_data
 
-        firm_pre_states = {}
-        household_pre_states = {}
-        household_time_allocation = {}
-
-        # Construct Market Signals (Phase 2)
-        from modules.system.api import MarketSignalDTO
-        market_signals: Dict[str, MarketSignalDTO] = {}
-
-        import math
-
-        for m_id, market in state.markets.items():
-            # Only process OrderBookMarkets that have items
-            if isinstance(market, OrderBookMarket):
-                # Identify all unique items in this market (buy or sell side)
-                all_items = set(market.buy_orders.keys()) | set(market.sell_orders.keys()) | set(market.last_traded_prices.keys())
-
-                for item_id in all_items:
-                     price_history = list(market.price_history.get(item_id, []))
-                     # Take last 7 ticks or less
-                     history_7d = price_history[-7:]
-
-                     # Volatility Calculation
-                     volatility = 0.0
-                     if len(history_7d) > 1:
-                         mean = sum(history_7d) / len(history_7d)
-                         variance = sum((p - mean) ** 2 for p in history_7d) / len(history_7d)
-                         volatility = math.sqrt(variance)
-
-                     # Check frozen status
-                     min_p, max_p = market.get_dynamic_price_bounds(item_id)
-                     # Treat as frozen if price is inf or circuit breaker active (heuristic)
-                     # Since we don't have explicit state, we assume False unless proven otherwise.
-                     is_frozen = False
-
-                     signal = MarketSignalDTO(
-                         market_id=m_id,
-                         item_id=item_id,
-                         best_bid=market.get_best_bid(item_id),
-                         best_ask=market.get_best_ask(item_id),
-                         last_traded_price=market.get_last_traded_price(item_id),
-                         last_trade_tick=market.get_last_trade_tick(item_id) or -1,
-                         price_history_7d=history_7d,
-                         volatility_7d=volatility,
-                         order_book_depth_buy=len(market.buy_orders.get(item_id, [])),
-                         order_book_depth_sell=len(market.sell_orders.get(item_id, [])),
-                         is_frozen=is_frozen
-                     )
-                     market_signals[item_id] = signal
-
+        # 1. Create Signals using the factory
+        market_signals = self.signal_factory.create_market_signals(state.markets)
         market_snapshot = MarketSnapshotDTO(
             tick=state.time,
             market_signals=market_signals,
             market_data=market_data # Legacy support
         )
 
-        gov = state.government
-        bank = state.bank
-        gov_policy = GovernmentPolicyDTO(
-             income_tax_rate=getattr(gov, "income_tax_rate", 0.1),
-             sales_tax_rate=getattr(state.config_module, "SALES_TAX_RATE", 0.05),
-             corporate_tax_rate=getattr(gov, "corporate_tax_rate", 0.2),
-             base_interest_rate=getattr(bank, "base_rate", 0.05) if bank else 0.05
-        )
+        # 2. Create Base Input DTO using the factory
+        base_input_dto = self.input_factory.create_decision_input(state, self.world_state, market_snapshot)
 
-        # Create Fiscal Context
-        gov_proxy = GovernmentFiscalProxy(gov) if gov else None
-        fiscal_context = FiscalContext(government=gov_proxy) if gov_proxy else None
-
-        macro_financial_context = None
-        if getattr(state.config_module, "MACRO_PORTFOLIO_ADJUSTMENT_ENABLED", False):
-            interest_rate_trend = 0.0
-            if bank:
-                interest_rate_trend = bank.base_rate - self.world_state.last_interest_rate
-                self.world_state.last_interest_rate = bank.base_rate
-
-            market_volatility = self.world_state.stock_tracker.get_market_volatility() if self.world_state.stock_tracker else 0.0
-
-            # Gov sensory data needed for macro context.
-            # Assuming government has it updated.
-            # Or retrieve from sensory system.
-            # We'll use dummy for now or previous tick data.
-            macro_financial_context = MacroFinancialContext(
-                inflation_rate=0.0,
-                gdp_growth_rate=0.0,
-                market_volatility=market_volatility,
-                interest_rate_trend=interest_rate_trend
-            )
+        # 3. Dispatch decisions
+        self._dispatch_firm_decisions(state, base_input_dto)
+        self._dispatch_household_decisions(state, base_input_dto)
 
-        # Prepare Agent Registry (WO-138)
-        agent_registry = {}
-        if state.government:
-            agent_registry["GOVERNMENT"] = state.government.id
-        if state.central_bank:
-            agent_registry["CENTRAL_BANK"] = state.central_bank.id
-        if state.bank:
-             agent_registry["BANK"] = state.bank.id
-
-        # Create Common Input DTO (Base)
-        base_input_dto = DecisionInputDTO(
-             markets=state.markets,
-             goods_data=state.goods_data,
-             market_data=market_data,
-             current_time=state.time,
-             fiscal_context=fiscal_context,
-             market_snapshot=market_snapshot,
-             government_policy=gov_policy,
-             agent_registry=agent_registry
-        )
+        # 4. Commerce Planning
+        self._plan_commerce(state, market_data)
+
+        return state
 
+    def _snapshot_agent_pre_states(self, state: SimulationState):
+        for f in state.firms:
+            if f.is_active: f.pre_state_snapshot = f.get_agent_data()
+        for h in state.households:
+            if h.is_active: h.pre_state_snapshot = h.get_agent_data()
+
+    def _dispatch_firm_decisions(self, state: SimulationState, base_input_dto: DecisionInputDTO):
         from dataclasses import replace
+        firm_pre_states = {}
 
-        # 1. Firms
         for firm in state.firms:
-            if firm.is_active:
-                if hasattr(firm.decision_engine, 'ai_engine') and firm.decision_engine.ai_engine:
-                    pre_strategic_state = (
-                        firm.decision_engine.ai_engine._get_strategic_state(
-                            firm.get_agent_data(), market_data
-                        )
-                    )
-                    pre_tactical_state = firm.decision_engine.ai_engine._get_tactical_state(
-                        firm.decision_engine.ai_engine.chosen_intention,
-                        firm.get_agent_data(),
-                        market_data,
+            if not firm.is_active: continue
+
+            if hasattr(firm.decision_engine, 'ai_engine') and firm.decision_engine.ai_engine:
+                pre_strategic_state = (
+                    firm.decision_engine.ai_engine._get_strategic_state(
+                        firm.get_agent_data(), state.market_data
                     )
-                    firm_pre_states[firm.id] = {
-                        "pre_strategic_state": pre_strategic_state,
-                        "pre_tactical_state": pre_tactical_state,
-                        "chosen_intention": firm.decision_engine.ai_engine.chosen_intention,
-                        "chosen_tactic": firm.decision_engine.ai_engine.last_chosen_tactic,
-                    }
-
-                stress_config = self.world_state.stress_scenario_config
-
-                # DTO Refactor: Expect DecisionOutputDTO
-                firm_input = replace(base_input_dto, stress_scenario_config=stress_config)
-                decision_output = firm.make_decision(firm_input)
-
-                # Check if it's new DTO or legacy tuple
-                if hasattr(decision_output, 'orders'):
-                    firm_orders = decision_output.orders
-                    # metadata ignored or used if needed
-                else:
-                    # Fallback for unmigrated code (Tuple)
-                    firm_orders, action_vector = decision_output
-
-                for order in firm_orders:
-                    target_market = state.markets.get(order.market_id)
-                    if target_market:
-                        # WO-024: Capture immediate transactions (e.g. LoanMarket)
-                        new_txs = target_market.place_order(order, state.time)
-                        if new_txs:
-                            state.transactions.extend(new_txs)
-
-        # 2. Households
+                )
+                pre_tactical_state = firm.decision_engine.ai_engine._get_tactical_state(
+                    firm.decision_engine.ai_engine.chosen_intention,
+                    firm.get_agent_data(),
+                    state.market_data,
+                )
+                firm_pre_states[firm.id] = {
+                    "pre_strategic_state": pre_strategic_state,
+                    "pre_tactical_state": pre_tactical_state,
+                    "chosen_intention": firm.decision_engine.ai_engine.chosen_intention,
+                    "chosen_tactic": firm.decision_engine.ai_engine.last_chosen_tactic,
+                }
+
+            firm_input = replace(base_input_dto, stress_scenario_config=self.world_state.stress_scenario_config)
+            decision_output = firm.make_decision(firm_input)
+
+            if hasattr(decision_output, 'orders'):
+                firm_orders = decision_output.orders
+            else:
+                firm_orders, action_vector = decision_output
+
+            for order in firm_orders:
+                target_market = state.markets.get(order.market_id)
+                if target_market:
+                    new_txs = target_market.place_order(order, state.time)
+                    if new_txs:
+                        state.transactions.extend(new_txs)
+
+        state.firm_pre_states = firm_pre_states
+
+    def _dispatch_household_decisions(self, state: SimulationState, base_input_dto: DecisionInputDTO):
+        from dataclasses import replace
+        household_pre_states = {}
+        household_time_allocation = {}
+
         for household in state.households:
-            if household.is_active:
-                if hasattr(household.decision_engine, 'ai_engine') and household.decision_engine.ai_engine:
-                    pre_strategic_state = (
-                        household.decision_engine.ai_engine._get_strategic_state(
-                            household.get_agent_data(), market_data
-                        )
+            if not household.is_active: continue
+
+            if hasattr(household.decision_engine, 'ai_engine') and household.decision_engine.ai_engine:
+                pre_strategic_state = (
+                    household.decision_engine.ai_engine._get_strategic_state(
+                        household.get_agent_data(), state.market_data
                     )
-                    household_pre_states[household.id] = {
-                        "pre_strategic_state": pre_strategic_state,
-                    }
-
-                stress_config = self.world_state.stress_scenario_config
-                # DTO Refactor: Expect DecisionOutputDTO
-                household_input = replace(
-                    base_input_dto,
-                    stress_scenario_config=stress_config,
-                    macro_context=macro_financial_context
                 )
-                decision_output = household.make_decision(household_input)
+                household_pre_states[household.id] = {
+                    "pre_strategic_state": pre_strategic_state,
+                }
+
+            household_input = replace(
+                base_input_dto,
+                stress_scenario_config=self.world_state.stress_scenario_config,
+                macro_context=base_input_dto.macro_context
+            )
+            decision_output = household.make_decision(household_input)
 
+            if hasattr(decision_output, 'orders'):
+                household_orders = decision_output.orders
+                metadata = decision_output.metadata
+                if hasattr(metadata, 'work_aggressiveness'):
+                     work_aggressiveness = metadata.work_aggressiveness
+                else:
+                     work_aggressiveness = 0.5
+            else:
+                household_orders, action_vector = decision_output
+                if hasattr(action_vector, 'work_aggressiveness'):
+                    work_aggressiveness = action_vector.work_aggressiveness
+                else:
+                    work_aggressiveness = 0.5
 
-                if hasattr(decision_output, 'orders'):
-                    household_orders = decision_output.orders
-                    metadata = decision_output.metadata
+            max_work_hours = state.config_module.MAX_WORK_HOURS
+            shopping_hours = getattr(state.config_module, "SHOPPING_HOURS", 2.0)
+            hours_per_tick = getattr(state.config_module, "HOURS_PER_TICK", 24.0)
 
-                    # Assume metadata contains action_vector if needed, or handle if it is the vector itself
-                    # Since AIDrivenHouseholdDecisionEngine returns vector as second element,
-                    # metadata should be that vector.
+            work_hours = work_aggressiveness * max_work_hours
+            leisure_hours = max(0.0, hours_per_tick - work_hours - shopping_hours)
+            household_time_allocation[household.id] = leisure_hours
 
-                    if hasattr(metadata, 'work_aggressiveness'):
-                        action_vector = metadata
-                        work_aggressiveness = action_vector.work_aggressiveness
-                    else:
-                         work_aggressiveness = 0.5
-                else:
-                    # Legacy Tuple
-                    household_orders, action_vector = decision_output
-                    if hasattr(action_vector, 'work_aggressiveness'):
-                        work_aggressiveness = action_vector.work_aggressiveness
-                    else:
-                        work_aggressiveness = 0.5
-
-                max_work_hours = state.config_module.MAX_WORK_HOURS
-                shopping_hours = getattr(state.config_module, "SHOPPING_HOURS", 2.0)
-                hours_per_tick = getattr(state.config_module, "HOURS_PER_TICK", 24.0)
-
-                work_hours = work_aggressiveness * max_work_hours
-                leisure_hours = max(0.0, hours_per_tick - work_hours - shopping_hours)
-                household_time_allocation[household.id] = leisure_hours
-
-                for order in household_orders:
-                    # WO-053: Force deflationary pressure on basic_food
-                    if hasattr(order, "item_id") and order.item_id == "basic_food" and order.side == "BUY": # Update order_type -> side
-                         # Check for generic scenario parameter via config injection
-                         deflationary_multiplier = getattr(state.config_module, "DEFLATIONARY_PRESSURE_MULTIPLIER", None)
-
-                         if deflationary_multiplier is not None:
-                             current_price = market_data.get("basic_food_current_sell_price", 5.0)
-                             # Update price -> price_limit (OrderDTO) or use alias
-                             # OrderDTO has 'price' property alias
-                             # But Order dataclass (alias) might not if it's just OrderDTO
-                             # OrderDTO has price property.
-                             # But we might need to construct a new order if it's frozen?
-                             # OrderDTO is frozen=True.
-                             # So we must replace.
-                             from dataclasses import replace
-                             new_price = min(order.price, max(0.1, current_price * float(deflationary_multiplier)))
-                             order = replace(order, price_limit=new_price)
-
-                    if order.side == "INVEST" and order.market_id == "admin": # Update order_type -> side
-                        if self.world_state.firm_system:
-                            self.world_state.firm_system.spawn_firm(state, household)
-                        else:
-                            state.logger.warning(f"SKIPPED_INVESTMENT | Agent {household.id} tried startup but firm_system missing.")
-                        continue
-
-                    target_market_id = order.market_id
-                    if order.side in ["DEPOSIT", "WITHDRAW", "LOAN_REQUEST", "REPAYMENT"]: # Update order_type -> side
-                        target_market_id = "loan_market"
-                    elif hasattr(order, "item_id") and order.item_id in ["deposit", "currency"]:
-                        target_market_id = "loan_market"
-
-                    household_target_market = state.markets.get(target_market_id)
-
-                    if household_target_market:
-                        # WO-024: Capture immediate transactions (e.g. LoanMarket)
-                        new_txs = household_target_market.place_order(order, state.time)
-                        if new_txs:
-                            state.transactions.extend(new_txs)
+            for order in household_orders:
+                self._process_household_order(state, household, order, state.market_data)
 
-        state.firm_pre_states = firm_pre_states
         state.household_pre_states = household_pre_states
         state.household_time_allocation = household_time_allocation
 
-        # Commerce Planning
+    def _process_household_order(self, state: SimulationState, household: Household, order: Order, market_data: Dict[str, Any]):
+        # WO-053: Force deflationary pressure on basic_food
+        if hasattr(order, "item_id") and order.item_id == "basic_food" and order.side == "BUY":
+                deflationary_multiplier = getattr(state.config_module, "DEFLATIONARY_PRESSURE_MULTIPLIER", None)
+
+                if deflationary_multiplier is not None:
+                    current_price = market_data.get("basic_food_current_sell_price", 5.0)
+                    from dataclasses import replace
+                    new_price = min(order.price_limit, max(0.1, current_price * float(deflationary_multiplier)))
+                    order = replace(order, price_limit=new_price)
+
+        if order.side == "INVEST" and order.market_id == "admin":
+            if self.world_state.firm_system:
+                self.world_state.firm_system.spawn_firm(state, household)
+            else:
+                state.logger.warning(f"SKIPPED_INVESTMENT | Agent {household.id} tried startup but firm_system missing.")
+            return
+
+        target_market_id = self._get_redirected_market(order)
+        household_target_market = state.markets.get(target_market_id)
+
+        if household_target_market:
+            new_txs = household_target_market.place_order(order, state.time)
+            if new_txs:
+                state.transactions.extend(new_txs)
+
+    def _get_redirected_market(self, order: Order) -> str:
+        target_market_id = order.market_id
+        if order.side in ["DEPOSIT", "WITHDRAW", "LOAN_REQUEST", "REPAYMENT"]:
+            target_market_id = "loan_market"
+        elif hasattr(order, "item_id") and order.item_id in ["deposit", "currency"]:
+            target_market_id = "loan_market"
+        return target_market_id
+
+    def _plan_commerce(self, state: SimulationState, market_data: Dict[str, Any]):
+         # Commerce Planning
         current_vacancies = 0
         labor_market = state.markets.get("labor")
         if labor_market and isinstance(labor_market, OrderBookMarket):
@@ -473,7 +382,7 @@ class Phase1_Decision(IPhaseStrategy):
             "households": state.households,
             "agents": state.agents,
             "breeding_planner": self.world_state.breeding_planner,
-            "household_time_allocation": household_time_allocation,
+            "household_time_allocation": state.household_time_allocation,
             "market_data": consumption_market_data,
             "config": state.config_module,
             "time": state.time,
diff --git a/tests/unit/test_factories.py b/tests/unit/test_factories.py
new file mode 100644
index 0000000..b3fd600
--- /dev/null
+++ b/tests/unit/test_factories.py
@@ -0,0 +1,60 @@
+import pytest
+from unittest.mock import Mock, MagicMock
+from simulation.orchestration.factories import MarketSignalFactory, DecisionInputFactory
+from simulation.markets.order_book_market import OrderBookMarket
+from modules.system.api import MarketSignalDTO, MarketSnapshotDTO
+from simulation.dtos.api import SimulationState, DecisionInputDTO
+
+class TestMarketSignalFactory:
+    def test_create_market_signals(self):
+        factory = MarketSignalFactory()
+
+        # Mock Market
+        mock_market = MagicMock(spec=OrderBookMarket)
+        # MagicMock isinstance check works if spec is class
+
+        mock_market.buy_orders = {"item1": []}
+        mock_market.sell_orders = {"item1": []}
+        mock_market.last_traded_prices = {"item1": 10.0}
+        mock_market.price_history = {"item1": [10.0, 10.0]}
+        mock_market.get_best_bid.return_value = 9.0
+        mock_market.get_best_ask.return_value = 11.0
+        mock_market.get_last_traded_price.return_value = 10.0
+        mock_market.get_last_trade_tick.return_value = 1
+
+        markets = {"market1": mock_market}
+
+        signals = factory.create_market_signals(markets)
+
+        assert "item1" in signals
+        assert isinstance(signals["item1"], MarketSignalDTO)
+        assert signals["item1"].market_id == "market1"
+        assert signals["item1"].best_bid == 9.0
+
+class TestDecisionInputFactory:
+    def test_create_decision_input(self):
+        factory = DecisionInputFactory()
+
+        # Mock State
+        state = MagicMock(spec=SimulationState)
+        state.government = MagicMock()
+        state.bank = MagicMock()
+        state.central_bank = MagicMock()
+        state.config_module = MagicMock()
+        state.markets = {}
+        state.goods_data = {}
+        state.market_data = {}
+        state.time = 10
+
+        # Mock WorldState
+        world_state = MagicMock()
+        world_state.stock_tracker = MagicMock()
+        world_state.stress_scenario_config = MagicMock()
+
+        market_snapshot = MagicMock(spec=MarketSnapshotDTO)
+
+        dto = factory.create_decision_input(state, world_state, market_snapshot)
+
+        assert isinstance(dto, DecisionInputDTO)
+        assert dto.current_time == 10
+        assert dto.market_snapshot == market_snapshot
diff --git a/tests/unit/test_phase1_refactor.py b/tests/unit/test_phase1_refactor.py
new file mode 100644
index 0000000..8a4856f
--- /dev/null
+++ b/tests/unit/test_phase1_refactor.py
@@ -0,0 +1,112 @@
+import pytest
+from unittest.mock import Mock, MagicMock, patch
+from simulation.orchestration.phases import Phase1_Decision
+from simulation.dtos.api import SimulationState, DecisionInputDTO
+
+class TestPhase1DecisionRefactor:
+    def test_execute_flow(self):
+        # Mock Dependencies
+        world_state = MagicMock()
+        state = MagicMock(spec=SimulationState)
+        state.time = 100
+        state.markets = {"market1": MagicMock()}
+        state.firms = []
+        state.households = []
+        state.agents = {}
+        state.government = MagicMock()
+        state.bank = MagicMock()
+        state.config_module = MagicMock()
+        state.config_module.MACRO_PORTFOLIO_ADJUSTMENT_ENABLED = False
+        state.config_module.SALES_TAX_RATE = 0.05
+        state.config_module.MAX_WORK_HOURS = 10.0
+        state.config_module.HOURS_PER_TICK = 24.0
+        state.config_module.SHOPPING_HOURS = 2.0
+
+        world_state.commerce_system = MagicMock()
+        world_state.commerce_system.plan_consumption_and_leisure.return_value = ({}, [])
+
+        # Prepare mocking factories
+        # Phase1_Decision instantiates factories in __init__
+        # We need to mock them *after* instantiation or patch the classes
+
+        with patch('simulation.orchestration.phases.MarketSignalFactory') as MockSignalFactory, \
+             patch('simulation.orchestration.phases.DecisionInputFactory') as MockInputFactory, \
+             patch('simulation.orchestration.phases.prepare_market_data') as mock_prepare_data:
+
+            mock_prepare_data.return_value = {}
+
+            phase = Phase1_Decision(world_state)
+
+            # Setup factory returns
+            mock_signal_factory_instance = MockSignalFactory.return_value
+            mock_signal_factory_instance.create_market_signals.return_value = {"signal": "mock"}
+
+            mock_input_factory_instance = MockInputFactory.return_value
+            # dataclasses.replace requires a real dataclass instance
+            mock_input_factory_instance.create_decision_input.return_value = DecisionInputDTO(
+                markets={},
+                goods_data={},
+                market_data={},
+                current_time=100
+            )
+
+            # Execute
+            phase.execute(state)
+
+            # Verify Factory Calls
+            mock_signal_factory_instance.create_market_signals.assert_called_once_with(state.markets)
+            mock_input_factory_instance.create_decision_input.assert_called_once()
+
+            # Verify market data preparation
+            mock_prepare_data.assert_called_once_with(state)
+
+    def test_dispatch_logic(self):
+        # Test that _dispatch_firm_decisions and _dispatch_household_decisions are called
+        # (Implicitly tested via execute, but we can check if agents make decisions)
+
+        world_state = MagicMock()
+        world_state.commerce_system = MagicMock()
+        world_state.commerce_system.plan_consumption_and_leisure.return_value = ({}, [])
+
+        state = MagicMock(spec=SimulationState)
+        state.time = 100
+        state.markets = {}
+        state.agents = {}
+        state.government = MagicMock()
+        state.config_module = MagicMock()
+        state.config_module.MAX_WORK_HOURS = 10.0
+        state.config_module.HOURS_PER_TICK = 24.0
+        state.config_module.SHOPPING_HOURS = 2.0
+
+        firm = MagicMock()
+        firm.is_active = True
+        firm.make_decision.return_value = ([], None) # Legacy return
+        firm.get_agent_data.return_value = {}
+
+        household = MagicMock()
+        household.is_active = True
+        household.make_decision.return_value = ([], None) # Legacy return
+        household.get_agent_data.return_value = {}
+
+        state.firms = [firm]
+        state.households = [household]
+
+        with patch('simulation.orchestration.phases.MarketSignalFactory'), \
+             patch('simulation.orchestration.phases.DecisionInputFactory') as MockInputFactory, \
+             patch('simulation.orchestration.phases.prepare_market_data', return_value={}):
+
+            phase = Phase1_Decision(world_state)
+
+            # Setup factory to return real DTO
+            mock_input_factory_instance = MockInputFactory.return_value
+            mock_input_factory_instance.create_decision_input.return_value = DecisionInputDTO(
+                markets={},
+                goods_data={},
+                market_data={},
+                current_time=100
+            )
+
+            phase.execute(state)
+
+            firm.make_decision.assert_called_once()
+            household.make_decision.assert_called_once()
