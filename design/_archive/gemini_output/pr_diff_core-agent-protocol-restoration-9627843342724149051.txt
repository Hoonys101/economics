diff --git a/communications/insights/mission_core_agent_restoration.md b/communications/insights/mission_core_agent_restoration.md
new file mode 100644
index 00000000..c5ca058b
--- /dev/null
+++ b/communications/insights/mission_core_agent_restoration.md
@@ -0,0 +1,25 @@
+# Mission Insights: Core Agent & Protocol Restoration
+
+## Technical Debt & Insights
+
+### 1. Mock fragility in System Tests
+`tests/system/test_engine.py` uses a mix of real objects (`Firm`, `Simulation`) and Mocks (`Household`, `Transaction`). This hybrid approach causes significant friction when protocols change (e.g., `IFinancialAgent` requiring `get_balance`). The mocks often lack the full behavior required by complex systems like `SettlementSystem` (e.g., side effects for `withdraw` working but state not persisting correctly for rollback logic, or method signature mismatches).
+**Recommendation:** Refactor system tests to use lightweight real implementations of `Household` (stubbed engines) instead of pure Mocks where possible, or use a strictly typed `FakeAgent` that fully implements `IAgent` protocols.
+
+### 2. Protocol Adherence
+The shift to `IFinancialAgent` (withdraw/deposit with currency) and `IInventoryHandler` is largely complete in code but tests lag behind. The strict enforcement of `currency` in `withdraw` exposed that many mocks were naive.
+**Recommendation:** Add a linting step or a test utility that verifies Mocks against Protocols (`verify_object=True` or custom checker) to catch signature drifts early.
+
+### 3. State Access Patterns
+Direct access to attributes like `agent.inventory` (dict) or `agent.finance.balance` persists in tests despite the codebase moving to `agent.get_quantity()` and `agent.wallet.get_balance()`.
+**Action Taken:** Fixed several occurrences in `test_engine.py`, but a global audit of test assertions is recommended.
+
+### 4. Settlement System Complexity
+The `settle_atomic` failure in `test_process_transactions_labor_trade` (rollback despite valid conditions) suggests a subtle issue with Mock state interactions or `TaxationSystem` configuration in the test environment. The lack of visibility (swallowed logs in tests) made debugging difficult.
+**Recommendation:** Ensure `mock_logger` in tests is configured to print to stderr on failure, or use `caplog` fixture more effectively.
+
+## Protocol Deviations Fixed
+- `Household.__init__`: Updated to use `AgentCoreConfigDTO` and `engine`.
+- `Firm.__init__`: Updated to use `AgentCoreConfigDTO` and `engine`.
+- `MockAgent`: Updated `withdraw`/`deposit` to accept `currency`.
+- `test_api_extensions.py`: Updated to use `_econ_state.assets` structure.
diff --git a/tests/integration/test_atomic_settlement.py b/tests/integration/test_atomic_settlement.py
index 3fcedb35..55adf308 100644
--- a/tests/integration/test_atomic_settlement.py
+++ b/tests/integration/test_atomic_settlement.py
@@ -7,11 +7,11 @@ class MockAgent:
         self.id = id
         self.assets = assets
 
-    def deposit(self, amount):
+    def deposit(self, amount, currency="USD"):
         if amount < 0: raise ValueError("Negative deposit")
         self.assets += amount
 
-    def withdraw(self, amount):
+    def withdraw(self, amount, currency="USD"):
         if amount < 0: raise ValueError("Negative withdraw")
         # SettlementSystem checks assets property manually before calling withdraw,
         # but pure withdraw should also work.
diff --git a/tests/system/test_engine.py b/tests/system/test_engine.py
index 6592fea6..4002c798 100644
--- a/tests/system/test_engine.py
+++ b/tests/system/test_engine.py
@@ -15,6 +15,8 @@ from simulation.decisions.ai_driven_firm_engine import AIDrivenFirmDecisionEngin
 import config
 from simulation.dtos.api import SimulationState
 from tests.utils.factories import create_household_config_dto, create_firm_config_dto
+from modules.simulation.api import AgentCoreConfigDTO
+from modules.system.api import DEFAULT_CURRENCY
 
 # Mock Logger to prevent actual file writes during tests
 @pytest.fixture(autouse=True)
@@ -151,7 +153,7 @@ def mock_households(mock_config_module):
     hh1._bio_state = Mock()
     hh1._bio_state.is_active = True
     hh1._econ_state = Mock()
-    hh1._econ_state.assets = 100.0
+    hh1._econ_state.assets = {DEFAULT_CURRENCY: 100.0}
     hh1._social_state = Mock()
 
     hh1._assets = 100.0
@@ -175,20 +177,34 @@ def mock_households(mock_config_module):
     hh1.talent.base_learning_rate = 0.1
     hh1.inventory_quality = {}
 
-    def withdraw_side_effect_hh1(amount):
+    def withdraw_side_effect_hh1(amount, currency=DEFAULT_CURRENCY):
         hh1.assets -= amount
     hh1.withdraw = Mock(side_effect=withdraw_side_effect_hh1)
 
-    def deposit_side_effect_hh1(amount):
+    def deposit_side_effect_hh1(amount, currency=DEFAULT_CURRENCY):
         hh1.assets += amount
     hh1.deposit = Mock(side_effect=deposit_side_effect_hh1)
 
+    hh1.get_balance = Mock(side_effect=lambda currency=DEFAULT_CURRENCY: hh1.assets)
+
     def record_consumption_side_effect_hh1(quantity, is_food=False):
         hh1.current_consumption += quantity
         if is_food:
             hh1.current_food_consumption += quantity
     hh1.record_consumption = Mock(side_effect=record_consumption_side_effect_hh1)
 
+    def add_item_side_effect_hh1(item_id, quantity, transaction_id=None, quality=1.0):
+        hh1.inventory[item_id] = hh1.inventory.get(item_id, 0.0) + quantity
+        return True
+    hh1.add_item = Mock(side_effect=add_item_side_effect_hh1)
+
+    def remove_item_side_effect_hh1(item_id, quantity, transaction_id=None):
+        if hh1.inventory.get(item_id, 0.0) >= quantity:
+            hh1.inventory[item_id] -= quantity
+            return True
+        return False
+    hh1.remove_item = Mock(side_effect=remove_item_side_effect_hh1)
+
     hh2 = Mock(spec=Household)
     hh2.id = 2
 
@@ -196,7 +212,7 @@ def mock_households(mock_config_module):
     hh2._bio_state = Mock()
     hh2._bio_state.is_active = True
     hh2._econ_state = Mock()
-    hh2._econ_state.assets = 150.0
+    hh2._econ_state.assets = {DEFAULT_CURRENCY: 150.0}
     hh2._social_state = Mock()
 
     hh2._assets = 150.0
@@ -218,62 +234,78 @@ def mock_households(mock_config_module):
     hh2.talent.base_learning_rate = 0.1
     hh2.inventory_quality = {}
 
-    def withdraw_side_effect_hh2(amount):
+    def withdraw_side_effect_hh2(amount, currency=DEFAULT_CURRENCY):
         hh2.assets -= amount
     hh2.withdraw = Mock(side_effect=withdraw_side_effect_hh2)
 
-    def deposit_side_effect_hh2(amount):
+    def deposit_side_effect_hh2(amount, currency=DEFAULT_CURRENCY):
         hh2.assets += amount
     hh2.deposit = Mock(side_effect=deposit_side_effect_hh2)
 
+    hh2.get_balance = Mock(side_effect=lambda currency=DEFAULT_CURRENCY: hh2.assets)
+
     def record_consumption_side_effect_hh2(quantity, is_food=False):
         hh2.current_consumption += quantity
         if is_food:
             hh2.current_food_consumption += quantity
     hh2.record_consumption = Mock(side_effect=record_consumption_side_effect_hh2)
 
+    def add_item_side_effect_hh2(item_id, quantity, transaction_id=None, quality=1.0):
+        hh2.inventory[item_id] = hh2.inventory.get(item_id, 0.0) + quantity
+        return True
+    hh2.add_item = Mock(side_effect=add_item_side_effect_hh2)
+
+    def remove_item_side_effect_hh2(item_id, quantity, transaction_id=None):
+        if hh2.inventory.get(item_id, 0.0) >= quantity:
+            hh2.inventory[item_id] -= quantity
+            return True
+        return False
+    hh2.remove_item = Mock(side_effect=remove_item_side_effect_hh2)
+
     return [hh1, hh2]
 
 
 @pytest.fixture
-def mock_firms(mock_config_module):
-    f1 = Firm(
+def mock_firms(mock_config_module, mock_logger):
+    f1_config = AgentCoreConfigDTO(
         id=101,
-        initial_capital=1000,
-        initial_liquidity_need=100,
+        name="Firm_101",
+        value_orientation="test",
+        initial_needs={"liquidity_need": 100.0},
+        logger=mock_logger,
+        memory_interface=None
+    )
+    f1 = Firm(
+        core_config=f1_config,
+        engine=Mock(),
         specialization="basic_food",
         productivity_factor=1.0,
-        decision_engine=Mock(),
-        value_orientation="test",
         config_dto=create_firm_config_dto(),
         initial_inventory={"basic_food": 50},
     )
+    f1.deposit(1000.0, DEFAULT_CURRENCY)
     f1.is_active = True
     f1.total_shares = 1000.0
     f1.treasury_shares = 0.0
     f1.age = 25 # Set age for testing
 
-    # Firm uses FinanceDepartment which handles assets.
-    # But SettlementSystem calls firm.withdraw() if firm is passed.
-    # Firm.withdraw delegates to finance.debit.
-    # BaseAgent.withdraw/deposit are implemented.
-    # Firm is instantiated as REAL object here (not Mock), so it should work?
-    # Yes, f1 is Firm(...).
-    # But check if f1.finance is initialized correctly?
-    # Firm.__init__ initializes FinanceDepartment.
-    # So f1.withdraw should work.
-
-    f2 = Firm(
+    f2_config = AgentCoreConfigDTO(
         id=102,
-        initial_capital=1200,
-        initial_liquidity_need=100,
+        name="Firm_102",
+        value_orientation="test",
+        initial_needs={"liquidity_need": 100.0},
+        logger=mock_logger,
+        memory_interface=None
+    )
+    f2 = Firm(
+        core_config=f2_config,
+        engine=Mock(),
         specialization="luxury_food",
         productivity_factor=1.0,
-        decision_engine=Mock(),
-        value_orientation="test",
         config_dto=create_firm_config_dto(),
         initial_inventory={"luxury_food": 60},
     )
+    f2.deposit(1200.0, DEFAULT_CURRENCY)
     f2.is_active = False  # Inactive firm
     f2.total_shares = 1000.0
     f2.treasury_shares = 0.0
@@ -425,7 +457,7 @@ class TestSimulation:
         assert "goods_market" in market_data
         assert "loan_market" in market_data
         assert "all_households" in market_data
-        assert market_data["avg_goods_price"] == pytest.approx(13.333333333333334)
+        assert abs(market_data["avg_goods_price"] - 13.333333333333334) < 1e-9
 
     def test_prepare_market_data_no_goods_market(
         self, simulation_instance, mock_goods_data, mock_tracker
@@ -460,7 +492,7 @@ class TestSimulation:
         assert market_data["goods_market"]["food_current_sell_price"] == 10.0
         assert market_data["goods_market"]["luxury_food_current_sell_price"] == 30.0
         assert market_data["goods_market"]["basic_food_current_sell_price"] == 12.0
-        assert market_data["avg_goods_price"] == pytest.approx((10.0 + 30.0 + 12.0) / 3)
+        assert abs(market_data["avg_goods_price"] - (10.0 + 30.0 + 12.0) / 3) < 1e-9
 
 
     def test_process_transactions_goods_trade(
@@ -469,8 +501,8 @@ class TestSimulation:
         buyer_hh = mock_households[0]
         seller_firm = mock_firms[0]
         initial_buyer_assets = buyer_hh.assets
-        initial_seller_assets = seller_firm.finance.balance
-        initial_seller_inventory = seller_firm.inventory.get("basic_food", 0)
+        initial_seller_assets = seller_firm.wallet.get_balance(DEFAULT_CURRENCY)
+        initial_seller_inventory = seller_firm.get_quantity("basic_food")
         initial_buyer_inventory = buyer_hh.inventory.get("basic_food", 0)
 
         tx = Mock(spec=Transaction)
@@ -481,6 +513,7 @@ class TestSimulation:
         tx.price = 10.0
         tx.quality = 1.0 # Ensure quality is a float
         tx.transaction_type = "goods"
+        tx.metadata = {}
 
         simulation_instance._process_transactions([tx])
 
@@ -488,9 +521,9 @@ class TestSimulation:
         trade_value = tx.quantity * tx.price
         tax = trade_value * simulation_instance.config_module.SALES_TAX_RATE
         assert buyer_hh.assets == initial_buyer_assets - (trade_value + tax)
-        assert seller_firm.finance.balance == initial_seller_assets + trade_value
+        assert seller_firm.wallet.get_balance(DEFAULT_CURRENCY) == initial_seller_assets + trade_value
         assert (
-            seller_firm.inventory["basic_food"]
+            seller_firm.get_quantity("basic_food")
             == initial_seller_inventory - tx.quantity
         )
         assert buyer_hh.inventory["basic_food"] == initial_buyer_inventory + tx.quantity
@@ -498,18 +531,18 @@ class TestSimulation:
         # This assertion might need adjustment depending on how consumption of different food types is tracked
         # For now, assuming any food purchase contributes to current_food_consumption
         assert buyer_hh.current_food_consumption == tx.quantity
-        assert seller_firm.finance.revenue_this_turn == (tx.quantity * tx.price)
+        assert seller_firm.revenue_this_turn.get(DEFAULT_CURRENCY, 0.0) == (tx.quantity * tx.price)
 
     def test_process_transactions_labor_trade(
         self, simulation_instance, mock_households, mock_firms
     ):
         buyer_firm = mock_firms[0]
         seller_hh = mock_households[0]
-        initial_buyer_assets = buyer_firm.finance.balance
+        initial_buyer_assets = buyer_firm.wallet.get_balance(DEFAULT_CURRENCY)
         initial_seller_assets = seller_hh.assets
 
         seller_hh.is_employed = False
-        buyer_firm.hr.employees = []
+        buyer_firm.hr_state.employees = []
 
         tx = Mock(spec=Transaction)
         tx.buyer_id = buyer_firm.id
@@ -518,6 +551,7 @@ class TestSimulation:
         tx.quantity = 1.0
         tx.price = 20.0
         tx.transaction_type = "labor"
+        tx.metadata = {}
 
         simulation_instance._process_transactions([tx])
 
@@ -539,15 +573,15 @@ class TestSimulation:
         # tax = 1.25
         tax = 2.0
 
-        assert buyer_firm.finance.balance == initial_buyer_assets - trade_value
-        assert seller_hh.assets == pytest.approx(initial_seller_assets + (trade_value - tax))
+        assert buyer_firm.wallet.get_balance(DEFAULT_CURRENCY) == initial_buyer_assets - trade_value
+        assert abs(seller_hh.assets - (initial_seller_assets + (trade_value - tax))) < 1e-9
         assert seller_hh.is_employed is True
         assert seller_hh.employer_id == buyer_firm.id
         assert seller_hh.needs["labor_need"] == 0.0
-        assert seller_hh in buyer_firm.hr.employees
+        assert seller_hh in buyer_firm.hr_state.employees
 
         # Checking cost >= trade_value to account for potential marketing/other costs
-        assert buyer_firm.finance.expenses_this_tick >= (tx.quantity * tx.price)
+        assert buyer_firm.expenses_this_tick.get(DEFAULT_CURRENCY, 0.0) >= (tx.quantity * tx.price)
 
     def test_process_transactions_research_labor_trade(
         self, simulation_instance, mock_households, mock_firms
@@ -565,11 +599,12 @@ class TestSimulation:
         tx.quantity = 1.0
         tx.price = 30.0
         tx.transaction_type = "research_labor"
+        tx.metadata = {}
 
         simulation_instance._process_transactions([tx])
 
         assert seller_hh.is_employed is True
-        assert seller_hh in buyer_firm.hr.employees
+        assert seller_hh in buyer_firm.hr_state.employees
         assert buyer_firm.productivity_factor == initial_productivity_factor + (
             seller_hh.skills["research"].value
             * simulation_instance.config_module.RND_PRODUCTIVITY_MULTIPLIER
@@ -655,78 +690,105 @@ def setup_simulation_for_lifecycle(
     talent_employed = Mock(spec=Talent)
     talent_employed.base_learning_rate = 0.1
 
+    # Core Configs for Households
+    hh_active_config = AgentCoreConfigDTO(
+        id=1, name="Household_1", value_orientation="test", initial_needs=initial_needs.copy(), logger=mock_logger, memory_interface=None
+    )
+    hh_inactive_config = AgentCoreConfigDTO(
+        id=2, name="Household_2", value_orientation="test", initial_needs=initial_needs.copy(), logger=mock_logger, memory_interface=None
+    )
+    hh_employed_config = AgentCoreConfigDTO(
+        id=3, name="Household_3", value_orientation="test", initial_needs=initial_needs.copy(), logger=mock_logger, memory_interface=None
+    )
+
     household_active = Household(
-        id=1,
+        core_config=hh_active_config,
+        engine=mock_household_decision_engine_for_lifecycle,
         talent=talent_active,
         goods_data=mock_goods_data_for_lifecycle,
-        initial_assets=100,
-        initial_needs=initial_needs.copy(),
-        decision_engine=mock_household_decision_engine_for_lifecycle,
-        value_orientation="test",
         personality=Personality.MISER,
         config_dto=create_household_config_dto(),
+        initial_assets_record=100,
     )
+    # Ensure assets are actually deposited if initial_assets_record doesn't do it automatically (it does in Household.__init__)
+    # But Household.__init__ uses initial_assets_record to set _econ_state, but might not deposit to wallet?
+    # Let's check Household.__init__ code.
+    # It says: "effective_initial_assets = initial_assets_record ... is_wealthy = ..."
+    # And: "initial_assets_record if initial_assets_record is not None else 0.0" is passed to EconStateDTO.
+    # EconStateDTO has initial_assets_record field.
+    # Does it populate wallet?
+    # "temp_wallet = Wallet(core_config.id, {})"
+    # It does NOT seem to populate wallet from initial_assets_record automatically in the code I read.
+    # Wait, "self._wallet = self._econ_state.wallet".
+    # And "self.memory_v2.add_record... data={'initial_assets': ...}".
+    # I don't see wallet.add() in Household.__init__ for initial assets.
+    # The clone method does: "if initial_assets_from_parent > 0: new_household.deposit(...)"
+    # So I should probably deposit manually to be safe.
+    household_active.deposit(100.0, DEFAULT_CURRENCY)
+
     household_active.is_active = True
     household_active.is_employed = True
     household_active.employer_id = 101
 
     household_inactive = Household(
-        id=2,
+        core_config=hh_inactive_config,
+        engine=mock_household_decision_engine_for_lifecycle,
         talent=talent_inactive,
         goods_data=mock_goods_data_for_lifecycle,
-        initial_assets=50,
-        initial_needs=initial_needs.copy(),
-        decision_engine=mock_household_decision_engine_for_lifecycle,
-        value_orientation="test",
         personality=Personality.MISER,
         config_dto=create_household_config_dto(),
+        initial_assets_record=50,
     )
+    household_inactive.deposit(50.0, DEFAULT_CURRENCY)
     household_inactive.is_active = False
 
     household_employed_by_inactive_firm = Household(
-        id=3,
+        core_config=hh_employed_config,
+        engine=mock_household_decision_engine_for_lifecycle,
         talent=talent_employed,
         goods_data=mock_goods_data_for_lifecycle,
-        initial_assets=70,
-        initial_needs=initial_needs.copy(),
-        decision_engine=mock_household_decision_engine_for_lifecycle,
-        value_orientation="test",
         personality=Personality.MISER,
         config_dto=create_household_config_dto(),
+        initial_assets_record=70,
     )
+    household_employed_by_inactive_firm.deposit(70.0, DEFAULT_CURRENCY)
     household_employed_by_inactive_firm.is_active = True
     household_employed_by_inactive_firm.is_employed = True
     household_employed_by_inactive_firm.employer_id = 102
 
+    # Core Configs for Firms
+    f_active_config = AgentCoreConfigDTO(
+        id=101, name="Firm_101", value_orientation="test", initial_needs={"liquidity_need": 100.0}, logger=mock_logger, memory_interface=None
+    )
+    f_inactive_config = AgentCoreConfigDTO(
+        id=102, name="Firm_102", value_orientation="test", initial_needs={"liquidity_need": 50.0}, logger=mock_logger, memory_interface=None
+    )
+
     firm_active = Firm(
-        id=101,
-        initial_capital=1000,
-        initial_liquidity_need=100,
+        core_config=f_active_config,
+        engine=mock_firm_decision_engine_for_lifecycle,
         specialization="food",
         productivity_factor=1.0,
-        decision_engine=mock_firm_decision_engine_for_lifecycle,
-        value_orientation="test",
         config_dto=create_firm_config_dto(),
     )
+    firm_active.deposit(1000.0, DEFAULT_CURRENCY)
     firm_active.is_active = True
     firm_active.total_shares = 1000.0
     firm_active.treasury_shares = 0.0
-    firm_active.hr.employees.append(household_active)
+    firm_active.hr_state.employees.append(household_active)
 
     firm_inactive = Firm(
-        id=102,
-        initial_capital=500,
-        initial_liquidity_need=50,
+        core_config=f_inactive_config,
+        engine=mock_firm_decision_engine_for_lifecycle,
         specialization="food",
         productivity_factor=1.0,
-        decision_engine=mock_firm_decision_engine_for_lifecycle,
-        value_orientation="test",
         config_dto=create_firm_config_dto(),
     )
+    firm_inactive.deposit(500.0, DEFAULT_CURRENCY)
     firm_inactive.is_active = False
     firm_inactive.total_shares = 1000.0
     firm_inactive.treasury_shares = 0.0
-    firm_inactive.hr.employees.append(household_employed_by_inactive_firm)
+    firm_inactive.hr_state.employees.append(household_employed_by_inactive_firm)
 
     households = [
         household_active,
@@ -761,6 +823,12 @@ def setup_simulation_for_lifecycle(
     )
     sim = initializer.build_simulation()
 
+    # Inject mock transaction processor as it is required for lifecycle/inheritance
+    sim.transaction_processor = Mock()
+    result = Mock()
+    result.success = True
+    sim.transaction_processor.execute.return_value = [result]
+
     assert sim.agents[household_active.id] == household_active
     assert sim.agents[household_inactive.id] == household_inactive
     assert sim.agents[firm_active.id] == firm_active
@@ -794,8 +862,8 @@ def test_handle_agent_lifecycle_removes_inactive_agents(setup_simulation_for_lif
     assert firm_inactive in sim.firms
     assert household_employed_by_inactive_firm.is_employed
     assert household_employed_by_inactive_firm.employer_id == firm_inactive.id
-    assert household_active in firm_active.hr.employees
-    assert household_employed_by_inactive_firm in firm_inactive.hr.employees
+    assert household_active in firm_active.hr_state.employees
+    assert household_employed_by_inactive_firm in firm_inactive.hr_state.employees
 
     state = SimulationState(
         time=sim.time,
@@ -817,7 +885,8 @@ def test_handle_agent_lifecycle_removes_inactive_agents(setup_simulation_for_lif
         ai_training_manager=getattr(sim, 'ai_training_manager', None),
         ai_trainer=getattr(sim, 'ai_trainer', None),
         next_agent_id=getattr(sim, 'next_agent_id', 0),
-        real_estate_units=getattr(sim, 'real_estate_units', [])
+        real_estate_units=getattr(sim, 'real_estate_units', []),
+        transaction_processor=sim.transaction_processor, # Inject processor
     )
 
     # Force inactive state as SimulationInitializer.build_simulation -> update_needs resets it
@@ -842,7 +911,7 @@ def test_handle_agent_lifecycle_removes_inactive_agents(setup_simulation_for_lif
     assert not household_employed_by_inactive_firm.is_employed
     assert household_employed_by_inactive_firm.employer_id is None
 
-    assert len(firm_active.hr.employees) == 1
-    assert household_active in firm_active.hr.employees
+    assert len(firm_active.hr_state.employees) == 1
+    assert household_active in firm_active.hr_state.employees
 
-    assert len(firm_inactive.hr.employees) == 0
+    assert len(firm_inactive.hr_state.employees) == 0
diff --git a/tests/unit/test_api_extensions.py b/tests/unit/test_api_extensions.py
index d0620e71..ee70c584 100644
--- a/tests/unit/test_api_extensions.py
+++ b/tests/unit/test_api_extensions.py
@@ -22,12 +22,15 @@ class TestEconomicIndicatorsViewModel:
                  else [MagicMock() for _ in range(2)])
 
         # Override assets
-        households[0]._assets = 10
-        households[1]._assets = 20
-        households[2]._assets = 100
+        # Households access ._econ_state.assets
+        for h, val in zip(households, [10, 20, 100]):
+            if not hasattr(h, '_econ_state'):
+                h._econ_state = MagicMock()
+            h._econ_state.assets = val
 
-        firms[0]._assets = 50
-        firms[1]._assets = 10
+        # Firms access .assets
+        firms[0].assets = 50
+        firms[1].assets = 10
 
         # Total assets: 10, 20, 100, 50, 10
         # Min: 10, Max: 100
@@ -69,7 +72,8 @@ class TestEconomicIndicatorsViewModel:
         assert sales["banana"] == 5
 
     def test_get_market_order_book(self, vm):
-        market = OrderBookMarket("test_market")
+        market = MagicMock(spec=OrderBookMarket)
+        market.id = "test_market"
         # Manually inject orders for testing
         market.buy_orders = {
             "apple": [Order(agent_id=1, side="BUY", market_id="test_market", item_id="apple", quantity=10, price_limit=5)]
