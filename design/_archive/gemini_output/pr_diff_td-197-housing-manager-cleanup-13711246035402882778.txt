diff --git a/communications/insights/TD-197_HousingManager_Cleanup.md b/communications/insights/TD-197_HousingManager_Cleanup.md
new file mode 100644
index 0000000..d7b65a5
--- /dev/null
+++ b/communications/insights/TD-197_HousingManager_Cleanup.md
@@ -0,0 +1,24 @@
+# Insight Report: TD-197 HousingManager Cleanup
+
+## Summary
+The legacy `HousingManager` class (`simulation/decisions/household/housing_manager.py` and `simulation/decisions/housing_manager.py`) has been removed. This class was responsible for generating `Order` objects for housing purchases based on System 1 logic (including "Personality Bias" and "Mimicry").
+
+The system has transitioned to a Saga-based approach (`HousingSystem.initiate_purchase` via `DecisionUnit` and `HousingPlanner`), rendering the `Order`-based approach obsolete and ineffective (as there is no active OrderBookMarket for housing).
+
+## Changes
+1.  **Removed `HousingManager`**: Both the legacy and the "active" versions were deleted.
+2.  **Refactored `AIDrivenHouseholdDecisionEngine`**: Removed the call to `HousingManager.decide_housing`. This engine no longer produces housing orders.
+3.  **Refactored `SocialSystem`**: Removed dependency on `HousingManager`. Inlined simple logic for `get_housing_tier` (checking `residing_property_id`).
+4.  **Refactored Tests**:
+    *   `tests/integration/scenarios/verify_real_estate_sales.py`: Deleted as it tested dead code.
+    *   `tests/integration/scenarios/verify_vanity_society.py`: Heavily refactored to remove dependencies on `HousingManager` and fix breakage caused by recent `AIDrivenHouseholdDecisionEngine` and `ConsumptionManager` changes (DTOs, Config Aliases).
+    *   `tests/unit/systems/test_social_system.py`: Updated to match `SocialSystem` refactor.
+
+## Functional Impact / Feature Loss
+*   **Mimicry / Vanity Housing**: The logic that triggered panic buying of housing based on "Social Rank Gap" (Mimicry) is **removed**. `HousingPlanner` does not currently implement this feature. If this feature is critical, it must be re-implemented within `HousingPlanner` or `DecisionUnit`.
+*   **Personality Bias in Housing**: The `should_buy` logic in `HousingManager` included biases for Optimism (appreciation rate) and Ambition (prestige bonus). This logic is **removed**. `HousingPlanner` uses a simpler Value-for-Money score.
+
+## Technical Debt Resolved
+*   **TD-197**: HousingManager Legacy | Architectural confusion.
+*   Reduced code duplication and confusion regarding which component decides housing purchases.
+*   Clarified that `DecisionUnit` -> `HousingPlanner` -> `HousingSystem` (Saga) is the single source of truth for housing transactions.
diff --git a/simulation/decisions/ai_driven_household_engine.py b/simulation/decisions/ai_driven_household_engine.py
index 3c546ae..2a37c18 100644
--- a/simulation/decisions/ai_driven_household_engine.py
+++ b/simulation/decisions/ai_driven_household_engine.py
@@ -8,12 +8,11 @@ from simulation.dtos import DecisionContext, MacroFinancialContext, DecisionOutp
 
 # Modular Managers
 from simulation.decisions.household.api import (
-    ConsumptionContext, LaborContext, AssetManagementContext, HousingContext
+    ConsumptionContext, LaborContext, AssetManagementContext
 )
 from simulation.decisions.household.consumption_manager import ConsumptionManager
 from simulation.decisions.household.labor_manager import LaborManager
 from simulation.decisions.household.asset_manager import AssetManager
-from simulation.decisions.household.housing_manager import HousingManager
 
 if TYPE_CHECKING:
     from simulation.ai.household_ai import HouseholdAI
@@ -40,7 +39,6 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
         self.consumption_manager = ConsumptionManager()
         self.labor_manager = LaborManager()
         self.asset_manager = AssetManager()
-        self.housing_manager = HousingManager(logger=self.logger)
 
         self.logger.info(
             "AIDrivenHouseholdDecisionEngine initialized (Modularized).",
@@ -122,14 +120,6 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
         )
         orders.extend(self.asset_manager.decide_investments(asset_ctx))
         
-        # 5. Housing
-        housing_ctx = HousingContext(
-             household=household, config=config, market_data=market_data,
-             market_snapshot=market_snapshot, current_time=current_time,
-             stress_config=context.stress_scenario_config, logger=self.logger
-        )
-        orders.extend(self.housing_manager.decide_housing(housing_ctx))
-        
         return DecisionOutputDTO(orders=orders, metadata=action_vector)
 
     def decide_reproduction(self, context: DecisionContext) -> bool:
diff --git a/simulation/decisions/household/housing_manager.py b/simulation/decisions/household/housing_manager.py
deleted file mode 100644
index b8dff00..0000000
--- a/simulation/decisions/household/housing_manager.py
+++ /dev/null
@@ -1,199 +0,0 @@
-from __future__ import annotations
-from typing import Any, Dict, Optional, TYPE_CHECKING, Union, List
-import math
-from simulation.models import Order
-from simulation.decisions.household.api import HousingContext
-
-if TYPE_CHECKING:
-    from modules.household.dtos import HouseholdStateDTO
-    from simulation.dtos import HouseholdConfigDTO
-
-class PurchaseIntent:
-    """DTO for Mimicry Purchase decision"""
-    def __init__(self, target="housing", max_ltv=0.8, priority="NORMAL"):
-        self.target = target
-        self.max_ltv = max_ltv
-        self.priority = priority
-
-class HousingManager:
-    """
-    Phase 17-3B: Housing Manager
-    Acts as a 'Proxy Planner' (System 2 Proxy) for the Household.
-    Calculates Buy vs Rent decisions using NPV and Personality Bias.
-    Refactored for DTO Purity Gate.
-    """
-
-    def __init__(self, logger: Optional[Any] = None):
-        self.logger = logger
-
-    def decide_housing(self, context: HousingContext) -> List[Order]:
-        orders = []
-        agent = context.household
-        config = context.config
-        market_data = context.market_data
-
-        if not context.market_snapshot:
-            return orders
-
-        reference_standard = market_data.get("reference_standard", {})
-        mimicry_intent = self.decide_mimicry_purchase(agent, config, reference_standard)
-
-        is_owner_occupier = agent.residing_property_id in agent.owned_properties
-        should_search = (not is_owner_occupier) or (mimicry_intent is not None)
-
-        if should_search:
-             best_offer = None
-             min_price = float('inf')
-
-             # Iterate over snapshot asks to find housing units
-             # Housing units are identified by 'unit_' prefix in item_id
-             # Compatible with both legacy dict and TypedDict
-
-             snapshot = context.market_snapshot
-             legacy_asks = getattr(snapshot, "asks", None) # Check if object has attribute
-             if legacy_asks is None:
-                 # Check TypedDict keys
-                 if isinstance(snapshot, dict):
-                     legacy_asks = snapshot.get("asks", {})
-
-             if legacy_asks:
-                 for item_id, orders_list in legacy_asks.items():
-                     if not item_id.startswith("unit_"):
-                         continue
-                     if not orders_list:
-                         continue
-
-                     cheapest = orders_list[0] # Assuming sorted ascending
-                     if cheapest.price < min_price:
-                         min_price = cheapest.price
-                         best_offer = cheapest
-
-             if best_offer:
-                 # Use market_data instead of live loan_market object (IBankService formalization)
-                 default_rate = getattr(config, 'default_mortgage_rate', 0.05)
-                 mortgage_rate = market_data.get("loan_market", {}).get("interest_rate", default_rate)
-
-                 should_buy = False
-
-                 if mimicry_intent:
-                     should_buy = True
-                 elif not is_owner_occupier:
-                     initial_rent_price = getattr(config, 'initial_rent_price', 100.0)
-                     should_buy = self.should_buy(
-                         agent,
-                         config,
-                         best_offer.price,
-                         initial_rent_price,
-                         mortgage_rate
-                     )
-
-                 if should_buy:
-                     buy_order = Order(
-                         agent_id=agent.id,
-                         side="BUY",
-                         item_id=best_offer.item_id,
-                         quantity=1.0,
-                         price_limit=best_offer.price,
-                         market_id="housing"
-
-                     )
-                     orders.append(buy_order)
-
-                     if mimicry_intent and context.logger:
-                         context.logger.info(
-                             f"MIMICRY_BUY | Household {agent.id} panic buying housing due to relative deprivation.",
-                             extra={"tick": context.current_time, "agent_id": agent.id}
-                         )
-        return orders
-
-    def get_housing_tier(self, agent: "HouseholdStateDTO") -> float:
-        """
-        Estimates housing tier based on residence value.
-        """
-        if agent.is_homeless or agent.residing_property_id is None:
-            return 0.0
-        return 1.0 # Default Tier 1
-
-    def decide_mimicry_purchase(self, agent: "HouseholdStateDTO", config: Union[Any, HouseholdConfigDTO], reference_standard: Dict[str, float]) -> Optional[PurchaseIntent]:
-        """
-        Phase 17-4: Mimicry Consumption Logic.
-        """
-        # Use DTO attribute if available, otherwise legacy getattr
-        enable_vanity = config.enable_vanity_system if hasattr(config, 'enable_vanity_system') else getattr(config, "ENABLE_VANITY_SYSTEM", False)
-
-        if not enable_vanity:
-            return None
-
-        # 1. Calculate Gap
-        my_tier = self.get_housing_tier(agent)
-        ref_tier = reference_standard.get("avg_housing_tier", 1.0)
-
-        gap = ref_tier - my_tier
-        if gap <= 0:
-            return None
-
-        # 2. Calculate Urgency
-        conformity = getattr(agent, "conformity", 0.5)
-
-        mimicry_factor = config.mimicry_factor if hasattr(config, 'mimicry_factor') else getattr(config, "MIMICRY_FACTOR", 0.5)
-
-        urgency = conformity * gap * mimicry_factor
-
-        # 3. Trigger Condition
-        if urgency > 0.5:
-             return PurchaseIntent(
-                 target="housing",
-                 max_ltv=0.95, # Panic Buy: Max Leverage
-                 priority="URGENT"
-             )
-        return None
-
-    def should_buy(self, agent: "HouseholdStateDTO", config: Union[Any, HouseholdConfigDTO], property_value: float, rent_price: float, interest_rate: float = 0.05) -> bool:
-        """
-        Determines whether to buy a property based on NPV calculation biased by personality.
-        """
-        # 1. Base Economic Parameters
-        horizon = 120
-        discount_rate = 0.005
-        # Access safely
-        maintenance_rate = config.maintenance_rate_per_tick if hasattr(config, 'maintenance_rate_per_tick') else getattr(config, 'MAINTENANCE_RATE_PER_TICK', 0.001)
-
-        # 2. Personality-Biased Parameters
-
-        # Optimism Bias
-        base_appreciation = 0.002
-        perceived_appreciation_rate = base_appreciation * (0.5 + getattr(agent, 'optimism', 0.5))
-
-        # Ambition Bias
-        prestige_bonus = 0.0
-        ambition = getattr(agent, 'ambition', 0.5)
-        prestige_bonus = property_value * 0.1 * ambition
-
-        # 3. NPV Calculation
-        rent_npv = 0.0
-        for t in range(horizon):
-            rent_npv += rent_price / ((1 + discount_rate) ** t)
-
-        ltv = 0.8
-        down_payment = property_value * (1 - ltv)
-        loan_principal = property_value * ltv
-
-        monthly_rate = interest_rate / 12
-        if monthly_rate > 0:
-            monthly_payment = loan_principal * (monthly_rate * (1 + monthly_rate) ** 360) / ((1 + monthly_rate) ** 360 - 1)
-        else:
-            monthly_payment = loan_principal / 360
-
-        buy_outflow_npv = down_payment
-        for t in range(horizon):
-            maintenance_cost = property_value * maintenance_rate
-            total_monthly_cost = monthly_payment + maintenance_cost
-            buy_outflow_npv += total_monthly_cost / ((1 + discount_rate) ** t)
-
-        future_value = property_value * ((1 + perceived_appreciation_rate) ** horizon)
-        future_value_npv = future_value / ((1 + discount_rate) ** horizon)
-
-        # Net Cost of Buying (Cost - Asset Value - Prestige)
-        net_buy_cost = buy_outflow_npv - future_value_npv - prestige_bonus
-
-        return net_buy_cost < rent_npv
diff --git a/simulation/decisions/housing_manager.py b/simulation/decisions/housing_manager.py
deleted file mode 100644
index d56dca3..0000000
--- a/simulation/decisions/housing_manager.py
+++ /dev/null
@@ -1,118 +0,0 @@
-from __future__ import annotations
-from typing import Any, Dict, Optional, TYPE_CHECKING, Union
-import math
-from simulation.models import Order
-
-if TYPE_CHECKING:
-    from modules.household.dtos import HouseholdStateDTO
-    from simulation.dtos import HouseholdConfigDTO
-
-class PurchaseIntent:
-    """DTO for Mimicry Purchase decision"""
-    def __init__(self, target="housing", max_ltv=0.8, priority="NORMAL"):
-        self.target = target
-        self.max_ltv = max_ltv
-        self.priority = priority
-
-class HousingManager:
-    """
-    Phase 17-3B: Housing Manager
-    Acts as a 'Proxy Planner' (System 2 Proxy) for the Household.
-    Calculates Buy vs Rent decisions using NPV and Personality Bias.
-    Refactored for DTO Purity Gate.
-    """
-
-    def __init__(self, agent: "HouseholdStateDTO", config: Union[Any, HouseholdConfigDTO]):
-        self.agent = agent  # HouseholdStateDTO
-        self.config = config
-
-    def get_housing_tier(self, agent: "HouseholdStateDTO") -> float:
-        """
-        Estimates housing tier based on residence value.
-        """
-        if agent.is_homeless or agent.residing_property_id is None:
-            return 0.0
-        return 1.0 # Default Tier 1
-
-    def decide_mimicry_purchase(self, reference_standard: Dict[str, float]) -> Optional[PurchaseIntent]:
-        """
-        Phase 17-4: Mimicry Consumption Logic.
-        """
-        # Use DTO attribute if available, otherwise legacy getattr
-        enable_vanity = self.config.enable_vanity_system if hasattr(self.config, 'enable_vanity_system') else getattr(self.config, "ENABLE_VANITY_SYSTEM", False)
-
-        if not enable_vanity:
-            return None
-
-        # 1. Calculate Gap
-        my_tier = self.get_housing_tier(self.agent)
-        ref_tier = reference_standard.get("avg_housing_tier", 1.0)
-
-        gap = ref_tier - my_tier
-        if gap <= 0:
-            return None
-
-        # 2. Calculate Urgency
-        conformity = getattr(self.agent, "conformity", 0.5)
-
-        mimicry_factor = self.config.mimicry_factor if hasattr(self.config, 'mimicry_factor') else getattr(self.config, "MIMICRY_FACTOR", 0.5)
-
-        urgency = conformity * gap * mimicry_factor
-
-        # 3. Trigger Condition
-        if urgency > 0.5:
-             return PurchaseIntent(
-                 target="housing",
-                 max_ltv=0.95, # Panic Buy: Max Leverage
-                 priority="URGENT"
-             )
-        return None
-
-    def should_buy(self, property_value: float, rent_price: float, interest_rate: float = 0.05) -> bool:
-        """
-        Determines whether to buy a property based on NPV calculation biased by personality.
-        """
-        # 1. Base Economic Parameters
-        horizon = 120
-        discount_rate = 0.005
-        maintenance_rate = self.config.maintenance_rate_per_tick if hasattr(self.config, 'maintenance_rate_per_tick') else self.config.MAINTENANCE_RATE_PER_TICK
-        
-        # 2. Personality-Biased Parameters
-        
-        # Optimism Bias
-        base_appreciation = 0.002
-        perceived_appreciation_rate = base_appreciation * (0.5 + getattr(self.agent, 'optimism', 0.5))
-        
-        # Ambition Bias
-        prestige_bonus = 0.0
-        ambition = getattr(self.agent, 'ambition', 0.5)
-        prestige_bonus = property_value * 0.1 * ambition
-
-        # 3. NPV Calculation
-        rent_npv = 0.0
-        for t in range(horizon):
-            rent_npv += rent_price / ((1 + discount_rate) ** t)
-            
-        ltv = 0.8
-        down_payment = property_value * (1 - ltv)
-        loan_principal = property_value * ltv
-        
-        monthly_rate = interest_rate / 12
-        if monthly_rate > 0:
-            monthly_payment = loan_principal * (monthly_rate * (1 + monthly_rate) ** 360) / ((1 + monthly_rate) ** 360 - 1)
-        else:
-            monthly_payment = loan_principal / 360
-            
-        buy_outflow_npv = down_payment
-        for t in range(horizon):
-            maintenance_cost = property_value * maintenance_rate
-            total_monthly_cost = monthly_payment + maintenance_cost
-            buy_outflow_npv += total_monthly_cost / ((1 + discount_rate) ** t)
-            
-        future_value = property_value * ((1 + perceived_appreciation_rate) ** horizon)
-        future_value_npv = future_value / ((1 + discount_rate) ** horizon)
-        
-        # Net Cost of Buying (Cost - Asset Value - Prestige)
-        net_buy_cost = buy_outflow_npv - future_value_npv - prestige_bonus
-        
-        return net_buy_cost < rent_npv
diff --git a/simulation/systems/social_system.py b/simulation/systems/social_system.py
index 9b1384f..532e41c 100644
--- a/simulation/systems/social_system.py
+++ b/simulation/systems/social_system.py
@@ -3,7 +3,6 @@ Implements the SocialSystem which handles social rank updates and reference stan
 """
 from typing import Dict, Any, List
 from simulation.systems.api import ISocialSystem, SocialMobilityContext
-from simulation.decisions.housing_manager import HousingManager
 
 class SocialSystem(ISocialSystem):
     """
@@ -13,42 +12,28 @@ class SocialSystem(ISocialSystem):
     def __init__(self, config: Any):
         self.config = config
 
+    def _get_housing_tier(self, agent: Any) -> float:
+        """Helper to estimate housing tier based on residence."""
+        if hasattr(agent, "residing_property_id") and agent.residing_property_id is not None:
+            return 1.0
+        if hasattr(agent, "_econ_state") and agent._econ_state.residing_property_id is not None:
+            return 1.0
+        return 0.0
+
     def update_social_ranks(self, context: SocialMobilityContext) -> None:
         """
         Calculates and updates the social rank (percentile) for all active households.
         The score is a weighted sum of consumption and housing tier.
         """
         households = context["households"]
-        # HousingManager might be passed in context or instantiated here.
-        # The spec says context has 'housing_manager', but the old code instantiated it.
-        # Let's instantiate it if not provided to be safe, or use what's provided.
-        # For simplicity and to match legacy logic, we instantiate a helper.
-        # But `HousingManager` needs an agent.
-
         scores = []
 
-        # We need a helper for housing tier. The HousingManager takes (agent, config).
-        # We will reuse it per agent or just create one temporary instance if stateless?
-        # HousingManager.get_housing_tier(agent) uses agent attributes.
-        # So we can just instantiate it once with None agent if the method accepts agent.
-        # Checking HousingManager code... `get_housing_tier` takes `agent`.
-        # The `__init__` takes `agent`, but `get_housing_tier` also takes `agent` as argument.
-        # This seems redundant or one is ignored.
-        # Looking at `simulation/decisions/housing_manager.py`:
-        # class HousingManager: def __init__(self, agent: Any, config: Any): self.agent = agent ...
-        # def get_housing_tier(self, agent: Any) -> float: ...
-        # It seems it can be used statelessly if we pass agent to get_housing_tier.
-
-        hm = context.get("housing_manager")
-        if not hm:
-             hm = HousingManager(None, self.config)
-
         for h in households:
             if not h.is_active: continue
 
             # Calculate Score
             consumption_score = h._econ_state.current_consumption * 10.0
-            housing_tier = hm.get_housing_tier(h)
+            housing_tier = self._get_housing_tier(h)
             housing_score = housing_tier * 1000.0
 
             total_score = consumption_score + housing_score
@@ -83,12 +68,8 @@ class SocialSystem(ISocialSystem):
         top_20_count = max(1, int(len(active_households) * 0.20))
         top_20 = sorted_hh[:top_20_count]
 
-        hm = context.get("housing_manager")
-        if not hm:
-             hm = HousingManager(None, self.config)
-
         avg_cons = sum(h._econ_state.current_consumption for h in top_20) / len(top_20)
-        avg_tier = sum(hm.get_housing_tier(h) for h in top_20) / len(top_20)
+        avg_tier = sum(self._get_housing_tier(h) for h in top_20) / len(top_20)
 
         return {
             "avg_consumption": avg_cons,
diff --git a/tests/integration/scenarios/verify_real_estate_sales.py b/tests/integration/scenarios/verify_real_estate_sales.py
deleted file mode 100644
index fd607fe..0000000
--- a/tests/integration/scenarios/verify_real_estate_sales.py
+++ /dev/null
@@ -1,185 +0,0 @@
-
-import unittest
-from unittest.mock import MagicMock
-from simulation.core_agents import Household
-from simulation.decisions.housing_manager import HousingManager
-from simulation.engine import Simulation as Engine
-from simulation.bank import Bank, Loan
-from simulation.markets import OrderBookMarket
-from simulation.models import Order
-from simulation.models import RealEstateUnit
-from simulation.ai.api import Personality
-import config
-
-class MockConfig:
-    INITIAL_PROPERTY_VALUE = 10000.0
-    INITIAL_RENT_PRICE = 50.0
-    MAINTENANCE_RATE_PER_TICK = 0.001
-    MORTGAGE_INTEREST_RATE = 0.05 / 12 # Monthly
-    GOODS = {}
-    SERVICE_SECTORS = []
-    ADAPTATION_RATE_NORMAL = 0.05
-    INITIAL_HOUSEHOLD_ASSETS_MEAN = 1000.0
-    INITIAL_HOUSEHOLD_ASSETS_STD = 0.0
-    INITIAL_HOUSEHOLD_WAGE_MEAN = 10.0
-    INITIAL_HOUSEHOLD_WAGE_STD = 0.0
-    LABOR_MARKET_MIN_WAGE = 5.0
-    BASE_DESIRE_GROWTH = 0.1
-    INITIAL_NEEDS_MEAN = 50.0
-    INITIAL_NEEDS_STD = 0.0
-    GOODS_INITIAL_PRICE = {}
-    INITIAL_FIRM_LIQUIDITY_NEED_MEAN = 50.0
-    MAX_DESIRE_VALUE = 100.0
-    SURVIVAL_NEED_DEATH_THRESHOLD = 90.0
-    HOUSEHOLD_MIN_ASSETS_FOR_INVESTMENT = 500.0
-    ASSETS_DEATH_THRESHOLD = -100.0
-    HOUSEHOLD_DEATH_TURNS_THRESHOLD = 50
-    START_AGE = 20
-    MAX_AGE = 100
-    AGING_ENABLED = False
-    
-class TestRealEstateSales(unittest.TestCase):
-    def setUp(self):
-        self.config = MockConfig()
-        mock_decision_engine = MagicMock()
-        
-        self.agent = Household(
-            id=1, 
-            config_module=self.config, 
-            talent=0.5, 
-            goods_data=[],
-            initial_assets=1000.0,
-            initial_needs={},
-            decision_engine=mock_decision_engine,
-            value_orientation="WEALTH",
-            personality=Personality.STATUS_SEEKER
-        )
-        self.housing_manager = HousingManager(self.agent, self.config)
-
-    def test_personality_bias_optimism(self):
-        # Scenario: NPV is slightly negative for neutral agent, but Optimist sees as Positive
-        # Prop Value = 10000, Appr = 0.2%
-        # Rent = 40 (Cheap rent makes Buying less attractive)
-        
-        prop_val = 10000
-        rent = 40 
-        
-        # 1. Neutral (Optimism 0.0 -> 0.5 effectively in formula)
-        self.agent.optimism = 0.0 # Normalized range 0.0-1.0? 
-        # In code: base * (0.5 + optimism). 
-        # Wait, core_agents init: 0.5 + uniform.
-        # Let's set explicit values.
-        self.agent.optimism = 0.0 # Very Pessimistic: multiplier 0.5
-        self.agent.ambition = 0.0
-        
-        should_buy_pessimist = self.housing_manager.should_buy(prop_val, rent)
-        
-        # 2. Maximum Optimist (Optimism 1.0 -> multiplier 1.5)
-        self.agent.optimism = 1.0
-        should_buy_optimist = self.housing_manager.should_buy(prop_val, rent)
-        
-        print(f"Pessimist Buy? {should_buy_pessimist} | Optimist Buy? {should_buy_optimist}")
-        
-        # We expect Optimist to be MORE likely to buy.
-        # If Pessimist False and Optimist True => Success logic test
-        # If both False, rent is too cheap. If both True, rent is too high.
-        # Adjusted Rent to find the sweet spot if needed, but relative comparison is key.
-        if should_buy_pessimist == should_buy_optimist:
-             # Just verify that Net Buy Cost is lower for Optimist (Higher Future Value)
-             pass
-        else:
-             self.assertTrue(should_buy_optimist and not should_buy_pessimist, "Optimist should buy while Pessimist rents in marginal case")
-
-    def test_personality_bias_ambition(self):
-        # Ambition adds Prestige Bonus (Negative Cost)
-        prop_val = 10000
-        rent = 40
-        
-        self.agent.optimism = 0.5 # Neutral
-        self.agent.ambition = 0.0 # No pride
-        decision_modest = self.housing_manager.should_buy(prop_val, rent)
-        
-        self.agent.ambition = 1.0 # High pride -> Big Prestige Bonus
-        decision_proud = self.housing_manager.should_buy(prop_val, rent)
-        
-        print(f"Modest Buy? {decision_modest} | Proud Buy? {decision_proud}")
-        # Proud agent subtracts (Val * 0.1) from Cost. Should be much more likely to buy.
-        
-    def test_engine_transaction_execution(self):
-        # 1. Setup Engine
-        # Mocking arguments for Simulation
-        mock_ai_trainer = MagicMock()
-        mock_repo = MagicMock()
-        
-        # Need real households to test interaction? Or mocks?
-        # Real household needed for attributes like assets/id in transaction
-        mock_talent = MagicMock()
-        mock_talent.base_learning_rate = 0.5
-        mock_talent.max_potential = {}
-        hh1 = Household(id=100, config_module=self.config, talent=mock_talent, goods_data={}, initial_assets=10000.0, initial_needs={"survival": 50.0, "asset": 50.0, "social": 50.0, "growth": 50.0, "leisure": 50.0, "self_actualization": 50.0, "improvement": 50.0}, decision_engine=MagicMock(), value_orientation="WEALTH", personality=Personality.STATUS_SEEKER)
-        
-        # Need at least one household
-        households = [hh1]
-        firms = []
-        
-        engine = Engine(households=households, firms=firms, ai_trainer=mock_ai_trainer, repository=mock_repo, config_module=config, goods_data={})
-        
-        # 2. Setup Market and Orders
-        engine.markets["housing"] = OrderBookMarket("housing")
-        
-        # Manually init real_estate_units as Engine.__init__ might do it if I passed config, 
-        # But Engine.__init__ uses self.config_module.NUM_HOUSING_UNITS.
-        # My MockConfig has it? No, need to check.
-        # Let's manually inject units to be sure.
-        unit0 = RealEstateUnit(id=0, estimated_value=10000.0, rent_price=50.0)
-        engine.real_estate_units = [unit0]
-        
-        # Seller: Government (Agent -1) selling Unit 0
-        unit = engine.real_estate_units[0]
-        unit.owner_id = None # Gov owned
-        unit.estimated_value = 10000.0
-        
-        # Mock Government ID in Engine
-        # Engine initializes Government agent inside __init__.
-        # We need to ensure engine.government exists and get its ID.
-        # Since we initialized Engine with mock config, it creates a government agent.
-        gov_id = engine.government.id
-
-        buy_order = Order(agent_id=engine.households[0].id, item_id="unit_0", price_limit=10000.0, quantity=1, side="BUY", market_id="housing")
-        # Use valid government ID for Sell Order
-        sell_order = Order(agent_id=gov_id, item_id="unit_0", price_limit=10000.0, quantity=1, side="SELL", market_id="housing")
-        
-        # Inject orders directly for matching simulation
-        engine.markets["housing"].place_order(buy_order, 0)
-        engine.markets["housing"].place_order(sell_order, 0)
-        
-        # 3. Match Orders (returns Transaction DTOs)
-        txs = engine.markets["housing"].match_orders(0)
-        print(f"DEBUG: Transactions generated: {txs}")
-        
-        # 4. Process Transactions (Logic we implemented)
-        # Give buyer some assets but less than price to trigger Mortgage
-        buyer = engine.households[0]
-        buyer._assets = 3000.0 # Needs 7000 Loan (LTV 70%)
-        # Note: Logic grants LTV 80% (8000). Max Loan.
-        # Downpayment = 2000. Buyer has 3000. OK.
-        
-        print(f"DEBUG: Bank Assets: {engine.bank.assets}")
-        print(f"DEBUG: Config Bank Assets: {config.INITIAL_BANK_ASSETS}")
-
-        engine._process_transactions(txs)
-        
-        # 5. Assertions
-        # Title Transfer
-        self.assertEqual(unit.owner_id, buyer.id)
-        # Mortgage Exists
-        self.assertIsNotNone(unit.mortgage_id)
-        # Loan Check
-        loan = engine.bank.loans[unit.mortgage_id]
-        self.assertEqual(loan.borrower_id, buyer.id)
-        self.assertEqual(loan.principal, 8000.0) # 80% of 10000
-        
-        print("Transaction & Mortgage Test Passed")
-
-if __name__ == '__main__':
-    unittest.main()
diff --git a/tests/integration/scenarios/verify_vanity_society.py b/tests/integration/scenarios/verify_vanity_society.py
index 9b2e7c8..d56a82c 100644
--- a/tests/integration/scenarios/verify_vanity_society.py
+++ b/tests/integration/scenarios/verify_vanity_society.py
@@ -8,7 +8,6 @@ sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
 
 from simulation.core_agents import Household
 from simulation.ai.enums import Personality
-from simulation.decisions.housing_manager import HousingManager
 from simulation.ai.household_ai import HouseholdAI
 import config
 
@@ -24,46 +23,84 @@ def vanity_config():
         "MISER": (0.1, 0.2)
     }
     config_module.GOODS = {
-        "luxury_bag": {"is_veblen": True}
+        "luxury_bag": {"is_veblen": True, "utility_effects": {"social": 1.0}}
     }
+    config_module.goods = config_module.GOODS
     config_module.MIMICRY_FACTOR = 0.5
+    config_module.DEFAULT_MORTGAGE_RATE = 0.05
+    config_module.default_mortgage_rate = 0.05
     config_module.INITIAL_RENT_PRICE = 100.0
     config_module.MAINTENANCE_RATE_PER_TICK = 0.001
     config_module.DSR_CRITICAL_THRESHOLD = 0.4
+    config_module.dsr_critical_threshold = 0.4
     config_module.HOUSEHOLD_MAX_PURCHASE_QUANTITY = 5.0
+    config_module.household_max_purchase_quantity = 5.0
     config_module.BULK_BUY_NEED_THRESHOLD = 70.0
+    config_module.bulk_buy_need_threshold = 70.0
     config_module.BULK_BUY_AGG_THRESHOLD = 0.8
+    config_module.bulk_buy_agg_threshold = 0.8
     config_module.BULK_BUY_MODERATE_RATIO = 0.6
+    config_module.bulk_buy_moderate_ratio = 0.6
     config_module.NEED_FACTOR_BASE = 0.5
+    config_module.need_factor_base = 0.5
     config_module.NEED_FACTOR_SCALE = 100.0
+    config_module.need_factor_scale = 100.0
     config_module.VALUATION_MODIFIER_BASE = 0.9
+    config_module.valuation_modifier_base = 0.9
     config_module.VALUATION_MODIFIER_RANGE = 0.2
+    config_module.valuation_modifier_range = 0.2
     config_module.MARKET_PRICE_FALLBACK = 10.0
+    config_module.market_price_fallback = 10.0
     config_module.MIN_PURCHASE_QUANTITY = 0.1
+    config_module.min_purchase_quantity = 0.1
     config_module.BUDGET_LIMIT_NORMAL_RATIO = 0.5
+    config_module.budget_limit_normal_ratio = 0.5
     config_module.BUDGET_LIMIT_URGENT_NEED = 80.0
+    config_module.budget_limit_urgent_need = 80.0
     config_module.BUDGET_LIMIT_URGENT_RATIO = 0.9
+    config_module.budget_limit_urgent_ratio = 0.9
     config_module.JOB_QUIT_THRESHOLD_BASE = 2.0
+    config_module.job_quit_threshold_base = 2.0
     config_module.JOB_QUIT_PROB_BASE = 0.1
+    config_module.job_quit_prob_base = 0.1
     config_module.JOB_QUIT_PROB_SCALE = 0.9
+    config_module.job_quit_prob_scale = 0.9
     config_module.RESERVATION_WAGE_BASE = 1.5
+    config_module.reservation_wage_base = 1.5
     config_module.RESERVATION_WAGE_RANGE = 1.0
+    config_module.reservation_wage_range = 1.0
     config_module.LABOR_MARKET_MIN_WAGE = 8.0
+    config_module.labor_market_min_wage = 8.0
     config_module.TARGET_FOOD_BUFFER_QUANTITY = 5.0
+    config_module.target_food_buffer_quantity = 5.0
     config_module.PANIC_BUYING_THRESHOLD = 0.05
+    config_module.panic_buying_threshold = 0.05
     config_module.DEFLATION_WAIT_THRESHOLD = -0.05
+    config_module.deflation_wait_threshold = -0.05
     config_module.HOARDING_FACTOR = 0.5
+    config_module.hoarding_factor = 0.5
     config_module.DELAY_FACTOR = 0.5
+    config_module.delay_factor = 0.5
     config_module.HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK = 2.0
+    config_module.household_food_consumption_per_tick = 2.0
     config_module.STOCK_MARKET_ENABLED = False
+    config_module.stock_market_enabled = False
     config_module.HOUSEHOLD_MIN_ASSETS_FOR_INVESTMENT = 500.0
+    config_module.household_min_assets_for_investment = 500.0
     config_module.HOUSEHOLD_INVESTMENT_BUDGET_RATIO = 0.2
+    config_module.household_investment_budget_ratio = 0.2
     config_module.STOCK_MIN_ORDER_QUANTITY = 1.0
+    config_module.stock_min_order_quantity = 1.0
     config_module.STOCK_BUY_DISCOUNT_THRESHOLD = 0.1
+    config_module.stock_buy_discount_threshold = 0.1
     config_module.STOCK_SELL_PROFIT_THRESHOLD = 0.15
+    config_module.stock_sell_profit_threshold = 0.15
     config_module.STARTUP_COST = 30000.0
+    config_module.startup_cost = 30000.0
     config_module.EXPECTED_STARTUP_ROI = 0.15
+    config_module.expected_startup_roi = 0.15
     config_module.WAGE_RECOVERY_RATE = 0.01
+    config_module.wage_recovery_rate = 0.01
 
     return config_module
 
@@ -71,23 +108,37 @@ def test_social_rank_calculation(vanity_config):
     """Verify sorting and percentile assignment"""
     households = []
     for i in range(5):
-        h = Mock(spec=Household)
+        h = Mock()
         h.id = i
         h._bio_state.is_active = True
         h._econ_state.current_consumption = float(i * 10) # 0, 10, 20, 30, 40
+
+        # Mock behavior for residing_property_id
+        # We simulate that the property returns None by default (homeless)
+        # However, Mock spec creates a PropertyMock. We need to configure it or the attribute.
+        # Simplest way for this test: rely on is_homeless logic if we were using HousingManager,
+        # but since we are replacing logic, we should set attributes explicitly.
+
+        h.residing_property_id = None
         h._econ_state.residing_property_id = None
         h._econ_state.is_homeless = True # Tier 0
         households.append(h)
 
     # Give top agent a house
-    households[4].is_homeless = False # Tier 1
+    households[4].is_homeless = False
+    households[4].residing_property_id = 1 # Tier 1
+    households[4]._econ_state.residing_property_id = 1
 
-    # Inject the logic here to test correctness
+    # Inject the logic here to test correctness (mimicking SocialSystem logic)
     scores = []
-    hm = HousingManager(None, vanity_config)
     for h in households:
         consumption_score = h._econ_state.current_consumption * 10.0
-        housing_tier = hm.get_housing_tier(h)
+
+        # Logic from SocialSystem._get_housing_tier
+        housing_tier = 0.0
+        if h.residing_property_id is not None:
+            housing_tier = 1.0
+
         housing_score = housing_tier * 1000.0
         scores.append((h.id, consumption_score + housing_score))
 
@@ -108,17 +159,26 @@ def test_veblen_demand(vanity_config):
     from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
     from simulation.dtos import DecisionContext
 
-    household = Mock(spec=Household)
+    household = Mock()
     household.id = 1
     household._econ_state.is_employed = True
     household._econ_state.current_wage = 100.0
-    household._econ_state.portfolio.to_legacy_dict() = {}
+    household._econ_state.portfolio.to_legacy_dict.return_value = {}
     household._social_state.conformity = 1.0 # Max conformity
     household._econ_state.inventory = {}
-    household._bio_state.needs = {"social": 10.0}
+    household._bio_state.needs = {"social": 10.0, "survival": 0.0}
+    household.needs = {"social": 10.0, "survival": 0.0}
     household._assets = 10000.0
+    household.assets = 10000.0
+    household.current_wage = 100.0
+    household.durable_assets = []
+    household.inventory = {}
+    household.perceived_prices = {}
+    household.demand_elasticity = 1.0
     household._econ_state.expected_inflation = {} # Fix attribute error
+    household.expected_inflation = {}
     household._social_state.personality = Personality.STATUS_SEEKER # Fix attribute error
+    household.risk_aversion = 1.0
     household.preference_asset = 1.0
     household.preference_social = 1.0
     household.preference_growth = 1.0
@@ -137,57 +197,34 @@ def test_veblen_demand(vanity_config):
     # Case 1: Low Price
     market_data_low = {"goods_market": {"luxury_bag_current_sell_price": 100.0}}
     context = DecisionContext(
-        markets={},
         goods_data=[],
         market_data=market_data_low,
         current_time=0,
-        household=household
+        state=household,
+        config=vanity_config
     )
-    orders_low, _ = engine.make_decisions(context)
+    output_low = engine.make_decisions(context)
+    orders_low = output_low.orders
     wtp_low = orders_low[0].price if orders_low else 0
 
     # Case 2: High Price
     market_data_high = {"goods_market": {"luxury_bag_current_sell_price": 1000.0}}
     context = DecisionContext(
-        markets={},
         goods_data=[],
         market_data=market_data_high,
         current_time=0,
-        household=household
+        state=household,
+        config=vanity_config
     )
-    orders_high, _ = engine.make_decisions(context)
+    output_high = engine.make_decisions(context)
+    orders_high = output_high.orders
     wtp_high = orders_high[0].price if orders_high else 0
 
     # Just ensure code execution path
     assert len(orders_high) > 0
     assert wtp_high > wtp_low
 
-def test_mimicry_trigger(vanity_config):
-    """Verify panic buy trigger"""
-    agent = Mock(spec=Household)
-    agent.conformity = 1.0
-    agent.is_homeless = True # Tier 0
-    agent.residing_property_id = None
-
-    config = vanity_config
-    hm = HousingManager(agent, config)
-
-    # Ref Standard: Tier 1.0
-    ref = {"avg_housing_tier": 1.0}
-
-    # Case A: Urgency 0.5 (Borderline) -> None
-    intent = hm.decide_mimicry_purchase(ref)
-    assert intent is None
-
-    # Case B: Increase Gap or Conformity? Conformity maxed.
-    # Increase Mimicry Factor in config
-    config.MIMICRY_FACTOR = 0.6
-    hm = HousingManager(agent, config)
-
-    intent = hm.decide_mimicry_purchase(ref)
-    assert intent is not None
-    assert intent.priority == "URGENT"
-    assert intent.max_ltv == 0.95
+# test_mimicry_trigger removed as HousingManager mimicry logic is deprecated
 
 def test_vanity_switch_ab(vanity_config):
     """Integration: test_vanity_switch_ab (VANITY_WEIGHT=0 vs 1.5 비교)"""
diff --git a/tests/unit/decisions/legacy_household_engine_fixture.py b/tests/unit/decisions/legacy_household_engine_fixture.py
index 5885482..98d73d3 100644
--- a/tests/unit/decisions/legacy_household_engine_fixture.py
+++ b/tests/unit/decisions/legacy_household_engine_fixture.py
@@ -330,61 +330,8 @@ class LegacyAIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
 
         # 6. Real Estate Logic
         # Refactored for DTO Purity (WO-103)
-        if context.market_snapshot:
-             from simulation.decisions.housing_manager import HousingManager
-
-             # Use context.config (HouseholdConfigDTO)
-             housing_manager = HousingManager(household, context.config)
-
-             reference_standard = market_data.get("reference_standard", {})
-             mimicry_intent = housing_manager.decide_mimicry_purchase(reference_standard)
-
-             is_owner_occupier = household._econ_state.residing_property_id in household._econ_state.owned_properties
-             should_search = (not is_owner_occupier) or (mimicry_intent is not None)
-
-             if should_search:
-                 best_offer = None
-                 min_price = float('inf')
-
-                 # Iterate over snapshot asks to find housing units
-                 # Housing units are identified by 'unit_' prefix in item_id
-                 for item_id, orders_list in context.market_snapshot.asks.items():
-                     if not item_id.startswith("unit_"):
-                         continue
-                     if not orders_list:
-                         continue
-
-                     cheapest = orders_list[0] # Assuming sorted ascending
-                     if cheapest.price < min_price:
-                         min_price = cheapest.price
-                         best_offer = cheapest
-
-                 if best_offer:
-                     # Use market_data instead of live loan_market object (IBankService formalization)
-                     mortgage_rate = market_data.get("loan_market", {}).get("interest_rate", config.default_mortgage_rate)
-
-                     should_buy = False
-
-                     if mimicry_intent:
-                         should_buy = True
-                     elif not is_owner_occupier:
-                         should_buy = housing_manager.should_buy(
-                             best_offer.price,
-                             self.config_module.INITIAL_RENT_PRICE,
-                             mortgage_rate
-                         )
-
-                     if should_buy:
-                         buy_order = Order(
-                             household.id, "BUY", best_offer.item_id, 1.0, best_offer.price, "housing"
-                         )
-                         orders.append(buy_order)
-
-                         if mimicry_intent:
-                             self.logger.info(
-                                 f"MIMICRY_BUY | Household {household.id} panic buying housing due to relative deprivation.",
-                                 extra={"tick": current_time, "agent_id": household.id}
-                             )
+        # Housing Manager Logic removed as part of TD-197 cleanup (Saga Implementation supersedes)
+        pass
 
         return orders, action_vector
 
diff --git a/tests/unit/systems/test_social_system.py b/tests/unit/systems/test_social_system.py
index ba27200..6a72763 100644
--- a/tests/unit/systems/test_social_system.py
+++ b/tests/unit/systems/test_social_system.py
@@ -7,16 +7,25 @@ class MockHousehold:
     def __init__(self, id, consumption, housing_tier, is_active=True):
         self.id = id
         self.current_consumption = consumption
-        self.housing_tier = housing_tier # Helper for mocking HousingManager
+        self.housing_tier = housing_tier
+        # Map housing_tier to residing_property_id (Tier > 0 -> has house)
+        # Note: HousingManager allowed tiers > 1.0 (based on logic).
+        # The new SocialSystem simple logic treats any house as 1.0.
+        # So we adjust expectations or inputs.
+        # For this test, h2 had tier 3.0. This implies legacy logic allowed value-based tiers.
+        # But SocialSystem now returns 1.0 for any house.
+        # So we need to update the test expectation or inputs.
+        # If we want to test correct ranking, we should ensure consumption dominates or tiers match new logic.
+        # Let's adjust inputs to match the new simple 0/1 logic.
+
+        self.residing_property_id = 1 if housing_tier > 0 else None
+        self._econ_state = MagicMock()
+        self._econ_state.current_consumption = consumption
+        self._econ_state.residing_property_id = self.residing_property_id
+
         self.is_active = is_active
         self.social_rank = 0.0
 
-class MockHousingManager:
-    def __init__(self, agent, config):
-        pass
-    def get_housing_tier(self, agent):
-        return agent.housing_tier
-
 @pytest.fixture
 def social_system():
     config = MagicMock()
@@ -24,14 +33,21 @@ def social_system():
 
 def test_update_social_ranks(social_system):
     # Setup
-    h1 = MockHousehold(1, consumption=100, housing_tier=1.0) # Score = 1000 + 1000 = 2000
-    h2 = MockHousehold(2, consumption=200, housing_tier=3.0) # Score = 2000 + 3000 = 5000 (Top)
-    h3 = MockHousehold(3, consumption=50, housing_tier=1.0)  # Score = 500 + 1000 = 1500 (Bottom)
+    # Updated logic: Housing Tier is 1.0 if owning/residing, else 0.0.
+    # Scores: Consumption * 10 + Tier * 1000
+
+    # h2: Cons 200 -> Score 2000. Tier 1 -> Score 1000. Total 3000.
+    h2 = MockHousehold(2, consumption=200, housing_tier=1.0)
+
+    # h1: Cons 100 -> Score 1000. Tier 1 -> Score 1000. Total 2000.
+    h1 = MockHousehold(1, consumption=100, housing_tier=1.0)
+
+    # h3: Cons 50 -> Score 500. Tier 1 -> Score 1000. Total 1500.
+    h3 = MockHousehold(3, consumption=50, housing_tier=1.0)
 
     households = [h1, h2, h3]
     context: SocialMobilityContext = {
-        "households": households,
-        "housing_manager": MockHousingManager(None, None)
+        "households": households
     }
 
     # Execute
@@ -62,8 +78,7 @@ def test_calculate_reference_standard(social_system):
 
     households = [h1, h2, h3, h4, h5]
     context: SocialMobilityContext = {
-        "households": households,
-        "housing_manager": MockHousingManager(None, None)
+        "households": households
     }
 
     # Execute
