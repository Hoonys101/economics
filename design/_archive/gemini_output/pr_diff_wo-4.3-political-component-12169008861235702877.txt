diff --git a/communications/insights/WO-4.3_Political_Component.md b/communications/insights/WO-4.3_Political_Component.md
new file mode 100644
index 0000000..7ed57e4
--- /dev/null
+++ b/communications/insights/WO-4.3_Political_Component.md
@@ -0,0 +1,11 @@
+# WO-4.3 Political Component Implementation Insights
+
+## Technical Debt
+1. **Government Stance Proxy**: Currently, `PoliticalComponent` assumes a binary stance for political parties (BLUE=0.9, RED=0.1). A more sophisticated model would have the Government agent expose a continuous `fiscal_stance` or `policy_score` that reflects its actual policy decisions (tax rates, spending), allowing for more nuanced ideological matching.
+2. **Missing `PoliticalComponent` Interface**: While `ISocialComponent` exists, `PoliticalComponent` does not implement an interface defined in `api.py`. It is currently a concrete class dependency in `Household`. Future refactoring should introduce `IPoliticalComponent` for better decoupling and testing.
+3. **`market_data` Coupling**: We injected government data into `market_data` in `prepare_market_data`. While effective, `market_data` is becoming a "god object" for context. A dedicated `SocioPoliticalContextDTO` might be cleaner in the future.
+
+## Insights
+1. **Stateless Decomposition Pattern**: The pattern of "Stateless Component + State DTO" proved effective again here. It allowed `PoliticalComponent` to be purely functional, making unit testing trivial (as seen in `test_political_component.py`).
+2. **Integration Complexity**: The main challenge was ensuring `Household` had access to global Government state (ruling party). Injecting this via `market_data` was the least invasive solution given the current architecture where `Household.update_needs` only receives `market_data`.
+3. **Trust Dynamics**: The trust damper mechanism (`trust < 0.2 => approval = 0`) creates a hysteresis effect where once trust is lost, it is hard to regain approval even if policies align. This adds realistic inertia to political dynamics.
diff --git a/modules/household/api.py b/modules/household/api.py
index 9073c94..84d6131 100644
--- a/modules/household/api.py
+++ b/modules/household/api.py
@@ -154,15 +154,6 @@ class ISocialComponent(ABC):
         """Calculates social status."""
         pass
 
-    @abstractmethod
-    def update_political_opinion(
-        self,
-        state: SocialStateDTO,
-        survival_need: float
-    ) -> SocialStateDTO:
-        """Updates political approval based on needs."""
-        pass
-
     @abstractmethod
     def apply_leisure_effect(
         self,
diff --git a/modules/household/dtos.py b/modules/household/dtos.py
index 3416adb..060ca72 100644
--- a/modules/household/dtos.py
+++ b/modules/household/dtos.py
@@ -167,6 +167,10 @@ class SocialStateDTO:
     # WO-157: Demand Elasticity
     demand_elasticity: float = 1.0
 
+    # WO-4.3: Political Component State
+    economic_vision: float = 0.5
+    trust_score: float = 0.5
+
     def copy(self) -> "SocialStateDTO":
         new_state = copy.copy(self)
         new_state.brand_loyalty = self.brand_loyalty.copy()
diff --git a/modules/household/mixins/_lifecycle.py b/modules/household/mixins/_lifecycle.py
index 6c6f043..c549150 100644
--- a/modules/household/mixins/_lifecycle.py
+++ b/modules/household/mixins/_lifecycle.py
@@ -14,6 +14,7 @@ if TYPE_CHECKING:
     from modules.household.bio_component import BioComponent
     from modules.household.econ_component import EconComponent
     from modules.household.social_component import SocialComponent
+    from modules.household.political_component import PoliticalComponent
     from simulation.decisions.base_decision_engine import BaseDecisionEngine
 
 class HouseholdLifecycleMixin:
@@ -37,6 +38,7 @@ class HouseholdLifecycleMixin:
     bio_component: "BioComponent"
     econ_component: "EconComponent"
     social_component: "SocialComponent"
+    political_component: "PoliticalComponent"
     decision_engine: "BaseDecisionEngine"
 
     def consume(self, item_id: str, quantity: float, current_time: int) -> ConsumptionResult:
@@ -98,8 +100,14 @@ class HouseholdLifecycleMixin:
         self._bio_state.is_active = is_active
 
         # 3. Update Political Opinion
-        self._social_state = self.social_component.update_political_opinion(
-            self._social_state, self._bio_state.needs.get("survival", 0.0)
+        gov_party = None
+        if market_data and "government" in market_data:
+            gov_party = market_data["government"].get("party")
+
+        self._social_state = self.political_component.update_opinion(
+            self._social_state,
+            self._bio_state.needs.get("survival", 0.0),
+            gov_party
         )
 
         # 4. Aging (Bio) - Also checks natural death
diff --git a/modules/household/political_component.py b/modules/household/political_component.py
index 7d46b53..cadfe78 100644
--- a/modules/household/political_component.py
+++ b/modules/household/political_component.py
@@ -1,6 +1,7 @@
 import logging
 import random
-from typing import Dict, Any, Optional
+from typing import Tuple
+from modules.household.dtos import SocialStateDTO
 from simulation.ai.enums import Personality, PoliticalParty, PoliticalVision
 
 logger = logging.getLogger(__name__)
@@ -8,92 +9,69 @@ logger = logging.getLogger(__name__)
 class PoliticalComponent:
     """
     Household's political soul.
-    Calculates approval and trust based on internal vision and external reality.
-    
-    Vision: 0.0 (Safety/Equity) to 1.0 (Growth/Ladder)
+    Stateless component that operates on SocialStateDTO.
     """
 
-    def __init__(self, personality: Personality):
-        self._economic_vision: float = self._derive_vision(personality)
-        self._trust_score: float = 0.5
-        self._current_approval: float = 0.5
-        
-        # Determine discretized vision for convenience
-        self._vision_enum: PoliticalVision = (
-            PoliticalVision.GROWTH if self._economic_vision > 0.5 
-            else PoliticalVision.SAFETY
-        )
-
-    def _derive_vision(self, personality: Personality) -> float:
-        """Derives economic vision from personality with some noise."""
+    def initialize_state(self, personality: Personality) -> Tuple[float, float]:
+        """
+        Derives initial economic vision and trust score from personality.
+        Returns: (economic_vision, trust_score)
+        """
         vision_map = {
             Personality.GROWTH_ORIENTED: 0.9,
             Personality.STATUS_SEEKER: 0.8,
-            Personality.MISER: 0.4, # Misers often prefer conservative stability but might shift
-            Personality.CONSERVATIVE: 0.3, # Personality 'Conservative' usually favors stability/status-quo
+            Personality.MISER: 0.4,
+            Personality.CONSERVATIVE: 0.3,
             Personality.IMPULSIVE: 0.5
         }
         base = vision_map.get(personality, 0.5)
         # Add noise to ensure diversity within cohorts (Emergence)
-        return max(0.0, min(1.0, base + random.uniform(-0.15, 0.15)))
-
-    @property
-    def economic_vision(self) -> float:
-        return self._economic_vision
-
-    @property
-    def trust_score(self) -> float:
-        return self._trust_score
-
-    @property
-    def vision_enum(self) -> PoliticalVision:
-        return self._vision_enum
+        economic_vision = max(0.0, min(1.0, base + random.uniform(-0.15, 0.15)))
+        trust_score = 0.5
+        return economic_vision, trust_score
 
-    def calculate_approval(
-        self, 
-        survival_satisfaction: float, 
-        gov_party: PoliticalParty,
-        gov_stance: float
-    ) -> float:
+    def update_opinion(
+        self,
+        state: SocialStateDTO,
+        survival_need: float,
+        gov_party: PoliticalParty
+    ) -> SocialStateDTO:
         """
-        [ADR-2] The Happiness Index & Ideological Match.
-        
-        Approval = (0.4 * Economic Reality) + (0.6 * Ideological Match)
-        Modified by Trust.
+        Updates political approval based on satisfaction and ideological match.
         """
-        # 1. Economic Reality (0.0 - 1.0)
-        # Assuming survival_satisfaction is already normalized
-        economic_reality = max(0.0, min(1.0, survival_satisfaction))
+        new_state = state.copy()
 
-        # 2. Ideological Distance (0.0 - 1.0)
+        # 1. Derive Gov Stance from Party
+        # BLUE (Growth) -> 0.9, RED (Safety) -> 0.1
+        gov_stance = 0.9 if gov_party == PoliticalParty.BLUE else 0.1
+
+        # 2. Calculate Satisfaction
+        # High survival need = Low satisfaction
+        # Assuming survival_need is 0-100 scale where 100 is max need (bad)
+        discontent = min(1.0, survival_need / 100.0)
+        satisfaction = 1.0 - discontent
+        new_state.discontent = discontent
+
+        # 3. Calculate Ideological Match
         # Distance = |My Vision - Gov Stance|
-        # Match = 1.0 - Distance
-        ideological_match = 1.0 - abs(self._economic_vision - gov_stance)
+        ideological_match = 1.0 - abs(new_state.economic_vision - gov_stance)
 
-        # 3. Base Approval
-        base_approval = (0.4 * economic_reality) + (0.6 * ideological_match)
+        # 4. Update Trust (EMA)
+        # Trust grows with satisfaction, decays with dissatisfaction
+        # Using slow adaptation (alpha=0.05)
+        new_trust = 0.95 * new_state.trust_score + 0.05 * satisfaction
+        new_state.trust_score = max(0.0, min(1.0, new_trust))
 
-        # 4. Trust Damper
-        # If trust is extremely low, approval is cratered regardless of match
-        if self._trust_score < 0.2:
-            base_approval *= (self._trust_score / 0.2)
-            
-        self._current_approval = max(0.0, min(1.0, base_approval))
-        return self._current_approval
+        # 5. Calculate Approval
+        # Approval = 0.4 * Satisfaction + 0.6 * Match
+        approval_score = (0.4 * satisfaction) + (0.6 * ideological_match)
 
-    def update_trust(self, economic_satisfaction: float):
-        """
-        Updates trust based on economic outcomes. 
-        Uses an EMA to reflect 'Memory' but slow adaptation.
-        """
-        alpha = 0.05 # Trust changes slowly
-        self._trust_score = (1 - alpha) * self._trust_score + alpha * economic_satisfaction
-        self._trust_score = max(0.0, min(1.0, self._trust_score))
+        # 6. Trust Damper
+        if new_state.trust_score < 0.2:
+            approval_score = 0.0
 
-    def get_state_dict(self) -> Dict[str, Any]:
-        return {
-            "economic_vision": self._economic_vision,
-            "vision_enum": self._vision_enum.name,
-            "trust_score": self._trust_score,
-            "approval": self._current_approval
-        }
+        # 7. Update Binary Approval Rating
+        # Threshold 0.5
+        new_state.approval_rating = 1 if approval_score > 0.5 else 0
+
+        return new_state
diff --git a/modules/household/social_component.py b/modules/household/social_component.py
index c80c81c..de69c4b 100644
--- a/modules/household/social_component.py
+++ b/modules/household/social_component.py
@@ -48,26 +48,6 @@ class SocialComponent(ISocialComponent):
 
         return new_state
 
-    def update_political_opinion(
-        self,
-        state: SocialStateDTO,
-        survival_need: float
-    ) -> SocialStateDTO:
-        """
-        Updates political approval based on needs.
-        Logic migrated from PsychologyComponent.update_political_opinion.
-        """
-        new_state = state.copy()
-        new_state.discontent = min(1.0, survival_need / 100.0)
-
-        # Determine Approval (Tolerance = 0.4)
-        if new_state.discontent < 0.4:
-            new_state.approval_rating = 1
-        else:
-            new_state.approval_rating = 0
-
-        return new_state
-
     def apply_leisure_effect(
         self,
         state: SocialStateDTO,
diff --git a/simulation/core_agents.py b/simulation/core_agents.py
index c0b5b53..1de1df4 100644
--- a/simulation/core_agents.py
+++ b/simulation/core_agents.py
@@ -114,7 +114,7 @@ class Household(
         self.social_component = SocialComponent()
         self.consumption_manager = ConsumptionManager()
         self.decision_unit = DecisionUnit()
-        self.political_component = PoliticalComponent(personality)
+        self.political_component = PoliticalComponent()
 
         # --- Initialize Internal State DTOs ---
 
@@ -245,6 +245,11 @@ class Household(
         else:
              self._social_state.desire_weights = {"survival": 1.0, "asset": 1.0, "social": 1.0, "improvement": 1.0, "quality": 1.0}
 
+        # WO-4.3: Initialize Political State
+        e_vision, t_score = self.political_component.initialize_state(personality)
+        self._social_state.economic_vision = e_vision
+        self._social_state.trust_score = t_score
+
         self.goods_info_map = {g["id"]: g for g in goods_data}
         self.risk_aversion = risk_aversion
 
diff --git a/simulation/orchestration/utils.py b/simulation/orchestration/utils.py
index 1ec6c98..437c52d 100644
--- a/simulation/orchestration/utils.py
+++ b/simulation/orchestration/utils.py
@@ -108,12 +108,18 @@ def prepare_market_data(state: SimulationState) -> Dict[str, Any]:
     if state.bank:
         interest_rate = state.bank.base_rate
 
+    # 3. Government Data (WO-4.3)
+    gov_data = {"party": None}
+    if state.government and hasattr(state.government, "ruling_party"):
+        gov_data["party"] = state.government.ruling_party
+
     return {
         "time": state.time,
         "goods_market": goods_market_data,
         "housing_market": housing_market_data,
         "loan_market": {"interest_rate": interest_rate},
         "stock_market": stock_market_data,
+        "government": gov_data,
         "all_households": state.households,
         "avg_goods_price": avg_goods_price_for_market_data,
         "debt_data": debt_data_map,
diff --git a/tests/modules/household/test_political_component.py b/tests/modules/household/test_political_component.py
new file mode 100644
index 0000000..8ade45f
--- /dev/null
+++ b/tests/modules/household/test_political_component.py
@@ -0,0 +1,84 @@
+import pytest
+from modules.household.political_component import PoliticalComponent
+from modules.household.dtos import SocialStateDTO
+from simulation.ai.enums import Personality, PoliticalParty
+
+def test_initialize_state_growth_oriented():
+    comp = PoliticalComponent()
+    vision, trust = comp.initialize_state(Personality.GROWTH_ORIENTED)
+    # Base 0.9 +/- 0.15 noise -> 0.75 to 1.0 (clamped)
+    assert 0.75 <= vision <= 1.0
+    assert trust == 0.5
+
+def test_initialize_state_conservative():
+    comp = PoliticalComponent()
+    vision, trust = comp.initialize_state(Personality.CONSERVATIVE)
+    # Base 0.3 +/- 0.15 -> 0.15 to 0.45
+    assert 0.15 <= vision <= 0.45
+    assert trust == 0.5
+
+def test_update_opinion_match():
+    comp = PoliticalComponent()
+    # High vision (Growth), Low Survival Need (Satisfied), Gov Blue (Growth)
+    state = SocialStateDTO(
+        personality=Personality.GROWTH_ORIENTED,
+        social_status=0.0, discontent=0.0, approval_rating=0,
+        conformity=0.5, social_rank=0.5, quality_preference=0.5,
+        brand_loyalty={}, last_purchase_memory={}, patience=0.5, optimism=0.5, ambition=0.5,
+        last_leisure_type="", demand_elasticity=1.0,
+        economic_vision=0.9, trust_score=0.5
+    )
+
+    # Gov Blue -> Stance 0.9. Match = 1.0 - |0.9 - 0.9| = 1.0
+    # Survival Need 10 -> Discontent 0.1, Satisfaction 0.9
+    # Approval = 0.4*0.9 + 0.6*1.0 = 0.36 + 0.6 = 0.96
+
+    new_state = comp.update_opinion(state, survival_need=10.0, gov_party=PoliticalParty.BLUE)
+
+    assert new_state.approval_rating == 1
+    assert new_state.discontent == 0.1
+    # Trust should increase: 0.95*0.5 + 0.05*0.9 = 0.475 + 0.045 = 0.52
+    assert new_state.trust_score > 0.5
+
+def test_update_opinion_mismatch_and_discontent():
+    comp = PoliticalComponent()
+    # High vision (Growth), High Survival Need (Dissatisfied), Gov Red (Safety)
+    state = SocialStateDTO(
+        personality=Personality.GROWTH_ORIENTED,
+        social_status=0.0, discontent=0.0, approval_rating=1,
+        conformity=0.5, social_rank=0.5, quality_preference=0.5,
+        brand_loyalty={}, last_purchase_memory={}, patience=0.5, optimism=0.5, ambition=0.5,
+        last_leisure_type="", demand_elasticity=1.0,
+        economic_vision=0.9, trust_score=0.5
+    )
+
+    # Gov Red -> Stance 0.1. Match = 1.0 - |0.9 - 0.1| = 0.2
+    # Survival Need 80 -> Discontent 0.8, Satisfaction 0.2
+    # Approval = 0.4*0.2 + 0.6*0.2 = 0.08 + 0.12 = 0.2
+
+    new_state = comp.update_opinion(state, survival_need=80.0, gov_party=PoliticalParty.RED)
+
+    assert new_state.approval_rating == 0
+    assert new_state.discontent == 0.8
+    # Trust should decrease: 0.95*0.5 + 0.05*0.2 = 0.475 + 0.01 = 0.485
+    assert new_state.trust_score < 0.5
+
+def test_trust_damper():
+    comp = PoliticalComponent()
+    # Trust very low
+    state = SocialStateDTO(
+        personality=Personality.GROWTH_ORIENTED,
+        social_status=0.0, discontent=0.0, approval_rating=1,
+        conformity=0.5, social_rank=0.5, quality_preference=0.5,
+        brand_loyalty={}, last_purchase_memory={}, patience=0.5, optimism=0.5, ambition=0.5,
+        last_leisure_type="", demand_elasticity=1.0,
+        economic_vision=0.9, trust_score=0.1
+    )
+
+    # Perfect match and satisfaction
+    new_state = comp.update_opinion(state, survival_need=0.0, gov_party=PoliticalParty.BLUE)
+
+    # Calculated approval would be high, but trust < 0.2 -> damper -> 0
+    # New trust will update: 0.95*0.1 + 0.05*1.0 = 0.095 + 0.05 = 0.145 (< 0.2)
+
+    assert new_state.approval_rating == 0
diff --git a/tests/modules/household/test_political_integration.py b/tests/modules/household/test_political_integration.py
new file mode 100644
index 0000000..acd7442
--- /dev/null
+++ b/tests/modules/household/test_political_integration.py
@@ -0,0 +1,84 @@
+import pytest
+from unittest.mock import MagicMock
+from simulation.core_agents import Household
+from simulation.ai.enums import Personality, PoliticalParty
+from simulation.dtos.config_dtos import HouseholdConfigDTO
+from modules.household.dtos import SocialStateDTO
+
+def test_household_update_political_opinion_integration():
+    # 1. Setup Mock Household
+    # Minimal config
+    config = MagicMock(spec=HouseholdConfigDTO)
+    config.initial_household_age_range = (20, 40)
+    config.value_orientation_mapping = {}
+    config.ticks_per_year = 100
+    config.wage_memory_length = 10
+    config.price_memory_length = 10
+    config.adaptation_rate_normal = 0.1
+    config.adaptation_rate_impulsive = 0.2
+    config.adaptation_rate_conservative = 0.05
+    config.initial_aptitude_distribution = (0.5, 0.1)
+    config.conformity_ranges = {}
+    config.initial_household_assets_mean = 1000
+    config.quality_pref_snob_min = 0.8
+    config.quality_pref_miser_max = 0.2
+    config.base_desire_growth = 1.0
+    config.max_desire_value = 100.0
+    config.survival_need_death_threshold = 200.0
+    config.social_status_asset_weight = 0.5
+    config.social_status_luxury_weight = 0.5
+    config.leisure_coeffs = {}
+    config.distress_grace_period_ticks = 10
+    config.elasticity_mapping = {}
+
+    mock_decision_engine = MagicMock()
+
+    household = Household(
+        id=1,
+        talent=MagicMock(),
+        goods_data=[],
+        initial_assets=1000.0,
+        initial_needs={"survival": 0.0},
+        decision_engine=mock_decision_engine,
+        value_orientation="Survival",
+        personality=Personality.GROWTH_ORIENTED,
+        config_dto=config
+    )
+
+    # Verify Initialization
+    assert household._social_state.economic_vision > 0.0
+    assert household._social_state.trust_score == 0.5
+
+    # 2. Run update_needs with Market Data (Government BLUE)
+    market_data = {
+        "government": {
+            "party": PoliticalParty.BLUE
+        }
+    }
+
+    # We want to check if approval rating updates.
+    # Initially 1 (default in DTO).
+    household._social_state.approval_rating = 0 # Force to 0 to see change
+
+    # Mock bio/econ component calls to avoid complex logic and side effects
+    household.econ_component.work = MagicMock(return_value=(household._econ_state, None))
+    household.social_component.update_psychology = MagicMock(
+        return_value=(
+            household._social_state,
+            {"survival": 10.0}, # New needs
+            [], # Durable assets
+            True # Is Active
+        )
+    )
+    household.bio_component.age_one_tick = MagicMock(return_value=household._bio_state)
+    household.econ_component.update_skills = MagicMock(return_value=household._econ_state)
+
+    household.update_needs(current_tick=1, market_data=market_data)
+
+    # 3. Assertions
+    # Growth personality (vision ~0.9) + Blue Gov (0.9) + Low Need (10) -> High Satisfaction + High Match
+    # Approval should become 1
+    assert household._social_state.approval_rating == 1
+
+    # Trust should increase
+    assert household._social_state.trust_score > 0.5
