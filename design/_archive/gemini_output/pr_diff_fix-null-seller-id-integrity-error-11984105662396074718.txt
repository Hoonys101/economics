diff --git a/communications/insights/mission_fix_null_seller_id.md b/communications/insights/mission_fix_null_seller_id.md
new file mode 100644
index 00000000..dc802619
--- /dev/null
+++ b/communications/insights/mission_fix_null_seller_id.md
@@ -0,0 +1,36 @@
+# Technical Insight Report: Fix NULL seller_id IntegrityError
+
+## 1. Problem Phenomenon
+- **Symptom**: The simulation crashes at Tick 50 with `sqlite3.IntegrityError: NOT NULL constraint failed: transactions.seller_id`.
+- **Context**: This occurs during "Firm 127's IPO/startup capital transfer".
+- **Stack Trace Analysis**: The error originates from `PersistenceManager` trying to save a `Transaction` where `seller_id` is None.
+- **Root Cause Indication**: A `Transaction` object was created with `seller_id=None` and passed to the persistence layer.
+
+## 2. Root Cause Analysis
+- **Primary Cause**: `SettlementSystem.transfer` and `_create_transaction_record` lacked validation for `buyer_id` and `seller_id`. If `debit_agent.id` or `credit_agent.id` was None (e.g., due to an initialization failure or improper mocking/usage in edge cases), a `Transaction` with `None` ID was created.
+- **Secondary Cause**: `PersistenceManager` blindly converted `Transaction` objects to `TransactionData` DTOs without checking for validity, leading to a database constraint violation.
+- **Specific Scenario**: Likely occurred during firm creation (`FirmSystem.spawn_firm`) if `new_firm.id` was somehow not properly initialized or if the `founder_household` (source) was invalid. Although tests with valid inputs passed, the system was fragile to invalid inputs.
+- **IPO/Stock Market**: `StockMarket.match_orders` also lacked validation, which could produce invalid transactions if an order from an agent with `None` ID was matched (e.g., a "Zombie" firm or malformed order).
+
+## 3. Solution Implementation Details
+1.  **FirmSystem.spawn_firm Validation**:
+    - Added critical checks to ensure `new_firm.id` and `founder_household.id` are not `None` before attempting the startup capital transfer.
+    - Logs a `STARTUP_FATAL` error and aborts if IDs are missing.
+
+2.  **SettlementSystem Validation**:
+    - `transfer`: Checks `debit_agent.id` and `credit_agent.id`. If `None`, logs `SETTLEMENT_FATAL` and returns `None` (aborting transfer).
+    - `_create_transaction_record`: Checks `buyer_id` and `seller_id`. If `None`, logs `SETTLEMENT_INTEGRITY_FAIL` and returns `None`.
+
+3.  **StockMarket Validation**:
+    - `match_orders`: Checks `agent_id` of matched orders. If `None`, logs `STOCK_MATCH_FATAL`, removes the invalid order, and skips the match.
+
+4.  **PersistenceManager Resilience**:
+    - `buffer_tick_state`: Checks if `tx.buyer_id` or `tx.seller_id` is `None`. If so, logs `PERSISTENCE_SKIP` and discards the transaction, protecting the database from `IntegrityError`.
+
+## 4. Lessons Learned & Technical Debt
+- **Lesson**: "Fail Fast" is crucial for data integrity. Systems like `SettlementSystem` should not accept invalid agents.
+- **Lesson**: Persistence layers should be defensive. They are the last line of defense before the database.
+- **Technical Debt**:
+    - `Firm` initialization relies on external `id` generation (`max_id + 1`). This is brittle in concurrent or distributed contexts (though fine for single-threaded).
+    - `Transaction` dataclass allows `None` (implicitly via `int | str` if strict type checking isn't enforced at runtime), but DB enforces `NOT NULL`. DTO validation should be stricter.
+    - Test coverage for edge cases (like invalid agents) was missing in core systems.
diff --git a/simulation/markets/stock_market.py b/simulation/markets/stock_market.py
index 7f595a7e..13af3a3d 100644
--- a/simulation/markets/stock_market.py
+++ b/simulation/markets/stock_market.py
@@ -244,6 +244,23 @@ class StockMarket(Market):
                 # 거래 가격: 두 호가의 평균
                 trade_price = (best_buy_dto.price_limit + best_sell_dto.price_limit) / 2
                 trade_quantity = min(best_buy_managed.remaining_quantity, best_sell_managed.remaining_quantity)
+
+                # Validation (Tech Debt Fix)
+                if best_buy_dto.agent_id is None or best_sell_dto.agent_id is None:
+                    self.logger.critical(
+                        f"STOCK_MATCH_FATAL | NULL ID in matched order! "
+                        f"BuyerID: {best_buy_dto.agent_id}, SellerID: {best_sell_dto.agent_id}. Skipping match.",
+                        extra={"tick": tick, "firm_id": firm_id}
+                    )
+                    # Skip this match and possibly pop the problematic order?
+                    # For safety, we just break or continue.
+                    # If we don't pop, we infinite loop.
+                    # We should pop the invalid one.
+                    if best_buy_dto.agent_id is None:
+                        buy_orders.pop(0)
+                    if best_sell_dto.agent_id is None:
+                        sell_orders.pop(0)
+                    continue
                 
                 # 거래 생성
                 transaction = Transaction(
diff --git a/simulation/systems/firm_management.py b/simulation/systems/firm_management.py
index 6bb59b6a..5dddcc0b 100644
--- a/simulation/systems/firm_management.py
+++ b/simulation/systems/firm_management.py
@@ -131,6 +131,15 @@ class FirmSystem:
         # Inject SettlementSystem into new firm
         new_firm.settlement_system = settlement_system
 
+        # CRITICAL VALIDATION (Tech Debt Fix: Null Seller ID)
+        if new_firm.id is None:
+            logger.critical(f"STARTUP_FATAL | New firm has NULL ID during creation! Aborting.")
+            return None
+
+        if not hasattr(founder_household, 'id') or founder_household.id is None:
+            logger.critical(f"STARTUP_FATAL | Founder household has NULL ID! Aborting.")
+            return None
+
         success = settlement_system.transfer(
             founder_household,
             new_firm,
diff --git a/simulation/systems/persistence_manager.py b/simulation/systems/persistence_manager.py
index 4db3fcd6..5cf16d5e 100644
--- a/simulation/systems/persistence_manager.py
+++ b/simulation/systems/persistence_manager.py
@@ -84,6 +84,15 @@ class PersistenceManager:
 
         # 2. Buffer transactions
         for tx in transactions:
+            # Validation (Tech Debt Fix)
+            if tx.buyer_id is None or tx.seller_id is None:
+                logger.error(
+                    f"PERSISTENCE_SKIP | Skipping transaction with NULL ID. "
+                    f"Buyer: {tx.buyer_id}, Seller: {tx.seller_id}, Item: {tx.item_id}",
+                    extra={"tick": time, "tags": ["persistence", "skip"]}
+                )
+                continue
+
             tx_dto = TransactionData(
                 run_id=self.run_id,
                 time=time,
diff --git a/simulation/systems/settlement_system.py b/simulation/systems/settlement_system.py
index a61ae7d9..710374b1 100644
--- a/simulation/systems/settlement_system.py
+++ b/simulation/systems/settlement_system.py
@@ -663,6 +663,19 @@ class SettlementSystem(ISettlementSystem):
              self.logger.error(f"SETTLEMENT_FAIL | Debit or Credit agent is None. Memo: {memo}")
              return None
 
+        # VALIDATION (Tech Debt Fix: Null IDs)
+        debit_id = getattr(debit_agent, 'id', None)
+        credit_id = getattr(credit_agent, 'id', None)
+
+        if debit_id is None or credit_id is None:
+             self.logger.critical(
+                 f"SETTLEMENT_FATAL | Transfer attempted with NULL agent IDs! "
+                 f"Debit ID: {debit_id}, Credit ID: {credit_id}. Memo: {memo}. "
+                 f"Aborting to prevent DB Integrity Error.",
+                 extra={"tick": tick, "tags": ["settlement", "integrity_error"]}
+             )
+             return None
+
         # EXECUTE
         success = self._execute_withdrawal(debit_agent, amount, memo, tick, currency=currency)
         if not success:
@@ -771,7 +784,15 @@ class SettlementSystem(ISettlementSystem):
             # If not CB, treat as regular transfer (e.g. tax to Gov)
             return self.transfer(source, sink_authority, amount, reason, tick=tick, currency=currency)
 
-    def _create_transaction_record(self, buyer_id: int, seller_id: int, amount: float, memo: str, tick: int) -> Transaction:
+    def _create_transaction_record(self, buyer_id: int, seller_id: int, amount: float, memo: str, tick: int) -> Optional[Transaction]:
+        if buyer_id is None or seller_id is None:
+             self.logger.critical(
+                 f"SETTLEMENT_INTEGRITY_FAIL | Attempted to create transaction with NULL ID. "
+                 f"Buyer: {buyer_id}, Seller: {seller_id}, Memo: {memo}. Skipping record creation.",
+                 extra={"tick": tick, "tags": ["integrity_error"]}
+             )
+             return None
+
         return Transaction(
             buyer_id=buyer_id,
             seller_id=seller_id,
