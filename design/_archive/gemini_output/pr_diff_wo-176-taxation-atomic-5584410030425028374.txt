diff --git a/communications/insights/WO-176.md b/communications/insights/WO-176.md
new file mode 100644
index 0000000..96f2bba
--- /dev/null
+++ b/communications/insights/WO-176.md
@@ -0,0 +1,24 @@
+# WO-176: Atomic Taxation & Settlement System
+
+## Status
+- **Date**: 2024-05-22
+- **Author**: Jules
+- **Mission**: WO-176
+
+## Technical Debt Identified
+1.  **Lack of Atomicity**: Tax payments are processed in separate, sequential transactions after the primary trade. This creates a risk where the trade succeeds but the tax payment fails (e.g., due to insufficient funds after the trade), leading to money leaks or inconsistent states.
+2.  **God Class (TransactionProcessor)**: `TransactionProcessor` handles financial settlement, tax calculation, inventory updates, and employment changes. This violates the Single Responsibility Principle (SRP).
+3.  **Tight Coupling**: `TransactionProcessor` is tightly coupled to `Government`'s internal tax logic (calling `collect_tax`).
+4.  **Government Responsibilities**: `Government` agent mixes policy-making with tax bookkeeping and direct collection logic.
+
+## Solution Overview
+We are implementing a "Saga-like" atomic settlement system.
+-   **TaxationSystem**: A dedicated system for tax calculation and revenue recording (pure logic + ledger).
+-   **SettlementSystem**: Enhanced with `settle_escrow` to handle multi-party atomic transfers (1 Debit -> N Credits) with rollback.
+-   **TransactionProcessor**: Refactored to be a pure orchestrator that bundles payment intents and delegates execution.
+-   **Government**: Simplified to be a policy decision maker and a passive payee.
+
+## Risks
+-   **Rollback Complexity**: Ensuring strict rollback in `SettlementSystem` is critical. If rollback fails, the system enters an inconsistent state.
+-   **Backward Compatibility**: The `Government` agent is widely used. Removing methods like `collect_tax` requires careful verification that no other components rely on them (or they must be updated).
+-   **State Management**: `TaxationSystem` now holds the tax revenue ledger. We must ensure that the `Government` agent can still access this data for its policy decisions (Taylor Rule, Fiscal Policy). We decided that `Government` will own the `TaxationSystem` instance, and `TransactionProcessor` will access it via `state.government.taxation_system`.
diff --git a/modules/government/taxation/api.py b/modules/government/taxation/api.py
new file mode 100644
index 0000000..fbd6e11
--- /dev/null
+++ b/modules/government/taxation/api.py
@@ -0,0 +1,79 @@
+"""
+API contracts for the TaxationSystem and related data structures.
+This API facilitates the decoupling of tax logic from the core TransactionProcessor.
+"""
+from __future__ import annotations
+from typing import Protocol, List, TypedDict, Optional, TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from simulation.models import Transaction
+    from simulation.dtos.api import SimulationState
+
+# ==================================================================
+# Data Transfer Objects (DTOs)
+# ==================================================================
+
+class TaxIntentDTO(TypedDict):
+    """
+    A specific instruction for a tax payment, generated by the TaxationSystem.
+    It includes the tax type for detailed revenue recording.
+    """
+    payer_id: int
+    payee_id: int # Should always be the government's ID
+    amount: float
+    tax_type: str # e.g., "sales_tax", "income_tax", "wealth_tax"
+
+class TaxCollectionResultDTO(TypedDict):
+    """
+    A record of the outcome of a tax collection attempt. This is used
+    for asynchronous recording and auditing.
+    """
+    success: bool
+    amount_collected: float
+    tax_type: str
+    payer_id: int
+    payee_id: int
+    tick: int
+    error_message: Optional[str]
+
+# ==================================================================
+# System Interface
+# ==================================================================
+
+class ITaxationSystem(Protocol):
+    """
+    Defines the public interface for a system responsible for all tax-related
+    calculations and record-keeping.
+    """
+
+    def generate_tax_intents(
+        self,
+        transaction: "Transaction",
+        state: "SimulationState"
+    ) -> List[TaxIntentDTO]:
+        """
+        Calculates all applicable taxes for a given transaction and returns them
+        as a list of TaxIntentDTOs. This method is purely computational and
+        MUST NOT cause any state changes.
+
+        Args:
+            transaction: The core transaction being processed (e.g., goods, labor).
+            state: The current simulation state for context (e.g., market prices).
+
+        Returns:
+            A list of tax intents to be bundled into a settlement operation.
+        """
+        ...
+
+    def record_revenue(self, intent: TaxIntentDTO, success: bool, tick: int) -> None:
+        """
+        Records the outcome of a tax payment attempt in the government's ledgers.
+        This method is called by the orchestrator (TransactionProcessor) after
+        the atomic settlement has been attempted.
+
+        Args:
+            intent: The original tax intent that was processed.
+            success: A boolean indicating if the settlement was successful.
+            tick: The current simulation tick.
+        """
+        ...
diff --git a/modules/government/taxation/system.py b/modules/government/taxation/system.py
index c9af0ac..b793e2e 100644
--- a/modules/government/taxation/system.py
+++ b/modules/government/taxation/system.py
@@ -1,23 +1,25 @@
-from dataclasses import dataclass
-from typing import List, Any, Dict, Optional
+from typing import List, Any, Dict, Optional, TYPE_CHECKING
+from modules.government.taxation.api import ITaxationSystem, TaxIntentDTO
 import logging
+from collections import defaultdict
 
-logger = logging.getLogger(__name__)
+if TYPE_CHECKING:
+    from simulation.models import Transaction
+    from simulation.dtos.api import SimulationState
 
-@dataclass
-class TaxIntent:
-    payer_id: int
-    payee_id: int # Usually Government ID
-    amount: float
-    reason: str
+logger = logging.getLogger(__name__)
 
-class TaxationSystem:
+class TaxationSystem(ITaxationSystem):
     """
     Pure logic component for tax calculations.
     Decoupled from Government agent state (policies are passed in) and Settlement execution.
+    Maintains a ledger of collected tax revenue.
     """
     def __init__(self, config_module: Any):
         self.config_module = config_module
+        self.tax_revenue_ledger: Dict[str, float] = {}
+        # Stores revenue per tick: {tick: {tax_type: amount}}
+        self.revenue_by_tick: Dict[int, Dict[str, float]] = defaultdict(lambda: defaultdict(float))
 
     def calculate_income_tax(self, income: float, survival_cost: float, current_income_tax_rate: float, tax_mode: str = 'PROGRESSIVE') -> float:
         """
@@ -61,36 +63,49 @@ class TaxationSystem:
         """Calculates corporate tax."""
         return profit * current_corporate_tax_rate if profit > 0 else 0.0
 
-    def calculate_tax_intents(
+    def generate_tax_intents(
         self,
-        transaction: Any, # Transaction model
-        buyer: Any,
-        seller: Any,
-        government: Any,
-        market_data: Optional[Dict[str, Any]] = None
-    ) -> List[TaxIntent]:
+        transaction: "Transaction",
+        state: "SimulationState"
+    ) -> List[TaxIntentDTO]:
         """
-        Determines applicable taxes for a transaction and returns TaxIntents.
+        Determines applicable taxes for a transaction and returns TaxIntentDTOs.
         Does NOT execute any transfer.
         """
-        intents: List[TaxIntent] = []
+        intents: List[TaxIntentDTO] = []
         trade_value = transaction.quantity * transaction.price
 
+        government = state.government
+        if not government:
+            logger.error("TaxationSystem: Government not found in state.")
+            return []
+
+        buyer = state.agents.get(transaction.buyer_id) or getattr(state, "inactive_agents", {}).get(transaction.buyer_id)
+        seller = state.agents.get(transaction.seller_id) or getattr(state, "inactive_agents", {}).get(transaction.seller_id)
+
+        market_data = state.market_data if state.market_data else {}
+
         # 1. Sales Tax (Goods)
         if transaction.transaction_type == "goods":
             sales_tax_rate = getattr(self.config_module, "SALES_TAX_RATE", 0.05)
             tax_amount = trade_value * sales_tax_rate
 
             if tax_amount > 0:
-                intents.append(TaxIntent(
-                    payer_id=buyer.id,
+                intents.append(TaxIntentDTO(
+                    payer_id=transaction.buyer_id,
                     payee_id=government.id,
                     amount=tax_amount,
-                    reason=f"sales_tax_{transaction.transaction_type}"
+                    tax_type=f"sales_tax_{transaction.transaction_type}"
                 ))
 
         # 2. Income Tax (Labor)
         elif transaction.transaction_type in ["labor", "research_labor"]:
+            if not buyer or not seller:
+                 # It's possible for agents to be missing if they were just removed, but transaction remains?
+                 # Or if ids are invalid.
+                 # logger.warning(f"TaxationSystem: Missing agents for labor tax calc. Buyer: {transaction.buyer_id}, Seller: {transaction.seller_id}")
+                 return []
+
             # Determine Survival Cost
             avg_food_price = 5.0 # Default
             if market_data:
@@ -105,7 +120,6 @@ class TaxationSystem:
             survival_cost = max(avg_food_price * daily_food_need, 10.0)
 
             # Get Tax Rate from Government
-            # Assuming government object has income_tax_rate attribute
             current_rate = getattr(government, "income_tax_rate", 0.1)
             tax_mode = getattr(self.config_module, "TAX_MODE", "PROGRESSIVE")
 
@@ -117,23 +131,31 @@ class TaxationSystem:
                 payer_id = buyer.id if tax_payer_type == "FIRM" else seller.id
                 reason = "income_tax_firm" if tax_payer_type == "FIRM" else "income_tax_household"
 
-                intents.append(TaxIntent(
+                intents.append(TaxIntentDTO(
                     payer_id=payer_id,
                     payee_id=government.id,
                     amount=tax_amount,
-                    reason=reason
+                    tax_type=reason
                 ))
 
-        # 3. Escheatment (If handled here, though it's usually 100% transfer)
-        # TransactionProcessor handled 'escheatment' as "collect_tax(trade_value)".
-        # This implies it's a transfer to Government.
-        # If we handle it here:
+        # 3. Escheatment
         elif transaction.transaction_type == "escheatment":
-             intents.append(TaxIntent(
-                payer_id=buyer.id, # Agent
+             intents.append(TaxIntentDTO(
+                payer_id=transaction.buyer_id,
                 payee_id=government.id,
                 amount=trade_value,
-                reason="escheatment"
+                tax_type="escheatment"
             ))
 
         return intents
+
+    def record_revenue(self, intent: TaxIntentDTO, success: bool, tick: int) -> None:
+        if success:
+            tax_type = intent['tax_type']
+            amount = intent['amount']
+            self.tax_revenue_ledger[tax_type] = self.tax_revenue_ledger.get(tax_type, 0.0) + amount
+            self.revenue_by_tick[tick][tax_type] += amount
+
+    def get_tick_revenue(self, tick: int) -> Dict[str, float]:
+        """Returns the revenue breakdown for a specific tick."""
+        return dict(self.revenue_by_tick.get(tick, {}))
diff --git a/simulation/agents/government.py b/simulation/agents/government.py
index 1499925..cd9a633 100644
--- a/simulation/agents/government.py
+++ b/simulation/agents/government.py
@@ -184,21 +184,6 @@ class Government:
                 extra={"tick": dto.tick, "agent_id": self.id, "tags": ["sensory", "wo-057-b"]}
             )
 
-    def calculate_income_tax(self, income: float, survival_cost: float) -> float:
-        """
-        Calculates income tax using the FiscalPolicyManager and current policy.
-        """
-        if self.fiscal_policy:
-            return self.fiscal_policy_manager.calculate_tax_liability(self.fiscal_policy, income)
-
-        # Fallback (should not happen if initialized correctly)
-        tax_mode = getattr(self.config_module, "TAX_MODE", "PROGRESSIVE")
-        return self.taxation_system.calculate_income_tax(income, survival_cost, self.income_tax_rate, tax_mode)
-
-    def calculate_corporate_tax(self, profit: float) -> float:
-        """Delegates corporate tax calculation to the TaxationSystem."""
-        return self.taxation_system.calculate_corporate_tax(profit, self.corporate_tax_rate)
-
     def reset_tick_flow(self):
         """
         매 틱 시작 시 호출되어 이번 틱의 Flow 데이터를 초기화하고,
@@ -231,71 +216,6 @@ class Government:
                 self.total_money_destroyed += tx.price
                 logger.debug(f"MONETARY_CONTRACTION | Credit destroyed: {tx.price:.2f}")
 
-    def collect_tax(self, amount: float, tax_type: str, payer: Any, current_tick: int) -> "TaxCollectionResult":
-        """
-        Legacy adapter method used by TransactionProcessor.
-
-        DEPRECATED: Direct usage of this method is discouraged.
-        """
-        warnings.warn(
-            "Government.collect_tax is deprecated. Use settlement.settle_atomic and government.record_revenue() instead.",
-            DeprecationWarning,
-            stacklevel=2
-        )
-
-        payer_id = payer.id if hasattr(payer, 'id') else str(payer)
-
-        if not self.settlement_system:
-            logger.error("Government has no SettlementSystem linked. Cannot collect tax.")
-            return {
-                "success": False,
-                "amount_collected": 0.0,
-                "tax_type": tax_type,
-                "payer_id": payer_id,
-                "payee_id": self.id,
-                "error_message": "No SettlementSystem linked"
-            }
-
-        # Execute atomic transfer directly via SettlementSystem (Internal logic)
-        # Using transfer() for single payment
-        success = self.settlement_system.transfer(payer, self, amount, f"{tax_type} collection")
-
-        result = {
-            "success": bool(success),
-            "amount_collected": amount if success else 0.0,
-            "tax_type": tax_type,
-            "payer_id": payer_id,
-            "payee_id": self.id,
-            "error_message": None if success else "Transfer failed"
-        }
-
-        # Record stats
-        self.record_revenue(result)
-
-        return result
-
-    def record_revenue(self, result: "TaxCollectionResult"):
-        """
-        [NEW] Updates the government's internal ledgers based on a verified
-        TaxCollectionResult DTO.
-        """
-        if not result['success'] or result['amount_collected'] <= 0:
-            return
-
-        amount = result['amount_collected']
-        tax_type = result['tax_type']
-        payer_id = result['payer_id']
-
-        self.total_collected_tax += amount
-        self.revenue_this_tick += amount
-        self.tax_revenue[tax_type] = (
-            self.tax_revenue.get(tax_type, 0.0) + amount
-        )
-        self.current_tick_stats["tax_revenue"][tax_type] = (
-            self.current_tick_stats["tax_revenue"].get(tax_type, 0.0) + amount
-        )
-        self.current_tick_stats["total_collected"] += amount
-
     def update_public_opinion(self, households: List[Any]):
         """
         Aggregates approval ratings from households and updates the opinion queue (Lag).
@@ -516,12 +436,25 @@ class Government:
                     tax_amount = min(tax_amount, agent.assets)
 
                     if tax_amount > 0 and self.settlement_system:
-                        # Replaced TaxAgency call with internal collect_tax or direct transfer
-                        # Using collect_tax (even if deprecated for external) is fine for internal shortcut
-                        # to handle recording.
-                        result = self.collect_tax(tax_amount, "wealth_tax", agent, current_tick)
-                        if result['success']:
-                             total_wealth_tax += result['amount_collected']
+                        # Direct atomic settlement using escrow
+                        intents = [{
+                            "payee": self,
+                            "amount": tax_amount,
+                            "memo": "wealth_tax"
+                        }]
+
+                        success = self.settlement_system.settle_escrow(agent, intents, current_tick)
+
+                        if success:
+                            # Record in TaxationSystem
+                            self.taxation_system.record_revenue({
+                                "payer_id": agent.id,
+                                "payee_id": self.id,
+                                "amount": tax_amount,
+                                "tax_type": "wealth_tax"
+                            }, True, current_tick)
+
+                            total_wealth_tax += tax_amount
 
                 # B. Unemployment Benefit
                 if not agent.is_employed:
@@ -658,9 +591,19 @@ class Government:
         """
         Called at the end of every tick to finalize statistics and push to history buffers.
         """
-        revenue_snapshot = self.current_tick_stats["tax_revenue"].copy()
+        # Fetch verified revenue stats from TaxationSystem
+        if hasattr(self.taxation_system, 'get_tick_revenue'):
+            revenue_data = self.taxation_system.get_tick_revenue(current_tick)
+        else:
+            revenue_data = {}
+
+        total_collected = sum(revenue_data.values())
+
+        revenue_snapshot = revenue_data.copy()
         revenue_snapshot["tick"] = current_tick
-        revenue_snapshot["total"] = self.current_tick_stats["total_collected"]
+        revenue_snapshot["total"] = total_collected
+
+        self.total_collected_tax += total_collected # Sync global total if needed
 
         # WO-057 Deficit Spending: Update total_debt based on FinanceSystem
         if self.finance_system:
diff --git a/simulation/finance/api.py b/simulation/finance/api.py
index 363a771..df6d910 100644
--- a/simulation/finance/api.py
+++ b/simulation/finance/api.py
@@ -1,4 +1,4 @@
-from typing import Protocol, runtime_checkable, Optional, Dict, Any, TypedDict, Union
+from typing import Protocol, runtime_checkable, Optional, Dict, Any, TypedDict, Union, List
 from abc import ABC, abstractmethod
 
 @runtime_checkable
@@ -44,6 +44,15 @@ class ITransaction(TypedDict):
     time: int
     metadata: Optional[Dict[str, Any]]
 
+class PaymentIntentDTO(TypedDict):
+    """
+    A generic instruction for the SettlementSystem to transfer funds.
+    Used in atomic escrow settlement.
+    """
+    payee: IFinancialEntity
+    amount: float
+    memo: str
+
 class ISettlementSystem(ABC):
     """
     Interface for the centralized settlement system.
@@ -82,6 +91,19 @@ class ISettlementSystem(ABC):
         """
         ...
 
+    @abstractmethod
+    def settle_escrow(
+        self,
+        payer: IFinancialEntity,
+        intents: List[PaymentIntentDTO],
+        tick: int
+    ) -> bool:
+        """
+        Atomically settles a multi-payment from one payer to multiple payees.
+        Returns True on success, False on failure (with full rollback).
+        """
+        ...
+
     @abstractmethod
     def create_and_transfer(
         self,
diff --git a/simulation/systems/settlement_system.py b/simulation/systems/settlement_system.py
index 7e8f279..457b6ad 100644
--- a/simulation/systems/settlement_system.py
+++ b/simulation/systems/settlement_system.py
@@ -1,7 +1,7 @@
 from typing import Optional, Dict, Any, cast, TYPE_CHECKING, Tuple, List
 import logging
 
-from simulation.finance.api import ISettlementSystem, ITransaction
+from simulation.finance.api import ISettlementSystem, ITransaction, PaymentIntentDTO
 from modules.finance.api import IFinancialEntity, InsufficientFundsError
 
 if TYPE_CHECKING:
@@ -154,49 +154,51 @@ class SettlementSystem(ISettlementSystem):
              self.logger.exception(f"SETTLEMENT_UNHANDLED_FAIL | {e}")
              return False
 
-    def settle_atomic(
+    def settle_escrow(
         self,
-        debit_agent: IFinancialEntity,
-        credits_list: List[Tuple[IFinancialEntity, float, str]],
+        payer: IFinancialEntity,
+        intents: List[PaymentIntentDTO],
         tick: int
     ) -> bool:
         """
-        Executes a one-to-many atomic settlement.
-        All credits are summed to determine the total debit amount.
-        If the debit fails, the entire transaction is aborted.
-        If any credit fails, previous credits in this batch are rolled back.
+        Atomically settles a multi-payment from one payer to multiple payees.
+        Returns True on success, False on failure (with full rollback).
         """
-        if not credits_list:
+        if not intents:
             return True
 
-        # 0. Validate Credits (No negative transfers allowed in this atomic mode)
-        for _, amount, memo in credits_list:
+        # 0. Validate Credits
+        total_debit = 0.0
+        for intent in intents:
+             amount = intent['amount']
              if amount < 0:
-                 self.logger.error(f"SETTLEMENT_FAIL | Negative credit amount {amount} in atomic batch. Memo: {memo}")
+                 self.logger.error(f"SETTLEMENT_FAIL | Negative credit amount {amount} in atomic batch. Memo: {intent['memo']}")
                  return False
+             total_debit += amount
 
-        # 1. Calculate Total Debit
-        total_debit = sum(amount for _, amount, _ in credits_list)
         if total_debit <= 0:
              return True
 
-        # 2. Debit Check & Withdrawal
-        memo = f"atomic_batch_{len(credits_list)}_txs"
-        success = self._execute_withdrawal(debit_agent, total_debit, memo, tick)
+        # 1. Debit Check & Withdrawal
+        memo = f"atomic_escrow_{len(intents)}_txs"
+        success = self._execute_withdrawal(payer, total_debit, memo, tick)
         if not success:
             return False
 
-        # 3. Execute Credits
+        # 2. Execute Credits
         completed_credits = []
-        for credit_agent, amount, credit_memo in credits_list:
+        for intent in intents:
+            payee = intent['payee']
+            amount = intent['amount']
             if amount <= 0:
                 continue
+
             try:
-                credit_agent.deposit(amount)
-                completed_credits.append((credit_agent, amount))
+                payee.deposit(amount)
+                completed_credits.append((payee, amount))
             except Exception as e:
                 self.logger.error(
-                    f"SETTLEMENT_ROLLBACK | Deposit failed for {credit_agent.id}. Rolling back atomic batch. Error: {e}"
+                    f"SETTLEMENT_ROLLBACK | Deposit failed for {payee.id}. Rolling back atomic batch. Error: {e}"
                 )
                 # ROLLBACK
                 # 1. Reverse completed credits
@@ -208,14 +210,30 @@ class SettlementSystem(ISettlementSystem):
 
                 # 2. Refund debit agent
                 try:
-                    debit_agent.deposit(total_debit)
+                    payer.deposit(total_debit)
                 except Exception as rb_err:
-                    self.logger.critical(f"SETTLEMENT_FATAL | Debit Refund failed for {debit_agent.id}. {rb_err}")
+                    self.logger.critical(f"SETTLEMENT_FATAL | Debit Refund failed for {payer.id}. {rb_err}")
 
                 return False
 
+        self.logger.debug(f"ESCROW_SUCCESS | Settled {total_debit:.2f} from {payer.id} to {len(intents)} payees.")
         return True
 
+    def settle_atomic(
+        self,
+        debit_agent: IFinancialEntity,
+        credits_list: List[Tuple[IFinancialEntity, float, str]],
+        tick: int
+    ) -> bool:
+        """
+        Wrapper around settle_escrow for backward compatibility.
+        """
+        intents: List[PaymentIntentDTO] = []
+        for payee, amount, memo in credits_list:
+            intents.append({"payee": payee, "amount": amount, "memo": memo})
+
+        return self.settle_escrow(debit_agent, intents, tick)
+
     def transfer(
         self,
         debit_agent: IFinancialEntity,
diff --git a/simulation/systems/transaction_processor.py b/simulation/systems/transaction_processor.py
index 985c9a1..c18bd14 100644
--- a/simulation/systems/transaction_processor.py
+++ b/simulation/systems/transaction_processor.py
@@ -1,12 +1,12 @@
 from __future__ import annotations
-from typing import List, Dict, Any, TYPE_CHECKING
+from typing import List, Dict, Any, TYPE_CHECKING, Optional
 import logging
 
 from simulation.models import Transaction
 from simulation.core_agents import Household, Skill
 from simulation.firms import Firm
 from simulation.systems.api import SystemInterface
-from modules.government.taxation.system import TaxationSystem, TaxIntent
+from simulation.finance.api import PaymentIntentDTO
 
 if TYPE_CHECKING:
     from simulation.agents.government import Government
@@ -23,7 +23,7 @@ class TransactionProcessor(SystemInterface):
 
     def __init__(self, config_module: Any):
         self.config_module = config_module
-        self.taxation_system = TaxationSystem(config_module)
+        # NOTE: TaxationSystem is now accessed via state.government.taxation_system
 
     def execute(self, state: SimulationState) -> None:
         """
@@ -35,12 +35,25 @@ class TransactionProcessor(SystemInterface):
         government = state.government
         current_time = state.time
 
+        if not government:
+             logger.error("TransactionProcessor: Government agent missing from state.")
+             return
+
         # WO-109: Look up inactive agents
         inactive_agents = getattr(state, "inactive_agents", {})
 
         # market_data is now in state
         goods_market_data = state.market_data.get("goods_market", {}) if state.market_data else {}
 
+        # WO-125: Enforce SettlementSystem presence (TD-101)
+        settlement = state.settlement_system
+        if not settlement:
+            raise RuntimeError("SettlementSystem is required for TransactionProcessor but is missing in SimulationState.")
+
+        taxation_system = getattr(government, 'taxation_system', None)
+        if not taxation_system:
+             logger.warning("TransactionProcessor: Government has no taxation_system. Tax logic will be skipped.")
+
         for tx in transactions:
             # WO-109: Fallback to inactive agents
             buyer = agents.get(tx.buyer_id) or inactive_agents.get(tx.buyer_id)
@@ -50,104 +63,49 @@ class TransactionProcessor(SystemInterface):
                 continue
 
             trade_value = tx.quantity * tx.price
-            sales_tax_rate = getattr(self.config_module, "SALES_TAX_RATE", 0.05)
-            tax_amount = 0.0 # Initialize for scope
+            success = False
             
             # ==================================================================
             # 1. Financial Settlement (Asset Transfer & Taxes)
             # ==================================================================
-            # WO-125: Enforce SettlementSystem presence (TD-101)
-            settlement = state.settlement_system
-            if not settlement:
-                raise RuntimeError("SettlementSystem is required for TransactionProcessor but is missing in SimulationState.")
-
-            success = False
 
             if tx.transaction_type == "lender_of_last_resort":
-                # Special Minting Logic (Handled via Settlement)
-                # Buyer (Gov) -> Seller (Bank).
+                # Special Minting Logic
                 success = settlement.transfer(buyer, seller, trade_value, "lender_of_last_resort")
                 if success and hasattr(buyer, "total_money_issued"):
                     buyer.total_money_issued += trade_value
 
             elif tx.transaction_type == "asset_liquidation":
-                # Special Minting Logic + Asset Transfer
-                # Buyer (Gov) -> Seller (Agent).
                 success = settlement.transfer(buyer, seller, trade_value, "asset_liquidation")
                 if success:
                     if hasattr(buyer, "total_money_issued"):
                         buyer.total_money_issued += trade_value
-
-                    # Asset Transfer
-                    if tx.item_id.startswith("stock_"):
-                        self._handle_stock_transaction(tx, buyer, seller, state.stock_market, state.logger, current_time)
-                    elif tx.item_id.startswith("real_estate_"):
-                        self._handle_real_estate_transaction(tx, buyer, seller, state.real_estate_units, state.logger, current_time)
+                    self._handle_asset_transfer_logic(tx, buyer, seller, state, current_time)
 
             elif tx.transaction_type == "asset_transfer":
-                 # Standard Transfer (Zero-Sum)
                  success = settlement.transfer(buyer, seller, trade_value, f"asset_transfer:{tx.item_id}")
-
-                 # Asset Transfer Logic
                  if success:
-                     if tx.item_id.startswith("stock_"):
-                         self._handle_stock_transaction(tx, buyer, seller, state.stock_market, state.logger, current_time)
-                     elif tx.item_id.startswith("real_estate_"):
-                         self._handle_real_estate_transaction(tx, buyer, seller, state.real_estate_units, state.logger, current_time)
+                     self._handle_asset_transfer_logic(tx, buyer, seller, state, current_time)
 
             elif tx.transaction_type == "escheatment":
-                 # Buyer: Agent (Deceased/Closed), Seller: Government
-                 # Direct atomic settlement to government
-                 success = settlement.settle_atomic(buyer, [(government, trade_value, "escheatment")], current_time)
-                 if success:
-                      government.record_revenue({
-                             "success": True,
-                             "amount_collected": trade_value,
-                             "tax_type": "escheatment",
+                 # Atomic settlement to government
+                 success = settlement.transfer(buyer, government, trade_value, "escheatment")
+                 # We can record this as tax revenue if needed, or rely on SettlementSystem.record_liquidation
+                 if success and taxation_system:
+                      # Manual record
+                      taxation_system.record_revenue({
                              "payer_id": buyer.id,
                              "payee_id": government.id,
-                             "error_message": None
-                         })
+                             "amount": trade_value,
+                             "tax_type": "escheatment"
+                         }, True, current_time)
 
             elif tx.transaction_type == "inheritance_distribution":
-                heir_ids = tx.metadata.get("heir_ids", []) if tx.metadata else []
-                total_cash = buyer.assets
-                if total_cash > 0 and heir_ids:
-                    import math
-                    count = len(heir_ids)
-                    # Calculate amount per heir, avoiding float precision issues (floor to cent)
-                    base_amount = math.floor((total_cash / count) * 100) / 100.0
-
-                    distributed_sum = 0.0
-                    all_success = True
-
-                    # Distribute to all but the last heir
-                    for i in range(count - 1):
-                        h_id = heir_ids[i]
-                        heir = agents.get(h_id)
-                        if heir:
-                            if settlement.transfer(buyer, heir, base_amount, "inheritance_distribution"):
-                                distributed_sum += base_amount
-                            else:
-                                all_success = False
-
-                    # Last heir gets the remainder to ensure zero-sum
-                    last_heir_id = heir_ids[-1]
-                    last_heir = agents.get(last_heir_id)
-                    if last_heir:
-                        remaining_amount = total_cash - distributed_sum
-                        # Ensure we don't transfer negative amounts or dust if something went wrong
-                        if remaining_amount > 0:
-                            if not settlement.transfer(buyer, last_heir, remaining_amount, "inheritance_distribution_final"):
-                                all_success = False
-
-                    success = all_success
+                # Keeps existing logic as it is complex 1-to-many distribution
+                success = self._handle_inheritance_distribution(tx, buyer, agents, settlement)
 
             elif tx.transaction_type == "bond_purchase":
-                # Buyer: Bank or Central Bank, Seller: Government
                 success = settlement.transfer(buyer, seller, trade_value, "bond_purchase")
-
-                # QE Check: If Buyer is Central Bank, it's money creation
                 if success and state.central_bank and buyer.id == state.central_bank.id:
                     if hasattr(government, "total_money_issued"):
                         government.total_money_issued += trade_value
@@ -157,139 +115,108 @@ class TransactionProcessor(SystemInterface):
                         )
 
             elif tx.transaction_type == "bond_repayment":
-                # Buyer: Government (Payer), Seller: Bank or Central Bank (Payee/Holder)
                 success = settlement.transfer(buyer, seller, trade_value, "bond_repayment")
-
-                # QE Reversal Check: If Seller (Recipient) is Central Bank, it's money destruction
                 if success and state.central_bank and seller.id == state.central_bank.id:
                     if hasattr(government, "total_money_destroyed"):
                         government.total_money_destroyed += trade_value
 
-            elif tx.transaction_type == "goods":
-                # Goods: Apply Sales Tax (Decoupled & Atomic)
-                intents = self.taxation_system.calculate_tax_intents(tx, buyer, seller, government, state.market_data)
-
-                credits = []
-                # 1. Main Trade Credit (Seller)
-                credits.append((seller, trade_value, f"goods_trade:{tx.item_id}"))
+            elif tx.transaction_type == "goods" or tx.transaction_type in ["labor", "research_labor"]:
+                # === ATOMIC ESCROW SETTLEMENT ===
+                payment_intents: List[PaymentIntentDTO] = []
+                tax_intents = []
 
-                # 2. Tax Credits (Government)
-                total_cost = trade_value
-                for intent in intents:
-                    credits.append((government, intent.amount, intent.reason))
-                    if intent.payer_id == buyer.id:
-                        total_cost += intent.amount
+                if taxation_system:
+                    tax_intents = taxation_system.generate_tax_intents(tx, state)
                 
-                # Solvency Check
+                # Determine Payee Logic
+                # Goods: Buyer -> Seller (Trade Value). Buyer -> Gov (Sales Tax, Add-on).
+                # Labor: Buyer -> Seller (Wage). Seller -> Gov (Income Tax, Deduction).
+
+                net_trade_value = trade_value
+
+                # Process Tax Intents
+                for ti in tax_intents:
+                    # Construct PaymentIntent for Tax
+                    # We assume ALL payments in this batch come from the Primary Payer (tx.buyer)
+                    # This enables Atomic "Withholding" / "Sales Tax collection" behavior.
+
+                    tax_payee = agents.get(ti['payee_id']) or government
+                    payment_intents.append({
+                        "payee": tax_payee,
+                        "amount": ti['amount'],
+                        "memo": ti['tax_type']
+                    })
+
+                    # Adjust Net Trade Value if the tax was supposed to be paid by Seller (Deduction)
+                    if ti['payer_id'] == seller.id:
+                        net_trade_value -= ti['amount']
+
+                    # If payer_id == buyer.id, it's an add-on, so net_trade_value remains same.
+
+                # Add Primary Trade Intent
+                payment_intents.append({
+                    "payee": seller,
+                    "amount": net_trade_value,
+                    "memo": f"{tx.transaction_type}_payment:{tx.item_id}"
+                })
+
+                # Solvency Check (Optional optimization)
+                total_cost = sum(p['amount'] for p in payment_intents)
                 if hasattr(buyer, 'check_solvency'):
                     if buyer.assets < total_cost:
                         buyer.check_solvency(government)
 
-                success = settlement.settle_atomic(buyer, credits, current_time)
+                # Execute Atomic Settlement
+                success = settlement.settle_escrow(buyer, payment_intents, current_time)
 
                 if success:
                     # Record Revenue
-                    for intent in intents:
-                        government.record_revenue({
-                             "success": True,
-                             "amount_collected": intent.amount,
-                             "tax_type": intent.reason,
-                             "payer_id": intent.payer_id,
-                             "payee_id": intent.payee_id,
-                             "error_message": None
-                        })
+                    if taxation_system:
+                        for ti in tax_intents:
+                            taxation_system.record_revenue(ti, True, current_time)
+
+                # Store tax_amount for side-effects if needed
+                # (Legacy logic used tax_amount in labor side effects)
+                tax_amount = sum(ti['amount'] for ti in tax_intents) # Total tax involved
 
             elif tx.transaction_type == "stock":
-                # Stock: NO Sales Tax
                 success = settlement.transfer(buyer, seller, trade_value, f"stock_trade:{tx.item_id}")
             
-            elif tx.transaction_type in ["labor", "research_labor"]:
-                # Labor: Apply Income Tax (Decoupled & Atomic)
-                intents = self.taxation_system.calculate_tax_intents(tx, buyer, seller, government, state.market_data)
-                
-                credits = []
-                seller_net_amount = trade_value
-
-                for intent in intents:
-                    credits.append((government, intent.amount, intent.reason))
-                    if intent.payer_id == seller.id:
-                        # If Seller (Worker) pays, deduct from their receipt (Withholding)
-                        seller_net_amount -= intent.amount
-                        tax_amount = intent.amount
-                    elif intent.payer_id == buyer.id:
-                        # If Buyer (Firm) pays, it's extra cost
-                        pass
-                
-                # Update tax_amount for later side-effects logic (Step 2)
-                # If no intents, tax_amount remains 0.0 (from scope start) or we should set it?
-                # The original code relied on tax_amount being set here.
-                # If intents exist, we sum them up or pick specific one?
-                # Usually only one income tax intent.
-                if intents:
-                    tax_amount = sum(i.amount for i in intents)
-                else:
-                    tax_amount = 0.0
-
-                credits.append((seller, seller_net_amount, f"labor_wage:{tx.transaction_type}"))
-
-                success = settlement.settle_atomic(buyer, credits, current_time)
-
-                if success:
-                    # Record Revenue
-                    for intent in intents:
-                        government.record_revenue({
-                             "success": True,
-                             "amount_collected": intent.amount,
-                             "tax_type": intent.reason,
-                             "payer_id": intent.payer_id,
-                             "payee_id": intent.payee_id,
-                             "error_message": None
-                        })
-            
             elif tx.item_id == "interest_payment":
                 success = settlement.transfer(buyer, seller, trade_value, "interest_payment")
-
                 if success and isinstance(buyer, Firm):
                     buyer.finance.record_expense(trade_value)
 
             elif tx.transaction_type == "dividend":
                 success = settlement.transfer(seller, buyer, trade_value, "dividend_payment")
-
                 if success and isinstance(buyer, Household) and hasattr(buyer, "capital_income_this_tick"):
                     buyer.capital_income_this_tick += trade_value
+
             elif tx.transaction_type == "tax":
-                # Direct atomic settlement to government
-                success = settlement.settle_atomic(buyer, [(government, trade_value, tx.item_id)], current_time)
-                if success:
-                      government.record_revenue({
-                             "success": True,
-                             "amount_collected": trade_value,
-                             "tax_type": tx.item_id,
+                # Direct transfer
+                success = settlement.transfer(buyer, government, trade_value, tx.item_id)
+                if success and taxation_system:
+                      taxation_system.record_revenue({
                              "payer_id": buyer.id,
                              "payee_id": government.id,
-                             "error_message": None
-                         })
+                             "amount": trade_value,
+                             "tax_type": tx.item_id
+                         }, True, current_time)
+
             elif tx.transaction_type == "infrastructure_spending":
-                # Standard Transfer (Gov -> Reflux)
                 success = settlement.transfer(buyer, seller, trade_value, "infrastructure_spending")
 
             elif tx.transaction_type == "emergency_buy":
-                # Fast Purchase (Buyer -> Reflux/System)
-                # No Sales Tax, Immediate Inventory Update
                 success = settlement.transfer(buyer, seller, trade_value, "emergency_buy")
-
                 if success:
                     buyer.inventory[tx.item_id] = buyer.inventory.get(tx.item_id, 0.0) + tx.quantity
 
             elif tx.transaction_type in ["credit_creation", "credit_destruction"]:
-                # WO-024: Symbolic Monetary Policy Transactions.
-                # These are accounting records for the Government and are processed in Phase3
-                # via `government.process_monetary_transactions`.
-                # They MUST NOT be executed as real financial transfers here to avoid double counting.
+                # Symbolic
                 success = True
 
             else:
-                # Default / Other
+                # Default
                 success = settlement.transfer(buyer, seller, trade_value, f"generic:{tx.transaction_type}")
 
             # WO-109: Apply Deferred Effects only on Success
@@ -301,7 +228,11 @@ class TransactionProcessor(SystemInterface):
             # ==================================================================
             if success:
                 if tx.transaction_type in ["labor", "research_labor"]:
-                    self._handle_labor_transaction(tx, buyer, seller, trade_value, tax_amount, agents)
+                    # We need tax_amount here. In 'goods/labor' block we calculated it.
+                    # If transaction type matched that block, tax_amount is set.
+                    # Otherwise (unlikely for labor), default to 0.
+                    t_amt = locals().get('tax_amount', 0.0)
+                    self._handle_labor_transaction(tx, buyer, seller, trade_value, t_amt, agents)
 
                 elif tx.transaction_type == "goods":
                     self._handle_goods_transaction(tx, buyer, seller, trade_value, current_time)
@@ -309,15 +240,46 @@ class TransactionProcessor(SystemInterface):
                 elif tx.transaction_type == "stock":
                     self._handle_stock_transaction(tx, buyer, seller, state.stock_market, state.logger, current_time)
 
-                elif tx.transaction_type == "housing" or (hasattr(tx, "market_id") and tx.market_id == "housing"):
-                    pass
+    def _handle_asset_transfer_logic(self, tx, buyer, seller, state, current_time):
+        if tx.item_id.startswith("stock_"):
+            self._handle_stock_transaction(tx, buyer, seller, state.stock_market, state.logger, current_time)
+        elif tx.item_id.startswith("real_estate_"):
+            self._handle_real_estate_transaction(tx, buyer, seller, state.real_estate_units, state.logger, current_time)
+
+    def _handle_inheritance_distribution(self, tx, buyer, agents, settlement):
+        heir_ids = tx.metadata.get("heir_ids", []) if tx.metadata else []
+        total_cash = buyer.assets
+        if total_cash > 0 and heir_ids:
+            import math
+            count = len(heir_ids)
+            base_amount = math.floor((total_cash / count) * 100) / 100.0
+            distributed_sum = 0.0
+            all_success = True
+
+            for i in range(count - 1):
+                h_id = heir_ids[i]
+                heir = agents.get(h_id)
+                if heir:
+                    if settlement.transfer(buyer, heir, base_amount, "inheritance_distribution"):
+                        distributed_sum += base_amount
+                    else:
+                        all_success = False
+
+            last_heir_id = heir_ids[-1]
+            last_heir = agents.get(last_heir_id)
+            if last_heir:
+                remaining_amount = total_cash - distributed_sum
+                if remaining_amount > 0:
+                    if not settlement.transfer(buyer, last_heir, remaining_amount, "inheritance_distribution_final"):
+                        all_success = False
+            return all_success
+        return False
 
     def _handle_labor_transaction(self, tx: Transaction, buyer: Any, seller: Any, trade_value: float, tax_amount: float, agents: Dict[int, Any]):
         if isinstance(seller, Household):
             if seller.is_employed and seller.employer_id is not None and seller.employer_id != buyer.id:
                 previous_employer = agents.get(seller.employer_id)
                 if isinstance(previous_employer, Firm):
-                    # SoC Refactor: Use HRDepartment
                     previous_employer.hr.remove_employee(seller)
 
             seller.is_employed = True
@@ -325,15 +287,16 @@ class TransactionProcessor(SystemInterface):
             seller.current_wage = tx.price
             seller.needs["labor_need"] = 0.0
             if hasattr(seller, "labor_income_this_tick"):
+                # Net income
                 seller.labor_income_this_tick += (trade_value - tax_amount)
 
         if isinstance(buyer, Firm):
-            # SoC Refactor: Use HRDepartment and FinanceDepartment
             if seller not in buyer.hr.employees:
                 buyer.hr.hire(seller, tx.price)
             else:
                  buyer.hr.employee_wages[seller.id] = tx.price
 
+            # Expense is Gross
             buyer.finance.record_expense(trade_value)
 
             if tx.transaction_type == "research_labor":
@@ -364,11 +327,8 @@ class TransactionProcessor(SystemInterface):
                 buyer.inventory[tx.item_id] = total_new_qty
 
         if isinstance(seller, Firm):
-            # SoC Refactor: Use FinanceDepartment
             seller.finance.record_revenue(trade_value)
             seller.finance.sales_volume_this_tick += tx.quantity
-
-            # WO-157: Record Sale for Velocity Tracking
             if hasattr(seller, 'record_sale'):
                 seller.record_sale(tx.item_id, tx.quantity, current_time)
         
@@ -379,18 +339,15 @@ class TransactionProcessor(SystemInterface):
                     buyer.current_food_consumption += tx.quantity
 
     def _handle_real_estate_transaction(self, tx: Transaction, buyer: Any, seller: Any, real_estate_units: List[Any], logger: Any, current_time: int):
-        # item_id = "real_estate_{id}"
         try:
             unit_id = int(tx.item_id.split("_")[2])
             unit = next((u for u in real_estate_units if u.id == unit_id), None)
             if unit:
                 unit.owner_id = buyer.id
-                # Update seller/buyer lists if they exist
                 if hasattr(seller, "owned_properties") and unit_id in seller.owned_properties:
                     seller.owned_properties.remove(unit_id)
                 if hasattr(buyer, "owned_properties"):
                     buyer.owned_properties.append(unit_id)
-
                 if logger:
                     logger.info(f"RE_TX | Unit {unit_id} transferred from {seller.id} to {buyer.id}")
         except (IndexError, ValueError) as e:
@@ -399,8 +356,6 @@ class TransactionProcessor(SystemInterface):
 
     def _handle_stock_transaction(self, tx: Transaction, buyer: Any, seller: Any, stock_market: Any, logger: Any, current_time: int):
         firm_id = int(tx.item_id.split("_")[1])
-        
-        # 1. Update Holdings
         if isinstance(seller, Household):
             current_shares = seller.shares_owned.get(firm_id, 0)
             seller.shares_owned[firm_id] = max(0, current_shares - tx.quantity)
@@ -411,26 +366,20 @@ class TransactionProcessor(SystemInterface):
         elif isinstance(seller, Firm) and seller.id == firm_id:
             seller.treasury_shares = max(0, seller.treasury_shares - tx.quantity)
         elif hasattr(seller, "portfolio"):
-            # Secondary market trade for Firms/Institutions if they have portfolio
             seller.portfolio.remove(firm_id, tx.quantity)
         
         if isinstance(buyer, Household):
             buyer.shares_owned[firm_id] = buyer.shares_owned.get(firm_id, 0) + tx.quantity
             if hasattr(buyer, "portfolio"):
                 buyer.portfolio.add(firm_id, tx.quantity, tx.price)
-                # Sync legacy dict
                 buyer.shares_owned[firm_id] = buyer.portfolio.holdings[firm_id].quantity
         elif isinstance(buyer, Firm) and buyer.id == firm_id:
             buyer.treasury_shares += tx.quantity
             buyer.total_shares -= tx.quantity
 
-        # 2. Sync Market Shareholder Registry (CRITICAL for Dividends)
         if stock_market:
-            # Sync Buyer
             if hasattr(buyer, "portfolio") and firm_id in buyer.portfolio.holdings:
                  stock_market.update_shareholder(buyer.id, firm_id, buyer.portfolio.holdings[firm_id].quantity)
-
-            # Sync Seller
             if hasattr(seller, "portfolio") and firm_id in seller.portfolio.holdings:
                 stock_market.update_shareholder(seller.id, firm_id, seller.portfolio.holdings[firm_id].quantity)
             else:
diff --git a/tests/test_taxation_atomic.py b/tests/test_taxation_atomic.py
new file mode 100644
index 0000000..d12caa6
--- /dev/null
+++ b/tests/test_taxation_atomic.py
@@ -0,0 +1,269 @@
+import pytest
+from unittest.mock import MagicMock, Mock
+from typing import List, Dict, Any
+
+from modules.government.taxation.system import TaxationSystem
+from simulation.systems.settlement_system import SettlementSystem
+from simulation.systems.transaction_processor import TransactionProcessor
+from simulation.models import Transaction
+from simulation.finance.api import PaymentIntentDTO, IFinancialEntity
+from modules.finance.api import InsufficientFundsError
+from modules.government.taxation.api import TaxIntentDTO
+
+# --- Mocks ---
+
+class MockEntity:
+    def __init__(self, id, assets=0.0):
+        self.id = id
+        self._assets = float(assets)
+        self.fail_deposit = False
+        self.inventory = {}
+        self.inventory_quality = {}
+        self.shares_owned = {}
+        self.check_solvency_called = False
+
+    @property
+    def assets(self):
+        return self._assets
+
+    def deposit(self, amount):
+        if self.fail_deposit:
+            raise Exception("Deposit failed!")
+        self._assets += amount
+
+    def withdraw(self, amount):
+        if self._assets < amount:
+            raise InsufficientFundsError(f"Insufficient funds: {self._assets} < {amount}")
+        self._assets -= amount
+
+    def check_solvency(self, government):
+        pass
+
+class MockGovernment(MockEntity):
+    def __init__(self, id, assets=0.0):
+        super().__init__(id, assets)
+        self.taxation_system = None
+        self.income_tax_rate = 0.1
+        self.corporate_tax_rate = 0.2
+
+class MockConfig:
+    SALES_TAX_RATE = 0.10
+    TAX_MODE = "PROGRESSIVE"
+    TAX_BRACKETS = []
+    TAX_RATE_BASE = 0.1
+    HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK = 1.0
+    GOODS_INITIAL_PRICE = {"basic_food": 5.0}
+    INCOME_TAX_PAYER = "FIRM" # Default
+    GOODS = {}
+    RAW_MATERIAL_SECTORS = []
+    RND_PRODUCTIVITY_MULTIPLIER = 1.0
+
+class MockState:
+    def __init__(self):
+        self.transactions = []
+        self.agents = {}
+        self.government = None
+        self.settlement_system = None
+        self.market_data = {}
+        self.time = 0
+        self.logger = MagicMock()
+        self.stock_market = None
+        self.real_estate_units = []
+        self.effects_queue = []
+
+# --- Tests ---
+
+def test_taxation_calculation():
+    config = MockConfig()
+    tax_system = TaxationSystem(config)
+
+    gov = MockGovernment(id=999)
+    buyer = MockEntity(id=1, assets=1000)
+    seller = MockEntity(id=2, assets=1000)
+
+    state = MockState()
+    state.government = gov
+    state.agents = {1: buyer, 2: seller}
+
+    # Test Goods (Sales Tax)
+    tx = Transaction(buyer_id=1, seller_id=2, item_id="apple", quantity=10, price=10.0,
+                     market_id="goods", transaction_type="goods", time=1)
+    # Trade Value = 100. Tax Rate = 0.10. Tax = 10.
+
+    intents = tax_system.generate_tax_intents(tx, state)
+    assert len(intents) == 1
+    assert intents[0]['payer_id'] == 1
+    assert intents[0]['payee_id'] == 999
+    assert intents[0]['amount'] == 10.0
+    assert intents[0]['tax_type'] == "sales_tax_goods"
+
+def test_settlement_atomic_success():
+    settlement = SettlementSystem()
+    payer = MockEntity(id=1, assets=200.0)
+    payee1 = MockEntity(id=2, assets=0.0)
+    payee2 = MockEntity(id=3, assets=0.0)
+
+    intents: List[PaymentIntentDTO] = [
+        {"payee": payee1, "amount": 100.0, "memo": "payment1"},
+        {"payee": payee2, "amount": 50.0, "memo": "payment2"}
+    ]
+
+    success = settlement.settle_escrow(payer, intents, tick=1)
+
+    assert success is True
+    assert payer.assets == 50.0 # 200 - 150
+    assert payee1.assets == 100.0
+    assert payee2.assets == 50.0
+
+def test_settlement_atomic_rollback():
+    settlement = SettlementSystem()
+    payer = MockEntity(id=1, assets=200.0)
+    payee1 = MockEntity(id=2, assets=0.0)
+    payee2 = MockEntity(id=3, assets=0.0)
+    payee2.fail_deposit = True # Trigger failure
+
+    intents: List[PaymentIntentDTO] = [
+        {"payee": payee1, "amount": 100.0, "memo": "payment1"},
+        {"payee": payee2, "amount": 50.0, "memo": "payment2"} # This will fail
+    ]
+
+    success = settlement.settle_escrow(payer, intents, tick=1)
+
+    assert success is False
+    assert payer.assets == 200.0 # Fully restored
+    assert payee1.assets == 0.0 # Rolled back
+    assert payee2.assets == 0.0 # Failed
+
+def test_transaction_processor_goods_flow():
+    config = MockConfig()
+
+    gov = MockGovernment(id=999, assets=0.0)
+    tax_system = TaxationSystem(config)
+    gov.taxation_system = tax_system
+
+    settlement = SettlementSystem()
+
+    tp = TransactionProcessor(config)
+
+    buyer = MockEntity(id=1, assets=200.0)
+    seller = MockEntity(id=2, assets=0.0)
+
+    state = MockState()
+    state.government = gov
+    state.settlement_system = settlement
+    state.agents = {1: buyer, 2: seller}
+    state.time = 1
+
+    tx = Transaction(buyer_id=1, seller_id=2, item_id="apple", quantity=10, price=10.0,
+                     market_id="goods", transaction_type="goods", time=1)
+    state.transactions = [tx]
+
+    tp.execute(state)
+
+    # Verify Financials
+    # Trade: 100. Tax: 10 (10%). Total Cost: 110.
+    assert buyer.assets == 90.0 # 200 - 110
+    assert seller.assets == 100.0
+
+    # Verify Tax Revenue Ledger
+    assert tax_system.tax_revenue_ledger.get("sales_tax_goods") == 10.0
+
+    # Verify Government Access
+    tick_revenue = tax_system.get_tick_revenue(1)
+    assert tick_revenue["sales_tax_goods"] == 10.0
+
+def test_transaction_processor_labor_flow_withholding():
+    config = MockConfig()
+    config.INCOME_TAX_PAYER = "FIRM" # Withholding
+
+    gov = MockGovernment(id=999, assets=0.0)
+    tax_system = TaxationSystem(config)
+    gov.taxation_system = tax_system
+
+    settlement = SettlementSystem()
+
+    tp = TransactionProcessor(config)
+
+    firm = MockEntity(id=1, assets=200.0) # Buyer of Labor
+    worker = MockEntity(id=2, assets=0.0) # Seller of Labor
+
+    state = MockState()
+    state.government = gov
+    state.settlement_system = settlement
+    state.agents = {1: firm, 2: worker}
+
+    # Labor Transaction
+    tx = Transaction(buyer_id=1, seller_id=2, item_id="labor_hours", quantity=1, price=100.0,
+                     market_id="labor", transaction_type="labor", time=1)
+    state.transactions = [tx]
+
+    # Gov Income Tax Rate is 0.1 (10%)
+    # Tax = 10.0.
+    # Payer is Firm (INCOME_TAX_PAYER="FIRM").
+    # Intent: Firm -> Gov (10.0).
+    # Logic in TP:
+    #   Net Trade Value = 100 (Price) - 0 (Deduction from Seller) = 100?
+    #   Wait, if Payer is Firm, it is an "Add-on" cost or "Deduction"?
+    #   Usually Wage is Gross. Firm pays Gross.
+    #   If Payer is Firm, it means Firm pays Tax ON TOP of Wage? Or Firm pays Tax FROM Wage?
+    #   In `TaxationSystem`:
+    #   if tax_payer_type == "FIRM": payer_id = buyer.id
+    #   If Firm pays, it's usually Employer Payroll Tax (on top).
+    #   If Worker pays (but withheld), payer_id is Worker (Seller).
+
+    # Let's verify TP logic:
+    # if ti['payer_id'] == seller.id: net_trade_value -= ti['amount']
+
+    # Case A: Payroll Tax (Firm Pays). ti['payer_id'] == buyer.id.
+    #   net_trade_value = 100.
+    #   Tax Intent = 10 (Firm -> Gov).
+    #   Total Firm Pay = 110. Worker gets 100. Gov gets 10.
+
+    tp.execute(state)
+
+    # Taxable = 100 - 10 (Survival Cost) = 90. Tax = 9.0.
+    # Total Cost = 100 + 9 = 109.
+    assert firm.assets == 91.0 # 200 - 109
+    assert worker.assets == 100.0
+    assert tax_system.tax_revenue_ledger.get("income_tax_firm") == 9.0
+
+def test_transaction_processor_labor_flow_worker_pays():
+    config = MockConfig()
+    config.INCOME_TAX_PAYER = "HOUSEHOLD" # Worker pays (Withholding logic in TP)
+
+    gov = MockGovernment(id=999, assets=0.0)
+    tax_system = TaxationSystem(config)
+    gov.taxation_system = tax_system
+
+    settlement = SettlementSystem()
+
+    tp = TransactionProcessor(config)
+
+    firm = MockEntity(id=1, assets=200.0)
+    worker = MockEntity(id=2, assets=0.0)
+
+    state = MockState()
+    state.government = gov
+    state.settlement_system = settlement
+    state.agents = {1: firm, 2: worker}
+
+    tx = Transaction(buyer_id=1, seller_id=2, item_id="labor_hours", quantity=1, price=100.0,
+                     market_id="labor", transaction_type="labor", time=1)
+    state.transactions = [tx]
+
+    # Logic:
+    # Tax = 10.
+    # Payer = Seller (Worker).
+    # TP Logic:
+    #   if ti['payer_id'] == seller.id: net_trade_value -= ti['amount']
+    #   net_trade_value = 100 - 10 = 90.
+    #   Tax Intent: Firm -> Gov (10). (Constructed in TP loop)
+    #   Firm pays 90 to Worker, 10 to Gov. Total 100.
+
+    tp.execute(state)
+
+    # Tax = 9.0.
+    # Net Wage = 100 - 9 = 91.
+    assert firm.assets == 100.0 # 200 - 100.
+    assert worker.assets == 91.0 # Received Net Wage
+    assert tax_system.tax_revenue_ledger.get("income_tax_household") == 9.0
diff --git a/tests/unit/test_taxation_system.py b/tests/unit/test_taxation_system.py
index 107f5b3..665b75d 100644
--- a/tests/unit/test_taxation_system.py
+++ b/tests/unit/test_taxation_system.py
@@ -1,6 +1,7 @@
 import pytest
 from unittest.mock import MagicMock, Mock
-from modules.government.taxation.system import TaxationSystem, TaxIntent
+from modules.government.taxation.system import TaxationSystem
+from modules.government.taxation.api import TaxIntentDTO
 
 @pytest.fixture
 def config_module():
@@ -21,6 +22,8 @@ def taxation_system(config_module):
 def test_sales_tax_calculation(taxation_system, config_module):
     # Setup
     tx = Mock()
+    tx.buyer_id = 1
+    tx.seller_id = 2
     tx.transaction_type = "goods"
     tx.quantity = 10
     tx.price = 10.0 # Trade Value = 100
@@ -32,22 +35,29 @@ def test_sales_tax_calculation(taxation_system, config_module):
     government = Mock()
     government.id = 99
 
+    state = Mock()
+    state.agents = {1: buyer, 2: seller}
+    state.government = government
+    state.market_data = {}
+
     # Execute
-    intents = taxation_system.calculate_tax_intents(tx, buyer, seller, government)
+    intents = taxation_system.generate_tax_intents(tx, state)
 
     # Verify
     assert len(intents) == 1
     intent = intents[0]
-    assert intent.payer_id == buyer.id
-    assert intent.payee_id == government.id
-    assert intent.amount == 100 * 0.05 # 5.0
-    assert "sales_tax" in intent.reason
+    assert intent['payer_id'] == buyer.id
+    assert intent['payee_id'] == government.id
+    assert intent['amount'] == 100 * 0.05 # 5.0
+    assert "sales_tax" in intent['tax_type']
 
 def test_income_tax_household_payer(taxation_system, config_module):
     # Setup
     config_module.INCOME_TAX_PAYER = "HOUSEHOLD"
 
     tx = Mock()
+    tx.buyer_id = 10
+    tx.seller_id = 20
     tx.transaction_type = "labor"
     tx.quantity = 1
     tx.price = 100.0
@@ -61,21 +71,28 @@ def test_income_tax_household_payer(taxation_system, config_module):
     government.id = 99
     government.income_tax_rate = 0.1
 
+    state = Mock()
+    state.agents = {10: buyer, 20: seller}
+    state.government = government
+    state.market_data = {}
+
     # Execute
-    intents = taxation_system.calculate_tax_intents(tx, buyer, seller, government)
+    intents = taxation_system.generate_tax_intents(tx, state)
 
     # Verify
     assert len(intents) == 1
     intent = intents[0]
-    assert intent.payer_id == seller.id # Household pays
-    assert intent.amount == 100.0 * 0.1 # 10.0 (Flat rate mocked)
-    assert intent.reason == "income_tax_household"
+    assert intent['payer_id'] == seller.id # Household pays
+    assert intent['amount'] == 100.0 * 0.1 # 10.0 (Flat rate mocked)
+    assert intent['tax_type'] == "income_tax_household"
 
 def test_income_tax_firm_payer(taxation_system, config_module):
     # Setup
     config_module.INCOME_TAX_PAYER = "FIRM"
 
     tx = Mock()
+    tx.buyer_id = 10
+    tx.seller_id = 20
     tx.transaction_type = "labor"
     tx.quantity = 1
     tx.price = 100.0
@@ -89,18 +106,25 @@ def test_income_tax_firm_payer(taxation_system, config_module):
     government.id = 99
     government.income_tax_rate = 0.1
 
+    state = Mock()
+    state.agents = {10: buyer, 20: seller}
+    state.government = government
+    state.market_data = {}
+
     # Execute
-    intents = taxation_system.calculate_tax_intents(tx, buyer, seller, government)
+    intents = taxation_system.generate_tax_intents(tx, state)
 
     # Verify
     assert len(intents) == 1
     intent = intents[0]
-    assert intent.payer_id == buyer.id # Firm pays
-    assert intent.amount == 100.0 * 0.1
-    assert intent.reason == "income_tax_firm"
+    assert intent['payer_id'] == buyer.id # Firm pays
+    assert intent['amount'] == 100.0 * 0.1
+    assert intent['tax_type'] == "income_tax_firm"
 
 def test_escheatment(taxation_system):
     tx = Mock()
+    tx.buyer_id = 666
+    tx.seller_id = 99
     tx.transaction_type = "escheatment"
     tx.quantity = 1
     tx.price = 500.0
@@ -111,11 +135,16 @@ def test_escheatment(taxation_system):
     government = Mock()
     government.id = 99
 
-    intents = taxation_system.calculate_tax_intents(tx, buyer, seller, government)
+    state = Mock()
+    state.agents = {666: buyer}
+    state.government = government
+    state.market_data = {}
+
+    intents = taxation_system.generate_tax_intents(tx, state)
 
     assert len(intents) == 1
     intent = intents[0]
-    assert intent.payer_id == buyer.id
-    assert intent.payee_id == government.id
-    assert intent.amount == 500.0
-    assert intent.reason == "escheatment"
+    assert intent['payer_id'] == buyer.id
+    assert intent['payee_id'] == government.id
+    assert intent['amount'] == 500.0
+    assert intent['tax_type'] == "escheatment"
