diff --git a/communications/insights/TD-066_Household_Engine_Decomposition.md b/communications/insights/TD-066_Household_Engine_Decomposition.md
new file mode 100644
index 0000000..2ead71c
--- /dev/null
+++ b/communications/insights/TD-066_Household_Engine_Decomposition.md
@@ -0,0 +1,21 @@
+# TD-066: Household Engine Decomposition & Survival Logic Migration
+
+## Context
+The `AIDrivenHouseholdDecisionEngine` was previously a monolithic class containing logic for consumption, labor, investment, and housing. It has been partially refactored into specialized managers (`ConsumptionManager`, `LaborManager`, etc.), but the "Phase 2: Survival Override" logic (panic buying food when starving) remained in the coordinator engine.
+
+## Problem
+The persistence of the Survival Override logic in the engine violates the Single Responsibility Principle and the Coordinator Pattern. The engine should strictly orchestrate, while domain logic should reside in managers. Specifically, the logic for deciding *what* to buy (even in emergencies) belongs to the `ConsumptionManager`.
+
+## Solution
+1.  **Decomposition**: Move the Survival Override logic into `ConsumptionManager.check_survival_override()`.
+2.  **Delegation**: The engine will delegate this check to the manager before proceeding with the standard AI-driven flow.
+3.  **Encapsulation**: This completes the extraction of consumption-related decision logic from the engine.
+
+## Impact
+- Reduces complexity of `ai_driven_household_engine.py` (further).
+- Centralizes all consumption logic (routine and emergency) in `ConsumptionManager`.
+- Improves testability of the survival logic.
+
+## Technical Debt / Risks
+- **Dependency on `HouseholdActionVector`**: The `ConsumptionManager` now needs to be aware of `HouseholdActionVector` to return the appropriate override signal. This creates a slight coupling to the schema used by the AI engine, but it is necessary for the override mechanism.
+- **Context Handling**: The `check_survival_override` method requires raw arguments instead of `ConsumptionContext` because it runs *before* the `action_vector` (required by `ConsumptionContext`) is generated. This introduces a slight inconsistency in method signatures within `ConsumptionManager`. Future refactoring could introduce a `PreDecisionContext`.
diff --git a/simulation/decisions/ai_driven_household_engine.py b/simulation/decisions/ai_driven_household_engine.py
index d8a10e2..ad72ae1 100644
--- a/simulation/decisions/ai_driven_household_engine.py
+++ b/simulation/decisions/ai_driven_household_engine.py
@@ -67,48 +67,13 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
         current_time = context.current_time
 
         # --- Phase 2: Survival Override ---
-        survival_need = household.needs.get('survival', 0)
-        emergency_threshold = getattr(config, 'survival_need_emergency_threshold', 0.8)
-        if not isinstance(emergency_threshold, (int, float)):
-            emergency_threshold = 0.8
-
-        if survival_need > emergency_threshold:
-            food_id = getattr(config, 'primary_survival_good_id', 'food')
-            if not isinstance(food_id, str):
-                food_id = 'food'
-
-            signal = None
-            if market_snapshot and 'market_signals' in market_snapshot:
-                 signal = market_snapshot['market_signals'].get(food_id)
-
-            # If signal exists and has sellers
-            if signal and signal.get('best_ask') is not None:
-                ask_price = signal['best_ask']
-                # Affordability Check
-                if household.assets >= ask_price:
-                     premium = getattr(config, 'survival_bid_premium', 0.1)
-                     if not isinstance(premium, (int, float)):
-                         premium = 0.1
-                     bid_price = ask_price * (1 + premium)
-
-                     self.logger.warning(
-                         f"SURVIVAL_OVERRIDE | Agent {household.id} critical need {survival_need:.2f}. Panic buying {food_id} at {bid_price:.2f}",
-                         extra={"agent_id": household.id, "tick": current_time, "tags": ["survival", "override"]}
-                     )
-
-                     survival_order = Order(
-                         agent_id=household.id,
-                         item_id=food_id,
-                         order_type="BUY",
-                         quantity=1.0,
-                         price=bid_price,
-                         market_id=food_id
-                     )
-
-                     # Return immediately, skipping other logic
-                     from simulation.schemas import HouseholdActionVector
-                     # We return a vector with high work aggressiveness as survival instinct implies working hard too
-                     return [survival_order], HouseholdActionVector(work_aggressiveness=1.0)
+        # Delegated to ConsumptionManager
+        survival_override_result = self.consumption_manager.check_survival_override(
+            household, config, market_snapshot, current_time, self.logger
+        )
+
+        if survival_override_result:
+            return survival_override_result
 
         agent_data = household.agent_data
 
diff --git a/simulation/decisions/household/consumption_manager.py b/simulation/decisions/household/consumption_manager.py
index 11b05ec..d29c2cb 100644
--- a/simulation/decisions/household/consumption_manager.py
+++ b/simulation/decisions/household/consumption_manager.py
@@ -1,7 +1,8 @@
-from typing import List, Any, Optional
+from typing import List, Any, Optional, Tuple
 import random
 from simulation.models import Order
 from simulation.decisions.household.api import ConsumptionContext
+from simulation.schemas import HouseholdActionVector
 
 class ConsumptionManager:
     """
@@ -9,6 +10,64 @@ class ConsumptionManager:
     Refactored from AIDrivenHouseholdDecisionEngine.
     """
 
+    def check_survival_override(
+        self,
+        household: Any,
+        config: Any,
+        market_snapshot: Any,
+        current_time: int,
+        logger: Optional[Any]
+    ) -> Optional[Tuple[List[Order], HouseholdActionVector]]:
+        """
+        Phase 2: Survival Override.
+        Checks if critical needs exceed threshold and triggers panic buying.
+        """
+        survival_need = household.needs.get('survival', 0)
+        emergency_threshold = getattr(config, 'survival_need_emergency_threshold', 0.8)
+        if not isinstance(emergency_threshold, (int, float)):
+            emergency_threshold = 0.8
+
+        if survival_need > emergency_threshold:
+            food_id = getattr(config, 'primary_survival_good_id', 'food')
+            if not isinstance(food_id, str):
+                food_id = 'food'
+
+            signal = None
+            if market_snapshot and isinstance(market_snapshot, dict) and 'market_signals' in market_snapshot:
+                 signal = market_snapshot['market_signals'].get(food_id)
+            # Handle object-based market_snapshot if necessary (though engine used dict access logic)
+            # Assuming consistency with engine logic for now.
+
+            # If signal exists and has sellers
+            if signal and signal.get('best_ask') is not None:
+                ask_price = signal['best_ask']
+                # Affordability Check
+                if household.assets >= ask_price:
+                     premium = getattr(config, 'survival_bid_premium', 0.1)
+                     if not isinstance(premium, (int, float)):
+                         premium = 0.1
+                     bid_price = ask_price * (1 + premium)
+
+                     if logger:
+                         logger.warning(
+                             f"SURVIVAL_OVERRIDE | Agent {household.id} critical need {survival_need:.2f}. Panic buying {food_id} at {bid_price:.2f}",
+                             extra={"agent_id": household.id, "tick": current_time, "tags": ["survival", "override"]}
+                         )
+
+                     survival_order = Order(
+                         agent_id=household.id,
+                         side="BUY",
+                         item_id=food_id,
+                         quantity=1.0,
+                         price_limit=bid_price,
+                         market_id=food_id
+                     )
+
+                     # Return immediately, skipping other logic
+                     # We return a vector with high work aggressiveness as survival instinct implies working hard too
+                     return [survival_order], HouseholdActionVector(work_aggressiveness=1.0)
+        return None
+
     def decide_consumption(self, context: ConsumptionContext) -> List[Order]:
         orders = []
         household = context.household
diff --git a/tests/unit/test_consumption_manager_survival.py b/tests/unit/test_consumption_manager_survival.py
new file mode 100644
index 0000000..c2273ff
--- /dev/null
+++ b/tests/unit/test_consumption_manager_survival.py
@@ -0,0 +1,100 @@
+import pytest
+from unittest.mock import Mock, MagicMock
+from simulation.decisions.household.consumption_manager import ConsumptionManager
+from simulation.models import Order
+from simulation.schemas import HouseholdActionVector
+from tests.unit.factories import create_household_dto
+from tests.utils.factories import create_household_config_dto
+from simulation.ai.api import Personality
+
+@pytest.fixture
+def manager():
+    return ConsumptionManager()
+
+@pytest.fixture
+def mock_logger():
+    return MagicMock()
+
+@pytest.fixture
+def base_household():
+    return create_household_dto(
+        id=1,
+        assets=100.0,
+        needs={"survival": 0.5},
+        is_employed=False,
+        current_wage=0.0,
+        wage_modifier=1.0,
+        personality=Personality.BALANCED
+    )
+
+@pytest.fixture
+def base_config():
+    config = Mock()
+    config.survival_need_emergency_threshold = 0.8
+    config.primary_survival_good_id = "basic_food"
+    config.survival_bid_premium = 0.1
+    return config
+
+class TestConsumptionManagerSurvival:
+    def test_check_survival_override_no_emergency(self, manager, base_household, base_config, mock_logger):
+        # Survival need 0.5 < threshold 0.8
+        base_household.needs["survival"] = 0.5
+        market_snapshot = {}
+
+        result = manager.check_survival_override(base_household, base_config, market_snapshot, 1, mock_logger)
+
+        assert result is None
+
+    def test_check_survival_override_emergency_triggered(self, manager, base_household, base_config, mock_logger):
+        # Survival need 0.9 > threshold 0.8
+        base_household.needs["survival"] = 0.9
+
+        # Market signal
+        market_snapshot = {
+            "market_signals": {
+                "basic_food": {"best_ask": 10.0}
+            }
+        }
+
+        # Assets sufficient (100.0 > 10.0 * 1.1)
+        base_household.assets = 100.0
+
+        result = manager.check_survival_override(base_household, base_config, market_snapshot, 1, mock_logger)
+
+        assert result is not None
+        orders, vector = result
+
+        assert isinstance(orders, list)
+        assert len(orders) == 1
+        assert orders[0].item_id == "basic_food"
+        assert orders[0].side == "BUY"
+        # Price = 10.0 * 1.1 = 11.0
+        assert orders[0].price_limit == pytest.approx(11.0)
+
+        assert isinstance(vector, HouseholdActionVector)
+        assert vector.work_aggressiveness == 1.0
+
+    def test_check_survival_override_emergency_triggered_insufficient_funds(self, manager, base_household, base_config, mock_logger):
+        base_household.needs["survival"] = 0.9
+
+        market_snapshot = {
+            "market_signals": {
+                "basic_food": {"best_ask": 200.0} # Too expensive
+            }
+        }
+        base_household.assets = 100.0
+
+        result = manager.check_survival_override(base_household, base_config, market_snapshot, 1, mock_logger)
+
+        assert result is None
+
+    def test_check_survival_override_no_signal(self, manager, base_household, base_config, mock_logger):
+        base_household.needs["survival"] = 0.9
+
+        market_snapshot = {
+            "market_signals": {} # No basic_food
+        }
+
+        result = manager.check_survival_override(base_household, base_config, market_snapshot, 1, mock_logger)
+
+        assert result is None
