diff --git a/communications/insights/TD-255_Cockpit_Event_Refactoring.md b/communications/insights/TD-255_Cockpit_Event_Refactoring.md
new file mode 100644
index 00000000..48678a2d
--- /dev/null
+++ b/communications/insights/TD-255_Cockpit_Event_Refactoring.md
@@ -0,0 +1,28 @@
+# Technical Insight Report: TD-255 Cockpit Command Refactoring
+
+## 1. Problem Phenomenon
+The legacy cockpit system allowed external scripts (and potentially the user interface) to modify the simulation state directly and synchronously.
+This manifested as:
+-   **Untraceable State Changes**: State modifications occurred outside the event loop, making it impossible to reconstruct the sequence of events leading to a specific state.
+-   **Race Conditions**: Direct modifications could occur mid-tick or during sensitive phases, potentially violating invariants.
+-   **Lack of Audit Trail**: There was no structured log of manual interventions.
+
+## 2. Root Cause Analysis
+The root cause was a lack of a formalized command pipeline for manual interventions. The `WorldState` was treated as a mutable global object accessible from anywhere, violating the Command Pattern and Event Sourcing principles that the rest of the simulation attempts to follow.
+
+## 3. Solution Implementation Details
+We implemented an asynchronous System Command Pipeline:
+1.  **Command DTOs**: Defined `SystemCommand` (Union of `SetTaxRateCommand`, `SetInterestRateCommand`) in `modules/governance/api.py` to encapsulate intent.
+2.  **Command Queue**: Added `system_command_queue` to `WorldState` to buffer commands received from external sources.
+3.  **Command Phase**: Introduced `Phase_SystemCommands` in the `TickOrchestrator` (running early in the tick) to process these commands in a deterministic manner.
+4.  **Processor**: Implemented `SystemCommandProcessor` to execute the commands and apply changes to the `SimulationState`.
+
+This ensures that all manual interventions are:
+-   **Queued**: They happen at a specific point in the simulation lifecycle.
+-   **Logged**: The processor logs every execution.
+-   **Type-Safe**: DTOs ensure payload validity.
+
+## 4. Lessons Learned & Technical Debt Identified
+-   **Testing Infrastructure**: The existing test suite heavily relies on synchronous state modification. Migrating these tests to use the new async command pipeline will be a significant effort (`TD-256`).
+-   **DTO Proliferation**: We are accumulating many DTOs. We need to ensure strict organization to prevent circular dependencies, as seen with `SimulationState` vs `SystemCommand`.
+-   **Agent Access**: The processor currently modifies agent attributes directly (e.g., `government.corporate_tax_rate`). Ideally, agents should expose methods or consume events to update their own state to maintain encapsulation.
diff --git a/modules/governance/api.py b/modules/governance/api.py
new file mode 100644
index 00000000..d0c1a115
--- /dev/null
+++ b/modules/governance/api.py
@@ -0,0 +1,74 @@
+from __future__ import annotations
+from typing import TypedDict, Literal, Union, Protocol, TYPE_CHECKING, Any, runtime_checkable
+from enum import Enum
+
+if TYPE_CHECKING:
+    from simulation.dtos.api import SimulationState
+
+# --- Command Types ---
+
+class SystemCommandType(Enum):
+    """Defines the types of available system-level manual interventions."""
+    SET_TAX_RATE = "SET_TAX_RATE"
+    SET_INTEREST_RATE = "SET_INTEREST_RATE"
+    # TBD: Other commands like SET_GOV_SPENDING_LEVEL etc.
+
+# --- DTO Definitions ---
+
+class BaseSystemCommand(TypedDict):
+    """Base structure for all system commands."""
+    command_type: SystemCommandType
+
+class SetTaxRateCommand(BaseSystemCommand):
+    """Command to set a specific tax rate for the government."""
+    tax_type: Literal['corporate', 'income']
+    new_rate: float
+
+class SetInterestRateCommand(BaseSystemCommand):
+    """Command to set a specific interest rate for the central bank."""
+    rate_type: Literal['base_rate']
+    new_rate: float
+
+# --- Union Type for Handlers ---
+
+SystemCommand = Union[
+    SetTaxRateCommand,
+    SetInterestRateCommand
+]
+
+# --- Protocols ---
+
+@runtime_checkable
+class IFiscalPolicyHolder(Protocol):
+    corporate_tax_rate: float
+    income_tax_rate: float
+
+@runtime_checkable
+class IGovernment(Protocol):
+    corporate_tax_rate: float
+    income_tax_rate: float
+    fiscal_policy: IFiscalPolicyHolder
+
+@runtime_checkable
+class ICentralBank(Protocol):
+    base_rate: float
+
+# --- Processor Interface ---
+
+class ISystemCommandHandler(Protocol):
+    """
+    Interface for a processor that handles the execution of system commands.
+    This will be implemented by the SystemCommandProcessor.
+    """
+    def execute(self, command: SystemCommand, state: 'SimulationState') -> 'SimulationState':
+        """
+        Executes a given command, modifying and returning the simulation state.
+
+        Args:
+            command: The command DTO to execute.
+            state: The current simulation state DTO.
+
+        Returns:
+            The modified simulation state DTO.
+        """
+        ...
diff --git a/modules/governance/processor.py b/modules/governance/processor.py
new file mode 100644
index 00000000..d111e43f
--- /dev/null
+++ b/modules/governance/processor.py
@@ -0,0 +1,100 @@
+from __future__ import annotations
+from typing import TYPE_CHECKING, cast
+import logging
+from typing import Protocol, runtime_checkable
+
+from modules.governance.api import (
+    ISystemCommandHandler, SystemCommand, SystemCommandType, SetTaxRateCommand, SetInterestRateCommand,
+    IGovernment, ICentralBank
+)
+
+if TYPE_CHECKING:
+    from simulation.dtos.api import SimulationState
+
+logger = logging.getLogger(__name__)
+
+class SystemCommandProcessor(ISystemCommandHandler):
+    """
+    Processes system-level commands to manually intervene in the simulation state.
+    """
+
+    def execute(self, command: SystemCommand, state: SimulationState) -> SimulationState:
+        """
+        Executes a given command, modifying and returning the simulation state.
+        """
+        cmd_type = command['command_type']
+
+        logger.info(
+            f"SYSTEM_COMMAND | Executing {cmd_type.name}",
+            extra={"tick": state.time, "command": command}
+        )
+
+        if cmd_type == SystemCommandType.SET_TAX_RATE:
+            self._handle_set_tax_rate(cast(SetTaxRateCommand, command), state)
+        elif cmd_type == SystemCommandType.SET_INTEREST_RATE:
+            self._handle_set_interest_rate(cast(SetInterestRateCommand, command), state)
+        else:
+            logger.warning(f"SYSTEM_COMMAND | Unknown command type: {cmd_type}")
+
+        return state
+
+    def _handle_set_tax_rate(self, command: SetTaxRateCommand, state: SimulationState):
+        tax_type = command['tax_type']
+        new_rate = command['new_rate']
+
+        if state.government is None:
+            logger.error("SYSTEM_COMMAND | Government agent is None.")
+            return
+
+        # Guardrail: Strict Protocol Compliance Check
+        if not isinstance(state.government, IGovernment):
+            logger.error(f"SYSTEM_COMMAND | Government agent {type(state.government)} does not satisfy IGovernment protocol.")
+            return
+
+        government = state.government
+
+        if tax_type == 'corporate':
+            old_rate = government.corporate_tax_rate
+            government.corporate_tax_rate = new_rate
+
+            # Protocol IGovernment defines fiscal_policy as IFiscalPolicyHolder
+            # It should exist, but could be None if implementation allows (though types suggest it shouldn't be optional in protocol def)
+            # However, implementation might initialize it as None. Safe to check truthiness.
+            if government.fiscal_policy:
+                government.fiscal_policy.corporate_tax_rate = new_rate
+
+            logger.info(f"SYSTEM_COMMAND | Corporate Tax Rate: {old_rate} -> {new_rate}")
+
+        elif tax_type == 'income':
+            old_rate = government.income_tax_rate
+            government.income_tax_rate = new_rate
+
+            if government.fiscal_policy:
+                government.fiscal_policy.income_tax_rate = new_rate
+
+            logger.info(f"SYSTEM_COMMAND | Income Tax Rate: {old_rate} -> {new_rate}")
+
+        else:
+            logger.warning(f"SYSTEM_COMMAND | Unknown tax type: {tax_type}")
+
+    def _handle_set_interest_rate(self, command: SetInterestRateCommand, state: SimulationState):
+        rate_type = command['rate_type']
+        new_rate = command['new_rate']
+
+        if state.central_bank is None:
+            logger.error("SYSTEM_COMMAND | Central Bank agent is None.")
+            return
+
+        # Guardrail: Strict Protocol Compliance Check
+        if not isinstance(state.central_bank, ICentralBank):
+             logger.error(f"SYSTEM_COMMAND | Central Bank agent {type(state.central_bank)} does not satisfy ICentralBank protocol.")
+             return
+
+        central_bank = state.central_bank
+
+        if rate_type == 'base_rate':
+            old_rate = central_bank.base_rate
+            central_bank.base_rate = new_rate
+            logger.info(f"SYSTEM_COMMAND | CB Base Rate: {old_rate} -> {new_rate}")
+        else:
+            logger.warning(f"SYSTEM_COMMAND | Unknown interest rate type: {rate_type}")
diff --git a/simulation/dtos/api.py b/simulation/dtos/api.py
index 8f796e49..0e4a1954 100644
--- a/simulation/dtos/api.py
+++ b/simulation/dtos/api.py
@@ -5,6 +5,7 @@ from simulation.dtos.firm_state_dto import FirmStateDTO
 from simulation.models import Order
 from simulation.dtos.decision_dtos import DecisionOutputDTO
 from modules.finance.api import IFinancialEntity
+from modules.governance.api import SystemCommand
 
 # Alias for standardization
 OrderDTO = Order
@@ -244,6 +245,9 @@ class SimulationState:
     saga_orchestrator: Optional[Any] = None
     monetary_ledger: Optional[Any] = None
 
+    # TD-255: System Command Pipeline
+    system_commands: List[SystemCommand] = field(default_factory=list)
+
     # --- NEW TRANSIENT FIELDS ---
     # From Phase 1 (Decisions)
     firm_pre_states: Dict[int, Any] = None
@@ -276,6 +280,8 @@ class SimulationState:
     def __post_init__(self):
         if self.transactions is None:
             self.transactions = []
+        if self.system_commands is None:
+            self.system_commands = []
         if self.inter_tick_queue is None:
             self.inter_tick_queue = []
         if self.effects_queue is None:
diff --git a/simulation/orchestration/phases/system_commands.py b/simulation/orchestration/phases/system_commands.py
new file mode 100644
index 00000000..ed5f2cba
--- /dev/null
+++ b/simulation/orchestration/phases/system_commands.py
@@ -0,0 +1,47 @@
+from __future__ import annotations
+from typing import TYPE_CHECKING
+import logging
+
+from simulation.orchestration.api import IPhaseStrategy
+from simulation.dtos.api import SimulationState
+from modules.governance.processor import SystemCommandProcessor
+
+if TYPE_CHECKING:
+    from simulation.world_state import WorldState
+
+logger = logging.getLogger(__name__)
+
+class Phase_SystemCommands(IPhaseStrategy):
+    """
+    Orchestration phase for executing manual system commands (Cockpit interventions).
+    This phase runs early in the tick to ensure interventions apply before agent decisions.
+    """
+
+    def __init__(self, world_state: 'WorldState'):
+        self.world_state = world_state
+        # Instantiate processor. Can be stateless or stateful.
+        self.processor = SystemCommandProcessor()
+
+    def execute(self, state: SimulationState) -> SimulationState:
+        if not state.system_commands:
+            return state
+
+        logger.info(
+            f"SYSTEM_COMMANDS_PHASE | Processing {len(state.system_commands)} commands.",
+            extra={"tick": state.time, "count": len(state.system_commands)}
+        )
+
+        for command in state.system_commands:
+            try:
+                state = self.processor.execute(command, state)
+            except Exception as e:
+                logger.error(
+                    f"SYSTEM_COMMAND_ERROR | Failed to execute command: {command}",
+                    exc_info=True,
+                    extra={"tick": state.time, "command": command}
+                )
+
+        # Clear commands after processing to prevent re-execution if state is reused (though usually recreated)
+        state.system_commands.clear()
+
+        return state
diff --git a/simulation/orchestration/tick_orchestrator.py b/simulation/orchestration/tick_orchestrator.py
index dc6b1f48..9faee9e0 100644
--- a/simulation/orchestration/tick_orchestrator.py
+++ b/simulation/orchestration/tick_orchestrator.py
@@ -9,6 +9,7 @@ from simulation.orchestration.phases import (
     Phase_BankAndDebt, Phase_FirmProductionAndSalaries, Phase_GovernmentPrograms, Phase_TaxationIntents,
     Phase_MonetaryProcessing
 )
+from simulation.orchestration.phases.system_commands import Phase_SystemCommands
 from simulation.orchestration.utils import prepare_market_data
 from simulation.orchestration.phases_recovery import Phase_SystemicLiquidation
 from modules.system.api import DEFAULT_CURRENCY
@@ -28,6 +29,7 @@ class TickOrchestrator:
         # Initialize phases with dependencies
         self.phases: List[IPhaseStrategy] = [
             Phase0_PreSequence(world_state),
+            Phase_SystemCommands(world_state), # TD-255: Cockpit Interventions
             Phase_Production(world_state),
             Phase1_Decision(world_state),
             Phase_Bankruptcy(world_state),           # Phase 4 (Spec): Lifecycle & Bankruptcy
@@ -93,6 +95,10 @@ class TickOrchestrator:
     def _create_simulation_state_dto(self, injectable_sensory_dto: Optional[GovernmentSensoryDTO]) -> SimulationState:
         state = self.world_state
 
+        # Drain command queue
+        commands_for_tick = list(state.system_command_queue)
+        state.system_command_queue.clear()
+
         # Ensure injectable_sensory_dto has valid current_gdp if provided
         # This is passed to government as sensory_data, which is then used by FinanceSystem
         # to calculate debt-to-GDP ratio via FiscalMonitor.
@@ -132,6 +138,7 @@ class TickOrchestrator:
             saga_orchestrator=state.saga_orchestrator, # TD-253
             monetary_ledger=state.monetary_ledger,     # TD-253
             shareholder_registry=state.shareholder_registry, # TD-275
+            system_commands=commands_for_tick, # TD-255
             effects_queue=[], # TD-192: Init empty
             inter_tick_queue=[], # TD-192: Init empty
             transactions=[], # TD-192: Init empty
diff --git a/simulation/world_state.py b/simulation/world_state.py
index bb59e0fa..09db016b 100644
--- a/simulation/world_state.py
+++ b/simulation/world_state.py
@@ -45,6 +45,7 @@ from modules.system.api import IAssetRecoverySystem, ICurrencyHolder, CurrencyCo
 from modules.system.constants import ID_CENTRAL_BANK
 from modules.finance.kernel.api import ISagaOrchestrator, IMonetaryLedger
 from modules.finance.api import IShareholderRegistry
+from modules.governance.api import SystemCommand
 
 
 class WorldState:
@@ -103,6 +104,7 @@ class WorldState:
         self.inter_tick_queue: List[Transaction] = []  # WO-109: Queue for next tick
         self.effects_queue: List[Dict[str, Any]] = []  # WO-109: Queue for side-effects
         self.inactive_agents: Dict[int, Any] = {}  # WO-109: Store inactive agents for transaction processing
+        self.system_command_queue: List[SystemCommand] = [] # TD-255: Cockpit Event Queue
 
         # New Systems
         self.social_system: Optional[SocialSystem] = None
diff --git a/tests/modules/governance/test_system_command_processor.py b/tests/modules/governance/test_system_command_processor.py
new file mode 100644
index 00000000..f7819512
--- /dev/null
+++ b/tests/modules/governance/test_system_command_processor.py
@@ -0,0 +1,87 @@
+import pytest
+from unittest.mock import MagicMock
+from modules.governance.api import SystemCommandType, SetTaxRateCommand, SetInterestRateCommand
+from modules.governance.processor import SystemCommandProcessor
+from simulation.dtos.api import SimulationState
+
+@pytest.fixture
+def mock_simulation_state():
+    state = MagicMock(spec=SimulationState)
+    state.time = 100
+    state.government = MagicMock()
+    state.central_bank = MagicMock()
+
+    # Setup government attributes
+    state.government.corporate_tax_rate = 0.2
+    state.government.income_tax_rate = 0.1
+    state.government.fiscal_policy = MagicMock()
+    state.government.fiscal_policy.corporate_tax_rate = 0.2
+    state.government.fiscal_policy.income_tax_rate = 0.1
+
+    # Setup central bank attributes
+    state.central_bank.base_rate = 0.05
+    return state
+
+def test_set_corporate_tax_rate(mock_simulation_state):
+    processor = SystemCommandProcessor()
+    command: SetTaxRateCommand = {
+        'command_type': SystemCommandType.SET_TAX_RATE,
+        'tax_type': 'corporate',
+        'new_rate': 0.25
+    }
+
+    processor.execute(command, mock_simulation_state)
+
+    assert mock_simulation_state.government.corporate_tax_rate == 0.25
+    assert mock_simulation_state.government.fiscal_policy.corporate_tax_rate == 0.25
+
+def test_set_income_tax_rate(mock_simulation_state):
+    processor = SystemCommandProcessor()
+    command: SetTaxRateCommand = {
+        'command_type': SystemCommandType.SET_TAX_RATE,
+        'tax_type': 'income',
+        'new_rate': 0.15
+    }
+
+    processor.execute(command, mock_simulation_state)
+
+    assert mock_simulation_state.government.income_tax_rate == 0.15
+    assert mock_simulation_state.government.fiscal_policy.income_tax_rate == 0.15
+
+def test_set_base_interest_rate(mock_simulation_state):
+    processor = SystemCommandProcessor()
+    command: SetInterestRateCommand = {
+        'command_type': SystemCommandType.SET_INTEREST_RATE,
+        'rate_type': 'base_rate',
+        'new_rate': 0.03
+    }
+
+    processor.execute(command, mock_simulation_state)
+
+    assert mock_simulation_state.central_bank.base_rate == 0.03
+
+def test_ignore_unknown_tax_type(mock_simulation_state):
+    processor = SystemCommandProcessor()
+    command: SetTaxRateCommand = {
+        'command_type': SystemCommandType.SET_TAX_RATE,
+        'tax_type': 'invalid', # type: ignore
+        'new_rate': 0.99
+    }
+
+    # Should not raise error and should not modify state
+    processor.execute(command, mock_simulation_state)
+
+    assert mock_simulation_state.government.corporate_tax_rate == 0.2
+    assert mock_simulation_state.government.income_tax_rate == 0.1
+
+def test_missing_government(mock_simulation_state):
+    mock_simulation_state.government = None
+    processor = SystemCommandProcessor()
+    command: SetTaxRateCommand = {
+        'command_type': SystemCommandType.SET_TAX_RATE,
+        'tax_type': 'corporate',
+        'new_rate': 0.25
+    }
+
+    # Should log error but not crash
+    processor.execute(command, mock_simulation_state)
