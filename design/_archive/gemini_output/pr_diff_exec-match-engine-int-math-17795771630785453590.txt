diff --git a/communications/insights/exec-match-engine-int-math.md b/communications/insights/exec-match-engine-int-math.md
new file mode 100644
index 00000000..2ebeeb93
--- /dev/null
+++ b/communications/insights/exec-match-engine-int-math.md
@@ -0,0 +1,44 @@
+# Insight Report: Matching Engine Integer Math Hardening
+## Executive Summary
+This report details the successful hardening of the simulation's financial integrity by enforcing integer math (pennies) across key systems. The primary goal was to eliminate floating-point drift and ensure zero-sum correctness in transaction processing.
+
+## Architectural Insights
+1.  **Dual-Precision Model**:
+    *   We adopted a "Dual-Precision" model where `Transaction.total_pennies` (int) serves as the Single Source of Truth (SSoT) for financial settlement.
+    *   `Transaction.price` (float) is retained for backward compatibility with UI and legacy agents but is treated as a derived or display value.
+
+2.  **Explicit Rounding**:
+    *   `CommerceSystem` and `TransactionProcessor` were refactored to use `round_to_pennies(price * quantity * 100)` instead of simple integer casting. This prevents truncation errors (e.g., $0.29 * 100 -> 28.99... -> 28) and ensures accurate financial accounting.
+
+3.  **Handler Hardening**:
+    *   `GoodsTransactionHandler`, `LaborTransactionHandler`, and `HousingTransactionHandler` were updated to prioritize `total_pennies` if present.
+    *   Fallback logic was improved to explicitly interpret legacy float prices as dollars and convert them to pennies using robust rounding.
+
+4.  **Saga Integrity**:
+    *   `HousingTransactionSagaHandler` was updated to explicitly set `total_pennies` and correct dollar-based prices in manual `Transaction` creations, ensuring consistency with the new standard.
+
+## Test Evidence
+The following tests confirm the correctness of the implementation:
+
+```
+tests/market/test_matching_engine_hardening.py::TestMatchingEngineHardening::test_order_book_matching_integer_math PASSED [ 16%]
+tests/market/test_matching_engine_hardening.py::TestMatchingEngineHardening::test_stock_matching_mid_price_rounding PASSED [ 33%]
+tests/market/test_matching_engine_hardening.py::TestMatchingEngineHardening::test_small_quantity_zero_pennies PASSED [ 50%]
+tests/unit/test_goods_handler_precision.py::TestGoodsHandlerPrecision::test_legacy_price_handling PASSED [ 66%]
+tests/unit/test_transaction_integrity.py::TestTransactionIntegrity::test_commerce_system_transaction_total_pennies PASSED [ 83%]
+tests/unit/test_transaction_integrity.py::TestTransactionIntegrity::test_settlement_system_record_total_pennies PASSED [100%]
+
+=============================== warnings summary ===============================
+../home/jules/.local/share/pipx/venvs/pytest/lib/python3.12/site-packages/_pytest/config/__init__.py:1428
+  /home/jules/.local/share/pipx/venvs/pytest/lib/python3.12/site-packages/_pytest/config/__init__.py:1428: PytestConfigWarning: Unknown config option: asyncio_default_fixture_loop_scope
+
+    self._warn_or_fail_if_strict(f"Unknown config option: {key}\n")
+
+../home/jules/.local/share/pipx/venvs/pytest/lib/python3.12/site-packages/_pytest/config/__init__.py:1428
+  /home/jules/.local/share/pipx/venvs/pytest/lib/python3.12/site-packages/_pytest/config/__init__.py:1428: PytestConfigWarning: Unknown config option: asyncio_mode
+
+    self._warn_or_fail_if_strict(f"Unknown config option: {key}\n")
+
+-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
+======================== 6 passed, 2 warnings in 0.35s =========================
+```
diff --git a/modules/finance/saga_handler.py b/modules/finance/saga_handler.py
index 5e6290a7..5d31446c 100644
--- a/modules/finance/saga_handler.py
+++ b/modules/finance/saga_handler.py
@@ -251,12 +251,14 @@ class HousingTransactionSagaHandler(IHousingTransactionSagaHandler):
                          reason="mortgage_disbursal"
                      )
                  else:
+                     from modules.finance.utils.currency_math import round_to_pennies
                      tx_credit = Transaction(
                         buyer_id=bank.id,
                         seller_id=-1, # System Authorization
                         item_id=f"mortgage_disbursal_{saga['saga_id']}",
                         quantity=1.0,
                         price=principal,
+                        total_pennies=round_to_pennies(principal * 100),
                         market_id="monetary_policy",
                         transaction_type="credit_creation",
                         time=self.simulation.time,
@@ -349,12 +351,14 @@ class HousingTransactionSagaHandler(IHousingTransactionSagaHandler):
                      reason="mortgage_rollback"
                  )
              else:
+                 from modules.finance.utils.currency_math import round_to_pennies
                  tx_destroy = Transaction(
                     buyer_id=-1,
                     seller_id=bank.id,
                     item_id=f"mortgage_rollback_{saga['saga_id']}",
                     quantity=1.0,
                     price=principal,
+                    total_pennies=round_to_pennies(principal * 100),
                     market_id="monetary_policy",
                     transaction_type="credit_destruction",
                     time=self.simulation.time,
@@ -376,12 +380,14 @@ class HousingTransactionSagaHandler(IHousingTransactionSagaHandler):
         if seller_id is None:
              seller_id = saga.get('seller_id')
 
+        from modules.finance.utils.currency_math import round_to_pennies
         tx_record = Transaction(
             buyer_id=buyer_id,
             seller_id=seller_id,
             item_id=f"unit_{saga['property_id']}",
             quantity=1.0,
             price=saga['offer_price'],
+            total_pennies=round_to_pennies(saga['offer_price'] * 100),
             market_id="housing",
             transaction_type="housing",
             time=self.simulation.time,
diff --git a/modules/market/handlers/housing_transaction_handler.py b/modules/market/handlers/housing_transaction_handler.py
index 5361ce7a..a1b2d6c1 100644
--- a/modules/market/handlers/housing_transaction_handler.py
+++ b/modules/market/handlers/housing_transaction_handler.py
@@ -9,6 +9,7 @@ from modules.common.interfaces import IPropertyOwner
 from modules.system.api import DEFAULT_CURRENCY
 from simulation.firms import Firm
 from modules.simulation.api import AgentID
+from modules.finance.utils.currency_math import round_to_pennies
 
 logger = logging.getLogger(__name__)
 
@@ -61,7 +62,12 @@ class HousingTransactionHandler(ITransactionHandler, IHousingTransactionHandler)
         # Interest Rate (Bank Config or Global)
         mortgage_rate = getattr(context.config_module, "MORTGAGE_INTEREST_RATE", 0.05)
 
-        sale_price = tx.price * tx.quantity
+        if getattr(tx, 'total_pennies', 0) > 0:
+            sale_price = tx.total_pennies
+        else:
+            # Fallback for legacy transactions without total_pennies
+            # Assume price is in dollars
+            sale_price = round_to_pennies(tx.price * tx.quantity * 100)
         loan_amount = 0.0
         down_payment = sale_price
 
diff --git a/simulation/systems/commerce_system.py b/simulation/systems/commerce_system.py
index 85998375..f5388c0b 100644
--- a/simulation/systems/commerce_system.py
+++ b/simulation/systems/commerce_system.py
@@ -123,13 +123,16 @@ class CommerceSystem(ICommerceSystem):
 
                         # Use a proper constant for the system seller ID
                         from simulation.constants import SYSTEM_MARKET_MAKER_ID
+                        from modules.finance.utils.currency_math import round_to_pennies
 
+                        total_pennies = round_to_pennies(bid_price * b_amt * 100)
                         tx = Transaction(
                             buyer_id=household.id,
                             seller_id=SYSTEM_MARKET_MAKER_ID,
                             item_id="basic_food",
                             quantity=b_amt,
                             price=bid_price,
+                            total_pennies=total_pennies,
                             market_id="basic_food",
                             transaction_type="PHASE23_MARKET_ORDER",
                             time=current_time
@@ -149,13 +152,16 @@ class CommerceSystem(ICommerceSystem):
                             planned_consumptions[household.id]["buy_amount"] = b_amt
                             government = context.get("government")
                             seller_id = government.id if government else 999999
+                            from modules.finance.utils.currency_math import round_to_pennies
 
+                            total_pennies = round_to_pennies(food_price * b_amt * 100)
                             tx = Transaction(
                                 buyer_id=household.id,
                                 seller_id=seller_id,
                                 item_id="basic_food",
                                 quantity=b_amt,
                                 price=food_price,
+                                total_pennies=total_pennies,
                                 market_id="system",
                                 transaction_type="emergency_buy",
                                 time=current_time
diff --git a/simulation/systems/handlers/goods_handler.py b/simulation/systems/handlers/goods_handler.py
index 486f716f..4dbab2d2 100644
--- a/simulation/systems/handlers/goods_handler.py
+++ b/simulation/systems/handlers/goods_handler.py
@@ -29,7 +29,8 @@ class GoodsTransactionHandler(ITransactionHandler):
              trade_value = 0
         else:
              # Fallback for legacy transactions without total_pennies
-             trade_value = round_to_pennies(tx.quantity * tx.price)
+             # Assume price is in dollars
+             trade_value = round_to_pennies(tx.quantity * tx.price * 100)
 
 
         # 1. Prepare Settlement (Calculate tax intents)
diff --git a/simulation/systems/handlers/labor_handler.py b/simulation/systems/handlers/labor_handler.py
index 79e2419d..aaa05920 100644
--- a/simulation/systems/handlers/labor_handler.py
+++ b/simulation/systems/handlers/labor_handler.py
@@ -22,7 +22,9 @@ class LaborTransactionHandler(ITransactionHandler):
         elif getattr(tx, 'total_pennies', 0) == 0 and tx.price == 0:
              trade_value = 0
         else:
-             trade_value = round_to_pennies(tx.quantity * tx.price)
+             # Fallback for legacy transactions without total_pennies
+             # Assume price is in dollars
+             trade_value = round_to_pennies(tx.quantity * tx.price * 100)
 
         # 1. Prepare Settlement (Calculate tax intents)
         # Note: TransactionProcessor used market_data.get("goods_market")?
diff --git a/simulation/systems/settlement_system.py b/simulation/systems/settlement_system.py
index 3bd37717..e87c35dc 100644
--- a/simulation/systems/settlement_system.py
+++ b/simulation/systems/settlement_system.py
@@ -494,6 +494,7 @@ class SettlementSystem(IMonetaryAuthority):
             item_id="currency",
             quantity=amount,
             price=1,
+            total_pennies=amount,
             market_id="settlement",
             transaction_type="transfer",
             time=tick,
diff --git a/simulation/systems/transaction_processor.py b/simulation/systems/transaction_processor.py
index 7a4646f8..62230b77 100644
--- a/simulation/systems/transaction_processor.py
+++ b/simulation/systems/transaction_processor.py
@@ -66,9 +66,9 @@ class TransactionProcessor(SystemInterface):
                     amount = 0.0
                     if success:
                         if getattr(tx, 'total_pennies', 0) > 0:
-                            amount = float(tx.total_pennies)
+                            amount = tx.total_pennies
                         else:
-                            amount = tx.quantity * tx.price
+                            amount = round_to_pennies(tx.quantity * tx.price * 100)
 
                     return SettlementResultDTO(
                         original_transaction=tx,
@@ -199,9 +199,9 @@ class TransactionProcessor(SystemInterface):
                 if success:
                     # TD-MKT-FLOAT-MATCH: total_pennies is the SSoT for settlement
                     if getattr(tx, 'total_pennies', 0) > 0:
-                        amount = float(tx.total_pennies)
+                        amount = tx.total_pennies
                     else:
-                        amount = tx.quantity * tx.price
+                        amount = round_to_pennies(tx.quantity * tx.price * 100)
 
                 results.append(
                     SettlementResultDTO(
diff --git a/tests/market/test_matching_engine_hardening.py b/tests/market/test_matching_engine_hardening.py
new file mode 100644
index 00000000..0a7a644f
--- /dev/null
+++ b/tests/market/test_matching_engine_hardening.py
@@ -0,0 +1,139 @@
+import pytest
+from unittest.mock import MagicMock
+from simulation.markets.matching_engine import OrderBookMatchingEngine, StockMatchingEngine
+from modules.market.api import CanonicalOrderDTO, OrderBookStateDTO, StockMarketStateDTO
+from simulation.models import Transaction
+
+class TestMatchingEngineHardening:
+
+    def test_order_book_matching_integer_math(self):
+        engine = OrderBookMatchingEngine()
+
+        # Scenario: Buyer wants 0.1 units at $10.05 (1005 pennies)
+        # Seller sells 0.1 units at $10.05 (1005 pennies)
+        # Expected total pennies: 1005 * 0.1 = 100.5 -> 100 pennies (int cast)
+
+        buy_order = CanonicalOrderDTO(
+            agent_id="buyer_1",
+            side="BUY",
+            item_id="item_1",
+            quantity=0.1,
+            price_pennies=1005,
+            price_limit=10.05,
+            market_id="goods"
+        )
+
+        sell_order = CanonicalOrderDTO(
+            agent_id="seller_1",
+            side="SELL",
+            item_id="item_1",
+            quantity=0.1,
+            price_pennies=1005, # Matching price
+            price_limit=10.05,
+            market_id="goods"
+        )
+
+        state = OrderBookStateDTO(
+            buy_orders={"item_1": [buy_order]},
+            sell_orders={"item_1": [sell_order]},
+            market_id="goods"
+        )
+
+        result = engine.match(state, current_tick=1)
+
+        assert len(result.transactions) == 1
+        tx = result.transactions[0]
+
+        # Verify total_pennies is calculated correctly as int(1005 * 0.1) = 100
+        assert tx.total_pennies == 100
+        assert tx.quantity == 0.1
+        # Effective price should be derived from total_pennies: 100 / 0.1 / 100 = 10.0
+        # Original price was 10.05. The effective price is slightly different due to integer rounding.
+        assert tx.price == 10.0
+
+    def test_stock_matching_mid_price_rounding(self):
+        engine = StockMatchingEngine()
+
+        # Scenario:
+        # Buyer bids $10.01 (1001 pennies)
+        # Seller asks $10.00 (1000 pennies)
+        # Mid price: (1001 + 1000) // 2 = 2001 // 2 = 1000 pennies
+
+        buy_order = CanonicalOrderDTO(
+            agent_id=1,
+            side="BUY",
+            item_id="stock_1",
+            quantity=1.0,
+            price_pennies=1001,
+            price_limit=10.01,
+            market_id="stock"
+        )
+
+        sell_order = CanonicalOrderDTO(
+            agent_id=2,
+            side="SELL",
+            item_id="stock_1",
+            quantity=1.0,
+            price_pennies=1000,
+            price_limit=10.00,
+            market_id="stock"
+        )
+
+        state = StockMarketStateDTO(
+            buy_orders={1: [buy_order]},
+            sell_orders={1: [sell_order]},
+            market_id="stock"
+        )
+
+        result = engine.match(state, current_tick=1)
+
+        assert len(result.transactions) == 1
+        tx = result.transactions[0]
+
+        # Trade price should be 1000 pennies
+        # Total pennies: 1000 * 1 = 1000
+        assert tx.total_pennies == 1000
+        assert tx.price == 10.00
+
+    def test_small_quantity_zero_pennies(self):
+        engine = OrderBookMatchingEngine()
+
+        # Scenario: Very small quantity resulting in 0 pennies
+        # Price: 100 pennies ($1.00)
+        # Quantity: 0.001
+        # Total: 100 * 0.001 = 0.1 -> 0 pennies
+
+        buy_order = CanonicalOrderDTO(
+            agent_id="buyer_2",
+            side="BUY",
+            item_id="item_2",
+            quantity=0.001,
+            price_pennies=100,
+            price_limit=1.00,
+            market_id="goods"
+        )
+
+        sell_order = CanonicalOrderDTO(
+            agent_id="seller_2",
+            side="SELL",
+            item_id="item_2",
+            quantity=0.001,
+            price_pennies=100,
+            price_limit=1.00,
+            market_id="goods"
+        )
+
+        state = OrderBookStateDTO(
+            buy_orders={"item_2": [buy_order]},
+            sell_orders={"item_2": [sell_order]},
+            market_id="goods"
+        )
+
+        result = engine.match(state, current_tick=1)
+
+        assert len(result.transactions) == 1
+        tx = result.transactions[0]
+
+        assert tx.total_pennies == 0
+        assert tx.quantity == 0.001
+        assert tx.price == 0.0
diff --git a/tests/unit/test_goods_handler_precision.py b/tests/unit/test_goods_handler_precision.py
new file mode 100644
index 00000000..00252159
--- /dev/null
+++ b/tests/unit/test_goods_handler_precision.py
@@ -0,0 +1,63 @@
+import pytest
+from unittest.mock import MagicMock
+from simulation.systems.handlers.goods_handler import GoodsTransactionHandler
+from simulation.models import Transaction
+from modules.finance.api import IFinancialAgent
+from simulation.systems.api import TransactionContext
+from simulation.core_agents import Household
+from simulation.firms import Firm
+
+class TestGoodsHandlerPrecision:
+
+    def test_legacy_price_handling(self):
+        """
+        Verify that legacy transactions (without total_pennies) are handled correctly.
+        Current implementation suspects that dollars are treated as pennies.
+        """
+        handler = GoodsTransactionHandler()
+
+        # Scenario: 1 unit at $10.00
+        # Should be 1000 pennies.
+        tx = Transaction(
+            buyer_id=1,
+            seller_id=2,
+            item_id="test_item",
+            quantity=1.0,
+            price=10.00, # Dollars
+            market_id="test",
+            transaction_type="goods",
+            time=1
+        )
+
+        # Mock Context
+        context = MagicMock(spec=TransactionContext)
+        context.taxation_system = MagicMock()
+        context.taxation_system.calculate_tax_intents.return_value = []
+        context.settlement_system = MagicMock()
+        context.settlement_system.settle_atomic.return_value = True
+        context.config_module = MagicMock()
+        context.government = MagicMock() # Added this
+        context.market_data = {}
+        context.time = 1
+
+        buyer = MagicMock(spec=Household)
+        buyer.id = 1
+        seller = MagicMock(spec=Firm)
+        seller.id = 2
+
+        # Execute
+        handler.handle(tx, buyer, seller, context)
+
+        # Check what was passed to settle_atomic
+        # settle_atomic(debit_agent, credits_list, tick)
+        # credits_list = [(seller, amount, memo), ...]
+        call_args = context.settlement_system.settle_atomic.call_args
+        assert call_args is not None
+
+        credits = call_args[0][1]
+        amount = credits[0][1]
+
+        # If the bug exists, amount will be 10 (pennies) instead of 1000.
+        print(f"Settled Amount: {amount}")
+
+        assert amount == 1000, f"Expected 1000 pennies ($10.00), got {amount}"
diff --git a/tests/unit/test_transaction_integrity.py b/tests/unit/test_transaction_integrity.py
new file mode 100644
index 00000000..3e32119b
--- /dev/null
+++ b/tests/unit/test_transaction_integrity.py
@@ -0,0 +1,81 @@
+import pytest
+from unittest.mock import MagicMock
+from simulation.systems.commerce_system import CommerceSystem
+from simulation.systems.settlement_system import SettlementSystem
+from simulation.models import Transaction
+
+class TestTransactionIntegrity:
+
+    def test_commerce_system_transaction_total_pennies(self):
+        """
+        Verify that CommerceSystem.plan_consumption_and_leisure creates transactions with total_pennies set.
+        """
+        config = MagicMock()
+        config.DEFAULT_FALLBACK_PRICE = 5.0
+
+        system = CommerceSystem(config)
+
+        # Mock Context
+        context = {
+            "households": [],
+            "breeding_planner": MagicMock(),
+            "market_data": {"basic_food_current_sell_price": 5.0},
+            "time": 1,
+            "household_time_allocation": {},
+            "agents": {}
+        }
+
+        # Setup Breeding Planner to return a 'buy' decision
+        # Ensure survival_threshold is a float to match comparison logic
+        context["breeding_planner"].survival_threshold = 50.0
+        context["breeding_planner"].decide_consumption_batch.return_value = {
+            "consume": [0.0],
+            "buy": [1.0], # Buy 1 unit
+            "price": 5.0  # Price $5.00
+        }
+
+        # Create a mock household
+        household = MagicMock()
+        household.id = 1
+        household._bio_state.is_active = True
+        household._econ_state.is_employed = True
+        # Assets handling in CommerceSystem: cash = assets.get(DEFAULT_CURRENCY)
+        # Using a dict for assets
+        household._econ_state.assets = { "USD": 1000 }
+
+        # Mocking needs.get
+        # survival_need = household._bio_state.needs.get("survival", 0.0)
+        # We need household._bio_state.needs to be a dict or behave like one
+        household._bio_state.needs = {"survival": 40.0}
+
+        context["households"] = [household]
+
+        # Execute
+        planned, transactions = system.plan_consumption_and_leisure(context)
+
+        assert len(transactions) == 1
+        tx = transactions[0]
+
+        # Expected: 1 unit * $5.00 = 500 pennies
+        assert getattr(tx, 'total_pennies', 0) == 500
+        assert tx.price == 5.0
+
+    def test_settlement_system_record_total_pennies(self):
+        """
+        Verify that SettlementSystem._create_transaction_record sets total_pennies.
+        """
+        system = SettlementSystem()
+
+        # Call private method directly for testing
+        tx = system._create_transaction_record(
+            buyer_id=1,
+            seller_id=2,
+            amount=100, # 100 pennies transfer
+            memo="test",
+            tick=1
+        )
+
+        assert tx is not None
+        assert getattr(tx, 'total_pennies', 0) == 100
+        assert tx.quantity == 100
+        assert tx.price == 1
