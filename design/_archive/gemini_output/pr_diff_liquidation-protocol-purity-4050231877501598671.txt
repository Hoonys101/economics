diff --git a/communications/insights/TD-LIQ-INV.md b/communications/insights/TD-LIQ-INV.md
new file mode 100644
index 00000000..2523c1fc
--- /dev/null
+++ b/communications/insights/TD-LIQ-INV.md
@@ -0,0 +1,35 @@
+# Technical Insight Report: TD-LIQ-INV Protocol Purity
+
+## 1. Problem Phenomenon
+The `InventoryLiquidationHandler` relied on dynamic `getattr` and `hasattr` calls to access internal configuration of agents, specifically `fire_sale_discount` and `goods`. This created an implicit coupling between the liquidation system and the concrete implementation of `Firm` agents. Changes to `FirmConfigDTO` structure could silently break liquidation logic without type checker warnings.
+
+Symptoms:
+-   `InventoryLiquidationHandler` contained code like `getattr(agent.config, "fire_sale_discount", 0.2)`.
+-   Integration tests were fragile and failed when internal structures changed.
+-   `Firm` class implementation of `get_liquidation_config` also used defensive `hasattr` checks, masking potential configuration errors.
+
+## 2. Root Cause Analysis
+The root cause was a violation of the "Protocol Purity" architectural guardrail. The liquidation system was accessing internal state directly instead of using a defined interface contract.
+-   The system lacked a strict contract (`IConfigurable`) for retrieving liquidation parameters.
+-   Unit and Integration tests were mocking `Firm` objects loosely, without adhering to a strict protocol spec, leading to tests that passed even when the underlying contract was violated or incomplete.
+-   Integration tests for `LiquidationManager` were particularly brittle, mocking `Firm` but not its protocol methods (`get_all_claims`, `get_all_items`, `get_liquidation_config`), causing the manager to receive empty data and tests to fail silently or with confusing assertions.
+
+## 3. Solution Implementation Details
+The solution involved refactoring to enforce Protocol Purity:
+
+1.  **Protocol Definition**: `IConfigurable` protocol and `LiquidationConfigDTO` were utilized (already present in `modules/simulation/api.py`).
+2.  **Firm Implementation**:
+    -   Refactored `Firm.get_liquidation_config` to remove `hasattr` safety nets and access `self.config.fire_sale_discount` directly. This ensures that if the config is missing the attribute, it raises an error early rather than using a default silently.
+    -   Ensured `Firm` explicitly implements `IConfigurable`.
+3.  **Handler Refactor**: Verified `InventoryLiquidationHandler` uses `agent.get_liquidation_config()` and `isinstance(agent, IConfigurable)` check.
+4.  **Test Refactoring**:
+    -   Updated `tests/integration/test_liquidation_waterfall.py` to correctly mock the protocol methods.
+    -   Mocked `get_liquidation_config`, `get_all_items`, and `get_all_claims` using `side_effect` to simulate real logic or return consistent test data.
+    -   Fixed `LiquidationManager` instantiation in tests to include the required `shareholder_registry` mock.
+    -   Ensured `assert_any_call` matches the actual implementation strings ("Agent" vs "Firm").
+
+## 4. Lessons Learned & Technical Debt
+-   **Test Fragility**: Integration tests that mock too much internal structure (like `firm.hr.employees` without mocking the `get_all_claims` method that uses it) are highly fragile. When the system under test (`LiquidationManager`) delegates logic back to the mocked object (`Firm`), the mock must faithfully reproduce that logic or the test becomes invalid.
+-   **Mocking Protocols**: When mocking objects that implement protocols, it is crucial to mock the protocol methods (`get_X`) explicitly. Simply setting attributes (`firm.inventory`) is insufficient if the consumer uses the accessor method (`firm.get_all_items()`).
+-   **Legacy Aliases**: The `Firm` class and tests still use some legacy aliases (e.g., `firm.finance` aliasing `firm.finance_state`). These should be cleaned up in a future "God Class" refactor (TD-073) to strictly enforce the new State/Engine architecture.
+-   **Dependency Injection**: The `LiquidationManager` constructor signature change (adding `shareholder_registry`) was not reflected in the integration test, causing silent failures (handler not initialized). Tests must use strict typing or be updated when signatures change.
diff --git a/simulation/firms.py b/simulation/firms.py
index d3ea33b2..f5cfd74b 100644
--- a/simulation/firms.py
+++ b/simulation/firms.py
@@ -189,7 +189,7 @@ class Firm(ILearningAgent, IFinancialEntity, IFinancialAgent, ILiquidatable, IOr
                      initial_prices[k] = v["initial_price"]
 
         return LiquidationConfigDTO(
-            haircut=self.config.fire_sale_discount if hasattr(self.config, "fire_sale_discount") else 0.2,
+            haircut=self.config.fire_sale_discount,
             initial_prices=initial_prices,
             default_price=10.0,
             market_prices=self.last_prices.copy()
diff --git a/tests/integration/test_liquidation_waterfall.py b/tests/integration/test_liquidation_waterfall.py
index 85e07b83..19d3e2a4 100644
--- a/tests/integration/test_liquidation_waterfall.py
+++ b/tests/integration/test_liquidation_waterfall.py
@@ -8,6 +8,8 @@ from simulation.firms import Firm
 from simulation.core_agents import Household
 from simulation.dtos.api import SimulationState
 from simulation.dtos.config_dtos import FirmConfigDTO
+from modules.simulation.api import LiquidationConfigDTO
+from modules.finance.api import EquityStake
 from modules.system.api import IAssetRecoverySystem, DEFAULT_CURRENCY
 from modules.system.registry import AgentRegistry
 from modules.hr.service import HRService
@@ -19,6 +21,7 @@ class TestLiquidationWaterfallIntegration(unittest.TestCase):
         self.mock_public_manager = MagicMock(spec=IAssetRecoverySystem)
         self.mock_public_manager.managed_inventory = {}
         self.mock_public_manager.id = 999
+        self.mock_shareholder_registry = MagicMock()
         self.mock_settlement.transfer.return_value = True # Default success
 
         # Use Real Services
@@ -31,6 +34,7 @@ class TestLiquidationWaterfallIntegration(unittest.TestCase):
             self.hr_service,
             self.tax_service,
             self.agent_registry,
+            self.mock_shareholder_registry,
             self.mock_public_manager
         )
 
@@ -46,19 +50,49 @@ class TestLiquidationWaterfallIntegration(unittest.TestCase):
         self.firm = MagicMock(spec=Firm)
         self.firm.id = 1
         self.firm.config = self.config
-        self.firm.finance = MagicMock()
-        self.firm.finance.balance = {DEFAULT_CURRENCY: 0.0} # Start with 0 cash
-        self.firm.finance.current_profit = 0.0 # Fix 1
+        self.firm.finance_state = MagicMock()
+        self.firm.finance_state.balance = {DEFAULT_CURRENCY: 0.0}
+        self.firm.finance_state.current_profit = 0.0
+        # Alias for backward compatibility in test setup
+        self.firm.finance = self.firm.finance_state
 
         # Configure liquidate_assets to return current balance
         self.firm.liquidate_assets.side_effect = lambda tick: self.firm.finance.balance
 
+        # Mock Protocol Methods
+        self.firm.get_all_items.side_effect = lambda: self.firm.inventory
+        self.firm.get_liquidation_config.side_effect = lambda: LiquidationConfigDTO(
+            haircut=getattr(self.firm.config, "fire_sale_discount", 0.2),
+            initial_prices={},
+            default_price=10.0,
+            market_prices=self.firm.last_prices
+        )
+
+        def get_all_claims_side_effect(ctx):
+            claims = []
+            if ctx.hr_service:
+                claims.extend(ctx.hr_service.calculate_liquidation_employee_claims(self.firm, ctx.current_tick))
+            if ctx.tax_service:
+                claims.extend(ctx.tax_service.calculate_liquidation_tax_claims(self.firm))
+            if self.firm.total_debt > 0:
+                bank_id = "bank"
+                if self.firm.decision_engine and self.firm.decision_engine.loan_market and self.firm.decision_engine.loan_market.bank:
+                    bank_id = self.firm.decision_engine.loan_market.bank.id
+                claims.append(Claim(creditor_id=bank_id, amount=self.firm.total_debt, tier=2, description="Secured Loan"))
+            return claims
+
+        self.firm.get_all_claims.side_effect = get_all_claims_side_effect
+        self.firm.get_equity_stakes.return_value = []
+        self.firm.clear_inventory.side_effect = lambda: self.firm.inventory.clear()
+
         self.firm.inventory = {}
         self.firm.last_prices = {}
-        self.firm.hr = MagicMock()
-        self.firm.hr.employees = []
-        self.firm.hr.employee_wages = {}
-        self.firm.hr.unpaid_wages = {}
+        self.firm.hr_state = MagicMock()
+        self.firm.hr_state.employees = []
+        self.firm.hr_state.employee_wages = {}
+        self.firm.hr_state.unpaid_wages = {}
+        # Alias for backward compatibility in test setup
+        self.firm.hr = self.firm.hr_state
         self.firm.total_shares = 1000.0
         self.firm.treasury_shares = 0.0
         self.firm.total_debt = 0.0
@@ -184,6 +218,11 @@ class TestLiquidationWaterfallIntegration(unittest.TestCase):
         self.state.agents["bank"] = bank
         self.state.agents[201] = shareholder
 
+        # Override get_equity_stakes for this test
+        self.firm.get_equity_stakes.return_value = [
+             EquityStake(shareholder_id=201, ratio=0.5)
+        ]
+
         # Run
         self.manager.initiate_liquidation(self.firm, self.state)
 
@@ -266,7 +305,7 @@ class TestLiquidationWaterfallIntegration(unittest.TestCase):
             self.mock_public_manager,
             self.firm,
             800.0,
-            "Asset Liquidation (Inventory) - Firm 1",
+            "Asset Liquidation (Inventory) - Agent 1",
             currency=DEFAULT_CURRENCY
         )
 
