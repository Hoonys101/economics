diff --git a/communications/insights/WO-211-Liquidation-Refactor.md b/communications/insights/WO-211-Liquidation-Refactor.md
new file mode 100644
index 0000000..33bb1b8
--- /dev/null
+++ b/communications/insights/WO-211-Liquidation-Refactor.md
@@ -0,0 +1,22 @@
+# Insight: WO-211 Refactoring LiquidationManager
+
+## Overview
+Refactored `LiquidationManager` to adhere to the Single Responsibility Principle (SRP) by extracting claim calculation logic into dedicated services (`HRService`, `TaxService`) and introducing an `AgentRegistry` for agent resolution.
+
+## Changes
+- Created `IHRService`, `ITaxService`, `IAgentRegistry` interfaces.
+- Implemented `HRService`, `TaxService`, `AgentRegistry`.
+- Refactored `LiquidationManager` to use these services instead of hardcoded logic.
+- Updated `LifecycleManager` to initialize and inject these dependencies.
+- Added and updated tests to verify the new architecture.
+
+## Technical Debt & Observations
+- **Mocking**: The `Firm` class was difficult to mock in unit tests due to `spec=Firm` enforcing class attributes while `finance` is added dynamically in `__init__`. Relaxed strict mocking for `firm` in `test_liquidation_manager.py`.
+- **Imports**: Circular imports or `NameError` in `TYPE_CHECKING` blocks required careful handling of `from __future__ import annotations`.
+- **Dependency Injection**: `LifecycleManager` is becoming a heavy composition root. Future refactoring might consider a dedicated DI container or factory.
+- **Agent Registry**: `AgentRegistry` currently wraps `SimulationState.agents`. It needs to be explicitly updated with `set_state(state)` every tick in `LifecycleManager`. Added fallback logic to `get_agent` to ensure `government` is resolvable even if not present in the main `agents` dictionary during intermediate states.
+
+## Verification
+- Unit tests for `LiquidationManager` pass.
+- Integration tests for `LiquidationServices` pass.
+- Integration tests for `LiquidationWaterfall` pass.
diff --git a/modules/common/dtos.py b/modules/common/dtos.py
new file mode 100644
index 0000000..a7ff56c
--- /dev/null
+++ b/modules/common/dtos.py
@@ -0,0 +1,10 @@
+from dataclasses import dataclass
+from typing import Any
+
+@dataclass
+class Claim:
+    """Represents a creditor's claim against a liquidating entity."""
+    creditor_id: Any
+    amount: float
+    tier: int
+    description: str
diff --git a/modules/finance/api.py b/modules/finance/api.py
index 3127c15..6a028fc 100644
--- a/modules/finance/api.py
+++ b/modules/finance/api.py
@@ -1,3 +1,4 @@
+from __future__ import annotations
 from typing import Protocol, Dict, List, Any, Optional, TypedDict, Literal, Tuple, runtime_checkable, TYPE_CHECKING
 from dataclasses import dataclass
 import abc
@@ -7,6 +8,7 @@ from uuid import UUID
 if TYPE_CHECKING:
     from modules.simulation.api import IGovernment, EconomicIndicatorsDTO
     from simulation.models import Order, Transaction
+    from modules.common.dtos import Claim
 
 # Forward reference for type hinting
 class Firm: pass
@@ -442,3 +444,9 @@ class IHeirProvider(Protocol):
     def get_heir(self) -> Any: # Should resolve to IPortfolioHandler & IFinancialEntity
         """Returns the designated heir, or None if there is no heir."""
         ...
+
+class ITaxService(ABC):
+    @abstractmethod
+    def calculate_liquidation_tax_claims(self, firm: Firm) -> List[Claim]:
+        """Calculates corporate tax claims for a firm in liquidation."""
+        ...
diff --git a/modules/finance/service.py b/modules/finance/service.py
new file mode 100644
index 0000000..6d94e5b
--- /dev/null
+++ b/modules/finance/service.py
@@ -0,0 +1,34 @@
+from __future__ import annotations
+from typing import List, TYPE_CHECKING
+from modules.finance.api import ITaxService
+from modules.common.dtos import Claim
+
+if TYPE_CHECKING:
+    from simulation.firms import Firm
+    from modules.system.api import IAgentRegistry
+
+class TaxService(ITaxService):
+    def __init__(self, agent_registry: IAgentRegistry):
+        self.agent_registry = agent_registry
+
+    def calculate_liquidation_tax_claims(self, firm: Firm) -> List[Claim]:
+        claims = []
+        tax_rate = getattr(firm.config, "corporate_tax_rate", 0.0)
+
+        if firm.finance.current_profit > 0:
+            tax_liability = firm.finance.current_profit * tax_rate
+
+            # Find Government ID
+            gov_agent = self.agent_registry.get_agent("government")
+            gov_id = "government"
+            if gov_agent:
+                gov_id = gov_agent.id
+
+            claims.append(Claim(
+                creditor_id=gov_id,
+                amount=tax_liability,
+                tier=3,
+                description="Corporate Tax"
+            ))
+
+        return claims
diff --git a/modules/hr/api.py b/modules/hr/api.py
new file mode 100644
index 0000000..3fb22b4
--- /dev/null
+++ b/modules/hr/api.py
@@ -0,0 +1,13 @@
+from __future__ import annotations
+from abc import ABC, abstractmethod
+from typing import List, TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from modules.common.dtos import Claim
+    from simulation.firms import Firm
+
+class IHRService(ABC):
+    @abstractmethod
+    def calculate_liquidation_employee_claims(self, firm: Firm, current_tick: int) -> List[Claim]:
+        """Calculates all employee-related claims (wages, severance) for a firm in liquidation."""
+        ...
diff --git a/modules/hr/service.py b/modules/hr/service.py
new file mode 100644
index 0000000..84da4b1
--- /dev/null
+++ b/modules/hr/service.py
@@ -0,0 +1,59 @@
+from __future__ import annotations
+from typing import List, TYPE_CHECKING
+from modules.hr.api import IHRService
+from modules.common.dtos import Claim
+
+if TYPE_CHECKING:
+    from simulation.firms import Firm
+
+class HRService(IHRService):
+    def calculate_liquidation_employee_claims(self, firm: Firm, current_tick: int) -> List[Claim]:
+        claims = []
+        ticks_per_year = getattr(firm.config, "ticks_per_year", 365)
+
+        # A. Unpaid Wages
+        # Cap at 3 months (ticks_per_year / 4)
+        wage_cutoff_tick = current_tick - (ticks_per_year // 4)
+        if hasattr(firm.hr, 'unpaid_wages'):
+            for employee_id, wage_records in firm.hr.unpaid_wages.items():
+                # Filter strict 3-month window
+                total_unpaid = sum(amount for tick, amount in wage_records if tick >= wage_cutoff_tick)
+                if total_unpaid > 0:
+                    claims.append(Claim(
+                        creditor_id=employee_id,
+                        amount=total_unpaid,
+                        tier=1,
+                        description="Unpaid Wages"
+                    ))
+
+        # B. Severance Pay
+        # "Accrued severance pay for all employees over the last 3 years of service."
+        accrual_rate_weeks = getattr(firm.config, "severance_pay_weeks", 2.0)
+        ticks_per_week = ticks_per_year / 52.0
+
+        for employee in firm.hr.employees:
+            # Calculate Tenure
+            start_tick = getattr(employee._econ_state, 'employment_start_tick', -1)
+            tenure_years = 0.0
+            if start_tick >= 0:
+                tenure_years = (current_tick - start_tick) / ticks_per_year
+
+            # Cap at 3 years
+            effective_tenure = min(tenure_years, 3.0)
+
+            # Calculate Severance Amount
+            current_wage = firm.hr.employee_wages.get(employee.id, 0.0)
+            if current_wage > 0:
+                # Formula: Years * Weeks/Year * Ticks/Week * Wage/Tick
+                severance_ticks = effective_tenure * accrual_rate_weeks * ticks_per_week
+                severance_amount = severance_ticks * current_wage
+
+                if severance_amount > 0:
+                    claims.append(Claim(
+                        creditor_id=employee.id,
+                        amount=severance_amount,
+                        tier=1,
+                        description=f"Severance ({effective_tenure:.2f} yr)"
+                    ))
+
+        return claims
diff --git a/modules/system/api.py b/modules/system/api.py
index b6d2efd..24b3b4e 100644
--- a/modules/system/api.py
+++ b/modules/system/api.py
@@ -1,6 +1,11 @@
 from __future__ import annotations
 from dataclasses import dataclass, field
-from typing import TypedDict, List, Dict, Optional, Any, Protocol
+from typing import TypedDict, List, Dict, Optional, Any, Protocol, TYPE_CHECKING
+from abc import ABC, abstractmethod
+
+if TYPE_CHECKING:
+    from simulation.agents import Agent
+    from simulation.dtos.api import SimulationState
 
 # --- DTOs for Market Stability Signals ---
 
@@ -123,3 +128,14 @@ class IAssetRecoverySystem(Protocol):
     def get_status_report(self) -> PublicManagerReportDTO:
         """Returns a status report of the manager's state."""
         ...
+
+class IAgentRegistry(ABC):
+    @abstractmethod
+    def get_agent(self, agent_id: Any) -> Optional[Agent]:
+        """Resolves an agent ID to an agent object."""
+        ...
+
+    @abstractmethod
+    def set_state(self, state: SimulationState) -> None:
+        """Updates the registry with the current simulation state."""
+        ...
diff --git a/modules/system/registry.py b/modules/system/registry.py
new file mode 100644
index 0000000..80cb3ed
--- /dev/null
+++ b/modules/system/registry.py
@@ -0,0 +1,29 @@
+from __future__ import annotations
+from typing import Optional, Any, TYPE_CHECKING
+from modules.system.api import IAgentRegistry
+
+if TYPE_CHECKING:
+    from simulation.agents import Agent
+    from simulation.dtos.api import SimulationState
+
+class AgentRegistry(IAgentRegistry):
+    def __init__(self):
+        self._state: Optional[SimulationState] = None
+
+    def set_state(self, state: SimulationState) -> None:
+        self._state = state
+
+    def get_agent(self, agent_id: Any) -> Optional[Agent]:
+        if self._state is None:
+            return None
+
+        agent = self._state.agents.get(agent_id)
+        if agent:
+            return agent
+
+        # Fallback for government if not in agents map
+        if hasattr(self._state, 'government') and self._state.government:
+            if agent_id == "government" or agent_id == self._state.government.id:
+                return self._state.government
+
+        return None
diff --git a/simulation/systems/lifecycle_manager.py b/simulation/systems/lifecycle_manager.py
index 3bfcdde..32f5a20 100644
--- a/simulation/systems/lifecycle_manager.py
+++ b/simulation/systems/lifecycle_manager.py
@@ -16,6 +16,9 @@ from simulation.systems.liquidation_manager import LiquidationManager
 from simulation.ai.vectorized_planner import VectorizedHouseholdPlanner
 from simulation.finance.api import ISettlementSystem
 from modules.system.api import IAssetRecoverySystem
+from modules.system.registry import AgentRegistry
+from modules.hr.service import HRService
+from modules.finance.service import TaxService
 
 class AgentLifecycleManager(AgentLifecycleManagerInterface):
     """
@@ -35,8 +38,19 @@ class AgentLifecycleManager(AgentLifecycleManagerInterface):
         self.public_manager = public_manager
         self.immigration_manager = ImmigrationManager(config_module=config_module, settlement_system=settlement_system)
 
+        # Dependencies for LiquidationManager
+        self.agent_registry = AgentRegistry()
+        self.hr_service = HRService()
+        self.tax_service = TaxService(self.agent_registry)
+
         # TD-187: Liquidation Waterfall
-        self.liquidation_manager = LiquidationManager(settlement_system, public_manager)
+        self.liquidation_manager = LiquidationManager(
+            settlement_system,
+            self.hr_service,
+            self.tax_service,
+            self.agent_registry,
+            public_manager
+        )
 
         self.breeding_planner = VectorizedHouseholdPlanner(config_module)
         self.logger = logger
@@ -48,6 +62,9 @@ class AgentLifecycleManager(AgentLifecycleManagerInterface):
             List[Transaction]: Transactions generated by lifecycle events (e.g., inheritance)
                                to be queued for the NEXT tick.
         """
+        # Update AgentRegistry with current state
+        self.agent_registry.set_state(state)
+
         # 1. Aging (and internal lifecycle update)
         self.demographic_manager.process_aging(state.households, state.time, state.market_data)
 
diff --git a/simulation/systems/liquidation_manager.py b/simulation/systems/liquidation_manager.py
index 2884053..eb4c41c 100644
--- a/simulation/systems/liquidation_manager.py
+++ b/simulation/systems/liquidation_manager.py
@@ -1,32 +1,35 @@
 from __future__ import annotations
-from dataclasses import dataclass, field
-from typing import List, Dict, Any, TYPE_CHECKING, Optional
+from typing import List, TYPE_CHECKING, Optional, Any
 import logging
+from modules.common.dtos import Claim
 
 if TYPE_CHECKING:
     from simulation.firms import Firm
     from simulation.finance.api import ISettlementSystem
     from simulation.dtos.api import SimulationState
-    from modules.system.api import IAssetRecoverySystem
+    from modules.system.api import IAssetRecoverySystem, IAgentRegistry
+    from modules.hr.api import IHRService
+    from modules.finance.api import ITaxService
 
 logger = logging.getLogger(__name__)
 
-@dataclass
-class Claim:
-    """Represents a creditor's claim against the firm."""
-    creditor_id: Any
-    amount: float
-    tier: int
-    description: str
-
 class LiquidationManager:
     """
     Manages the liquidation waterfall process for insolvent firms.
     Implements TD-187 Protocol.
+    Refactored to comply with SRP (WO-211).
     """
 
-    def __init__(self, settlement_system: ISettlementSystem, public_manager: Optional[IAssetRecoverySystem] = None):
+    def __init__(self,
+                 settlement_system: ISettlementSystem,
+                 hr_service: IHRService,
+                 tax_service: ITaxService,
+                 agent_registry: IAgentRegistry,
+                 public_manager: Optional[IAssetRecoverySystem] = None):
         self.settlement_system = settlement_system
+        self.hr_service = hr_service
+        self.tax_service = tax_service
+        self.agent_registry = agent_registry
         self.public_manager = public_manager
 
     def initiate_liquidation(self, firm: Firm, state: SimulationState) -> None:
@@ -47,16 +50,40 @@ class LiquidationManager:
         # Re-fetch cash after liquidation
         available_cash = firm.finance.balance
 
-        # 1. Calculate Claims
-        claims = self.calculate_claims(firm, state)
+        all_claims: List[Claim] = []
+
+        # 1. Get HR Claims (Tier 1)
+        employee_claims = self.hr_service.calculate_liquidation_employee_claims(firm, current_tick)
+        all_claims.extend(employee_claims)
+
+        # 2. Get Tax Claims (Tier 3)
+        tax_claims = self.tax_service.calculate_liquidation_tax_claims(firm)
+        all_claims.extend(tax_claims)
+
+        # 3. Get Secured Debt Claims (Tier 2)
+        # Query firm.finance for secured debt (e.g., bank loans).
+        total_debt = getattr(firm, 'total_debt', 0.0)
+        bank_agent = None
+        if hasattr(firm, 'decision_engine') and hasattr(firm.decision_engine, 'loan_market'):
+            loan_market = firm.decision_engine.loan_market
+            if loan_market and hasattr(loan_market, 'bank') and loan_market.bank:
+                bank_agent = loan_market.bank
+
+        if total_debt > 0:
+            all_claims.append(Claim(
+                creditor_id=bank_agent.id if bank_agent else "BANK_UNKNOWN",
+                amount=total_debt,
+                tier=2,
+                description="Secured Loan"
+            ))
 
         logger.info(
-            f"LIQUIDATION_START | Firm {firm.id} starting liquidation. Assets: {available_cash:.2f}, Total Claims: {sum(c.amount for c in claims):.2f}",
+            f"LIQUIDATION_START | Firm {firm.id} starting liquidation. Assets: {available_cash:.2f}, Total Claims: {sum(c.amount for c in all_claims):.2f}",
             extra={"tick": current_tick, "agent_id": firm.id, "tags": ["liquidation", "waterfall"]}
         )
 
-        # 2. Execute Waterfall
-        self.execute_waterfall(firm, claims, available_cash, state)
+        # 4. Execute Waterfall
+        self.execute_waterfall(firm, all_claims, available_cash, state)
 
     def _liquidate_assets(self, firm: Firm, state: SimulationState):
         """
@@ -119,132 +146,10 @@ class LiquidationManager:
             else:
                 logger.error(f"LIQUIDATION_ASSET_SALE_FAIL | PublicManager failed to pay {total_value:.2f} to Firm {firm.id}.")
 
-    def calculate_claims(self, firm: Firm, state: SimulationState) -> List[Claim]:
-        """
-        Calculates all claims and assigns priority tiers.
-        Tier 1: Employee Severance & Unpaid Wages
-        Tier 2: Secured Creditors (Loans)
-        Tier 3: Unsecured Priority (Taxes)
-        Tier 4: General Unsecured
-        Tier 5: Equity Holders
-        """
-        claims = []
-        ticks_per_year = getattr(firm.config, "ticks_per_year", 365)
-
-        # --- Tier 1: Employee Entitlements ---
-
-        # A. Unpaid Wages (from HR tracking)
-        # Cap at 3 months (ticks_per_year / 4)
-        wage_cutoff_tick = state.time - (ticks_per_year // 4)
-
-        if hasattr(firm.hr, 'unpaid_wages'):
-            for employee_id, wage_records in firm.hr.unpaid_wages.items():
-                # Filter strict 3-month window
-                total_unpaid = sum(amount for tick, amount in wage_records if tick >= wage_cutoff_tick)
-                if total_unpaid > 0:
-                    claims.append(Claim(
-                        creditor_id=employee_id,
-                        amount=total_unpaid,
-                        tier=1,
-                        description="Unpaid Wages"
-                    ))
-
-        # B. Severance Pay
-        # "Accrued severance pay for all employees over the last 3 years of service."
-
-        accrual_rate_weeks = getattr(firm.config, "severance_pay_weeks", 2.0)
-        current_tick = state.time
-        ticks_per_week = ticks_per_year / 52.0
-
-        for employee in firm.hr.employees:
-            # Calculate Tenure
-            start_tick = getattr(employee._econ_state, 'employment_start_tick', -1)
-            tenure_years = 0.0
-            if start_tick >= 0:
-                tenure_years = (current_tick - start_tick) / ticks_per_year
-
-            # Cap at 3 years
-            effective_tenure = min(tenure_years, 3.0)
-
-            # Calculate Severance Amount
-            current_wage = firm.hr.employee_wages.get(employee.id, 0.0)
-            if current_wage > 0:
-                # Formula: Years * Weeks/Year * Ticks/Week * Wage/Tick
-                severance_ticks = effective_tenure * accrual_rate_weeks * ticks_per_week
-                severance_amount = severance_ticks * current_wage
-
-                if severance_amount > 0:
-                    claims.append(Claim(
-                        creditor_id=employee.id,
-                        amount=severance_amount,
-                        tier=1,
-                        description=f"Severance ({effective_tenure:.2f} yr)"
-                    ))
-
-        # --- Tier 2: Secured Creditors (Bank Loans) ---
-        # Query bank if possible
-        total_debt = getattr(firm, 'total_debt', 0.0)
-        # Attempt to get exact creditor (Bank)
-        bank_agent = None
-        if hasattr(firm, 'decision_engine') and hasattr(firm.decision_engine, 'loan_market'):
-            loan_market = firm.decision_engine.loan_market
-            if loan_market and hasattr(loan_market, 'bank') and loan_market.bank:
-                bank_agent = loan_market.bank
-
-        if total_debt > 0:
-            claims.append(Claim(
-                creditor_id=bank_agent.id if bank_agent else "BANK_UNKNOWN",
-                amount=total_debt,
-                tier=2,
-                description="Secured Loan"
-            ))
-
-        # --- Tier 3: Unsecured Priority (Taxes) ---
-        # We assume current tick's tax liability if profit exists, plus any potential unpaid backlog (not tracked currently).
-        # We'll rely on what FinanceDepartment would have paid.
-        # But FinanceDepartment calcs tax on *paid* revenue? Or accrued?
-        # `generate_tax_transaction` uses `revenue_this_turn`.
-        # If we are liquidating, we might have revenue from inventory liquidation (if we sold it).
-        # But here we are distributing CASH.
-        # Let's estimate tax on `retained_earnings` if that's a proxy for untaxed profit?
-        # Or better: `current_profit` * `corporate_tax_rate`.
-
-        tax_rate = getattr(firm.config, "corporate_tax_rate", 0.0)
-        if firm.finance.current_profit > 0:
-            tax_liability = firm.finance.current_profit * tax_rate
-
-            # Find Government ID
-            # Usually passed in methods, but we need to find it.
-            # Using 'system' or looking up via settlement system if possible?
-            # Or pass it in? `initiate_liquidation` doesn't take gov.
-            # We can use a string placeholder if ID unknown, but SettlementSystem needs valid ID.
-            # We will try to find "government" in firm's known agents or similar.
-            # But usually tax is paid to ID 0 or "government".
-            # Let's assume there is a government agent.
-            # Workaround: Use string "government" if ID not found, but SettlementSystem might fail.
-            # Better: `LiquidationManager` should ideally have access to registry.
-            # But for now, let's leave creditor_id as "government" and handle resolution in execute.
-
-            claims.append(Claim(
-                creditor_id="government",
-                amount=tax_liability,
-                tier=3,
-                description="Corporate Tax"
-            ))
-
-        # --- Tier 5: Equity Holders (Shareholders) ---
-        # We don't add them as fixed claims because they are residual.
-        # But to be consistent with "Waterfall", we can add them as claims equal to their share % * remaining.
-        # But the standard way is: Claims are fixed. Equity gets *everything else*.
-        # So we won't add them to the list of fixed claims. We handle them as the "Residual" tier in execution.
-
-        return claims
-
     def execute_waterfall(self, firm: Firm, claims: List[Claim], available_cash: float, state: SimulationState) -> None:
         """
         Distributes cash according to tiers.
         """
-        current_tick = state.time
         remaining_cash = available_cash
 
         # Sort claims by tier
@@ -272,7 +177,7 @@ class LiquidationManager:
             if remaining_cash >= total_tier_claim:
                 # Pay all fully
                 for claim in tier_claims:
-                    self._pay_claim(firm, claim, claim.amount, state)
+                    self._pay_claim(firm, claim, claim.amount)
                 remaining_cash -= total_tier_claim
                 logger.info(f"LIQUIDATION_WATERFALL | Tier {tier} fully paid. Remaining cash: {remaining_cash:.2f}")
             else:
@@ -280,7 +185,7 @@ class LiquidationManager:
                 factor = remaining_cash / total_tier_claim
                 for claim in tier_claims:
                     payment = claim.amount * factor
-                    self._pay_claim(firm, claim, payment, state, partial=True)
+                    self._pay_claim(firm, claim, payment, partial=True)
                 remaining_cash = 0.0
                 logger.info(f"LIQUIDATION_WATERFALL | Tier {tier} partially paid (Factor: {factor:.2f}). Cash exhausted.")
 
@@ -307,24 +212,13 @@ class LiquidationManager:
 
                 logger.info(f"LIQUIDATION_WATERFALL | Tier 5 (Equity) distributed {total_distributed:.2f} to shareholders.")
 
-    def _pay_claim(self, firm: Firm, claim: Claim, amount: float, state: SimulationState, partial: bool = False):
-        """Helper to execute transfer."""
+    def _pay_claim(self, firm: Firm, claim: Claim, amount: float, partial: bool = False):
+        """Helper to execute transfer using AgentRegistry."""
         if amount <= 0:
             return
 
         creditor_id = claim.creditor_id
-        creditor = None
-
-        # Resolve Creditor Object
-        if creditor_id == "government":
-            if hasattr(state, "government"):
-                creditor = state.government
-        elif creditor_id in state.agents:
-            creditor = state.agents[creditor_id]
-        else:
-             # Try households list if not in main agents map (though it should be)
-             # or look in other lists
-             pass
+        creditor = self.agent_registry.get_agent(creditor_id)
 
         if creditor:
             memo = f"Liquidation Payout: {claim.description}" + (" (Partial)" if partial else "")
diff --git a/tests/integration/test_liquidation_services.py b/tests/integration/test_liquidation_services.py
new file mode 100644
index 0000000..9fa2b82
--- /dev/null
+++ b/tests/integration/test_liquidation_services.py
@@ -0,0 +1,87 @@
+import unittest
+from unittest.mock import MagicMock
+from simulation.firms import Firm
+from simulation.core_agents import Household
+from modules.hr.service import HRService
+from modules.finance.service import TaxService
+from modules.system.registry import AgentRegistry
+from simulation.dtos.config_dtos import FirmConfigDTO
+
+class TestLiquidationServices(unittest.TestCase):
+    def setUp(self):
+        self.hr_service = HRService()
+        self.agent_registry = AgentRegistry()
+        self.tax_service = TaxService(self.agent_registry)
+
+        # Mock Config
+        self.config = MagicMock(spec=FirmConfigDTO)
+        self.config.ticks_per_year = 365
+        self.config.severance_pay_weeks = 2.0
+        self.config.corporate_tax_rate = 0.2
+
+        # Mock Firm
+        self.firm = MagicMock(spec=Firm)
+        self.firm.config = self.config
+        self.firm.hr = MagicMock()
+        self.firm.finance = MagicMock()
+        self.firm.id = 1
+        self.firm.finance.current_profit = 0.0
+
+    def test_hr_service_unpaid_wages(self):
+        current_tick = 1000
+        # Wage cutoff = 1000 - 91 = 909
+
+        # Employee 1: Unpaid wages 500 (tick 950 - OK)
+        # Employee 2: Unpaid wages 500 (tick 800 - Too Old)
+
+        self.firm.hr.unpaid_wages = {
+            101: [(950, 500.0)],
+            102: [(800, 500.0)]
+        }
+        self.firm.hr.employees = []
+        self.firm.hr.employee_wages = {}
+
+        claims = self.hr_service.calculate_liquidation_employee_claims(self.firm, current_tick)
+
+        self.assertEqual(len(claims), 1)
+        self.assertEqual(claims[0].creditor_id, 101)
+        self.assertEqual(claims[0].amount, 500.0)
+        self.assertEqual(claims[0].tier, 1)
+
+    def test_hr_service_severance(self):
+        current_tick = 2000
+
+        # Employee: 2 years tenure
+        # Start tick = 2000 - (365 * 2) = 1270
+        emp = MagicMock()
+        emp.id = 101
+        emp._econ_state.employment_start_tick = 1270
+
+        self.firm.hr.employees = [emp]
+        self.firm.hr.employee_wages = {101: 100.0}
+        self.firm.hr.unpaid_wages = {}
+
+        # Severance = 2 yrs * 2 weeks/yr * 7.019 ticks/week * 100 wage
+        # ticks_per_week = 365/52 = 7.01923
+        # 2 * 2 * 7.019 * 100 = 2807.69
+
+        claims = self.hr_service.calculate_liquidation_employee_claims(self.firm, current_tick)
+
+        self.assertEqual(len(claims), 1)
+        self.assertEqual(claims[0].creditor_id, 101)
+        self.assertAlmostEqual(claims[0].amount, 2807.69, delta=1.0)
+
+    def test_tax_service(self):
+        self.firm.finance.current_profit = 1000.0
+
+        # Mock Registry to return Government
+        gov_agent = MagicMock()
+        gov_agent.id = "gov_real_id"
+        self.agent_registry.get_agent = MagicMock(return_value=gov_agent)
+
+        claims = self.tax_service.calculate_liquidation_tax_claims(self.firm)
+
+        self.assertEqual(len(claims), 1)
+        self.assertEqual(claims[0].creditor_id, "gov_real_id")
+        self.assertEqual(claims[0].amount, 200.0) # 20% of 1000
+        self.assertEqual(claims[0].tier, 3)
diff --git a/tests/integration/test_liquidation_waterfall.py b/tests/integration/test_liquidation_waterfall.py
index 87ec0f2..b40daa4 100644
--- a/tests/integration/test_liquidation_waterfall.py
+++ b/tests/integration/test_liquidation_waterfall.py
@@ -2,12 +2,16 @@ import unittest
 from unittest.mock import MagicMock, Mock
 from typing import List
 
-from simulation.systems.liquidation_manager import LiquidationManager, Claim
+from simulation.systems.liquidation_manager import LiquidationManager
+from modules.common.dtos import Claim
 from simulation.firms import Firm
 from simulation.core_agents import Household
 from simulation.dtos.api import SimulationState
 from simulation.dtos.config_dtos import FirmConfigDTO
 from modules.system.api import IAssetRecoverySystem
+from modules.system.registry import AgentRegistry
+from modules.hr.service import HRService
+from modules.finance.service import TaxService
 
 class TestLiquidationWaterfallIntegration(unittest.TestCase):
     def setUp(self):
@@ -17,7 +21,18 @@ class TestLiquidationWaterfallIntegration(unittest.TestCase):
         self.mock_public_manager.id = 999
         self.mock_settlement.transfer.return_value = True # Default success
 
-        self.manager = LiquidationManager(self.mock_settlement, self.mock_public_manager)
+        # Use Real Services
+        self.agent_registry = AgentRegistry()
+        self.hr_service = HRService()
+        self.tax_service = TaxService(self.agent_registry)
+
+        self.manager = LiquidationManager(
+            self.mock_settlement,
+            self.hr_service,
+            self.tax_service,
+            self.agent_registry,
+            self.mock_public_manager
+        )
 
         # Setup Config
         self.config = MagicMock(spec=FirmConfigDTO)
@@ -54,6 +69,9 @@ class TestLiquidationWaterfallIntegration(unittest.TestCase):
         # Mock shares_owned.get for government to avoid TypeError
         self.state.government.shares_owned.get.return_value = 0.0
 
+    def _setup_registry(self):
+        self.agent_registry.set_state(self.state)
+
     def test_severance_priority_over_shareholders(self):
         """
         Verify that employees receive severance before shareholders receive any dividends.
@@ -65,6 +83,7 @@ class TestLiquidationWaterfallIntegration(unittest.TestCase):
         - Shortfall: 600.
         - Expected: Employees get pro-rata (5000/5600 ratio). Shareholders get 0.
         """
+        self._setup_registry()
         self.firm.finance.balance = 5000.0
 
         # Employee A
@@ -130,6 +149,7 @@ class TestLiquidationWaterfallIntegration(unittest.TestCase):
         - Remaining: 3000.
         - Tier 5 (Equity): Should receive 3000.
         """
+        self._setup_registry()
         self.firm.finance.balance = 10000.0
 
         # Employee (Tier 1) - 2000 claim
@@ -202,6 +222,7 @@ class TestLiquidationWaterfallIntegration(unittest.TestCase):
         - Employee paid 500.0.
         - Equity (or Escheatment) gets 300.0.
         """
+        self._setup_registry()
         self.firm.finance.balance = 0.0
         self.firm.inventory = {"apples": 100.0}
         self.firm.last_prices = {"apples": 10.0}
diff --git a/tests/unit/systems/test_liquidation_manager.py b/tests/unit/systems/test_liquidation_manager.py
index 09b6558..26d64b7 100644
--- a/tests/unit/systems/test_liquidation_manager.py
+++ b/tests/unit/systems/test_liquidation_manager.py
@@ -1,150 +1,97 @@
 import unittest
-from unittest.mock import MagicMock, Mock
-from typing import List, Dict, Any
+from unittest.mock import MagicMock, call
+from typing import List
 
-from simulation.systems.liquidation_manager import LiquidationManager, Claim
+from simulation.systems.liquidation_manager import LiquidationManager
+from modules.common.dtos import Claim
 from simulation.firms import Firm
-from simulation.core_agents import Household
 from simulation.dtos.api import SimulationState
+from modules.system.api import IAssetRecoverySystem, IAgentRegistry
+from modules.hr.api import IHRService
+from modules.finance.api import ITaxService
+from simulation.finance.api import ISettlementSystem
 
 class TestLiquidationManager(unittest.TestCase):
     def setUp(self):
-        self.mock_settlement = MagicMock()
-        self.manager = LiquidationManager(self.mock_settlement)
-
-        # Mock State
-        self.mock_state = MagicMock(spec=SimulationState)
-        self.mock_state.time = 1000
-        self.mock_state.households = []
-        self.mock_state.government = MagicMock()
-        self.mock_state.government.id = "government"
-        self.mock_state.agents = {"government": self.mock_state.government}
-
-        # Mock Firm
-        self.mock_firm = MagicMock(spec=Firm)
-        self.mock_firm.id = 1
-        self.mock_firm.config = MagicMock()
-        self.mock_firm.config.ticks_per_year = 365
-        self.mock_firm.config.severance_pay_weeks = 2.0
-        self.mock_firm.config.corporate_tax_rate = 0.2
-        self.mock_firm.finance = MagicMock()
-        self.mock_firm.finance.balance = 0.0
-        self.mock_firm.finance.current_profit = 0.0
-        self.mock_firm.hr = MagicMock()
-        self.mock_firm.hr.employees = []
-        self.mock_firm.hr.unpaid_wages = {}
-        self.mock_firm.hr.employee_wages = {}
-        self.mock_firm.total_shares = 100.0
-        self.mock_firm.treasury_shares = 0.0
-        self.mock_firm.total_debt = 0.0
-
-    def test_calculate_claims_severance(self):
-        # Setup Employee with 2 years tenure
-        emp1 = MagicMock(spec=Household)
-        emp1.id = 101
-        emp1._econ_state = MagicMock()
-        emp1._econ_state.employment_start_tick = 1000 - (365 * 2) # 2 years ago
-
-        self.mock_firm.hr.employees = [emp1]
-        self.mock_firm.hr.employee_wages = {101: 100.0} # Wage 100
-
-        # Severance = 2 years * 2 weeks * (365/52) ticks/week * 100 wage
-        # ticks_per_week = 7.01923
-        # severance_ticks = 2.0 * 2.0 * 7.01923 = 28.0769
-        # amount = 28.0769 * 100.0 = 2807.69
-
-        claims = self.manager.calculate_claims(self.mock_firm, self.mock_state)
-
-        self.assertEqual(len(claims), 1)
-        self.assertEqual(claims[0].tier, 1)
-        self.assertEqual(claims[0].creditor_id, 101)
-        self.assertIn("Severance", claims[0].description)
-        self.assertAlmostEqual(claims[0].amount, 2807.69, delta=1.0)
-
-    def test_calculate_claims_unpaid_wages(self):
-        # Current tick 1000. Cutoff 1000 - 91 = 909.
-        self.mock_firm.hr.unpaid_wages = {
-            102: [(900, 50.0), (950, 50.0)] # 900 filtered out. Total 50.
-        }
-
-        claims = self.manager.calculate_claims(self.mock_firm, self.mock_state)
-
-        self.assertEqual(len(claims), 1)
-        self.assertEqual(claims[0].tier, 1)
-        self.assertEqual(claims[0].creditor_id, 102)
-        self.assertEqual(claims[0].amount, 50.0) # Filtered result
-        self.assertEqual(claims[0].description, "Unpaid Wages")
-
-    def test_calculate_claims_debt_and_tax(self):
-        self.mock_firm.total_debt = 5000.0
-        self.mock_firm.finance.current_profit = 1000.0
-        # Tax = 1000 * 0.2 = 200.0
-
-        claims = self.manager.calculate_claims(self.mock_firm, self.mock_state)
-
-        # Claims: Debt (Tier 2), Tax (Tier 3)
-        self.assertEqual(len(claims), 2)
-
-        debt_claim = next(c for c in claims if c.tier == 2)
-        self.assertEqual(debt_claim.amount, 5000.0)
-
-        tax_claim = next(c for c in claims if c.tier == 3)
-        self.assertEqual(tax_claim.amount, 200.0)
-        self.assertEqual(tax_claim.creditor_id, "government")
-
-    def test_execute_waterfall_full_payment(self):
-        claims = [
-            Claim(101, 100.0, 1, "Severance"),
-            Claim("bank", 200.0, 2, "Loan"),
-        ]
-        available_cash = 400.0 # Enough for all + equity
-
-        self.mock_firm.finance.balance = available_cash
-        self.mock_state.agents[101] = MagicMock()
-        self.mock_state.agents["bank"] = MagicMock()
-
-        # Mock shareholders to return 0 shares to avoid Equity loop failing on MagicMock > 0
-        self.mock_state.households = []
-        self.mock_state.government = MagicMock()
-        self.mock_state.government.shares_owned.get.return_value = 0.0
-
-        self.manager.execute_waterfall(self.mock_firm, claims, available_cash, self.mock_state)
-
-        # Verify calls to settlement system
-        # Tier 1
-        self.mock_settlement.transfer.assert_any_call(self.mock_firm, self.mock_state.agents[101], 100.0, "Liquidation Payout: Severance")
-        # Tier 2
-        self.mock_settlement.transfer.assert_any_call(self.mock_firm, self.mock_state.agents["bank"], 200.0, "Liquidation Payout: Loan")
-
-        # Remaining 100 to equity?
-        # We need mock shareholders
-        # But this test didn't setup shareholders in state.households properly to verify equity,
-        # but verified tiers 1 and 2.
-
-    def test_execute_waterfall_pro_rata(self):
-        claims = [
-            Claim(101, 100.0, 1, "Severance"),
-            Claim(102, 100.0, 1, "Severance"),
-            Claim("bank", 500.0, 2, "Loan"),
-        ]
-        available_cash = 150.0
-        # Tier 1 Total: 200. Cash: 150.
-        # Pro-rata: 150 / 200 = 0.75
-        # Each gets 75.0
-
-        self.mock_state.agents[101] = MagicMock()
-        self.mock_state.agents[102] = MagicMock()
-
-        self.manager.execute_waterfall(self.mock_firm, claims, available_cash, self.mock_state)
-
-        self.mock_settlement.transfer.assert_any_call(self.mock_firm, self.mock_state.agents[101], 75.0, "Liquidation Payout: Severance (Partial)")
-        self.mock_settlement.transfer.assert_any_call(self.mock_firm, self.mock_state.agents[102], 75.0, "Liquidation Payout: Severance (Partial)")
-
-        # Tier 2 gets nothing
-        # Check call args to ensure bank wasn't paid
-        transfers = self.mock_settlement.transfer.call_args_list
-        # Should be 2 calls
-        self.assertEqual(len(transfers), 2)
-
-if __name__ == '__main__':
-    unittest.main()
+        self.mock_settlement = MagicMock(spec=ISettlementSystem)
+        self.mock_hr = MagicMock(spec=IHRService)
+        self.mock_tax = MagicMock(spec=ITaxService)
+        self.mock_registry = MagicMock(spec=IAgentRegistry)
+        self.mock_public = MagicMock(spec=IAssetRecoverySystem)
+
+        self.manager = LiquidationManager(
+            self.mock_settlement,
+            self.mock_hr,
+            self.mock_tax,
+            self.mock_registry,
+            self.mock_public
+        )
+
+        self.firm = MagicMock()
+        self.firm.id = 1
+        self.firm.finance.balance = 1000.0
+        self.firm.total_shares = 1000.0
+        self.firm.treasury_shares = 0.0
+        self.firm.total_debt = 0.0
+        # Mock last_prices and inventory for asset liquidation check
+        self.firm.last_prices = {}
+        self.firm.inventory = {}
+        self.firm.config = MagicMock()
+
+        self.state = MagicMock(spec=SimulationState)
+        self.state.time = 100
+        # For shareholder iteration in tier 5
+        self.state.households = []
+        self.state.government = None
+
+    def test_initiate_liquidation_orchestration(self):
+        # Setup Claims returned by services
+        claim_hr = Claim(creditor_id=101, amount=100.0, tier=1, description="Wage")
+        claim_tax = Claim(creditor_id="gov", amount=50.0, tier=3, description="Tax")
+
+        self.mock_hr.calculate_liquidation_employee_claims.return_value = [claim_hr]
+        self.mock_tax.calculate_liquidation_tax_claims.return_value = [claim_tax]
+
+        # Mock Registry resolution
+        agent_101 = MagicMock()
+        agent_101.id = 101
+        agent_gov = MagicMock()
+        agent_gov.id = "gov"
+
+        self.mock_registry.get_agent.side_effect = lambda x: {101: agent_101, "gov": agent_gov}.get(x)
+        self.mock_settlement.transfer.return_value = True
+
+        # Run
+        self.manager.initiate_liquidation(self.firm, self.state)
+
+        # Verify Services Called
+        self.mock_hr.calculate_liquidation_employee_claims.assert_called_once_with(self.firm, 100)
+        self.mock_tax.calculate_liquidation_tax_claims.assert_called_once_with(self.firm)
+
+        # Verify Transfers
+        # Expect transfers for both claims
+        self.mock_settlement.transfer.assert_has_calls([
+            call(self.firm, agent_101, 100.0, "Liquidation Payout: Wage"),
+            call(self.firm, agent_gov, 50.0, "Liquidation Payout: Tax")
+        ], any_order=True)
+
+    def test_bank_claim_handling(self):
+        self.mock_hr.calculate_liquidation_employee_claims.return_value = []
+        self.mock_tax.calculate_liquidation_tax_claims.return_value = []
+
+        # Setup Bank Debt
+        self.firm.total_debt = 500.0
+        bank = MagicMock()
+        bank.id = "bank_1"
+        self.firm.decision_engine.loan_market.bank = bank
+
+        bank_agent = MagicMock()
+        bank_agent.id = "bank_1"
+        self.mock_registry.get_agent.return_value = bank_agent
+
+        self.manager.initiate_liquidation(self.firm, self.state)
+
+        # Check transfer to bank
+        self.mock_settlement.transfer.assert_called_with(
+            self.firm, bank_agent, 500.0, "Liquidation Payout: Secured Loan"
+        )
