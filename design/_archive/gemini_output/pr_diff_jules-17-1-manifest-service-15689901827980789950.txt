diff --git a/.gitignore b/.gitignore
index b4125fa7..8e9f98b3 100644
--- a/.gitignore
+++ b/.gitignore
@@ -176,7 +176,9 @@ test_error.txt
 
 *.pyc
 design/command_registry.json
-_internal/
+!_internal/
+_internal/*
+!_internal/registry/
 audit-go.bat
 session-go.bat
 reset-go.bat
diff --git a/_internal/registry/__init__.py b/_internal/registry/__init__.py
new file mode 100644
index 00000000..e69de29b
diff --git a/_internal/registry/api.py b/_internal/registry/api.py
new file mode 100644
index 00000000..b9f8dcb6
--- /dev/null
+++ b/_internal/registry/api.py
@@ -0,0 +1,84 @@
+"""
+Mission Registry API Definition.
+Defines the Data Transfer Objects and Service Interface for the Mission Registry System.
+"""
+from dataclasses import dataclass, field
+from typing import List, Dict, Optional, Protocol, Union, Any, runtime_checkable
+from enum import Enum
+
+class MissionType(Enum):
+    JULES = "jules"
+    GEMINI = "gemini"
+
+@dataclass
+class MissionDTO:
+    """
+    Data Transfer Object representing a single mission (task).
+    Unified structure for both Jules and Gemini missions.
+    """
+    key: str
+    title: str
+    type: MissionType
+    instruction_raw: str  # The raw instruction without protocol injections
+
+    # Common Optional
+    status: str = "pending"
+    created_at: str = ""
+
+    # Jules Specific
+    command: Optional[str] = None  # 'create', 'send-message'
+    file_path: Optional[str] = None
+    wait: bool = False
+    session_id: Optional[str] = None
+
+    # Gemini Specific
+    worker: Optional[str] = None  # 'spec', 'reporter', etc.
+    context_files: List[str] = field(default_factory=list)
+    output_path: Optional[str] = None
+    model: Optional[str] = None
+    audit_requirements: Optional[str] = None
+
+@runtime_checkable
+class IMissionRegistryService(Protocol):
+    """
+    Interface for the Mission Registry Service.
+    Handles CRUD operations for missions and protocol injection.
+    """
+
+    def load_missions(self) -> Dict[str, MissionDTO]:
+        """
+        Loads all missions from the persistence layer (mission_db.json).
+        """
+        ...
+
+    def get_mission(self, key: str) -> Optional[MissionDTO]:
+        """
+        Retrieves a specific mission by key.
+        """
+        ...
+
+    def register_mission(self, mission: MissionDTO) -> None:
+        """
+        Saves or updates a mission atomically.
+        """
+        ...
+
+    def delete_mission(self, key: str) -> bool:
+        """
+        Removes a mission by key. Returns True if found and deleted.
+        """
+        ...
+
+    def get_mission_prompt(self, key: str) -> str:
+        """
+        Constructs the full, protocol-compliant prompt for a mission.
+        Injects META, GUARDRAILS, and OUTPUT_DISCIPLINE dynamically.
+        """
+        ...
+
+    def migrate_from_legacy(self, legacy_file_path: str) -> int:
+        """
+        One-time migration from legacy command_manifest.py to mission_db.json.
+        Returns the number of missions migrated.
+        """
+        ...
diff --git a/_internal/registry/mission_protocol.py b/_internal/registry/mission_protocol.py
new file mode 100644
index 00000000..4a2e6586
--- /dev/null
+++ b/_internal/registry/mission_protocol.py
@@ -0,0 +1,57 @@
+"""
+Mission Protocol Definitions.
+Contains the safety protocols and prompt construction logic for missions.
+"""
+
+META = """
+MISSION: {title}
+Mission Key: {key}
+============================================================
+"""
+
+GUARDRAILS = """
+[PROJECT MANDATE]
+============================================================
+
+ðŸ›¡ï¸ [ARCHITECTURAL GUARDRAILS]
+1. Zero-Sum Integrity: No magic money creation/leaks. All transfers must be balanced.
+2. Protocol Purity: Use `@runtime_checkable` Protocols and `isinstance()`. Avoid `hasattr()`.
+3. DTO Purity: Use typed DTOs/Dataclasses for cross-boundary data. Avoid raw dicts.
+4. Logic Separation: Keep business logic in Systems/Services, data in State/Repository.
+
+ðŸš¨ [MANDATORY REPORTING]
+Before completing this task, you MUST create a NEW insight report file at:
+`communications/insights/{key}.md`
+
+DO NOT append to `manual.md` or any other shared file. This is CRITICAL to prevent merge conflicts.
+
+The report MUST include:
+1. [Architectural Insights]: Technical debt identified or architectural decisions made.
+2. [Test Evidence]: Copy-paste the literal output of `pytest` demonstrating that your changes pass.
+(No verified test logs = Submission Rejected)
+
+ðŸ§ª [TESTING DISCIPLINE]
+1. Protocol Fidelity: When mocking Protocols, explicitly implement required methods or use specs. Enforce `isinstance(mock, Protocol)`.
+2. No Mock Drift: Do not invent attributes on mocks. Use `MagicMock(spec=RealClass)`.
+3. Hygiene: NEVER patch `sys.modules` globally in a test file. Use `conftest.py` or `patch.dict`.
+4. Async: Use `pytest-asyncio` with proper loop scope. Avoid mixing thread/process loops.
+"""
+
+OUTPUT_DISCIPLINE = """
+ðŸš¨ [OUTPUT DISCIPLINE]
+1. Output ONLY the file content or the specific Markdown block requested.
+2. DO NOT include conversational preamble (e.g., 'Sure!', 'I have updated...').
+3. Respect code fences and file-level termination rules.
+
+============================================================
+"""
+
+def construct_mission_prompt(key: str, title: str, instruction_raw: str) -> str:
+    """
+    Constructs the full mission prompt by injecting protocols.
+    """
+    prompt = META.format(title=title, key=key)
+    prompt += instruction_raw + "\n\n"
+    prompt += GUARDRAILS.format(key=key)
+    prompt += OUTPUT_DISCIPLINE
+    return prompt
diff --git a/_internal/registry/service.py b/_internal/registry/service.py
new file mode 100644
index 00000000..8ede69aa
--- /dev/null
+++ b/_internal/registry/service.py
@@ -0,0 +1,177 @@
+import json
+import time
+import os
+import shutil
+from pathlib import Path
+from typing import Dict, Optional, Any
+from dataclasses import asdict
+
+from .api import IMissionRegistryService, MissionDTO, MissionType
+from .mission_protocol import construct_mission_prompt
+
+DB_PATH = Path("_internal/registry/mission_db.json")
+LOCK_PATH = Path("_internal/registry/mission.lock")
+
+class MissionLock:
+    def __init__(self, timeout: int = 10):
+        self.timeout = timeout
+        self.lock_file = LOCK_PATH
+
+    def __enter__(self):
+        start_time = time.time()
+        while True:
+            try:
+                # Atomic creation (exclusive creation)
+                self.lock_file.touch(exist_ok=False)
+                break
+            except FileExistsError:
+                if time.time() - start_time > self.timeout:
+                    # Check if lock is stale (e.g. > 30 seconds old)
+                    try:
+                        stat = self.lock_file.stat()
+                        if time.time() - stat.st_mtime > 30:
+                            print(f"Breaking stale lock: {self.lock_file}")
+                            self.lock_file.unlink(missing_ok=True)
+                            continue # Retry immediately
+                    except FileNotFoundError:
+                        pass # Lock gone, retry
+
+                    raise TimeoutError(f"Could not acquire lock after {self.timeout} seconds")
+                time.sleep(0.1)
+
+    def __exit__(self, exc_type, exc_val, exc_tb):
+        if self.lock_file.exists():
+            self.lock_file.unlink()
+
+class MissionRegistryService:
+    def __init__(self, db_path: Path = DB_PATH):
+        self.db_path = db_path
+        # Ensure directory exists
+        if not self.db_path.parent.exists():
+            self.db_path.parent.mkdir(parents=True, exist_ok=True)
+
+    def _load_db(self) -> Dict[str, Any]:
+        if not self.db_path.exists():
+            return {"_meta": {"version": "1.0"}, "missions": {}}
+
+        try:
+            with open(self.db_path, 'r') as f:
+                return json.load(f)
+        except json.JSONDecodeError:
+            return {"_meta": {"version": "1.0"}, "missions": {}}
+
+    def _save_db(self, data: Dict[str, Any]):
+        # Atomic write
+        temp_path = self.db_path.with_suffix('.tmp')
+        with open(temp_path, 'w') as f:
+            json.dump(data, f, indent=2)
+        shutil.move(str(temp_path), str(self.db_path))
+
+    def load_missions(self) -> Dict[str, MissionDTO]:
+        data = self._load_db()
+        missions = {}
+        for key, m_data in data.get("missions", {}).items():
+            # Convert string type back to Enum
+            if isinstance(m_data.get("type"), str):
+                try:
+                    m_data["type"] = MissionType(m_data["type"])
+                except ValueError:
+                    # Fallback to GEMINI if unknown, or log warning
+                    m_data["type"] = MissionType.GEMINI
+
+            missions[key] = MissionDTO(**m_data)
+        return missions
+
+    def get_mission(self, key: str) -> Optional[MissionDTO]:
+        missions = self.load_missions()
+        return missions.get(key)
+
+    def register_mission(self, mission: MissionDTO) -> None:
+        with MissionLock():
+            data = self._load_db()
+
+            # Serialize DTO
+            mission_dict = asdict(mission)
+            mission_dict["type"] = mission.type.value # Enum to string
+
+            if "missions" not in data:
+                data["missions"] = {}
+
+            data["missions"][mission.key] = mission_dict
+            self._save_db(data)
+
+    def delete_mission(self, key: str) -> bool:
+        with MissionLock():
+            data = self._load_db()
+            if "missions" in data and key in data["missions"]:
+                del data["missions"][key]
+                self._save_db(data)
+                return True
+            return False
+
+    def get_mission_prompt(self, key: str) -> str:
+        mission = self.get_mission(key)
+        if not mission:
+            raise ValueError(f"Mission {key} not found")
+
+        return construct_mission_prompt(
+            key=mission.key,
+            title=mission.title,
+            instruction_raw=mission.instruction_raw
+        )
+
+    def migrate_from_legacy(self, legacy_file_path: str) -> int:
+        legacy_path = Path(legacy_file_path)
+        if not legacy_path.exists():
+            # If the file doesn't exist, we can't migrate.
+            # But we should check if it's maybe just a path issue.
+            # Assuming absolute path or relative to CWD.
+            return 0
+
+        import importlib.util
+        spec = importlib.util.spec_from_file_location("legacy_manifest", legacy_path)
+        if spec is None or spec.loader is None:
+             return 0
+
+        module = importlib.util.module_from_spec(spec)
+        spec.loader.exec_module(module)
+
+        count = 0
+
+        # JULES
+        if hasattr(module, "JULES_MISSIONS"):
+            for key, m_data in module.JULES_MISSIONS.items():
+                dto = MissionDTO(
+                    key=key,
+                    title=m_data.get("title", key),
+                    type=MissionType.JULES,
+                    instruction_raw=m_data.get("instruction", ""),
+                    command=m_data.get("command"),
+                    file_path=m_data.get("file_path"),
+                    wait=m_data.get("wait", False),
+                    session_id=m_data.get("session_id")
+                )
+                self.register_mission(dto)
+                count += 1
+
+        # GEMINI
+        if hasattr(module, "GEMINI_MISSIONS"):
+            for key, m_data in module.GEMINI_MISSIONS.items():
+                dto = MissionDTO(
+                    key=key,
+                    title=m_data.get("title", key),
+                    type=MissionType.GEMINI,
+                    instruction_raw=m_data.get("instruction", ""),
+                    worker=m_data.get("worker"),
+                    context_files=m_data.get("context_files", []),
+                    output_path=m_data.get("output_path"),
+                    model=m_data.get("model"),
+                    audit_requirements=m_data.get("audit_requirements")
+                )
+                self.register_mission(dto)
+                count += 1
+
+        # Rename legacy file
+        shutil.move(str(legacy_path), str(legacy_path.with_suffix('.py.bak')))
+
+        return count
diff --git a/communications/insights/jules-17-1-manifest-service.md b/communications/insights/jules-17-1-manifest-service.md
new file mode 100644
index 00000000..ca8f5c62
--- /dev/null
+++ b/communications/insights/jules-17-1-manifest-service.md
@@ -0,0 +1,61 @@
+# Architectural Insight: Spec 17.1 (Manifest Migration)
+
+## 1. Technical Debt Retired
+-   **TD-SYS-BATCH-FRAGILITY (Data as Code)**: Replaced the fragile `command_manifest.py` (which was missing from the repo but referenced in specs) with a robust `mission_db.json` managed by `MissionRegistryService`.
+-   **TD-SYS-REGEX-PARSING**: Eliminated the need for regex-based editing of Python files for mission management.
+-   **TD-ENV-MISSING-FILES**: Identified and mitigated the absence of `launcher.py` and `_internal` directory by creating a new `MissionRegistryService` and `scripts/mission_launcher.py`.
+
+## 2. Architectural Decisions
+-   **Protocol Injection Pattern**: Implemented `MissionRegistryService.get_mission_prompt` to dynamically inject `META`, `GUARDRAILS`, and `OUTPUT_DISCIPLINE` into mission prompts. This ensures that even old pending missions use the latest safety protocols.
+-   **Service-Based Locking**: Implemented `MissionLock` within the service to ensure transactional integrity during mission registration and deletion.
+    -   *Update*: Fixed a potential race condition in `MissionLock` by using atomic `touch(exist_ok=False)` creation instead of checking `exists()`.
+-   **Launcher Replacement**: Since the original `launcher.py` was not present in the repository, a new `scripts/mission_launcher.py` was created to interface with the `MissionRegistryService`. This script provides `list`, `create`, `run`, `delete`, and `migrate` commands.
+-   **DTO Purity**: Defined strict `MissionDTO` and `MissionType` in `_internal.registry.api` to ensure data consistency across boundaries.
+
+## 3. Risk Analysis
+-   **Migration One-Way Valve**: The migration from `command_manifest.py` is supported but relies on the file being present. Since the file was missing in this environment, the migration logic was verified via unit tests with a dummy file.
+-   **Environment Consistency**: The `_internal` directory was missing and had to be created and un-ignored in `.gitignore`. This might cause conflicts if the user has a local `_internal` directory with different content. The new service is isolated in `_internal/registry`.
+-   **Missing Protocol Fix**: During testing, a missing `IHouseholdFactory` in `modules/simulation/api.py` was blocking tests (via `conftest.py`). This was fixed by adding the missing protocol definition, restoring environment health.
+
+## 4. Test Evidence
+The following tests confirm the functionality of `MissionRegistryService` and the migration logic:
+
+```bash
+$ python -m pytest tests/unit/registry/test_service.py
+============================= test session starts ==============================
+platform linux -- Python 3.12.12, pytest-9.0.2, pluggy-1.6.0
+rootdir: /app
+configfile: pytest.ini
+plugins: asyncio-0.25.3, anyio-4.12.1, mock-3.15.1
+collected 7 items
+
+tests/unit/registry/test_service.py::test_load_missions_empty PASSED     [ 14%]
+tests/unit/registry/test_service.py::test_register_and_get_mission PASSED [ 28%]
+tests/unit/registry/test_service.py::test_delete_mission PASSED          [ 42%]
+tests/unit/registry/test_service.py::test_get_mission_prompt PASSED      [ 57%]
+tests/unit/registry/test_service.py::test_migration PASSED               [ 71%]
+tests/unit/registry/test_service.py::test_lock_timeout PASSED            [ 85%]
+tests/unit/registry/test_service.py::test_lock_success PASSED            [100%]
+
+============================== 7 passed in 0.60s ===============================
+```
+
+## 5. Usage Guide
+Since `launcher.py` was replaced, use `scripts/mission_launcher.py`:
+
+```bash
+# List missions
+python scripts/mission_launcher.py list
+
+# Create a mission
+python scripts/mission_launcher.py create my-key --type jules --title "My Mission" --instruction "Do X"
+
+# Run a mission (get prompt)
+python scripts/mission_launcher.py run my-key
+
+# Delete a mission
+python scripts/mission_launcher.py delete my-key
+
+# Migrate legacy
+python scripts/mission_launcher.py migrate path/to/command_manifest.py
+```
diff --git a/modules/simulation/api.py b/modules/simulation/api.py
index ac0e34a4..6d6185bf 100644
--- a/modules/simulation/api.py
+++ b/modules/simulation/api.py
@@ -285,3 +285,20 @@ class IShockInjector(Protocol):
         This method is expected to be called every tick.
         """
         ...
+
+@dataclass
+class HouseholdFactoryContext:
+    core_config_module: Any
+    household_config_dto: Any
+    goods_data: List[Any]
+    loan_market: Any
+    ai_training_manager: Any
+    settlement_system: Any
+    markets: Dict[str, Any]
+    memory_system: Any
+    central_bank: Any
+
+@runtime_checkable
+class IHouseholdFactory(Protocol):
+    def create_newborn(self, parent: Any, simulation: Any, child_id: int) -> Any:
+        ...
diff --git a/scripts/mission_launcher.py b/scripts/mission_launcher.py
new file mode 100644
index 00000000..fcd4f2a3
--- /dev/null
+++ b/scripts/mission_launcher.py
@@ -0,0 +1,114 @@
+"""
+Mission Launcher Script.
+Replaces the legacy launcher.py with a robust, service-backed implementation.
+"""
+import argparse
+import sys
+from pathlib import Path
+
+# Add project root to sys.path
+root = Path(__file__).resolve().parent.parent
+sys.path.append(str(root))
+
+from _internal.registry.api import MissionDTO, MissionType
+from _internal.registry.service import MissionRegistryService
+
+def list_missions(service: MissionRegistryService):
+    missions = service.load_missions()
+    if not missions:
+        print("No missions found.")
+        return
+
+    print(f"{'KEY':<20} {'TYPE':<10} {'TITLE'}")
+    print("-" * 60)
+    for key, m in missions.items():
+        print(f"{key:<20} {m.type.value:<10} {m.title}")
+
+def create_mission(service: MissionRegistryService, args):
+    mission_type = MissionType.GEMINI if args.type == "gemini" else MissionType.JULES
+
+    dto = MissionDTO(
+        key=args.key,
+        title=args.title,
+        type=mission_type,
+        instruction_raw=args.instruction,
+        worker=args.worker,
+        output_path=args.output,
+        command=args.command
+    )
+
+    if args.context:
+        dto.context_files = args.context
+
+    service.register_mission(dto)
+    print(f"Mission '{args.key}' created.")
+
+def run_mission(service: MissionRegistryService, key: str):
+    mission = service.get_mission(key)
+    if not mission:
+        print(f"Error: Mission '{key}' not found.")
+        sys.exit(1)
+
+    prompt = service.get_mission_prompt(key)
+    print("=== MISSION PROMPT ===")
+    print(prompt)
+    print("======================")
+
+    # In a real launcher, this would dispatch to an agent.
+    # Here we just output the prompt as per the spec "get_mission_prompt".
+
+def delete_mission(service: MissionRegistryService, key: str):
+    if service.delete_mission(key):
+        print(f"Mission '{key}' deleted.")
+    else:
+        print(f"Mission '{key}' not found.")
+
+def main():
+    parser = argparse.ArgumentParser(description="Mission Registry Launcher")
+    subparsers = parser.add_subparsers(dest="command", help="Command to execute")
+
+    # LIST
+    subparsers.add_parser("list", help="List all missions")
+
+    # CREATE
+    create_parser = subparsers.add_parser("create", help="Register a new mission")
+    create_parser.add_argument("key", help="Unique mission key")
+    create_parser.add_argument("--type", choices=["jules", "gemini"], required=True)
+    create_parser.add_argument("--title", required=True)
+    create_parser.add_argument("--instruction", required=True)
+    create_parser.add_argument("--worker", help="Worker type (Gemini only)")
+    create_parser.add_argument("--output", help="Output path (Gemini only)")
+    create_parser.add_argument("--command", help="Command (Jules only)")
+    create_parser.add_argument("--context", nargs="*", help="Context files")
+
+    # RUN
+    run_parser = subparsers.add_parser("run", help="Run (print prompt) for a mission")
+    run_parser.add_argument("key", help="Mission key")
+
+    # DELETE
+    delete_parser = subparsers.add_parser("delete", help="Delete a mission")
+    delete_parser.add_argument("key", help="Mission key")
+
+    # MIGRATE
+    migrate_parser = subparsers.add_parser("migrate", help="Migrate from legacy manifest")
+    migrate_parser.add_argument("path", help="Path to legacy command_manifest.py")
+
+    args = parser.parse_args()
+    service = MissionRegistryService()
+
+    if args.command == "list":
+        list_missions(service)
+    elif args.command == "create":
+        create_mission(service, args)
+    elif args.command == "run":
+        run_mission(service, args.key)
+    elif args.command == "delete":
+        delete_mission(service, args.key)
+    elif args.command == "migrate":
+        count = service.migrate_from_legacy(args.path)
+        print(f"Migrated {count} missions.")
+    else:
+        parser.print_help()
+
+if __name__ == "__main__":
+    main()
diff --git a/tests/unit/registry/test_service.py b/tests/unit/registry/test_service.py
new file mode 100644
index 00000000..07217f77
--- /dev/null
+++ b/tests/unit/registry/test_service.py
@@ -0,0 +1,138 @@
+import pytest
+import json
+import os
+import time
+from pathlib import Path
+from unittest.mock import MagicMock, patch
+
+from _internal.registry.api import MissionDTO, MissionType
+from _internal.registry.service import MissionRegistryService, MissionLock
+
+@pytest.fixture
+def temp_db_path(tmp_path):
+    return tmp_path / "mission_db.json"
+
+@pytest.fixture
+def service(temp_db_path):
+    # Ensure parent dir exists for lock file patching if needed,
+    # but service creates parent dir for db_path.
+    return MissionRegistryService(db_path=temp_db_path)
+
+def test_load_missions_empty(service):
+    missions = service.load_missions()
+    assert missions == {}
+
+def test_register_and_get_mission(service):
+    dto = MissionDTO(
+        key="test-mission",
+        title="Test Mission",
+        type=MissionType.JULES,
+        instruction_raw="Do something"
+    )
+    service.register_mission(dto)
+
+    loaded = service.get_mission("test-mission")
+    assert loaded is not None
+    assert loaded.key == "test-mission"
+    assert loaded.title == "Test Mission"
+    assert loaded.type == MissionType.JULES
+
+def test_delete_mission(service):
+    dto = MissionDTO(
+        key="delete-me",
+        title="Delete Me",
+        type=MissionType.GEMINI,
+        instruction_raw="Delete instruction"
+    )
+    service.register_mission(dto)
+
+    assert service.get_mission("delete-me") is not None
+
+    deleted = service.delete_mission("delete-me")
+    assert deleted is True
+    assert service.get_mission("delete-me") is None
+
+    deleted_again = service.delete_mission("delete-me")
+    assert deleted_again is False
+
+def test_get_mission_prompt(service):
+    dto = MissionDTO(
+        key="prompt-mission",
+        title="Prompt Mission",
+        type=MissionType.JULES,
+        instruction_raw="Execute order 66"
+    )
+    service.register_mission(dto)
+
+    prompt = service.get_mission_prompt("prompt-mission")
+    assert "MISSION: Prompt Mission" in prompt
+    assert "Mission Key: prompt-mission" in prompt
+    assert "Execute order 66" in prompt
+    assert "ARCHITECTURAL GUARDRAILS" in prompt # From GUARDRAILS
+
+def test_migration(service, tmp_path):
+    # Create a dummy legacy file
+    legacy_file = tmp_path / "command_manifest.py"
+    legacy_content = """
+JULES_MISSIONS = {
+    "legacy-jules": {
+        "title": "Legacy Jules",
+        "instruction": "Old instruction",
+        "command": "create"
+    }
+}
+GEMINI_MISSIONS = {
+    "legacy-gemini": {
+        "title": "Legacy Gemini",
+        "instruction": "Old gemini instruction",
+        "worker": "spec"
+    }
+}
+"""
+    legacy_file.write_text(legacy_content)
+
+    count = service.migrate_from_legacy(str(legacy_file))
+    assert count == 2
+
+    # Check if missions are registered
+    jules = service.get_mission("legacy-jules")
+    assert jules is not None
+    assert jules.type == MissionType.JULES
+    assert jules.instruction_raw == "Old instruction"
+
+    gemini = service.get_mission("legacy-gemini")
+    assert gemini is not None
+    assert gemini.type == MissionType.GEMINI
+
+    # Check if file was renamed
+    assert not legacy_file.exists()
+    assert legacy_file.with_suffix(".py.bak").exists()
+
+def test_lock_timeout(tmp_path):
+    # We need to patch LOCK_PATH to use a temp file
+    lock_path = tmp_path / "test.lock"
+
+    with patch("_internal.registry.service.LOCK_PATH", lock_path):
+        # Create lock file manually to simulate another process holding it
+        lock_path.touch()
+
+        # Set timeout to very small
+        start = time.time()
+        with pytest.raises(TimeoutError):
+            # We use a short timeout
+            lock = MissionLock(timeout=0.1)
+            with lock:
+                pass
+        duration = time.time() - start
+        assert duration >= 0.1 # Should have waited at least 0.1s
+
+    # Clean up handled by tmp_path but good practice
+    if lock_path.exists():
+        lock_path.unlink()
+
+def test_lock_success(tmp_path):
+    lock_path = tmp_path / "test.lock"
+    with patch("_internal.registry.service.LOCK_PATH", lock_path):
+        with MissionLock(timeout=1):
+            assert lock_path.exists()
+        assert not lock_path.exists()
