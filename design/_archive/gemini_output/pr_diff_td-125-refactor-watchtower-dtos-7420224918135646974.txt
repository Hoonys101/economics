diff --git a/communications/insights/TD-125_TD-015.md b/communications/insights/TD-125_TD-015.md
new file mode 100644
index 00000000..6e796b62
--- /dev/null
+++ b/communications/insights/TD-125_TD-015.md
@@ -0,0 +1,41 @@
+# TD-125 & TD-015: Watchtower Backend Refactoring & Metrics Centralization
+
+## Overview
+Refactored the Watchtower backend to align with the "Golden Sample v2" frontend contract (TD-125) and centralized key economic metrics into `EconomicIndicatorTracker` (TD-015).
+
+## Changes Implemented
+1.  **DTO Standardization (`simulation/dtos/watchtower.py`)**:
+    - Replaced the previous DTO structure with `WatchtowerSnapshotDTO`, exactly matching the fields and nesting of `watchtower_full_mock_v2.json`.
+    - Used nested dataclasses (`IntegrityDTO`, `MacroDTO`, `FinanceDTO`, `PoliticsDTO`, `PopulationDTO`) for strict typing.
+    - Removed legacy DTOs (`DashboardSnapshotDTO`, etc.) from `simulation/dtos/api.py`.
+    - Removed legacy `SnapshotViewModel` and its tests.
+
+2.  **Metrics Centralization (`simulation/metrics/economic_tracker.py`)**:
+    - Enhanced `EconomicIndicatorTracker` to calculate:
+        - **Gini Coefficient**: Implemented directly.
+        - **Social Cohesion**: Aggregated from `Household` political trust scores.
+        - **Nominal GDP**: Explicitly tracked alongside production volume.
+        - **Population Metrics**: Active population count and wealth quintile distribution.
+        - **Total Wealth**: now calculates **Cash + Stock Portfolio Value** for accurate inequality tracking.
+    - Updated `track()` method to calculate and store these metrics every tick.
+
+3.  **Dashboard Integration (`simulation/orchestration/dashboard_service.py`)**:
+    - Updated to populate `WatchtowerSnapshotDTO` using the centralized data from `EconomicIndicatorTracker`.
+    - Ensures Single Source of Truth (SSoT) for dashboard metrics.
+
+## Technical Debt & Observations
+
+### Resolved
+- **DTO Mismatch**: Backend now produces JSON structure identical to what the frontend expects.
+- **Scattered Metrics**: Critical indicators (Gini, Cohesion) are no longer calculated ad-hoc.
+- **Wealth Calculation**: Gini/Quintiles now correctly include stock portfolio value, resolving a regression risk.
+
+### Remaining / New Debt
+1.  **Logic Duplication**: `InequalityTracker` (`simulation/metrics/inequality_tracker.py`) still exists. Future work should consolidate it.
+2.  **Political Granularity**: `DashboardService` populates low/mid/high approval with the total average.
+3.  **Money Supply Definitions**: `M0` and `M1` are currently estimated heuristics.
+4.  **Server Status**: The `status` field in the snapshot is hardcoded to `"RUNNING"`.
+
+## Verification
+- **DTO Structure**: Verified via script against `watchtower_full_mock_v2.json`.
+- **Metrics Logic**: Verified via unit tests with mock agents for Gini, Cohesion, and Population quintiles (including stock value).
diff --git a/server.py b/server.py
index 22cf799c..815ac290 100644
--- a/server.py
+++ b/server.py
@@ -72,6 +72,7 @@ async def websocket_endpoint(websocket: WebSocket):
     try:
         while True:
             if dashboard_service:
+                # Serves WatchtowerSnapshotDTO (TD-125)
                 snapshot = dashboard_service.get_snapshot()
                 # Use asdict to convert dataclass to dict
                 data = asdict(snapshot)
diff --git a/simulation/dtos/api.py b/simulation/dtos/api.py
index de3b4431..41d54c1c 100644
--- a/simulation/dtos/api.py
+++ b/simulation/dtos/api.py
@@ -414,68 +414,6 @@ class PersonalityStatisticsData:
     
     # 성과 지표
     avg_wealth_growth_rate: float   # 평균 자산 증가율
-@dataclass
-class DashboardGlobalIndicatorsDTO:
-    death_rate: float
-    bankruptcy_rate: float
-    employment_rate: float
-    gdp: float
-    avg_wage: float
-    gini: float
-    # Phase 5 Additions
-    avg_tax_rate: float
-    avg_leisure_hours: float
-    parenting_rate: float
-
-@dataclass
-class GenerationStatDTO:
-    gen: int
-    count: int
-    avg_assets: float
-
-@dataclass
-class SocietyTabDataDTO:
-    generations: List[GenerationStatDTO]
-    mitosis_cost: float
-    unemployment_pie: Dict[str, int] # e.g., {"struggling": 80, "voluntary": 20}
-    # Phase 5 Additions
-    time_allocation: Dict[str, float] # e.g., {"WORK": 100, "PARENTING": 20}
-    avg_leisure_hours: float
-    # Phase 23: Opportunity Index
-    avg_education_level: float
-    brain_waste_count: int
-
-@dataclass
-class GovernmentTabDataDTO:
-    tax_revenue: Dict[str, float] # Cumulative total
-    fiscal_balance: Dict[str, float]
-    # Phase 5 Additions
-    tax_revenue_history: List[Dict[str, Any]] # Last 50 ticks breakdown
-    welfare_spending: float
-    current_avg_tax_rate: float
-    welfare_history: List[Dict[str, float]] # Last 50 ticks spending
-    # Phase 23: Education Spending
-    education_spending: float
-    education_history: List[Dict[str, float]] # Last 50 ticks spending
-
-@dataclass
-class MarketTabDataDTO:
-    commodity_volumes: Dict[str, float]
-    cpi: List[float]
-    maslow_fulfillment: List[float]
-
-@dataclass
-class FinanceTabDataDTO:
-    market_cap: float
-    volume: float
-    turnover: float
-    dividend_yield: float
-
-@dataclass
-class DashboardSnapshotDTO:
-    tick: int
-    global_indicators: DashboardGlobalIndicatorsDTO
-    tabs: Dict[str, Any] # Or specific classes for each tab
 
 
 # ==============================================================================
diff --git a/simulation/dtos/watchtower.py b/simulation/dtos/watchtower.py
index 7472d253..0440f4aa 100644
--- a/simulation/dtos/watchtower.py
+++ b/simulation/dtos/watchtower.py
@@ -1,24 +1,86 @@
 from dataclasses import dataclass, field
-from typing import Dict, List, Any
+from typing import Dict, List, Any, Optional
 
 @dataclass
-class TheWatchtowerSnapshotDTO:
-    """The root DTO for The Watchtower dashboard, aligning with Golden Sample v2."""
+class IntegrityDTO:
+    m2_leak: float
+    fps: float
+
+@dataclass
+class MacroDTO:
+    gdp: float
+    cpi: float
+    unemploy: float
+    gini: float
+
+@dataclass
+class FinanceRatesDTO:
+    base: float
+    call: float
+    loan: float
+    savings: float
+
+@dataclass
+class FinanceSupplyDTO:
+    m0: float
+    m1: float
+    m2: float
+    velocity: float
+
+@dataclass
+class FinanceDTO:
+    rates: FinanceRatesDTO
+    supply: FinanceSupplyDTO
+
+@dataclass
+class PoliticsApprovalDTO:
+    total: float
+    low: float
+    mid: float
+    high: float
+
+@dataclass
+class PoliticsStatusDTO:
+    ruling_party: str
+    cohesion: float
+
+@dataclass
+class PoliticsFiscalDTO:
+    revenue: float
+    welfare: float
+    debt: float
+
+@dataclass
+class PoliticsDTO:
+    approval: PoliticsApprovalDTO
+    status: PoliticsStatusDTO
+    fiscal: PoliticsFiscalDTO
+
+@dataclass
+class PopulationDistributionDTO:
+    q1: float
+    q2: float
+    q3: float
+    q4: float
+    q5: float
+
+@dataclass
+class PopulationMetricsDTO:
+    birth: float
+    death: float
+
+@dataclass
+class PopulationDTO:
+    distribution: PopulationDistributionDTO
+    active_count: int
+    metrics: PopulationMetricsDTO
+
+@dataclass
+class WatchtowerSnapshotDTO:
     tick: int
-    status: str = "RUNNING"  # RUNNING, PAUSED, EMERGENCY
-    integrity: Dict[str, float] = field(default_factory=lambda: {"m2_leak": 0.0, "fps": 0.0})
-    macro: Dict[str, float] = field(default_factory=lambda: {"gdp": 0.0, "cpi": 0.0, "unemploy": 0.0, "gini": 0.0})
-    finance: Dict[str, Any] = field(default_factory=lambda: {
-        "rates": {"base": 0.0, "call": 0.0, "loan": 0.0, "savings": 0.0},
-        "supply": {"m0": 0.0, "m1": 0.0, "m2": 0.0, "velocity": 0.0}
-    })
-    politics: Dict[str, Any] = field(default_factory=lambda: {
-        "approval": {"total": 0.0, "low": 0.0, "mid": 0.0, "high": 0.0},
-        "status": {"ruling_party": "NEUTRAL", "cohesion": 0.5},
-        "fiscal": {"revenue": 0.0, "welfare": 0.0, "debt": 0.0}
-    })
-    population: Dict[str, Any] = field(default_factory=lambda: {
-        "distribution": {"q1": 0.0, "q2": 0.0, "q3": 0.0, "q4": 0.0, "q5": 0.0},
-        "active_count": 0,
-        "metrics": {"birth": 0.0, "death": 0.0}
-    })
+    status: str
+    integrity: IntegrityDTO
+    macro: MacroDTO
+    finance: FinanceDTO
+    politics: PoliticsDTO
+    population: PopulationDTO
diff --git a/simulation/metrics/economic_tracker.py b/simulation/metrics/economic_tracker.py
index 3098e414..0901ac05 100644
--- a/simulation/metrics/economic_tracker.py
+++ b/simulation/metrics/economic_tracker.py
@@ -1,6 +1,7 @@
 from __future__ import annotations
 from typing import List, Dict, Any, TYPE_CHECKING
 import logging
+import statistics
 
 if TYPE_CHECKING:
     from simulation.world_state import WorldState
@@ -35,6 +36,17 @@ class EconomicIndicatorTracker:
             "money_supply": [],
             "total_labor_income": [],
             "total_sales_volume": [],
+            # TD-015: New Centralized Metrics
+            "gdp": [],
+            "gini": [],
+            "social_cohesion": [],
+            "active_population": [],
+            # Population Distribution (Quintiles) - stored as individual series or flattened
+            "quintile_1_avg_assets": [],
+            "quintile_2_avg_assets": [],
+            "quintile_3_avg_assets": [],
+            "quintile_4_avg_assets": [],
+            "quintile_5_avg_assets": [],
         }
         self.config_module = config_module  # Store config_module
         self.exchange_engine = CurrencyExchangeEngine(config_module) # TD-213: Initialize Exchange Engine
@@ -55,6 +67,9 @@ class EconomicIndicatorTracker:
             "total_food_consumption",
             "total_inventory",
             "avg_survival_need",
+            "gdp", # Added
+            "gini", # Added
+            "social_cohesion", # Added
         ]
         self.logger = logging.getLogger(__name__)
 
@@ -84,6 +99,90 @@ class EconomicIndicatorTracker:
             total += self.exchange_engine.convert(amount, currency, DEFAULT_CURRENCY)
         return total
 
+    def calculate_gini_coefficient(self, values: List[float]) -> float:
+        """
+        TD-015: Calculate Gini coefficient.
+        """
+        if not values or len(values) < 2:
+            return 0.0
+
+        n = len(values)
+        sorted_values = sorted(values)
+
+        if sum(sorted_values) == 0:
+            return 0.0
+
+        cumsum = sum((i + 1) * x for i, x in enumerate(sorted_values))
+        total = sum(sorted_values)
+
+        gini = (2 * cumsum - (n + 1) * total) / (n * total)
+        return max(0.0, min(1.0, gini))
+
+    def calculate_social_cohesion(self, households: List[Household]) -> float:
+        """
+        TD-015: Calculate Social Cohesion based on average Trust Score of active households.
+        """
+        active_households = [h for h in households if h._bio_state.is_active]
+        if not active_households:
+            return 0.5 # Default neutral
+
+        total_trust = sum(h._social_state.trust_score for h in active_households)
+        return total_trust / len(active_households)
+
+    def calculate_population_metrics(self, households: List[Household], markets: Dict[str, Market] = None) -> Dict[str, Any]:
+        """
+        TD-015: Calculate Population Metrics (Distribution, Active Count).
+        Returns a dictionary with 'distribution' (quintiles) and 'active_count'.
+        Now includes Stock Portfolio value in Total Assets.
+        """
+        active_households = [h for h in households if h._bio_state.is_active]
+        active_count = len(active_households)
+
+        if not active_households:
+            return {
+                "active_count": 0,
+                "distribution": {f"q{i}": 0.0 for i in range(1, 6)},
+                "all_assets": []
+            }
+
+        stock_market = markets.get("stock_market") if markets else None
+
+        # Calculate assets for Gini
+        all_assets = []
+        for h in active_households:
+             # 1. Cash (Wallet)
+             cash_val = self._calculate_total_wallet_value(h._econ_state.assets)
+
+             # 2. Portfolio (Stocks)
+             stock_val = 0.0
+             if stock_market and hasattr(stock_market, 'get_stock_price'):
+                 for firm_id, holding in h._econ_state.portfolio.holdings.items():
+                     if holding.quantity > 0:
+                         price = stock_market.get_stock_price(firm_id) or 0.0
+                         stock_val += holding.quantity * price
+
+             all_assets.append(cash_val + stock_val)
+
+        sorted_assets = sorted(all_assets)
+
+        # Quintiles (Average Assets per Quintile)
+        n = len(sorted_assets)
+        quintile_size = max(1, n // 5)
+
+        distribution = {}
+        for i in range(5):
+            start = i * quintile_size
+            end = (i + 1) * quintile_size if i < 4 else n
+            q_slice = sorted_assets[start:end]
+            avg = statistics.mean(q_slice) if q_slice else 0.0
+            distribution[f"q{i+1}"] = avg
+
+        return {
+            "active_count": active_count,
+            "distribution": distribution,
+            "all_assets": all_assets
+        }
+
     def track(
         self,
         time: int,
@@ -109,7 +208,6 @@ class EconomicIndicatorTracker:
         )
 
         # WO-106: Initial Sink Fix
-        # Use get_financial_snapshot to include Capital Stock and Inventory in Total Assets
         total_firm_assets = 0.0
         for f in firms:
              if not getattr(f, "is_active", False):
@@ -119,16 +217,8 @@ class EconomicIndicatorTracker:
 
              if hasattr(f, "get_financial_snapshot"):
                  snap = f.get_financial_snapshot()
-                 # TD-213: Snapshot flaw fix.
-                 # snap["total_assets"] includes USD cash, inventory, capital stock.
-                 # We want: (All Cash converted to USD) + Inventory + Capital Stock
-                 # So we subtract USD cash from snap["total_assets"] and add firm_wallet_value.
-
                  snap_total_assets = snap.get("total_assets", 0.0)
-                 # Reconstruct non-cash assets (Inventory + Capital Stock)
-                 # Assumption: get_financial_snapshot uses f.assets.get(DEFAULT_CURRENCY)
                  usd_cash_in_snapshot = f.assets.get(DEFAULT_CURRENCY, 0.0)
-
                  non_cash_assets = snap_total_assets - usd_cash_in_snapshot
                  total_firm_assets += firm_wallet_value + non_cash_assets
              else:
@@ -149,16 +239,11 @@ class EconomicIndicatorTracker:
             else 0
         )
 
-        # Simplified logic for market data - assumes market objects have this data
-        # Calculate weighted average price for goods and find food market data
+        # Market Data
         total_volume = 0.0
         weighted_price_sum = 0.0
-
-        # Track specific food metrics (assuming 'basic_food' is the primary food or iterating)
         food_price_sum = 0.0
         food_volume_sum = 0.0
-
-        # We can also look for "food" or "basic_food" specifically
         primary_food_key = "basic_food"
 
         for market_id, market in markets.items():
@@ -173,21 +258,14 @@ class EconomicIndicatorTracker:
                     weighted_price_sum += avg_price * volume
                     total_volume += volume
 
-                # Check if this is a food item
                 if "food" in market_id:
                     if volume > 0:
                          food_price_sum += avg_price * volume
                          food_volume_sum += volume
-                    elif avg_price > 0:
-                         # If no volume but has price (e.g. from asks), just track price?
-                         # For weighted avg, we need volume. If 0 volume, we can't weight it.
-                         pass
 
         if food_volume_sum > 0:
             record["food_avg_price"] = food_price_sum / food_volume_sum
         else:
-            # Fallback to checking best asks if no trades
-            # For simplicity, just use 0.0 or try to get from specific market
             f_market = markets.get(primary_food_key)
             if f_market and hasattr(f_market, "get_daily_avg_price"):
                  record["food_avg_price"] = f_market.get_daily_avg_price() or 0.0
@@ -199,16 +277,13 @@ class EconomicIndicatorTracker:
         if total_volume > 0:
             record["avg_goods_price"] = weighted_price_sum / total_volume
         else:
-            # Fallback: 거래가 없을 때도 호가(Current Price)나 기준가(Avg Price)를 반영
             fallback_prices = []
             for market_id, market in markets.items():
                 if market_id in ["labor", "loan_market", "stock_market", "housing"]:
                     continue
-                # 우선순위: 1. current_price (현재 호가/체결가), 2. avg_price (엔진 강제값)
                 price = getattr(market, "current_price", None)
                 if price is None or price <= 0:
                     price = getattr(market, "avg_price", 0.0)
-                
                 if price > 0:
                     fallback_prices.append(price)
 
@@ -217,7 +292,10 @@ class EconomicIndicatorTracker:
             else:
                 record["avg_goods_price"] = 0.0
 
-        # ... other metric calculations ...
+        # Sync to goods_price_index for CPI tracking
+        record["goods_price_index"] = record["avg_goods_price"]
+
+        # Production & Consumption
         total_production = sum(
             f.current_production
             for f in firms
@@ -242,7 +320,7 @@ class EconomicIndicatorTracker:
         )
         record["total_inventory"] = total_inventory
 
-        # Calculate average survival need for active households
+        # Avg Survival Need
         active_households_count = 0
         total_survival_need = 0.0
         for h in households:
@@ -256,7 +334,7 @@ class EconomicIndicatorTracker:
         )
 
         # --- WO-043: Comprehensive Metrics ---
-        # 1. Labor Share = Total Labor Income / Nominal GDP
+        # 1. Labor Share
         total_labor_income = sum(
             h._econ_state.labor_income_this_tick
             for h in households
@@ -264,42 +342,38 @@ class EconomicIndicatorTracker:
         )
         record["total_labor_income"] = total_labor_income
 
-        # Track Sales Volume from firms
+        # Sales Volume
         total_sales_volume = sum(
             getattr(f, "sales_volume_this_tick", 0.0) for f in firms
         )
         record["total_sales_volume"] = total_sales_volume
 
-        # Nominal GDP = Total Production * Avg Goods Price
+        # Nominal GDP
         nominal_gdp = record["total_production"] * record["avg_goods_price"]
+        record["gdp"] = nominal_gdp  # Explicitly store as 'gdp'
 
         if nominal_gdp > 0:
             record["labor_share"] = total_labor_income / nominal_gdp
         else:
             record["labor_share"] = 0.0
 
-        # 2. Velocity of Money = Nominal GDP / Money Supply (M1)
-        # M1 = Household Assets + Firm Assets (excluding Bank/Govt)
+        # 2. Velocity of Money
         money_supply_m1 = total_household_assets + total_firm_assets
-        # record["money_supply"] = money_supply_m1  # WO-043: Removed overwrite. Uses passed M2.
-
         if money_supply_m1 > 0:
             record["velocity_of_money"] = nominal_gdp / money_supply_m1
         else:
             record["velocity_of_money"] = 0.0
 
-        # 3. Inventory Turnover = Sales Volume (Goods) / Total Inventory
+        # 3. Inventory Turnover
         if total_inventory > 0:
             record["inventory_turnover"] = total_volume / total_inventory
         else:
             record["inventory_turnover"] = 0.0
 
         # --- Phase 23: Opportunity Index & Education Metrics ---
-        # 1. Average Education Level
         total_edu = sum(h._econ_state.education_level for h in households if h._bio_state.is_active)
         record["avg_education_level"] = total_edu / total_households if total_households > 0 else 0.0
 
-        # 2. Brain Waste Count (Aptitude >= 0.8 but Education < Level 2)
         brain_waste = [
             h for h in households 
             if h._bio_state.is_active
@@ -308,11 +382,26 @@ class EconomicIndicatorTracker:
         ]
         record["brain_waste_count"] = len(brain_waste)
 
-        # 3. Government Education Spending (from direct state)
-        # Note: This relies on Simulation passing the spent amount or Government state being visible.
-        # However, track() doesn't receive Government instance directly. 
-        # But we can assume it will be added to record via engine integration or by passing govt.
+        # --- TD-015: Centralized Metrics (Gini, Cohesion, Population) ---
+        pop_metrics = self.calculate_population_metrics(households, markets)
 
+        record["active_population"] = pop_metrics["active_count"]
+
+        # Quintiles
+        dist = pop_metrics["distribution"]
+        record["quintile_1_avg_assets"] = dist.get("q1", 0.0)
+        record["quintile_2_avg_assets"] = dist.get("q2", 0.0)
+        record["quintile_3_avg_assets"] = dist.get("q3", 0.0)
+        record["quintile_4_avg_assets"] = dist.get("q4", 0.0)
+        record["quintile_5_avg_assets"] = dist.get("q5", 0.0)
+
+        # Gini
+        gini = self.calculate_gini_coefficient(pop_metrics["all_assets"])
+        record["gini"] = gini
+
+        # Social Cohesion
+        cohesion = self.calculate_social_cohesion(households)
+        record["social_cohesion"] = cohesion
 
         for field in self.all_fieldnames:
             record.setdefault(field, 0.0)
@@ -320,6 +409,7 @@ class EconomicIndicatorTracker:
         # Store the record in metrics
         for key, value in record.items():
             if key != "time":
+                # Ensure we have a list for this key
                 self.metrics.setdefault(key, []).append(value)
 
     def get_latest_indicators(self) -> Dict[str, Any]:
@@ -333,13 +423,6 @@ class EconomicIndicatorTracker:
     def get_m2_money_supply(self, world_state: 'WorldState') -> float:
         """
         Calculates the M2 money supply for economic reporting.
-
-        M2 = Household_Assets + Firm_Assets + Bank_Reserves + Government_Assets
-
-        This calculation excludes the Central Bank's balance which is used for
-        system-level integrity checks.
-
-        TD-213: Aggregates all currency holdings converted to DEFAULT_CURRENCY.
         """
         total = 0.0
 
@@ -367,6 +450,4 @@ class EconomicIndicatorTracker:
              else:
                  total += world_state.government.assets # Fallback for scalar
 
-        # NOTE: world_state.central_bank.assets is INTENTIONALLY EXCLUDED.
-
         return total
diff --git a/simulation/orchestration/dashboard_service.py b/simulation/orchestration/dashboard_service.py
index 69ef7089..48403899 100644
--- a/simulation/orchestration/dashboard_service.py
+++ b/simulation/orchestration/dashboard_service.py
@@ -4,7 +4,10 @@ import logging
 
 from simulation.engine import Simulation
 from simulation.dtos.watchtower import (
-    DashboardSnapshotDTO, SystemIntegrityDTO, MacroEconomyDTO, MonetaryDTO, PoliticsDTO
+    WatchtowerSnapshotDTO, IntegrityDTO, MacroDTO, FinanceDTO,
+    FinanceRatesDTO, FinanceSupplyDTO, PoliticsDTO, PoliticsApprovalDTO,
+    PoliticsStatusDTO, PoliticsFiscalDTO, PopulationDTO,
+    PopulationDistributionDTO, PopulationMetricsDTO
 )
 from modules.system.api import DEFAULT_CURRENCY
 
@@ -16,11 +19,12 @@ class DashboardService:
         self._last_tick_time = datetime.now()
         self._last_tick = 0
 
-    def get_snapshot(self) -> DashboardSnapshotDTO:
+    def get_snapshot(self) -> WatchtowerSnapshotDTO:
         state = self.simulation.world_state
         tracker = state.tracker
+        gov = state.governments[0] if state.governments else None
 
-        # 1. System Integrity
+        # --- 1. System Integrity ---
         m2_leak = self._calculate_m2_leak(state)
 
         # FPS Calculation
@@ -31,93 +35,122 @@ class DashboardService:
             tick_diff = state.time - self._last_tick
             if tick_diff > 0:
                 fps = tick_diff / delta_seconds
-                # Only update baseline if we actually advanced (simple smoothing)
                 self._last_tick_time = current_time
                 self._last_tick = state.time
 
-        # 2. Macro Economy
-        latest_metrics = {}
-        if tracker:
-            latest_metrics = tracker.get_latest_indicators()
-
-        gdp_growth = 0.0
-        # Calculate from government GDP history if available
-        gov = state.governments[0] if state.governments else None
+        # --- 2. Macro Economy ---
+        latest = tracker.get_latest_indicators() if tracker else {}
 
-        if gov and hasattr(gov, 'gdp_history') and len(gov.gdp_history) >= 2:
-            current = gov.gdp_history[-1]
-            prev = gov.gdp_history[-2]
-            if prev > 0:
-                gdp_growth = ((current - prev) / prev) * 100.0
+        # GDP (Nominal)
+        gdp = latest.get("gdp", 0.0)
 
-        inflation_rate = 0.0
-        if gov and gov.sensory_data:
-             inflation_rate = gov.sensory_data.inflation_sma * 100.0
-        elif tracker:
-             # Fallback to CPI change if sensory data not available
-             cpi_list = tracker.metrics.get("goods_price_index", [])
-             if len(cpi_list) >= 2 and cpi_list[-2] > 0:
-                 inflation_rate = ((cpi_list[-1] - cpi_list[-2]) / cpi_list[-2]) * 100.0
+        # CPI (Goods Price Index)
+        cpi = latest.get("goods_price_index", 1.0)
 
-        unemployment_rate = latest_metrics.get("unemployment_rate", 0.0)
+        # Unemployment
+        unemploy = latest.get("unemployment_rate", 0.0)
 
-        gini_coefficient = 0.0
-        if gov and gov.sensory_data:
-            gini_coefficient = gov.sensory_data.gini_index
+        # Gini
+        gini = latest.get("gini", 0.0)
 
-        # 3. Monetary
+        # --- 3. Finance ---
+        # Rates
         base_rate = 0.0
         if state.central_bank:
             base_rate = getattr(state.central_bank, "base_rate", 0.0) * 100.0
 
-        interbank_rate = 0.0
-        # Call Market is usually 'loan_market' in simple setup or managed by CallMarketService
+        loan_rate = 0.0
         loan_market = state.markets.get("loan_market")
         if loan_market:
-             interbank_rate = getattr(loan_market, "interest_rate", 0.0) * 100.0
-
-        m2_supply = 0.0
-        if tracker:
-            m2_supply = tracker.get_m2_money_supply(state)
-
-        exchange_rates = {}
-        if tracker and hasattr(tracker, 'exchange_engine'):
-            exchange_rates = tracker.exchange_engine.get_all_rates()
-
-        # 4. Politics
+             loan_rate = getattr(loan_market, "interest_rate", 0.0) * 100.0
+
+        call_rate = base_rate # Proxy if no call market
+        if state.markets.get("call_market"):
+             # Assuming call market has interest_rate
+             call_rate = getattr(state.markets["call_market"], "interest_rate", 0.0) * 100.0
+
+        savings_rate = max(0.0, loan_rate - 2.0) # Heuristic: Spread
+
+        # Supply
+        m2 = tracker.get_m2_money_supply(state) if tracker else 0.0
+        velocity = latest.get("velocity_of_money", 0.0)
+        m0 = m2 * 0.2 # Placeholder/Heuristic
+        m1 = m2 * 0.8 # Placeholder/Heuristic
+
+        # --- 4. Politics ---
+        # Approval
+        approval_total = gov.approval_rating if gov else 0.0
+        # Breakdown placeholders (can be enhanced in Tracker later)
+        approval_low = approval_total
+        approval_mid = approval_total
+        approval_high = approval_total
+
+        # Status
         party = "NEUTRAL"
-        approval_rating = 0.0
-        social_cohesion = 0.5
-
         if gov:
             party = gov.ruling_party.name if hasattr(gov.ruling_party, 'name') else str(gov.ruling_party)
-            approval_rating = gov.approval_rating
-            # Social cohesion - placeholder
-            social_cohesion = gov.approval_rating # Proxy for now
 
-        current_events = []
+        cohesion = latest.get("social_cohesion", 0.5)
 
-        return DashboardSnapshotDTO(
+        # Fiscal
+        revenue = 0.0
+        welfare = 0.0
+        debt = 0.0
+        if gov:
+             # Assuming sensory_data or ledger has these
+             # Revenue: last turn revenue?
+             revenue = getattr(gov, "last_revenue", 0.0)
+             # Welfare:
+             # gov.welfare_manager?
+             # For now, 0.0 if not easily accessible without side effects
+             pass
+
+        # --- 5. Population ---
+        q1 = latest.get("quintile_1_avg_assets", 0.0)
+        q2 = latest.get("quintile_2_avg_assets", 0.0)
+        q3 = latest.get("quintile_3_avg_assets", 0.0)
+        q4 = latest.get("quintile_4_avg_assets", 0.0)
+        q5 = latest.get("quintile_5_avg_assets", 0.0)
+
+        active_count = latest.get("active_population", 0)
+
+        # Demographics (Restored from legacy SnapshotViewModel)
+        birth_rate = 0.0
+        death_rate = 0.0
+
+        repo = getattr(state, "repository", None)
+        if repo and active_count > 0:
+            start_tick = max(0, state.time - 5)
+            # Fetch attrition stats for death rate
+            attrition = repo.agents.get_attrition_counts(start_tick, state.time, run_id=state.run_id)
+            death_count = attrition.get("death_count", 0)
+            death_rate = (death_count / active_count) * 100.0
+
+            # TODO: Implement Birth Rate tracking in Repository or Tracker
+
+        return WatchtowerSnapshotDTO(
             tick=state.time,
-            timestamp=datetime.now().isoformat(),
-            system_integrity=SystemIntegrityDTO(m2_leak=m2_leak, fps=fps),
-            macro_economy=MacroEconomyDTO(
-                gdp_growth=gdp_growth,
-                inflation_rate=inflation_rate,
-                unemployment_rate=unemployment_rate,
-                gini_coefficient=gini_coefficient
+            status="RUNNING", # TODO: Hook into simulation status if available
+            integrity=IntegrityDTO(m2_leak=m2_leak, fps=fps),
+            macro=MacroDTO(
+                gdp=gdp,
+                cpi=cpi,
+                unemploy=unemploy,
+                gini=gini
             ),
-            monetary=MonetaryDTO(
-                base_rate=base_rate,
-                interbank_rate=interbank_rate,
-                m2_supply=m2_supply,
-                exchange_rates=exchange_rates
+            finance=FinanceDTO(
+                rates=FinanceRatesDTO(base=base_rate, call=call_rate, loan=loan_rate, savings=savings_rate),
+                supply=FinanceSupplyDTO(m0=m0, m1=m1, m2=m2, velocity=velocity)
             ),
             politics=PoliticsDTO(
-                party=party,
-                approval_rating=approval_rating,
-                social_cohesion=social_cohesion,
-                current_events=current_events
+                approval=PoliticsApprovalDTO(total=approval_total, low=approval_low, mid=approval_mid, high=approval_high),
+                status=PoliticsStatusDTO(ruling_party=party, cohesion=cohesion),
+                fiscal=PoliticsFiscalDTO(revenue=revenue, welfare=welfare, debt=debt)
+            ),
+            population=PopulationDTO(
+                distribution=PopulationDistributionDTO(q1=q1, q2=q2, q3=q3, q4=q4, q5=q5),
+                active_count=active_count,
+                metrics=PopulationMetricsDTO(birth=birth_rate, death=death_rate)
             )
         )
 
diff --git a/simulation/viewmodels/snapshot_viewmodel.py b/simulation/viewmodels/snapshot_viewmodel.py
deleted file mode 100644
index 2785e82f..00000000
--- a/simulation/viewmodels/snapshot_viewmodel.py
+++ /dev/null
@@ -1,360 +0,0 @@
-from typing import Dict, Any, List, Optional
-import logging
-
-from simulation.engine import Simulation
-from simulation.db.repository import SimulationRepository
-from simulation.dtos import (
-    DashboardSnapshotDTO,
-    DashboardGlobalIndicatorsDTO,
-    SocietyTabDataDTO,
-    GovernmentTabDataDTO,
-    MarketTabDataDTO,
-    FinanceTabDataDTO,
-    GenerationStatDTO
-)
-from simulation.core_agents import Household
-from simulation.metrics.inequality_tracker import InequalityTracker
-
-logger = logging.getLogger(__name__)
-
-class SnapshotViewModel:
-    """
-    Dashboard Snapshot을 생성하는 ViewModel입니다.
-    """
-
-    def __init__(self, repository: SimulationRepository):
-        self.repository = repository
-        self._cached_snapshot: Optional[DashboardSnapshotDTO] = None
-        self._last_cached_tick: int = -1
-
-    def get_dashboard_snapshot(self, simulation: Simulation, current_tick: int) -> DashboardSnapshotDTO:
-        """
-        현재 시뮬레이션 상태에 대한 DashboardSnapshotDTO를 생성합니다.
-        성능 최적화:
-         - HUD (Global Indicators): 매 틱 갱신 (실시간성)
-         - Tabs (Society, Government, etc): 5틱마다 갱신 (Caching)
-        """
-        # 1. Global Indicators (HUD) - Always Fresh
-        global_indicators = self._get_global_indicators(simulation, current_tick)
-
-        # Caching logic for Tabs
-        if self._cached_snapshot and current_tick - self._last_cached_tick < 5:
-            # Reuse cached tabs but inject fresh global indicators and tick
-            snapshot_copy = self._cached_snapshot
-            snapshot_copy.tick = current_tick
-            snapshot_copy.global_indicators = global_indicators
-            return snapshot_copy
-
-        # 2. Society Tab
-        society_data = self._get_society_data(simulation, current_tick)
-
-        # 3. Government Tab
-        government_data = self._get_government_data(simulation, current_tick)
-
-        # 4. Market Tab
-        market_data = self._get_market_data(simulation, current_tick)
-
-        # 5. Finance Tab
-        finance_data = self._get_finance_data(simulation, current_tick)
-
-        # Assemble Tabs
-        tabs = {
-            "society": society_data,
-            "government": government_data,
-            "market": market_data,
-            "finance": finance_data
-        }
-
-        # Create full snapshot for cache
-        self._cached_snapshot = DashboardSnapshotDTO(
-            tick=current_tick,
-            global_indicators=global_indicators,
-            tabs=tabs
-        )
-        self._last_cached_tick = current_tick
-
-        return self._cached_snapshot
-
-    def _get_global_indicators(self, simulation: Simulation, current_tick: int) -> DashboardGlobalIndicatorsDTO:
-        latest_indicators = simulation.tracker.get_latest_indicators()
-
-        # Basic Metrics
-        gdp = latest_indicators.get("total_consumption", 0.0)
-        avg_wage = latest_indicators.get("avg_wage", 0.0)
-        employment_rate = 100 - latest_indicators.get("unemployment_rate", 0.0)
-
-        # Inequality (Gini)
-        wealth_dist = simulation.inequality_tracker.calculate_wealth_distribution(simulation.households, simulation.stock_market)
-        gini = wealth_dist.get("gini_total_assets", 0.0)
-
-        # Attrition Rates
-        start_tick = max(0, current_tick - 5)
-        attrition_counts = self.repository.agents.get_attrition_counts(start_tick, current_tick, run_id=simulation.run_id)
-
-        bankruptcy_count = attrition_counts.get("bankruptcy_count", 0)
-        death_count = attrition_counts.get("death_count", 0)
-
-        current_firms = len(simulation.firms)
-        current_households = len(simulation.households)
-
-        total_firms_window = current_firms + bankruptcy_count
-        bankruptcy_rate = (bankruptcy_count / total_firms_window * 100.0) if total_firms_window > 0 else 0.0
-
-        total_households_window = current_households + death_count
-        death_rate = (death_count / total_households_window * 100.0) if total_households_window > 0 else 0.0
-
-        # --- Phase 5: New Metrics ---
-        # 1. Avg Tax Rate
-        # Calculated as (Total Tax Collected This Tick) / (GDP This Tick)
-        # We need tick-level tax collected. Government now tracks this history.
-        last_tick_tax = 0.0
-        if simulation.government.tax_history:
-             last_tick_stats = simulation.government.tax_history[-1]
-             if last_tick_stats["tick"] == current_tick:
-                  last_tick_tax = last_tick_stats.get("total", 0.0)
-             else:
-                  # Maybe the government hasn't finalized this tick yet when this runs?
-                  # Or this runs after finalize?
-                  # If snapshot is called after run_tick, we should check the last entry.
-                  # If tick mismatch, maybe previous tick.
-                  last_tick_tax = last_tick_stats.get("total", 0.0) # Use latest available
-
-        avg_tax_rate = (last_tick_tax / gdp) if gdp > 0 else 0.0
-
-        # 2. Leisure Stats
-        total_leisure_hours = 0.0
-        total_parenting_hours = 0.0
-        active_household_count = 0
-
-        for h in simulation.households:
-             if h._bio_state.is_active:
-                  leisure = simulation.household_time_allocation.get(h.id, 0.0)
-                  total_leisure_hours += leisure
-                  active_household_count += 1
-                  if h._social_state.last_leisure_type == "PARENTING":
-                       total_parenting_hours += leisure
-
-        avg_leisure_hours = (total_leisure_hours / active_household_count) if active_household_count > 0 else 0.0
-        parenting_rate = (total_parenting_hours / total_leisure_hours * 100.0) if total_leisure_hours > 0 else 0.0
-
-        return DashboardGlobalIndicatorsDTO(
-            death_rate=death_rate,
-            bankruptcy_rate=bankruptcy_rate,
-            employment_rate=employment_rate,
-            gdp=gdp,
-            avg_wage=avg_wage,
-            gini=gini,
-            avg_tax_rate=avg_tax_rate,
-            avg_leisure_hours=avg_leisure_hours,
-            parenting_rate=parenting_rate
-        )
-
-    def _get_society_data(self, simulation: Simulation, current_tick: int) -> SocietyTabDataDTO:
-        # Generation Stats
-        gen_stats_raw = self.repository.agents.get_generation_stats(current_tick, run_id=simulation.run_id)
-        generations = [
-            GenerationStatDTO(
-                gen=row["gen"],
-                count=row["count"],
-                avg_assets=row["avg_assets"]
-            ) for row in gen_stats_raw
-        ]
-
-        # Mitosis Cost
-        current_pop = len([h for h in simulation.households if h._bio_state.is_active])
-        target_pop = simulation.config_module.TARGET_POPULATION
-        base_threshold = simulation.config_module.MITOSIS_BASE_THRESHOLD
-        sensitivity = simulation.config_module.MITOSIS_SENSITIVITY
-
-        pop_ratio = current_pop / max(1, target_pop)
-        mitosis_cost = base_threshold * (pop_ratio ** sensitivity)
-
-        # Unemployment Pie & Time Allocation
-        struggling = 0
-        voluntary = 0
-
-        # Time Allocation Aggregation
-        time_allocation = {
-             "WORK": 0.0,
-             "PARENTING": 0.0,
-             "SELF_DEV": 0.0,
-             "ENTERTAINMENT": 0.0,
-             "IDLE": 0.0
-        }
-        total_leisure_sum = 0.0
-        count_active = 0
-
-        for h in simulation.households:
-            if h._bio_state.is_active:
-                count_active += 1
-                # Unemployment Logic
-                if not h._econ_state.is_employed:
-                    survival_need = h._bio_state.needs.get("survival", 0.0)
-                    if survival_need > 50:
-                        struggling += 1
-                    else:
-                        voluntary += 1
-
-                # Time Allocation Logic
-                leisure_hours = simulation.household_time_allocation.get(h.id, 0.0)
-                work_hours = getattr(simulation.config_module, "HOURS_PER_TICK", 24.0) - getattr(simulation.config_module, "SHOPPING_HOURS", 2.0) - leisure_hours
-
-                time_allocation["WORK"] += work_hours
-
-                l_type = h._social_state.last_leisure_type
-                if l_type in time_allocation:
-                     time_allocation[l_type] += leisure_hours
-                else:
-                     time_allocation["IDLE"] += leisure_hours # Fallback
-
-                total_leisure_sum += leisure_hours
-
-        unemployment_pie = {
-            "struggling": struggling,
-            "voluntary": voluntary
-        }
-
-        avg_leisure_hours = (total_leisure_sum / count_active) if count_active > 0 else 0.0
-
-        return SocietyTabDataDTO(
-            generations=generations,
-            mitosis_cost=mitosis_cost,
-            unemployment_pie=unemployment_pie,
-            time_allocation=time_allocation,
-            avg_leisure_hours=avg_leisure_hours,
-            avg_education_level=simulation.tracker.get_latest_indicators().get("avg_education_level", 0.0),
-            brain_waste_count=int(simulation.tracker.get_latest_indicators().get("brain_waste_count", 0))
-        )
-
-    def _get_government_data(self, simulation: Simulation, current_tick: int) -> GovernmentTabDataDTO:
-        # Accumulated Stats
-        tax_revenue = simulation.government.tax_revenue.copy()
-        # Fiscal Balance
-        fiscal_balance = {
-            "revenue": simulation.government.total_collected_tax,
-            "expense": simulation.government.total_spent_subsidies + (simulation.government.infrastructure_level * getattr(simulation.config_module, "INFRASTRUCTURE_INVESTMENT_COST", 5000.0)) # Approx
-        }
-
-        # Phase 5: Historical Data
-        tax_history = simulation.government.tax_history
-        welfare_history = simulation.government.welfare_history
-
-        # Current Stats
-        # Use latest history point or current_tick_stats (which is reset at tick end, so might be empty if called after finalize)
-        # Snapshot is usually called after tick is done.
-        current_welfare = 0.0
-        current_avg_tax_rate = 0.0
-
-        if tax_history:
-             last = tax_history[-1]
-             # Calculate rate relative to GDP
-             gdp = simulation.tracker.get_latest_indicators().get("total_consumption", 1.0)
-             current_avg_tax_rate = (last.get("total", 0.0) / gdp) if gdp > 0 else 0.0
-
-        if welfare_history:
-             last_w = welfare_history[-1]
-             current_welfare = last_w.get("welfare", 0.0) + last_w.get("stimulus", 0.0)
-
-        return GovernmentTabDataDTO(
-            tax_revenue=tax_revenue,
-            fiscal_balance=fiscal_balance,
-            tax_revenue_history=tax_history,
-            welfare_spending=current_welfare,
-            current_avg_tax_rate=current_avg_tax_rate,
-            welfare_history=welfare_history,
-            education_spending=simulation.government.current_tick_stats.get("education_spending", 0.0) if hasattr(simulation.government, "education_history") else 0.0,
-            education_history=getattr(simulation.government, "education_history", [])
-        )
-
-    def _get_market_data(self, simulation: Simulation, current_tick: int) -> MarketTabDataDTO:
-        # Commodity Volumes (Current Tick)
-        commodity_volumes = {}
-        # Fetch from markets
-        for name, market in simulation.markets.items():
-            if hasattr(market, 'get_daily_volume'):
-                 commodity_volumes[name] = market.get_daily_volume()
-
-        # History Window
-        WINDOW_SIZE = 50
-        start_tick = max(0, current_tick - WINDOW_SIZE)
-
-        history_data = self.repository.analytics.get_economic_indicators(start_tick, current_tick, run_id=simulation.run_id)
-
-        # CPI: Weighted Average of Goods Prices
-        # In `EconomicIndicatorData`, we have `avg_goods_price` (which is weighted avg of goods).
-        # We also have `food_avg_price`.
-        # Let's use `avg_goods_price` as CPI proxy.
-        cpi = [row["avg_goods_price"] if row["avg_goods_price"] else 0.0 for row in history_data]
-
-        # Maslow Fulfillment: 100 - avg_survival_need
-        # We need `avg_survival_need` from history.
-        maslow_fulfillment = []
-        for row in history_data:
-            avg_survival = row.get("avg_survival_need") or 0.0
-            maslow_fulfillment.append(max(0.0, 100.0 - avg_survival))
-
-        return MarketTabDataDTO(
-            commodity_volumes=commodity_volumes,
-            cpi=cpi,
-            maslow_fulfillment=maslow_fulfillment
-        )
-
-    def _get_finance_data(self, simulation: Simulation, current_tick: int) -> FinanceTabDataDTO:
-        stock_market = simulation.stock_market
-
-        market_cap = 0.0
-        volume = 0.0
-        turnover = 0.0
-        dividend_yield = 0.0 # Placeholder
-
-        if stock_market:
-            # Market Cap = Sum(Price * Total Shares)
-            # We need current prices and total shares for all firms.
-            # StockMarket doesn't store total shares, Firms do.
-            for firm in simulation.firms:
-                if firm.is_active:
-                    price = stock_market.get_stock_price(firm.id) or 0.0 # get_stock_price handles None? It returns Optional[float]
-                    # If None (no trade), use last trade or reference?
-                    # StockMarket.get_stock_price returns last trade price or None.
-                    if price == 0.0:
-                         # Fallback to daily avg or reference
-                         price = stock_market.get_daily_avg_price(firm.id)
-
-                    market_cap += price * firm.total_shares
-
-            # Volume (Daily)
-            # StockMarket is a Market subclass? It has `get_daily_volume()`?
-            # StockMarket inherits from OrderBookMarket? No, from Market directly?
-            # Let's check StockMarket implementation.
-            # Assuming it aggregates volume across all tickers or we sum up.
-            # Simulation code calls `stock_market.match_orders` which likely returns transactions.
-            # Does `stock_market` have a total volume counter?
-            # Usually `get_daily_volume()` on Market returns volume for that market.
-            # If StockMarket handles multiple items (tickers), does it sum them?
-            # Let's assume yes or iterate firms if needed.
-            # `market_data` logic in engine calls `stock_market.get_daily_volume()`? No, it calls per firm?
-            # I will check StockMarket code if needed. For now, assume a method exists or sum manually.
-            pass
-
-            # Volume aggregation manually if get_daily_volume isn't global
-            # Actually, `StockMarket` has `daily_trade_volume` dict by firm_id?
-            # I'll check `stock_tracker` or `stock_market` instance.
-            # Safe bet: Iterate firms and sum volumes if `stock_market` methods are per-firm.
-            # But `market.get_daily_volume()` is abstract in `Market`.
-
-            # Volume (Daily)
-            if hasattr(stock_market, 'get_daily_volume'):
-                 volume = stock_market.get_daily_volume()
-
-            # For Turnover: Volume / Total Outstanding Shares?
-            # Total shares in market = Sum(firm.total_shares)
-            total_shares_market = sum(f.total_shares for f in simulation.firms if f.is_active)
-            if total_shares_market > 0:
-                 turnover = (volume / total_shares_market) * 100.0 # Percentage
-
-        return FinanceTabDataDTO(
-            market_cap=market_cap,
-            volume=volume,
-            turnover=turnover,
-            dividend_yield=dividend_yield
-        )
diff --git a/tests/unit/api/test_dashboard_api.py b/tests/unit/api/test_dashboard_api.py
deleted file mode 100644
index b635b898..00000000
--- a/tests/unit/api/test_dashboard_api.py
+++ /dev/null
@@ -1,177 +0,0 @@
-import unittest
-from unittest.mock import MagicMock, PropertyMock
-import pytest
-import json
-
-from simulation.engine import Simulation
-from simulation.db.repository import SimulationRepository
-from simulation.viewmodels.snapshot_viewmodel import SnapshotViewModel
-from simulation.dtos import (
-    DashboardSnapshotDTO,
-    DashboardGlobalIndicatorsDTO,
-    SocietyTabDataDTO,
-    GovernmentTabDataDTO,
-    MarketTabDataDTO,
-    FinanceTabDataDTO
-)
-from simulation.core_agents import Household
-from simulation.agents.government import Government
-from simulation.metrics.economic_tracker import EconomicIndicatorTracker
-from simulation.metrics.inequality_tracker import InequalityTracker
-from simulation.markets.stock_market import StockMarket
-from dataclasses import asdict
-
-class TestDashboardAPI:
-    def setup_method(self):
-        self.mock_repo = MagicMock(spec=SimulationRepository)
-        self.mock_simulation = MagicMock(spec=Simulation)
-        self.mock_tracker = MagicMock(spec=EconomicIndicatorTracker)
-        self.mock_inequality_tracker = MagicMock(spec=InequalityTracker)
-        self.mock_government = MagicMock(spec=Government)
-        self.mock_stock_market = MagicMock(spec=StockMarket)
-
-        self.mock_simulation.tracker = self.mock_tracker
-        self.mock_simulation.inequality_tracker = self.mock_inequality_tracker
-        self.mock_simulation.government = self.mock_government
-        self.mock_simulation.stock_market = self.mock_stock_market
-        self.mock_simulation.run_id = 1
-        self.mock_simulation.config_module = MagicMock()
-        self.mock_simulation.config_module.TARGET_POPULATION = 100
-        self.mock_simulation.config_module.MITOSIS_BASE_THRESHOLD = 1000.0
-        self.mock_simulation.config_module.MITOSIS_SENSITIVITY = 1.0
-        self.mock_simulation.config_module.INFRASTRUCTURE_INVESTMENT_COST = 5000.0
-        self.mock_simulation.config_module.HOURS_PER_TICK = 24.0
-        self.mock_simulation.config_module.SHOPPING_HOURS = 2.0
-
-        # Patch missing attributes for Government mock
-        self.mock_government.tax_history = []
-        self.mock_government.welfare_history = []
-        self.mock_government.education_history = []
-        self.mock_government.current_tick_stats = {
-            "education_spending": 0.0,
-            "welfare_spending": 0.0,
-            "stimulus_spending": 0.0,
-            "total_collected": 0.0
-        }
-
-        self.mock_simulation.markets = {}
-        self.mock_simulation.household_time_allocation = {}
-
-        self.vm = SnapshotViewModel(self.mock_repo)
-
-    def test_get_dashboard_snapshot_structure(self, golden_households, golden_firms):
-        # Arrange
-        current_tick = 100
-
-        # Inject Golden Fixtures
-        # Patch households 'needs' and 'last_leisure_type' as done in generator
-        for h in golden_households:
-            if isinstance(h._bio_state.needs, MagicMock):
-                h._bio_state.needs = {"survival": h._bio_state.needs.survival}
-            h._social_state.last_leisure_type = "IDLE"
-
-        # Patch firms 'total_shares'
-        for f in golden_firms:
-            f.total_shares = 1000.0
-
-        self.mock_simulation.households = golden_households
-        self.mock_simulation.firms = golden_firms
-
-        # Mock Global Indicators
-        self.mock_tracker.get_latest_indicators.return_value = {
-            "total_consumption": 50000.0,
-            "avg_wage": 200.0,
-            "unemployment_rate": 5.0
-        }
-
-        # Mock Inequality
-        self.mock_inequality_tracker.calculate_wealth_distribution.return_value = {
-            "gini_total_assets": 0.35
-        }
-
-        # Mock Attrition
-        self.mock_repo.get_attrition_counts.return_value = {
-            "bankruptcy_count": 2,
-            "death_count": 5
-        }
-
-        # Mock Generation Stats
-        self.mock_repo.get_generation_stats.return_value = [
-            {"gen": 0, "count": 50, "avg_assets": 1000.0},
-            {"gen": 1, "count": 50, "avg_assets": 500.0}
-        ]
-
-        # Mock Government
-        self.mock_government.tax_revenue = {"income": 1000.0, "sales": 500.0}
-        self.mock_government.total_collected_tax = 1500.0
-        self.mock_government.total_spent_subsidies = 200.0
-        self.mock_government.infrastructure_level = 1
-
-        # Mock Market History
-        self.mock_repo.get_economic_indicators.return_value = [
-            {"avg_goods_price": 10.0, "avg_survival_need": 20.0},
-            {"avg_goods_price": 11.0, "avg_survival_need": 21.0}
-        ]
-
-        # Mock Stock Market
-        self.mock_stock_market.get_daily_volume.return_value = 1000.0
-        self.mock_stock_market.get_stock_price.return_value = 10.0
-
-        # Act
-        snapshot = self.vm.get_dashboard_snapshot(self.mock_simulation, current_tick)
-
-        # Assert against Golden Snapshot
-        # Convert to dict
-        result = asdict(snapshot)
-
-        with open("tests/integration/goldens/dashboard_snapshot.json") as f:
-            expected = json.load(f)
-
-        # Legacy fields cleanup (SnapshotDTO evolved)
-        if "goods_data" in expected:
-            del expected["goods_data"]
-        if "market_data" in expected:
-            del expected["market_data"]
-
-        assert result == expected, "Dashboard structure changed"
-
-    def test_dashboard_api_endpoint_mock(self):
-        # Verify DTO to Dict conversion (Contract check)
-        from dataclasses import asdict
-
-        # Act: Create a dummy DTO
-        dto = DashboardSnapshotDTO(
-            tick=100,
-            global_indicators=DashboardGlobalIndicatorsDTO(
-                death_rate=0.0, bankruptcy_rate=0.0, employment_rate=100.0,
-                gdp=1000.0, avg_wage=10.0, gini=0.2, avg_tax_rate=0.0, avg_leisure_hours=0.0, parenting_rate=0.0
-            ),
-            tabs={
-                "society": SocietyTabDataDTO(
-                    generations=[], mitosis_cost=100.0, unemployment_pie={},
-                    time_allocation={}, avg_leisure_hours=0.0, avg_education_level=0.0, brain_waste_count=0
-                ),
-                "government": GovernmentTabDataDTO(
-                    tax_revenue={}, fiscal_balance={}, tax_revenue_history=[], welfare_spending=0.0,
-                    current_avg_tax_rate=0.0, welfare_history=[], education_spending=0.0, education_history=[]
-                ),
-                "market": MarketTabDataDTO(
-                    commodity_volumes={}, cpi=[], maslow_fulfillment=[]
-                ),
-                "finance": FinanceTabDataDTO(
-                    market_cap=1000.0, volume=100.0, turnover=0.1, dividend_yield=0.0
-                )
-            }
-        )
-
-        # Verify it can be converted to dict (simulating what happens before jsonify)
-        result = asdict(dto)
-
-        assert result["tick"] == 100
-        assert "global_indicators" in result
-        assert result["global_indicators"]["gdp"] == 1000.0
-        assert "tabs" in result
-        assert "society" in result["tabs"]
-
-if __name__ == "__main__":
-    pytest.main([__file__])
diff --git a/verification/verify_dto_structure.py b/verification/verify_dto_structure.py
new file mode 100644
index 00000000..66050b3b
--- /dev/null
+++ b/verification/verify_dto_structure.py
@@ -0,0 +1,71 @@
+import json
+import dataclasses
+from dataclasses import asdict
+from simulation.dtos.watchtower import (
+    WatchtowerSnapshotDTO, IntegrityDTO, MacroDTO, FinanceDTO,
+    FinanceRatesDTO, FinanceSupplyDTO, PoliticsDTO, PoliticsApprovalDTO,
+    PoliticsStatusDTO, PoliticsFiscalDTO, PopulationDTO,
+    PopulationDistributionDTO, PopulationMetricsDTO
+)
+
+MOCK_PATH = "design/3_work_artifacts/specs/golden_samples/watchtower_full_mock_v2.json"
+
+def verify_dto():
+    print(f"Loading mock from {MOCK_PATH}...")
+    with open(MOCK_PATH, 'r') as f:
+        mock_data = json.load(f)
+
+    print("Instantiating DTOs...")
+    try:
+        # Manual instantiation to check every field matches
+        snapshot = WatchtowerSnapshotDTO(
+            tick=mock_data['tick'],
+            status=mock_data['status'],
+            integrity=IntegrityDTO(**mock_data['integrity']),
+            macro=MacroDTO(**mock_data['macro']),
+            finance=FinanceDTO(
+                rates=FinanceRatesDTO(**mock_data['finance']['rates']),
+                supply=FinanceSupplyDTO(**mock_data['finance']['supply'])
+            ),
+            politics=PoliticsDTO(
+                approval=PoliticsApprovalDTO(**mock_data['politics']['approval']),
+                status=PoliticsStatusDTO(**mock_data['politics']['status']),
+                fiscal=PoliticsFiscalDTO(**mock_data['politics']['fiscal'])
+            ),
+            population=PopulationDTO(
+                distribution=PopulationDistributionDTO(**mock_data['population']['distribution']),
+                active_count=mock_data['population']['active_count'],
+                metrics=PopulationMetricsDTO(**mock_data['population']['metrics'])
+            )
+        )
+        print("DTO instantiated successfully.")
+    except TypeError as e:
+        print(f"FAILED to instantiate DTO: {e}")
+        exit(1)
+    except KeyError as e:
+        print(f"FAILED to find key in mock: {e}")
+        exit(1)
+
+    print("Converting back to dict...")
+    dto_dict = asdict(snapshot)
+
+    print("Comparing structures...")
+    # Basic check - keys should match
+    # Note: floating point comparison might be tricky for exact equality,
+    # but structure equality is what we care about here.
+
+    # Check top level keys
+    assert dto_dict.keys() == mock_data.keys()
+
+    # Check nested keys recursively (simplified)
+    assert dto_dict['integrity'] == mock_data['integrity']
+    assert dto_dict['macro'] == mock_data['macro']
+    assert dto_dict['finance'] == mock_data['finance']
+    assert dto_dict['politics'] == mock_data['politics']
+    # Population metrics might need float tolerance if logic was involved, but here it's pass-through
+    assert dto_dict['population'] == mock_data['population']
+
+    print("VERIFICATION PASSED: DTO matches Mock exactly.")
+
+if __name__ == "__main__":
+    verify_dto()
diff --git a/verification/verify_metrics_logic.py b/verification/verify_metrics_logic.py
new file mode 100644
index 00000000..c1164892
--- /dev/null
+++ b/verification/verify_metrics_logic.py
@@ -0,0 +1,116 @@
+import unittest
+from unittest.mock import MagicMock
+from typing import Dict, Any
+
+from simulation.metrics.economic_tracker import EconomicIndicatorTracker
+from modules.system.api import DEFAULT_CURRENCY
+
+# Mocks
+class MockWallet:
+    def __init__(self, balances):
+        self.balances = balances
+    def get_all_balances(self):
+        return self.balances
+
+class MockHolding:
+    def __init__(self, quantity):
+        self.quantity = quantity
+
+class MockPortfolio:
+    def __init__(self, holdings):
+        self.holdings = holdings
+
+class MockEconState:
+    def __init__(self, assets_val, stock_qty=0):
+        self.assets = {DEFAULT_CURRENCY: assets_val}
+        self.wallet = MockWallet(self.assets)
+        self.labor_income_this_tick = 100.0
+        self.current_consumption = 50.0
+        self.current_food_consumption = 10.0
+        self.education_level = 1
+        self.aptitude = 0.5
+        self.is_employed = True
+        self.portfolio = MockPortfolio({1: MockHolding(stock_qty)})
+
+class MockSocialState:
+    def __init__(self, trust):
+        self.trust_score = trust
+
+class MockBioState:
+    def __init__(self, active=True):
+        self.is_active = active
+        self.needs = {"survival": 0.5}
+
+class MockHousehold:
+    def __init__(self, assets, trust, active=True):
+        self._econ_state = MockEconState(assets)
+        self._social_state = MockSocialState(trust)
+        self._bio_state = MockBioState(active)
+
+class MockStockMarket:
+    def get_stock_price(self, firm_id):
+        return 10.0 # Fixed price 10.0
+
+class VerifyMetrics(unittest.TestCase):
+    def setUp(self):
+        self.mock_config = MagicMock()
+        self.tracker = EconomicIndicatorTracker(self.mock_config)
+        self.tracker.exchange_engine.convert = lambda amt, f, t: amt
+        self.tracker.exchange_engine.get_all_rates = lambda: {}
+
+        self.stock_market = MockStockMarket()
+        self.markets = {"stock_market": self.stock_market}
+
+    def test_gini(self):
+        self.assertAlmostEqual(self.tracker.calculate_gini_coefficient([10, 10, 10]), 0.0)
+        self.assertAlmostEqual(self.tracker.calculate_gini_coefficient([0, 10]), 0.5)
+
+    def test_cohesion(self):
+        h1 = MockHousehold(10, 0.8)
+        h2 = MockHousehold(20, 0.4)
+        cohesion = self.tracker.calculate_social_cohesion([h1, h2])
+        self.assertAlmostEqual(cohesion, 0.6)
+
+    def test_population_metrics(self):
+        # 5 households
+        households = [
+            MockHousehold(10, 0.5),
+            MockHousehold(20, 0.5),
+            MockHousehold(30, 0.5),
+            MockHousehold(40, 0.5),
+            MockHousehold(50, 0.5)
+        ]
+        metrics = self.tracker.calculate_population_metrics(households, self.markets)
+        self.assertEqual(metrics["active_count"], 5)
+        dist = metrics["distribution"]
+        # Stock qty is 0 by default in MockHousehold init (unless customized)
+        # MockEconState default stock_qty=0
+        self.assertEqual(dist["q1"], 10.0)
+        self.assertEqual(dist["q5"], 50.0)
+
+    def test_wealth_with_stocks(self):
+        # Cash 100, Stock 10 * 10.0 = 200 Total
+        h = MockHousehold(100, 0.5)
+        # Manually set econ state with stocks
+        h._econ_state = MockEconState(100, 10) # 10 shares
+
+        metrics = self.tracker.calculate_population_metrics([h], self.markets)
+        self.assertEqual(metrics["all_assets"][0], 200.0)
+
+    def test_track(self):
+        # Household with 100 cash, 10 shares (worth 100) -> 200 total
+        h = MockHousehold(100, 0.9)
+        h._econ_state = MockEconState(100, 10)
+        households = [h]
+        firms = []
+
+        self.tracker.track(1, households, firms, self.markets)
+
+        latest = self.tracker.get_latest_indicators()
+        self.assertAlmostEqual(latest["social_cohesion"], 0.9)
+        self.assertAlmostEqual(latest["gini"], 0.0)
+        self.assertEqual(latest["active_population"], 1)
+        self.assertEqual(latest["quintile_1_avg_assets"], 200.0)
+
+if __name__ == '__main__':
+    unittest.main()
