diff --git a/communications/insights/THOUGHTSTREAM-INSTRUMENTATION.md b/communications/insights/THOUGHTSTREAM-INSTRUMENTATION.md
new file mode 100644
index 0000000..134b606
--- /dev/null
+++ b/communications/insights/THOUGHTSTREAM-INSTRUMENTATION.md
@@ -0,0 +1,13 @@
+# Insight Report: Agent Decision-Making Observability
+
+### 현상 (Phenomenon)
+시뮬레이션에서 기업의 생산 중단이나 가계의 소비 실패와 같은 이상 현상이 발생했을 때, 로그만으로는 그 근본적인 원인을 파악하기 어려웠다. 이는 경제 침체나 시스템 붕괴의 원인 분석을 지연시키는 주요 원인이었다.
+
+### 원인 (Cause)
+기존 시스템은 에이전트가 특정 행동을 수행하지 않기로 결정한 '이유'를 기록하지 않았다. 예를 들어, 자금이 부족해 생산을 못 하는 것인지, 원자재가 없어 못 하는 것인지 구분할 수 없었다. 결정 과정이 코드의 제어 흐름 속에 암묵적으로만 존재했다.
+
+### 해결 (Solution)
+"ThoughtStream" 로깅 시스템을 도입하여 주요 의사결정 지점을 계측(instrument)했다. 이제 에이전트가 특정 행동을 중단하거나 거부할 때, `LIQUIDITY_CRUNCH`, `INPUT_SHORTAGE`, `INSOLVENT` 등 구체적인 이유를 진단하여 별도의 DB에 기록한다. 이를 통해 특정 에이전트의 실패 원인을 명확하게 추적할 수 있게 되었다.
+
+### 교훈 (Lesson Learned)
+거시적인 현상을 이해하기 위해서는 개별 에이전트 수준의 의사결정 과정에 대한 가시성 확보가 필수적이다. 단순히 '무엇을' 했는지가 아니라 '왜' 그렇게 행동했는지(또는 행동하지 않았는지)를 기록하는 것은 디버깅과 시스템 분석의 효율을 극적으로 향상시킨다.
diff --git a/simulation/__init__.py b/simulation/__init__.py
index e69de29..ee1e417 100644
--- a/simulation/__init__.py
+++ b/simulation/__init__.py
@@ -0,0 +1 @@
+logger = None
diff --git a/simulation/components/production_department.py b/simulation/components/production_department.py
index 11c6199..83954e8 100644
--- a/simulation/components/production_department.py
+++ b/simulation/components/production_department.py
@@ -2,6 +2,7 @@ from __future__ import annotations
 from typing import TYPE_CHECKING
 import logging
 import math
+import simulation
 
 if TYPE_CHECKING:
     from simulation.firms import Firm
@@ -24,6 +25,15 @@ class ProductionDepartment:
         try:
             # [EARLY EXIT]
             if len(self.firm.hr.employees) == 0:
+                if simulation.logger:
+                    simulation.logger.log_thought(
+                        tick=current_time,
+                        agent_id=str(self.firm.id),
+                        action="PRODUCE",
+                        decision="HALT",
+                        reason="NO_EMPLOYEES",
+                        context={}
+                    )
                 return 0.0
 
             log_extra = {"tick": current_time, "agent_id": self.firm.id, "tags": ["production"]}
@@ -96,6 +106,51 @@ class ProductionDepartment:
                 if actual_produced > 0:
                     self.firm.add_inventory(self.firm.specialization, actual_produced, actual_quality)
 
+            # ThoughtStream: Instrument halted production
+            if actual_produced == 0.0 and simulation.logger:
+                 reason = "UNKNOWN"
+                 context = {}
+
+                 # 2. Check Liquidity (Wage Bill)
+                 wage_bill = 0.0
+                 for employee in self.firm.hr.employees:
+                     base = self.firm.hr.employee_wages.get(employee.id, 0.0)
+                     wage = self.firm.hr.calculate_wage(employee, base)
+                     wage_bill += wage
+
+                 if self.firm.assets < wage_bill:
+                     reason = "LIQUIDITY_CRUNCH"
+                     context = {"cash": self.firm.assets, "wage_bill": wage_bill}
+
+                 # 3. Check Input Shortage
+                 elif produced_quantity > 0:
+                     # If we theoretically could produce (labor & capital > 0) but actual is 0
+                     input_config = self.config.goods.get(self.firm.specialization, {}).get("inputs", {})
+                     if input_config:
+                         for mat, req in input_config.items():
+                             if req > 0 and self.firm.input_inventory.get(mat, 0.0) == 0:
+                                  reason = "INPUT_SHORTAGE"
+                                  context = {"input_inventory": self.firm.input_inventory.copy()}
+                                  break
+
+                 # 4. Check Overstock
+                 if reason == "UNKNOWN":
+                     target = self.firm.production_target
+                     current_inv = self.firm.inventory.get(self.firm.specialization, 0.0)
+                     if current_inv > target * 2.0:
+                          reason = "OVERSTOCK"
+                          context = {"inventory": current_inv, "target": target}
+
+                 if reason != "UNKNOWN":
+                     simulation.logger.log_thought(
+                        tick=current_time,
+                        agent_id=str(self.firm.id),
+                        action="PRODUCE",
+                        decision="HALT",
+                        reason=reason,
+                        context=context
+                     )
+
             return actual_produced
 
         except Exception as e:
diff --git a/simulation/core_agents.py b/simulation/core_agents.py
index c8cb418..9fe04fb 100644
--- a/simulation/core_agents.py
+++ b/simulation/core_agents.py
@@ -23,6 +23,7 @@ from simulation.portfolio import Portfolio
 from simulation.ai.household_ai import HouseholdAI
 from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
 from simulation.systems.api import LifecycleContext, MarketInteractionContext, LearningUpdateContext, ILearningAgent
+import simulation
 
 # New Components
 from modules.household.bio_component import BioComponent
@@ -726,6 +727,51 @@ class Household(BaseAgent, ILearningAgent):
             self.config
         )
         self._bio_state.needs = new_needs
+
+        # ThoughtStream: Instrument non-consumption
+        if not consumed_items and simulation.logger:
+             reason = "UNKNOWN"
+             context = {}
+
+             # 1. Check Needs (Urgency)
+             # Note: Needs represent deficit/hunger (0 = satisfied, High = hungry)
+             survival_need = self.needs.get("survival", 0.0)
+             threshold = self.config.survival_need_consumption_threshold
+
+             if survival_need > threshold:
+                 # We wanted to consume (Hungry) but didn't. Why?
+
+                 # Check Inventory for food
+                 has_food = any(self.inventory.get(f, 0) > 0 for f in ["food", "basic_food", "luxury_food"])
+
+                 if not has_food:
+                     # Stock Out. Could we afford it?
+                     price = self._econ_state.perceived_avg_prices.get("food", self.config.default_fallback_price)
+
+                     if self.assets < price:
+                         reason = "INSOLVENT"
+                         context = {"cash": self.assets, "price": price, "need": survival_need}
+                     else:
+                         reason = "STOCK_OUT"
+                         context = {"inventory": self.inventory.copy(), "cash": self.assets}
+                 else:
+                     # Has food but didn't consume?
+                     # This implies inventory was skipped or logic failed?
+                     # Or maybe inventory is non-food items?
+                     reason = "UTILITY_CONSTRAINT"
+             else:
+                 reason = "SATISFIED"
+
+             if reason != "SATISFIED":
+                 simulation.logger.log_thought(
+                    tick=current_time,
+                    agent_id=str(self.id),
+                    action="CONSUME_FOOD",
+                    decision="REJECT",
+                    reason=reason,
+                    context=context
+                 )
+
         self.update_needs(current_time, market_data)
         return consumed_items
 
diff --git a/simulation/engine.py b/simulation/engine.py
index 363427f..8ef3d4c 100644
--- a/simulation/engine.py
+++ b/simulation/engine.py
@@ -14,6 +14,9 @@ from simulation.action_processor import ActionProcessor
 from simulation.models import Transaction
 from modules.simulation.api import MarketSnapshotDTO, SystemStateDTO
 
+from simulation.db.logger import SimulationLogger
+import simulation
+
 logger = logging.getLogger(__name__)
 
 
@@ -40,12 +43,18 @@ class Simulation:
         self.action_processor = ActionProcessor(self.world_state)
         self.tick_orchestrator = TickOrchestrator(self.world_state, self.action_processor)
 
+        # Initialize SimulationLogger
+        db_path = self.world_state.config_manager.get("simulation.database_name", "simulation_data.db")
+        self.simulation_logger = SimulationLogger(db_path)
+        # Expose via global module attribute for access by agents
+        simulation.logger = self.simulation_logger
+
     def __getattr__(self, name: str) -> Any:
         return getattr(self.world_state, name)
 
     def __setattr__(self, name: str, value: Any) -> None:
         # Avoid infinite recursion for internal components
-        if name in ["world_state", "tick_orchestrator", "action_processor"]:
+        if name in ["world_state", "tick_orchestrator", "action_processor", "simulation_logger"]:
             super().__setattr__(name, value)
             return
 
@@ -62,10 +71,12 @@ class Simulation:
         
         self.world_state.repository.update_simulation_run_end_time(self.world_state.run_id)
         self.world_state.repository.close()
+        self.simulation_logger.close()
         self.world_state.logger.info("Simulation finalized and Repository connection closed.")
 
     def run_tick(self, injectable_sensory_dto: Optional[GovernmentStateDTO] = None) -> None:
         self.tick_orchestrator.run_tick(injectable_sensory_dto)
+        self.simulation_logger.flush()
 
     def get_all_agents(self) -> List[Any]:
         """시뮬레이션에 참여하는 모든 활성 에이전트(가계, 기업, 은행 등)를 반환합니다."""
