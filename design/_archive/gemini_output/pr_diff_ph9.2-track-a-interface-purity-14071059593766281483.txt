diff --git a/communications/insights/PH9.2_TrackA.md b/communications/insights/PH9.2_TrackA.md
new file mode 100644
index 00000000..587d0298
--- /dev/null
+++ b/communications/insights/PH9.2_TrackA.md
@@ -0,0 +1,30 @@
+# Technical Insight Report: Phase 9.2 Track A (Financial SSoT)
+
+**Mission Key:** PH9.2_TrackA
+**Status:** IMPLEMENTED
+**Date:** 2026-02-10
+
+## 1. Problem Phenomenon
+The legacy `SettlementSystem` relied on direct attribute access (`agent.assets`) and untyped checks (e.g., `hasattr(agent, 'wallet')`) to perform financial transfers. This violated the Single Source of Truth (SSoT) principle and made it impossible to enforce zero-sum integrity, as any module could arbitrarily mutate an agent's cash balance. Furthermore, the `Bank` class had ambiguous interfaces for accessing its own equity versus customer deposits.
+
+## 2. Root Cause Analysis
+*   **Lack of Formal Protocols:** There was no strict contract defining what a "Financial Agent" is. Agents implemented ad-hoc methods or exposed raw state.
+*   **Ambiguous Dependencies:** `SettlementSystem` depended on `Optional[Any]` for the bank, leading to "duck typing" that was fragile and hard to test.
+*   **Method Name Collision:** Both the generic financial agent interface and the specific banking service interface used `get_balance`, but with different semantics (Own Equity vs. Customer Deposit).
+
+## 3. Solution Implementation Details
+### 3.1 Protocol Definition
+We introduced two strict protocols in `modules/finance/api.py`:
+1.  `IFinancialAgent`: Defines `deposit`, `withdraw`, and `get_balance(currency)`. This represents an entity's *own* wallet.
+2.  `IBank`: Defines banking services. Crucially, we renamed the customer balance accessor to `get_customer_balance(agent_id)` to avoid conflict with `IFinancialAgent.get_balance`.
+
+### 3.2 Refactoring
+*   **SettlementSystem:** Refactored `transfer` and `_execute_withdrawal` to use `IFinancialAgent` methods exclusively. It now uses the EAFP (Easier to Ask for Forgiveness than Permission) pattern by attempting `withdraw` and catching `InsufficientFundsError`, rather than inspecting state beforehand.
+*   **Agents:** Updated `Household`, `Firm`, `Government`, and `Bank` to strictly implement `IFinancialAgent`.
+*   **Bank:** Implemented dual interfaces. The `Bank` acts as an `IFinancialAgent` for its reserves and an `IBank` for its customers.
+
+## 4. Lessons Learned & Technical Debt
+*   **Protocol Method Collisions:** When an entity plays multiple roles (e.g., Bank as an Agent and Bank as a Service), method names must be distinct. `get_balance` was too generic. We resolved this by renaming the service method to `get_customer_balance`.
+*   **Dependency Injection:** Injecting `IBank` into `SettlementSystem` (instead of `Any`) allowed for robust type checking and clearer intent.
+*   **Legacy Support:** We left some legacy fallbacks (e.g., checking `IFinancialEntity`) in `SettlementSystem` to prevent immediate regression in untested corners of the simulation, but these should be removed in a future cleanup phase.
+*   **Technical Debt:** The `CurrencyCode` type alias is just `str`, which limits static analysis. Future refactoring should consider making it a NewType or Enum.
diff --git a/modules/finance/api.py b/modules/finance/api.py
index 91832b87..8b767839 100644
--- a/modules/finance/api.py
+++ b/modules/finance/api.py
@@ -5,14 +5,13 @@ import abc
 from abc import ABC, abstractmethod
 from uuid import UUID
 from modules.finance.dtos import MoneyDTO, MultiCurrencyWalletDTO, LoanApplicationDTO, LoanDTO, DepositDTO
-from modules.system.api import MarketContextDTO
+from modules.system.api import MarketContextDTO, DEFAULT_CURRENCY, CurrencyCode
 
 if TYPE_CHECKING:
     from modules.simulation.api import IGovernment, EconomicIndicatorsDTO
     from simulation.models import Order, Transaction
     from modules.common.dtos import Claim
     from modules.finance.wallet.api import IWallet
-    from modules.system.api import CurrencyCode
 
 # Forward reference for type hinting
 class Firm: pass
@@ -248,6 +247,7 @@ class IFinancialEntity(Protocol):
     """
     Protocol for any entity that possesses assets and participates in financial transactions.
     Native implementation operates exclusively on DEFAULT_CURRENCY.
+    DEPRECATED: Prefer IFinancialAgent for multi-currency support.
     """
     id: int
 
@@ -269,26 +269,41 @@ class IFinancialEntity(Protocol):
         """
         ...
 
-class IBankService(IFinancialEntity, Protocol):
+@runtime_checkable
+class IFinancialAgent(Protocol):
+    """
+    Strict protocol for any agent participating in the financial system.
+    Supports multi-currency operations and replaces direct attribute access.
+    """
+    id: int
+
+    def deposit(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
+        """Deposits a specific amount of a given currency."""
+        ...
+
+    def withdraw(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
+        """
+        Withdraws a specific amount of a given currency.
+        Raises InsufficientFundsError if funds are insufficient.
+        """
+        ...
+
+    def get_balance(self, currency: CurrencyCode = DEFAULT_CURRENCY) -> float:
+        """Returns the current balance for the specified currency."""
+        ...
+
+
+class IBank(IFinancialAgent, Protocol):
     """
     Interface for commercial and central banks, providing core banking services.
     Designed to be used as a dependency for Household and Firm agents.
+    Inherits IFinancialAgent for its own equity/reserves management.
     """
 
     @abc.abstractmethod
     def grant_loan(self, borrower_id: str, amount: float, interest_rate: float, due_tick: Optional[int] = None, borrower_profile: Optional[BorrowerProfileDTO] = None) -> Optional[LoanInfoDTO]:
         """
         Grants a loan to a borrower.
-
-        Args:
-            borrower_id: The ID of the entity receiving the loan (Household or Firm).
-            amount: The principal amount of the loan.
-            interest_rate: The annual interest rate for the loan.
-            due_tick: Optional. The simulation tick when the loan is due. If None, it's an open-ended loan.
-            borrower_profile: Optional. DTO with financial data for credit scoring.
-
-        Returns:
-            A LoanInfoDTO if the loan is successfully granted, otherwise None.
         """
         ...
 
@@ -296,17 +311,6 @@ class IBankService(IFinancialEntity, Protocol):
     def stage_loan(self, borrower_id: str, amount: float, interest_rate: float, due_tick: Optional[int] = None, borrower_profile: Optional[BorrowerProfileDTO] = None) -> Optional[LoanInfoDTO]:
         """
         Creates a loan record but does not disburse funds (no deposit creation).
-        Used for atomic settlements where funds are transferred directly from Bank Reserves via SettlementSystem.
-
-        Args:
-            borrower_id: The ID of the entity receiving the loan.
-            amount: The principal amount.
-            interest_rate: The annual interest rate.
-            due_tick: Optional due tick.
-            borrower_profile: Optional credit scoring profile.
-
-        Returns:
-            A LoanInfoDTO if the loan is successfully staged, otherwise None.
         """
         ...
 
@@ -314,30 +318,14 @@ class IBankService(IFinancialEntity, Protocol):
     def repay_loan(self, loan_id: str, amount: float) -> bool:
         """
         Repays a portion or the full amount of a specific loan.
-
-        Args:
-            loan_id: The unique identifier of the loan to be repaid.
-            amount: The amount to repay.
-
-        Returns:
-            True if the repayment is successful and the loan is updated, False otherwise.
-
-        Raises:
-            LoanNotFoundError: If the loan_id does not correspond to an active loan.
-            LoanRepaymentError: If there's an issue processing the repayment (e.g., negative amount).
         """
         ...
 
     @abc.abstractmethod
-    def get_balance(self, account_id: str) -> float:
+    def get_customer_balance(self, agent_id: str) -> float:
         """
-        Retrieves the current balance for a given account.
-
-        Args:
-            account_id: The ID of the account owner (Household or Firm).
-
-        Returns:
-            The current monetary balance of the account.
+        Retrieves the current balance for a given CUSTOMER account (deposit).
+        Use get_balance(currency) for the Bank's own funds.
         """
         ...
 
@@ -345,12 +333,6 @@ class IBankService(IFinancialEntity, Protocol):
     def get_debt_status(self, borrower_id: str) -> DebtStatusDTO:
         """
         Retrieves the comprehensive debt status for a given borrower.
-
-        Args:
-            borrower_id: The ID of the entity whose debt status is requested.
-
-        Returns:
-            A DebtStatusDTO containing details about all outstanding loans and overall debt.
         """
         ...
 
@@ -358,10 +340,19 @@ class IBankService(IFinancialEntity, Protocol):
     def terminate_loan(self, loan_id: str) -> Optional["Transaction"]:
         """
         Forcefully terminates a loan (e.g. foreclosure or voiding).
-        Returns a credit_destruction transaction if balance was > 0.
         """
         ...
 
+    @abc.abstractmethod
+    def withdraw_for_customer(self, agent_id: int, amount: float) -> bool:
+        """
+        Withdraws funds from a customer's deposit account.
+        """
+        ...
+
+# Alias for backward compatibility during refactor
+IBankService = IBank
+
 class IFiscalMonitor(Protocol):
     """Interface for the fiscal health analysis component."""
     def get_debt_to_gdp_ratio(self, government: "IGovernment", indicators: "EconomicIndicatorsDTO") -> float: ...
diff --git a/simulation/agents/government.py b/simulation/agents/government.py
index e7c25778..615cf6d1 100644
--- a/simulation/agents/government.py
+++ b/simulation/agents/government.py
@@ -13,7 +13,7 @@ from simulation.utils.shadow_logger import log_shadow
 from simulation.models import Transaction
 from simulation.systems.ministry_of_education import MinistryOfEducation
 from simulation.portfolio import Portfolio
-from modules.finance.api import InsufficientFundsError, TaxCollectionResult, IPortfolioHandler, PortfolioDTO, PortfolioAsset, IFinancialEntity
+from modules.finance.api import InsufficientFundsError, TaxCollectionResult, IPortfolioHandler, PortfolioDTO, PortfolioAsset, IFinancialEntity, IFinancialAgent
 from modules.government.dtos import (
     FiscalPolicyDTO,
     PaymentRequestDTO,
@@ -39,7 +39,7 @@ if TYPE_CHECKING:
 
 logger = logging.getLogger(__name__)
 
-class Government(ICurrencyHolder, IFinancialEntity):
+class Government(ICurrencyHolder, IFinancialEntity, IFinancialAgent):
     """
     정부 에이전트. 세금을 징수하고 보조금을 지급하거나 인프라에 투자합니다.
     """
@@ -668,6 +668,10 @@ class Government(ICurrencyHolder, IFinancialEntity):
         # Wallet checks sufficiency
         self.wallet.subtract(amount, currency)
 
+    def get_balance(self, currency: CurrencyCode = DEFAULT_CURRENCY) -> float:
+        """Implements IFinancialAgent.get_balance."""
+        return self.wallet.get_balance(currency)
+
     # WO-054: Public Education System
     def run_public_education(self, agents: List[Any], config_module: Any, current_tick: int) -> List[Transaction]:
         """
diff --git a/simulation/bank.py b/simulation/bank.py
index 14c3f1bf..2a192918 100644
--- a/simulation/bank.py
+++ b/simulation/bank.py
@@ -4,7 +4,8 @@ import math
 from modules.common.config_manager.api import ConfigManager
 from modules.finance.api import (
     InsufficientFundsError,
-    IBankService,
+    IBank,
+    IBankService, # Alias
     LoanInfoDTO,
     DebtStatusDTO,
     LoanNotFoundError,
@@ -16,7 +17,9 @@ from modules.finance.api import (
     IDepositManager,
     IShareholderRegistry,
     IPortfolioHandler,
-    ICreditFrozen
+    ICreditFrozen,
+    IFinancialAgent,
+    IFinancialEntity
 )
 from modules.simulation.api import IEducated
 from modules.finance.managers.loan_manager import LoanManager
@@ -38,13 +41,12 @@ logger = logging.getLogger(__name__)
 _DEFAULT_TICKS_PER_YEAR = 365.0
 _DEFAULT_INITIAL_BASE_ANNUAL_RATE = 0.03
 
-from modules.finance.api import IFinancialEntity
-
-class Bank(IBankService, ICurrencyHolder, IFinancialEntity):
+class Bank(IBank, ICurrencyHolder, IFinancialEntity):
     """
     Phase 3: Central & Commercial Bank Hybrid System.
     WO-109: Refactored for Sacred Sequence (Transactions).
     TD-274: Decomposed into LoanManager and DepositManager Facade.
+    PH9.2: Implements IBank & IFinancialAgent for Protocol Purity.
     """
 
     def __init__(self, id: int, initial_assets: float, config_manager: ConfigManager,
@@ -96,6 +98,8 @@ class Bank(IBankService, ICurrencyHolder, IFinancialEntity):
     def wallet(self) -> IWallet:
         return self._wallet
 
+    # --- IFinancialEntity Implementation (Deprecated/Legacy) ---
+
     @property
     def assets(self) -> float:
         """
@@ -103,8 +107,28 @@ class Bank(IBankService, ICurrencyHolder, IFinancialEntity):
         """
         return self._wallet.get_balance(DEFAULT_CURRENCY)
 
+    # --- IFinancialAgent Implementation ---
+
+    def deposit(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
+        if amount <= 0:
+            raise ValueError("Deposit amount must be positive.")
+        self._wallet.add(amount, currency, memo="Deposit")
+
+    def withdraw(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
+        if amount <= 0:
+            raise ValueError("Withdrawal amount must be positive.")
+        self._wallet.subtract(amount, currency, memo="Withdraw")
+
+    def get_balance(self, currency: CurrencyCode = DEFAULT_CURRENCY) -> float:
+        """
+        Returns the Bank's OWN funds (Reserves/Equity).
+        Implements IFinancialAgent.get_balance.
+        """
+        return self._wallet.get_balance(currency)
+
+    # --- ICurrencyHolder Implementation ---
+
     def get_assets_by_currency(self) -> Dict[CurrencyCode, float]:
-        """Implementation of ICurrencyHolder."""
         return self._wallet.get_all_balances()
 
     def _internal_add_assets(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
@@ -131,7 +155,7 @@ class Bank(IBankService, ICurrencyHolder, IFinancialEntity):
         self.base_rate = new_rate
         logger.info(f"MONETARY_POLICY | Base Rate updated: {self.base_rate:.2%}")
 
-    # --- IBankService Implementation ---
+    # --- IBank Implementation ---
 
     def grant_loan(self, borrower_id: str, amount: float, interest_rate: float, due_tick: Optional[int] = None, borrower_profile: Optional[BorrowerProfileDTO] = None) -> Optional[Tuple[LoanInfoDTO, Transaction]]:
         """
@@ -233,9 +257,13 @@ class Bank(IBankService, ICurrencyHolder, IFinancialEntity):
         # Delegate to LoanManager (Protocol guaranteed)
         return self.loan_manager.repay_loan(loan_id, amount)
 
-    def get_balance(self, account_id: str) -> float:
+    def get_customer_balance(self, agent_id: str) -> float:
+        """
+        Retrieves the current balance for a given CUSTOMER account (deposit).
+        Renamed from get_balance to avoid conflict with IFinancialAgent.get_balance.
+        """
         try:
-            aid_int = int(account_id)
+            aid_int = int(agent_id)
             return self.deposit_manager.get_balance(aid_int)
         except ValueError:
             return 0.0
@@ -301,16 +329,6 @@ class Bank(IBankService, ICurrencyHolder, IFinancialEntity):
 
         return True
 
-    def deposit(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
-        if amount <= 0:
-            raise ValueError("Deposit amount must be positive.")
-        self._wallet.add(amount, currency, memo="Deposit")
-
-    def withdraw(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
-        if amount <= 0:
-            raise ValueError("Withdrawal amount must be positive.")
-        self._wallet.subtract(amount, currency, memo="Withdraw")
-
     def get_debt_summary(self, agent_id: int) -> Dict[str, float]:
         loans = self.loan_manager.get_loans_for_agent(agent_id)
         total_principal = sum(l['remaining_principal'] for l in loans)
diff --git a/simulation/core_agents.py b/simulation/core_agents.py
index 1c9e84c2..dc5d039d 100644
--- a/simulation/core_agents.py
+++ b/simulation/core_agents.py
@@ -22,7 +22,7 @@ from modules.simulation.api import AgentCoreConfigDTO, IDecisionEngine, IOrchest
 from simulation.ai.household_ai import HouseholdAI
 from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
 from simulation.systems.api import LifecycleContext, MarketInteractionContext, LearningUpdateContext, ILearningAgent
-from modules.finance.api import IFinancialEntity, ICreditFrozen
+from modules.finance.api import IFinancialEntity, IFinancialAgent, ICreditFrozen
 from modules.simulation.api import IEducated
 from modules.system.api import DEFAULT_CURRENCY, CurrencyCode
 from modules.finance.wallet.wallet import Wallet
@@ -72,6 +72,7 @@ class Household(
     IEmployeeDataProvider,
     IEducated,
     IFinancialEntity,
+    IFinancialAgent,
     IOrchestratorAgent,
     ICreditFrozen,
     IInventoryHandler
@@ -377,18 +378,22 @@ class Household(
         return self._econ_state.wallet.get_balance(DEFAULT_CURRENCY)
 
     @override
-    def deposit(self, amount: float) -> None:
+    def deposit(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
         """
-        Deposits a given amount of DEFAULT_CURRENCY into the wallet.
+        Deposits a given amount of currency into the wallet.
         """
-        self._econ_state.wallet.add(amount, currency=DEFAULT_CURRENCY, memo="Deposit")
+        self._econ_state.wallet.add(amount, currency=currency, memo="Deposit")
 
     @override
-    def withdraw(self, amount: float) -> None:
+    def withdraw(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
         """
-        Withdraws a given amount of DEFAULT_CURRENCY from the wallet.
+        Withdraws a given amount of currency from the wallet.
         """
-        self._econ_state.wallet.subtract(amount, currency=DEFAULT_CURRENCY, memo="Withdraw")
+        self._econ_state.wallet.subtract(amount, currency=currency, memo="Withdraw")
+
+    def get_balance(self, currency: CurrencyCode = DEFAULT_CURRENCY) -> float:
+        """Implements IFinancialAgent.get_balance."""
+        return self._econ_state.wallet.get_balance(currency)
 
     @override
     def get_assets_by_currency(self) -> Dict[CurrencyCode, float]:
diff --git a/simulation/firms.py b/simulation/firms.py
index e2536947..a4c748e2 100644
--- a/simulation/firms.py
+++ b/simulation/firms.py
@@ -27,7 +27,7 @@ from simulation.components.engines.sales_engine import SalesEngine
 from simulation.dtos.context_dtos import PayrollProcessingContext, FinancialTransactionContext, SalesContext
 
 from simulation.utils.shadow_logger import log_shadow
-from modules.finance.api import InsufficientFundsError, IFinancialEntity, ICreditFrozen
+from modules.finance.api import InsufficientFundsError, IFinancialEntity, IFinancialAgent, ICreditFrozen
 from modules.finance.dtos import MoneyDTO, MultiCurrencyWalletDTO
 from modules.finance.wallet.wallet import Wallet
 from modules.inventory.manager import InventoryManager
@@ -46,7 +46,7 @@ if TYPE_CHECKING:
 
 logger = logging.getLogger(__name__)
 
-class Firm(ILearningAgent, IFinancialEntity, IOrchestratorAgent, ICreditFrozen, IInventoryHandler, ICurrencyHolder):
+class Firm(ILearningAgent, IFinancialEntity, IFinancialAgent, IOrchestratorAgent, ICreditFrozen, IInventoryHandler, ICurrencyHolder):
     """
     Firm Agent (Orchestrator).
     Manages state and delegates logic to stateless engines.
@@ -801,17 +801,21 @@ class Firm(ILearningAgent, IFinancialEntity, IOrchestratorAgent, ICreditFrozen,
         return self.wallet.get_balance(DEFAULT_CURRENCY)
 
     @override
-    def deposit(self, amount: float) -> None:
-         self.wallet.add(amount, DEFAULT_CURRENCY)
+    def deposit(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
+         self.wallet.add(amount, currency)
 
     @override
-    def withdraw(self, amount: float) -> None:
-         current_bal = self.wallet.get_balance(DEFAULT_CURRENCY)
+    def withdraw(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
+         current_bal = self.wallet.get_balance(currency)
          if current_bal < amount:
             raise InsufficientFundsError(
-                f"Insufficient funds", required=MoneyDTO(amount=amount, currency=DEFAULT_CURRENCY), available=MoneyDTO(amount=current_bal, currency=DEFAULT_CURRENCY)
+                f"Insufficient funds", required=MoneyDTO(amount=amount, currency=currency), available=MoneyDTO(amount=current_bal, currency=currency)
             )
-         self.wallet.subtract(amount, DEFAULT_CURRENCY)
+         self.wallet.subtract(amount, currency)
+
+    def get_balance(self, currency: CurrencyCode = DEFAULT_CURRENCY) -> float:
+        """Implements IFinancialAgent.get_balance."""
+        return self.wallet.get_balance(currency)
 
     @override
     def get_assets_by_currency(self) -> Dict[CurrencyCode, float]:
diff --git a/simulation/systems/settlement_system.py b/simulation/systems/settlement_system.py
index 1156ff4c..9f62700e 100644
--- a/simulation/systems/settlement_system.py
+++ b/simulation/systems/settlement_system.py
@@ -4,7 +4,7 @@ from uuid import UUID
 
 from simulation.finance.api import ISettlementSystem, ITransaction
 from modules.finance.api import (
-    IFinancialEntity, InsufficientFundsError,
+    IFinancialEntity, IFinancialAgent, IBank, InsufficientFundsError,
     IPortfolioHandler, PortfolioDTO, PortfolioAsset, IHeirProvider, LienDTO
 )
 from simulation.dtos.settlement_dtos import LegacySettlementAccount
@@ -28,7 +28,7 @@ class SettlementSystem(ISettlementSystem):
     Money creation/destruction is ONLY allowed via the CentralBank (Minting Authority).
     """
 
-    def __init__(self, logger: Optional[logging.Logger] = None, bank: Optional[Any] = None):
+    def __init__(self, logger: Optional[logging.Logger] = None, bank: Optional[IBank] = None):
         self.logger = logger if logger else logging.getLogger(__name__)
         self.bank = bank # TD-179: Reference to Bank for Seamless Payments
         self.total_liquidation_losses: float = 0.0
@@ -245,13 +245,13 @@ class SettlementSystem(ISettlementSystem):
 
     def record_liquidation(
         self,
-        agent: IFinancialEntity,
+        agent: IFinancialAgent,
         inventory_value: float,
         capital_value: float,
         recovered_cash: float,
         reason: str,
         tick: int,
-        government_agent: Optional[IFinancialEntity] = None
+        government_agent: Optional[IFinancialAgent] = None
     ) -> None:
         """
         Records the value destroyed during a firm's bankruptcy and liquidation.
@@ -275,8 +275,8 @@ class SettlementSystem(ISettlementSystem):
 
         # WO-178: Escheatment Logic
         if government_agent:
-            # Native IFinancialEntity usage
-            current_assets_val = agent.assets
+            # IFinancialAgent usage
+            current_assets_val = agent.get_balance(DEFAULT_CURRENCY)
 
             if current_assets_val > 0:
                 self.transfer(
@@ -288,7 +288,7 @@ class SettlementSystem(ISettlementSystem):
                     currency=DEFAULT_CURRENCY
                 )
 
-    def _execute_withdrawal(self, agent: IFinancialEntity, amount: float, memo: str, tick: int, currency: CurrencyCode = DEFAULT_CURRENCY) -> bool:
+    def _execute_withdrawal(self, agent: IFinancialAgent, amount: float, memo: str, tick: int, currency: CurrencyCode = DEFAULT_CURRENCY) -> bool:
         """
         Executes withdrawal with checks and seamless payment (Bank) support.
         Returns True on success, False on failure.
@@ -308,27 +308,19 @@ class SettlementSystem(ISettlementSystem):
                  self.logger.error(f"SETTLEMENT_FAIL | Central Bank withdrawal failed. {e}")
                  return False
 
-        # 2. Standard Agent Checks (Native Interface)
-        current_cash = 0.0
-        if currency == DEFAULT_CURRENCY:
-            current_cash = agent.assets
-            # DEBUG: Check type of current_cash
-            if isinstance(current_cash, dict):
-                self.logger.error(
-                    f"SETTLEMENT_TYPE_ERROR | agent.assets returned dict instead of float! "
-                    f"Agent: {agent.__class__.__name__} {agent.id}. "
-                    f"Value: {current_cash}"
-                )
-                # Fail-safe: try to extract value if it matches currency?
-                # But strictly this is an interface violation.
-                # Assuming single currency dict {'USD': 100.0}
-                current_cash = current_cash.get(DEFAULT_CURRENCY, 0.0)
+        # 2. Standard Agent Checks (IFinancialAgent Interface)
+        # Using EAFP (Easier to Ask for Forgiveness than Permission) or Look Before You Leap
+        # Spec says: "Direct .cash or .assets access a clear protocol violation"
 
-        elif isinstance(agent, ICurrencyHolder):
-            current_cash = agent.get_assets_by_currency().get(currency, 0.0)
+        current_cash = 0.0
+        if isinstance(agent, IFinancialAgent):
+            current_cash = agent.get_balance(currency)
         else:
-            # Fallback for strict mode
-            pass
+            # Fallback for legacy IFinancialEntity
+            if currency == DEFAULT_CURRENCY and isinstance(agent, IFinancialEntity):
+                current_cash = agent.assets
+            elif isinstance(agent, ICurrencyHolder):
+                current_cash = agent.get_assets_by_currency().get(currency, 0.0)
 
         if current_cash < amount:
             # Seamless Check (Only for DEFAULT_CURRENCY for now, assume Bank uses DEFAULT_CURRENCY)
@@ -336,7 +328,7 @@ class SettlementSystem(ISettlementSystem):
                 needed_from_bank = amount - current_cash
                 # Bank balance check using str(agent.id)
                 agent_id_str = str(agent.id)
-                bank_balance = self.bank.get_balance(agent_id_str)
+                bank_balance = self.bank.get_customer_balance(agent_id_str)
 
                 if (current_cash + bank_balance) < amount:
                     self.logger.error(
@@ -348,7 +340,7 @@ class SettlementSystem(ISettlementSystem):
                     return False
             else:
                 self.logger.error(
-                    f"SETTLEMENT_FAIL | Insufficient cash for {agent.id} AND Bank service is missing. "
+                    f"SETTLEMENT_FAIL | Insufficient cash for {agent.id} AND Bank service is missing/incompatible. "
                     f"Cash: {current_cash:.2f}, Required: {amount:.2f}. Memo: {memo}",
                     extra={"tags": ["settlement", "insufficient_funds"]}
                 )
@@ -357,13 +349,8 @@ class SettlementSystem(ISettlementSystem):
         # 3. Execution
         try:
             if current_cash >= amount:
-                # Use native withdraw
-                if currency == DEFAULT_CURRENCY:
-                    agent.withdraw(amount)
-                else:
-                    # Fallback for multi-currency calls (assuming agent implementation supports it)
-                    agent.withdraw(amount, currency=currency)
-
+                # Use standard withdraw
+                agent.withdraw(amount, currency=currency)
                 self.logger.debug(f"DEBUG_WITHDRAW | Agent {agent.id} withdrew {amount:.4f}. Memo: {memo}")
             else:
                 # Seamless (Only for DEFAULT_CURRENCY)
@@ -373,13 +360,13 @@ class SettlementSystem(ISettlementSystem):
 
                 needed_from_bank = amount - current_cash
                 if current_cash > 0:
-                    agent.withdraw(current_cash)
+                    agent.withdraw(current_cash, currency=currency)
 
                 success = self.bank.withdraw_for_customer(int(agent.id), needed_from_bank)
                 if not success:
                     # Rollback cash
                     if current_cash > 0:
-                         agent.deposit(current_cash)
+                         agent.deposit(current_cash, currency=currency)
                     raise InsufficientFundsError(f"Bank withdrawal failed for {agent.id} despite check.")
 
                 self.logger.info(
@@ -396,7 +383,7 @@ class SettlementSystem(ISettlementSystem):
 
     def execute_multiparty_settlement(
         self,
-        transfers: List[Tuple[IFinancialEntity, IFinancialEntity, float]],
+        transfers: List[Tuple[IFinancialAgent, IFinancialAgent, float]],
         tick: int
     ) -> bool:
         """
@@ -439,8 +426,8 @@ class SettlementSystem(ISettlementSystem):
 
     def settle_atomic(
         self,
-        debit_agent: IFinancialEntity,
-        credits_list: List[Tuple[IFinancialEntity, float, str]],
+        debit_agent: IFinancialAgent,
+        credits_list: List[Tuple[IFinancialAgent, float, str]],
         tick: int
     ) -> bool:
         """
@@ -501,8 +488,8 @@ class SettlementSystem(ISettlementSystem):
 
     def transfer(
         self,
-        debit_agent: IFinancialEntity,
-        credit_agent: IFinancialEntity,
+        debit_agent: IFinancialAgent,
+        credit_agent: IFinancialAgent,
         amount: float,
         memo: str,
         debit_context: Optional[Dict[str, Any]] = None,
@@ -546,20 +533,14 @@ class SettlementSystem(ISettlementSystem):
             return None
 
         try:
-            if currency == DEFAULT_CURRENCY:
-                credit_agent.deposit(amount)
-            else:
-                credit_agent.deposit(amount, currency=currency)
+            credit_agent.deposit(amount, currency=currency)
         except Exception as e:
             # ROLLBACK: Credit failed, must reverse debit
             self.logger.error(
                 f"SETTLEMENT_ROLLBACK | Deposit failed for {credit_agent.id}. Rolling back withdrawal of {amount:.2f} from {debit_agent.id}. Error: {e}"
             )
             try:
-                if currency == DEFAULT_CURRENCY:
-                    debit_agent.deposit(amount)
-                else:
-                    debit_agent.deposit(amount, currency=currency)
+                debit_agent.deposit(amount, currency=currency)
                 self.logger.info(f"SETTLEMENT_ROLLBACK_SUCCESS | Rolled back {amount:.2f} to {debit_agent.id}.")
             except Exception as rollback_error:
                 self.logger.critical(
@@ -578,8 +559,8 @@ class SettlementSystem(ISettlementSystem):
 
     def create_and_transfer(
         self,
-        source_authority: IFinancialEntity,
-        destination: IFinancialEntity,
+        source_authority: IFinancialAgent,
+        destination: IFinancialAgent,
         amount: float,
         reason: str,
         tick: int,
@@ -596,10 +577,7 @@ class SettlementSystem(ISettlementSystem):
         if is_central_bank:
             # Minting logic: Just credit destination. Source (CB) is assumed to have infinite capacity.
             try:
-                if currency == DEFAULT_CURRENCY:
-                    destination.deposit(amount)
-                else:
-                    destination.deposit(amount, currency=currency)
+                destination.deposit(amount, currency=currency)
 
                 self.logger.info(
                     f"MINT_AND_TRANSFER | Created {amount:.2f} {currency} from {source_authority.id} to {destination.id}. Reason: {reason}",
@@ -617,8 +595,8 @@ class SettlementSystem(ISettlementSystem):
 
     def transfer_and_destroy(
         self,
-        source: IFinancialEntity,
-        sink_authority: IFinancialEntity,
+        source: IFinancialAgent,
+        sink_authority: IFinancialAgent,
         amount: float,
         reason: str,
         tick: int,
diff --git a/tests/unit/systems/test_settlement_system.py b/tests/unit/systems/test_settlement_system.py
index 94ebc407..87a32d7e 100644
--- a/tests/unit/systems/test_settlement_system.py
+++ b/tests/unit/systems/test_settlement_system.py
@@ -1,12 +1,13 @@
 import pytest
 from unittest.mock import MagicMock, PropertyMock, patch
 from simulation.systems.settlement_system import SettlementSystem
-from modules.finance.api import IFinancialEntity, InsufficientFundsError
+from modules.finance.api import IFinancialEntity, IFinancialAgent, IBank, InsufficientFundsError
 from modules.system.constants import ID_CENTRAL_BANK
+from modules.system.api import DEFAULT_CURRENCY
 
 from modules.finance.api import IPortfolioHandler, IHeirProvider, PortfolioDTO, PortfolioAsset
 
-class MockAgent(IFinancialEntity, IPortfolioHandler, IHeirProvider):
+class MockAgent(IFinancialAgent, IPortfolioHandler, IHeirProvider):
     def __init__(self, agent_id, assets=0.0, heir_id=None):
         self._id = agent_id
         self._assets = float(assets)
@@ -15,7 +16,7 @@ class MockAgent(IFinancialEntity, IPortfolioHandler, IHeirProvider):
 
         # Mock wallet to satisfy SettlementSystem checks
         self._wallet = MagicMock()
-        self._wallet.get_balance.side_effect = lambda c=None: self._assets
+        self._wallet.get_balance.side_effect = lambda c=DEFAULT_CURRENCY: self._assets if c == DEFAULT_CURRENCY else 0.0
         self._wallet.owner_id = self._id
 
     @property
@@ -30,13 +31,24 @@ class MockAgent(IFinancialEntity, IPortfolioHandler, IHeirProvider):
     def assets(self):
         return self._assets
 
-    def withdraw(self, amount, currency="USD"):
+    def withdraw(self, amount, currency=DEFAULT_CURRENCY):
+        if currency != DEFAULT_CURRENCY:
+             raise ValueError("MockAgent only supports USD")
         if self._assets < amount:
             raise InsufficientFundsError("Insufficient funds")
         self._assets -= amount
 
-    def deposit(self, amount, currency="USD"):
-        self._assets += amount
+    def deposit(self, amount, currency=DEFAULT_CURRENCY):
+        if currency != DEFAULT_CURRENCY:
+             # Just ignore other currencies for simple tests or store them if needed
+             pass
+        else:
+             self._assets += amount
+
+    def get_balance(self, currency=DEFAULT_CURRENCY) -> float:
+        if currency == DEFAULT_CURRENCY:
+            return self._assets
+        return 0.0
 
     def _add_assets(self, amount):
         self.deposit(amount)
@@ -58,14 +70,31 @@ class MockAgent(IFinancialEntity, IPortfolioHandler, IHeirProvider):
 
 class MockCentralBank(MockAgent):
     # Central Bank can withdraw infinitely (negative assets allowed for tracking)
-    def withdraw(self, amount, currency="USD"):
+    def withdraw(self, amount, currency=DEFAULT_CURRENCY):
         self._assets -= amount
 
-class MockBank:
+class MockBank(IBank):
     def __init__(self):
+        self.id = 999
         self.accounts = {}
+        self.own_assets = 10000.0
+
+    # IFinancialAgent impl
+    def deposit(self, amount: float, currency: str = DEFAULT_CURRENCY) -> None:
+        if currency == DEFAULT_CURRENCY:
+            self.own_assets += amount
+
+    def withdraw(self, amount: float, currency: str = DEFAULT_CURRENCY) -> None:
+        if currency == DEFAULT_CURRENCY:
+            self.own_assets -= amount
+
+    def get_balance(self, currency: str = DEFAULT_CURRENCY) -> float:
+        if currency == DEFAULT_CURRENCY:
+            return self.own_assets
+        return 0.0
 
-    def get_balance(self, agent_id: str) -> float:
+    # IBank impl
+    def get_customer_balance(self, agent_id: str) -> float:
         return self.accounts.get(str(agent_id), 0.0)
 
     def withdraw_for_customer(self, agent_id: int, amount: float) -> bool:
@@ -80,6 +109,13 @@ class MockBank:
         str_id = str(agent_id)
         self.accounts[str_id] = self.accounts.get(str_id, 0.0) + amount
 
+    # Stub other IBank methods
+    def grant_loan(self, *args, **kwargs): return None
+    def stage_loan(self, *args, **kwargs): return None
+    def repay_loan(self, *args, **kwargs): return True
+    def get_debt_status(self, *args, **kwargs): return {}
+    def terminate_loan(self, *args, **kwargs): return None
+
 @pytest.fixture
 def mock_bank():
     return MockBank()
@@ -178,7 +214,7 @@ def test_record_liquidation_escheatment(settlement_system):
 
 def test_transfer_rollback(settlement_system):
     class FaultyAgent(MockAgent):
-        def deposit(self, amount):
+        def deposit(self, amount, currency=DEFAULT_CURRENCY):
             raise Exception("Deposit Failed")
 
     sender = MockAgent(1, 100.0)
@@ -264,7 +300,7 @@ def test_transfer_seamless_success(settlement_system, mock_bank):
 
     assert tx is not None
     assert sender.assets == 0.0 # Cash drained
-    assert mock_bank.get_balance("1") == 60.0 # 100 - (50 - 10) = 60
+    assert mock_bank.get_customer_balance("1") == 60.0 # 100 - (50 - 10) = 60
     assert receiver.assets == 50.0
 
 def test_transfer_seamless_fail_bank(settlement_system, mock_bank):
@@ -277,7 +313,7 @@ def test_transfer_seamless_fail_bank(settlement_system, mock_bank):
 
     assert tx is None
     assert sender.assets == 10.0 # Untouched (due to check)
-    assert mock_bank.get_balance("1") == 10.0
+    assert mock_bank.get_customer_balance("1") == 10.0
     assert receiver.assets == 0.0
 
 def test_execute_multiparty_settlement_success(settlement_system):
@@ -307,18 +343,8 @@ def test_execute_multiparty_settlement_rollback(settlement_system):
     transfers = [
         (agent_a, agent_b, 50.0), # This succeeds initially
         (agent_b, agent_c, 200.0) # This fails (150 vs 200? No, check is done per transfer.)
-        # Wait, if done sequentially:
-        # 1. A->B: A=50, B=150.
-        # 2. B->C: B=150. If transfer 200 -> Fail.
-        # So rollback A->B.
     ]
 
-    # Note: MockAgent withdraw checks balance.
-    # But wait, settlement_system.transfer calls withdraw.
-    # In seq: A withdraws 50 (OK). B deposits 50 (OK).
-    # Then B withdraws 200 (Fail, has 150).
-    # Rollback: B withdraws 50 (OK). A deposits 50 (OK).
-
     success = settlement_system.execute_multiparty_settlement(transfers, tick=1)
 
     assert success is False
@@ -364,7 +390,7 @@ def test_settle_atomic_rollback(settlement_system):
 def test_settle_atomic_credit_fail_rollback(settlement_system):
     # A pays Faulty 50. A has 100.
     class FaultyAgent(MockAgent):
-        def deposit(self, amount):
+        def deposit(self, amount, currency=DEFAULT_CURRENCY):
             raise Exception("Deposit Fail")
 
     agent_a = MockAgent("A", 100.0)
@@ -423,4 +449,3 @@ def test_escheatment_portfolio_transfer(settlement_system):
     assert len(gov.portfolio.assets) == 1
     assert gov.portfolio.assets[0].asset_id == "GOV_TEST"
     assert len(account.escrow_portfolio.assets) == 0
-
