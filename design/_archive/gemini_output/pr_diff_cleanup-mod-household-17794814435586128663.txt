diff --git a/communications/insights/cleanup-mod-household.md b/communications/insights/cleanup-mod-household.md
new file mode 100644
index 00000000..1dc6d9ef
--- /dev/null
+++ b/communications/insights/cleanup-mod-household.md
@@ -0,0 +1,42 @@
+# Technical Insight Report: Household Module Cleanup
+
+**Mission Key:** `cleanup-mod-household`
+**Date:** 2024-05-23
+**Author:** Jules
+
+## 1. Problem Phenomenon
+The `household` module unit tests were failing due to significant architectural drift. Key symptoms included:
+- `TypeError` during `Household` instantiation due to signature changes (missing `core_config`, `engine`).
+- `AttributeError` on mocks (e.g., `_bio_state`) because tests mocked the class but didn't populate internal DTOs used by new Orchestrator logic.
+- `TypeError` in `EconStateDTO` initialization (missing `wallet`, `employment_start_tick`).
+- Tests referencing deprecated components (`DecisionUnit` housing logic, AI Tactics) that have been refactored or removed.
+- Tests expecting `assets` (float) on `EconStateDTO` instead of `IWallet`.
+
+## 2. Root Cause Analysis
+1.  **Architecture Shift:** The transition to the Orchestrator-Engine pattern and `AIDrivenHouseholdDecisionEngine` (ActionVector based) rendered many tests obsolete. Tests were still verifying legacy AI Tactics (`decide_and_learn`) which are no longer used.
+2.  **DTO Evolution:** `EconStateDTO` evolved to use `IWallet` and added fields like `employment_start_tick`, but tests were not updated.
+3.  **Missing Mixin:** `Household` class in `simulation/core_agents.py` was missing inheritance from `HouseholdStateAccessMixin`, causing `HouseholdSnapshotAssembler` to fail when accessing `get_bio_state` etc.
+4.  **Hardcoded Values:** Logic contained magic numbers (e.g., `0.95` smoothing factor, `30` tick check) scattered across engines.
+
+## 3. Solution Implementation Details
+1.  **Test Factory Update:**
+    -   Updated `tests/utils/factories.py` with a robust `create_household` factory that handles dependency injection (`AgentCoreConfigDTO`, `IDecisionEngine`, `Wallet` hydration).
+    -   This standardized test setup and eliminated boilerplate errors.
+
+2.  **DTO & Logic Fixes:**
+    -   Updated `EconStateDTO` initialization in tests to use `Wallet` and include all required fields.
+    -   Updated `EconStateDTO.copy()` to perform a deep copy of `Wallet` to ensure snapshot isolation, fixing `TestHouseholdSnapshotAssembler` failures.
+    -   Added `HouseholdStateAccessMixin` to the `Household` class to support snapshot services.
+
+3.  **Legacy Test Cleanup:**
+    -   Deleted/Skipped tests in `test_household_decision_engine_multi_good.py`, `test_household_marginal_utility.py`, and `test_household_ai_consumption.py` that verified deprecated AI Tactics (`decide_and_learn`) or removed internal methods (`_handle_specific_purchase`).
+    -   Updated `test_decision_unit.py` to mock `HousingPlanner` and `HousingSystem` (Saga) interactions, as `DecisionUnit` now delegates housing actions instead of executing them directly.
+
+4.  **Constant Refactoring:**
+    -   Extracted magic numbers in `modules/household/engines/*.py` to module-level constants or `HouseholdConfigDTO` lookups.
+    -   Replaced hardcoded `"USD"` with `modules.system.api.DEFAULT_CURRENCY`.
+
+## 4. Lessons Learned & Technical Debt
+-   **Technical Debt (Legacy Tests):** A significant portion of tests in `tests/unit/test_household_*.py` targets legacy logic (Tactics, old DecisionUnit). These tests were deleted/skipped to unblock the build but represent a gap in coverage for the new `ActionVector` logic. **Action:** Create new tests for `AIDrivenHouseholdDecisionEngine` focusing on `ActionVector` outputs.
+-   **Technical Debt (DecisionUnit):** `DecisionUnit` class seems to be a legacy orchestrator co-existing with `BudgetEngine`. Its role is ambiguous. **Action:** Deprecate `DecisionUnit` fully in favor of `BudgetEngine` and `ConsumptionEngine`.
+-   **Mocking Risks:** Tests relying on `MagicMock(spec=Household)` were fragile because they missed dynamic attributes initialized in `__init__`. **Insight:** Use factories (`create_household`) to instantiate real objects with mocked dependencies for more robust integration-like unit tests.
diff --git a/modules/household/dtos.py b/modules/household/dtos.py
index 4981fc83..e6727c77 100644
--- a/modules/household/dtos.py
+++ b/modules/household/dtos.py
@@ -101,19 +101,11 @@ class EconStateDTO:
 
     def copy(self) -> "EconStateDTO":
         new_state = copy.copy(self)
-        # Wallet is mutable but we probably shouldn't deep copy it for simulation logic unless intent is cloning.
-        # But DTO copy is used for decision making snapshots usually?
-        # If it's for snapshot, it should be a copy.
-        # But Wallet is an object.
-        # DTO copy is shallow for attributes not explicitly handled.
-        # If we want read-only snapshot, Wallet interface might need to be careful.
-        # For now, we keep reference or new wallet?
-        # Typically copy() is used for creating new state for next tick or planning.
-        # But Wallet is the source of truth.
-        # Ideally, we pass the SAME wallet reference if it's the agent's wallet.
-        # Or if this is a snapshot, we should pass a ReadOnly wallet wrapper or just the balance.
-        # However, EconStateDTO is the internal state of EconComponent.
-        # So we keep the reference.
+
+        # Deep copy wallet to ensure snapshot isolation
+        from modules.finance.wallet.wallet import Wallet
+        new_wallet = Wallet(self.wallet.owner_id, self.wallet.get_all_balances())
+        new_state.wallet = new_wallet
 
         new_state.inventory = self.inventory.copy()
         new_state.inventory_quality = self.inventory_quality.copy()
diff --git a/modules/household/engines/budget.py b/modules/household/engines/budget.py
index 9b56ac7f..49d20b97 100644
--- a/modules/household/engines/budget.py
+++ b/modules/household/engines/budget.py
@@ -10,6 +10,13 @@ from modules.system.api import DEFAULT_CURRENCY
 
 logger = logging.getLogger(__name__)
 
+SHADOW_WAGE_DECAY = 0.95
+SHADOW_WAGE_TARGET_WEIGHT = 0.05
+SHADOW_WAGE_UNEMPLOYED_DECAY = 0.02
+HOUSING_CHECK_FREQUENCY = 30
+DEFAULT_FOOD_PRICE_ESTIMATE = 10.0
+DEFAULT_SURVIVAL_BUDGET = 50.0
+
 class BudgetEngine(IBudgetEngine):
     """
     Stateless engine managing financial planning, budgeting, and housing decisions.
@@ -58,16 +65,16 @@ class BudgetEngine(IBudgetEngine):
 
         if state.is_employed:
             target = max(state.current_wage, state.shadow_reservation_wage)
-            state.shadow_reservation_wage = (state.shadow_reservation_wage * 0.95) + (target * 0.05)
+            state.shadow_reservation_wage = (state.shadow_reservation_wage * SHADOW_WAGE_DECAY) + (target * SHADOW_WAGE_TARGET_WEIGHT)
         else:
-            state.shadow_reservation_wage *= (1.0 - 0.02)
+            state.shadow_reservation_wage *= (1.0 - SHADOW_WAGE_UNEMPLOYED_DECAY)
             min_wage = config.household_min_wage_demand
             if state.shadow_reservation_wage < min_wage:
                 state.shadow_reservation_wage = min_wage
 
     def _plan_housing(self, state: EconStateDTO, market_snapshot: Any, current_tick: int) -> Optional[HousingActionDTO]:
         # Logic from DecisionUnit housing part
-        if state.is_homeless or current_tick % 30 == 0:
+        if state.is_homeless or current_tick % HOUSING_CHECK_FREQUENCY == 0:
             # We need to construct a wrapper that mimics HouseholdSnapshotDTO or just has econ_state
             # HousingPlanner expects `request['household_state']` which has `.econ_state`.
 
@@ -132,7 +139,7 @@ class BudgetEngine(IBudgetEngine):
             # E.g. Survival -> Food.
             if need.need_id == "survival":
                 # Estimate food cost.
-                food_price = config.default_food_price_estimate if config else 10.0
+                food_price = config.default_food_price_estimate if config else DEFAULT_FOOD_PRICE_ESTIMATE
                 goods_market = getattr(market_snapshot, "goods", {})
 
                 # Check different keys for food
@@ -143,7 +150,7 @@ class BudgetEngine(IBudgetEngine):
 
                 # Quantity: Place enough for buffer?
                 # Placeholder: Allocate fixed amount
-                amount_to_allocate = config.survival_budget_allocation if config else 50.0
+                amount_to_allocate = config.survival_budget_allocation if config else DEFAULT_SURVIVAL_BUDGET
                 if total_cash - spent >= amount_to_allocate:
                     allocations["food"] = amount_to_allocate
                     spent += amount_to_allocate
diff --git a/modules/household/engines/consumption.py b/modules/household/engines/consumption.py
index d2c92ba2..699d55d3 100644
--- a/modules/household/engines/consumption.py
+++ b/modules/household/engines/consumption.py
@@ -9,6 +9,10 @@ from modules.system.api import DEFAULT_CURRENCY
 
 logger = logging.getLogger(__name__)
 
+DEFAULT_FOOD_PRICE = 10.0
+DEFAULT_FOOD_UTILITY = 20.0
+PRICE_LIMIT_MULTIPLIER = 1.1
+
 class ConsumptionEngine(IConsumptionEngine):
     """
     Stateless engine responsible for executing consumption from inventory,
@@ -61,7 +65,7 @@ class ConsumptionEngine(IConsumptionEngine):
                 new_econ_state.inventory["food"] -= 1.0
 
             # Reduce need
-            utility = config.food_consumption_utility if config else 20.0
+            utility = config.food_consumption_utility if config else DEFAULT_FOOD_UTILITY
             new_bio_state.needs["survival"] = max(0.0, survival_need - utility)
             # Log consumption?
 
@@ -75,11 +79,11 @@ class ConsumptionEngine(IConsumptionEngine):
 
         if survival_need > 0 and food_inventory < 1.0 and food_alloc > 0:
             # Buy food
-            food_price = 10.0
+            food_price = DEFAULT_FOOD_PRICE
             goods_market = getattr(market_snapshot, "goods", {})
             m = goods_market.get("basic_food") or goods_market.get("food")
             if m:
-                 food_price = getattr(m, "avg_price", 10.0) or getattr(m, "current_price", 10.0)
+                 food_price = getattr(m, "avg_price", DEFAULT_FOOD_PRICE) or getattr(m, "current_price", DEFAULT_FOOD_PRICE)
 
             qty_to_buy = food_alloc / food_price
             if qty_to_buy > 0:
@@ -88,7 +92,7 @@ class ConsumptionEngine(IConsumptionEngine):
                     side="BUY",
                     item_id="basic_food",
                     quantity=qty_to_buy,
-                    price_limit=food_price * 1.1,
+                    price_limit=food_price * PRICE_LIMIT_MULTIPLIER,
                     market_id="goods_market"
                 )
                 orders.append(order)
diff --git a/modules/household/engines/lifecycle.py b/modules/household/engines/lifecycle.py
index 411aedd6..9164120a 100644
--- a/modules/household/engines/lifecycle.py
+++ b/modules/household/engines/lifecycle.py
@@ -29,13 +29,13 @@ class LifecycleEngine(ILifecycleEngine):
 
         # 2. Natural Death Check
         # Logic from BioComponent.age_one_tick
-        age_death_probabilities = {
+        age_death_probabilities = getattr(config, 'age_death_probabilities', {
             60: 0.01,
             70: 0.02,
             80: 0.05,
             90: 0.15,
             100: 0.50,
-        }
+        })
 
         death_prob_per_year = 0.0
         # Determine applicable probability
diff --git a/modules/household/engines/social.py b/modules/household/engines/social.py
index d145bba5..2612d2e4 100644
--- a/modules/household/engines/social.py
+++ b/modules/household/engines/social.py
@@ -10,6 +10,16 @@ from modules.system.api import DEFAULT_CURRENCY
 
 logger = logging.getLogger(__name__)
 
+# Political Constants
+STANCE_BLUE = 0.9
+STANCE_RED = 0.1
+SURVIVAL_NEED_SCALE = 100.0
+TRUST_EMA_ALPHA = 0.05
+APPROVAL_WEIGHT_SATISFACTION = 0.4
+APPROVAL_WEIGHT_MATCH = 0.6
+TRUST_THRESHOLD = 0.2
+APPROVAL_THRESHOLD = 0.5
+
 class SocialEngine(ISocialEngine):
     """
     Stateless engine managing social status, political opinion, and other social metrics.
@@ -88,12 +98,12 @@ class SocialEngine(ISocialEngine):
 
         # 1. Derive Gov Stance from Party
         # BLUE (Growth) -> 0.9, RED (Safety) -> 0.1
-        gov_stance = 0.9 if gov_party == PoliticalParty.BLUE else 0.1
+        gov_stance = STANCE_BLUE if gov_party == PoliticalParty.BLUE else STANCE_RED
 
         # 2. Calculate Satisfaction
         # High survival need = Low satisfaction
         # Assuming survival_need is 0-100 scale where 100 is max need (bad)
-        discontent = min(1.0, survival_need / 100.0)
+        discontent = min(1.0, survival_need / SURVIVAL_NEED_SCALE)
         satisfaction = 1.0 - discontent
         new_state.discontent = discontent
 
@@ -104,19 +114,19 @@ class SocialEngine(ISocialEngine):
         # 4. Update Trust (EMA)
         # Trust grows with satisfaction, decays with dissatisfaction
         # Using slow adaptation (alpha=0.05)
-        new_trust = 0.95 * new_state.trust_score + 0.05 * satisfaction
+        new_trust = (1.0 - TRUST_EMA_ALPHA) * new_state.trust_score + TRUST_EMA_ALPHA * satisfaction
         new_state.trust_score = max(0.0, min(1.0, new_trust))
 
         # 5. Calculate Approval
         # Approval = 0.4 * Satisfaction + 0.6 * Match
-        approval_score = (0.4 * satisfaction) + (0.6 * ideological_match)
+        approval_score = (APPROVAL_WEIGHT_SATISFACTION * satisfaction) + (APPROVAL_WEIGHT_MATCH * ideological_match)
 
         # 6. Trust Damper
-        if new_state.trust_score < 0.2:
+        if new_state.trust_score < TRUST_THRESHOLD:
             approval_score = 0.0
 
         # 7. Update Binary Approval Rating
         # Threshold 0.5
-        new_state.approval_rating = 1 if approval_score > 0.5 else 0
+        new_state.approval_rating = 1 if approval_score > APPROVAL_THRESHOLD else 0
 
         return new_state
diff --git a/simulation/core_agents.py b/simulation/core_agents.py
index 7a688ef8..d055a0b5 100644
--- a/simulation/core_agents.py
+++ b/simulation/core_agents.py
@@ -49,6 +49,7 @@ from modules.household.dtos import (
 )
 from modules.analytics.dtos import AgentTickAnalyticsDTO
 from modules.household.services import HouseholdSnapshotAssembler
+from modules.household.mixins._state_access import HouseholdStateAccessMixin
 
 # Protocols
 from modules.hr.api import IEmployeeDataProvider
@@ -69,7 +70,8 @@ class Household(
     ICreditFrozen,
     IInventoryHandler,
     ISensoryDataProvider,
-    IPropertyOwner
+    IPropertyOwner,
+    HouseholdStateAccessMixin
 ):
     """
     Household Agent (Orchestrator).
diff --git a/tests/unit/household/test_snapshot_assembler.py b/tests/unit/household/test_snapshot_assembler.py
index 49ad14de..01250ce4 100644
--- a/tests/unit/household/test_snapshot_assembler.py
+++ b/tests/unit/household/test_snapshot_assembler.py
@@ -5,46 +5,29 @@ from modules.household.dtos import BioStateDTO, EconStateDTO, SocialStateDTO
 from modules.household.services import HouseholdSnapshotAssembler
 from simulation.ai.api import Personality
 from simulation.models import Talent
+from tests.utils.factories import create_household
 
 class TestHouseholdSnapshotAssembler:
 
     @pytest.fixture
     def mock_household(self):
-        # Create a mock Household with mocked internal states
-        household = MagicMock(spec=Household)
-        household.id = 123
-
-        # Mock Bio State
-        bio_state = BioStateDTO(
-            id=123, age=30, gender="F", generation=1, is_active=True, needs={"survival": 50},
-            children_ids=[1, 2]
-        )
-        household._bio_state = bio_state
-        household.get_bio_state.return_value = bio_state
-
-        # Mock Econ State
-        econ_state = EconStateDTO(
-            assets=1000.0, inventory={"food": 10}, inventory_quality={}, durable_assets=[],
-            portfolio=MagicMock(), is_employed=True, employer_id=5, current_wage=100, wage_modifier=1.0,
-            labor_skill=0.8, education_xp=100, education_level=2, expected_wage=110, talent=Talent(1.0, 1.0, 1.0),
-            skills={}, aptitude=0.5, owned_properties=[], residing_property_id=None, is_homeless=False,
-            home_quality_score=1.0, housing_target_mode="RENT", housing_price_history=[], market_wage_history=[],
-            shadow_reservation_wage=90, last_labor_offer_tick=0, last_fired_tick=-1, job_search_patience=10,
-            employment_start_tick=0, current_consumption=10, current_food_consumption=5, expected_inflation={},
-            perceived_avg_prices={}, price_history={}, price_memory_length=10, adaptation_rate=0.1,
-            labor_income_this_tick=0, capital_income_this_tick=0
+        household = create_household(
+            id=123,
+            initial_age=30,
+            gender="F",
+            generation=1,
+            initial_needs={"survival": 50},
+            assets=1000.0,
+            personality=Personality.CONSERVATIVE,
         )
-        household._econ_state = econ_state
-        household.get_econ_state.return_value = econ_state
+        # Customize state for specific test requirements
+        household._bio_state.children_ids = [1, 2]
 
-        # Mock Social State
-        social_state = SocialStateDTO(
-            personality=Personality.CONSERVATIVE, social_status=0.5, discontent=0.1, approval_rating=50,
-            conformity=0.5, social_rank=0.5, quality_preference=0.5, brand_loyalty={}, last_purchase_memory={},
-            patience=0.5, optimism=0.5, ambition=0.5, last_leisure_type="IDLE"
-        )
-        household._social_state = social_state
-        household.get_social_state.return_value = social_state
+        household._econ_state.inventory = {"food": 10}
+        household._econ_state.is_employed = True
+        household._econ_state.employer_id = 5
+        household._econ_state.current_wage = 100
+        # ... other econ state overrides if needed for specific assertions
 
         return household
 
@@ -58,18 +41,19 @@ class TestHouseholdSnapshotAssembler:
 
         # Verify Content Matches
         assert snapshot.bio_state.age == 30
-        assert snapshot.econ_state.assets == 1000.0
+        from modules.system.api import DEFAULT_CURRENCY
+        assert snapshot.econ_state.wallet.get_balance(DEFAULT_CURRENCY) == 1000.0
         assert snapshot.social_state.personality == Personality.CONSERVATIVE
 
         # Verify Independence (Copy Check)
         # Modify the original household state
         mock_household._bio_state.age = 31
-        mock_household._econ_state.assets = 2000.0
+        mock_household.deposit(1000.0) # 1000 + 1000 = 2000
         mock_household._bio_state.children_ids.append(3)
 
         # Snapshot should remain unchanged
         assert snapshot.bio_state.age == 30
-        assert snapshot.econ_state.assets == 1000.0
+        assert snapshot.econ_state.wallet.get_balance(DEFAULT_CURRENCY) == 1000.0
         assert len(snapshot.bio_state.children_ids) == 2
 
     def test_assemble_nested_structures(self, mock_household):
diff --git a/tests/unit/modules/household/test_consumption_manager.py b/tests/unit/modules/household/test_consumption_manager.py
index 5b3c4679..30d075f4 100644
--- a/tests/unit/modules/household/test_consumption_manager.py
+++ b/tests/unit/modules/household/test_consumption_manager.py
@@ -6,6 +6,7 @@ from modules.household.dtos import EconStateDTO
 from simulation.models import Talent
 from simulation.portfolio import Portfolio
 from tests.utils.factories import create_household_config_dto
+from modules.finance.wallet.wallet import Wallet
 
 class TestConsumptionManager:
     @pytest.fixture
@@ -19,8 +20,10 @@ class TestConsumptionManager:
 
     @pytest.fixture
     def econ_state(self):
+        wallet = Wallet(1, {})
+        wallet.add(1000.0)
         return EconStateDTO(
-            assets=1000.0,
+            wallet=wallet,
             inventory={"food": 10.0, "water": 5.0},
             inventory_quality={"food": 1.0, "water": 1.0},
             durable_assets=[],
@@ -47,6 +50,7 @@ class TestConsumptionManager:
             last_labor_offer_tick=0,
             last_fired_tick=-1,
             job_search_patience=0,
+            employment_start_tick=-1,
             current_consumption=0.0,
             current_food_consumption=0.0,
             expected_inflation=defaultdict(float),
diff --git a/tests/unit/modules/household/test_decision_unit.py b/tests/unit/modules/household/test_decision_unit.py
index 73df7573..fd00e8ea 100644
--- a/tests/unit/modules/household/test_decision_unit.py
+++ b/tests/unit/modules/household/test_decision_unit.py
@@ -3,10 +3,12 @@ from unittest.mock import MagicMock
 from collections import deque, defaultdict
 from modules.household.decision_unit import DecisionUnit
 from modules.household.dtos import EconStateDTO
-from modules.household.api import OrchestrationContextDTO, MarketSnapshotDTO, HousingMarketSnapshotDTO, LoanMarketSnapshotDTO, LaborMarketSnapshotDTO
+from modules.household.api import OrchestrationContextDTO
+from modules.system.api import MarketSnapshotDTO, HousingMarketSnapshotDTO, LoanMarketSnapshotDTO, LaborMarketSnapshotDTO
 from simulation.models import Talent, Order
 from simulation.portfolio import Portfolio
 from tests.utils.factories import create_household_config_dto
+from modules.finance.wallet.wallet import Wallet
 
 class TestDecisionUnit:
     @pytest.fixture
@@ -19,8 +21,10 @@ class TestDecisionUnit:
 
     @pytest.fixture
     def econ_state(self):
+        wallet = Wallet(1, {})
+        wallet.add(1000.0)
         return EconStateDTO(
-            assets=1000.0,
+            wallet=wallet,
             inventory={},
             inventory_quality={},
             durable_assets=[],
@@ -47,6 +51,7 @@ class TestDecisionUnit:
             last_labor_offer_tick=0,
             last_fired_tick=-1,
             job_search_patience=0,
+            employment_start_tick=-1,
             current_consumption=0.0,
             current_food_consumption=0.0,
             expected_inflation=defaultdict(float),
@@ -61,15 +66,26 @@ class TestDecisionUnit:
     def test_orchestrate_housing_buy(self, econ_state, mock_config):
         decision_unit = DecisionUnit()
 
+        # Mock housing planner to isolate DecisionUnit logic
+        decision_unit.housing_planner = MagicMock()
+        decision_unit.housing_planner.evaluate_housing_options.return_value = {
+            'decision_type': "INITIATE_PURCHASE",
+            'target_property_id': "unit_1",
+            'offer_price': 10000.0,
+            'down_payment_amount': 2000.0
+        }
+
         # Setup state for BUY decision
-        econ_state.assets = 5000.0
+        econ_state.wallet.add(4000.0) # 1000 + 4000 = 5000
         econ_state.is_homeless = True
 
         # Construct DTOs
+        from modules.system.api import HousingMarketUnitDTO
         housing_snapshot = HousingMarketSnapshotDTO(
             for_sale_units=[
-                {"unit_id": "unit_1", "price": 10000.0, "quality": 1.0}
+                HousingMarketUnitDTO(unit_id="unit_1", price=10000.0, quality=1.0)
             ],
+            units_for_rent=[],
             avg_rent_price=500.0,
             avg_sale_price=10000.0
         )
@@ -77,16 +93,22 @@ class TestDecisionUnit:
         labor_snapshot = LaborMarketSnapshotDTO(avg_wage=10.0)
 
         market_snapshot = MarketSnapshotDTO(
+            tick=30,
+            market_signals={},
             housing=housing_snapshot,
             loan=loan_snapshot,
             labor=labor_snapshot
         )
 
+        # Mock housing system
+        mock_housing_system = MagicMock()
         context = OrchestrationContextDTO(
             market_snapshot=market_snapshot,
             current_time=30,
             stress_scenario_config=None,
-            config=mock_config
+            config=mock_config,
+            household_state=MagicMock(),
+            housing_system=mock_housing_system
         )
 
         initial_orders = []
@@ -98,10 +120,8 @@ class TestDecisionUnit:
 
         # Verify
         assert new_state.housing_target_mode == "BUY"
-        assert len(refined_orders) == 1
-        assert refined_orders[0].item_id == "unit_1"
-        assert refined_orders[0].price_limit == 10000.0
-        assert refined_orders[0].side == "BUY"
+        # DecisionUnit delegates to housing_system, does not create market orders directly for housing
+        mock_housing_system.initiate_purchase.assert_called()
 
     def test_shadow_wage_update(self, econ_state, mock_config):
         decision_unit = DecisionUnit()
@@ -113,12 +133,14 @@ class TestDecisionUnit:
         # Construct DTOs
         # Housing doesn't matter for this test
         housing_snapshot = HousingMarketSnapshotDTO(
-            for_sale_units=[], avg_rent_price=100.0, avg_sale_price=20000.0
+            for_sale_units=[], units_for_rent=[], avg_rent_price=100.0, avg_sale_price=20000.0
         )
         loan_snapshot = LoanMarketSnapshotDTO(interest_rate=0.05)
         labor_snapshot = LaborMarketSnapshotDTO(avg_wage=12.0)
 
         market_snapshot = MarketSnapshotDTO(
+            tick=100,
+            market_signals={},
             housing=housing_snapshot,
             loan=loan_snapshot,
             labor=labor_snapshot
@@ -128,7 +150,9 @@ class TestDecisionUnit:
             market_snapshot=market_snapshot,
             current_time=100,
             stress_scenario_config=None,
-            config=mock_config
+            config=mock_config,
+            household_state=MagicMock(),
+            housing_system=None
         )
 
         initial_orders = []
diff --git a/tests/unit/modules/household/test_econ_component.py b/tests/unit/modules/household/test_econ_component.py
index 905674f7..0f8e0fa0 100644
--- a/tests/unit/modules/household/test_econ_component.py
+++ b/tests/unit/modules/household/test_econ_component.py
@@ -7,6 +7,7 @@ from simulation.ai.api import Personality
 from simulation.models import Talent
 from simulation.portfolio import Portfolio
 from tests.utils.factories import create_household_config_dto
+from modules.finance.wallet.wallet import Wallet
 
 class TestEconComponent:
     @pytest.fixture
@@ -21,8 +22,10 @@ class TestEconComponent:
     @pytest.fixture
     def econ_state(self):
         # Create a basic EconStateDTO
+        wallet = Wallet(1, {})
+        wallet.add(1000.0)
         return EconStateDTO(
-            assets=1000.0,
+            wallet=wallet,
             inventory={},
             inventory_quality={},
             durable_assets=[],
@@ -49,6 +52,7 @@ class TestEconComponent:
             last_labor_offer_tick=0,
             last_fired_tick=-1,
             job_search_patience=0,
+            employment_start_tick=-1,
             current_consumption=0.0,
             current_food_consumption=0.0,
             expected_inflation=defaultdict(float),
diff --git a/tests/unit/test_household_ai.py b/tests/unit/test_household_ai.py
index 4e8ba586..18557951 100644
--- a/tests/unit/test_household_ai.py
+++ b/tests/unit/test_household_ai.py
@@ -2,7 +2,7 @@ import os
 import sys
 import json
 import pytest
-from tests.utils.factories import create_firm_config_dto, create_household_config_dto
+from tests.utils.factories import create_firm_config_dto, create_household_config_dto, create_household
 from unittest.mock import Mock
 
 # Add project root to sys.path to allow imports from other modules
@@ -91,16 +91,16 @@ def test_ai_creates_purchase_order(setup_test_environment, ai_engine_setup):
 
     hh_config = create_config_dto(config, HouseholdConfigDTO)
     talent = Talent(base_learning_rate=0.1, max_potential={"strength": 100})
-    household = Household(
+    household = create_household(
+        config_dto=hh_config,
         id=2,
         talent=talent,
         goods_data=goods_data,
-        initial_assets=100.0,
+        assets=100.0,
         initial_needs={"survival": 80.0, "social": 20.0, "improvement": 10.0, "asset": 10.0},
         value_orientation=value_orientation,
-        decision_engine=household_decision_engine,
+        engine=household_decision_engine,
         personality=Personality.MISER,
-        config_dto=hh_config,
     )
 
     market_data = {
@@ -121,6 +121,7 @@ def test_ai_creates_purchase_order(setup_test_environment, ai_engine_setup):
         market_data=market_data,
         current_time=1
     )
+    household.update_needs(1, market_data)
     orders, _ = household.make_decision(input_dto)
 
     assert orders is not None
@@ -152,16 +153,16 @@ def test_ai_evaluates_consumption_options(setup_test_environment, ai_engine_setu
 
     hh_config = create_config_dto(config, HouseholdConfigDTO)
     talent = Talent(base_learning_rate=0.1, max_potential={"strength": 100})
-    household = Household(
+    household = create_household(
+        config_dto=hh_config,
         id=3,
         talent=talent,
         goods_data=goods_data,
-        initial_assets=1000.0,
+        assets=1000.0,
         initial_needs={"survival": 10.0, "social": 80.0, "improvement": 10.0, "asset": 10.0},
         value_orientation=value_orientation,
-        decision_engine=household_decision_engine,
+        engine=household_decision_engine,
         personality=Personality.STATUS_SEEKER,
-        config_dto=hh_config,
     )
 
     market_data = {
@@ -182,6 +183,7 @@ def test_ai_evaluates_consumption_options(setup_test_environment, ai_engine_setu
         market_data=market_data,
         current_time=1
     )
+    household.update_needs(1, market_data)
     orders, action_vector = household.make_decision(input_dto)
 
     assert orders is not None
diff --git a/tests/unit/test_household_ai_consumption.py b/tests/unit/test_household_ai_consumption.py
deleted file mode 100644
index a7573d10..00000000
--- a/tests/unit/test_household_ai_consumption.py
+++ /dev/null
@@ -1,96 +0,0 @@
-import pytest
-from unittest.mock import MagicMock
-from simulation.core_agents import Household
-from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
-from simulation.ai.household_ai import HouseholdAI
-from simulation.ai.enums import Tactic, Aggressiveness
-from simulation.dtos import DecisionContext
-from modules.household.dtos import HouseholdStateDTO
-from simulation.models import Order
-from tests.utils.factories import create_household_config_dto
-import config
-
-class TestHouseholdAIConsumption:
-    @pytest.fixture
-    def setup_household(self):
-        # Create mocks
-        mock_config = MagicMock()
-        mock_config.SURVIVAL_NEED_THRESHOLD = 20.0
-        mock_config.SURVIVAL_NEED_CONSUMPTION_THRESHOLD = 50.0 # High threshold
-        mock_config.HOUSEHOLD_MIN_FOOD_INVENTORY = 2.0
-        mock_config.PERCEIVED_FAIR_PRICE_THRESHOLD_FACTOR = 0.9
-        mock_config.FOOD_PURCHASE_MAX_PER_TICK = 5.0
-        mock_config.GOODS = {"food": {"utility_effects": {"survival": 10}}}
-        
-        mock_logger = MagicMock()
-        
-        # Mock HouseholdAI
-        mock_household_ai = MagicMock(spec=HouseholdAI)
-        # Mock decide_and_learn to return the tuple directly
-        # Using Aggressiveness.PASSIVE as a placeholder if NEUTRAL doesn't exist
-        mock_household_ai.decide_and_learn.return_value = (Tactic.EVALUATE_CONSUMPTION_OPTIONS, Aggressiveness.PASSIVE)
-        
-        engine = AIDrivenHouseholdDecisionEngine(mock_household_ai, mock_config, mock_logger)
-        
-        household = MagicMock(spec=Household)
-        household.id = 1
-        household._bio_state.needs = {"survival": 80.0} # High survival need
-        household._econ_state.inventory = {"food": 0.0}
-        household._assets = 100.0
-        household.get_agent_data.return_value = {}
-        household.get_pre_state_data.return_value = {}
-        household._econ_state.perceived_avg_prices = {"food": 10.0}
-        
-        return engine, household, mock_household_ai
-
-    def test_ai_chooses_consumption_tactic(self, setup_household):
-        engine, household, mock_household_ai = setup_household
-        
-        markets = {"goods_market": MagicMock()}
-        # Mock get_best_ask for food
-        markets["goods_market"].get_best_ask.return_value = 10.0
-        
-        goods_data = [{"id": "food", "name": "Food"}]
-        market_data = {}
-        current_time = 1
-        
-        # Run make_decisions
-        state = MagicMock(spec=HouseholdStateDTO)
-        state.needs = household._bio_state.needs
-        state.inventory = household._econ_state.inventory
-        state.assets = household._econ_state.assets
-        state.perceived_prices = household._econ_state.perceived_avg_prices
-
-        context = DecisionContext(
-            state=state,
-            config=create_household_config_dto(),
-            goods_data=goods_data,
-            market_data=market_data,
-            current_time=current_time,
-        )
-        # Hack: Pass markets via side channel or ensure Manager uses context.market_data
-        # AIDrivenHouseholdDecisionEngine uses managers.
-        # Managers generally use context.market_data OR they might need IMarket interface if they call methods.
-        # ConsumptionManager typically calls market.get_price().
-        # But DecisionContext doesn't hold markets.
-        # It holds market_data (history/snapshot).
-        # If engine needs execution access (to query order book depth), it might fail if not provided.
-        # But make_decisions only PLANS.
-
-        orders, (tactic, aggressiveness) = engine.make_decisions(context)
-        
-        # Verify Tactic
-        assert tactic == Tactic.EVALUATE_CONSUMPTION_OPTIONS
-        
-        # Verify AI decide_and_learn was called
-        mock_household_ai.decide_and_learn.assert_called()
-        
-        # Verify Order Generation (EVALUATE_CONSUMPTION_OPTIONS logic)
-        # The logic iterates GOODS, so we need config.GOODS to be set (which we did in setup)
-        # And it checks markets["goods_market"].get_best_ask(item_id)
-        
-        # Check if any order was created
-        assert len(orders) > 0
-        assert orders[0].order_type == "BUY"
-        # The logic might buy based on utility. "food" has utility.
-        assert orders[0].item_id == "food"
diff --git a/tests/unit/test_household_decision_engine_multi_good.py b/tests/unit/test_household_decision_engine_multi_good.py
deleted file mode 100644
index ac92531d..00000000
--- a/tests/unit/test_household_decision_engine_multi_good.py
+++ /dev/null
@@ -1,222 +0,0 @@
-import pytest
-from tests.utils.factories import create_firm_config_dto, create_household_config_dto
-from unittest.mock import Mock, MagicMock
-
-from simulation.decisions.ai_driven_household_engine import (
-    AIDrivenHouseholdDecisionEngine,
-)
-from simulation.core_agents import Household
-from simulation.ai.household_ai import HouseholdAI
-from simulation.ai.enums import Tactic, Aggressiveness
-from simulation.dtos import DecisionContext
-from simulation.markets.order_book_market import OrderBookMarket
-
-
-# Mock config_module for testing purposes
-class MockConfig:
-    GOODS = {
-        "basic_food": {"production_cost": 3, "utility_effects": {"survival": 10}},
-        "luxury_food": {
-            "production_cost": 10,
-            "utility_effects": {"survival": 12, "social": 5},
-        },
-        "education_service": {
-            "production_cost": 50,
-            "utility_effects": {"improvement": 20},
-        },
-    }
-    SURVIVAL_NEED_CONSUMPTION_THRESHOLD = 50.0
-    BASE_DESIRE_GROWTH = 1.0
-    MAX_DESIRE_VALUE = 100.0
-    PERCEIVED_FAIR_PRICE_THRESHOLD_FACTOR = 0.9
-    FOOD_PURCHASE_MAX_PER_TICK = 5.0
-    TARGET_FOOD_BUFFER_QUANTITY = 5.0
-    HOUSEHOLD_MAX_PURCHASE_QUANTITY = 5.0
-    LABOR_MARKET_MIN_WAGE = 8.0
-    # New config constants for refactored code
-    MARKET_PRICE_FALLBACK = 10.0
-    NEED_FACTOR_BASE = 0.5
-    NEED_FACTOR_SCALE = 100.0
-    VALUATION_MODIFIER_BASE = 0.9
-    VALUATION_MODIFIER_RANGE = 0.2
-    BULK_BUY_NEED_THRESHOLD = 70.0
-    BULK_BUY_AGG_THRESHOLD = 0.8
-    BULK_BUY_MODERATE_RATIO = 0.6
-    BUDGET_LIMIT_NORMAL_RATIO = 0.5
-    BUDGET_LIMIT_URGENT_NEED = 80.0
-    BUDGET_LIMIT_URGENT_RATIO = 0.9
-    MIN_PURCHASE_QUANTITY = 0.1
-    JOB_QUIT_THRESHOLD_BASE = 2.0
-    JOB_QUIT_PROB_BASE = 0.1
-    JOB_QUIT_PROB_SCALE = 0.9
-    RESERVATION_WAGE_BASE = 1.5
-    RESERVATION_WAGE_RANGE = 1.0
-
-
-@pytest.fixture
-def mock_config_module():
-    return MockConfig()
-
-
-@pytest.fixture
-def mock_household(mock_config_module):
-    household = Mock(spec=Household)
-    household.id = 1
-    household._assets = 100.0
-    household._econ_state.inventory = {"basic_food": 0, "luxury_food": 0}
-    household._bio_state.needs = {
-        "survival": 70.0,
-        "social": 30.0,
-        "improvement": 10.0,
-        "asset": 50.0,
-    }
-    household._econ_state.perceived_avg_prices = {}
-    household.config_module = mock_config_module
-    household.get_agent_data.return_value = {
-        "assets": household._econ_state.assets,
-        "needs": household._bio_state.needs.copy(),
-        "inventory": household._econ_state.inventory.copy(),
-    }
-    household.get_pre_state_data.return_value = household.get_agent_data()
-    household.logger = MagicMock()  # Mock the logger
-    household.get_desired_wage.return_value = 12.0  # For labor market test
-    return household
-
-
-@pytest.fixture
-def mock_ai_engine_registry():
-    registry = Mock()
-    mock_ai_decision_engine = Mock()
-    mock_ai_decision_engine.is_trained = True
-    registry.get_engine.return_value = mock_ai_decision_engine
-    return registry
-
-
-@pytest.fixture
-def household_decision_engine(
-    mock_household, mock_ai_engine_registry, mock_config_module
-):
-    # Create a mock for the ai_engine
-    mock_ai_engine = Mock(spec=HouseholdAI)
-    # Set the ai_engine for the AIDrivenHouseholdDecisionEngine
-    engine = AIDrivenHouseholdDecisionEngine(
-        ai_engine=mock_ai_engine,  # Pass the mock ai_engine here
-        config_module=mock_config_module,
-    )
-    return engine, mock_ai_engine  # Return both the engine and its mock ai_engine
-
-
-@pytest.fixture
-def mock_markets():
-    markets = {
-        "goods_market": Mock(spec=OrderBookMarket),
-        "labor_market": Mock(spec=OrderBookMarket),
-        "loan_market": Mock(),
-    }
-    # Set return values for get_best_ask
-    markets["goods_market"].get_best_ask.side_effect = lambda item_id: {
-        "basic_food": 5.0,
-        "luxury_food": 15.0,
-        "education_service": 60.0,
-    }.get(item_id)
-    markets["labor_market"].id = "labor_market"
-    markets["goods_market"].id = "goods_market"
-    return markets
-
-
-class TestHouseholdDecisionEngineMultiGood:
-    @pytest.mark.skip(reason="Refactoring needed: tests private method on non-existent rule_based_engine")
-    def test_get_consumption_candidates(
-        self, household_decision_engine, mock_markets, mock_household
-    ):
-        pass
-
-    @pytest.mark.skip(reason="Refactoring needed: tests private method on non-existent rule_based_engine")
-    def test_calculate_utility_gain_basic_food(
-        self, household_decision_engine, mock_household
-    ):
-        pass
-
-    @pytest.mark.skip(reason="Refactoring needed: tests private method on non-existent rule_based_engine")
-    def test_calculate_utility_gain_luxury_food(
-        self, household_decision_engine, mock_household
-    ):
-        pass
-    
-    @pytest.mark.skip(reason="Refactoring needed: tests private method on non-existent rule_based_engine")
-    def test_find_optimal_consumption_bundle_prioritize_cheaper(
-        self, household_decision_engine, mock_household, mock_markets
-    ):
-        pass
-
-    @pytest.mark.skip(reason="Refactoring needed: tests private method on non-existent rule_based_engine")
-    def test_find_optimal_consumption_bundle_insufficient_funds(
-        self, household_decision_engine, mock_household, mock_markets
-    ):
-        pass
-
-    @pytest.mark.skip(reason="Refactoring needed: tests private method on non-existent rule_based_engine")
-    def test_find_optimal_consumption_bundle_no_candidates(
-        self, household_decision_engine, mock_household, mock_markets
-    ):
-        pass
-
-    def test_make_decisions_with_evaluate_consumption_options(
-        self, household_decision_engine, mock_household, mock_markets
-    ):
-        engine, mock_ai_engine = household_decision_engine
-        # Mock AI to return EVALUATE_CONSUMPTION_OPTIONS
-        mock_ai_engine.decide_and_learn.return_value = (
-            Tactic.EVALUATE_CONSUMPTION_OPTIONS, Aggressiveness.NORMAL
-        )
-
-        # Household has 100 assets, will buy basic_food
-        context = DecisionContext(
-            household=mock_household,
-            markets=mock_markets,
-            goods_data=list(MockConfig.GOODS.values()),
-            market_data={},
-            current_time=1,
-        )
-        orders, tactic_tuple = engine.make_decisions(context)
-        tactic, _ = tactic_tuple
-
-        assert tactic == Tactic.EVALUATE_CONSUMPTION_OPTIONS
-        # The logic will choose the item with the best utility/price ratio, which is basic_food in the default setup.
-        # It will then create ONE order for it.
-        assert len(orders) == 1
-        assert orders[0].item_id == "basic_food"
-
-    def test_make_decisions_with_participate_labor_market(
-        self, household_decision_engine, mock_household, mock_markets
-    ):
-        engine, mock_ai_engine = household_decision_engine
-        # Mock AI to return PARTICIPATE_LABOR_MARKET
-        mock_ai_engine.decide_and_learn.return_value = (
-            Tactic.PARTICIPATE_LABOR_MARKET, Aggressiveness.NORMAL
-        )
-        mock_household.get_desired_wage.return_value = 12.0
-        mock_household.is_employed = False
-
-        context = DecisionContext(
-            household=mock_household,
-            markets=mock_markets,
-            goods_data=[],
-            market_data={},
-            current_time=1,
-        )
-        orders, tactic_tuple = engine.make_decisions(context)
-        tactic, _ = tactic_tuple
-
-        assert tactic == Tactic.PARTICIPATE_LABOR_MARKET
-        assert len(orders) == 1
-        assert orders[0].item_id == "labor"
-        assert orders[0].order_type == "SELL"
-        assert orders[0].price == 12.0
-        assert orders[0].market_id == "labor_market"
-
-    @pytest.mark.skip(reason="Refactoring needed: tests private method on non-existent rule_based_engine")
-    def test_find_optimal_consumption_bundle_mix_goods_sufficient_budget(
-        self, household_decision_engine, mock_household, mock_markets
-    ):
-        pass
\ No newline at end of file
diff --git a/tests/unit/test_household_marginal_utility.py b/tests/unit/test_household_marginal_utility.py
deleted file mode 100644
index 049af401..00000000
--- a/tests/unit/test_household_marginal_utility.py
+++ /dev/null
@@ -1,139 +0,0 @@
-
-import unittest
-from unittest.mock import MagicMock, patch
-from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
-from simulation.core_agents import Household, Talent
-from simulation.ai.household_ai import HouseholdAI
-from simulation.ai.enums import Tactic, Aggressiveness, Personality
-from simulation.ai_model import AIDecisionEngine
-from simulation.models import Order
-from tests.utils.factories import create_household_config_dto
-
-class MockConfig:
-    GOODS = {
-        "food": {
-            "id": "food",
-            "utility_effects": {"survival": 10.0}, # Base Utility = 10
-            "production_cost": 5.0
-        }
-    }
-    TARGET_FOOD_BUFFER_QUANTITY = 10
-    PERCEIVED_FAIR_PRICE_THRESHOLD_FACTOR = 1.2
-    FOOD_PURCHASE_MAX_PER_TICK = 50
-    SURVIVAL_NEED_CONSUMPTION_THRESHOLD = 50
-    BASE_DESIRE_GROWTH = 1.0
-    HOUSEHOLD_MAX_PURCHASE_QUANTITY = 5.0
-    LABOR_MARKET_MIN_WAGE = 8.0
-    # New config constants for refactored code
-    MARKET_PRICE_FALLBACK = 10.0
-    NEED_FACTOR_BASE = 0.5
-    NEED_FACTOR_SCALE = 100.0
-    VALUATION_MODIFIER_BASE = 0.9
-    VALUATION_MODIFIER_RANGE = 0.2
-    BULK_BUY_NEED_THRESHOLD = 70.0
-    BULK_BUY_AGG_THRESHOLD = 0.8
-    BULK_BUY_MODERATE_RATIO = 0.6
-    BUDGET_LIMIT_NORMAL_RATIO = 0.5
-    BUDGET_LIMIT_URGENT_NEED = 80.0
-    BUDGET_LIMIT_URGENT_RATIO = 0.9
-    MIN_PURCHASE_QUANTITY = 0.1
-    JOB_QUIT_THRESHOLD_BASE = 2.0
-    JOB_QUIT_PROB_BASE = 0.1
-    JOB_QUIT_PROB_SCALE = 0.9
-    RESERVATION_WAGE_BASE = 1.5
-    RESERVATION_WAGE_RANGE = 1.0
-
-
-class TestHouseholdMarginalUtility(unittest.TestCase):
-    def setUp(self):
-        self.config = MockConfig()
-        
-        # Mock AI components
-        self.mock_ai_decision_engine = MagicMock(spec=AIDecisionEngine)
-        self.ai_engine = HouseholdAI("agent_1", self.mock_ai_decision_engine)
-        
-        # Create Household
-        talent = Talent(base_learning_rate=0.1, max_potential={})
-        self.household = Household(
-            id=1,
-            talent=talent,
-            goods_data=[self.config.GOODS["food"]],
-            initial_assets=1000.0,
-            initial_needs={"survival": 1.0},
-            decision_engine=AIDrivenHouseholdDecisionEngine(self.ai_engine, self.config),
-            value_orientation="N/A",
-            personality=Personality.GROWTH_ORIENTED,
-            config_dto=create_household_config_dto()
-        )
-        # Give infinite money
-        self.household._assets = 1_000_000_000
-        self.household._econ_state.inventory = {"food": 0}
-        self.household._bio_state.needs = {"survival": 1.0} # Needs > 0 to have utility
-
-        self.engine = AIDrivenHouseholdDecisionEngine(self.ai_engine, self.config)
-
-    def test_marginal_utility_stops_buying(self):
-        """
-        Test that purchasing stops when Marginal Utility < Price.
-        Base Utility = 10 * 1 = 10.
-        MU = 10 / (1 + Inventory)
-        
-        Scenario 1: Price = 2.0
-        MU > 2.0 when Inventory < 4. (10/1=10, 10/2=5, 10/3=3.3, 10/4=2.5, 10/5=2.0)
-        So it should buy exactly 4 or 5 units depending on <= or < logic.
-        Code says: if marginal_utility > best_ask: buy.
-        10/1 > 2 ? Yes (Buy 1st, Inv=0->1)
-        10/2 > 2 ? Yes (Buy 2nd, Inv=1->2)
-        10/3 > 2 ? Yes (Buy 3rd, Inv=2->3)
-        10/4 > 2 ? Yes (Buy 4th, Inv=3->4)
-        10/5 > 2 ? No (2 > 2 is False).
-        So expected quantity = 4.
-        """
-        
-        market_data = {
-            "goods_market": MagicMock()
-        }
-        market_data["goods_market"].get_best_ask.return_value = 2.0 # Price = 2.0
-        
-        tactic = Tactic.BUY_BASIC_FOOD # Logic is shared in _handle_specific_purchase
-        aggressiveness = Aggressiveness.NORMAL # Factor = 1.0
-
-        # We need to call _handle_specific_purchase directly or simulate _execute_tactic
-        # Let's call _handle_specific_purchase directly for unit testing logic
-        
-        orders = self.engine._handle_specific_purchase(
-            self.household,
-            "food",
-            aggressiveness,
-            current_tick=1,
-            markets=market_data
-        )
-        
-        self.assertTrue(len(orders) > 0)
-        self.assertEqual(orders[0].quantity, 4)
-        
-    def test_high_price_prevents_buying(self):
-        """
-        Scenario 2: Price = 11.0
-        Base Utility = 10.
-        MU (first unit) = 10/1 = 10.
-        10 > 11 ? No.
-        Should buy 0 units.
-        """
-        market_data = {
-            "goods_market": MagicMock()
-        }
-        market_data["goods_market"].get_best_ask.return_value = 11.0 # Price = 11.0
-        
-        orders = self.engine._handle_specific_purchase(
-            self.household,
-            "food",
-            Aggressiveness.NORMAL,
-            current_tick=1,
-            markets=market_data
-        )
-        
-        self.assertEqual(len(orders), 0)
-
-if __name__ == "__main__":
-    unittest.main()
diff --git a/tests/unit/test_household_refactor.py b/tests/unit/test_household_refactor.py
index 0f2463f1..e66e6e66 100644
--- a/tests/unit/test_household_refactor.py
+++ b/tests/unit/test_household_refactor.py
@@ -5,6 +5,7 @@ from modules.household.dtos import EconStateDTO, BioStateDTO, SocialStateDTO
 from simulation.dtos.config_dtos import HouseholdConfigDTO
 from simulation.ai.api import Personality
 from simulation.models import Talent
+from tests.utils.factories import create_household
 
 class TestHouseholdRefactor:
     def test_property_management(self):
@@ -23,16 +24,16 @@ class TestHouseholdRefactor:
         config.adaptation_rate_normal = 0.1
 
         # Initialize Household
-        household = Household(
+        household = create_household(
+            config_dto=config,
             id=1,
             talent=Talent(base_learning_rate=0.1, max_potential=1.0),
             goods_data=[],
-            initial_assets=1000.0,
+            assets=1000.0,
             initial_needs={},
-            decision_engine=MagicMock(),
+            engine=MagicMock(),
             value_orientation="neutral",
             personality=Personality.BALANCED,
-            config_dto=config
         )
 
         # Test add_property
diff --git a/tests/utils/factories.py b/tests/utils/factories.py
index b514fdd1..cdafe1bf 100644
--- a/tests/utils/factories.py
+++ b/tests/utils/factories.py
@@ -1,3 +1,8 @@
+from unittest.mock import MagicMock
+from simulation.core_agents import Household
+from simulation.models import Talent
+from simulation.ai.api import Personality
+from modules.simulation.api import AgentCoreConfigDTO
 from simulation.dtos.config_dtos import HouseholdConfigDTO, FirmConfigDTO
 
 def create_household_config_dto(**kwargs) -> HouseholdConfigDTO:
@@ -164,3 +169,49 @@ def create_firm_config_dto(**kwargs) -> FirmConfigDTO:
     }
     defaults.update(kwargs)
     return FirmConfigDTO(**defaults)
+
+def create_household(
+    config_dto: HouseholdConfigDTO = None,
+    id: int = 1,
+    name: str = "TestHousehold",
+    assets: float = 1000.0,
+    initial_needs: dict = None,
+    value_orientation: str = "needs_and_social_status",
+    engine = None,
+    **kwargs
+) -> Household:
+    if config_dto is None:
+        config_dto = create_household_config_dto()
+
+    if initial_needs is None:
+        initial_needs = config_dto.initial_needs.copy()
+
+    core_config = AgentCoreConfigDTO(
+        id=id,
+        name=name,
+        initial_needs=initial_needs,
+        logger=MagicMock(),
+        memory_interface=None,
+        value_orientation=value_orientation
+    )
+
+    if engine is None:
+        engine = MagicMock()
+
+    talent = kwargs.pop('talent', Talent(base_learning_rate=0.5, max_potential={}))
+    goods_data = kwargs.pop('goods_data', [{"id": "food", "initial_price": 10.0}])
+    personality = kwargs.pop('personality', Personality.CONSERVATIVE)
+
+    household = Household(
+        core_config=core_config,
+        engine=engine,
+        talent=talent,
+        goods_data=goods_data,
+        personality=personality,
+        config_dto=config_dto,
+        initial_assets_record=assets,
+        **kwargs
+    )
+    if assets > 0:
+        household.deposit(assets)
+    return household
