diff --git a/communications/insights/modernize-omo-tests.md b/communications/insights/modernize-omo-tests.md
new file mode 100644
index 00000000..f5644b3c
--- /dev/null
+++ b/communications/insights/modernize-omo-tests.md
@@ -0,0 +1,49 @@
+# Modernize OMO & Settlement Tests (SSoT Alignment) - Insight Report
+
+## 1. Introduction
+This report documents the modernization of `tests/integration/test_omo_system.py` and `tests/integration/test_atomic_settlement.py` to align with the Single Source of Truth (SSoT) architecture.
+
+**Goal**:
+- Eliminate direct state access on `MockAgent` (e.g., `agent.assets`).
+- Enforce Zero-Sum Integrity via `SettlementSystem.audit_total_m2()` or explicit summation.
+- Ensure Protocol Purity by implementing `IFinancialAgent` and `IFinancialEntity` on mocks.
+
+## 2. Pre-Refactor State
+- **Direct Access**: Tests currently assert balances by reading `agent.assets` directly.
+- **Mock Drift**: `MockAgent` classes implement ad-hoc methods (`_deposit`, `_withdraw`) without formal Protocol adherence.
+- **Settlement Isolation**: `SettlementSystem` in `test_atomic_settlement.py` operates without an `AgentRegistry`, relying on passing agent instances directly to `settle_atomic`. This bypasses the SSoT lookup mechanism (`get_balance(id)`).
+
+## 3. Implementation Plan
+- **Mock Refactor**: Implement `IFinancialAgent` and `IFinancialEntity` on `MockAgent` (renamed to `OMOTestAgent` in OMO tests).
+- **Registry Injection**: Create a `MockRegistry` implementing `IAgentRegistry` and inject it into `SettlementSystem`.
+- **SSoT Verification**: Update all assertions to use `settlement.get_balance(agent.id)`.
+
+## 4. Execution Log
+### 4.1. Modifications
+- **`tests/integration/test_atomic_settlement.py`**:
+    - Replaced `MockAgent` with `MockFinancialAgent` (still named `MockAgent` locally) implementing strict protocols.
+    - Added `MockRegistry` and injected into `SettlementSystem`.
+    - Switched all assertions to `settlement.get_balance()`.
+- **`tests/integration/test_omo_system.py`**:
+    - Renamed `MockAgent` to `OMOTestAgent` with protocol compliance.
+    - Updated `omo_setup` to resolve ID collision (Gov Agent ID 0 -> 2) which was masking Registry issues.
+    - Added `settlement.audit_total_m2()` checks to verify Zero-Sum Integrity (Expansion/Contraction).
+
+### 4.2. Test Evidence
+```bash
+tests/integration/test_atomic_settlement.py::test_settle_atomic_success PASSED [ 16%]
+tests/integration/test_atomic_settlement.py::test_settle_atomic_rollback
+-------------------------------- live log call ---------------------------------
+ERROR    simulation.systems.settlement_system:settlement_system.py:364 SETTLEMENT_ROLLBACK | Deposit failed for 3. Rolling back atomic batch. Error: Bank Frozen
+PASSED                                                                   [ 33%]
+tests/integration/test_omo_system.py::test_execute_omo_purchase_order_creation PASSED [ 50%]
+tests/integration/test_omo_system.py::test_execute_omo_sale_order_creation PASSED [ 66%]
+tests/integration/test_omo_system.py::test_process_omo_purchase_transaction PASSED [ 83%]
+tests/integration/test_omo_system.py::test_process_omo_sale_transaction PASSED [100%]
+
+============================== 6 passed in 0.36s ===============================
+```
+
+## 5. Architectural Insights
+- **Protocol Purity**: Tests now strictly adhere to `IFinancialAgent`, exposing issues like ID collisions that were previously hidden by lax duck typing.
+- **Zero-Sum**: `audit_total_m2` proved effective in verifying that OMO operations correctly expand/contract the money supply relative to the non-Central Bank agents.
diff --git a/tests/integration/test_atomic_settlement.py b/tests/integration/test_atomic_settlement.py
index 9fc5629f..e74bd5f5 100644
--- a/tests/integration/test_atomic_settlement.py
+++ b/tests/integration/test_atomic_settlement.py
@@ -1,43 +1,73 @@
 import pytest
 from unittest.mock import MagicMock
+from typing import List, Any, Dict
 from simulation.systems.settlement_system import SettlementSystem
-from modules.system.api import DEFAULT_CURRENCY
+from modules.system.api import DEFAULT_CURRENCY, IAgentRegistry
+from modules.finance.api import IFinancialEntity, IFinancialAgent, InsufficientFundsError
 
-class MockAgent:
+class MockAgent: # Implements IFinancialEntity and IFinancialAgent
     def __init__(self, id, assets=10000):
         self.id = id
-        self.assets = int(assets)
+        self._assets = int(assets)
+
+    @property
+    def balance_pennies(self) -> int:
+        return self._assets
+
+    def deposit(self, amount: int, currency=DEFAULT_CURRENCY):
+        self._deposit(amount, currency)
+
+    def withdraw(self, amount: int, currency=DEFAULT_CURRENCY):
+        self._withdraw(amount, currency)
 
     def _deposit(self, amount: int, currency=DEFAULT_CURRENCY):
         if amount < 0: raise ValueError("Negative deposit")
-        self.assets += amount
+        self._assets += amount
 
     def _withdraw(self, amount: int, currency=DEFAULT_CURRENCY):
         if amount < 0: raise ValueError("Negative withdraw")
-        # SettlementSystem checks assets property manually before calling withdraw,
-        # but pure withdraw should also work.
-        if self.assets < amount:
-             # In simulation context, withdraw might raise InsufficientFundsError
-             # but here we just decrement or let it go negative if not checked strictly by method.
-             pass
-        self.assets -= amount
+        if self._assets < amount:
+             raise InsufficientFundsError(f"Insufficient Funds: {self._assets} < {amount}")
+        self._assets -= amount
 
     def get_balance(self, currency=DEFAULT_CURRENCY) -> int:
-        return self.assets
+        return self._assets
 
-    def get_all_balances(self):
-        return {DEFAULT_CURRENCY: self.assets}
+    def get_all_balances(self) -> Dict[str, int]:
+        return {DEFAULT_CURRENCY: self._assets}
 
     @property
     def total_wealth(self) -> int:
-        return self.assets
+        return self._assets
+
+    def get_liquid_assets(self, currency="USD") -> float:
+        return float(self._assets)
+
+    def get_total_debt(self) -> float:
+        return 0.0
+
+class MockRegistry:
+    def __init__(self, agents: List[Any]):
+        self.agents = {agent.id: agent for agent in agents}
+
+    def get_agent(self, agent_id: Any) -> Any:
+        return self.agents.get(agent_id)
+
+    def get_all_financial_agents(self) -> List[Any]:
+        return list(self.agents.values())
+
+    def set_state(self, state: Any) -> None:
+        pass
 
 def test_settle_atomic_success():
-    settlement = SettlementSystem()
     debit_agent = MockAgent(1, 10000) # $100.00
     credit_agent1 = MockAgent(2, 0)
     credit_agent2 = MockAgent(3, 0)
 
+    registry = MockRegistry([debit_agent, credit_agent1, credit_agent2])
+    settlement = SettlementSystem()
+    settlement.agent_registry = registry
+
     credits = [
         (credit_agent1, 3000, "c1"), # $30.00
         (credit_agent2, 2000, "c2")  # $20.00
@@ -46,18 +76,24 @@ def test_settle_atomic_success():
     success = settlement.settle_atomic(debit_agent, credits, tick=1)
 
     assert success is True
-    assert debit_agent.get_balance() == 5000
-    assert credit_agent1.get_balance() == 3000
-    assert credit_agent2.get_balance() == 2000
+    # SSoT Verification
+    assert settlement.get_balance(debit_agent.id) == 5000
+    assert settlement.get_balance(credit_agent1.id) == 3000
+    assert settlement.get_balance(credit_agent2.id) == 2000
 
 def test_settle_atomic_rollback():
-    settlement = SettlementSystem()
     debit_agent = MockAgent(1, 10000)
     credit_agent1 = MockAgent(2, 0)
     credit_agent2 = MockAgent(3, 0)
 
     # Mock credit_agent2 to fail on deposit
+    # We patch _deposit to simulate failure, as settle_atomic calls _deposit or deposit
     credit_agent2._deposit = MagicMock(side_effect=Exception("Bank Frozen"))
+    credit_agent2.deposit = credit_agent2._deposit # Ensure protocol method also fails
+
+    registry = MockRegistry([debit_agent, credit_agent1, credit_agent2])
+    settlement = SettlementSystem()
+    settlement.agent_registry = registry
 
     credits = [
         (credit_agent1, 3000, "c1"),
@@ -67,8 +103,9 @@ def test_settle_atomic_rollback():
     success = settlement.settle_atomic(debit_agent, credits, tick=1)
 
     assert success is False
-    assert debit_agent.get_balance() == 10000 # Full refund
-    assert credit_agent1.get_balance() == 0 # Rolled back
+    # SSoT Verification: Full Rollback
+    assert settlement.get_balance(debit_agent.id) == 10000
+    assert settlement.get_balance(credit_agent1.id) == 0
 
     # Verify that credit_agent2.deposit was called
     credit_agent2._deposit.assert_called_once()
diff --git a/tests/integration/test_omo_system.py b/tests/integration/test_omo_system.py
index d688aeb2..93528c15 100644
--- a/tests/integration/test_omo_system.py
+++ b/tests/integration/test_omo_system.py
@@ -1,51 +1,90 @@
 import pytest
 from unittest.mock import MagicMock, Mock
+from typing import List, Any, Dict
 from simulation.systems.central_bank_system import CentralBankSystem
 from simulation.systems.transaction_manager import TransactionManager
 from simulation.systems.settlement_system import SettlementSystem
 from simulation.models import Order, Transaction
-from modules.finance.api import OMOInstructionDTO
+from modules.finance.api import OMOInstructionDTO, IFinancialEntity, IFinancialAgent, InsufficientFundsError
 from modules.system.constants import ID_CENTRAL_BANK
+from modules.system.api import IAgentRegistry, DEFAULT_CURRENCY
 
-class MockAgent:
+class OMOTestAgent: # Implements IFinancialEntity and IFinancialAgent
     def __init__(self, agent_id, assets=0):
         self.id = agent_id
-        self.assets = int(assets)
+        self._assets = int(assets)
+        # Legacy attributes required by TransactionManager checks
         self.total_money_issued = 0
         self.total_money_destroyed = 0
         self._econ_state = MagicMock()
-        self._econ_state.assets = self.assets
+        self._econ_state.assets = self._assets
 
-    def _deposit(self, amount, currency="USD"):
-        self.assets += amount
-        self._econ_state.assets = self.assets
+    @property
+    def balance_pennies(self) -> int:
+        return self._assets
+
+    def deposit(self, amount: int, currency=DEFAULT_CURRENCY):
+        self._deposit(amount, currency)
+
+    def withdraw(self, amount: int, currency=DEFAULT_CURRENCY):
+        self._withdraw(amount, currency)
 
-    def _withdraw(self, amount, currency="USD"):
-        if self.id != ID_CENTRAL_BANK and self.assets < amount:
-            from modules.finance.api import InsufficientFundsError
-            raise InsufficientFundsError("Insufficient Funds")
-        self.assets -= amount
-        self._econ_state.assets = self.assets
+    def _deposit(self, amount: int, currency=DEFAULT_CURRENCY):
+        if amount < 0: raise ValueError("Negative deposit")
+        self._assets += amount
+        self._econ_state.assets = self._assets
 
-    def get_balance(self, currency="USD"):
-        return self.assets
+    def _withdraw(self, amount: int, currency=DEFAULT_CURRENCY):
+        if amount < 0: raise ValueError("Negative withdraw")
+        # Allow Central Bank to go negative (Minting)
+        if self.id != ID_CENTRAL_BANK and self._assets < amount:
+            raise InsufficientFundsError(f"Insufficient Funds: {self._assets} < {amount}")
+        self._assets -= amount
+        self._econ_state.assets = self._assets
 
-    def get_all_balances(self):
-        return {"USD": self.assets}
+    def get_balance(self, currency=DEFAULT_CURRENCY) -> int:
+        return self._assets
+
+    def get_all_balances(self) -> Dict[str, int]:
+        return {DEFAULT_CURRENCY: self._assets}
 
     @property
     def total_wealth(self) -> int:
-        return self.assets
+        return self._assets
+
+    def get_liquid_assets(self, currency="USD") -> float:
+        return float(self._assets)
+
+    def get_total_debt(self) -> float:
+        return 0.0
+
+class MockRegistry:
+    def __init__(self, agents: List[Any]):
+        self.agents = {agent.id: agent for agent in agents}
+
+    def get_agent(self, agent_id: Any) -> Any:
+        return self.agents.get(agent_id)
+
+    def get_all_financial_agents(self) -> List[Any]:
+        return list(self.agents.values())
+
+    def set_state(self, state: Any) -> None:
+        pass
 
 @pytest.fixture
 def omo_setup():
     # SettlementSystem checks for "CENTRAL_BANK" ID or "CentralBank" class name to allow overdraft (Minting)
-    cb_agent = MockAgent(agent_id=ID_CENTRAL_BANK, assets=0)
-    gov_agent = MockAgent(agent_id=0, assets=1000)
-    household = MockAgent(agent_id=1, assets=500)
+    # Ensure distinct IDs to avoid Registry collision (ID_CENTRAL_BANK might be 0)
+    cb_agent = OMOTestAgent(agent_id=ID_CENTRAL_BANK, assets=0)
+    gov_agent = OMOTestAgent(agent_id=2, assets=1000) # Changed from 0 to 2
+    household = OMOTestAgent(agent_id=1, assets=500)
+
+    # Setup Registry
+    registry = MockRegistry([cb_agent, gov_agent, household])
 
     logger = MagicMock()
     settlement = SettlementSystem(logger=logger)
+    settlement.agent_registry = registry # Inject Registry
 
     cb_system = CentralBankSystem(
         central_bank_agent=cb_agent,
@@ -58,8 +97,8 @@ def omo_setup():
     state = MagicMock()
     state.agents = {
         cb_agent.id: cb_agent, # Use dynamic ID
-        0: gov_agent,
-        1: household
+        gov_agent.id: gov_agent,
+        household.id: household
     }
     state.government = gov_agent
     state.transactions = []
@@ -74,10 +113,10 @@ def omo_setup():
         logger=logger
     )
 
-    return cb_system, tx_manager, state, cb_agent, gov_agent, household
+    return cb_system, tx_manager, state, cb_agent, gov_agent, household, settlement
 
 def test_execute_omo_purchase_order_creation(omo_setup):
-    cb_system, _, _, _, _, _ = omo_setup
+    cb_system, _, _, _, _, _, _ = omo_setup
 
     instruction: OMOInstructionDTO = {
         "operation_type": "purchase",
@@ -94,7 +133,7 @@ def test_execute_omo_purchase_order_creation(omo_setup):
     assert orders[0].market_id == "security_market"
 
 def test_execute_omo_sale_order_creation(omo_setup):
-    cb_system, _, _, _, _, _ = omo_setup
+    cb_system, _, _, _, _, _, _ = omo_setup
 
     instruction: OMOInstructionDTO = {
         "operation_type": "sale",
@@ -111,10 +150,10 @@ def test_execute_omo_sale_order_creation(omo_setup):
     assert orders[0].market_id == "security_market"
 
 def test_process_omo_purchase_transaction(omo_setup):
-    cb_system, tx_manager, state, cb_agent, gov_agent, household = omo_setup
+    cb_system, tx_manager, state, cb_agent, gov_agent, household, settlement = omo_setup
 
     # Household sells bond to CB (OMO Purchase by CB)
-    # CB pays Household
+    # CB pays Household (Minting new money)
     trade_price = 100
     tx = Transaction(
         buyer_id=cb_agent.id,
@@ -128,22 +167,38 @@ def test_process_omo_purchase_transaction(omo_setup):
     )
     state.transactions = [tx]
 
-    initial_hh_assets = household.get_balance()
+    # Use SSoT for initial state
+    initial_hh_assets = settlement.get_balance(household.id)
     initial_money_issued = gov_agent.total_money_issued
 
+    # Audit M2 before (Sum of non-CB agents)
+    # M2 = Household(500) + Gov(1000) = 1500
+    initial_m2 = settlement.audit_total_m2(expected_total=None) # Returns bool, but logs value.
+    # We can calculate manually for assertion or trust audit_total_m2 logic.
+    # Let's calculate manually using settlement.get_balance
+    m2_before = settlement.get_balance(household.id) + settlement.get_balance(gov_agent.id)
+
     tx_manager.execute(state)
 
-    # Verify Household got paid
-    assert household.get_balance() == initial_hh_assets + trade_price
+    # Verify Household got paid via SSoT
+    assert settlement.get_balance(household.id) == initial_hh_assets + trade_price
 
-    # Verify Gov Ledger Updated (Minting)
+    # Verify Gov Ledger Updated (Minting) - TransactionManager updates this manually on gov agent
     assert gov_agent.total_money_issued == initial_money_issued + trade_price
 
+    # Verify Zero-Sum Integrity (M2 Expansion)
+    # New money entered the system (minted by CB). M2 should increase by trade_price.
+    m2_after = settlement.get_balance(household.id) + settlement.get_balance(gov_agent.id)
+    assert m2_after == m2_before + trade_price
+
+    # Confirm using audit_total_m2
+    assert settlement.audit_total_m2(expected_total=m2_after) is True
+
 def test_process_omo_sale_transaction(omo_setup):
-    cb_system, tx_manager, state, cb_agent, gov_agent, household = omo_setup
+    cb_system, tx_manager, state, cb_agent, gov_agent, household, settlement = omo_setup
 
     # Household buys bond from CB (OMO Sale by CB)
-    # Household pays CB
+    # Household pays CB (Burning money)
     trade_price = 100
     tx = Transaction(
         buyer_id=household.id,
@@ -157,13 +212,23 @@ def test_process_omo_sale_transaction(omo_setup):
     )
     state.transactions = [tx]
 
-    initial_hh_assets = household.get_balance()
+    initial_hh_assets = settlement.get_balance(household.id)
     initial_money_destroyed = gov_agent.total_money_destroyed
 
+    m2_before = settlement.get_balance(household.id) + settlement.get_balance(gov_agent.id)
+
     tx_manager.execute(state)
 
-    # Verify Household paid
-    assert household.get_balance() == initial_hh_assets - trade_price
+    # Verify Household paid via SSoT
+    assert settlement.get_balance(household.id) == initial_hh_assets - trade_price
 
     # Verify Gov Ledger Updated (Burning)
     assert gov_agent.total_money_destroyed == initial_money_destroyed + trade_price
+
+    # Verify Zero-Sum Integrity (M2 Contraction)
+    # Money left the system (burned by CB). M2 should decrease by trade_price.
+    m2_after = settlement.get_balance(household.id) + settlement.get_balance(gov_agent.id)
+    assert m2_after == m2_before - trade_price
+
+    # Confirm using audit_total_m2
+    assert settlement.audit_total_m2(expected_total=m2_after) is True
