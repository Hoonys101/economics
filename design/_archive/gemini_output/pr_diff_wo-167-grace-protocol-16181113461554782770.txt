diff --git a/communications/insights/WO-167.md b/communications/insights/WO-167.md
new file mode 100644
index 0000000..5e49b3a
--- /dev/null
+++ b/communications/insights/WO-167.md
@@ -0,0 +1,20 @@
+# Insight Report: WO-167 Grace Protocol
+
+## 1. Phenomenon
+The current bankruptcy logic is overly aggressive. Firms and households with valuable non-cash assets (inventory, stocks) are liquidated immediately upon running out of cash or reaching starvation thresholds, even if they could theoretically survive by selling those assets. This leads to premature economic destruction and breaks the realism of "distress sales".
+
+## 2. Technical Debt & Structural Issues
+*   **Order Generation in Lifecycle Manager:** The Grace Protocol requires `AgentLifecycleManager` (or `FinanceDepartment` called by it) to generate and place `Order` objects. Typically, orders are generated by `DecisionEngine`s in `Phase1_Decision`. Injecting orders in `Phase_Bankruptcy` (which runs between Decision and Matching) is a deviation from the standard flow but necessary for this emergency mechanism.
+*   **Coupling:** `FinanceDepartment` needs to know about `Order` structures, which arguably belongs to `DecisionEngine`. However, creating a "DistressDecisionEngine" seems overkill. We will implement `trigger_emergency_liquidation` in `FinanceDepartment` to generate orders, acknowledging this minor coupling.
+*   **Household Death Logic:** Household death logic is split between `BioComponent` (aging) and `SocialComponent` (starvation/needs). `AgentLifecycleManager` processes death *after* it happens (liquidation). To implement Grace Protocol, we must intervene *before* death (in `AgentLifecycleManager` or `update_needs`) to override the `is_active=False` flag if the agent is in a "grace period".
+*   **Market Access:** `AgentLifecycleManager` needs access to `state.markets` to place emergency orders. This is available in `SimulationState` passed to `execute()`.
+
+## 3. Solution Overview
+We will implement a "Grace Protocol" (Distress Mode):
+1.  **Firms:** Modify `FinanceDepartment` to detect "Cash Crunch". If crunched but solvent (has inventory), enter distress mode (5-tick timer). Automatically place 20% discounted sell orders. Prevent liquidation during this period.
+2.  **Households:** Similar logic. If starving but asset-rich (stocks/inventory), sell assets and prevent starvation death for 5 ticks.
+3.  **Phase Execution:** These checks run in `Phase_Bankruptcy`, which is ideally situated before `Phase2_Matching`, allowing emergency orders to be executed immediately in the same tick.
+
+## 4. Lessons Learned (Pre-Implementation)
+*   The "Sacred Sequence" of phases (`Decision -> Bankruptcy -> Matching`) is crucial. If `Bankruptcy` ran after `Matching`, the Grace Protocol would fail to save agents in the current tick. The current architecture supports this feature well.
+*   "God Classes" like `Household` make it slightly harder to cleanly separate "Distress Logic" from "Core Logic", requiring modifications to the main class.
diff --git a/simulation/components/finance_department.py b/simulation/components/finance_department.py
index c6b8837..10e3ac2 100644
--- a/simulation/components/finance_department.py
+++ b/simulation/components/finance_department.py
@@ -2,7 +2,7 @@ from __future__ import annotations
 from typing import List, Dict, Any, Optional, TYPE_CHECKING
 import logging
 from collections import deque
-from simulation.models import Transaction
+from simulation.models import Transaction, Order
 from modules.finance.api import InsufficientFundsError
 
 if TYPE_CHECKING:
@@ -47,6 +47,10 @@ class FinanceDepartment:
         self.last_sales_volume: float = 1.0
         self.sales_volume_this_tick: float = 0.0
 
+        # WO-167: Grace Protocol (Distress Mode)
+        self.is_distressed: bool = False
+        self.distress_tick_counter: int = 0
+
     @property
     def balance(self) -> float:
         return self._cash
@@ -353,6 +357,50 @@ class FinanceDepartment:
         else:
             self.consecutive_loss_turns = 0
 
+    def check_cash_crunch(self) -> bool:
+        """
+        WO-167: Evaluates if the firm is in a 'Cash Crunch'.
+        Defined as Cash < 0 or Cash < 10% of expected expenses.
+        """
+        threshold = 0.1 * self.last_daily_expenses
+        return self._cash < 0 or self._cash < threshold
+
+    def trigger_emergency_liquidation(self) -> List[Order]:
+        """
+        WO-167: Generates emergency sell orders for all inventory items at 80% market price.
+        """
+        orders = []
+        for good, qty in self.firm.inventory.items():
+            if qty <= 0:
+                continue
+
+            # Determine price: 80% of market average, or last known price, or initial price
+            price = self.firm.last_prices.get(good, 0.0)
+            if price == 0.0:
+                if self.config and self.config.goods:
+                    price = self.config.goods.get(good, {}).get('initial_price', 10.0)
+                else:
+                    price = 10.0
+
+            liquidation_price = price * 0.8
+
+            order = Order(
+                agent_id=self.firm.id,
+                order_type="SELL",
+                item_id=good,
+                quantity=qty,
+                price=liquidation_price,
+                market_id=good
+            )
+            orders.append(order)
+
+            self.firm.logger.warning(
+                f"GRACE_PROTOCOL | Firm {self.firm.id} triggering emergency liquidation for {good}. Qty: {qty}, Price: {liquidation_price:.2f}",
+                extra={"agent_id": self.firm.id, "tags": ["grace_protocol", "liquidation"]}
+            )
+
+        return orders
+
     def calculate_valuation(self) -> float:
         """
         Calculate Firm Valuation based on Net Assets + Profit Potential.
diff --git a/simulation/core_agents.py b/simulation/core_agents.py
index 61d7e5b..5c25a59 100644
--- a/simulation/core_agents.py
+++ b/simulation/core_agents.py
@@ -8,7 +8,7 @@ import copy
 
 from simulation.base_agent import BaseAgent
 from simulation.decisions.base_decision_engine import BaseDecisionEngine
-from simulation.models import Order, Skill, Talent
+from simulation.models import Order, StockOrder, Skill, Talent
 from simulation.ai.api import (
     Personality,
     Tactic,
@@ -218,6 +218,9 @@ class Household(BaseAgent, ILearningAgent):
         self.goods_info_map = {g["id"]: g for g in goods_data}
         self.risk_aversion = risk_aversion
 
+        # WO-167: Grace Protocol (Distress Mode)
+        self.distress_tick_counter: int = 0
+
         # Setup Decision Engine
         decision_engine.loan_market = loan_market
         decision_engine.logger = self.logger
@@ -734,6 +737,64 @@ class Household(BaseAgent, ILearningAgent):
         self._bio_state.needs = new_needs
         return result
 
+    def trigger_emergency_liquidation(self) -> List[Any]:
+        """
+        WO-167: Generates emergency sell orders for all inventory items and stocks.
+        Returns mixed list of Order and StockOrder.
+        """
+        orders = []
+
+        # 1. Liquidate Inventory
+        for good, qty in self.inventory.items():
+            if qty <= 0:
+                continue
+
+            price = self.perceived_avg_prices.get(good, 10.0)
+            liquidation_price = price * 0.8
+
+            order = Order(
+                agent_id=self.id,
+                order_type="SELL",
+                item_id=good,
+                quantity=qty,
+                price=liquidation_price,
+                market_id=good
+            )
+            orders.append(order)
+
+        # 2. Liquidate Stocks
+        for firm_id, shares in self.shares_owned.items():
+            if shares <= 0:
+                continue
+
+            # Heuristic price for stock: we don't have access to stock market price here easily
+            # without checking markets. We'll use a very low price to ensure sale (market order effectively)
+            # or rely on the market to match.
+            # Ideally we check market data if passed, but here we assume desperation.
+            # We will use 1.0 or 0.1 as a "market sell" signal if the market supports it,
+            # but OrderBookMarket matches based on price.
+            # If we set price too low, we might crash the market.
+            # Let's try to be somewhat reasonable: 10.0 (default fallback) * 0.8 = 8.0
+            price = 8.0
+
+            order = StockOrder(
+                agent_id=self.id,
+                order_type="SELL",
+                firm_id=firm_id,
+                quantity=shares,
+                price=price,
+                market_id="stock_market"
+            )
+            orders.append(order)
+
+        if orders:
+            self.logger.warning(
+                f"GRACE_PROTOCOL | Household {self.id} triggering emergency liquidation. Generated {len(orders)} orders.",
+                extra={"agent_id": self.id, "tags": ["grace_protocol", "liquidation"]}
+            )
+
+        return orders
+
     @override
     def update_needs(self, current_tick: int, market_data: Optional[Dict[str, Any]] = None):
         """
@@ -763,6 +824,15 @@ class Household(BaseAgent, ILearningAgent):
         )
         self._bio_state.needs = new_needs
         self._econ_state.durable_assets = new_durable_assets
+
+        # WO-167: Grace Protocol - Override death if in distress grace period
+        if not is_active and 0 < self.distress_tick_counter <= 5:
+            is_active = True
+            self.logger.info(
+                f"GRACE_PROTOCOL_SAVE | Household {self.id} saved from death. Distress tick {self.distress_tick_counter}",
+                extra={"agent_id": self.id, "tags": ["grace_protocol", "survival"]}
+            )
+
         self._bio_state.is_active = is_active
 
         # 3. Update Political Opinion
diff --git a/simulation/systems/lifecycle_manager.py b/simulation/systems/lifecycle_manager.py
index d618f89..0545371 100644
--- a/simulation/systems/lifecycle_manager.py
+++ b/simulation/systems/lifecycle_manager.py
@@ -60,6 +60,9 @@ class AgentLifecycleManager(AgentLifecycleManagerInterface):
         # 2. NEW: Firm Lifecycle (Aging & Bankruptcy Checks)
         self._process_firm_lifecycle(state)
 
+        # 2a. Household Lifecycle (Distress Checks)
+        self._process_household_lifecycle(state)
+
         # 3. Births
         new_children = self._process_births(state)
         self._register_new_agents(state, new_children)
@@ -77,6 +80,7 @@ class AgentLifecycleManager(AgentLifecycleManagerInterface):
     def _process_firm_lifecycle(self, state: SimulationState) -> None:
         """
         Handles lifecycle updates for all active firms, formerly in Firm.update_needs.
+        Includes WO-167 Grace Protocol for distressed firms.
         """
         assets_threshold = getattr(self.config, "ASSETS_CLOSURE_THRESHOLD", 0.0)
         closure_turns_threshold = getattr(self.config, "FIRM_CLOSURE_TURNS_THRESHOLD", 5)
@@ -94,9 +98,44 @@ class AgentLifecycleManager(AgentLifecycleManagerInterface):
             # Check bankruptcy status (logic from FinanceDepartment)
             firm.finance.check_bankruptcy()
 
-            # Check for closure based on assets or consecutive losses
+            # WO-167: Grace Protocol
+            # Check for Cash Crunch
+            is_crunch = firm.finance.check_cash_crunch()
+            inventory_val = firm.finance.get_inventory_value()
+
+            if is_crunch and inventory_val > 0:
+                # Enter or Continue Distress
+                firm.finance.is_distressed = True
+                firm.finance.distress_tick_counter += 1
+
+                # If within grace period (5 ticks)
+                if firm.finance.distress_tick_counter <= 5:
+                    # Trigger Emergency Liquidation
+                    emergency_orders = firm.finance.trigger_emergency_liquidation()
+
+                    # Inject orders into markets
+                    for order in emergency_orders:
+                        market = state.markets.get(order.market_id)
+                        if market:
+                            market.place_order(order, state.time)
+
+                    # SKIP standard closure check
+                    continue
+            else:
+                # Recovery or No Crunch
+                firm.finance.is_distressed = False
+                firm.finance.distress_tick_counter = 0
+
+            # Standard Closure Check
             if (firm.assets <= assets_threshold or
                     firm.finance.consecutive_loss_turns >= closure_turns_threshold):
+
+                # Double check grace period (if we fell through but counter is high)
+                if firm.finance.distress_tick_counter > 5:
+                    pass # Allow closure
+                elif firm.finance.is_distressed:
+                    continue # Should have been caught above, but safety check
+
                 firm.is_active = False
                 self.logger.warning(
                     f"FIRM_INACTIVE | Firm {firm.id} closed down. Assets: {firm.assets:.2f}, Consecutive Loss Turns: {firm.finance.consecutive_loss_turns}",
@@ -109,6 +148,49 @@ class AgentLifecycleManager(AgentLifecycleManagerInterface):
                     }
                 )
 
+    def _process_household_lifecycle(self, state: SimulationState) -> None:
+        """
+        WO-167: Handles distress checks for households.
+        Triggers emergency liquidation if starving but solvent.
+        """
+        survival_threshold = getattr(self.config, "SURVIVAL_NEED_DEATH_THRESHOLD", 100.0)
+        # We intervene before they hit the threshold perfectly, or if they are close.
+        # Let's say 90% of threshold.
+        distress_threshold = survival_threshold * 0.9
+
+        for household in state.households:
+            if not household.is_active:
+                continue
+
+            survival_need = household.needs.get("survival", 0.0)
+
+            # Check for Distress (High Survival Need or Low Assets but High Real Assets)
+            # Simplification: If survival need is high, we check if they have things to sell.
+            if survival_need > distress_threshold:
+                has_inventory = any(qty > 0 for qty in household.inventory.values())
+                has_stocks = any(qty > 0 for qty in household.shares_owned.values())
+
+                if has_inventory or has_stocks:
+                    household.distress_tick_counter += 1
+
+                    if household.distress_tick_counter <= 5:
+                         emergency_orders = household.trigger_emergency_liquidation()
+
+                         for order in emergency_orders:
+                             market = state.markets.get(order.market_id)
+                             if market:
+                                 market.place_order(order, state.time)
+                             else:
+                                 # Fallback for stocks if market_id="stock_market" is not in dict keys directly?
+                                 if order.market_id == "stock_market" and hasattr(state, "stock_market") and state.stock_market:
+                                     state.stock_market.place_order(order, state.time)
+
+                else:
+                    # No assets to sell, nature takes its course
+                    pass
+            else:
+                household.distress_tick_counter = 0
+
     def _process_births(self, state: SimulationState) -> List[Household]:
         birth_requests = []
         active_households = [h for h in state.households if h.is_active]
diff --git a/tests/integration/test_wo167_grace_protocol.py b/tests/integration/test_wo167_grace_protocol.py
new file mode 100644
index 0000000..3efc972
--- /dev/null
+++ b/tests/integration/test_wo167_grace_protocol.py
@@ -0,0 +1,158 @@
+import pytest
+from unittest.mock import MagicMock
+from simulation.core_agents import Household
+from simulation.firms import Firm
+from simulation.components.finance_department import FinanceDepartment
+from simulation.systems.lifecycle_manager import AgentLifecycleManager
+from simulation.dtos.api import SimulationState
+from simulation.models import Order, StockOrder
+from tests.utils.factories import create_firm_config_dto, create_household_config_dto
+
+class TestGraceProtocol:
+
+    @pytest.fixture
+    def setup_firm_state(self):
+        config = create_firm_config_dto()
+        config.ASSETS_CLOSURE_THRESHOLD = 0.0
+        config.FIRM_CLOSURE_TURNS_THRESHOLD = 5
+        config.LIQUIDITY_NEED_INCREASE_RATE = 1.0
+
+        firm = MagicMock(spec=Firm)
+        firm.id = 1
+        firm.is_active = True
+        firm.age = 10
+        firm.needs = {"liquidity_need": 0.0}
+        firm.assets = 0.0 # No cash
+        firm.inventory = {"wood": 10.0}
+        firm.last_prices = {"wood": 10.0}
+
+        # Real FinanceDepartment to test logic
+        firm.finance = FinanceDepartment(firm, config, initial_capital=0.0)
+        # Mock logger
+        firm.logger = MagicMock()
+
+        return firm, config
+
+    def test_firm_grace_protocol(self, setup_firm_state):
+        firm, config = setup_firm_state
+
+        # Setup Markets
+        market_mock = MagicMock()
+        markets = {"wood": market_mock}
+
+        state = MagicMock(spec=SimulationState)
+        state.firms = [firm]
+        state.markets = markets
+        state.time = 1
+
+        # Lifecycle Manager
+        manager = AgentLifecycleManager(config, MagicMock(), MagicMock(), MagicMock(), MagicMock(), MagicMock(), MagicMock())
+
+        # Run 1: Enter Distress
+        firm.finance._cash = -10.0 # Cash Crunch
+        manager._process_firm_lifecycle(state)
+
+        assert firm.finance.is_distressed is True
+        assert firm.finance.distress_tick_counter == 1
+        assert firm.is_active is True # Saved
+
+        # Check Order Placement
+        # manager._process_firm_lifecycle calls market.place_order(order, time)
+        assert market_mock.place_order.called
+        call_args = market_mock.place_order.call_args
+        order = call_args[0][0]
+        assert isinstance(order, Order)
+        assert order.order_type == "SELL"
+        assert order.item_id == "wood"
+        assert order.price == 8.0 # 10.0 * 0.8
+
+        # Run 2-5: Stay in Distress
+        for i in range(2, 6):
+            state.time = i
+            manager._process_firm_lifecycle(state)
+            assert firm.finance.distress_tick_counter == i
+            assert firm.is_active is True
+
+        # Run 6: Death
+        state.time = 6
+        manager._process_firm_lifecycle(state)
+        assert firm.finance.distress_tick_counter == 6
+        # Should fall through to closure check
+        # Since assets <= threshold (0 <= 0), it should close.
+        # But wait, logic says:
+        # if distress_tick_counter > 5: pass (allow closure)
+        # then if assets <= threshold: active=False
+        assert firm.is_active is False
+
+    @pytest.fixture
+    def setup_household_state(self):
+        config = create_household_config_dto()
+        config.SURVIVAL_NEED_DEATH_THRESHOLD = 100.0
+
+        hh = MagicMock(spec=Household)
+        hh.id = 101
+        hh.is_active = True
+        hh.needs = {"survival": 95.0} # Critical (> 90)
+        hh.inventory = {}
+        hh.shares_owned = {1: 10.0} # Has stocks
+        hh.distress_tick_counter = 0
+        hh.logger = MagicMock()
+
+        # We need the real trigger_emergency_liquidation logic?
+        # But Household is mocked. We should assign the real method or mock the return.
+        # Ideally we use real Household but it has many dependencies.
+        # Let's bind the method if possible or just implement the method on the mock
+        # or use real Household with mocked components.
+
+        # Let's try real Household with mocked dependencies
+        real_hh = Household(
+            id=101,
+            talent=MagicMock(),
+            goods_data=[{"id": "wood", "initial_price": 10.0}],
+            initial_assets=0.0,
+            initial_needs={"survival": 95.0},
+            decision_engine=MagicMock(),
+            value_orientation="traditional",
+            personality=MagicMock(),
+            config_dto=config,
+            logger=MagicMock()
+        )
+        # Update portfolio correctly
+        real_hh._econ_state.portfolio.add(firm_id=1, quantity=10.0, price=10.0)
+
+        return real_hh, config
+
+    def test_household_grace_protocol(self, setup_household_state):
+        hh, config = setup_household_state
+
+        # Setup Markets
+        stock_market_mock = MagicMock()
+        state = MagicMock(spec=SimulationState)
+        state.households = [hh]
+        state.markets = {}
+        state.stock_market = stock_market_mock
+        state.time = 1
+
+        manager = AgentLifecycleManager(config, MagicMock(), MagicMock(), MagicMock(), MagicMock(), MagicMock(), MagicMock())
+
+        # Run 1: Enter Distress
+        manager._process_household_lifecycle(state)
+
+        assert hh.distress_tick_counter == 1
+
+        # Check Stock Order
+        assert stock_market_mock.place_order.called
+        order = stock_market_mock.place_order.call_args[0][0]
+        assert isinstance(order, StockOrder)
+        assert order.firm_id == 1
+
+        # Test Death Override in update_needs
+        # Mock social component to return False (Death)
+        hh.social_component = MagicMock()
+        hh.social_component.update_psychology.return_value = (MagicMock(), {"survival": 100}, [], False) # is_active=False
+
+        hh.update_needs(current_tick=1)
+
+        # Should be saved by Grace Protocol
+        assert hh.is_active is True
+        hh.logger.info.assert_called()
diff --git a/tests/utils/factories.py b/tests/utils/factories.py
index 7715574..349a33f 100644
--- a/tests/utils/factories.py
+++ b/tests/utils/factories.py
@@ -82,6 +82,8 @@ def create_household_config_dto(**kwargs) -> HouseholdConfigDTO:
         "survival_need_emergency_threshold": 80.0,
         "primary_survival_good_id": "food",
         "survival_bid_premium": 0.2,
+        "elasticity_mapping": {"DEFAULT": 1.0},
+        "max_willingness_to_pay_multiplier": 1.5,
     }
     defaults.update(kwargs)
     return HouseholdConfigDTO(**defaults)
@@ -141,6 +143,8 @@ def create_firm_config_dto(**kwargs) -> FirmConfigDTO:
         "fire_sale_inventory_target": 10.0,
         "fire_sale_discount": 0.5,
         "fire_sale_cost_discount": 0.8,
+        "sale_timeout_ticks": 10,
+        "dynamic_price_reduction_factor": 0.05,
     }
     defaults.update(kwargs)
     return FirmConfigDTO(**defaults)
