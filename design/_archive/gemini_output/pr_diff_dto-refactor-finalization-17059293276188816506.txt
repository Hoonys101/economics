diff --git a/communications/insights/DTO_Refactor.md b/communications/insights/DTO_Refactor.md
new file mode 100644
index 0000000..fe67d8a
--- /dev/null
+++ b/communications/insights/DTO_Refactor.md
@@ -0,0 +1,44 @@
+# Technical Debt: DTO Refactor and Standardization
+
+**Mission Key:** DTO_Refactor
+**Date:** 2024-05-23
+**Author:** Jules
+
+## Context
+The codebase is currently in a transitional state regarding Data Transfer Objects (DTOs). While `OrderDTO` has been standardized as a Dataclass, other critical DTOs like `MarketSnapshotDTO` and `SystemStateDTO` are defined as `TypedDict` in some places and used as objects in others. Furthermore, there is a naming collision for `MarketSnapshotDTO` between `modules/system/api.py` (Agent-facing market signals) and `modules/simulation/api.py` (Observer-facing macro indicators).
+
+## Identified Technical Debt
+
+### 1. Dual Definition of `MarketSnapshotDTO`
+- **modules/system/api.py**: Defines `MarketSnapshotDTO` as a `TypedDict` containing detailed market signals (`market_signals`). Used by `DecisionContext` for agents.
+- **modules/simulation/api.py**: Defines `MarketSnapshotDTO` as a `TypedDict` containing macro indicators (`gdp`, `cpi`). Used by `Simulation` engine for logging.
+- **Impact**: Confusion in `simulation/engine.py` and decision engines. `DecisionContext` imports from `system/api`, while `engine.py` imports from `simulation/api`. This leads to `AttributeError` or `KeyError` if usage is mixed.
+
+### 2. TypedDict vs Dataclass Inconsistency
+- The project is moving towards Dataclasses (e.g., `OrderDTO`), but many internal DTOs remain `TypedDict`.
+- **Impact**: Inconsistent access patterns (e.g., `d['key']` vs `d.key`). Dataclasses offer better type safety and method support.
+
+### 3. Return Type Ambiguity in Decision Engines
+- Decision engines return `Tuple[List[Order], Any]`. The second element (`metadata` or `tactic`) varies by implementation and is not type-safe.
+- **Impact**: Difficult to extend or introspect the decision output.
+
+### 4. Legacy Dictionary Usage
+- `market_data` is passed as a raw dictionary (`Dict[str, Any]`) throughout the system.
+- **Impact**: While out of scope for this specific refactor, it remains a significant source of implicit coupling and potential runtime errors.
+
+## Refactoring Strategy
+
+### 1. Resolve Naming Collision
+- Rename `modules/simulation/api.py:MarketSnapshotDTO` to `EconomicIndicatorsDTO` (or `MacroSnapshotDTO`).
+- Keep `modules/system/api.py:MarketSnapshotDTO` for agent signals.
+
+### 2. Standardize to Dataclasses
+- Convert `MarketSnapshotDTO`, `MarketSignalDTO`, `EconomicIndicatorsDTO`, and `SystemStateDTO` to `@dataclass`.
+- This enforces dot notation access (`obj.field`) and provides a clear schema.
+
+### 3. Introduce `DecisionOutputDTO`
+- Replace the tuple return type in decision engines with a standardized `DecisionOutputDTO(orders: List[OrderDTO], metadata: Any)`.
+
+### 4. Update Engine and Orchestration
+- Update `simulation/engine.py` to use `EconomicIndicatorsDTO` for logging.
+- Update `simulation/orchestration/phases.py` to construct proper Dataclass instances for `DecisionContext`.
diff --git a/modules/simulation/api.py b/modules/simulation/api.py
index 3d0fca1..9a2f8b8 100644
--- a/modules/simulation/api.py
+++ b/modules/simulation/api.py
@@ -1,4 +1,5 @@
 from __future__ import annotations
+from dataclasses import dataclass
 from typing import Protocol, TypedDict, Any, List, Dict
 
 # --- DTOs ---
@@ -10,14 +11,17 @@ class ShockConfigDTO(TypedDict):
     tfp_multiplier: float  # The factor to multiply the baseline TFP by (e.g., 0.5 for a 50% drop)
     baseline_tfp: float   # The normal TFP value to restore to
 
-class MarketSnapshotDTO(TypedDict):
+@dataclass
+class EconomicIndicatorsDTO:
     """
     Snapshot of key market indicators for analysis modules.
+    Formerly MarketSnapshotDTO.
     """
     gdp: float
     cpi: float
 
-class SystemStateDTO(TypedDict):
+@dataclass
+class SystemStateDTO:
     """
     Internal system flags and states not meant for agent decision-making but essential for observation.
     """
@@ -61,7 +65,7 @@ class ISimulationState(Protocol):
     government: IGovernment
     config_module: IConfig
 
-    def get_market_snapshot(self) -> MarketSnapshotDTO:
+    def get_economic_indicators(self) -> EconomicIndicatorsDTO:
         """
         Retrieves the current market snapshot containing economic indicators like GDP.
         """
diff --git a/modules/system/api.py b/modules/system/api.py
index 08cf71d..a5d60c9 100644
--- a/modules/system/api.py
+++ b/modules/system/api.py
@@ -1,9 +1,11 @@
 from __future__ import annotations
+from dataclasses import dataclass, field
 from typing import TypedDict, List, Dict, Optional, Any, Protocol
 
 # --- DTOs for Market Stability Signals ---
 
-class MarketSignalDTO(TypedDict):
+@dataclass
+class MarketSignalDTO:
     """
     Provides agents with essential, pre-calculated signals about a specific market's state.
     This is generated by the MarketSignalObserver after each trading round to ensure data purity
@@ -23,7 +25,8 @@ class MarketSignalDTO(TypedDict):
 
 # --- Modifications to Existing Core DTOs ---
 
-class MarketSnapshotDTO(TypedDict):
+@dataclass
+class MarketSnapshotDTO:
     """
     [MODIFIED] A snapshot of all relevant market data for a given tick.
     This is a breaking change. The snapshot now contains a structured dictionary
diff --git a/simulation/decisions/ai_driven_household_engine.py b/simulation/decisions/ai_driven_household_engine.py
index d8a10e2..85add59 100644
--- a/simulation/decisions/ai_driven_household_engine.py
+++ b/simulation/decisions/ai_driven_household_engine.py
@@ -4,7 +4,7 @@ import logging
 
 from simulation.models import Order
 from .base_decision_engine import BaseDecisionEngine
-from simulation.dtos import DecisionContext, MacroFinancialContext
+from simulation.dtos import DecisionContext, MacroFinancialContext, DecisionOutputDTO
 
 # Modular Managers
 from simulation.decisions.household.api import (
@@ -51,7 +51,7 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
         self,
         context: DecisionContext,
         macro_context: Optional[MacroFinancialContext] = None,
-    ) -> Tuple[List[Order], Any]: # Returns HouseholdActionVector
+    ) -> DecisionOutputDTO:
         """
         AI ì—”ì§„ì„ ì‚¬ìš©í•˜ì—¬ ìµœì ì˜ ì „ìˆ (Vector)ì„ ê²°ì •í•˜ê³ , ê·¸ì— ë”°ë¥¸ ì£¼ë¬¸ì„ ìƒì„±í•œë‹¤.
         """
@@ -60,7 +60,7 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
 
         if household is None:
             from simulation.schemas import HouseholdActionVector
-            return [], HouseholdActionVector()
+            return DecisionOutputDTO(orders=[], metadata=HouseholdActionVector())
 
         market_snapshot = context.market_snapshot
         market_data = context.market_data
@@ -78,12 +78,12 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
                 food_id = 'food'
 
             signal = None
-            if market_snapshot and 'market_signals' in market_snapshot:
-                 signal = market_snapshot['market_signals'].get(food_id)
+            if market_snapshot and market_snapshot.market_signals:
+                 signal = market_snapshot.market_signals.get(food_id)
 
             # If signal exists and has sellers
-            if signal and signal.get('best_ask') is not None:
-                ask_price = signal['best_ask']
+            if signal and signal.best_ask is not None:
+                ask_price = signal.best_ask
                 # Affordability Check
                 if household.assets >= ask_price:
                      premium = getattr(config, 'survival_bid_premium', 0.1)
@@ -99,16 +99,19 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
                      survival_order = Order(
                          agent_id=household.id,
                          item_id=food_id,
-                         order_type="BUY",
+                         side="BUY",
                          quantity=1.0,
-                         price=bid_price,
+                         price_limit=bid_price,
                          market_id=food_id
                      )
 
                      # Return immediately, skipping other logic
                      from simulation.schemas import HouseholdActionVector
                      # We return a vector with high work aggressiveness as survival instinct implies working hard too
-                     return [survival_order], HouseholdActionVector(work_aggressiveness=1.0)
+                     return DecisionOutputDTO(
+                         orders=[survival_order],
+                         metadata=HouseholdActionVector(work_aggressiveness=1.0)
+                     )
 
         agent_data = household.agent_data
 
@@ -162,7 +165,7 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
         )
         orders.extend(self.housing_manager.decide_housing(housing_ctx))
         
-        return orders, action_vector
+        return DecisionOutputDTO(orders=orders, metadata=action_vector)
 
     def decide_reproduction(self, context: DecisionContext) -> bool:
         """
diff --git a/simulation/decisions/base_decision_engine.py b/simulation/decisions/base_decision_engine.py
index 8dae4d1..98daa17 100644
--- a/simulation/decisions/base_decision_engine.py
+++ b/simulation/decisions/base_decision_engine.py
@@ -1,8 +1,7 @@
 from __future__ import annotations
-from typing import List, Dict, Any, Tuple, TYPE_CHECKING, Optional
+from typing import List, Dict, Any, Tuple, TYPE_CHECKING, Optional, Union
 from simulation.models import Order
-
-from simulation.dtos import DecisionContext
+from simulation.dtos import DecisionContext, DecisionOutputDTO
 
 if TYPE_CHECKING:
     from simulation.core_markets import Market
@@ -14,7 +13,7 @@ class BaseDecisionEngine:
         self,
         context: DecisionContext,
         macro_context: Optional[MacroFinancialContext] = None,
-    ) -> Tuple[List[Order], Any]:
+    ) -> DecisionOutputDTO:
         """
         ì—ì´ì „íŠ¸ì˜ í˜„ìž¬ ìƒíƒœì™€ ì‹œìž¥ ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì˜ì‚¬ê²°ì •ì„ ë‚´ë¦½ë‹ˆë‹¤.
         ðŸš¨ DTO PURITY GATE ðŸš¨: ì§ì ‘ì ì¸ ì—ì´ì „íŠ¸ ì¸ìŠ¤í„´ìŠ¤ ì ‘ê·¼ì„ ì°¨ë‹¨í•©ë‹ˆë‹¤.
@@ -29,7 +28,7 @@ class BaseDecisionEngine:
         self,
         context: DecisionContext,
         macro_context: Optional[MacroFinancialContext] = None,
-    ) -> Tuple[List[Order], Any]:
+    ) -> DecisionOutputDTO:
         """
         ì‹¤ì œ ì˜ì‚¬ê²°ì • ë¡œì§ì„ êµ¬í˜„í•˜ëŠ” ë‚´ë¶€ ë©”ì„œë“œ.
         í•˜ìœ„ í´ëž˜ìŠ¤ì—ì„œ ë°˜ë“œì‹œ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤.
diff --git a/simulation/decisions/household/asset_manager.py b/simulation/decisions/household/asset_manager.py
index 872ecd9..f92224c 100644
--- a/simulation/decisions/household/asset_manager.py
+++ b/simulation/decisions/household/asset_manager.py
@@ -50,7 +50,14 @@ class AssetManager:
             repay_amount = min(repay_amount, household.assets * liquidity_ratio)
 
             if repay_amount > 1.0:
-                 orders.append(Order(household.id, "REPAYMENT", "currency", repay_amount, 1.0, "loan_market"))
+                 orders.append(Order(
+                     agent_id=household.id,
+                     side="REPAYMENT",
+                     item_id="currency",
+                     quantity=repay_amount,
+                     price_limit=1.0,
+                     market_id="loan_market"
+                 ))
                  if logger:
                     logger.info(f"DEBT_AVERSION | Household {household.id} prioritizing repayment: {repay_amount:.1f}")
 
@@ -149,11 +156,25 @@ class AssetManager:
         if diff_deposit > 10.0:
             actual_deposit = min(cash, diff_deposit)
             if actual_deposit > 10.0:
-                orders.append(Order(household.id, "DEPOSIT", "currency", actual_deposit, 1.0, "currency"))
+                orders.append(Order(
+                    agent_id=household.id,
+                    side="DEPOSIT",
+                    item_id="currency",
+                    quantity=actual_deposit,
+                    price_limit=1.0,
+                    market_id="currency"
+                ))
 
         elif diff_deposit < -10.0:
             amount_to_withdraw = abs(diff_deposit)
-            orders.append(Order(household.id, "WITHDRAW", "currency", amount_to_withdraw, 1.0, "currency"))
+            orders.append(Order(
+                agent_id=household.id,
+                side="WITHDRAW",
+                item_id="currency",
+                quantity=amount_to_withdraw,
+                price_limit=1.0,
+                market_id="currency"
+            ))
 
         startup_cost = getattr(config, "startup_cost", 30000.0)
 
@@ -162,7 +183,14 @@ class AssetManager:
             survival_buffer = 2000.0
 
             if projected_cash >= (startup_cost + survival_buffer):
-                orders.append(Order(household.id, "INVEST", "startup", 1.0, startup_cost, "admin"))
+                orders.append(Order(
+                    agent_id=household.id,
+                    side="INVEST",
+                    item_id="startup",
+                    quantity=1.0,
+                    price_limit=startup_cost,
+                    market_id="admin"
+                ))
 
         return orders
 
@@ -177,7 +205,14 @@ class AssetManager:
 
             if deposit_balance > 10.0:
                 amount = min(deposit_balance, 50.0)
-                orders.append(Order(household.id, "WITHDRAW", "currency", amount, 1.0, "currency"))
+                orders.append(Order(
+                    agent_id=household.id,
+                    side="WITHDRAW",
+                    item_id="currency",
+                    quantity=amount,
+                    price_limit=1.0,
+                    market_id="currency"
+                ))
 
         return orders
 
diff --git a/simulation/decisions/household/consumption_manager.py b/simulation/decisions/household/consumption_manager.py
index 11b05ec..5830b6e 100644
--- a/simulation/decisions/household/consumption_manager.py
+++ b/simulation/decisions/household/consumption_manager.py
@@ -121,7 +121,14 @@ class ConsumptionManager:
                      final_quantity = max(1, int(quantity_to_buy))
 
                  orders.append(
-                    Order(household.id, "BUY", item_id, final_quantity, bid_price, item_id)
+                    Order(
+                        agent_id=household.id,
+                        side="BUY",
+                        item_id=item_id,
+                        quantity=final_quantity,
+                        price_limit=bid_price,
+                        market_id=item_id
+                    )
                  )
 
         return orders
diff --git a/simulation/decisions/household/housing_manager.py b/simulation/decisions/household/housing_manager.py
index 0d4c134..52123f9 100644
--- a/simulation/decisions/household/housing_manager.py
+++ b/simulation/decisions/household/housing_manager.py
@@ -89,7 +89,12 @@ class HousingManager:
 
                  if should_buy:
                      buy_order = Order(
-                         agent.id, "BUY", best_offer.item_id, 1.0, best_offer.price, "housing"
+                         agent_id=agent.id,
+                         side="BUY",
+                         item_id=best_offer.item_id,
+                         quantity=1.0,
+                         price_limit=best_offer.price,
+                         market_id="housing"
                      )
                      orders.append(buy_order)
 
diff --git a/simulation/decisions/household/labor_manager.py b/simulation/decisions/household/labor_manager.py
index 46876e8..08f420d 100644
--- a/simulation/decisions/household/labor_manager.py
+++ b/simulation/decisions/household/labor_manager.py
@@ -37,7 +37,14 @@ class LaborManager:
 
                 if random.random() < (config.job_quit_prob_base + agg_mobility * config.job_quit_prob_scale):
                     # Signal quit via Order
-                    orders.append(Order(household.id, "QUIT", "labor", 0, 0, "labor"))
+                    orders.append(Order(
+                        agent_id=household.id,
+                        side="QUIT",
+                        item_id="labor",
+                        quantity=0.0,
+                        price_limit=0.0,
+                        market_id="labor"
+                    ))
 
         # Scenario B: Unemployed
         if not household.is_employed:
@@ -92,7 +99,14 @@ class LaborManager:
                     )
             else:
                 orders.append(
-                    Order(household.id, "SELL", "labor", 1, reservation_wage, "labor")
+                    Order(
+                        agent_id=household.id,
+                        side="SELL",
+                        item_id="labor",
+                        quantity=1.0,
+                        price_limit=reservation_wage,
+                        market_id="labor"
+                    )
                 )
 
         return orders
diff --git a/simulation/decisions/rule_based_firm_engine.py b/simulation/decisions/rule_based_firm_engine.py
index bc0222e..55ff03d 100644
--- a/simulation/decisions/rule_based_firm_engine.py
+++ b/simulation/decisions/rule_based_firm_engine.py
@@ -3,12 +3,9 @@ from typing import TYPE_CHECKING, List, Dict, Any, Optional, Tuple
 import logging
 
 from simulation.models import Order
-from simulation.decisions.base_decision_engine import BaseDecisionEngine
+from .base_decision_engine import BaseDecisionEngine
 from simulation.ai.enums import Tactic
-from simulation.dtos import DecisionContext, FirmStateDTO
-
-if TYPE_CHECKING:
-    from simulation.dtos import MacroFinancialContext
+from simulation.dtos import DecisionContext, MacroFinancialContext, DecisionOutputDTO, FirmStateDTO
 
 class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
     """
@@ -26,7 +23,7 @@ class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
         self,
         context: DecisionContext,
         macro_context: Optional[MacroFinancialContext] = None,
-    ) -> Tuple[List[Order], Tactic]:
+    ) -> DecisionOutputDTO:
         """
         Executes rule-based logic.
         """
@@ -42,7 +39,17 @@ class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
         if inventory > 0:
             # Determine Price
             market_price = 10.0
-            if "goods_market" in market_data:
+
+            # Use market_snapshot if available (Standardized DTO)
+            if context.market_snapshot and context.market_snapshot.market_signals:
+                signal = context.market_snapshot.market_signals.get(specialization)
+                if signal:
+                    if signal.last_traded_price:
+                        market_price = signal.last_traded_price
+                    elif signal.best_ask:
+                        market_price = signal.best_ask
+
+            if market_price <= 0 and "goods_market" in market_data:
                 market_price = market_data["goods_market"].get(f"{specialization}_current_sell_price", 10.0)
 
             # Simple Undercut Strategy to ensure liquidity
@@ -53,10 +60,10 @@ class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
 
             orders.append(Order(
                 agent_id=firm_state.id,
-                order_type="SELL",
+                side="SELL",
                 item_id=specialization,
                 quantity=inventory,
-                price=sell_price,
+                price_limit=sell_price,
                 market_id=specialization
             ))
 
@@ -79,7 +86,7 @@ class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
              fire_orders = self._fire_excess_labor(firm_state, needed_labor)
              orders.extend(fire_orders)
 
-        return orders, Tactic.NO_ACTION
+        return DecisionOutputDTO(orders=orders, metadata=Tactic.NO_ACTION)
 
     def _fire_excess_labor(self, firm: FirmStateDTO, needed_labor: float) -> List[Order]:
         """
@@ -101,11 +108,6 @@ class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
         min_wage = getattr(self.config_module, "LABOR_MARKET_MIN_WAGE", 5.0)
 
         # Access employee details via DTO if available, else use defaults.
-        # Assuming FirmStateDTO could be extended or we assume standard wage for RuleBased.
-        # However, for robustness, we should try to use actual data if possible.
-        # Since BaseDecisionEngine operates on DTOs, and DTOs might not have deep employee data,
-        # we will use a conservative estimate or look for 'employees_data' if it exists.
-
         employees_data = getattr(firm, "employees_data", {})
 
         for emp_id in candidates:
@@ -117,12 +119,12 @@ class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
             severance_pay = current_wage * severance_weeks * skill
 
             orders.append(Order(
-                firm.id,
-                "FIRE",
-                "internal",
-                1,
-                severance_pay,
-                "internal",
+                agent_id=firm.id,
+                side="FIRE",
+                item_id="internal",
+                quantity=1,
+                price_limit=severance_pay,
+                market_id="internal",
                 target_agent_id=emp_id
             ))
 
@@ -164,7 +166,17 @@ class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
             )
 
         if new_target != target_quantity:
-            return [Order(firm.id, "SET_TARGET", "internal", new_target, 0.0, "internal")]
+            # "SET_TARGET" is likely not a valid 'side' enum in OrderDTO but internal usage might tolerate it or handle as special.
+            # If OrderDTO enforces side as "BUY"/"SELL", this might be tricky.
+            # Assuming OrderDTO side is string and allows custom types or engines interpret it.
+            return [Order(
+                agent_id=firm.id,
+                side="SET_TARGET",
+                item_id="internal",
+                quantity=new_target,
+                price_limit=0.0,
+                market_id="internal"
+            )]
 
         return []
 
@@ -186,14 +198,28 @@ class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
 
         if current_employees < min_employees:
             to_hire = min_employees - current_employees
-            order = Order(firm.id, "BUY", "labor", float(to_hire), offered_wage, "labor")
+            order = Order(
+                agent_id=firm.id,
+                side="BUY",
+                item_id="labor",
+                quantity=float(to_hire),
+                price_limit=offered_wage,
+                market_id="labor"
+            )
             orders.append(order)
         elif (
             needed_labor > current_employees
             and current_employees < max_employees
         ):
             to_hire = min(needed_labor - current_employees, max_employees - current_employees)
-            order = Order(firm.id, "BUY", "labor", float(to_hire), offered_wage, "labor")
+            order = Order(
+                agent_id=firm.id,
+                side="BUY",
+                item_id="labor",
+                quantity=float(to_hire),
+                price_limit=offered_wage,
+                market_id="labor"
+            )
             orders.append(order)
 
         return orders
diff --git a/simulation/decisions/rule_based_household_engine.py b/simulation/decisions/rule_based_household_engine.py
index 5092ae7..c3474aa 100644
--- a/simulation/decisions/rule_based_household_engine.py
+++ b/simulation/decisions/rule_based_household_engine.py
@@ -5,7 +5,7 @@ import logging
 from simulation.models import Order
 from simulation.ai.enums import Tactic, Aggressiveness
 from .base_decision_engine import BaseDecisionEngine
-from simulation.dtos import DecisionContext
+from simulation.dtos import DecisionContext, DecisionOutputDTO
 
 if TYPE_CHECKING:
     from simulation.dtos import MacroFinancialContext
@@ -36,7 +36,7 @@ class RuleBasedHouseholdDecisionEngine(BaseDecisionEngine):
         self,
         context: DecisionContext,
         macro_context: Optional[MacroFinancialContext] = None,
-    ) -> Tuple[List[Order], Tuple[Tactic, Aggressiveness]]:
+    ) -> DecisionOutputDTO:
         """
         ê·œì¹™ ê¸°ë°˜ ë¡œì§ì„ ì‚¬ìš©í•˜ì—¬ ê°€ê³„ì˜ ì˜ì‚¬ê²°ì •ì„ ìˆ˜í–‰í•œë‹¤.
         """
@@ -68,8 +68,12 @@ class RuleBasedHouseholdDecisionEngine(BaseDecisionEngine):
                 needed_quantity = target_buffer - food_in_inventory
                 market_id = food_item_id 
 
-                # TD-117: Use MarketSnapshotDTO
-                best_ask = market_snapshot.best_asks.get(food_item_id) if market_snapshot else None
+                # TD-117: Use MarketSnapshotDTO (Standardized)
+                best_ask = None
+                if market_snapshot and market_snapshot.market_signals:
+                    signal = market_snapshot.market_signals.get(food_item_id)
+                    if signal:
+                        best_ask = signal.best_ask
 
                 if best_ask is None or best_ask == 0:
                     best_ask = getattr(self.config_module, "DEFAULT_FALLBACK_PRICE", 5.0)
@@ -81,12 +85,12 @@ class RuleBasedHouseholdDecisionEngine(BaseDecisionEngine):
                     if quantity_to_buy > 0.1:
                         orders.append(
                             Order(
-                                state.id,
-                                "BUY",
-                                food_item_id,
-                                quantity_to_buy,
-                                best_ask,
-                                market_id,
+                                agent_id=state.id,
+                                side="BUY",
+                                item_id=food_item_id,
+                                quantity=quantity_to_buy,
+                                price_limit=best_ask,
+                                market_id=market_id,
                             )
                         )
                         self.logger.info(
@@ -102,7 +106,19 @@ class RuleBasedHouseholdDecisionEngine(BaseDecisionEngine):
 
             # 2. Survival Trigger (Panic Mode)
             food_inventory = state.inventory.get("basic_food", 0.0)
-            food_price = market_data.get("goods_market", {}).get("basic_food_avg_traded_price", 10.0)
+
+            # Use market_snapshot for price if available, else fallback
+            food_price = 10.0
+            if market_snapshot and market_snapshot.market_signals:
+                 signal = market_snapshot.market_signals.get("basic_food")
+                 if signal and signal.last_traded_price:
+                     food_price = signal.last_traded_price
+                 elif signal and signal.best_ask:
+                     food_price = signal.best_ask
+
+            if food_price <= 0:
+                food_price = market_data.get("goods_market", {}).get("basic_food_avg_traded_price", 10.0)
+
             if food_price <= 0: food_price = 10.0
 
             survival_days = food_inventory + (state.assets / food_price)
@@ -139,12 +155,12 @@ class RuleBasedHouseholdDecisionEngine(BaseDecisionEngine):
             else:
                 orders.append(
                     Order(
-                        state.id,
-                        "SELL",
-                        "labor",
-                        1.0,  # 1 unit of labor
-                        desired_wage,
-                        "labor",
+                        agent_id=state.id,
+                        side="SELL",
+                        item_id="labor",
+                        quantity=1.0,  # 1 unit of labor
+                        price_limit=desired_wage,
+                        market_id="labor",
                     )
                 )
                 self.logger.info(
@@ -152,4 +168,4 @@ class RuleBasedHouseholdDecisionEngine(BaseDecisionEngine):
                     extra={"tick": current_time, "agent_id": state.id, "tactic": chosen_tactic.name}
                 )
 
-        return orders, (chosen_tactic, chosen_aggressiveness)
+        return DecisionOutputDTO(orders=orders, metadata=(chosen_tactic, chosen_aggressiveness))
diff --git a/simulation/dtos/api.py b/simulation/dtos/api.py
index 1f2457f..c23f2f9 100644
--- a/simulation/dtos/api.py
+++ b/simulation/dtos/api.py
@@ -3,6 +3,7 @@ from dataclasses import dataclass, field
 from typing import Dict, Any, Optional, List, TYPE_CHECKING, Union, TypedDict
 from simulation.dtos.firm_state_dto import FirmStateDTO
 from simulation.models import Order
+from simulation.dtos.decision_dtos import DecisionOutputDTO
 
 if TYPE_CHECKING:
     from simulation.core_agents import Household
@@ -123,9 +124,10 @@ class OrderDTO:
     quantity: float
     price: float
 
-# Phase 1: MarketSnapshotDTO moved to modules.system.api and converted to TypedDict
-# This is a breaking change for existing agents.
+# Phase 1: MarketSnapshotDTO moved to modules.system.api
 from modules.system.api import MarketSnapshotDTO
+# Phase 1: EconomicIndicatorsDTO from modules.simulation.api
+from modules.simulation.api import EconomicIndicatorsDTO
 
 @dataclass
 class GovernmentPolicyDTO:
diff --git a/simulation/dtos/decision_dtos.py b/simulation/dtos/decision_dtos.py
new file mode 100644
index 0000000..e58a2b9
--- /dev/null
+++ b/simulation/dtos/decision_dtos.py
@@ -0,0 +1,9 @@
+from dataclasses import dataclass
+from typing import List, Any
+from simulation.models import Order
+
+@dataclass
+class DecisionOutputDTO:
+    """Standardized output from decision engines."""
+    orders: List[Order]
+    metadata: Any = None
diff --git a/simulation/engine.py b/simulation/engine.py
index a3dd89c..e89636c 100644
--- a/simulation/engine.py
+++ b/simulation/engine.py
@@ -12,7 +12,7 @@ from simulation.world_state import WorldState
 from simulation.orchestration.tick_orchestrator import TickOrchestrator
 from simulation.action_processor import ActionProcessor
 from simulation.models import Transaction
-from modules.simulation.api import MarketSnapshotDTO, SystemStateDTO
+from modules.simulation.api import EconomicIndicatorsDTO, SystemStateDTO
 
 from simulation.db.logger import SimulationLogger
 import simulation
@@ -79,14 +79,14 @@ class Simulation:
         self.tick_orchestrator.run_tick(injectable_sensory_dto)
         
         # Log macro snapshot for ThoughtStream analysis
-        snapshot = self.get_market_snapshot()
+        snapshot = self.get_economic_indicators()
         system_state = self.get_system_state()
         self.simulation_logger.log_snapshot(
             tick=self.world_state.time,
             snapshot_data={
-                "gdp": snapshot["gdp"],
+                "gdp": snapshot.gdp,
                 "m2": self.world_state.calculate_total_money(),
-                "cpi": snapshot["cpi"],
+                "cpi": snapshot.cpi,
                 "transaction_count": len(self.world_state.transactions)
             }
         )
@@ -99,10 +99,11 @@ class Simulation:
         """ì‹œë®¬ë ˆì´ì…˜ì— ì°¸ì—¬í•˜ëŠ” ëª¨ë“  í™œì„± ì—ì´ì „íŠ¸(ê°€ê³„, ê¸°ì—…, ì€í–‰ ë“±)ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."""
         return self.world_state.get_all_agents()
 
-    def get_market_snapshot(self) -> MarketSnapshotDTO:
+    def get_economic_indicators(self) -> EconomicIndicatorsDTO:
         """
         Retrieves the current market snapshot containing economic indicators.
         Exposes a public interface for observers (satisfies ISimulationState).
+        Formerly get_market_snapshot.
         """
         # Retrieve raw data from orchestrator
         market_data = self.tick_orchestrator.prepare_market_data()
@@ -120,7 +121,7 @@ class Simulation:
         cpi = total_price / count if count > 0 else 0.0
 
         # Construct and return formal DTO
-        return MarketSnapshotDTO(
+        return EconomicIndicatorsDTO(
             gdp=market_data.get("total_production", 0.0),
             cpi=cpi
         )
diff --git a/simulation/orchestration/phases.py b/simulation/orchestration/phases.py
index 3e5f46c..99787df 100644
--- a/simulation/orchestration/phases.py
+++ b/simulation/orchestration/phases.py
@@ -431,13 +431,22 @@ class Phase1_Decision(IPhaseStrategy):
 
                 stress_config = self.world_state.stress_scenario_config
 
-                firm_orders, action_vector = firm.make_decision(
+                # DTO Refactor: Expect DecisionOutputDTO
+                decision_output = firm.make_decision(
                     state.markets, state.goods_data, market_data, state.time,
                     state.government, stress_config,
                     market_snapshot=market_snapshot, government_policy=gov_policy,
                     agent_registry=agent_registry
                 )
 
+                # Check if it's new DTO or legacy tuple
+                if hasattr(decision_output, 'orders'):
+                    firm_orders = decision_output.orders
+                    # metadata ignored or used if needed
+                else:
+                    # Fallback for unmigrated code (Tuple)
+                    firm_orders, action_vector = decision_output
+
                 for order in firm_orders:
                     target_market = state.markets.get(order.market_id)
                     if target_market:
@@ -460,16 +469,35 @@ class Phase1_Decision(IPhaseStrategy):
                     }
 
                 stress_config = self.world_state.stress_scenario_config
-                household_orders, action_vector = household.make_decision(
+
+                # DTO Refactor: Expect DecisionOutputDTO
+                decision_output = household.make_decision(
                     state.markets, state.goods_data, market_data, state.time, state.government, macro_financial_context, stress_config,
                     market_snapshot=market_snapshot, government_policy=gov_policy,
                     agent_registry=agent_registry
                 )
 
-                if hasattr(action_vector, 'work_aggressiveness'):
-                    work_aggressiveness = action_vector.work_aggressiveness
+                if hasattr(decision_output, 'orders'):
+                    household_orders = decision_output.orders
+                    metadata = decision_output.metadata
+
+                    # Assume metadata contains action_vector if needed, or handle if it is the vector itself
+                    # Since AIDrivenHouseholdDecisionEngine returns vector as second element,
+                    # metadata should be that vector.
+
+                    if hasattr(metadata, 'work_aggressiveness'):
+                        action_vector = metadata
+                        work_aggressiveness = action_vector.work_aggressiveness
+                    else:
+                         work_aggressiveness = 0.5
                 else:
-                    work_aggressiveness = 0.5
+                    # Legacy Tuple
+                    household_orders, action_vector = decision_output
+                    if hasattr(action_vector, 'work_aggressiveness'):
+                        work_aggressiveness = action_vector.work_aggressiveness
+                    else:
+                        work_aggressiveness = 0.5
+
                 max_work_hours = state.config_module.MAX_WORK_HOURS
                 shopping_hours = getattr(state.config_module, "SHOPPING_HOURS", 2.0)
                 hours_per_tick = getattr(state.config_module, "HOURS_PER_TICK", 24.0)
@@ -480,15 +508,24 @@ class Phase1_Decision(IPhaseStrategy):
 
                 for order in household_orders:
                     # WO-053: Force deflationary pressure on basic_food
-                    if hasattr(order, "item_id") and order.item_id == "basic_food" and order.order_type == "BUY":
+                    if hasattr(order, "item_id") and order.item_id == "basic_food" and order.side == "BUY": # Update order_type -> side
                          # Check for generic scenario parameter via config injection
                          deflationary_multiplier = getattr(state.config_module, "DEFLATIONARY_PRESSURE_MULTIPLIER", None)
 
                          if deflationary_multiplier is not None:
                              current_price = market_data.get("basic_food_current_sell_price", 5.0)
-                             order.price = min(order.price, max(0.1, current_price * float(deflationary_multiplier)))
-
-                    if order.order_type == "INVEST" and order.market_id == "admin":
+                             # Update price -> price_limit (OrderDTO) or use alias
+                             # OrderDTO has 'price' property alias
+                             # But Order dataclass (alias) might not if it's just OrderDTO
+                             # OrderDTO has price property.
+                             # But we might need to construct a new order if it's frozen?
+                             # OrderDTO is frozen=True.
+                             # So we must replace.
+                             from dataclasses import replace
+                             new_price = min(order.price, max(0.1, current_price * float(deflationary_multiplier)))
+                             order = replace(order, price_limit=new_price)
+
+                    if order.side == "INVEST" and order.market_id == "admin": # Update order_type -> side
                         if self.world_state.firm_system:
                             self.world_state.firm_system.spawn_firm(state, household)
                         else:
@@ -496,7 +533,7 @@ class Phase1_Decision(IPhaseStrategy):
                         continue
 
                     target_market_id = order.market_id
-                    if order.order_type in ["DEPOSIT", "WITHDRAW", "LOAN_REQUEST", "REPAYMENT"]:
+                    if order.side in ["DEPOSIT", "WITHDRAW", "LOAN_REQUEST", "REPAYMENT"]: # Update order_type -> side
                         target_market_id = "loan_market"
                     elif hasattr(order, "item_id") and order.item_id in ["deposit", "currency"]:
                         target_market_id = "loan_market"
@@ -544,12 +581,13 @@ class Phase1_Decision(IPhaseStrategy):
             for tx in commerce_txs:
                 if tx.transaction_type == "PHASE23_MARKET_ORDER":
                      # WO-053: Convert special transaction to Order
+                     # Use new OrderDTO fields: side, price_limit
                      order = Order(
                          agent_id=tx.buyer_id,
                          item_id=tx.item_id,
                          quantity=tx.quantity,
-                         price=tx.price,
-                         order_type="BUY",
+                         price_limit=tx.price,
+                         side="BUY",
                          market_id=tx.item_id
                      )
                      market = state.markets.get(tx.item_id)
