diff --git a/communications/insights/phase23-surgical-separation.md b/communications/insights/phase23-surgical-separation.md
new file mode 100644
index 00000000..8396759d
--- /dev/null
+++ b/communications/insights/phase23-surgical-separation.md
@@ -0,0 +1,17 @@
+# Phase 23 Insight Report: Operation Surgical Separation
+
+## 1. Architectural Insights
+- **Goal**: Decouple stateful "Departments" (HR, Finance) into stateless "Engines" (SEO Pattern) and fix the singleton ambiguity in `WorldState`.
+- **Target Debt**: `TD-ARCH-FIRM-COUP` (High), `TD-ARCH-GOV-MISMATCH` (Medium).
+- **Strategy**:
+  - **Firm Orchestration**: Shift operational decision logic (hiring, firing, budgeting) from the generic `RuleBasedFirmDecisionEngine` to specialized, stateless `FinanceEngine` and `HREngine`. The `Firm` agent will orchestrate these engines directly in `make_decision`.
+  - **Government Singleton**: Resolve the `WorldState.governments` (List) vs `WorldState.government` (Property) ambiguity by enforcing a strict Singleton pattern (`self.government: Optional[Government]`). This aligns the implementation with the actual single-government assumption of the simulation.
+
+## 2. Test Evidence
+```
+tests/test_firm_surgical_separation.py::TestFirmSurgicalSeparation::test_make_decision_orchestrates_engines PASSED [ 33%]
+tests/unit/test_government_structure.py::TestGovernmentStructure::test_government_singleton PASSED [ 66%]
+tests/unit/test_government_structure.py::TestGovernmentStructure::test_simulation_delegation PASSED [100%]
+
+======================== 3 passed, 2 warnings in 0.28s =========================
+```
diff --git a/modules/firm/api.py b/modules/firm/api.py
index bd8bcf57..324eb2c6 100644
--- a/modules/firm/api.py
+++ b/modules/firm/api.py
@@ -1,11 +1,13 @@
 from __future__ import annotations
 from typing import Protocol, Any, Optional, Dict, List, Literal, runtime_checkable
 from dataclasses import dataclass, field
+from enum import Enum
 
 from modules.simulation.dtos.api import FirmConfigDTO, FinanceStateDTO, ProductionStateDTO, SalesStateDTO, HRStateDTO
 from modules.system.api import MarketSnapshotDTO
 from modules.simulation.api import IInventoryHandler
 from modules.finance.api import IFinancialAgent
+from simulation.models import Order
 
 # ==============================================================================
 # 1. ARCHITECTURAL RESOLUTION: ASSET PROTOCOLS
@@ -42,6 +44,11 @@ class ICollateralizableAsset(Protocol):
 # 2. DTO DEFINITIONS
 # ==============================================================================
 
+class FirmStrategy(Enum):
+    PROFIT_MAXIMIZATION = "PROFIT_MAXIMIZATION"
+    MARKET_SHARE = "MARKET_SHARE"
+    SURVIVAL = "SURVIVAL"
+
 @dataclass(frozen=True)
 class FirmSnapshotDTO:
     """
@@ -54,6 +61,49 @@ class FirmSnapshotDTO:
     production: ProductionStateDTO
     sales: SalesStateDTO
     hr: HRStateDTO
+    strategy: FirmStrategy = FirmStrategy.PROFIT_MAXIMIZATION
+
+# --- Finance Engine DTOs ---
+
+@dataclass(frozen=True)
+class FinanceDecisionInputDTO:
+    """Input for FinanceEngine."""
+    firm_snapshot: FirmSnapshotDTO
+    market_snapshot: MarketSnapshotDTO
+    config: FirmConfigDTO
+    current_tick: int
+    credit_rating: float = 0.0
+
+@dataclass(frozen=True)
+class BudgetPlanDTO:
+    """Output from FinanceEngine. Determines constraints for other engines."""
+    total_budget_pennies: int
+    labor_budget_pennies: int
+    capital_budget_pennies: int
+    marketing_budget_pennies: int
+    dividend_payout_pennies: int
+    debt_repayment_pennies: int
+    is_solvent: bool
+
+# --- HR Engine DTOs ---
+
+@dataclass(frozen=True)
+class HRDecisionInputDTO:
+    """Input for HREngine."""
+    firm_snapshot: FirmSnapshotDTO
+    budget_plan: BudgetPlanDTO
+    market_snapshot: MarketSnapshotDTO
+    config: FirmConfigDTO
+    current_tick: int
+    labor_market_avg_wage: int = 1000 # Pennies
+
+@dataclass(frozen=True)
+class HRDecisionOutputDTO:
+    """Output from HREngine."""
+    hiring_orders: List[Order]
+    firing_ids: List[int]
+    wage_updates: Dict[int, int]
+    target_headcount: int
 
 # --- Production Engine DTOs ---
 
@@ -159,6 +209,18 @@ class PricingResultDTO:
 # 3. ENGINE PROTOCOLS
 # ==============================================================================
 
+@runtime_checkable
+class IFinanceEngine(Protocol):
+    """Stateless engine for financial planning."""
+    def plan_budget(self, input_dto: FinanceDecisionInputDTO) -> BudgetPlanDTO:
+        ...
+
+@runtime_checkable
+class IHREngine(Protocol):
+    """Stateless engine for human resources management."""
+    def manage_workforce(self, input_dto: HRDecisionInputDTO) -> HRDecisionOutputDTO:
+        ...
+
 @runtime_checkable
 class IProductionEngine(Protocol):
     """
@@ -263,6 +325,11 @@ class IFinancialComponent(IFinancialAgent, IFirmComponent, Protocol):
 __all__ = [
     'ICollateralizableAsset',
     'FirmSnapshotDTO',
+    'FirmStrategy',
+    'FinanceDecisionInputDTO',
+    'BudgetPlanDTO',
+    'HRDecisionInputDTO',
+    'HRDecisionOutputDTO',
     'ProductionInputDTO',
     'ProductionResultDTO',
     'AssetManagementInputDTO',
@@ -273,6 +340,8 @@ __all__ = [
     'RDResultDTO',
     'PricingInputDTO',
     'PricingResultDTO',
+    'IFinanceEngine',
+    'IHREngine',
     'IProductionEngine',
     'IAssetManagementEngine',
     'IPricingEngine',
diff --git a/scenarios/scenario_stress_100.py b/scenarios/scenario_stress_100.py
index 614920d2..920e26fd 100644
--- a/scenarios/scenario_stress_100.py
+++ b/scenarios/scenario_stress_100.py
@@ -67,8 +67,8 @@ def run_stress_test():
         # Retrieve Authorized Delta
         # sim.government is usually the instance if using facade, or verify via state
         gov = getattr(sim, "government", None)
-        if not gov and state.governments:
-             gov = state.governments[0]
+        if not gov and state.government:
+             gov = state.government
 
         authorized_delta = 0.0
         if gov and hasattr(gov, "get_monetary_delta"):
diff --git a/scripts/fiscal_debug_master.py b/scripts/fiscal_debug_master.py
index 966cee17..1daaff03 100644
--- a/scripts/fiscal_debug_master.py
+++ b/scripts/fiscal_debug_master.py
@@ -19,7 +19,7 @@ def audit_money(sim, context_name):
     # Core Money Audit Logic
     h_sum = sum(h.total_wealth for h in sim.world_state.households)
     f_sum = sum(f.total_wealth for f in sim.world_state.firms)
-    gov_sum = sum(g.total_wealth for g in sim.world_state.governments)
+    gov_sum = sim.world_state.government.total_wealth if sim.world_state.government else 0
     bank_wealth = sim.world_state.bank.total_wealth if sim.world_state.bank else 0
     
     total = h_sum + f_sum + gov_sum + bank_wealth
diff --git a/scripts/hunt_leak.py b/scripts/hunt_leak.py
index 5b6997c5..b41ca2cc 100644
--- a/scripts/hunt_leak.py
+++ b/scripts/hunt_leak.py
@@ -28,8 +28,8 @@ def hunt_leak():
             snapshot["BANK"] = get_val(state.bank.assets)
         if state.central_bank:
             snapshot["CB"] = get_val(state.central_bank.assets)
-        if state.governments:
-            snapshot["GOVT"] = get_val(state.governments[0].assets)
+        if state.government:
+            snapshot["GOVT"] = get_val(state.government.assets)
         return snapshot
 
     print("--- LEAK HUNT START ---")
diff --git a/scripts/tick1_forensic.py b/scripts/tick1_forensic.py
index fdeaa275..b09ad51d 100644
--- a/scripts/tick1_forensic.py
+++ b/scripts/tick1_forensic.py
@@ -31,8 +31,8 @@ def forensic_tick1():
         h_sum = sum(h.total_wealth for h in sim.world_state.households if h.is_active)
         f_sum = sum(f.total_wealth for f in sim.world_state.firms if f.is_active)
         
-        # Government is a list in WorldState
-        gov_sum = sum(g.total_wealth for g in sim.world_state.governments)
+        # Government is a singleton in WorldState
+        gov_sum = sim.world_state.government.total_wealth if sim.world_state.government else 0
         
         bank_wealth = sim.world_state.bank.total_wealth if sim.world_state.bank else 0
         
diff --git a/simulation/action_processor.py b/simulation/action_processor.py
index 69ad60dc..ad8b3959 100644
--- a/simulation/action_processor.py
+++ b/simulation/action_processor.py
@@ -50,7 +50,7 @@ class ActionProcessor:
                 agents=self.world_state.agents,
                 markets=self.world_state.markets,
                 primary_government=self.world_state.government,
-                governments=self.world_state.governments, # Added for TD-ARCH-GOV-MISMATCH
+                governments=[self.world_state.government] if self.world_state.government else [], # TD-ARCH-GOV-MISMATCH: Populate list
                 bank=self.world_state.bank,
                 central_bank=self.world_state.central_bank,
                 escrow_agent=getattr(self.world_state, "escrow_agent", None),
diff --git a/simulation/components/engines/finance_engine.py b/simulation/components/engines/finance_engine.py
index 16586ab8..721843db 100644
--- a/simulation/components/engines/finance_engine.py
+++ b/simulation/components/engines/finance_engine.py
@@ -7,6 +7,7 @@ from modules.finance.api import InsufficientFundsError, IShareholderRegistry
 from modules.system.api import CurrencyCode, DEFAULT_CURRENCY
 from modules.finance.dtos import MoneyDTO, MultiCurrencyWalletDTO
 from simulation.dtos.context_dtos import FinancialTransactionContext
+from modules.firm.api import FinanceDecisionInputDTO, BudgetPlanDTO
 
 if TYPE_CHECKING:
     from modules.simulation.dtos.api import FirmConfigDTO
@@ -20,6 +21,97 @@ class FinanceEngine:
     MIGRATION: Uses integer pennies for transactions and state.
     """
 
+    def plan_budget(self, input_dto: FinanceDecisionInputDTO) -> BudgetPlanDTO:
+        """
+        Plans the budget for the upcoming tick based on current state and priorities.
+        """
+        firm_snapshot = input_dto.firm_snapshot
+        finance_state = firm_snapshot.finance
+        balance = finance_state.balance.get(DEFAULT_CURRENCY, 0)
+
+        # 1. Solvency Check (Operating Runway)
+        # Assuming simple rule: Keep 2 ticks of expenses as buffer if possible
+        # We don't have explicit "last tick total expenses" easily accessible in DTO
+        # except logic or history.
+        # But we can look at cost_this_turn if it was from previous tick?
+        # FinanceState has expenses_this_tick. If snapshot is taken before reset, it has last tick's expenses.
+        # But reset happens at end of tick. Decision happens in Phase 1.
+        # So expenses_this_tick is from *current* tick (0 so far).
+        # We can use profit_history or heuristics.
+
+        total_budget = balance
+
+        # Priorities:
+        # 1. Debt Repayment (if mandated or critical)
+        # 2. Labor (Wages)
+        # 3. Production (Inputs) - Not explicitly budgeted here but part of OPEX
+        # 4. Marketing
+        # 5. Capital/Automation (Investment)
+        # 6. Dividends
+
+        # Debt
+        debt_repayment = 0
+        total_debt = input_dto.firm_snapshot.finance.total_debt_pennies if hasattr(input_dto.firm_snapshot.finance, 'total_debt_pennies') else 0
+        if total_debt > 0:
+            # Simple heuristic: Pay 1% of debt per tick if cash allows
+            debt_repayment = min(int(total_debt * 0.01), total_budget)
+            total_budget -= debt_repayment
+
+        # Dividend
+        dividend_payout = 0
+        # Only pay dividends if we have excess cash?
+        # Usually dividends are from profits, handled in generate_financial_transactions.
+        # But here we set a "budget" cap.
+        # If generate_financial_transactions handles it based on profit, we can set this to 0 or MAX.
+        # Let's say we reserve amount equal to last profit * dividend_rate
+        last_profit = finance_state.profit_history[-1] if finance_state.profit_history else 0
+        if last_profit > 0:
+            dividend_payout = int(last_profit * finance_state.dividend_rate)
+            # But we don't subtract from budget yet, as this is "planned"
+            # And dividend is usually paid after OPEX.
+
+        # Labor Budget
+        # Estimate from current employees
+        # current_wage_bill = sum(w for w in firm_snapshot.hr.employees_data.values().wage)
+        # But we need to allow for hiring.
+        # Let's give 50% of remaining liquid assets to Labor + Production?
+        # Or use System2 guidance?
+
+        # For now, simple allocation:
+        # Reserve for Survival/Maintenance?
+
+        # We return the "Plan" which acts as constraints for other engines.
+
+        # Strategy Adjustment
+        strategy = firm_snapshot.strategy
+        marketing_priority = 0.1
+        capital_priority = 0.1
+
+        if str(strategy) == "FirmStrategy.MARKET_SHARE":
+            marketing_priority = 0.3
+        elif str(strategy) == "FirmStrategy.PROFIT_MAXIMIZATION":
+            capital_priority = 0.2
+
+        available_for_ops = total_budget
+
+        labor_budget = int(available_for_ops * 0.6)
+        marketing_budget = int(available_for_ops * marketing_priority)
+        capital_budget = int(available_for_ops * capital_priority)
+
+        # Ensure we have enough for current employees?
+        # That logic is in HREngine (fire if can't pay).
+        # Here we just say "You have X to spend".
+
+        return BudgetPlanDTO(
+            total_budget_pennies=balance,
+            labor_budget_pennies=labor_budget,
+            capital_budget_pennies=capital_budget,
+            marketing_budget_pennies=marketing_budget,
+            dividend_payout_pennies=dividend_payout,
+            debt_repayment_pennies=debt_repayment,
+            is_solvent=balance > 0 # Simple solvency check
+        )
+
     def generate_financial_transactions(
         self,
         state: FinanceState,
diff --git a/simulation/components/engines/hr_engine.py b/simulation/components/engines/hr_engine.py
index 1c59a387..b9016f0b 100644
--- a/simulation/components/engines/hr_engine.py
+++ b/simulation/components/engines/hr_engine.py
@@ -3,12 +3,13 @@ from typing import List, Dict, Any, Optional, Tuple, TYPE_CHECKING
 import logging
 from modules.system.api import DEFAULT_CURRENCY, CurrencyCode, MarketContextDTO
 from modules.hr.api import IEmployeeDataProvider
-from simulation.models import Transaction
+from simulation.models import Transaction, Order
 from simulation.components.state.firm_state_models import HRState
 from simulation.dtos.hr_dtos import HRPayrollContextDTO, HRPayrollResultDTO, EmployeeUpdateDTO
+from modules.firm.api import HRDecisionInputDTO, HRDecisionOutputDTO
 
 if TYPE_CHECKING:
-    from modules.simulation.dtos.api import FirmConfigDTO
+    from modules.simulation.dtos.api import FirmConfigDTO, FirmStateDTO
 
 logger = logging.getLogger(__name__)
 
@@ -18,6 +19,142 @@ class HREngine:
     Manages employees, calculates wages (skill + halo), and handles insolvency firing.
     """
 
+    def manage_workforce(self, input_dto: HRDecisionInputDTO) -> HRDecisionOutputDTO:
+        """
+        Decides on hiring and firing based on production needs and budget constraints.
+        Ported from RuleBasedFirmDecisionEngine.
+        """
+        orders: List[Order] = []
+        firing_ids: List[int] = []
+        wage_updates: Dict[int, int] = {}
+
+        firm_state = input_dto.firm_snapshot
+        config = input_dto.config
+        current_tick = input_dto.current_tick
+        budget_plan = input_dto.budget_plan
+
+        # 1. Calculate Needed Labor
+        # Logic from RuleBasedFirmDecisionEngine._calculate_needed_labor
+        item_id = firm_state.production.specialization
+        target_quantity = firm_state.production.production_target
+        current_inventory = firm_state.production.inventory.get(item_id, 0)
+
+        needed_production = max(0, target_quantity - current_inventory)
+        productivity_factor = firm_state.production.productivity_factor
+
+        if productivity_factor <= 0:
+            needed_labor = 999999.0
+        else:
+            needed_labor = needed_production / productivity_factor
+
+        target_headcount = int(needed_labor)
+
+        # 2. Compare with current headcount
+        current_employees_list = firm_state.hr.employees # Note: FirmSnapshotDTO has list of IDs? No, HRStateDTO has IDs.
+        # Wait, FirmSnapshotDTO.hr is HRStateDTO.
+        # HRStateDTO has `employees: List[int]` (IDs) and `employees_data: Dict[int, Dict]`.
+        # So I can get count.
+        current_headcount = len(firm_state.hr.employees)
+
+        # 3. Hire or Fire
+
+        # Budget Constraint: Check if we can afford current + new employees
+        # Avg Wage?
+        # We can use actual wages for current employees.
+        current_wage_bill = sum(e['wage'] for e in firm_state.hr.employees_data.values())
+
+        # Check Firing
+        # Logic from RuleBasedFirmDecisionEngine._fire_excess_labor
+        # "if current_employees > needed_labor + 1"
+        if current_headcount > target_headcount + 1:
+            excess = current_headcount - target_headcount
+            excess = min(excess, max(0, current_headcount - 1)) # Don't fire everyone? (implied by max(0, current-1))
+
+            if excess > 0:
+                # Find candidates (lowest skill? random? last hired?)
+                # Current logic was just firm.hr.employees[:excess] (first ones)
+                # We only have IDs in DTO.
+                candidates = firm_state.hr.employees[:excess]
+
+                severance_weeks = getattr(config, 'severance_pay_weeks', 2) # DTO attributes might be snake_case
+                # config is FirmConfigDTO.
+
+                for emp_id in candidates:
+                    emp_info = firm_state.hr.employees_data.get(emp_id, {})
+                    current_wage = emp_info.get('wage', 1000) # Pennies
+                    skill = emp_info.get('skill', 1.0)
+
+                    # Severance calculation (pennies)
+                    severance_pay = int(current_wage * severance_weeks * skill)
+
+                    # Create FIRE order (Internal Market)
+                    orders.append(Order(
+                        agent_id=firm_state.id,
+                        side='FIRE',
+                        item_id='internal',
+                        quantity=1,
+                        price_pennies=severance_pay,
+                        price_limit=float(severance_pay)/100.0,
+                        market_id='internal',
+                        target_agent_id=emp_id
+                    ))
+                    firing_ids.append(emp_id)
+
+        # Check Hiring
+        # Logic from RuleBasedFirmDecisionEngine._adjust_wages
+        min_employees = getattr(config, 'firm_min_employees', 1)
+        max_employees = getattr(config, 'firm_max_employees', 100)
+
+        to_hire = 0
+        if current_headcount < min_employees:
+            to_hire = min_employees - current_headcount
+        elif target_headcount > current_headcount and current_headcount < max_employees:
+            to_hire = min(target_headcount - current_headcount, max_employees - current_headcount)
+
+        if to_hire > 0:
+            # Check Budget
+            # Estimated wage offer
+            # Logic from RuleBasedFirmDecisionEngine._calculate_dynamic_wage_offer
+            base_wage = input_dto.labor_market_avg_wage # Pennies
+            sensitivity = 0.1
+            max_premium = 2.0
+
+            profit_history = firm_state.finance.profit_history
+            avg_profit = sum(profit_history) / len(profit_history) if profit_history else 0.0
+
+            profit_based_premium = avg_profit / (base_wage * 10.0) # Heuristic
+            wage_premium = max(0, min(profit_based_premium * sensitivity, max_premium))
+
+            offered_wage = int(base_wage * (1 + wage_premium))
+
+            # Can we afford N hires?
+            # Projected Cost = Current Wages + (N * Offered Wage)
+            # Budget Plan labor_budget covers this?
+            # Let's say labor_budget is for the *tick* (monthly/daily?)
+            # Usually wages are paid periodically.
+            # If labor_budget_pennies is the limit for *total* wage bill:
+            if current_wage_bill + (to_hire * offered_wage) <= budget_plan.labor_budget_pennies:
+                # Issue Buy Order
+                orders.append(Order(
+                    agent_id=firm_state.id,
+                    side='BUY',
+                    item_id='labor',
+                    quantity=float(to_hire),
+                    price_pennies=offered_wage,
+                    price_limit=float(offered_wage)/100.0,
+                    market_id='labor'
+                ))
+            else:
+                # Reduce hires or skip
+                pass
+
+        return HRDecisionOutputDTO(
+            hiring_orders=orders,
+            firing_ids=firing_ids,
+            wage_updates=wage_updates,
+            target_headcount=target_headcount
+        )
+
     def calculate_wage(self, employee: IEmployeeDataProvider, base_wage: int, config: FirmConfigDTO) -> int:
         """
         Calculates wage based on skill and halo effect. Returns int pennies.
diff --git a/simulation/firms.py b/simulation/firms.py
index 345328c4..d0d62a7f 100644
--- a/simulation/firms.py
+++ b/simulation/firms.py
@@ -36,6 +36,8 @@ from simulation.dtos.sales_dtos import SalesPostAskContextDTO, SalesMarketingCon
 # New API Imports
 from modules.firm.api import (
     FirmSnapshotDTO,
+    FinanceDecisionInputDTO, BudgetPlanDTO,
+    HRDecisionInputDTO, HRDecisionOutputDTO,
     ProductionInputDTO, ProductionResultDTO,
     AssetManagementInputDTO, AssetManagementResultDTO,
     RDInputDTO, RDResultDTO,
@@ -907,8 +909,47 @@ class Firm(ILearningAgent, IFinancialFirm, IFinancialAgent, ILiquidatable, IOrch
             },
         )
 
-        state_dto = self.get_state_dto()
+        # 1. State Snapshot
+        snapshot = self.get_snapshot_dto()
+
+        # 2. Finance Engine: Plan Budget
+        # TODO: credit_rating placeholder
+        fin_input = FinanceDecisionInputDTO(
+            firm_snapshot=snapshot,
+            market_snapshot=market_snapshot,
+            config=self.config,
+            current_tick=current_time,
+            credit_rating=0.0
+        )
+        budget_plan = self.finance_engine.plan_budget(fin_input)
+
+        # 3. HR Engine: Manage Workforce
+        labor_wage = 1000 # Default
+        if market_snapshot and market_snapshot.labor:
+            # Assuming labor market snapshot has avg_wage as int pennies or float
+            # MarketSnapshotDTO definition says LaborMarketSnapshotDTO.avg_wage is float.
+            # We need to cast to int pennies if it is float.
+            labor_wage = int(market_snapshot.labor.avg_wage * 100) if market_snapshot.labor.avg_wage > 0 else 1000
+        elif market_data and "labor" in market_data:
+             # Fallback to dictionary
+             labor_wage = int(market_data.get("labor", {}).get("avg_wage", 10.0) * 100)
+
+        hr_input = HRDecisionInputDTO(
+            firm_snapshot=snapshot,
+            budget_plan=budget_plan,
+            market_snapshot=market_snapshot,
+            config=self.config,
+            current_tick=current_time,
+            labor_market_avg_wage=labor_wage
+        )
+        hr_result = self.hr_engine.manage_workforce(hr_input)
+
+        # 4. Collect Engine Orders
+        engine_orders = []
+        engine_orders.extend(hr_result.hiring_orders)
 
+        # 5. Legacy Decision Engine (for Sales/Production)
+        state_dto = self.get_state_dto()
         context = DecisionContext(
             state=state_dto,
             config=self.config,
@@ -924,16 +965,27 @@ class Firm(ILearningAgent, IFinancialFirm, IFinancialAgent, ILiquidatable, IOrch
         decision_output = self.decision_engine.make_decisions(context)
         
         if hasattr(decision_output, "orders"):
-            decisions = decision_output.orders
+            legacy_orders = decision_output.orders
             tactic = decision_output.metadata
         else:
-            decisions, tactic = decision_output
+            legacy_orders, tactic = decision_output
+
+        # Filter legacy orders: Remove HR related (BUY labor, FIRE) to defer to Engines
+        filtered_legacy = [
+            o for o in legacy_orders
+            if o.market_id != 'labor' and o.order_type != 'FIRE'
+        ]
+
+        # Merge orders: Engine First (Priority) or Legacy First?
+        # Engine is "Planned", Legacy is "RuleBased".
+        # Let's say Engine orders are authoritative for HR.
+        all_orders = engine_orders + filtered_legacy
 
-        # Command Bus execution
-        self.execute_internal_orders(decisions, fiscal_context, current_time, market_context)
+        # Command Bus execution (Internal Orders like FIRE, SET_TARGET)
+        self.execute_internal_orders(all_orders, fiscal_context, current_time, market_context)
 
         # Filter external orders for further processing
-        external_orders = [o for o in decisions if o.market_id != "internal"]
+        external_orders = [o for o in all_orders if o.market_id != "internal"]
 
         self.sales_engine.check_and_apply_dynamic_pricing(
             self.sales_state, external_orders, current_time,
diff --git a/simulation/initialization/initializer.py b/simulation/initialization/initializer.py
index ace0aa69..67b93675 100644
--- a/simulation/initialization/initializer.py
+++ b/simulation/initialization/initializer.py
@@ -183,9 +183,8 @@ class SimulationInitializer(SimulationInitializerInterface):
         sim.bank.settlement_system = sim.settlement_system
         sim.agents[sim.bank.id] = sim.bank
         sim.next_agent_id += 1
-        sim.world_state.governments.clear()
         gov = Government(id=sim.next_agent_id, initial_assets=0.0, config_module=self.config, strategy=sim.strategy)
-        sim.world_state.governments.append(gov)
+        sim.world_state.government = gov
         sim.government.settlement_system = sim.settlement_system
         sim.agents[sim.government.id] = sim.government
         sim.next_agent_id += 1
diff --git a/simulation/orchestration/dashboard_service.py b/simulation/orchestration/dashboard_service.py
index ec52a27a..847a38d1 100644
--- a/simulation/orchestration/dashboard_service.py
+++ b/simulation/orchestration/dashboard_service.py
@@ -37,7 +37,7 @@ class DashboardService:
     def get_snapshot(self) -> WatchtowerSnapshotDTO:
         state = self.state
         tracker = state.tracker
-        gov = state.governments[0] if state.governments else None
+        gov = state.government
 
         # --- 1. System Integrity ---
         # Use smoothed M2 leak if available (Watchtower Hardening)
@@ -196,7 +196,7 @@ class DashboardService:
         delta_issued = 0.0
         delta_destroyed = 0.0
 
-        gov = state.governments[0] if state.governments else None
+        gov = state.government
 
         if gov and hasattr(gov, "monetary_ledger"):
             ledger = gov.monetary_ledger
diff --git a/simulation/orchestration/tick_orchestrator.py b/simulation/orchestration/tick_orchestrator.py
index 0883af3a..e1892cc0 100644
--- a/simulation/orchestration/tick_orchestrator.py
+++ b/simulation/orchestration/tick_orchestrator.py
@@ -145,7 +145,7 @@ class TickOrchestrator:
             agents=state.agents,
             markets=state.markets,
             primary_government=state.government, # Renamed to primary_government
-            governments=state.governments, # TD-ARCH-GOV-MISMATCH: Populate list
+            governments=[state.government] if state.government else [], # TD-ARCH-GOV-MISMATCH: Populate list
             bank=state.bank,
             central_bank=state.central_bank,
             escrow_agent=getattr(state, "escrow_agent", None),
diff --git a/simulation/world_state.py b/simulation/world_state.py
index bceb4e55..85f5efdc 100644
--- a/simulation/world_state.py
+++ b/simulation/world_state.py
@@ -79,7 +79,7 @@ class WorldState:
         self.next_agent_id: int = 0
         self.markets: Dict[str, Market] = {}
         self.bank: Optional[Bank] = None
-        self.governments: List[Government] = [] # Changed for Phase 33
+        self.government: Optional[Government] = None
         self.central_bank: Optional[CentralBank] = None
         self.stock_market: Optional[StockMarket] = None
         self.tracker: Optional[EconomicIndicatorTracker] = None
@@ -154,27 +154,6 @@ class WorldState:
 
         self.baseline_money_supply: float = 0.0
 
-    @property
-    def government(self) -> Optional[Government]:
-        """
-        Proxy property to access the primary government agent.
-        Resolves the singleton mismatch by delegating to self.governments[0].
-        """
-        if self.governments:
-            return self.governments[0]
-        return None
-
-    @government.setter
-    def government(self, value: Government) -> None:
-        """
-        Setter for the government property.
-        Ensures synchronization with self.governments list (SSoT).
-        """
-        if not self.governments:
-            self.governments.append(value)
-        else:
-            self.governments[0] = value
-
     def calculate_base_money(self) -> Dict[CurrencyCode, int]:
         """
         Calculates M0 (Base Money) for each currency.
@@ -262,7 +241,7 @@ class WorldState:
         """
         if role == "GOVERNMENT":
             self.logger.warning("Call to deprecated method WorldState.resolve_agent_id('GOVERNMENT')")
-            return AgentID(self.governments[0].id) if self.governments else None
+            return AgentID(self.government.id) if self.government else None
         elif role == "CENTRAL_BANK":
             return AgentID(self.central_bank.id) if self.central_bank else None
         return None
diff --git a/tests/integration/test_lifecycle_cycle.py b/tests/integration/test_lifecycle_cycle.py
index fa8ad86a..1b41219e 100644
--- a/tests/integration/test_lifecycle_cycle.py
+++ b/tests/integration/test_lifecycle_cycle.py
@@ -30,7 +30,6 @@ class TestLifecycleCycle:
 
         state.primary_government = MagicMock()
         state.government = state.primary_government # Backwards compatibility
-        state.governments = [state.primary_government] # Align DTO
         state.lifecycle_manager = MagicMock()
         state.transaction_processor = MagicMock()
 
diff --git a/tests/integration/test_tick_normalization.py b/tests/integration/test_tick_normalization.py
index 457f0c1c..e2c345b3 100644
--- a/tests/integration/test_tick_normalization.py
+++ b/tests/integration/test_tick_normalization.py
@@ -65,7 +65,6 @@ class TestTickNormalization:
         state.god_command_queue = deque()
         state.system_commands = []
         state.command_queue = MagicMock()
-        state.governments = [state.government] # Align DTO
         state.command_queue.empty.return_value = True
 
         # Systems
diff --git a/tests/modules/governance/test_cockpit_flow.py b/tests/modules/governance/test_cockpit_flow.py
index 68222809..347b1c18 100644
--- a/tests/modules/governance/test_cockpit_flow.py
+++ b/tests/modules/governance/test_cockpit_flow.py
@@ -51,7 +51,6 @@ def test_cockpit_command_flow_tax_rate(mock_deps):
     sim.world_state.government = MagicMock(spec=Government)
     sim.world_state.government.corporate_tax_rate = 0.2
     sim.world_state.government.income_tax_rate = 0.1
-    sim.world_state.governments = [sim.world_state.government] # Align DTO
 
     # Use spec=FiscalPolicyDTO for nested object
     sim.world_state.government.fiscal_policy = MagicMock(spec=FiscalPolicyDTO)
diff --git a/tests/system/test_engine.py b/tests/system/test_engine.py
index 2a819bc9..bd7086a7 100644
--- a/tests/system/test_engine.py
+++ b/tests/system/test_engine.py
@@ -802,7 +802,7 @@ def test_handle_agent_lifecycle_removes_inactive_agents(setup_simulation_for_lif
         agents=sim.agents,
         markets=sim.markets,
         primary_government=sim.government, # Renamed
-        governments=sim.governments, # Added for TD-ARCH-GOV-MISMATCH
+        governments=[sim.government] if sim.government else [], # Added for TD-ARCH-GOV-MISMATCH
         bank=sim.bank,
         central_bank=sim.central_bank, # Direct access
         escrow_agent=getattr(sim, 'escrow_agent', None), # Keep getattr for optional/dynamic
diff --git a/tests/test_firm_surgical_separation.py b/tests/test_firm_surgical_separation.py
new file mode 100644
index 00000000..3ccb065f
--- /dev/null
+++ b/tests/test_firm_surgical_separation.py
@@ -0,0 +1,198 @@
+import pytest
+from unittest.mock import MagicMock, patch
+from simulation.firms import Firm
+from modules.firm.api import (
+    FinanceDecisionInputDTO, BudgetPlanDTO,
+    HRDecisionInputDTO, HRDecisionOutputDTO,
+    FirmSnapshotDTO
+)
+from simulation.models import Order
+from simulation.dtos import DecisionInputDTO
+from modules.simulation.dtos.api import FirmConfigDTO
+
+class TestFirmSurgicalSeparation:
+
+    @pytest.fixture
+    def mock_firm(self):
+        # Create a Firm with mocked engines
+        mock_core_config = MagicMock()
+        mock_core_config.id = 1
+        mock_core_config.name = "TestFirm"
+        mock_core_config.initial_needs = {}
+
+        mock_decision_engine = MagicMock()
+        mock_config_dto = MagicMock(spec=FirmConfigDTO)
+        # Populate required fields
+        mock_config_dto.firm_min_production_target = 10.0
+        mock_config_dto.ipo_initial_shares = 1000
+        mock_config_dto.dividend_rate = 0.1
+        mock_config_dto.profit_history_ticks = 10
+        mock_config_dto.default_unit_cost = 10
+
+        firm = Firm(
+            core_config=mock_core_config,
+            engine=mock_decision_engine,
+            specialization="food",
+            productivity_factor=1.0,
+            config_dto=mock_config_dto
+        )
+
+        # Inject Mock Engines
+        firm.finance_engine = MagicMock()
+        firm.hr_engine = MagicMock()
+        firm.production_engine = MagicMock()
+        firm.sales_engine = MagicMock()
+        firm.pricing_engine = MagicMock()
+        firm.asset_management_engine = MagicMock()
+        firm.rd_engine = MagicMock()
+        firm.brand_engine = MagicMock()
+
+        firm.action_executor = MagicMock() # Mock execute_internal_orders delegate
+
+        # Ensure execute_internal_orders delegates to action_executor or we mock execute_internal_orders directly
+        firm.execute_internal_orders = MagicMock()
+
+        return firm
+
+    def test_make_decision_orchestrates_engines(self, mock_firm):
+        # Setup Inputs
+        input_dto = MagicMock(spec=DecisionInputDTO)
+        input_dto.current_time = 10
+        input_dto.market_snapshot = MagicMock()
+        # Ensure market_signals is empty or safe
+        input_dto.market_snapshot.market_signals = {}
+
+        # Mock labor market stats to allow comparison
+        # MagicMock > 0 fails, so we need to set avg_wage to a real number
+        input_dto.market_snapshot.labor = MagicMock()
+        input_dto.market_snapshot.labor.avg_wage = 10.0
+
+        input_dto.goods_data = []
+        input_dto.market_data = {}
+
+        # Setup Engine Returns
+        mock_budget = MagicMock(spec=BudgetPlanDTO)
+        mock_budget.labor_budget_pennies = 10000
+        mock_firm.finance_engine.plan_budget.return_value = mock_budget
+
+        mock_hr_result = MagicMock(spec=HRDecisionOutputDTO)
+        engine_order = Order(
+            agent_id=1, side="BUY", item_id="labor", quantity=1,
+            price_pennies=1000, market_id="labor",
+            price_limit=10.0
+        )
+        mock_hr_result.hiring_orders = [engine_order]
+        mock_firm.hr_engine.manage_workforce.return_value = mock_hr_result
+
+        # Configure Pricing Engine Mock (called in _calculate_invisible_hand_price)
+        mock_pricing_result = MagicMock()
+        mock_pricing_result.new_price = 1000
+        mock_pricing_result.shadow_price = 1000.0
+        mock_pricing_result.demand = 0.0
+        mock_pricing_result.supply = 0.0
+        mock_pricing_result.excess_demand_ratio = 0.0
+        mock_firm.pricing_engine.calculate_price.return_value = mock_pricing_result
+
+        # Setup Legacy Decision Engine Return
+        legacy_order_keep = Order(
+            agent_id=1, side="SELL", item_id="food", quantity=10,
+            price_pennies=2000, market_id="food",
+            price_limit=20.0
+        )
+        legacy_order_ignore = Order(
+            agent_id=1, side="BUY", item_id="labor", quantity=5, # Should be filtered
+            price_pennies=1000, market_id="labor",
+            price_limit=10.0
+        )
+        mock_firm.decision_engine.make_decisions.return_value = ([legacy_order_keep, legacy_order_ignore], "TACTIC")
+
+        # Act
+        external_orders, tactic = mock_firm.make_decision(input_dto)
+
+        # Assert: Finance Engine called
+        assert mock_firm.finance_engine.plan_budget.called
+        call_args_fin = mock_firm.finance_engine.plan_budget.call_args[0][0]
+        assert isinstance(call_args_fin, FinanceDecisionInputDTO)
+        assert call_args_fin.current_tick == 10
+
+        # Assert: HR Engine called
+        assert mock_firm.hr_engine.manage_workforce.called
+        call_args_hr = mock_firm.hr_engine.manage_workforce.call_args[0][0]
+        assert isinstance(call_args_hr, HRDecisionInputDTO)
+        assert call_args_hr.budget_plan == mock_budget
+
+        # Assert: Orders Merged and Filtered
+        # external_orders should contain engine_order and legacy_order_keep, but NOT legacy_order_ignore
+        assert len(external_orders) == 2
+        assert engine_order in external_orders
+        assert legacy_order_keep in external_orders
+        assert legacy_order_ignore not in external_orders
+
+        # Assert: Internal execution called
+        mock_firm.execute_internal_orders.assert_called_once()
+        executed_orders = mock_firm.execute_internal_orders.call_args[0][0]
+        assert len(executed_orders) == 2 # Same list passed to internal executor (it filters internally if needed)
+
+    def test_state_persistence_across_ticks(self, mock_firm):
+        """
+        Verify that Firm updates its internal state based on previous actions,
+        simulating persistence across ticks.
+        """
+        # 1. Initial State
+        mock_firm.hr_state.employees = []
+        mock_firm.hr_state.employee_wages = {}
+
+        # 2. Simulate HR Engine returning a wage update (as if from firing or negotiation)
+        # Note: In the current refactor, HREngine returns orders (hire/fire) and wage updates.
+        # But 'finalize_firing' and 'hire' are executed by transaction handlers or internal execution.
+        # So we verify that IF an internal order is executed, state changes.
+
+        # Mock action executor to APPLY changes or we verify that Firm's logic applies them.
+        # Firm.make_decision calls execute_internal_orders.
+        # But for HR, hiring happens via Market (External). Firing is Internal.
+
+        # Test Case: Firing
+        fire_order = Order(
+            agent_id=1, side="FIRE", item_id="internal", quantity=1,
+            price_pennies=1000, market_id="internal", target_agent_id=101,
+            price_limit=10.0 # Added price_limit
+        )
+
+        # Inject employee to fire
+        employee_mock = MagicMock()
+        employee_mock.id = 101
+        mock_firm.hr_state.employees = [employee_mock]
+        mock_firm.hr_state.employee_wages = {101: 1000}
+
+        # Setup inputs
+        fiscal_context = MagicMock()
+        current_time = 10
+
+        # We need to use the real action_executor logic
+        from modules.firm.orchestrators.firm_action_executor import FirmActionExecutor
+        real_action_executor = FirmActionExecutor()
+
+        # Setup mocks for what FirmActionExecutor calls on the firm
+        mock_tx = MagicMock()
+        mock_tx.price = 1000
+        mock_tx.currency = "USD"
+        mock_firm.hr_engine.create_fire_transaction.return_value = mock_tx
+
+        # Mock Settlement System
+        mock_settlement = MagicMock()
+        mock_settlement.transfer.return_value = True
+        mock_firm.settlement_system = mock_settlement
+
+        # Execute using real executor directly (since mock_firm.execute_internal_orders is mocked in fixture)
+        real_action_executor.execute(mock_firm, [fire_order], fiscal_context, current_time)
+
+        # Assertions
+        # 1. create_fire_transaction called
+        mock_firm.hr_engine.create_fire_transaction.assert_called()
+
+        # 2. finalize_firing called
+        mock_firm.hr_engine.finalize_firing.assert_called_with(mock_firm.hr_state, 101)
+
+        # Since finalize_firing is a mock in engines, the state won't change automatically
+        # unless we set side_effect.
+        # But this confirms the Orchestrator (ActionExecutor) correctly delegated the Persistence/State Update step.
diff --git a/tests/test_ws.py b/tests/test_ws.py
index 99e78796..9d9b4832 100644
--- a/tests/test_ws.py
+++ b/tests/test_ws.py
@@ -33,7 +33,7 @@ def test_websocket_endpoint():
 
         # Government
         gov = MagicMock()
-        world_state.governments = [gov]
+        world_state.government = gov
         gov.gdp_history = [100.0, 105.0]
         gov.sensory_data.inflation_sma = 0.02
         gov.sensory_data.gdp_growth_sma = 0.05
diff --git a/tests/unit/modules/firm/test_engines.py b/tests/unit/modules/firm/test_engines.py
new file mode 100644
index 00000000..e0dbb5f5
--- /dev/null
+++ b/tests/unit/modules/firm/test_engines.py
@@ -0,0 +1,186 @@
+import pytest
+from unittest.mock import MagicMock
+from simulation.components.engines.finance_engine import FinanceEngine
+from simulation.components.engines.hr_engine import HREngine
+from modules.firm.api import (
+    FinanceDecisionInputDTO, HRDecisionInputDTO, BudgetPlanDTO,
+    FirmSnapshotDTO, FirmStrategy
+)
+from modules.simulation.dtos.api import FirmConfigDTO, FinanceStateDTO, HRStateDTO, ProductionStateDTO, SalesStateDTO
+from modules.system.api import DEFAULT_CURRENCY
+
+class TestFinanceEngine:
+    @pytest.fixture
+    def engine(self):
+        return FinanceEngine()
+
+    @pytest.fixture
+    def mock_input(self):
+        # Create full snapshot hierarchy
+        fin_state = MagicMock(spec=FinanceStateDTO)
+        fin_state.balance = {DEFAULT_CURRENCY: 100000}
+        fin_state.total_debt_pennies = 0
+        fin_state.profit_history = [5000]
+        fin_state.dividend_rate = 0.1
+
+        prod_state = MagicMock(spec=ProductionStateDTO)
+        sales_state = MagicMock(spec=SalesStateDTO)
+        hr_state = MagicMock(spec=HRStateDTO)
+
+        snapshot = MagicMock(spec=FirmSnapshotDTO)
+        snapshot.finance = fin_state
+        snapshot.production = prod_state
+        snapshot.sales = sales_state
+        snapshot.hr = hr_state
+        snapshot.strategy = FirmStrategy.PROFIT_MAXIMIZATION
+
+        config = MagicMock(spec=FirmConfigDTO)
+
+        return FinanceDecisionInputDTO(
+            firm_snapshot=snapshot,
+            market_snapshot=MagicMock(),
+            config=config,
+            current_tick=10,
+            credit_rating=0.0
+        )
+
+    def test_plan_budget_basics(self, engine, mock_input):
+        plan = engine.plan_budget(mock_input)
+
+        assert isinstance(plan, BudgetPlanDTO)
+        assert plan.total_budget_pennies == 100000
+        assert plan.is_solvent == True
+
+        # Check defaults logic
+        # 60% labor, 20% capital (ProfitMax), 10% marketing
+        assert plan.labor_budget_pennies == 60000
+        assert plan.capital_budget_pennies == 20000
+
+    def test_plan_budget_with_debt(self, engine, mock_input):
+        mock_input.firm_snapshot.finance.total_debt_pennies = 1000000
+
+        plan = engine.plan_budget(mock_input)
+
+        # 1% repayment = 10000
+        assert plan.debt_repayment_pennies == 10000
+        assert plan.total_budget_pennies == 100000 # Balance
+        # Available for ops = 90000
+
+        # 60% of 90000
+        assert plan.labor_budget_pennies == 54000
+
+    def test_plan_budget_returns_integers(self, engine, mock_input):
+        """Zero-Sum Boundary Check: Output must be quantized integer pennies."""
+        mock_input.firm_snapshot.finance.balance = {DEFAULT_CURRENCY: 100001} # Odd number
+
+        plan = engine.plan_budget(mock_input)
+
+        assert isinstance(plan.total_budget_pennies, int)
+        assert isinstance(plan.labor_budget_pennies, int)
+        assert isinstance(plan.capital_budget_pennies, int)
+        assert isinstance(plan.marketing_budget_pennies, int)
+        assert isinstance(plan.dividend_payout_pennies, int)
+        assert isinstance(plan.debt_repayment_pennies, int)
+
+class TestHREngine:
+    @pytest.fixture
+    def engine(self):
+        return HREngine()
+
+    @pytest.fixture
+    def mock_input(self):
+        # Config
+        config = MagicMock(spec=FirmConfigDTO)
+        config.firm_min_employees = 1
+        config.firm_max_employees = 100
+        config.severance_pay_weeks = 2
+        config.halo_effect = 0.0
+
+        # State
+        prod_state = MagicMock(spec=ProductionStateDTO)
+        prod_state.specialization = "food"
+        prod_state.production_target = 100
+        prod_state.inventory = {"food": 0}
+        prod_state.productivity_factor = 10.0
+        # Needed labor = 100 / 10 = 10
+
+        hr_state = MagicMock(spec=HRStateDTO)
+        hr_state.employees = [1, 2, 3, 4, 5] # 5 employees
+        hr_state.employees_data = {
+            1: {"wage": 1000, "skill": 1.0},
+            2: {"wage": 1000, "skill": 1.0},
+            3: {"wage": 1000, "skill": 1.0},
+            4: {"wage": 1000, "skill": 1.0},
+            5: {"wage": 1000, "skill": 1.0},
+        }
+
+        fin_state = MagicMock(spec=FinanceStateDTO)
+        fin_state.profit_history = [10000]
+
+        snapshot = MagicMock(spec=FirmSnapshotDTO)
+        snapshot.finance = fin_state
+        snapshot.production = prod_state
+        snapshot.hr = hr_state
+        snapshot.id = 999
+
+        budget = MagicMock(spec=BudgetPlanDTO)
+        budget.labor_budget_pennies = 100000 # Plenty
+
+        return HRDecisionInputDTO(
+            firm_snapshot=snapshot,
+            budget_plan=budget,
+            market_snapshot=MagicMock(),
+            config=config,
+            current_tick=10,
+            labor_market_avg_wage=1000
+        )
+
+    def test_manage_workforce_hiring(self, engine, mock_input):
+        # Target = 10, Current = 5 -> Hire 5
+        result = engine.manage_workforce(mock_input)
+
+        assert len(result.hiring_orders) == 1
+        order = result.hiring_orders[0]
+        assert order.side == "BUY"
+        assert order.quantity == 5.0
+        assert order.market_id == "labor"
+
+    def test_manage_workforce_firing(self, engine, mock_input):
+        # Target = 2, Current = 5 -> Fire 3
+        mock_input.firm_snapshot.production.production_target = 20
+        # Needed = 20 / 10 = 2
+
+        result = engine.manage_workforce(mock_input)
+
+        assert len(result.hiring_orders) == 3 # Firing orders are returned in hiring_orders list (as orders)
+        assert result.hiring_orders[0].side == "FIRE"
+        assert len(result.firing_ids) == 3
+
+    def test_manage_workforce_wage_scaling(self, engine, mock_input):
+        """
+        Verify that the offered wage scales with the market average wage.
+        This confirms the fix for 'Logic & Spec Gaps: Disconnected Wage Logic'.
+        """
+        # Set market wage to 2000 (Non-default)
+        # Mock input is a frozen dataclass, so we must replace it (or create new)
+        # Actually HREngine uses input_dto.labor_market_avg_wage
+
+        from dataclasses import replace
+        new_input = replace(mock_input, labor_market_avg_wage=2000)
+
+        # Ensure we need to hire
+        new_input.firm_snapshot.production.production_target = 100 # Need 10, have 5
+
+        result = engine.manage_workforce(new_input)
+
+        assert len(result.hiring_orders) == 1
+        order = result.hiring_orders[0]
+
+        # Base wage 2000.
+        # Profit premium calculation: avg_profit=10000.
+        # profit_based_premium = 10000 / (2000 * 10) = 0.5
+        # wage_premium = min(0.5 * 0.1, 2.0) = 0.05
+        # offered = 2000 * 1.05 = 2100
+
+        assert order.price_pennies == 2100
+        assert order.price_limit == 21.0
diff --git a/tests/unit/test_government_structure.py b/tests/unit/test_government_structure.py
index fd22e625..5990da01 100644
--- a/tests/unit/test_government_structure.py
+++ b/tests/unit/test_government_structure.py
@@ -6,8 +6,8 @@ from simulation.engine import Simulation
 from modules.common.config_manager.api import ConfigManager
 
 class TestGovernmentStructure:
-    def test_government_property_proxy(self):
-        """Verify that WorldState.government property proxies to governments[0]."""
+    def test_government_singleton(self):
+        """Verify that WorldState.government is a direct attribute."""
         # Setup WorldState
         mock_config_manager = MagicMock(spec=ConfigManager)
         mock_logger = MagicMock()
@@ -15,50 +15,21 @@ class TestGovernmentStructure:
 
         ws = WorldState(mock_config_manager, None, mock_logger, mock_repo)
 
-        # Initially empty
+        # Initially None
         assert ws.government is None
-        assert ws.governments == []
+        # assert hasattr(ws, 'governments') is False # Verify removal
 
         # Create a mock Government
         mock_gov = MagicMock(spec=Government)
         mock_gov.id = 1
 
-        # Append directly
-        ws.governments.append(mock_gov)
+        # Set directly
+        ws.government = mock_gov
 
-        # Verify property access
+        # Verify access
         assert ws.government is mock_gov
         assert ws.government.id == 1
 
-    def test_government_setter_sync(self):
-        """Verify that setting WorldState.government updates governments list."""
-        # Setup WorldState
-        mock_config_manager = MagicMock(spec=ConfigManager)
-        mock_logger = MagicMock()
-        mock_repo = MagicMock()
-
-        ws = WorldState(mock_config_manager, None, mock_logger, mock_repo)
-
-        mock_gov1 = MagicMock(spec=Government)
-        mock_gov1.id = 101
-
-        # Set via property
-        ws.government = mock_gov1
-
-        assert len(ws.governments) == 1
-        assert ws.governments[0] is mock_gov1
-        assert ws.government is mock_gov1
-
-        # Replace via property
-        mock_gov2 = MagicMock(spec=Government)
-        mock_gov2.id = 102
-
-        ws.government = mock_gov2
-
-        assert len(ws.governments) == 1
-        assert ws.governments[0] is mock_gov2
-        assert ws.government is mock_gov2
-
     def test_simulation_delegation(self):
         """Verify that Simulation delegates government access to WorldState."""
         # Mock dependencies for Simulation
@@ -87,11 +58,8 @@ class TestGovernmentStructure:
         # Setup Mock Government
         mock_gov = MagicMock(spec=Government)
 
-        # Set via Simulation (delegates to WorldState setter)
+        # Set via Simulation (delegates to WorldState setter/attribute)
         sim.government = mock_gov
 
-        assert sim.world_state.governments[0] is mock_gov
+        assert sim.world_state.government is mock_gov
         assert sim.government is mock_gov
-
-        # Verify list integrity
-        assert len(sim.world_state.governments) == 1
