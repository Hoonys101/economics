diff --git a/communications/insights/TD-187_LIQUIDATION_REFACTOR.md b/communications/insights/TD-187_LIQUIDATION_REFACTOR.md
new file mode 100644
index 0000000..abf14fe
--- /dev/null
+++ b/communications/insights/TD-187_LIQUIDATION_REFACTOR.md
@@ -0,0 +1,38 @@
+# Mission Insight Report: TD-187 Liquidation Logic Refactor
+
+## Overview
+Refactored `LiquidationManager` to extract hardcoded inventory liquidation logic into `InventoryLiquidationHandler`. This aligns with the SRP and allows for future extension of liquidation logic for other asset types (e.g., Capital Stock, Financial Assets).
+
+## Technical Debt & Observations
+
+### 1. Conflicting Liquidation Logic in `Firm`
+During exploration, I found `Firm.liquidate_assets` in `simulation/firms.py`:
+```python
+    def liquidate_assets(self, current_tick: int = -1) -> float:
+        """
+        Liquidate assets.
+        CRITICAL FIX (WO-018): Inventory and Capital Stock are written off to zero
+        instead of being converted to cash, to prevent money creation from thin air.
+        Only existing cash (assets) is returned.
+        """
+        # 1. Write off Inventory
+        self.inventory.clear()
+        # ...
+```
+This method essentially destroys assets, whereas `LiquidationManager` attempts to sell them to the System Treasury (`PublicManager`). There is ambiguity about when each is used. If `LiquidationManager` runs, it sells inventory. If `Firm.liquidate_assets` is called independently (e.g., in some other bankruptcy flow), assets are destroyed. We should unify this behavior.
+
+### 2. Handler Injection
+Currently, `InventoryLiquidationHandler` is instantiated directly inside `LiquidationManager.__init__`.
+```python
+        if self.public_manager:
+            self.handlers.append(InventoryLiquidationHandler(self.settlement_system, self.public_manager))
+```
+While this works for now, it creates a coupling. In the future, we might want to inject a list of handlers or a `LiquidationHandlerFactory` to allow for more flexible configuration (e.g., enabling/disabling specific asset liquidations via config).
+
+### 3. Read-Only Dict Mocking in Tests
+Encountered an issue where `dict.clear` cannot be mocked directly because it is read-only. Solved by verifying the state of the dictionary (empty vs non-empty) rather than asserting the `clear` method was called.
+
+## Outcome
+- Created `simulation/systems/liquidation_handlers.py`.
+- Refactored `LiquidationManager` to iterate over handlers.
+- Added comprehensive unit tests for the new handler and updated manager tests.
diff --git a/simulation/systems/liquidation_handlers.py b/simulation/systems/liquidation_handlers.py
new file mode 100644
index 0000000..6b189be
--- /dev/null
+++ b/simulation/systems/liquidation_handlers.py
@@ -0,0 +1,95 @@
+from abc import ABC, abstractmethod
+from typing import TYPE_CHECKING, Dict, Any, Optional
+import logging
+from modules.system.api import DEFAULT_CURRENCY
+
+if TYPE_CHECKING:
+    from simulation.firms import Firm
+    from simulation.dtos.api import SimulationState
+    from simulation.finance.api import ISettlementSystem
+    from modules.system.api import IAssetRecoverySystem
+
+logger = logging.getLogger(__name__)
+
+class ILiquidationHandler(ABC):
+    """
+    Interface for asset-specific liquidation logic.
+    """
+    @abstractmethod
+    def liquidate(self, firm: 'Firm', state: 'SimulationState') -> None:
+        """
+        Liquidates specific assets of the firm to generate cash.
+        """
+        pass
+
+class InventoryLiquidationHandler(ILiquidationHandler):
+    """
+    Liquidates firm inventory by selling to PublicManager.
+    """
+    def __init__(self, settlement_system: 'ISettlementSystem', public_manager: 'IAssetRecoverySystem'):
+        self.settlement_system = settlement_system
+        self.public_manager = public_manager
+
+    def liquidate(self, firm: 'Firm', state: 'SimulationState') -> None:
+        """
+        Liquidates non-cash assets (Inventory) by selling them to the PublicManager.
+        This prevents the 'Asset-Rich Cash-Poor' leak.
+        """
+        if not self.public_manager:
+            return
+
+        # Calculate Total Value
+        total_value = 0.0
+
+        # Use last prices or default config price from firm's config
+        # Default price fallback: 10.0 if not found in config
+        default_price = 10.0
+        if firm.config and hasattr(firm.config, "goods_initial_price") and isinstance(firm.config.goods_initial_price, dict):
+             default_price = firm.config.goods_initial_price.get("default", 10.0)
+
+        # Configurable Haircut (Default 20%)
+        haircut = getattr(firm.config, "liquidation_haircut", 0.2)
+
+        inventory_transfer = {}
+        # Iterate over a copy to allow modification if needed (though we only read keys/values here)
+        # firm.inventory is a dict
+        for item_id, qty in firm.inventory.items():
+            if qty <= 0:
+                continue
+
+            # Determine fair value
+            price = firm.last_prices.get(item_id, 0.0)
+            if price <= 0:
+                # Fallback to configured initial price if available
+                if firm.config and hasattr(firm.config, "goods") and isinstance(firm.config.goods, dict):
+                     price = firm.config.goods.get(item_id, {}).get("initial_price", default_price)
+                else:
+                     price = default_price
+
+            # Apply Liquidation Discount (Haircut)
+            liquidation_value = price * qty * (1.0 - haircut)
+            total_value += liquidation_value
+            inventory_transfer[item_id] = qty
+
+        if total_value > 0:
+            # Transfer Funds: PublicManager -> Firm
+            # Note: PublicManager must implement IFinancialEntity to be a sender in SettlementSystem
+            # and it must have funds (System Treasury).
+            success = self.settlement_system.transfer(
+                self.public_manager,
+                firm,
+                total_value,
+                f"Asset Liquidation (Inventory) - Firm {firm.id}",
+                currency=DEFAULT_CURRENCY
+            )
+
+            if success:
+                logger.info(f"LIQUIDATION_ASSET_SALE | Firm {firm.id} sold inventory to PublicManager for {total_value:.2f}.")
+
+                # Transfer Inventory via Interface (Encapsulation)
+                self.public_manager.receive_liquidated_assets(inventory_transfer)
+
+                # Clear Firm Inventory
+                firm.inventory.clear()
+            else:
+                logger.error(f"LIQUIDATION_ASSET_SALE_FAIL | PublicManager failed to pay {total_value:.2f} to Firm {firm.id}.")
diff --git a/simulation/systems/liquidation_manager.py b/simulation/systems/liquidation_manager.py
index 712edc3..0d24510 100644
--- a/simulation/systems/liquidation_manager.py
+++ b/simulation/systems/liquidation_manager.py
@@ -3,6 +3,7 @@ from typing import List, TYPE_CHECKING, Optional, Any
 import logging
 from modules.common.dtos import Claim
 from modules.system.api import DEFAULT_CURRENCY
+from simulation.systems.liquidation_handlers import InventoryLiquidationHandler, ILiquidationHandler
 
 if TYPE_CHECKING:
     from simulation.firms import Firm
@@ -33,6 +34,10 @@ class LiquidationManager:
         self.agent_registry = agent_registry
         self.public_manager = public_manager
 
+        self.handlers: List[ILiquidationHandler] = []
+        if self.public_manager:
+            self.handlers.append(InventoryLiquidationHandler(self.settlement_system, self.public_manager))
+
     def initiate_liquidation(self, firm: Firm, state: SimulationState) -> None:
         """
         Executes the liquidation waterfall.
@@ -44,9 +49,9 @@ class LiquidationManager:
         current_tick = state.time
 
         # 0. Asset Liquidation (TD-187-LEAK Fix)
-        # If public_manager is available, liquidate assets to generate cash.
-        if self.public_manager:
-            self._liquidate_assets(firm, state)
+        # Use registered handlers to liquidate assets.
+        for handler in self.handlers:
+            handler.liquidate(firm, state)
 
         # Re-fetch cash after liquidation
         available_cash_raw = firm.finance.balance
@@ -89,68 +94,6 @@ class LiquidationManager:
         # 4. Execute Waterfall
         self.execute_waterfall(firm, all_claims, available_cash, state)
 
-    def _liquidate_assets(self, firm: Firm, state: SimulationState):
-        """
-        Liquidates non-cash assets (Inventory) by selling them to the PublicManager.
-        This prevents the 'Asset-Rich Cash-Poor' leak.
-        """
-        if not self.public_manager:
-            return
-
-        # Calculate Total Value
-        total_value = 0.0
-
-        # Use last prices or default config price from firm's config
-        # Default price fallback: 10.0 if not found in config
-        default_price = 10.0
-        if firm.config and hasattr(firm.config, "goods_initial_price") and isinstance(firm.config.goods_initial_price, dict):
-             default_price = firm.config.goods_initial_price.get("default", 10.0)
-
-        # Configurable Haircut (Default 20%)
-        haircut = getattr(firm.config, "liquidation_haircut", 0.2)
-
-        inventory_transfer = {}
-        for item_id, qty in firm.inventory.items():
-            if qty <= 0:
-                continue
-
-            # Determine fair value
-            price = firm.last_prices.get(item_id, 0.0)
-            if price <= 0:
-                # Fallback to configured initial price if available
-                if firm.config and hasattr(firm.config, "goods") and isinstance(firm.config.goods, dict):
-                     price = firm.config.goods.get(item_id, {}).get("initial_price", default_price)
-                else:
-                     price = default_price
-
-            # Apply Liquidation Discount (Haircut)
-            liquidation_value = price * qty * (1.0 - haircut)
-            total_value += liquidation_value
-            inventory_transfer[item_id] = qty
-
-        if total_value > 0:
-            # Transfer Funds: PublicManager -> Firm
-            # Note: PublicManager must implement IFinancialEntity to be a sender in SettlementSystem
-            # and it must have funds (System Treasury).
-            success = self.settlement_system.transfer(
-                self.public_manager,
-                firm,
-                total_value,
-                f"Asset Liquidation (Inventory) - Firm {firm.id}",
-                currency=DEFAULT_CURRENCY
-            )
-
-            if success:
-                logger.info(f"LIQUIDATION_ASSET_SALE | Firm {firm.id} sold inventory to PublicManager for {total_value:.2f}.")
-
-                # Transfer Inventory via Interface (Encapsulation)
-                self.public_manager.receive_liquidated_assets(inventory_transfer)
-
-                # Clear Firm Inventory
-                firm.inventory.clear()
-            else:
-                logger.error(f"LIQUIDATION_ASSET_SALE_FAIL | PublicManager failed to pay {total_value:.2f} to Firm {firm.id}.")
-
     def execute_waterfall(self, firm: Firm, claims: List[Claim], available_cash: float, state: SimulationState) -> None:
         """
         Distributes cash according to tiers.
diff --git a/tests/unit/systems/handlers/test_liquidation_handlers.py b/tests/unit/systems/handlers/test_liquidation_handlers.py
new file mode 100644
index 0000000..e645493
--- /dev/null
+++ b/tests/unit/systems/handlers/test_liquidation_handlers.py
@@ -0,0 +1,83 @@
+import unittest
+from unittest.mock import MagicMock
+from simulation.systems.liquidation_handlers import InventoryLiquidationHandler
+from modules.system.api import DEFAULT_CURRENCY
+from simulation.dtos.api import SimulationState
+
+class TestInventoryLiquidationHandler(unittest.TestCase):
+    def setUp(self):
+        self.mock_settlement = MagicMock()
+        self.mock_public = MagicMock()
+        self.handler = InventoryLiquidationHandler(self.mock_settlement, self.mock_public)
+        self.firm = MagicMock()
+        self.firm.id = 1
+        self.firm.config = MagicMock()
+        self.firm.config.liquidation_haircut = 0.2
+        self.firm.config.goods_initial_price = {"default": 10.0}
+        self.firm.config.goods = {}
+        self.firm.last_prices = {}
+        self.firm.inventory = {}
+        self.state = MagicMock(spec=SimulationState)
+
+    def test_liquidate_no_inventory(self):
+        self.firm.inventory = {}
+        self.handler.liquidate(self.firm, self.state)
+        self.mock_settlement.transfer.assert_not_called()
+
+    def test_liquidate_with_inventory(self):
+        self.firm.inventory = {"apple": 10}
+        self.firm.last_prices = {"apple": 5.0}
+
+        # 10 * 5.0 * (1 - 0.2) = 50 * 0.8 = 40.0
+
+        self.mock_settlement.transfer.return_value = True
+
+        self.handler.liquidate(self.firm, self.state)
+
+        self.mock_settlement.transfer.assert_called_once_with(
+            self.mock_public,
+            self.firm,
+            40.0,
+            "Asset Liquidation (Inventory) - Firm 1",
+            currency=DEFAULT_CURRENCY
+        )
+        self.mock_public.receive_liquidated_assets.assert_called_once_with({"apple": 10})
+        # Check inventory is cleared
+        self.assertEqual(self.firm.inventory, {})
+
+    def test_liquidate_fallback_price(self):
+        self.firm.inventory = {"unknown": 10}
+        self.firm.last_prices = {}
+        # default price 10.0
+        # 10 * 10.0 * 0.8 = 80.0
+
+        self.mock_settlement.transfer.return_value = True
+        self.handler.liquidate(self.firm, self.state)
+
+        self.mock_settlement.transfer.assert_called_once_with(
+            self.mock_public,
+            self.firm,
+            80.0,
+            "Asset Liquidation (Inventory) - Firm 1",
+            currency=DEFAULT_CURRENCY
+        )
+        self.assertEqual(self.firm.inventory, {})
+
+    def test_liquidate_payment_fail(self):
+        self.firm.inventory = {"apple": 10}
+        self.firm.last_prices = {"apple": 5.0}
+
+        self.mock_settlement.transfer.return_value = False
+
+        self.handler.liquidate(self.firm, self.state)
+
+        self.mock_settlement.transfer.assert_called_once()
+        self.mock_public.receive_liquidated_assets.assert_not_called()
+        # Inventory should NOT be cleared
+        self.assertEqual(self.firm.inventory, {"apple": 10})
+
+    def test_liquidate_no_public_manager(self):
+        handler = InventoryLiquidationHandler(self.mock_settlement, None)
+        self.firm.inventory = {"apple": 10}
+        handler.liquidate(self.firm, self.state)
+        self.mock_settlement.transfer.assert_not_called()
diff --git a/tests/unit/systems/test_liquidation_manager.py b/tests/unit/systems/test_liquidation_manager.py
index 26d64b7..029cca5 100644
--- a/tests/unit/systems/test_liquidation_manager.py
+++ b/tests/unit/systems/test_liquidation_manager.py
@@ -6,7 +6,7 @@ from simulation.systems.liquidation_manager import LiquidationManager
 from modules.common.dtos import Claim
 from simulation.firms import Firm
 from simulation.dtos.api import SimulationState
-from modules.system.api import IAssetRecoverySystem, IAgentRegistry
+from modules.system.api import IAssetRecoverySystem, IAgentRegistry, DEFAULT_CURRENCY
 from modules.hr.api import IHRService
 from modules.finance.api import ITaxService
 from simulation.finance.api import ISettlementSystem
@@ -71,8 +71,8 @@ class TestLiquidationManager(unittest.TestCase):
         # Verify Transfers
         # Expect transfers for both claims
         self.mock_settlement.transfer.assert_has_calls([
-            call(self.firm, agent_101, 100.0, "Liquidation Payout: Wage"),
-            call(self.firm, agent_gov, 50.0, "Liquidation Payout: Tax")
+            call(self.firm, agent_101, 100.0, "Liquidation Payout: Wage", currency=DEFAULT_CURRENCY),
+            call(self.firm, agent_gov, 50.0, "Liquidation Payout: Tax", currency=DEFAULT_CURRENCY)
         ], any_order=True)
 
     def test_bank_claim_handling(self):
@@ -93,5 +93,32 @@ class TestLiquidationManager(unittest.TestCase):
 
         # Check transfer to bank
         self.mock_settlement.transfer.assert_called_with(
-            self.firm, bank_agent, 500.0, "Liquidation Payout: Secured Loan"
+            self.firm, bank_agent, 500.0, "Liquidation Payout: Secured Loan", currency=DEFAULT_CURRENCY
         )
+
+    def test_asset_liquidation_integration(self):
+        # Setup Inventory
+        self.firm.inventory = {"apple": 10}
+        self.firm.last_prices = {"apple": 5.0}
+        self.firm.config.liquidation_haircut = 0.2
+        self.firm.config.goods_initial_price = {"default": 10.0}
+        self.firm.config.goods = {}
+
+        self.mock_settlement.transfer.return_value = True
+
+        self.manager.initiate_liquidation(self.firm, self.state)
+
+        # Check transfer for asset liquidation
+        # 10 * 5.0 * 0.8 = 40.0
+        self.mock_settlement.transfer.assert_any_call(
+            self.mock_public,
+            self.firm,
+            40.0,
+            "Asset Liquidation (Inventory) - Firm 1",
+            currency=DEFAULT_CURRENCY
+        )
+
+        # Also check receive_liquidated_assets
+        self.mock_public.receive_liquidated_assets.assert_called_with({"apple": 10})
+        # Check inventory is cleared
+        self.assertEqual(self.firm.inventory, {})
