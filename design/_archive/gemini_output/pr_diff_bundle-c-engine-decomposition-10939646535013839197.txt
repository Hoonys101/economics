diff --git a/communications/insights/Bundle_C.md b/communications/insights/Bundle_C.md
new file mode 100644
index 00000000..51f9060a
--- /dev/null
+++ b/communications/insights/Bundle_C.md
@@ -0,0 +1,41 @@
+# Bundle C Insights: System Integrity & Refactoring
+
+## Overview
+This bundle focused on decomposing the simulation engine, hardening the inheritance system, and cleaning up technical debt in DTOs and Commerce.
+
+## Key Changes
+
+### 1. Engine Decomposition (TD-238)
+The `simulation/orchestration/phases.py` monolith was successfully decomposed into granular phase handlers located in `simulation/orchestration/phases/`.
+- **Benefit**: Improved maintainability and testability of individual simulation phases.
+- **Structure**: Each phase (e.g., `Phase1_Decision`, `Phase_Production`) now resides in its own file.
+- **Backward Compatibility**: `simulation/orchestration/phases.py` now serves as a re-export module, preserving existing imports.
+
+### 2. Inheritance Atomicity (TD-232)
+The `InheritanceManager` was refactored to eliminate direct calls to `SettlementSystem`.
+- **Change**: `process_death` now generates `Transaction` objects for Tax, Inheritance Distribution, and Escheatment.
+- **Mechanism**: These transactions are dispatched via `TransactionProcessor`, ensuring they follow the standard transaction execution pipeline (Validation -> Execution -> Ledger).
+- **Zero Leak**: By using the processor, we ensure that all money movements are tracked and subject to system-wide invariants.
+
+### 3. Sales Tax Injection (TD-231)
+- **Fix**: `CommerceSystem` no longer relies on `self.config` lookup for `SALES_TAX_RATE`.
+- **Implementation**: The tax rate is now injected via `CommerceContext`, populated during the Decision phase. This decouples the system from global config state during execution and allows for dynamic tax policies in the future.
+
+### 4. DTO Cleanup (TD-225/223)
+- **Consolidation**: `LoanMarketSnapshotDTO` was consolidated into `modules/system/api.py` as a dataclass, adding `max_ltv` and `max_dti` fields.
+- **Removal**: The redundant `TypedDict` definition in `modules/market/housing_planner_api.py` was removed.
+
+## Technical Debt & Observations
+
+### Multi-Currency Liquidation
+- **Observation**: `Firm.liquidate_assets` currently returns only the `DEFAULT_CURRENCY` balance.
+- **Risk**: If a firm holds significant assets in foreign currencies, they are effectively "lost" (not distributed to creditors) during the write-off phase if not converted beforehand.
+- **Recommendation**: Future work should implement an auto-conversion mechanism (e.g., forced FX sell orders) in the `LiquidationManager` before the final write-off call, or update `liquidate_assets` to return a `MultiCurrencyWalletDTO`.
+
+### Inheritance Settlement Account
+- **Observation**: The refactor removed the explicit creation of a "Settlement Account" in `InheritanceManager`. Assets now remain on the deceased agent until the `TransactionProcessor` moves them.
+- **Implication**: This simplifies the flow but relies on the deceased agent not being "cleaned up" or interacting with the world between death processing and transaction execution (which is guaranteed by the sequential phase execution).
+
+### God Class Residue
+- **Status**: While `phases.py` is decomposed, `TickOrchestrator` (the consumer) likely still has high complexity.
+- **Next Step**: Consider refactoring `TickOrchestrator` to iterate over a list of `IPhaseStrategy` instances rather than hardcoding phase instantiation.
diff --git a/modules/market/housing_planner_api.py b/modules/market/housing_planner_api.py
index 86fe247e..4d19ccdd 100644
--- a/modules/market/housing_planner_api.py
+++ b/modules/market/housing_planner_api.py
@@ -4,17 +4,9 @@ from abc import ABC, abstractmethod
 # Import external DTOs
 # Note: Adjust imports based on actual file structure
 from modules.household.dtos import HouseholdSnapshotDTO
-from modules.system.api import HousingMarketSnapshotDTO
+from modules.system.api import HousingMarketSnapshotDTO, LoanMarketSnapshotDTO
 from modules.finance.api import MortgageApplicationDTO
 
-class LoanMarketSnapshotDTO(TypedDict):
-    """
-    Snapshot of the loan market conditions.
-    """
-    interest_rate: float
-    max_ltv: float
-    max_dti: float
-
 class HousingOfferRequestDTO(TypedDict):
     """
     Input for the HousingPlanner, containing all necessary state for a decision.
diff --git a/modules/system/api.py b/modules/system/api.py
index 2504cefb..e6a57e76 100644
--- a/modules/system/api.py
+++ b/modules/system/api.py
@@ -67,6 +67,8 @@ class HousingMarketSnapshotDTO:
 class LoanMarketSnapshotDTO:
     """Contains a snapshot of the loan market's state."""
     interest_rate: float
+    max_ltv: float = 0.8
+    max_dti: float = 0.43
 
 @dataclass(frozen=True)
 class LaborMarketSnapshotDTO:
diff --git a/simulation/components/finance_department.py b/simulation/components/finance_department.py
index 718b489e..7fbe6a3e 100644
--- a/simulation/components/finance_department.py
+++ b/simulation/components/finance_department.py
@@ -386,12 +386,14 @@ class FinanceDepartment(IFinanceDepartment):
             "wallet": wallet_dto,
             "total_assets_est": MoneyDTO(amount=total_assets, currency=DEFAULT_CURRENCY), # Approximate
             "working_capital_est": MoneyDTO(amount=total_assets - current_liabilities, currency=DEFAULT_CURRENCY),
-            "retained_earnings": MoneyDTO(amount=self.retained_earnings, currency=self.primary_currency),
-            "average_profit": MoneyDTO(amount=avg_profit, currency=self.primary_currency),
+            "retained_earnings_dto": MoneyDTO(amount=self.retained_earnings, currency=self.primary_currency),
+            "average_profit_dto": MoneyDTO(amount=avg_profit, currency=self.primary_currency),
             "total_debt": MoneyDTO(amount=current_liabilities, currency=DEFAULT_CURRENCY),
             # Legacy keys (float) if needed by other systems (optional but helpful)
             "total_assets": total_assets,
             "working_capital": total_assets - current_liabilities,
+            "retained_earnings": self.retained_earnings,
+            "average_profit": avg_profit,
         }
 
     def issue_shares(self, quantity: float, price: float) -> float:
diff --git a/simulation/orchestration/phases.py b/simulation/orchestration/phases.py
deleted file mode 100644
index 59ae4aee..00000000
--- a/simulation/orchestration/phases.py
+++ /dev/null
@@ -1,772 +0,0 @@
-from __future__ import annotations
-from typing import List, Dict, Any, Optional, Tuple, TYPE_CHECKING
-import logging
-
-from simulation.orchestration.api import IPhaseStrategy
-from simulation.dtos.api import (
-    SimulationState, MarketSnapshotDTO, GovernmentPolicyDTO,
-    DecisionContext, MacroFinancialContext, AIDecisionData,
-    DecisionInputDTO
-)
-from modules.government.dtos import MacroEconomicSnapshotDTO
-from simulation.dtos import (
-    GovernmentStateDTO, FiscalContext
-)
-from simulation.core_agents import Household
-from simulation.firms import Firm
-from simulation.markets.order_book_market import OrderBookMarket
-from simulation.systems.api import (
-    EventContext, SocialMobilityContext, SensoryContext,
-    CommerceContext, LearningUpdateContext
-)
-from simulation.models import Transaction, Order
-from modules.government.components.monetary_policy_manager import MonetaryPolicyManager
-from simulation.orchestration.utils import prepare_market_data
-from modules.government.proxy import GovernmentFiscalProxy
-
-# NEW
-from simulation.orchestration.factories import MarketSignalFactory, DecisionInputFactory, MarketSnapshotFactory
-
-
-if TYPE_CHECKING:
-    from simulation.world_state import WorldState
-    from simulation.action_processor import ActionProcessor
-    from simulation.metrics.economic_tracker import EconomicIndicatorTracker
-    from simulation.dtos.scenario import StressScenarioConfig
-
-logger = logging.getLogger(__name__)
-
-
-class Phase0_PreSequence(IPhaseStrategy):
-    def __init__(self, world_state: WorldState):
-        self.world_state = world_state
-        self.mp_manager = MonetaryPolicyManager(world_state.config_module)
-
-    def execute(self, state: SimulationState) -> SimulationState:
-        # WO-109: Pre-Sequence Stabilization
-        if state.bank and hasattr(state.bank, "generate_solvency_transactions"):
-            stabilization_txs = state.bank.generate_solvency_transactions(state.government)
-            if stabilization_txs:
-                state.transactions.extend(stabilization_txs)
-                state.logger.warning("STABILIZATION | Queued pre-sequence stabilization transactions.")
-
-        # AI Training
-        if state.ai_training_manager:
-            if state.time > 0 and state.time % state.config_module.IMITATION_LEARNING_INTERVAL == 0:
-                state.ai_training_manager.run_imitation_learning_cycle(state.time)
-
-        # --- WO-060 / Phase 17 Logic (Social & Gov) ---
-
-        # Update Stock Market Reference Prices
-        if state.stock_market:
-            active_firms = {f.id: f for f in state.firms if f.is_active}
-            state.stock_market.update_reference_prices(active_firms)
-
-        # Prepare Market Data (for Gov/Social)
-        market_data = prepare_market_data(state)
-
-        # Social Ranks
-        if getattr(state.config_module, "ENABLE_VANITY_SYSTEM", False) and self.world_state.social_system:
-            context: SocialMobilityContext = {
-                "households": state.households
-            }
-            self.world_state.social_system.update_social_ranks(context)
-            ref_std = self.world_state.social_system.calculate_reference_standard(context)
-            market_data["reference_standard"] = ref_std
-
-        # Government Public Opinion
-        if state.government:
-            state.government.update_public_opinion(state.households)
-
-        # Sensory System
-        sensory_context: SensoryContext = {
-            "tracker": state.tracker,
-            "government": state.government,
-            "time": state.time,
-            "inequality_tracker": self.world_state.inequality_tracker,
-            "households": state.households
-        }
-
-        sensory_dto = GovernmentStateDTO(state.time, 0, 0, 0, 0, 0, 0)
-        if self.world_state.sensory_system:
-            sensory_dto = self.world_state.sensory_system.generate_government_sensory_dto(sensory_context)
-        else:
-             state.logger.error("SensorySystem not initialized!")
-
-        if state.government:
-            if state.injectable_sensory_dto and state.injectable_sensory_dto.tick == state.time:
-                state.government.update_sensory_data(state.injectable_sensory_dto)
-                state.logger.warning(
-                    f"INJECTED_SENSORY_DATA | Overrode sensory data for tick {state.time} with custom DTO.",
-                    extra={"tick": state.time, "tags": ["test_injection"]}
-                )
-            else:
-                state.government.update_sensory_data(sensory_dto)
-
-            # Government Policy Decision
-            latest_gdp = state.tracker.get_latest_indicators().get("total_production", 0.0)
-            market_data["total_production"] = latest_gdp
-            state.government.make_policy_decision(market_data, state.time, state.central_bank)
-
-            state.government.check_election(state.time)
-
-        # WO-146: Monetary Policy Manager Integration
-        # Ensure Central Bank updates its internal state (Potential GDP)
-        if state.central_bank and hasattr(state.central_bank, "step"):
-             state.central_bank.step(state.time)
-
-        # Apply Monetary Policy periodically to ensure stability (WO-146 Insight)
-        update_interval = getattr(state.config_module, "CB_UPDATE_INTERVAL", 10)
-
-        if state.time > 0 and state.time % update_interval == 0:
-            # Create MacroEconomicSnapshotDTO with macro indicators
-            latest_indicators = state.tracker.get_latest_indicators()
-            # Retrieve potential GDP from Central Bank if available
-            potential_gdp = 0.0
-            if state.central_bank and hasattr(state.central_bank, "potential_gdp"):
-                 potential_gdp = state.central_bank.potential_gdp
-
-            macro_snapshot = MacroEconomicSnapshotDTO(
-                 inflation_rate=latest_indicators.get("inflation_rate", 0.0),
-                 unemployment_rate=latest_indicators.get("unemployment_rate", 0.0),
-                 nominal_gdp=latest_indicators.get("total_production", 0.0),
-                 potential_gdp=potential_gdp
-            )
-
-            mp_policy = self.mp_manager.determine_monetary_stance(macro_snapshot)
-
-            if state.central_bank:
-                 state.central_bank.base_rate = mp_policy.target_interest_rate
-
-            if state.bank and hasattr(state.bank, "update_base_rate"):
-                 state.bank.update_base_rate(mp_policy.target_interest_rate)
-
-        # Events (Moved to end to ensure shocks overwrite policy decisions)
-        if self.world_state.event_system:
-             context: EventContext = {
-                 "households": state.households,
-                 "firms": state.firms,
-                 "markets": state.markets,
-                 "government": state.government,
-                 "central_bank": state.central_bank,
-                 "bank": state.bank
-             }
-             self.world_state.event_system.execute_scheduled_events(state.time, context, self.world_state.stress_scenario_config)
-
-        return state
-
-
-class Phase_Production(IPhaseStrategy):
-    """
-    Phase 0.5: Technology update and firm production.
-    Ensures firms have updated inventory before the Decision phase.
-    """
-    def __init__(self, world_state: WorldState):
-        self.world_state = world_state
-
-    def execute(self, state: SimulationState) -> SimulationState:
-        from simulation.systems.tech.api import FirmTechInfoDTO, HouseholdEducationDTO
-
-        # 1. Calculate Human Capital Index
-        active_households_dto = [
-            HouseholdEducationDTO(is_active=h._bio_state.is_active, education_level=getattr(h, 'education_level', 0))
-            for h in state.households if h._bio_state.is_active
-        ]
-        
-        total_edu = sum(h['education_level'] for h in active_households_dto)
-        active_count = len(active_households_dto)
-        human_capital_index = total_edu / active_count if active_count > 0 else 1.0
-
-        # 2. Update Technology System
-        if self.world_state.technology_manager:
-            active_firms_dto = [
-                FirmTechInfoDTO(
-                    id=f.id,
-                    sector=f.sector,
-                    current_rd_investment=f.research_history.get("total_spent", 0.0) if hasattr(f, "research_history") else 0.0
-                )
-                for f in state.firms if f.is_active
-            ]
-            self.world_state.technology_manager.update(state.time, active_firms_dto, human_capital_index)
-
-        # 3. Trigger Firm Production
-        for firm in state.firms:
-            if firm.is_active:
-                firm.produce(state.time, technology_manager=self.world_state.technology_manager)
-
-        return state
-
-
-class Phase1_Decision(IPhaseStrategy):
-    def __init__(self, world_state: WorldState):
-        self.world_state = world_state
-        # TD-189: Use factories
-        self.input_factory = DecisionInputFactory()
-        self.snapshot_factory = MarketSnapshotFactory()
-
-    def execute(self, state: SimulationState) -> SimulationState:
-        # Snapshot agents for learning (Pre-state)
-        self._snapshot_agent_pre_states(state)
-
-        # Prepare Market Data
-        market_data = prepare_market_data(state)
-        state.market_data = market_data
-
-        # 1. Create Snapshot using the factory
-        market_snapshot = self.snapshot_factory.create_snapshot(state)
-
-        # 2. Create Base Input DTO using the factory
-        base_input_dto = self.input_factory.create_decision_input(state, self.world_state, market_snapshot)
-
-        # 3. Dispatch decisions
-        self._dispatch_firm_decisions(state, base_input_dto)
-        self._dispatch_household_decisions(state, base_input_dto)
-
-        # 4. Commerce Planning
-        self._plan_commerce(state, market_data)
-
-        return state
-
-    def _snapshot_agent_pre_states(self, state: SimulationState):
-        for f in state.firms:
-            if f.is_active: f.pre_state_snapshot = f.get_agent_data()
-        for h in state.households:
-            if h._bio_state.is_active: h.pre_state_snapshot = h.get_agent_data()
-
-    def _dispatch_firm_decisions(self, state: SimulationState, base_input_dto: DecisionInputDTO):
-        from dataclasses import replace
-        firm_pre_states = {}
-
-        for firm in state.firms:
-            if not firm.is_active: continue
-
-            if hasattr(firm.decision_engine, 'ai_engine') and firm.decision_engine.ai_engine:
-                pre_strategic_state = (
-                    firm.decision_engine.ai_engine._get_strategic_state(
-                        firm.get_agent_data(), state.market_data
-                    )
-                )
-                pre_tactical_state = firm.decision_engine.ai_engine._get_tactical_state(
-                    firm.decision_engine.ai_engine.chosen_intention,
-                    firm.get_agent_data(),
-                    state.market_data,
-                )
-                firm_pre_states[firm.id] = {
-                    "pre_strategic_state": pre_strategic_state,
-                    "pre_tactical_state": pre_tactical_state,
-                    "chosen_intention": firm.decision_engine.ai_engine.chosen_intention,
-                    "chosen_tactic": firm.decision_engine.ai_engine.last_chosen_tactic,
-                }
-
-            firm_input = replace(base_input_dto, stress_scenario_config=self.world_state.stress_scenario_config)
-            decision_output = firm.make_decision(firm_input)
-
-            if hasattr(decision_output, 'orders'):
-                firm_orders = decision_output.orders
-            else:
-                firm_orders, action_vector = decision_output
-
-            for order in firm_orders:
-                target_market = state.markets.get(order.market_id)
-                if target_market:
-                    new_txs = target_market.place_order(order, state.time)
-                    if new_txs:
-                        state.transactions.extend(new_txs)
-
-        state.firm_pre_states = firm_pre_states
-
-    def _dispatch_household_decisions(self, state: SimulationState, base_input_dto: DecisionInputDTO):
-        from dataclasses import replace
-        household_pre_states = {}
-        household_time_allocation = {}
-
-        for household in state.households:
-            if not household._bio_state.is_active: continue
-
-            if hasattr(household.decision_engine, 'ai_engine') and household.decision_engine.ai_engine:
-                pre_strategic_state = (
-                    household.decision_engine.ai_engine._get_strategic_state(
-                        household.get_agent_data(), state.market_data
-                    )
-                )
-                household_pre_states[household.id] = {
-                    "pre_strategic_state": pre_strategic_state,
-                }
-
-            household_input = replace(
-                base_input_dto,
-                stress_scenario_config=self.world_state.stress_scenario_config,
-                macro_context=base_input_dto.macro_context
-            )
-            decision_output = household.make_decision(household_input)
-
-            if hasattr(decision_output, 'orders'):
-                household_orders = decision_output.orders
-                metadata = decision_output.metadata
-                if hasattr(metadata, 'work_aggressiveness'):
-                     work_aggressiveness = metadata.work_aggressiveness
-                else:
-                     work_aggressiveness = 0.5
-            else:
-                household_orders, action_vector = decision_output
-                if hasattr(action_vector, 'work_aggressiveness'):
-                    work_aggressiveness = action_vector.work_aggressiveness
-                else:
-                    work_aggressiveness = 0.5
-
-            max_work_hours = state.config_module.MAX_WORK_HOURS
-            shopping_hours = getattr(state.config_module, "SHOPPING_HOURS", 2.0)
-            hours_per_tick = getattr(state.config_module, "HOURS_PER_TICK", 24.0)
-
-            work_hours = work_aggressiveness * max_work_hours
-            leisure_hours = max(0.0, hours_per_tick - work_hours - shopping_hours)
-            household_time_allocation[household.id] = leisure_hours
-
-            for order in household_orders:
-                self._process_household_order(state, household, order, state.market_data)
-
-        state.household_pre_states = household_pre_states
-        state.household_time_allocation = household_time_allocation
-
-    def _process_household_order(self, state: SimulationState, household: Household, order: Order, market_data: Dict[str, Any]):
-        # WO-053: Force deflationary pressure on basic_food
-        if hasattr(order, "item_id") and order.item_id == "basic_food" and order.side == "BUY":
-                deflationary_multiplier = getattr(state.config_module, "DEFLATIONARY_PRESSURE_MULTIPLIER", None)
-
-                if deflationary_multiplier is not None:
-                    current_price = market_data.get("basic_food_current_sell_price", 5.0)
-                    from dataclasses import replace
-                    new_price = min(order.price_limit, max(0.1, current_price * float(deflationary_multiplier)))
-                    order = replace(order, price_limit=new_price)
-
-        if order.side == "INVEST" and order.market_id == "admin":
-            if self.world_state.firm_system:
-                self.world_state.firm_system.spawn_firm(state, household)
-            else:
-                state.logger.warning(f"SKIPPED_INVESTMENT | Agent {household.id} tried startup but firm_system missing.")
-            return
-
-        target_market_id = self._get_redirected_market(order)
-        household_target_market = state.markets.get(target_market_id)
-
-        if household_target_market:
-            new_txs = household_target_market.place_order(order, state.time)
-            if new_txs:
-                state.transactions.extend(new_txs)
-
-    def _get_redirected_market(self, order: Order) -> str:
-        target_market_id = order.market_id
-        if order.side in ["DEPOSIT", "WITHDRAW", "LOAN_REQUEST", "REPAYMENT"]:
-            target_market_id = "loan_market"
-        elif hasattr(order, "item_id") and order.item_id in ["deposit", "currency"]:
-            target_market_id = "loan_market"
-        return target_market_id
-
-    def _plan_commerce(self, state: SimulationState, market_data: Dict[str, Any]):
-         # Commerce Planning
-        current_vacancies = 0
-        labor_market = state.markets.get("labor")
-        if labor_market and isinstance(labor_market, OrderBookMarket):
-             for item_orders in labor_market.buy_orders.values():
-                 for order in item_orders:
-                     current_vacancies += order.quantity
-
-        consumption_market_data = market_data.copy()
-        consumption_market_data["job_vacancies"] = current_vacancies
-
-        commerce_context: CommerceContext = {
-            "households": state.households,
-            "agents": state.agents,
-            "breeding_planner": self.world_state.breeding_planner,
-            "household_time_allocation": state.household_time_allocation,
-            "market_data": consumption_market_data,
-            "config": state.config_module,
-            "time": state.time,
-            "government": state.government
-        }
-
-        if self.world_state.commerce_system:
-            planned_cons, commerce_txs = self.world_state.commerce_system.plan_consumption_and_leisure(
-                commerce_context, self.world_state.stress_scenario_config
-            )
-            state.planned_consumption = planned_cons
-
-            for tx in commerce_txs:
-                if tx.transaction_type == "PHASE23_MARKET_ORDER":
-                     # WO-053: Convert special transaction to Order
-                     # Use new OrderDTO fields: side, price_limit
-                     order = Order(
-                         agent_id=tx.buyer_id,
-                         side="BUY",
-                         item_id=tx.item_id,
-                         quantity=tx.quantity,
-                         price_limit=tx.price,
-                         market_id=tx.item_id
-                     )
-                     market = state.markets.get(tx.item_id)
-                     if market:
-                         new_txs = market.place_order(order, state.time)
-                         if new_txs:
-                             state.transactions.extend(new_txs)
-                else:
-                     state.transactions.append(tx)
-
-        return state
-
-
-class Phase2_Matching(IPhaseStrategy):
-    def __init__(self, world_state: WorldState):
-        self.world_state = world_state
-
-    def execute(self, state: SimulationState) -> SimulationState:
-        matched_txs = []
-        for market in state.markets.values():
-            if isinstance(market, OrderBookMarket):
-                matched_txs.extend(market.match_orders(state.time))
-
-        if state.stock_market:
-            stock_txs = state.stock_market.match_orders(state.time)
-            matched_txs.extend(stock_txs)
-            state.stock_market.clear_expired_orders(state.time)
-
-        if "housing" in state.markets:
-             housing_txs = state.markets["housing"].match_orders(state.time)
-             matched_txs.extend(housing_txs)
-
-        state.transactions.extend(matched_txs)
-        return state
-
-
-class Phase_HousingSaga(IPhaseStrategy):
-    """
-    Phase 4.1: Advance Housing Sagas (Pre-Settlement Checks)
-
-    This phase processes long-running transactions (sagas), specifically for housing.
-    Its primary responsibility at this point in the tick is to perform pre-condition checks
-    that do not depend on market matching or financial settlement, such as agent liveness.
-    """
-    def __init__(self, world_state: WorldState):
-        self.world_state = world_state
-
-    def execute(self, state: SimulationState) -> SimulationState:
-        """
-        Checks for agent liveness and cancels sagas if participants are no longer active.
-        """
-        if state.settlement_system and hasattr(state.settlement_system, 'process_sagas'):
-            # The core logic is delegated to the settlement system.
-            # This call now handles all saga state transitions.
-            state.settlement_system.process_sagas(state)
-
-        return state
-
-
-class Phase_BankAndDebt(IPhaseStrategy):
-    """
-    Phase 4.2: Bank & Debt Service
-    Handles bank interest/fees and agent debt servicing.
-    """
-    def __init__(self, world_state: WorldState):
-        self.world_state = world_state
-
-    def execute(self, state: SimulationState) -> SimulationState:
-        # 1. Bank Tick
-        if state.bank and hasattr(state.bank, "run_tick"):
-            bank_txs = state.bank.run_tick(state.agents, state.time)
-            if bank_txs:
-                state.transactions.extend(bank_txs)
-
-        # 2. Debt Service
-        if self.world_state.finance_system:
-             debt_txs = self.world_state.finance_system.service_debt(state.time)
-             if debt_txs:
-                 state.transactions.extend(debt_txs)
-
-        return state
-
-class Phase_FirmProductionAndSalaries(IPhaseStrategy):
-    """
-    Phase 4.3: Firm Operations (Transactions)
-    Handles core firm operations like paying salaries.
-    Note: Production logic is in Phase_Production, this is for financial transactions.
-    """
-    def __init__(self, world_state: WorldState):
-        self.world_state = world_state
-
-    def execute(self, state: SimulationState) -> SimulationState:
-        market_data_prev = state.market_data
-
-        # TD-213: Fetch exchange rates for multi-currency transactions
-        exchange_rates = None
-        if state.tracker and hasattr(state.tracker, "capture_market_context"):
-            ctx = state.tracker.capture_market_context()
-            if ctx:
-                exchange_rates = ctx.exchange_rates
-
-        for firm in state.firms:
-             if firm.is_active:
-                 firm_txs = firm.generate_transactions(
-                     government=state.government,
-                     market_data=market_data_prev,
-                     all_households=state.households,
-                     current_time=state.time,
-                     exchange_rates=exchange_rates
-                 )
-                 if firm_txs:
-                     state.transactions.extend(firm_txs)
-        return state
-
-class Phase_GovernmentPrograms(IPhaseStrategy):
-    """
-    Phase 4.4: Government Spending Programs
-    """
-    def __init__(self, world_state: WorldState):
-        self.world_state = world_state
-
-    def execute(self, state: SimulationState) -> SimulationState:
-        market_data_prev = state.market_data
-
-        if state.government:
-            # Welfare
-            welfare_txs = state.government.run_welfare_check(list(state.agents.values()), market_data_prev, state.time)
-            if welfare_txs:
-                state.transactions.extend(welfare_txs)
-
-            # Infrastructure
-            infra_txs = state.government.invest_infrastructure(state.time, state.households)
-            if infra_txs:
-                state.transactions.extend(infra_txs)
-
-            # Education
-            edu_txs = state.government.run_public_education(state.households, state.config_module, state.time)
-            if edu_txs:
-                state.transactions.extend(edu_txs)
-
-        return state
-
-class Phase_TaxationIntents(IPhaseStrategy):
-    """
-    Phase 4.6: Corporate Tax Intents
-    Generates tax obligations before final transaction processing.
-    """
-    def __init__(self, world_state: WorldState):
-        self.world_state = world_state
-
-    def execute(self, state: SimulationState) -> SimulationState:
-        # WO-116: Corporate Tax Intent Generation
-        if state.taxation_system and state.government:
-            tax_intents = state.taxation_system.generate_corporate_tax_intents(state.firms, current_tick=state.time)
-            for tx in tax_intents:
-                if tx.seller_id == "GOVERNMENT":
-                     tx.seller_id = state.government.id
-            if tax_intents:
-                state.transactions.extend(tax_intents)
-        return state
-
-class Phase_MonetaryProcessing(IPhaseStrategy):
-    """
-    Phase 4.7: Monetary Processing
-    Updates the MonetaryLedger based on credit creation/destruction transactions.
-    """
-    def __init__(self, world_state: WorldState):
-        self.world_state = world_state
-
-    def execute(self, state: SimulationState) -> SimulationState:
-        # WO-4.2B: Delegate to MonetaryLedger
-        # We must process all transactions accumulated in WorldState so far,
-        # as sim_state.transactions is cleared after each phase drain.
-        if state.government and hasattr(state.government, "monetary_ledger"):
-             # Combine drained transactions with any current pending ones (though likely empty here)
-             all_transactions = list(self.world_state.transactions) + list(state.transactions)
-             state.government.monetary_ledger.process_transactions(all_transactions)
-
-        return state
-
-class Phase3_Transaction(IPhaseStrategy):
-    def __init__(self, world_state: WorldState):
-        self.world_state = world_state
-
-    def execute(self, state: SimulationState) -> SimulationState:
-        # Move system transactions from queue if any (e.g. from Bankruptcy phase)
-        if state.inter_tick_queue:
-            state.transactions.extend(state.inter_tick_queue)
-            state.inter_tick_queue.clear()
-
-        # WO-024: Monetary Transactions are now processed incrementally in TickOrchestrator._drain_and_sync_state (TD-177)
-        # Main transaction processing logic
-        if self.world_state.transaction_processor:
-            # TD-192: Pass combined transactions to ensure execution of drained (historic) and current items
-            combined_txs = list(self.world_state.transactions) + list(state.transactions)
-            results = self.world_state.transaction_processor.execute(state, transactions=combined_txs)
-
-            # WO-116: Record Revenue (Saga Pattern)
-            if state.taxation_system:
-                state.taxation_system.record_revenue(results)
-        else:
-            state.logger.error("TransactionProcessor not initialized.")
-
-        return state
-
-
-class Phase_Bankruptcy(IPhaseStrategy):
-    """
-    Phase 4: Agent Decisions & Lifecycle (Bankruptcy Check)
-    Agents make decisions. Bankrupt agents are identified here.
-    """
-    def __init__(self, world_state: WorldState):
-        self.world_state = world_state
-
-    def execute(self, state: SimulationState) -> SimulationState:
-        if self.world_state.lifecycle_manager:
-            lifecycle_txs = self.world_state.lifecycle_manager.execute(state)
-            if lifecycle_txs:
-                state.inter_tick_queue.extend(lifecycle_txs)
-        return state
-
-class Phase_Consumption(IPhaseStrategy):
-    """
-    Phase: Consumption Finalization.
-    Formerly part of Phase4_Lifecycle.
-    """
-    def __init__(self, world_state: WorldState):
-        self.world_state = world_state
-
-    def execute(self, state: SimulationState) -> SimulationState:
-        consumption_market_data = state.market_data
-
-        commerce_context: CommerceContext = {
-            "households": state.households,
-            "agents": state.agents,
-            "breeding_planner": self.world_state.breeding_planner,
-            "household_time_allocation": state.household_time_allocation,
-            "market_data": consumption_market_data,
-            "config": state.config_module,
-            "time": state.time
-        }
-
-        if self.world_state.commerce_system:
-            leisure_effects = self.world_state.commerce_system.finalize_consumption_and_leisure(
-                commerce_context, state.planned_consumption
-            )
-            state.household_leisure_effects = leisure_effects
-
-        return state
-
-
-class Phase5_PostSequence(IPhaseStrategy):
-    def __init__(self, world_state: WorldState):
-        self.world_state = world_state
-
-    def execute(self, state: SimulationState) -> SimulationState:
-        # Housing
-        if self.world_state.housing_system:
-             self.world_state.housing_system.process_housing(state)
-             self.world_state.housing_system.apply_homeless_penalty(state)
-
-        # Learning Update
-        market_data_for_learning = prepare_market_data(state)
-
-        # Firms
-        for firm in state.firms:
-            if firm.is_active and firm.id in state.firm_pre_states:
-                agent_data = firm.get_agent_data()
-
-                if hasattr(firm.decision_engine, 'ai_engine'):
-                     reward = firm.decision_engine.ai_engine.calculate_reward(
-                        firm, firm.get_pre_state_data(), agent_data
-                     )
-
-                     firm_context: LearningUpdateContext = {
-                        "reward": reward,
-                        "next_agent_data": agent_data,
-                        "next_market_data": market_data_for_learning
-                     }
-                     firm.update_learning(firm_context)
-
-                     decision_data = AIDecisionData(
-                        run_id=state.agents.get(firm.id).run_id if hasattr(state.agents.get(firm.id), 'run_id') else 0,
-                        tick=state.time,
-                        agent_id=firm.id,
-                        decision_type="VECTOR_V2",
-                        decision_details={"reward": reward},
-                        predicted_reward=None,
-                        actual_reward=reward,
-                     )
-                     self.world_state.repository.analytics.save_ai_decision(decision_data)
-
-        # Households
-        for household in state.households:
-             if household._bio_state.is_active and household.id in state.household_pre_states:
-                 if hasattr(household.decision_engine, 'ai_engine') and household.decision_engine.ai_engine:
-                     agent_data = household.get_agent_data()
-                     leisure_utility = state.household_leisure_effects.get(household.id, 0.0)
-                     agent_data["leisure_utility"] = leisure_utility
-
-                     reward = household.decision_engine.ai_engine._calculate_reward(
-                         household.get_pre_state_data(),
-                         agent_data, # post_state is current
-                         agent_data,
-                         market_data_for_learning
-                     )
-
-                     hh_context: LearningUpdateContext = {
-                        "reward": reward,
-                        "next_agent_data": agent_data,
-                        "next_market_data": market_data_for_learning
-                     }
-                     household.update_learning(hh_context)
-
-                     decision_data = AIDecisionData(
-                        run_id=state.agents.get(household.id).run_id if hasattr(state.agents.get(household.id), 'run_id') else 0,
-                        tick=state.time,
-                        agent_id=household.id,
-                        decision_type="VECTOR_V2",
-                        decision_details={"reward": reward},
-                        predicted_reward=None,
-                        actual_reward=reward,
-                     )
-                     self.world_state.repository.analytics.save_ai_decision(decision_data)
-
-        if self.world_state.ma_manager:
-            self.world_state.ma_manager.process_market_exits_and_entries(state.time)
-
-        # Cleanup firms
-        active_firms_before = len(state.firms)
-        state.firms[:] = [f for f in state.firms if f.is_active]
-        if len(state.firms) < active_firms_before:
-             state.logger.info(f"CLEANUP | Removed {active_firms_before - len(state.firms)} inactive firms.")
-
-        if state.government:
-             state.government.finalize_tick(state.time)
-
-        if self.world_state.persistence_manager:
-             # TD-160: Use world_state.transactions to ensure all drained transactions are captured
-             self.world_state.persistence_manager.buffer_tick_state(self.world_state, self.world_state.transactions)
-             if state.time % self.world_state.batch_save_interval == 0:
-                 self.world_state.persistence_manager.flush_buffers(state.time)
-
-        # Reset counters
-        for h in state.households:
-             if hasattr(h, "reset_consumption_counters"):
-                 h.reset_consumption_counters()
-
-        for f in state.firms:
-            if hasattr(f, 'finance'):
-                f.finance.last_daily_expenses = f.finance.expenses_this_tick
-                f.finance.last_sales_volume = f.finance.sales_volume_this_tick
-                f.finance.sales_volume_this_tick = 0.0
-                f.finance.expenses_this_tick = 0.0
-                f.finance.revenue_this_tick = 0.0
-
-        if self.world_state.generational_wealth_audit and state.time % 100 == 0:
-             self.world_state.generational_wealth_audit.run_audit(state.households, state.time)
-
-        if self.world_state.crisis_monitor:
-             self.world_state.crisis_monitor.monitor(state.time, state.firms)
-
-        for market in state.markets.values():
-             market.clear_orders()
-
-        if state.stock_market:
-             state.stock_tracker.track_all_firms(state.firms, state.stock_market)
-
-        return state
diff --git a/simulation/orchestration/phases/__init__.py b/simulation/orchestration/phases/__init__.py
new file mode 100644
index 00000000..46cc02bd
--- /dev/null
+++ b/simulation/orchestration/phases/__init__.py
@@ -0,0 +1,43 @@
+from .pre_sequence import Phase0_PreSequence
+from .production import Phase_Production
+from .decision import Phase1_Decision
+from .matching import Phase2_Matching
+from .housing_saga import Phase_HousingSaga
+from .bank_debt import Phase_BankAndDebt
+from .firm_operations import Phase_FirmProductionAndSalaries
+from .government_programs import Phase_GovernmentPrograms
+from .taxation_intents import Phase_TaxationIntents
+from .monetary_processing import Phase_MonetaryProcessing
+from .transaction import Phase3_Transaction
+from .bankruptcy import Phase_Bankruptcy
+from .consumption import Phase_Consumption
+from .post_sequence import Phase5_PostSequence
+
+# Re-export utils and factories for backward compatibility with tests and consumers
+from simulation.orchestration.factories import (
+    MarketSignalFactory,
+    DecisionInputFactory,
+    MarketSnapshotFactory
+)
+from simulation.orchestration.utils import prepare_market_data
+
+__all__ = [
+    "Phase0_PreSequence",
+    "Phase_Production",
+    "Phase1_Decision",
+    "Phase2_Matching",
+    "Phase_HousingSaga",
+    "Phase_BankAndDebt",
+    "Phase_FirmProductionAndSalaries",
+    "Phase_GovernmentPrograms",
+    "Phase_TaxationIntents",
+    "Phase_MonetaryProcessing",
+    "Phase3_Transaction",
+    "Phase_Bankruptcy",
+    "Phase_Consumption",
+    "Phase5_PostSequence",
+    "MarketSignalFactory",
+    "DecisionInputFactory",
+    "MarketSnapshotFactory",
+    "prepare_market_data"
+]
diff --git a/simulation/orchestration/phases/bank_debt.py b/simulation/orchestration/phases/bank_debt.py
new file mode 100644
index 00000000..75284f62
--- /dev/null
+++ b/simulation/orchestration/phases/bank_debt.py
@@ -0,0 +1,34 @@
+from __future__ import annotations
+from typing import TYPE_CHECKING
+import logging
+
+from simulation.orchestration.api import IPhaseStrategy
+from simulation.dtos.api import SimulationState
+
+if TYPE_CHECKING:
+    from simulation.world_state import WorldState
+
+logger = logging.getLogger(__name__)
+
+class Phase_BankAndDebt(IPhaseStrategy):
+    """
+    Phase 4.2: Bank & Debt Service
+    Handles bank interest/fees and agent debt servicing.
+    """
+    def __init__(self, world_state: WorldState):
+        self.world_state = world_state
+
+    def execute(self, state: SimulationState) -> SimulationState:
+        # 1. Bank Tick
+        if state.bank and hasattr(state.bank, "run_tick"):
+            bank_txs = state.bank.run_tick(state.agents, state.time)
+            if bank_txs:
+                state.transactions.extend(bank_txs)
+
+        # 2. Debt Service
+        if self.world_state.finance_system:
+             debt_txs = self.world_state.finance_system.service_debt(state.time)
+             if debt_txs:
+                 state.transactions.extend(debt_txs)
+
+        return state
diff --git a/simulation/orchestration/phases/bankruptcy.py b/simulation/orchestration/phases/bankruptcy.py
new file mode 100644
index 00000000..3122bde7
--- /dev/null
+++ b/simulation/orchestration/phases/bankruptcy.py
@@ -0,0 +1,26 @@
+from __future__ import annotations
+from typing import TYPE_CHECKING
+import logging
+
+from simulation.orchestration.api import IPhaseStrategy
+from simulation.dtos.api import SimulationState
+
+if TYPE_CHECKING:
+    from simulation.world_state import WorldState
+
+logger = logging.getLogger(__name__)
+
+class Phase_Bankruptcy(IPhaseStrategy):
+    """
+    Phase 4: Agent Decisions & Lifecycle (Bankruptcy Check)
+    Agents make decisions. Bankrupt agents are identified here.
+    """
+    def __init__(self, world_state: WorldState):
+        self.world_state = world_state
+
+    def execute(self, state: SimulationState) -> SimulationState:
+        if self.world_state.lifecycle_manager:
+            lifecycle_txs = self.world_state.lifecycle_manager.execute(state)
+            if lifecycle_txs:
+                state.inter_tick_queue.extend(lifecycle_txs)
+        return state
diff --git a/simulation/orchestration/phases/consumption.py b/simulation/orchestration/phases/consumption.py
new file mode 100644
index 00000000..007305d9
--- /dev/null
+++ b/simulation/orchestration/phases/consumption.py
@@ -0,0 +1,42 @@
+from __future__ import annotations
+from typing import TYPE_CHECKING
+import logging
+
+from simulation.orchestration.api import IPhaseStrategy
+from simulation.dtos.api import SimulationState
+from simulation.systems.api import CommerceContext
+
+if TYPE_CHECKING:
+    from simulation.world_state import WorldState
+
+logger = logging.getLogger(__name__)
+
+class Phase_Consumption(IPhaseStrategy):
+    """
+    Phase: Consumption Finalization.
+    Formerly part of Phase4_Lifecycle.
+    """
+    def __init__(self, world_state: WorldState):
+        self.world_state = world_state
+
+    def execute(self, state: SimulationState) -> SimulationState:
+        consumption_market_data = state.market_data
+
+        commerce_context: CommerceContext = {
+            "households": state.households,
+            "agents": state.agents,
+            "breeding_planner": self.world_state.breeding_planner,
+            "household_time_allocation": state.household_time_allocation,
+            "market_data": consumption_market_data,
+            "config": state.config_module,
+            "time": state.time,
+            "government": state.government
+        }
+
+        if self.world_state.commerce_system:
+            leisure_effects = self.world_state.commerce_system.finalize_consumption_and_leisure(
+                commerce_context, state.planned_consumption
+            )
+            state.household_leisure_effects = leisure_effects
+
+        return state
diff --git a/simulation/orchestration/phases/decision.py b/simulation/orchestration/phases/decision.py
new file mode 100644
index 00000000..b2ee861c
--- /dev/null
+++ b/simulation/orchestration/phases/decision.py
@@ -0,0 +1,234 @@
+from __future__ import annotations
+from typing import TYPE_CHECKING, Dict, Any
+import logging
+from dataclasses import replace
+
+from simulation.orchestration.api import IPhaseStrategy
+from simulation.dtos.api import SimulationState, DecisionInputDTO
+from simulation.models import Order
+from simulation.systems.api import CommerceContext
+from simulation.orchestration.utils import prepare_market_data
+from simulation.orchestration.factories import DecisionInputFactory, MarketSnapshotFactory
+from simulation.markets.order_book_market import OrderBookMarket
+from simulation.core_agents import Household
+
+if TYPE_CHECKING:
+    from simulation.world_state import WorldState
+
+logger = logging.getLogger(__name__)
+
+class Phase1_Decision(IPhaseStrategy):
+    def __init__(self, world_state: WorldState):
+        self.world_state = world_state
+        # TD-189: Use factories
+        self.input_factory = DecisionInputFactory()
+        self.snapshot_factory = MarketSnapshotFactory()
+
+    def execute(self, state: SimulationState) -> SimulationState:
+        # Snapshot agents for learning (Pre-state)
+        self._snapshot_agent_pre_states(state)
+
+        # Prepare Market Data
+        market_data = prepare_market_data(state)
+        state.market_data = market_data
+
+        # 1. Create Snapshot using the factory
+        market_snapshot = self.snapshot_factory.create_snapshot(state)
+
+        # 2. Create Base Input DTO using the factory
+        base_input_dto = self.input_factory.create_decision_input(state, self.world_state, market_snapshot)
+
+        # 3. Dispatch decisions
+        self._dispatch_firm_decisions(state, base_input_dto)
+        self._dispatch_household_decisions(state, base_input_dto)
+
+        # 4. Commerce Planning
+        self._plan_commerce(state, market_data)
+
+        return state
+
+    def _snapshot_agent_pre_states(self, state: SimulationState):
+        for f in state.firms:
+            if f.is_active: f.pre_state_snapshot = f.get_agent_data()
+        for h in state.households:
+            if h._bio_state.is_active: h.pre_state_snapshot = h.get_agent_data()
+
+    def _dispatch_firm_decisions(self, state: SimulationState, base_input_dto: DecisionInputDTO):
+        firm_pre_states = {}
+
+        for firm in state.firms:
+            if not firm.is_active: continue
+
+            if hasattr(firm.decision_engine, 'ai_engine') and firm.decision_engine.ai_engine:
+                pre_strategic_state = (
+                    firm.decision_engine.ai_engine._get_strategic_state(
+                        firm.get_agent_data(), state.market_data
+                    )
+                )
+                pre_tactical_state = firm.decision_engine.ai_engine._get_tactical_state(
+                    firm.decision_engine.ai_engine.chosen_intention,
+                    firm.get_agent_data(),
+                    state.market_data,
+                )
+                firm_pre_states[firm.id] = {
+                    "pre_strategic_state": pre_strategic_state,
+                    "pre_tactical_state": pre_tactical_state,
+                    "chosen_intention": firm.decision_engine.ai_engine.chosen_intention,
+                    "chosen_tactic": firm.decision_engine.ai_engine.last_chosen_tactic,
+                }
+
+            firm_input = replace(base_input_dto, stress_scenario_config=self.world_state.stress_scenario_config)
+            decision_output = firm.make_decision(firm_input)
+
+            if hasattr(decision_output, 'orders'):
+                firm_orders = decision_output.orders
+            else:
+                firm_orders, action_vector = decision_output
+
+            for order in firm_orders:
+                target_market = state.markets.get(order.market_id)
+                if target_market:
+                    new_txs = target_market.place_order(order, state.time)
+                    if new_txs:
+                        state.transactions.extend(new_txs)
+
+        state.firm_pre_states = firm_pre_states
+
+    def _dispatch_household_decisions(self, state: SimulationState, base_input_dto: DecisionInputDTO):
+        household_pre_states = {}
+        household_time_allocation = {}
+
+        for household in state.households:
+            if not household._bio_state.is_active: continue
+
+            if hasattr(household.decision_engine, 'ai_engine') and household.decision_engine.ai_engine:
+                pre_strategic_state = (
+                    household.decision_engine.ai_engine._get_strategic_state(
+                        household.get_agent_data(), state.market_data
+                    )
+                )
+                household_pre_states[household.id] = {
+                    "pre_strategic_state": pre_strategic_state,
+                }
+
+            household_input = replace(
+                base_input_dto,
+                stress_scenario_config=self.world_state.stress_scenario_config,
+                macro_context=base_input_dto.macro_context
+            )
+            decision_output = household.make_decision(household_input)
+
+            if hasattr(decision_output, 'orders'):
+                household_orders = decision_output.orders
+                metadata = decision_output.metadata
+                if hasattr(metadata, 'work_aggressiveness'):
+                     work_aggressiveness = metadata.work_aggressiveness
+                else:
+                     work_aggressiveness = 0.5
+            else:
+                household_orders, action_vector = decision_output
+                if hasattr(action_vector, 'work_aggressiveness'):
+                    work_aggressiveness = action_vector.work_aggressiveness
+                else:
+                    work_aggressiveness = 0.5
+
+            max_work_hours = state.config_module.MAX_WORK_HOURS
+            shopping_hours = getattr(state.config_module, "SHOPPING_HOURS", 2.0)
+            hours_per_tick = getattr(state.config_module, "HOURS_PER_TICK", 24.0)
+
+            work_hours = work_aggressiveness * max_work_hours
+            leisure_hours = max(0.0, hours_per_tick - work_hours - shopping_hours)
+            household_time_allocation[household.id] = leisure_hours
+
+            for order in household_orders:
+                self._process_household_order(state, household, order, state.market_data)
+
+        state.household_pre_states = household_pre_states
+        state.household_time_allocation = household_time_allocation
+
+    def _process_household_order(self, state: SimulationState, household: Household, order: Order, market_data: Dict[str, Any]):
+        # WO-053: Force deflationary pressure on basic_food
+        if hasattr(order, "item_id") and order.item_id == "basic_food" and order.side == "BUY":
+                deflationary_multiplier = getattr(state.config_module, "DEFLATIONARY_PRESSURE_MULTIPLIER", None)
+
+                if deflationary_multiplier is not None:
+                    current_price = market_data.get("basic_food_current_sell_price", 5.0)
+                    new_price = min(order.price_limit, max(0.1, current_price * float(deflationary_multiplier)))
+                    order = replace(order, price_limit=new_price)
+
+        if order.side == "INVEST" and order.market_id == "admin":
+            if self.world_state.firm_system:
+                self.world_state.firm_system.spawn_firm(state, household)
+            else:
+                state.logger.warning(f"SKIPPED_INVESTMENT | Agent {household.id} tried startup but firm_system missing.")
+            return
+
+        target_market_id = self._get_redirected_market(order)
+        household_target_market = state.markets.get(target_market_id)
+
+        if household_target_market:
+            new_txs = household_target_market.place_order(order, state.time)
+            if new_txs:
+                state.transactions.extend(new_txs)
+
+    def _get_redirected_market(self, order: Order) -> str:
+        target_market_id = order.market_id
+        if order.side in ["DEPOSIT", "WITHDRAW", "LOAN_REQUEST", "REPAYMENT"]:
+            target_market_id = "loan_market"
+        elif hasattr(order, "item_id") and order.item_id in ["deposit", "currency"]:
+            target_market_id = "loan_market"
+        return target_market_id
+
+    def _plan_commerce(self, state: SimulationState, market_data: Dict[str, Any]):
+         # Commerce Planning
+        current_vacancies = 0
+        labor_market = state.markets.get("labor")
+        if labor_market and isinstance(labor_market, OrderBookMarket):
+             for item_orders in labor_market.buy_orders.values():
+                 for order in item_orders:
+                     current_vacancies += order.quantity
+
+        consumption_market_data = market_data.copy()
+        consumption_market_data["job_vacancies"] = current_vacancies
+
+        sales_tax_rate = getattr(state.config_module, "SALES_TAX_RATE", 0.05)
+
+        commerce_context: CommerceContext = {
+            "households": state.households,
+            "agents": state.agents,
+            "breeding_planner": self.world_state.breeding_planner,
+            "household_time_allocation": state.household_time_allocation,
+            "market_data": consumption_market_data,
+            "config": state.config_module,
+            "time": state.time,
+            "government": state.government,
+            "sales_tax_rate": sales_tax_rate
+        }
+
+        if self.world_state.commerce_system:
+            planned_cons, commerce_txs = self.world_state.commerce_system.plan_consumption_and_leisure(
+                commerce_context, self.world_state.stress_scenario_config
+            )
+            state.planned_consumption = planned_cons
+
+            for tx in commerce_txs:
+                if tx.transaction_type == "PHASE23_MARKET_ORDER":
+                     # WO-053: Convert special transaction to Order
+                     # Use new OrderDTO fields: side, price_limit
+                     order = Order(
+                         agent_id=tx.buyer_id,
+                         side="BUY",
+                         item_id=tx.item_id,
+                         quantity=tx.quantity,
+                         price_limit=tx.price,
+                         market_id=tx.item_id
+                     )
+                     market = state.markets.get(tx.item_id)
+                     if market:
+                         new_txs = market.place_order(order, state.time)
+                         if new_txs:
+                             state.transactions.extend(new_txs)
+                else:
+                     state.transactions.append(tx)
+
+        return state
diff --git a/simulation/orchestration/phases/firm_operations.py b/simulation/orchestration/phases/firm_operations.py
new file mode 100644
index 00000000..57c662a9
--- /dev/null
+++ b/simulation/orchestration/phases/firm_operations.py
@@ -0,0 +1,43 @@
+from __future__ import annotations
+from typing import TYPE_CHECKING
+import logging
+
+from simulation.orchestration.api import IPhaseStrategy
+from simulation.dtos.api import SimulationState
+
+if TYPE_CHECKING:
+    from simulation.world_state import WorldState
+
+logger = logging.getLogger(__name__)
+
+class Phase_FirmProductionAndSalaries(IPhaseStrategy):
+    """
+    Phase 4.3: Firm Operations (Transactions)
+    Handles core firm operations like paying salaries.
+    Note: Production logic is in Phase_Production, this is for financial transactions.
+    """
+    def __init__(self, world_state: WorldState):
+        self.world_state = world_state
+
+    def execute(self, state: SimulationState) -> SimulationState:
+        market_data_prev = state.market_data
+
+        # TD-213: Fetch exchange rates for multi-currency transactions
+        exchange_rates = None
+        if state.tracker and hasattr(state.tracker, "capture_market_context"):
+            ctx = state.tracker.capture_market_context()
+            if ctx:
+                exchange_rates = ctx.exchange_rates
+
+        for firm in state.firms:
+             if firm.is_active:
+                 firm_txs = firm.generate_transactions(
+                     government=state.government,
+                     market_data=market_data_prev,
+                     all_households=state.households,
+                     current_time=state.time,
+                     exchange_rates=exchange_rates
+                 )
+                 if firm_txs:
+                     state.transactions.extend(firm_txs)
+        return state
diff --git a/simulation/orchestration/phases/government_programs.py b/simulation/orchestration/phases/government_programs.py
new file mode 100644
index 00000000..4de008db
--- /dev/null
+++ b/simulation/orchestration/phases/government_programs.py
@@ -0,0 +1,39 @@
+from __future__ import annotations
+from typing import TYPE_CHECKING
+import logging
+
+from simulation.orchestration.api import IPhaseStrategy
+from simulation.dtos.api import SimulationState
+
+if TYPE_CHECKING:
+    from simulation.world_state import WorldState
+
+logger = logging.getLogger(__name__)
+
+class Phase_GovernmentPrograms(IPhaseStrategy):
+    """
+    Phase 4.4: Government Spending Programs
+    """
+    def __init__(self, world_state: WorldState):
+        self.world_state = world_state
+
+    def execute(self, state: SimulationState) -> SimulationState:
+        market_data_prev = state.market_data
+
+        if state.government:
+            # Welfare
+            welfare_txs = state.government.run_welfare_check(list(state.agents.values()), market_data_prev, state.time)
+            if welfare_txs:
+                state.transactions.extend(welfare_txs)
+
+            # Infrastructure
+            infra_txs = state.government.invest_infrastructure(state.time, state.households)
+            if infra_txs:
+                state.transactions.extend(infra_txs)
+
+            # Education
+            edu_txs = state.government.run_public_education(state.households, state.config_module, state.time)
+            if edu_txs:
+                state.transactions.extend(edu_txs)
+
+        return state
diff --git a/simulation/orchestration/phases/housing_saga.py b/simulation/orchestration/phases/housing_saga.py
new file mode 100644
index 00000000..9e1b93d7
--- /dev/null
+++ b/simulation/orchestration/phases/housing_saga.py
@@ -0,0 +1,33 @@
+from __future__ import annotations
+from typing import TYPE_CHECKING
+import logging
+
+from simulation.orchestration.api import IPhaseStrategy
+from simulation.dtos.api import SimulationState
+
+if TYPE_CHECKING:
+    from simulation.world_state import WorldState
+
+logger = logging.getLogger(__name__)
+
+class Phase_HousingSaga(IPhaseStrategy):
+    """
+    Phase 4.1: Advance Housing Sagas (Pre-Settlement Checks)
+
+    This phase processes long-running transactions (sagas), specifically for housing.
+    Its primary responsibility at this point in the tick is to perform pre-condition checks
+    that do not depend on market matching or financial settlement, such as agent liveness.
+    """
+    def __init__(self, world_state: WorldState):
+        self.world_state = world_state
+
+    def execute(self, state: SimulationState) -> SimulationState:
+        """
+        Checks for agent liveness and cancels sagas if participants are no longer active.
+        """
+        if state.settlement_system and hasattr(state.settlement_system, 'process_sagas'):
+            # The core logic is delegated to the settlement system.
+            # This call now handles all saga state transitions.
+            state.settlement_system.process_sagas(state)
+
+        return state
diff --git a/simulation/orchestration/phases/matching.py b/simulation/orchestration/phases/matching.py
new file mode 100644
index 00000000..73d74203
--- /dev/null
+++ b/simulation/orchestration/phases/matching.py
@@ -0,0 +1,34 @@
+from __future__ import annotations
+from typing import TYPE_CHECKING
+import logging
+
+from simulation.orchestration.api import IPhaseStrategy
+from simulation.dtos.api import SimulationState
+from simulation.markets.order_book_market import OrderBookMarket
+
+if TYPE_CHECKING:
+    from simulation.world_state import WorldState
+
+logger = logging.getLogger(__name__)
+
+class Phase2_Matching(IPhaseStrategy):
+    def __init__(self, world_state: WorldState):
+        self.world_state = world_state
+
+    def execute(self, state: SimulationState) -> SimulationState:
+        matched_txs = []
+        for market in state.markets.values():
+            if isinstance(market, OrderBookMarket):
+                matched_txs.extend(market.match_orders(state.time))
+
+        if state.stock_market:
+            stock_txs = state.stock_market.match_orders(state.time)
+            matched_txs.extend(stock_txs)
+            state.stock_market.clear_expired_orders(state.time)
+
+        if "housing" in state.markets:
+             housing_txs = state.markets["housing"].match_orders(state.time)
+             matched_txs.extend(housing_txs)
+
+        state.transactions.extend(matched_txs)
+        return state
diff --git a/simulation/orchestration/phases/monetary_processing.py b/simulation/orchestration/phases/monetary_processing.py
new file mode 100644
index 00000000..e8e12abd
--- /dev/null
+++ b/simulation/orchestration/phases/monetary_processing.py
@@ -0,0 +1,30 @@
+from __future__ import annotations
+from typing import TYPE_CHECKING
+import logging
+
+from simulation.orchestration.api import IPhaseStrategy
+from simulation.dtos.api import SimulationState
+
+if TYPE_CHECKING:
+    from simulation.world_state import WorldState
+
+logger = logging.getLogger(__name__)
+
+class Phase_MonetaryProcessing(IPhaseStrategy):
+    """
+    Phase 4.7: Monetary Processing
+    Updates the MonetaryLedger based on credit creation/destruction transactions.
+    """
+    def __init__(self, world_state: WorldState):
+        self.world_state = world_state
+
+    def execute(self, state: SimulationState) -> SimulationState:
+        # WO-4.2B: Delegate to MonetaryLedger
+        # We must process all transactions accumulated in WorldState so far,
+        # as sim_state.transactions is cleared after each phase drain.
+        if state.government and hasattr(state.government, "monetary_ledger"):
+             # Combine drained transactions with any current pending ones (though likely empty here)
+             all_transactions = list(self.world_state.transactions) + list(state.transactions)
+             state.government.monetary_ledger.process_transactions(all_transactions)
+
+        return state
diff --git a/simulation/orchestration/phases/post_sequence.py b/simulation/orchestration/phases/post_sequence.py
new file mode 100644
index 00000000..94dd2a1f
--- /dev/null
+++ b/simulation/orchestration/phases/post_sequence.py
@@ -0,0 +1,132 @@
+from __future__ import annotations
+from typing import TYPE_CHECKING
+import logging
+
+from simulation.orchestration.api import IPhaseStrategy
+from simulation.dtos.api import SimulationState, AIDecisionData
+from simulation.orchestration.utils import prepare_market_data
+from simulation.systems.api import LearningUpdateContext
+
+if TYPE_CHECKING:
+    from simulation.world_state import WorldState
+
+logger = logging.getLogger(__name__)
+
+class Phase5_PostSequence(IPhaseStrategy):
+    def __init__(self, world_state: WorldState):
+        self.world_state = world_state
+
+    def execute(self, state: SimulationState) -> SimulationState:
+        # Housing
+        if self.world_state.housing_system:
+             self.world_state.housing_system.process_housing(state)
+             self.world_state.housing_system.apply_homeless_penalty(state)
+
+        # Learning Update
+        market_data_for_learning = prepare_market_data(state)
+
+        # Firms
+        for firm in state.firms:
+            if firm.is_active and firm.id in state.firm_pre_states:
+                agent_data = firm.get_agent_data()
+
+                if hasattr(firm.decision_engine, 'ai_engine'):
+                     reward = firm.decision_engine.ai_engine.calculate_reward(
+                        firm, firm.get_pre_state_data(), agent_data
+                     )
+
+                     firm_context: LearningUpdateContext = {
+                        "reward": reward,
+                        "next_agent_data": agent_data,
+                        "next_market_data": market_data_for_learning
+                     }
+                     firm.update_learning(firm_context)
+
+                     decision_data = AIDecisionData(
+                        run_id=state.agents.get(firm.id).run_id if hasattr(state.agents.get(firm.id), 'run_id') else 0,
+                        tick=state.time,
+                        agent_id=firm.id,
+                        decision_type="VECTOR_V2",
+                        decision_details={"reward": reward},
+                        predicted_reward=None,
+                        actual_reward=reward,
+                     )
+                     self.world_state.repository.analytics.save_ai_decision(decision_data)
+
+        # Households
+        for household in state.households:
+             if household._bio_state.is_active and household.id in state.household_pre_states:
+                 if hasattr(household.decision_engine, 'ai_engine') and household.decision_engine.ai_engine:
+                     agent_data = household.get_agent_data()
+                     leisure_utility = state.household_leisure_effects.get(household.id, 0.0)
+                     agent_data["leisure_utility"] = leisure_utility
+
+                     reward = household.decision_engine.ai_engine._calculate_reward(
+                         household.get_pre_state_data(),
+                         agent_data, # post_state is current
+                         agent_data,
+                         market_data_for_learning
+                     )
+
+                     hh_context: LearningUpdateContext = {
+                        "reward": reward,
+                        "next_agent_data": agent_data,
+                        "next_market_data": market_data_for_learning
+                     }
+                     household.update_learning(hh_context)
+
+                     decision_data = AIDecisionData(
+                        run_id=state.agents.get(household.id).run_id if hasattr(state.agents.get(household.id), 'run_id') else 0,
+                        tick=state.time,
+                        agent_id=household.id,
+                        decision_type="VECTOR_V2",
+                        decision_details={"reward": reward},
+                        predicted_reward=None,
+                        actual_reward=reward,
+                     )
+                     self.world_state.repository.analytics.save_ai_decision(decision_data)
+
+        if self.world_state.ma_manager:
+            self.world_state.ma_manager.process_market_exits_and_entries(state.time)
+
+        # Cleanup firms
+        active_firms_before = len(state.firms)
+        state.firms[:] = [f for f in state.firms if f.is_active]
+        if len(state.firms) < active_firms_before:
+             state.logger.info(f"CLEANUP | Removed {active_firms_before - len(state.firms)} inactive firms.")
+
+        if state.government:
+             state.government.finalize_tick(state.time)
+
+        if self.world_state.persistence_manager:
+             # TD-160: Use world_state.transactions to ensure all drained transactions are captured
+             self.world_state.persistence_manager.buffer_tick_state(self.world_state, self.world_state.transactions)
+             if state.time % self.world_state.batch_save_interval == 0:
+                 self.world_state.persistence_manager.flush_buffers(state.time)
+
+        # Reset counters
+        for h in state.households:
+             if hasattr(h, "reset_consumption_counters"):
+                 h.reset_consumption_counters()
+
+        for f in state.firms:
+            if hasattr(f, 'finance'):
+                f.finance.last_daily_expenses = f.finance.expenses_this_tick
+                f.finance.last_sales_volume = f.finance.sales_volume_this_tick
+                f.finance.sales_volume_this_tick = 0.0
+                f.finance.expenses_this_tick = 0.0
+                f.finance.revenue_this_tick = 0.0
+
+        if self.world_state.generational_wealth_audit and state.time % 100 == 0:
+             self.world_state.generational_wealth_audit.run_audit(state.households, state.time)
+
+        if self.world_state.crisis_monitor:
+             self.world_state.crisis_monitor.monitor(state.time, state.firms)
+
+        for market in state.markets.values():
+             market.clear_orders()
+
+        if state.stock_market:
+             state.stock_tracker.track_all_firms(state.firms, state.stock_market)
+
+        return state
diff --git a/simulation/orchestration/phases/pre_sequence.py b/simulation/orchestration/phases/pre_sequence.py
new file mode 100644
index 00000000..d0b21d8a
--- /dev/null
+++ b/simulation/orchestration/phases/pre_sequence.py
@@ -0,0 +1,135 @@
+from __future__ import annotations
+from typing import TYPE_CHECKING
+import logging
+
+from simulation.orchestration.api import IPhaseStrategy
+from simulation.dtos.api import SimulationState, GovernmentStateDTO
+from modules.government.dtos import MacroEconomicSnapshotDTO
+from simulation.systems.api import (
+    EventContext, SocialMobilityContext, SensoryContext
+)
+from modules.government.components.monetary_policy_manager import MonetaryPolicyManager
+from simulation.orchestration.utils import prepare_market_data
+
+if TYPE_CHECKING:
+    from simulation.world_state import WorldState
+
+logger = logging.getLogger(__name__)
+
+class Phase0_PreSequence(IPhaseStrategy):
+    def __init__(self, world_state: WorldState):
+        self.world_state = world_state
+        self.mp_manager = MonetaryPolicyManager(world_state.config_module)
+
+    def execute(self, state: SimulationState) -> SimulationState:
+        # WO-109: Pre-Sequence Stabilization
+        if state.bank and hasattr(state.bank, "generate_solvency_transactions"):
+            stabilization_txs = state.bank.generate_solvency_transactions(state.government)
+            if stabilization_txs:
+                state.transactions.extend(stabilization_txs)
+                state.logger.warning("STABILIZATION | Queued pre-sequence stabilization transactions.")
+
+        # AI Training
+        if state.ai_training_manager:
+            if state.time > 0 and state.time % state.config_module.IMITATION_LEARNING_INTERVAL == 0:
+                state.ai_training_manager.run_imitation_learning_cycle(state.time)
+
+        # --- WO-060 / Phase 17 Logic (Social & Gov) ---
+
+        # Update Stock Market Reference Prices
+        if state.stock_market:
+            active_firms = {f.id: f for f in state.firms if f.is_active}
+            state.stock_market.update_reference_prices(active_firms)
+
+        # Prepare Market Data (for Gov/Social)
+        market_data = prepare_market_data(state)
+
+        # Social Ranks
+        if getattr(state.config_module, "ENABLE_VANITY_SYSTEM", False) and self.world_state.social_system:
+            context: SocialMobilityContext = {
+                "households": state.households
+            }
+            self.world_state.social_system.update_social_ranks(context)
+            ref_std = self.world_state.social_system.calculate_reference_standard(context)
+            market_data["reference_standard"] = ref_std
+
+        # Government Public Opinion
+        if state.government:
+            state.government.update_public_opinion(state.households)
+
+        # Sensory System
+        sensory_context: SensoryContext = {
+            "tracker": state.tracker,
+            "government": state.government,
+            "time": state.time,
+            "inequality_tracker": self.world_state.inequality_tracker,
+            "households": state.households
+        }
+
+        sensory_dto = GovernmentStateDTO(state.time, 0, 0, 0, 0, 0, 0)
+        if self.world_state.sensory_system:
+            sensory_dto = self.world_state.sensory_system.generate_government_sensory_dto(sensory_context)
+        else:
+             state.logger.error("SensorySystem not initialized!")
+
+        if state.government:
+            if state.injectable_sensory_dto and state.injectable_sensory_dto.tick == state.time:
+                state.government.update_sensory_data(state.injectable_sensory_dto)
+                state.logger.warning(
+                    f"INJECTED_SENSORY_DATA | Overrode sensory data for tick {state.time} with custom DTO.",
+                    extra={"tick": state.time, "tags": ["test_injection"]}
+                )
+            else:
+                state.government.update_sensory_data(sensory_dto)
+
+            # Government Policy Decision
+            latest_gdp = state.tracker.get_latest_indicators().get("total_production", 0.0)
+            market_data["total_production"] = latest_gdp
+            state.government.make_policy_decision(market_data, state.time, state.central_bank)
+
+            state.government.check_election(state.time)
+
+        # WO-146: Monetary Policy Manager Integration
+        # Ensure Central Bank updates its internal state (Potential GDP)
+        if state.central_bank and hasattr(state.central_bank, "step"):
+             state.central_bank.step(state.time)
+
+        # Apply Monetary Policy periodically to ensure stability (WO-146 Insight)
+        update_interval = getattr(state.config_module, "CB_UPDATE_INTERVAL", 10)
+
+        if state.time > 0 and state.time % update_interval == 0:
+            # Create MacroEconomicSnapshotDTO with macro indicators
+            latest_indicators = state.tracker.get_latest_indicators()
+            # Retrieve potential GDP from Central Bank if available
+            potential_gdp = 0.0
+            if state.central_bank and hasattr(state.central_bank, "potential_gdp"):
+                 potential_gdp = state.central_bank.potential_gdp
+
+            macro_snapshot = MacroEconomicSnapshotDTO(
+                 inflation_rate=latest_indicators.get("inflation_rate", 0.0),
+                 unemployment_rate=latest_indicators.get("unemployment_rate", 0.0),
+                 nominal_gdp=latest_indicators.get("total_production", 0.0),
+                 potential_gdp=potential_gdp
+            )
+
+            mp_policy = self.mp_manager.determine_monetary_stance(macro_snapshot)
+
+            if state.central_bank:
+                 state.central_bank.base_rate = mp_policy.target_interest_rate
+
+            if state.bank and hasattr(state.bank, "update_base_rate"):
+                 state.bank.update_base_rate(mp_policy.target_interest_rate)
+
+        # Events (Moved to end to ensure shocks overwrite policy decisions)
+        if self.world_state.event_system:
+             context: EventContext = {
+                 "households": state.households,
+                 "firms": state.firms,
+                 "markets": state.markets,
+                 "government": state.government,
+                 "central_bank": state.central_bank,
+                 "bank": state.bank
+             }
+             self.world_state.event_system.execute_scheduled_events(state.time, context, self.world_state.stress_scenario_config)
+
+        return state
diff --git a/simulation/orchestration/phases/production.py b/simulation/orchestration/phases/production.py
new file mode 100644
index 00000000..c32bd5e9
--- /dev/null
+++ b/simulation/orchestration/phases/production.py
@@ -0,0 +1,51 @@
+from __future__ import annotations
+from typing import TYPE_CHECKING
+import logging
+
+from simulation.orchestration.api import IPhaseStrategy
+from simulation.dtos.api import SimulationState
+
+if TYPE_CHECKING:
+    from simulation.world_state import WorldState
+
+logger = logging.getLogger(__name__)
+
+class Phase_Production(IPhaseStrategy):
+    """
+    Phase 0.5: Technology update and firm production.
+    Ensures firms have updated inventory before the Decision phase.
+    """
+    def __init__(self, world_state: WorldState):
+        self.world_state = world_state
+
+    def execute(self, state: SimulationState) -> SimulationState:
+        from simulation.systems.tech.api import FirmTechInfoDTO, HouseholdEducationDTO
+
+        # 1. Calculate Human Capital Index
+        active_households_dto = [
+            HouseholdEducationDTO(is_active=h._bio_state.is_active, education_level=getattr(h, 'education_level', 0))
+            for h in state.households if h._bio_state.is_active
+        ]
+
+        total_edu = sum(h['education_level'] for h in active_households_dto)
+        active_count = len(active_households_dto)
+        human_capital_index = total_edu / active_count if active_count > 0 else 1.0
+
+        # 2. Update Technology System
+        if self.world_state.technology_manager:
+            active_firms_dto = [
+                FirmTechInfoDTO(
+                    id=f.id,
+                    sector=f.sector,
+                    current_rd_investment=f.research_history.get("total_spent", 0.0) if hasattr(f, "research_history") else 0.0
+                )
+                for f in state.firms if f.is_active
+            ]
+            self.world_state.technology_manager.update(state.time, active_firms_dto, human_capital_index)
+
+        # 3. Trigger Firm Production
+        for firm in state.firms:
+            if firm.is_active:
+                firm.produce(state.time, technology_manager=self.world_state.technology_manager)
+
+        return state
diff --git a/simulation/orchestration/phases/taxation_intents.py b/simulation/orchestration/phases/taxation_intents.py
new file mode 100644
index 00000000..0224d75a
--- /dev/null
+++ b/simulation/orchestration/phases/taxation_intents.py
@@ -0,0 +1,30 @@
+from __future__ import annotations
+from typing import TYPE_CHECKING
+import logging
+
+from simulation.orchestration.api import IPhaseStrategy
+from simulation.dtos.api import SimulationState
+
+if TYPE_CHECKING:
+    from simulation.world_state import WorldState
+
+logger = logging.getLogger(__name__)
+
+class Phase_TaxationIntents(IPhaseStrategy):
+    """
+    Phase 4.6: Corporate Tax Intents
+    Generates tax obligations before final transaction processing.
+    """
+    def __init__(self, world_state: WorldState):
+        self.world_state = world_state
+
+    def execute(self, state: SimulationState) -> SimulationState:
+        # WO-116: Corporate Tax Intent Generation
+        if state.taxation_system and state.government:
+            tax_intents = state.taxation_system.generate_corporate_tax_intents(state.firms, current_tick=state.time)
+            for tx in tax_intents:
+                if tx.seller_id == "GOVERNMENT":
+                     tx.seller_id = state.government.id
+            if tax_intents:
+                state.transactions.extend(tax_intents)
+        return state
diff --git a/simulation/orchestration/phases/transaction.py b/simulation/orchestration/phases/transaction.py
new file mode 100644
index 00000000..31f6a84a
--- /dev/null
+++ b/simulation/orchestration/phases/transaction.py
@@ -0,0 +1,36 @@
+from __future__ import annotations
+from typing import TYPE_CHECKING
+import logging
+
+from simulation.orchestration.api import IPhaseStrategy
+from simulation.dtos.api import SimulationState
+
+if TYPE_CHECKING:
+    from simulation.world_state import WorldState
+
+logger = logging.getLogger(__name__)
+
+class Phase3_Transaction(IPhaseStrategy):
+    def __init__(self, world_state: WorldState):
+        self.world_state = world_state
+
+    def execute(self, state: SimulationState) -> SimulationState:
+        # Move system transactions from queue if any (e.g. from Bankruptcy phase)
+        if state.inter_tick_queue:
+            state.transactions.extend(state.inter_tick_queue)
+            state.inter_tick_queue.clear()
+
+        # WO-024: Monetary Transactions are now processed incrementally in TickOrchestrator._drain_and_sync_state (TD-177)
+        # Main transaction processing logic
+        if self.world_state.transaction_processor:
+            # TD-192: Pass combined transactions to ensure execution of drained (historic) and current items
+            combined_txs = list(self.world_state.transactions) + list(state.transactions)
+            results = self.world_state.transaction_processor.execute(state, transactions=combined_txs)
+
+            # WO-116: Record Revenue (Saga Pattern)
+            if state.taxation_system:
+                state.taxation_system.record_revenue(results)
+        else:
+            state.logger.error("TransactionProcessor not initialized.")
+
+        return state
diff --git a/simulation/systems/api.py b/simulation/systems/api.py
index f8ace053..46ffe2ea 100644
--- a/simulation/systems/api.py
+++ b/simulation/systems/api.py
@@ -66,6 +66,7 @@ class CommerceContext(TypedDict):
     market_data: Dict[str, Any]
     config: Any
     time: int
+    sales_tax_rate: float
 
 class LifecycleContext(TypedDict):
     """    ."""
diff --git a/simulation/systems/commerce_system.py b/simulation/systems/commerce_system.py
index 432e31c1..cce6d7ae 100644
--- a/simulation/systems/commerce_system.py
+++ b/simulation/systems/commerce_system.py
@@ -82,7 +82,7 @@ class CommerceSystem(ICommerceSystem):
                     price = batch_decisions.get('price', default_price)
 
                     # TD-231: Account for Sales Tax in affordability check
-                    tax_rate = getattr(self.config, 'SALES_TAX_RATE', 0.05)
+                    tax_rate = context.get('sales_tax_rate', 0.05)
                     price_with_tax = price * (1 + tax_rate)
 
                     if household._econ_state.assets < price_with_tax:
@@ -135,7 +135,7 @@ class CommerceSystem(ICommerceSystem):
 
                     else:
                         # Legacy Emergency Buy
-                        tax_rate = getattr(self.config, 'SALES_TAX_RATE', 0.05)
+                        tax_rate = context.get('sales_tax_rate', 0.05)
                         cost = b_amt * food_price * (1 + tax_rate) # TD-231: Include tax
 
                         if household._econ_state.assets >= cost:
diff --git a/simulation/systems/inheritance_manager.py b/simulation/systems/inheritance_manager.py
index 1f8572a0..253d958f 100644
--- a/simulation/systems/inheritance_manager.py
+++ b/simulation/systems/inheritance_manager.py
@@ -32,7 +32,7 @@ class InheritanceManager:
         """
         transactions: List[Transaction] = []
         current_tick = simulation.time
-        settlement_system = simulation.settlement_system
+        # settlement_system = simulation.settlement_system # TD-232: Removed direct dependency
 
         # 1. Valuation & Asset Gathering
         # ------------------------------------------------------------------
@@ -145,31 +145,31 @@ class InheritanceManager:
                         if needed <= 0:
                             break
 
-        # 3. Create Settlement Account (Freezing)
-        # ------------------------------------------------------------------
-        # Move remaining assets to Settlement Account
-        # Logic: We define them here, and clear them from Deceased.
-        account = settlement_system.create_settlement(
-            agent=deceased,
-            tick=current_tick
-        )
-
-        # ATOMIC CLEAR: Handled by create_settlement via IPortfolioHandler interface.
-        # RE units remaining in `deceased_units` still point to `deceased.id`.
+        # 3. TD-232: Removed explicit Settlement Account creation.
+        # Assets remain on Deceased agent until moved by TransactionProcessor.
 
-        # 4. Plan Distribution
+        # 4. Plan Distribution & Execution
         # ------------------------------------------------------------------
-        distribution_plan = [] # List[Tuple[Recipient, Amount, Memo, TxType]]
 
         # A. Tax
-        # If we have enough cash (from liquidation or original), pay tax.
-        # If not (e.g. liquidation failed or insufficient total wealth), pay what we have.
         tax_to_pay = min(cash, tax_amount)
         if tax_to_pay > 0:
-            distribution_plan.append((government, tax_to_pay, "inheritance_tax", "tax"))
-            cash -= tax_to_pay
-
-        # B. Heirs
+            tx = Transaction(
+                buyer_id=deceased.id, # Payer
+                seller_id=government.id, # Payee
+                item_id="inheritance_tax",
+                quantity=1.0,
+                price=tax_to_pay,
+                market_id="system",
+                transaction_type="tax",
+                time=current_tick
+            )
+            results = simulation.transaction_processor.execute(simulation.world_state, [tx])
+            if results and results[0].success:
+                transactions.append(tx)
+                cash -= tax_to_pay
+
+        # B. Heirs & Escheatment
         heirs = []
         for child_id in deceased._bio_state.children_ids:
             child = simulation.agents.get(child_id)
@@ -179,16 +179,24 @@ class InheritanceManager:
         if not heirs:
             # Escheatment (To Gov)
             if cash > 0:
-                distribution_plan.append((government, cash, "escheatment_cash", "escheatment"))
-            else:
-                # TD-160: Ensure Gov is in plan for portfolio transfer even if cash is 0
-                # SettlementSystem requires a recipient in the plan to trigger receive_portfolio
-                distribution_plan.append((government, 0.0, "escheatment_portfolio_trigger", "escheatment"))
-
-            # Escheat remaining Assets
-            # Portfolio Transfer is handled by SettlementSystem (Atomic).
+                # TD-232: Escheatment via TransactionProcessor
+                # Note: EscheatmentHandler transfers ALL assets.
+                # Since we already paid tax, remaining cash is escheated.
+                tx = Transaction(
+                    buyer_id=deceased.id,
+                    seller_id=government.id,
+                    item_id="escheatment",
+                    quantity=1.0,
+                    price=cash, # Used for record, handler takes all
+                    market_id="system",
+                    transaction_type="escheatment",
+                    time=current_tick
+                )
+                results = simulation.transaction_processor.execute(simulation.world_state, [tx])
+                if results and results[0].success:
+                    transactions.append(tx)
 
-            # Real Estate Transfer (Execute Synchronously)
+            # Escheat remaining Real Estate (Execute Synchronously)
             for unit in deceased_units:
                  tx = Transaction(
                         buyer_id=government.id,
@@ -209,18 +217,25 @@ class InheritanceManager:
 
         else:
             # Distribute to Heirs
-            # Equal Split for now
-            count = len(heirs)
+            # Cash & Portfolio via InheritanceHandler (Single Transaction)
             if cash > 0:
-                share_cash = cash / count
-                for heir in heirs:
-                    distribution_plan.append((heir, share_cash, "inheritance_distribution", "inheritance_distribution"))
-
-            # Distribute Assets
-            # Portfolio Transfer is handled by SettlementSystem (Atomic) to the designated heir (Primary).
-            # Note: This changes from equal split to single heir for portfolio assets to ensure atomicity.
+                tx = Transaction(
+                    buyer_id=deceased.id,
+                    seller_id=None, # System distribution
+                    item_id="estate_distribution",
+                    quantity=1.0,
+                    price=cash, # Informational
+                    market_id="system",
+                    transaction_type="inheritance_distribution",
+                    time=current_tick,
+                    metadata={"heir_ids": [h.id for h in heirs]}
+                )
+                results = simulation.transaction_processor.execute(simulation.world_state, [tx])
+                if results and results[0].success:
+                    transactions.append(tx)
 
             # Distribute Real Estate (Round Robin - Synchronous)
+            count = len(heirs)
             for i, unit in enumerate(deceased_units):
                 recipient = heirs[i % count]
 
@@ -241,21 +256,14 @@ class InheritanceManager:
                     tx.metadata["executed"] = True
                     transactions.append(tx)
 
-        # 5. Execute Settlement (Cash)
-        # ------------------------------------------------------------------
-        receipts = settlement_system.execute_settlement(account.deceased_agent_id, distribution_plan, current_tick)
-
-        # Convert dict receipts to Transaction objects
-        for receipt in receipts:
-            transactions.append(self._dict_to_transaction(receipt))
+        # 5. TD-232: Removed execute_settlement as we dispatched transactions directly.
 
-        # 6. Close
-        # ------------------------------------------------------------------
-        settlement_system.verify_and_close(account.deceased_agent_id, current_tick)
+        # 6. TD-232: Removed verify_and_close as no Settlement Account was created.
 
         return transactions
 
     def _dict_to_transaction(self, tx_dict: dict) -> Transaction:
+         # Deprecated but kept if needed by other methods not shown
          return Transaction(
              buyer_id=tx_dict["buyer_id"],
              seller_id=tx_dict["seller_id"],
diff --git a/tests/unit/test_phase1_refactor.py b/tests/unit/test_phase1_refactor.py
index ab380247..79564f1e 100644
--- a/tests/unit/test_phase1_refactor.py
+++ b/tests/unit/test_phase1_refactor.py
@@ -8,7 +8,7 @@ from modules.system.api import (
 )
 
 def create_mock_snapshot(time=100):
-    housing_snapshot = HousingMarketSnapshotDTO(for_sale_units=[], avg_rent_price=100.0, avg_sale_price=24000.0)
+    housing_snapshot = HousingMarketSnapshotDTO(for_sale_units=[], units_for_rent=[], avg_rent_price=100.0, avg_sale_price=24000.0)
     loan_snapshot = LoanMarketSnapshotDTO(interest_rate=0.05)
     labor_snapshot = LaborMarketSnapshotDTO(avg_wage=0.0)
 
@@ -27,12 +27,18 @@ class TestPhase1DecisionRefactor:
         world_state = MagicMock()
         state = MagicMock(spec=SimulationState)
         state.time = 100
+        state.tracker = MagicMock() # Mock tracker
+        state.stock_market = MagicMock() # Mock stock_market
+        state.stock_market.get_daily_avg_price.return_value = 10.0 # Return mock float
+        state.goods_data = {} # Mock goods_data
         state.markets = {"market1": MagicMock()}
+        state.real_estate_units = [] # Mock empty list
         state.firms = []
         state.households = []
         state.agents = {}
         state.government = MagicMock()
         state.bank = MagicMock()
+        state.central_bank = MagicMock()
         state.config_module = MagicMock()
         state.config_module.MACRO_PORTFOLIO_ADJUSTMENT_ENABLED = False
         state.config_module.SALES_TAX_RATE = 0.05
@@ -47,19 +53,14 @@ class TestPhase1DecisionRefactor:
         # Phase1_Decision instantiates factories in __init__
         # We need to mock them *after* instantiation or patch the classes
 
-        with patch('simulation.orchestration.phases.MarketSignalFactory') as MockSignalFactory, \
-             patch('simulation.orchestration.phases.DecisionInputFactory') as MockInputFactory, \
-             patch('simulation.orchestration.phases.MarketSnapshotFactory') as MockSnapshotFactory, \
-             patch('simulation.orchestration.phases.prepare_market_data') as mock_prepare_data:
+        with patch('simulation.orchestration.phases.decision.DecisionInputFactory') as MockInputFactory, \
+             patch('simulation.orchestration.phases.decision.MarketSnapshotFactory') as MockSnapshotFactory, \
+             patch('simulation.orchestration.phases.decision.prepare_market_data') as mock_prepare_data:
 
             mock_prepare_data.return_value = {}
 
             phase = Phase1_Decision(world_state)
 
-            # Setup factory returns
-            mock_signal_factory_instance = MockSignalFactory.return_value
-            mock_signal_factory_instance.create_market_signals.return_value = {"signal": "mock"}
-
             mock_snapshot_factory_instance = MockSnapshotFactory.return_value
             snapshot = create_mock_snapshot(state.time)
             mock_snapshot_factory_instance.create_snapshot.return_value = snapshot
@@ -73,11 +74,17 @@ class TestPhase1DecisionRefactor:
                 current_time=100
             )
 
+            # Note: We mocked MarketSnapshotFactory class, and Phase1_Decision instantiates it in __init__.
+            # So `phase.snapshot_factory` is the mock instance created during __init__.
+            # `MockSnapshotFactory.return_value` gives us that instance.
+            # We already set `mock_snapshot_factory_instance.create_snapshot.return_value = snapshot` above.
+
             # Execute
             phase.execute(state)
 
             # Verify Factory Calls
-            mock_snapshot_factory_instance.create_snapshot.assert_called_once_with(state)
+            # Use `phase.snapshot_factory` which is the actual mock instance used by the phase
+            phase.snapshot_factory.create_snapshot.assert_called_once_with(state)
             mock_input_factory_instance.create_decision_input.assert_called_once()
 
             # Verify market data preparation
@@ -93,9 +100,16 @@ class TestPhase1DecisionRefactor:
 
         state = MagicMock(spec=SimulationState)
         state.time = 100
+        state.tracker = MagicMock() # Mock tracker
+        state.stock_market = MagicMock() # Mock stock_market
+        state.stock_market.get_daily_avg_price.return_value = 10.0 # Return mock float
+        state.bank = MagicMock() # Mock bank
+        state.goods_data = {} # Mock goods_data
         state.markets = {}
+        state.real_estate_units = [] # Mock empty list
         state.agents = {}
         state.government = MagicMock()
+        state.central_bank = MagicMock()
         state.config_module = MagicMock()
         state.config_module.MAX_WORK_HOURS = 10.0
         state.config_module.HOURS_PER_TICK = 24.0
@@ -114,10 +128,9 @@ class TestPhase1DecisionRefactor:
         state.firms = [firm]
         state.households = [household]
 
-        with patch('simulation.orchestration.phases.MarketSignalFactory'), \
-             patch('simulation.orchestration.phases.DecisionInputFactory') as MockInputFactory, \
-             patch('simulation.orchestration.phases.MarketSnapshotFactory') as MockSnapshotFactory, \
-             patch('simulation.orchestration.phases.prepare_market_data', return_value={}):
+        with patch('simulation.orchestration.phases.decision.DecisionInputFactory') as MockInputFactory, \
+             patch('simulation.orchestration.phases.decision.MarketSnapshotFactory') as MockSnapshotFactory, \
+             patch('simulation.orchestration.phases.decision.prepare_market_data', return_value={}):
 
             phase = Phase1_Decision(world_state)
 
