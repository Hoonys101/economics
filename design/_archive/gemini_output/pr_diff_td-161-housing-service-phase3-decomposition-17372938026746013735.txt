diff --git a/communications/insights/TD-161_Architecture_Refactoring.md b/communications/insights/TD-161_Architecture_Refactoring.md
new file mode 100644
index 0000000..70d6b45
--- /dev/null
+++ b/communications/insights/TD-161_Architecture_Refactoring.md
@@ -0,0 +1,35 @@
+# Insight: TD-161 & TD-205 Architecture Refactoring
+
+## Overview
+This mission focused on critical architectural refactoring to enforce Single Responsibility Principle (SRP) and purify data models.
+
+## Completed Tasks
+1.  **HousingService Extraction (TD-161, TD-204)**
+    -   Defined `IHousingService` in `modules/housing/api.py`.
+    -   Implemented `HousingService` in `modules/housing/service.py`, encapsulating housing-specific logic (liens, contracts, ownership).
+    -   Refactored `Registry` (`simulation/systems/registry.py`) to delegate housing operations to `HousingService` via dependency injection.
+    -   Updated `SimulationInitializer` to instantiate and inject `HousingService`.
+
+2.  **Phase3_Transaction Decomposition (TD-205)**
+    -   Decomposed the monolithic `Phase3_Transaction` into granular phases:
+        -   `Phase_BankAndDebt`: Bank ticks and debt service.
+        -   `Phase_FirmProductionAndSalaries`: Firm transactions.
+        -   `Phase_GovernmentPrograms`: Welfare, infrastructure, education.
+        -   `Phase_TaxationIntents`: Corporate tax intents.
+    -   Updated `TickOrchestrator` to execute these phases in sequence.
+    -   Retained `Phase3_Transaction` solely for transaction processing and cleanup.
+
+3.  **RealEstateUnit Purification (TD-161)**
+    -   Removed business logic (`is_under_contract`, `_registry_dependency`) from `RealEstateUnit` (`simulation/models.py`), making it a pure data object.
+    -   Updated `HousingTransactionSagaHandler` to interact with `HousingService` instead of `Registry` for housing operations.
+
+## Technical Debt & Observations
+-   **Registry Legacy**: `Registry` still handles labor, goods, and stock logic. Future refactoring should extract these into respective services (e.g., `LaborService`, `MarketRegistry`).
+-   **Module Boundaries**: `HousingTransactionSagaHandler` (in `finance`) directly depends on `HousingService` (in `housing`). This dependency direction is acceptable but highlights the coupling between Finance and Housing domains.
+-   **Test Coverage**: While unit tests for `HousingService` and `RealEstateUnit` were updated/created, comprehensive integration tests for the full housing saga flow with the new service would be beneficial to ensure robustness against edge cases.
+-   **Phase Order**: The strict sequence of phases in `TickOrchestrator` is critical. Any future changes to phase ordering must be carefully validated against dependencies (e.g., firms need market data from previous tick, tax intents depend on firm profits).
+
+## Impact
+-   **Modularity**: Housing logic is now centralized, reducing the complexity of the "God Class" Registry.
+-   **Maintainability**: Smaller, focused phases make the orchestration logic easier to understand and debug.
+-   **Testability**: `HousingService` can be tested in isolation, and pure `RealEstateUnit` simplifies model testing.
diff --git a/modules/finance/saga_handler.py b/modules/finance/saga_handler.py
index 316c921..dc82564 100644
--- a/modules/finance/saga_handler.py
+++ b/modules/finance/saga_handler.py
@@ -21,7 +21,7 @@ class HousingTransactionSagaHandler(IHousingTransactionSagaHandler):
         self.simulation = simulation
         self.settlement_system: ISettlementSystem = simulation.settlement_system
         # Note: Registry in simulation must implement IPropertyRegistry methods
-        self.registry = simulation.registry
+        self.housing_service = simulation.housing_service
         self.loan_market = simulation.markets.get("loan")
 
     def execute_step(self, saga: HousingTransactionSagaStateDTO) -> HousingTransactionSagaStateDTO:
@@ -71,8 +71,8 @@ class HousingTransactionSagaHandler(IHousingTransactionSagaHandler):
             if saga.get('mortgage_approval'):
                  # Remove Lien
                  lien_id = saga['mortgage_approval']['lien_id']
-                 if hasattr(self.registry, 'remove_lien'):
-                    self.registry.remove_lien(saga['property_id'], lien_id)
+                 if hasattr(self.housing_service, 'remove_lien'):
+                    self.housing_service.remove_lien(saga['property_id'], lien_id)
 
                  # Void Loan
                  loan_id = saga['mortgage_approval']['loan_id']
@@ -85,8 +85,8 @@ class HousingTransactionSagaHandler(IHousingTransactionSagaHandler):
                     self.loan_market.void_staged_application(saga['staged_loan_id'])
 
             # 4. Release Property Lock
-            if hasattr(self.registry, 'release_contract'):
-                self.registry.release_contract(saga['property_id'], saga['saga_id'])
+            if hasattr(self.housing_service, 'release_contract'):
+                self.housing_service.release_contract(saga['property_id'], saga['saga_id'])
 
             saga['status'] = "FAILED_ROLLED_BACK"
 
@@ -98,8 +98,8 @@ class HousingTransactionSagaHandler(IHousingTransactionSagaHandler):
 
     def _handle_initiated(self, saga: HousingTransactionSagaStateDTO) -> HousingTransactionSagaStateDTO:
         # 1. Lock Property
-        if hasattr(self.registry, 'set_under_contract'):
-             success = self.registry.set_under_contract(saga['property_id'], saga['saga_id'])
+        if hasattr(self.housing_service, 'set_under_contract'):
+             success = self.housing_service.set_under_contract(saga['property_id'], saga['saga_id'])
              if not success:
                  saga['error_message'] = "Property already under contract"
                  # Can't rollback lock if we didn't get it, but compensate handles cleanup
@@ -179,7 +179,7 @@ class HousingTransactionSagaHandler(IHousingTransactionSagaHandler):
         # LoanInfo might not have it, but we know it's the Bank.
         bank_id = self.simulation.bank.id if self.simulation.bank else -1
 
-        lien_id = self.registry.add_lien(saga['property_id'], loan_id, bank_id, principal)
+        lien_id = self.housing_service.add_lien(saga['property_id'], loan_id, bank_id, principal)
         if not lien_id:
              saga['error_message'] = "Failed to create lien"
              return self.compensate_step(saga)
@@ -234,7 +234,7 @@ class HousingTransactionSagaHandler(IHousingTransactionSagaHandler):
 
     def _handle_transfer_title(self, saga: HousingTransactionSagaStateDTO) -> HousingTransactionSagaStateDTO:
         # Finalize Ownership
-        success = self.registry.transfer_ownership(saga['property_id'], saga['buyer_id'])
+        success = self.housing_service.transfer_ownership(saga['property_id'], saga['buyer_id'])
 
         if success:
              self._log_transaction(saga)
@@ -243,7 +243,7 @@ class HousingTransactionSagaHandler(IHousingTransactionSagaHandler):
              # Draft: "Call PropertyRegistry.transfer_ownership... Transition to COMPLETED."
              # Usually ownership transfer overrides contract lock or lock is ignored for new owner.
              # But good hygiene: release lock.
-             self.registry.release_contract(saga['property_id'], saga['saga_id'])
+             self.housing_service.release_contract(saga['property_id'], saga['saga_id'])
 
              saga['status'] = "COMPLETED"
         else:
diff --git a/modules/housing/api.py b/modules/housing/api.py
index 59bd9a5..8ce20da 100644
--- a/modules/housing/api.py
+++ b/modules/housing/api.py
@@ -1,6 +1,14 @@
 from abc import ABC, abstractmethod
+from typing import Optional, TYPE_CHECKING, List, Any
+from uuid import UUID
+
+from modules.finance.api import LienDTO
 from modules.housing.dtos import HousingDecisionRequestDTO, HousingDecisionDTO, HousingTransactionSagaStateDTO
 
+if TYPE_CHECKING:
+    from simulation.dtos.api import SimulationState
+    from simulation.models import Transaction
+
 class IHousingPlanner(ABC):
     """
     Stateless interface for making a high-level housing recommendation.
@@ -26,3 +34,54 @@ class IHousingTransactionSagaHandler(ABC):
         via the SettlementSystem, including rollbacks.
         """
         ...
+
+class IHousingService(ABC):
+    """
+    Manages the lifecycle and state of all real estate and housing units.
+    This service is the single source of truth for ownership, liens,
+    and contractual status of properties.
+    """
+
+    @abstractmethod
+    def set_real_estate_units(self, units: List[Any]) -> None:
+        """Sets the reference to the list of real estate units."""
+        ...
+
+    @abstractmethod
+    def process_transaction(self, tx: "Transaction", state: "SimulationState") -> None:
+        """
+        Primary entry point to process a housing-related transaction and update
+        the state of real estate units, owners, and occupants.
+        This replaces the logic previously in Registry._handle_housing_registry.
+        """
+        ...
+
+    @abstractmethod
+    def is_under_contract(self, property_id: int) -> bool:
+        """Checks if a property is currently locked by a purchase saga."""
+        ...
+
+    @abstractmethod
+    def set_under_contract(self, property_id: int, saga_id: UUID) -> bool:
+        """Locks a property for a purchase saga."""
+        ...
+
+    @abstractmethod
+    def release_contract(self, property_id: int, saga_id: UUID) -> bool:
+        """Releases a property lock from a purchase saga."""
+        ...
+
+    @abstractmethod
+    def add_lien(self, property_id: int, loan_id: str, lienholder_id: int, principal: float) -> Optional[str]:
+        """Adds a lien (e.g., a mortgage) to a property."""
+        ...
+
+    @abstractmethod
+    def remove_lien(self, property_id: int, lien_id: str) -> bool:
+        """Removes a lien from a property."""
+        ...
+
+    @abstractmethod
+    def transfer_ownership(self, property_id: int, new_owner_id: int) -> bool:
+        """Transfers ownership of a property."""
+        ...
diff --git a/modules/housing/service.py b/modules/housing/service.py
new file mode 100644
index 0000000..26f710a
--- /dev/null
+++ b/modules/housing/service.py
@@ -0,0 +1,173 @@
+from typing import Optional, List, Any, Dict, TYPE_CHECKING
+from uuid import UUID
+import logging
+
+from modules.housing.api import IHousingService
+from modules.finance.api import LienDTO
+
+if TYPE_CHECKING:
+    from simulation.dtos.api import SimulationState
+    from simulation.models import Transaction
+    from simulation.core_agents import Household
+
+logger = logging.getLogger(__name__)
+
+class HousingService(IHousingService):
+    def __init__(self, logger: Optional[logging.Logger] = None):
+        self.logger = logger if logger else logging.getLogger(__name__)
+        self.contract_locks: Dict[int, UUID] = {}
+        self.real_estate_units: List[Any] = []
+
+    def set_real_estate_units(self, units: List[Any]) -> None:
+        self.real_estate_units = units
+
+    def is_under_contract(self, property_id: int) -> bool:
+        return property_id in self.contract_locks
+
+    def set_under_contract(self, property_id: int, saga_id: UUID) -> bool:
+        if property_id in self.contract_locks:
+             return False
+        self.contract_locks[property_id] = saga_id
+        return True
+
+    def release_contract(self, property_id: int, saga_id: UUID) -> bool:
+        if self.contract_locks.get(property_id) == saga_id:
+             del self.contract_locks[property_id]
+             return True
+        return False
+
+    def add_lien(self, property_id: int, loan_id: str, lienholder_id: int, principal: float) -> Optional[str]:
+        unit = next((u for u in self.real_estate_units if u.id == property_id), None)
+        if not unit:
+             return None
+
+        if any(l['loan_id'] == loan_id for l in unit.liens):
+             return f"lien_{loan_id}"
+
+        lien_id = f"lien_{loan_id}"
+        new_lien: LienDTO = {
+            "loan_id": loan_id,
+            "lienholder_id": lienholder_id,
+            "principal_remaining": principal,
+            "lien_type": "MORTGAGE"
+        }
+        unit.liens.append(new_lien)
+        return lien_id
+
+    def remove_lien(self, property_id: int, lien_id: str) -> bool:
+        unit = next((u for u in self.real_estate_units if u.id == property_id), None)
+        if not unit:
+             return False
+
+        original_len = len(unit.liens)
+        unit.liens = [l for l in unit.liens if f"lien_{l['loan_id']}" != lien_id and l['loan_id'] != lien_id]
+
+        return len(unit.liens) < original_len
+
+    def transfer_ownership(self, property_id: int, new_owner_id: int) -> bool:
+        unit = next((u for u in self.real_estate_units if u.id == property_id), None)
+        if not unit:
+             return False
+        unit.owner_id = new_owner_id
+        return True
+
+    def process_transaction(self, tx: "Transaction", state: "SimulationState") -> None:
+        tx_type = tx.transaction_type
+        item_id = tx.item_id
+
+        if item_id.startswith("real_estate_"):
+             self._handle_real_estate_registry(tx, state)
+        elif tx_type == "housing" or item_id.startswith("unit_"):
+             self._handle_housing_registry(tx, state)
+        else:
+             self.logger.warning(f"HOUSING_SERVICE | Unknown transaction format: {tx_type}, {item_id}")
+
+    def _handle_real_estate_registry(self, tx: "Transaction", state: "SimulationState"):
+        buyer_id = tx.buyer_id
+        seller_id = tx.seller_id
+
+        try:
+            # real_estate_{id}
+            unit_id = int(tx.item_id.split("_")[2])
+            unit = next((u for u in self.real_estate_units if u.id == unit_id), None)
+
+            # Resolve agents from state.agents dictionary
+            buyer = state.agents.get(buyer_id)
+            seller = state.agents.get(seller_id)
+
+            if unit and buyer:
+                unit.owner_id = buyer.id
+
+                if seller:
+                     if hasattr(seller, "owned_properties") and unit_id in seller.owned_properties:
+                          seller.owned_properties.remove(unit_id)
+
+                if hasattr(buyer, "owned_properties"):
+                     buyer.owned_properties.append(unit_id)
+
+                self.logger.info(f"RE_TX | Unit {unit_id} transferred from {seller_id} to {buyer.id}")
+
+        except (IndexError, ValueError) as e:
+            self.logger.error(f"RE_TX_FAIL | Invalid item_id format: {tx.item_id}. Error: {e}")
+
+    def _handle_housing_registry(self, tx: "Transaction", state: "SimulationState"):
+        buyer = state.agents.get(tx.buyer_id)
+        seller = state.agents.get(tx.seller_id)
+
+        try:
+            # item_id format: "unit_{id}"
+            unit_id = int(tx.item_id.split("_")[1])
+            unit = next((u for u in self.real_estate_units if u.id == unit_id), None)
+
+            if not unit:
+                self.logger.warning(f"HOUSING_REGISTRY | Unit {unit_id} not found.")
+                return
+
+            # Update Unit
+            unit.owner_id = tx.buyer_id
+            # Update Liens - Remove old mortgages if any (assuming refinancing or fresh purchase clears old mortgage)
+            # Logic from Registry:
+            unit.liens = [lien for lien in unit.liens if lien['lien_type'] != 'MORTGAGE']
+
+            if tx.metadata and "mortgage_id" in tx.metadata and tx.metadata["mortgage_id"]:
+                loan_id = str(tx.metadata["mortgage_id"])
+                loan_principal = float(tx.metadata.get("loan_principal", 0.0))
+                lender_id = int(tx.metadata.get("lender_id", 0))
+
+                new_lien: LienDTO = {
+                    "loan_id": loan_id,
+                    "lienholder_id": lender_id,
+                    "principal_remaining": loan_principal,
+                    "lien_type": "MORTGAGE"
+                }
+                unit.liens.append(new_lien)
+
+            # Update Seller (if not None/Govt)
+            if seller:
+                if hasattr(seller, "owned_properties"):
+                    if unit_id in seller.owned_properties:
+                        seller.owned_properties.remove(unit_id)
+
+            # Update Buyer
+            if buyer:
+                if hasattr(buyer, "owned_properties"):
+                    if unit_id not in buyer.owned_properties:
+                        buyer.owned_properties.append(unit_id)
+
+                # Housing System Logic: Auto-move-in if homeless
+                from simulation.core_agents import Household
+                if isinstance(buyer, Household):
+                    if buyer.residing_property_id is None:
+                        unit.occupant_id = buyer.id
+                        buyer.residing_property_id = unit_id
+                        buyer.is_homeless = False
+                elif hasattr(buyer, "residing_property_id"):
+                     if getattr(buyer, "residing_property_id", None) is None:
+                        unit.occupant_id = buyer.id
+                        buyer.residing_property_id = unit_id
+                        buyer.is_homeless = False
+
+            self.logger.info(f"HOUSING_REGISTRY | Unit {unit_id} transferred from {tx.seller_id} to {tx.buyer_id}")
+
+        except (IndexError, ValueError) as e:
+            self.logger.error(f"HOUSING_REGISTRY_FAIL | Invalid item_id format: {tx.item_id}. Error: {e}")
diff --git a/modules/simulation/api.py b/modules/simulation/api.py
index 83299ca..165d825 100644
--- a/modules/simulation/api.py
+++ b/modules/simulation/api.py
@@ -7,6 +7,7 @@ if TYPE_CHECKING:
     from simulation.systems.api import IRegistry
     from modules.finance.api import IBankService
     from simulation.interfaces.market_interface import IMarket
+    from modules.housing.api import IHousingService
 
 # --- DTOs ---
 
@@ -75,6 +76,7 @@ class ISimulationState(Protocol):
     time: int
     settlement_system: "ISettlementSystem"
     registry: "IRegistry"
+    housing_service: "IHousingService"
     agents: Dict[int, IAgent]
     bank: "IBankService"
     markets: Dict[str, "IMarket"]
diff --git a/simulation/initialization/initializer.py b/simulation/initialization/initializer.py
index 165f9b9..3155356 100644
--- a/simulation/initialization/initializer.py
+++ b/simulation/initialization/initializer.py
@@ -52,6 +52,7 @@ from simulation.systems.handlers.labor_handler import LaborTransactionHandler
 from simulation.systems.handlers.stock_handler import StockTransactionHandler
 from simulation.systems.handlers.asset_transfer_handler import AssetTransferHandler
 from modules.market.handlers.housing_transaction_handler import HousingTransactionHandler
+from modules.housing.service import HousingService
 from simulation.systems.handlers.inheritance_handler import InheritanceHandler
 from simulation.systems.handlers.monetary_handler import MonetaryTransactionHandler
 from simulation.systems.handlers.financial_handler import FinancialTransactionHandler
@@ -387,8 +388,12 @@ class SimulationInitializer(SimulationInitializerInterface):
         sim.generational_wealth_audit = GenerationalWealthAudit(config_module=self.config)
         sim.breeding_planner = VectorizedHouseholdPlanner(self.config)
 
+        # TD-161: Initialize HousingService
+        sim.housing_service = HousingService(logger=self.logger)
+        sim.housing_service.set_real_estate_units(sim.real_estate_units)
+
         # WO-124: Initialize Legacy Components (kept for compatibility)
-        sim.registry = Registry(logger=self.logger)
+        sim.registry = Registry(housing_service=sim.housing_service, logger=self.logger)
         sim.accounting_system = AccountingSystem(logger=self.logger)
         sim.central_bank_system = CentralBankSystem(
             central_bank_agent=sim.central_bank,
diff --git a/simulation/models.py b/simulation/models.py
index f507646..124cde0 100644
--- a/simulation/models.py
+++ b/simulation/models.py
@@ -4,9 +4,6 @@ import uuid
 from modules.market.api import OrderDTO
 from modules.finance.api import LienDTO
 
-if TYPE_CHECKING:
-    from modules.finance.api import IRealEstateRegistry
-
 # Alias for backward compatibility and migration
 Order = OrderDTO
 
@@ -62,9 +59,6 @@ class RealEstateUnit:
     # New field for tracking all liens against the property
     liens: List[LienDTO] = field(default_factory=list)
 
-    # Dependency for is_under_contract
-    _registry_dependency: Optional["IRealEstateRegistry"] = field(default=None, repr=False, compare=False, hash=False)
-
     @property
     def mortgage_id(self) -> Optional[str]:
         """
@@ -77,17 +71,6 @@ class RealEstateUnit:
                 return str(lien['loan_id'])
         return None
 
-    @property
-    def is_under_contract(self) -> bool:
-        """
-        Derived property to check if the unit is in a pending transaction.
-        Delegates the check to the Real Estate Registry, which queries the
-        Saga state, ensuring a single source of truth.
-        """
-        if self._registry_dependency:
-            return self._registry_dependency.is_under_contract(self.id)
-        return False
-
 @dataclass
 class Talent:
     """가계의 선천적 재능을 나타내는 클래스입니다."""
diff --git a/simulation/orchestration/phases.py b/simulation/orchestration/phases.py
index c010608..c47ec97 100644
--- a/simulation/orchestration/phases.py
+++ b/simulation/orchestration/phases.py
@@ -458,20 +458,41 @@ class Phase_HousingSaga(IPhaseStrategy):
         return state
 
 
-class Phase3_Transaction(IPhaseStrategy):
+class Phase_BankAndDebt(IPhaseStrategy):
+    """
+    Phase 4.2: Bank & Debt Service
+    Handles bank interest/fees and agent debt servicing.
+    """
     def __init__(self, world_state: WorldState):
         self.world_state = world_state
 
     def execute(self, state: SimulationState) -> SimulationState:
-        system_transactions = []
-        system_transactions.extend(state.inter_tick_queue)
-        state.inter_tick_queue.clear()
-
+        # 1. Bank Tick
         if state.bank and hasattr(state.bank, "run_tick"):
             bank_txs = state.bank.run_tick(state.agents, state.time)
-            system_transactions.extend(bank_txs)
+            if bank_txs:
+                state.transactions.extend(bank_txs)
 
+        # 2. Debt Service
+        if self.world_state.finance_system:
+             debt_txs = self.world_state.finance_system.service_debt(state.time)
+             if debt_txs:
+                 state.transactions.extend(debt_txs)
+
+        return state
+
+class Phase_FirmProductionAndSalaries(IPhaseStrategy):
+    """
+    Phase 4.3: Firm Operations (Transactions)
+    Handles core firm operations like paying salaries.
+    Note: Production logic is in Phase_Production, this is for financial transactions.
+    """
+    def __init__(self, world_state: WorldState):
+        self.world_state = world_state
+
+    def execute(self, state: SimulationState) -> SimulationState:
         market_data_prev = state.market_data
+
         for firm in state.firms:
              if firm.is_active:
                  firm_txs = firm.generate_transactions(
@@ -480,42 +501,69 @@ class Phase3_Transaction(IPhaseStrategy):
                      all_households=state.households,
                      current_time=state.time
                  )
-                 system_transactions.extend(firm_txs)
+                 if firm_txs:
+                     state.transactions.extend(firm_txs)
+        return state
 
-        if self.world_state.finance_system:
-             debt_txs = self.world_state.finance_system.service_debt(state.time)
-             system_transactions.extend(debt_txs)
+class Phase_GovernmentPrograms(IPhaseStrategy):
+    """
+    Phase 4.4: Government Spending Programs
+    """
+    def __init__(self, world_state: WorldState):
+        self.world_state = world_state
+
+    def execute(self, state: SimulationState) -> SimulationState:
+        market_data_prev = state.market_data
 
         if state.government:
+            # Welfare
             welfare_txs = state.government.run_welfare_check(list(state.agents.values()), market_data_prev, state.time)
-            system_transactions.extend(welfare_txs)
+            if welfare_txs:
+                state.transactions.extend(welfare_txs)
 
+            # Infrastructure
             infra_txs = state.government.invest_infrastructure(state.time, state.households)
             if infra_txs:
-                system_transactions.extend(infra_txs)
+                state.transactions.extend(infra_txs)
 
+            # Education
             edu_txs = state.government.run_public_education(state.households, state.config_module, state.time)
             if edu_txs:
-                system_transactions.extend(edu_txs)
+                state.transactions.extend(edu_txs)
 
-        state.transactions.extend(system_transactions)
-
-        # WO-024: Monetary Transactions are now processed incrementally in TickOrchestrator._drain_and_sync_state (TD-177)
+        return state
 
-        # REMOVED: Housing Saga Processing (Atomic V3) - Moved to Phase_HousingSaga
+class Phase_TaxationIntents(IPhaseStrategy):
+    """
+    Phase 4.6: Corporate Tax Intents
+    Generates tax obligations before final transaction processing.
+    """
+    def __init__(self, world_state: WorldState):
+        self.world_state = world_state
 
+    def execute(self, state: SimulationState) -> SimulationState:
         # WO-116: Corporate Tax Intent Generation
         if state.taxation_system and state.government:
             tax_intents = state.taxation_system.generate_corporate_tax_intents(state.firms, current_tick=state.time)
             for tx in tax_intents:
                 if tx.seller_id == "GOVERNMENT":
                      tx.seller_id = state.government.id
-            system_transactions.extend(tax_intents)
+            if tax_intents:
+                state.transactions.extend(tax_intents)
+        return state
+
+class Phase3_Transaction(IPhaseStrategy):
+    def __init__(self, world_state: WorldState):
+        self.world_state = world_state
 
-        state.transactions.extend(system_transactions)
+    def execute(self, state: SimulationState) -> SimulationState:
+        # Move system transactions from queue if any (e.g. from Bankruptcy phase)
+        if state.inter_tick_queue:
+            state.transactions.extend(state.inter_tick_queue)
+            state.inter_tick_queue.clear()
 
         # WO-024: Monetary Transactions are now processed incrementally in TickOrchestrator._drain_and_sync_state (TD-177)
-
+        # Main transaction processing logic
         if self.world_state.transaction_processor:
             # TD-192: Pass combined transactions to ensure execution of drained (historic) and current items
             combined_txs = list(self.world_state.transactions) + list(state.transactions)
diff --git a/simulation/orchestration/tick_orchestrator.py b/simulation/orchestration/tick_orchestrator.py
index 74f6146..3a8f82a 100644
--- a/simulation/orchestration/tick_orchestrator.py
+++ b/simulation/orchestration/tick_orchestrator.py
@@ -5,7 +5,8 @@ import logging
 from simulation.dtos.api import SimulationState, GovernmentStateDTO
 from simulation.orchestration.phases import (
     Phase0_PreSequence, Phase_Production, Phase1_Decision, Phase2_Matching,
-    Phase3_Transaction, Phase_Bankruptcy, Phase_HousingSaga, Phase_Consumption, Phase5_PostSequence
+    Phase3_Transaction, Phase_Bankruptcy, Phase_HousingSaga, Phase_Consumption, Phase5_PostSequence,
+    Phase_BankAndDebt, Phase_FirmProductionAndSalaries, Phase_GovernmentPrograms, Phase_TaxationIntents
 )
 from simulation.orchestration.utils import prepare_market_data
 from simulation.orchestration.phases_recovery import Phase_SystemicLiquidation
@@ -31,7 +32,14 @@ class TickOrchestrator:
             Phase_HousingSaga(world_state),          # Phase 4.1: Advance Housing Sagas
             Phase_SystemicLiquidation(world_state),  # Phase 4.5 (Spec): Systemic Liquidation
             Phase2_Matching(world_state),            # Phase 5 (Spec): Matching
-            Phase3_Transaction(world_state),
+
+            # --- Decomposed Phase 3 ---
+            Phase_BankAndDebt(world_state),
+            Phase_FirmProductionAndSalaries(world_state),
+            Phase_GovernmentPrograms(world_state),
+            Phase_TaxationIntents(world_state),
+            Phase3_Transaction(world_state),         # Transaction Processing & Cleanup
+
             Phase_Consumption(world_state),          # Late Lifecycle (Consumption Finalization)
             Phase5_PostSequence(world_state)
         ]
diff --git a/simulation/systems/registry.py b/simulation/systems/registry.py
index a9231b2..d4e478e 100644
--- a/simulation/systems/registry.py
+++ b/simulation/systems/registry.py
@@ -7,6 +7,7 @@ from simulation.models import Transaction
 from simulation.core_agents import Household, Skill
 from simulation.firms import Firm
 from simulation.dtos.api import SimulationState
+from modules.housing.api import IHousingService
 
 logger = logging.getLogger(__name__)
 
@@ -14,67 +15,16 @@ class Registry(IRegistry):
     """
     Updates non-financial state: Ownership, Inventory, Employment, Contracts.
     Extracted from TransactionProcessor.
+    Refactored to delegate housing logic to HousingService.
     """
 
-    def __init__(self, logger: Optional[logging.Logger] = None):
+    def __init__(self, housing_service: Optional[IHousingService] = None, logger: Optional[logging.Logger] = None):
         self.logger = logger if logger else logging.getLogger(__name__)
-        self.contract_locks: Dict[int, UUID] = {}
-        self.real_estate_units: List[Any] = []
+        self.housing_service = housing_service
 
     def set_real_estate_units(self, units: List[Any]) -> None:
-        self.real_estate_units = units
-
-    def is_under_contract(self, property_id: int) -> bool:
-        return property_id in self.contract_locks
-
-    def set_under_contract(self, property_id: int, saga_id: UUID) -> bool:
-        if property_id in self.contract_locks:
-             return False
-        self.contract_locks[property_id] = saga_id
-        return True
-
-    def release_contract(self, property_id: int, saga_id: UUID) -> bool:
-        if self.contract_locks.get(property_id) == saga_id:
-             del self.contract_locks[property_id]
-             return True
-        return False
-
-    def add_lien(self, property_id: int, loan_id: str, lienholder_id: int, principal: float) -> Optional[str]:
-        unit = next((u for u in self.real_estate_units if u.id == property_id), None)
-        if not unit:
-             return None
-
-        # Check if already has this loan lien
-        if any(l['loan_id'] == loan_id for l in unit.liens):
-             return f"lien_{loan_id}"
-
-        lien_id = f"lien_{loan_id}"
-        new_lien: LienDTO = {
-            "loan_id": loan_id,
-            "lienholder_id": lienholder_id,
-            "principal_remaining": principal,
-            "lien_type": "MORTGAGE"
-        }
-        unit.liens.append(new_lien)
-        return lien_id
-
-    def remove_lien(self, property_id: int, lien_id: str) -> bool:
-        unit = next((u for u in self.real_estate_units if u.id == property_id), None)
-        if not unit:
-             return False
-
-        original_len = len(unit.liens)
-        # Remove if lien_id matches generated ID or raw loan_id
-        unit.liens = [l for l in unit.liens if f"lien_{l['loan_id']}" != lien_id and l['loan_id'] != lien_id]
-
-        return len(unit.liens) < original_len
-
-    def transfer_ownership(self, property_id: int, new_owner_id: int) -> bool:
-        unit = next((u for u in self.real_estate_units if u.id == property_id), None)
-        if not unit:
-             return False
-        unit.owner_id = new_owner_id
-        return True
+        if self.housing_service:
+            self.housing_service.set_real_estate_units(units)
 
     def update_ownership(self, transaction: Transaction, buyer: Any, seller: Any, state: SimulationState) -> None:
         """
@@ -91,12 +41,11 @@ class Registry(IRegistry):
         elif tx_type == "stock":
             self._handle_stock_registry(transaction, buyer, seller, state.stock_market, state.time)
 
-        elif tx_type.startswith("real_estate_") or tx_type == "housing": # transaction_type might be 'asset_transfer' or 'housing'
-            # Check item_id for real_estate prefix if type is generic asset_transfer
-            if transaction.item_id.startswith("real_estate_"):
-                self._handle_real_estate_registry(transaction, buyer, seller, state.real_estate_units, state.time)
-            elif tx_type == "housing":
-                self._handle_housing_registry(transaction, buyer, seller, state.real_estate_units, state.time)
+        elif tx_type.startswith("real_estate_") or tx_type == "housing":
+             if self.housing_service:
+                 self.housing_service.process_transaction(transaction, state)
+             else:
+                 self.logger.error("Registry: HousingService not initialized but housing transaction received.")
 
         elif tx_type == "emergency_buy":
              self._handle_emergency_buy(transaction, buyer)
@@ -105,7 +54,10 @@ class Registry(IRegistry):
              if transaction.item_id.startswith("stock_"):
                  self._handle_stock_registry(transaction, buyer, seller, state.stock_market, state.time)
              elif transaction.item_id.startswith("real_estate_"):
-                 self._handle_real_estate_registry(transaction, buyer, seller, state.real_estate_units, state.time)
+                 if self.housing_service:
+                     self.housing_service.process_transaction(transaction, state)
+                 else:
+                     self.logger.error("Registry: HousingService not initialized but real_estate transaction received.")
 
     def _handle_labor_registry(self, tx: Transaction, buyer: Any, seller: Any, state: SimulationState):
         """Updates employment status and employer/employee lists."""
@@ -229,95 +181,6 @@ class Registry(IRegistry):
             else:
                 stock_market.update_shareholder(seller.id, firm_id, 0.0)
 
-    def _handle_real_estate_registry(self, tx: Transaction, buyer: Any, seller: Any, real_estate_units: List[Any], current_time: int):
-        """Updates real estate ownership."""
-        try:
-            unit_id = int(tx.item_id.split("_")[2])
-            unit = next((u for u in real_estate_units if u.id == unit_id), None)
-            if unit:
-                unit.owner_id = buyer.id
-                # Update seller/buyer lists if they exist
-                if isinstance(seller, Household):
-                    if unit_id in seller.owned_properties:
-                        seller.owned_properties.remove(unit_id)
-                elif hasattr(seller, "owned_properties") and unit_id in seller.owned_properties:
-                    seller.owned_properties.remove(unit_id)
-
-                if isinstance(buyer, Household):
-                    buyer.owned_properties.append(unit_id)
-                elif hasattr(buyer, "owned_properties"):
-                    buyer.owned_properties.append(unit_id)
-
-                self.logger.info(f"RE_TX | Unit {unit_id} transferred from {seller.id} to {buyer.id}")
-        except (IndexError, ValueError) as e:
-            self.logger.error(f"RE_TX_FAIL | Invalid item_id format: {tx.item_id}. Error: {e}")
-
-    def _handle_housing_registry(self, tx: Transaction, buyer: Any, seller: Any, real_estate_units: List[Any], current_time: int):
-        """
-        Updates housing ownership, handling 'unit_{id}' format.
-        Also updates 'is_homeless' status and 'residing_property_id'.
-        """
-        try:
-            # item_id format: "unit_{id}"
-            unit_id = int(tx.item_id.split("_")[1])
-            unit = next((u for u in real_estate_units if u.id == unit_id), None)
-
-            if not unit:
-                self.logger.warning(f"HOUSING_REGISTRY | Unit {unit_id} not found.")
-                return
-
-            # Update Unit
-            unit.owner_id = buyer.id
-            # Update Liens
-            unit.liens = [lien for lien in unit.liens if lien['lien_type'] != 'MORTGAGE']
-
-            if tx.metadata and "mortgage_id" in tx.metadata and tx.metadata["mortgage_id"]:
-                loan_id = str(tx.metadata["mortgage_id"])
-                loan_principal = float(tx.metadata.get("loan_principal", 0.0))
-                lender_id = int(tx.metadata.get("lender_id", 0))
-
-                new_lien: LienDTO = {
-                    "loan_id": loan_id,
-                    "lienholder_id": lender_id,
-                    "principal_remaining": loan_principal,
-                    "lien_type": "MORTGAGE"
-                }
-                unit.liens.append(new_lien)
-
-            # Update Seller (if not None/Govt)
-            if seller:
-                if isinstance(seller, Household):
-                     if unit_id in seller.owned_properties:
-                        seller.owned_properties.remove(unit_id)
-                elif hasattr(seller, "owned_properties"):
-                    if unit_id in seller.owned_properties:
-                        seller.owned_properties.remove(unit_id)
-
-            # Update Buyer
-            if isinstance(buyer, Household):
-                if unit_id not in buyer.owned_properties:
-                    buyer.owned_properties.append(unit_id)
-
-                # Housing System Logic: Auto-move-in if homeless
-                if buyer.residing_property_id is None:
-                    unit.occupant_id = buyer.id
-                    buyer.residing_property_id = unit_id
-                    buyer.is_homeless = False
-            elif hasattr(buyer, "owned_properties"):
-                if unit_id not in buyer.owned_properties:
-                    buyer.owned_properties.append(unit_id)
-
-                # Housing System Logic: Auto-move-in if homeless
-                if getattr(buyer, "residing_property_id", None) is None:
-                    unit.occupant_id = buyer.id
-                    buyer.residing_property_id = unit_id
-                    buyer.is_homeless = False
-
-            self.logger.info(f"HOUSING_REGISTRY | Unit {unit_id} transferred from {tx.seller_id} to {buyer.id}")
-
-        except (IndexError, ValueError) as e:
-            self.logger.error(f"HOUSING_REGISTRY_FAIL | Invalid item_id format: {tx.item_id}. Error: {e}")
-
     def _handle_emergency_buy(self, tx: Transaction, buyer: Any):
         """Updates inventory for emergency buys."""
         if isinstance(buyer, Household):
diff --git a/tests/unit/systems/test_registry_housing.py b/tests/unit/systems/test_housing_service.py
similarity index 61%
rename from tests/unit/systems/test_registry_housing.py
rename to tests/unit/systems/test_housing_service.py
index c26afe3..8f238a4 100644
--- a/tests/unit/systems/test_registry_housing.py
+++ b/tests/unit/systems/test_housing_service.py
@@ -1,18 +1,19 @@
 import pytest
 from unittest.mock import MagicMock
-from simulation.systems.registry import Registry
+from modules.housing.service import HousingService
 from simulation.models import Transaction
 from simulation.core_agents import Household
 from simulation.dtos.api import SimulationState
 
-def test_registry_handle_housing_updates_mortgage():
-    registry = Registry()
+def test_housing_service_handle_housing_updates_mortgage():
+    service = HousingService()
 
     # Setup
     buyer = MagicMock(spec=Household)
     buyer.id = 1
     buyer.owned_properties = []
     buyer.residing_property_id = None
+    buyer.is_homeless = True
 
     seller = MagicMock()
     seller.id = 2
@@ -21,13 +22,16 @@ def test_registry_handle_housing_updates_mortgage():
     unit = MagicMock()
     unit.id = 101
     unit.owner_id = 2
+    unit.liens = []
     unit.mortgage_id = None
 
     real_estate_units = [unit]
+    service.set_real_estate_units(real_estate_units)
 
     state = MagicMock(spec=SimulationState)
     state.real_estate_units = real_estate_units
     state.time = 0
+    state.agents = {1: buyer, 2: seller}
 
     # Transaction with mortgage_id
     tx = Transaction(
@@ -37,20 +41,22 @@ def test_registry_handle_housing_updates_mortgage():
     tx.metadata = {"mortgage_id": "loan_999"}
 
     # Execute
-    registry.update_ownership(tx, buyer, seller, state)
+    service.process_transaction(tx, state)
 
     # Verify
     assert unit.owner_id == 1
-    assert unit.mortgage_id == "loan_999"
+    # Check liens for mortgage
+    assert any(l['loan_id'] == "loan_999" and l['lien_type'] == "MORTGAGE" for l in unit.liens)
     assert 101 in buyer.owned_properties
     assert 101 not in seller.owned_properties
 
-def test_registry_handle_housing_clears_mortgage_if_missing():
-    registry = Registry()
+def test_housing_service_handle_housing_clears_mortgage_if_missing():
+    service = HousingService()
 
     buyer = MagicMock(spec=Household)
     buyer.id = 1
     buyer.owned_properties = []
+    buyer.residing_property_id = None
 
     seller = MagicMock()
     seller.id = 2
@@ -59,12 +65,21 @@ def test_registry_handle_housing_clears_mortgage_if_missing():
     unit = MagicMock()
     unit.id = 101
     unit.owner_id = 2
-    unit.mortgage_id = "old_loan"
+    # Pre-existing mortgage
+    unit.liens = [{
+        "loan_id": "old_loan",
+        "lienholder_id": 99,
+        "principal_remaining": 500,
+        "lien_type": "MORTGAGE"
+    }]
 
     real_estate_units = [unit]
+    service.set_real_estate_units(real_estate_units)
+
     state = MagicMock(spec=SimulationState)
     state.real_estate_units = real_estate_units
     state.time = 0
+    state.agents = {1: buyer, 2: seller}
 
     tx = Transaction(
         buyer_id=1, seller_id=2, item_id="unit_101", price=1000.0, quantity=1.0,
@@ -72,7 +87,8 @@ def test_registry_handle_housing_clears_mortgage_if_missing():
     )
     tx.metadata = {} # No mortgage_id
 
-    registry.update_ownership(tx, buyer, seller, state)
+    service.process_transaction(tx, state)
 
     assert unit.owner_id == 1
-    assert unit.mortgage_id is None
+    # Should have cleared mortgage
+    assert not any(l['lien_type'] == "MORTGAGE" for l in unit.liens)
diff --git a/tests/unit/test_real_estate_lien.py b/tests/unit/test_real_estate_lien.py
index 679da12..24a70ce 100644
--- a/tests/unit/test_real_estate_lien.py
+++ b/tests/unit/test_real_estate_lien.py
@@ -1,7 +1,7 @@
 import pytest
 from unittest.mock import MagicMock
 from simulation.models import RealEstateUnit
-from modules.finance.api import LienDTO, IRealEstateRegistry
+from modules.finance.api import LienDTO
 
 def test_real_estate_unit_initialization():
     """Test standard initialization without optional deps."""
@@ -9,7 +9,6 @@ def test_real_estate_unit_initialization():
     assert unit.id == 1
     assert unit.liens == []
     assert unit.mortgage_id is None
-    assert unit.is_under_contract is False
 
 def test_liens_management():
     """Test adding/removing liens."""
@@ -40,23 +39,6 @@ def test_liens_management():
     # mortgage_id should still find the mortgage
     assert unit.mortgage_id == "loan_101"
 
-def test_is_under_contract_delegation():
-    """Test delegation to registry."""
-    unit = RealEstateUnit(id=3)
-
-    # Mock Registry
-    registry = MagicMock(spec=IRealEstateRegistry)
-    registry.is_under_contract.return_value = True
-
-    # Inject dependency
-    unit._registry_dependency = registry
-
-    assert unit.is_under_contract is True
-    registry.is_under_contract.assert_called_with(3)
-
-    registry.is_under_contract.return_value = False
-    assert unit.is_under_contract is False
-
 def test_mortgage_id_backward_compatibility():
     """Test read-only property logic."""
     unit = RealEstateUnit(id=4)
