diff --git a/communications/insights/TD-170_Escrow_Atomic_Tax.md b/communications/insights/TD-170_Escrow_Atomic_Tax.md
new file mode 100644
index 0000000..c2a36b2
--- /dev/null
+++ b/communications/insights/TD-170_Escrow_Atomic_Tax.md
@@ -0,0 +1,31 @@
+# Insight Report: TD-170 Escrow-Based Atomic Tax Collection
+
+## Phenomenon
+The previous implementation of `TransactionProcessor` (now `TransactionManager`) executed sales tax collection as a separate transaction after the goods trade. This violated atomicity, allowing buyers to acquire goods even if they couldn't afford the tax, or if the tax collection failed, leading to "Phantom Tax" revenue loss and non-zero-sum behavior.
+
+## Cause
+The process was sequential and non-atomic:
+1. Buyer pays Seller.
+2. Government collects Tax from Buyer.
+
+If step 2 failed (insolvency), step 1 was already committed.
+
+## Solution (Escrow Model)
+We implemented a 3-step Escrow mechanism using a dedicated `EscrowAgent`:
+1. **Secure Funds**: Buyer transfers `Total Cost` (Price + Tax) to `EscrowAgent`.
+2. **Distribute Trade Value**: `EscrowAgent` transfers `Price` to Seller.
+3. **Distribute Tax**: `EscrowAgent` transfers `Tax` to Government.
+
+If Step 1 fails, the transaction is aborted (Atomic).
+If Step 2 or 3 fails, a rollback mechanism returns funds to the Buyer (and reverses Seller payment if needed).
+
+## Technical Debt & Insights
+1. **Rollback Complexity**: The rollback logic in `TransactionManager` is manual and complex. A proper Saga pattern or Database Transaction support would be cleaner.
+2. **EscrowAgent as Bottleneck**: The single `EscrowAgent` handles all goods transactions. In a high-concurrency environment, this could be a bottleneck (though fine for this sequential simulation).
+3. **Government Revenue Recording**: We manually construct `TaxCollectionResult` and call `record_revenue` on the Government agent, effectively bypassing `collect_tax`. This tight coupling requires `TransactionManager` to know how `Government` tracks revenue.
+4. **Agent Injection**: `EscrowAgent` is injected via `SimulationInitializer`, increasing the constructor argument count of `TransactionManager`.
+
+## Verification
+Unit tests in `tests/unit/test_transaction_processor.py` confirm:
+- Successful 3-step transfer.
+- Abort on insufficient funds (Step 1 failure).
diff --git a/modules/system/escrow_agent.py b/modules/system/escrow_agent.py
new file mode 100644
index 0000000..1431eeb
--- /dev/null
+++ b/modules/system/escrow_agent.py
@@ -0,0 +1,30 @@
+from modules.finance.api import IFinancialEntity, InsufficientFundsError
+
+class EscrowAgent(IFinancialEntity):
+    """
+    Acts as a temporary holding account for atomic transactions.
+    Ensures funds are secured before distribution to sellers and government.
+    """
+    def __init__(self, id: int):
+        self._id = id
+        self._assets = 0.0
+
+    @property
+    def id(self) -> int:
+        return self._id
+
+    @property
+    def assets(self) -> float:
+        return self._assets
+
+    def deposit(self, amount: float) -> None:
+        if amount < 0:
+            raise ValueError("Deposit amount must be positive")
+        self._assets += amount
+
+    def withdraw(self, amount: float) -> None:
+        if amount < 0:
+            raise ValueError("Withdraw amount must be positive")
+        if self._assets < amount:
+            raise InsufficientFundsError(f"EscrowAgent {self.id} has insufficient funds. Needed: {amount}, Has: {self._assets}")
+        self._assets -= amount
diff --git a/simulation/initialization/initializer.py b/simulation/initialization/initializer.py
index 6772add..a7b9dde 100644
--- a/simulation/initialization/initializer.py
+++ b/simulation/initialization/initializer.py
@@ -57,6 +57,7 @@ from simulation.systems.sensory_system import SensorySystem
 from simulation.systems.settlement_system import SettlementSystem
 from simulation.systems.commerce_system import CommerceSystem
 from simulation.systems.labor_market_analyzer import LaborMarketAnalyzer
+from modules.system.escrow_agent import EscrowAgent
 
 # Phase 29: Crisis Monitor
 from modules.analysis.crisis_monitor import CrisisMonitor
@@ -380,12 +381,18 @@ class SimulationInitializer(SimulationInitializerInterface):
             )
         }
 
+        # Initialize Escrow Agent (TD-170)
+        sim.escrow_agent = EscrowAgent(id=sim.next_agent_id)
+        sim.agents[sim.escrow_agent.id] = sim.escrow_agent
+        sim.next_agent_id += 1
+
         sim.transaction_processor = TransactionManager(
             registry=sim.registry,
             accounting_system=sim.accounting_system,
             settlement_system=sim.settlement_system,
             central_bank_system=sim.central_bank_system,
             config=self.config,
+            escrow_agent=sim.escrow_agent,
             handlers=sim.handlers,
             logger=self.logger
         )
diff --git a/simulation/systems/transaction_manager.py b/simulation/systems/transaction_manager.py
index fb5d684..735edff 100644
--- a/simulation/systems/transaction_manager.py
+++ b/simulation/systems/transaction_manager.py
@@ -29,6 +29,7 @@ class TransactionManager(SystemInterface):
         settlement_system: Any, # ISettlementSystem
         central_bank_system: IMintingAuthority,
         config: Any,
+        escrow_agent: Any, # IFinancialEntity
         handlers: Optional[Dict[str, ISpecializedTransactionHandler]] = None,
         logger: Optional[logging.Logger] = None
     ):
@@ -37,6 +38,7 @@ class TransactionManager(SystemInterface):
         self.settlement = settlement_system
         self.central_bank = central_bank_system
         self.config = config
+        self.escrow_agent = escrow_agent
         self.handlers = handlers if handlers else {}
         self.logger = logger if logger else logging.getLogger(__name__)
 
@@ -136,18 +138,81 @@ class TransactionManager(SystemInterface):
                 # Sales Tax Logic
                 sales_tax_rate = getattr(self.config, "SALES_TAX_RATE", 0.05)
                 tax_amount = trade_value * sales_tax_rate
+                total_cost = trade_value + tax_amount
 
                 # Solvency Check (Legacy compatibility)
                 if hasattr(buyer, 'check_solvency'):
-                    if buyer.assets < (trade_value + tax_amount):
+                    if buyer.assets < total_cost:
                         buyer.check_solvency(government)
 
-                # Standard Transfer
-                success = self.settlement.transfer(buyer, seller, trade_value, f"goods_trade:{tx.item_id}")
-
-                if success and tax_amount > 0:
-                    # Atomic Tax Collection
-                    government.collect_tax(tax_amount, f"sales_tax_{tx.transaction_type}", buyer, current_time)
+                # --- 3-Step Escrow Logic (Atomic) ---
+                # 1. Secure Total Amount in Escrow
+                memo_escrow = f"escrow_hold:{tx.item_id}"
+                escrow_success = self.settlement.transfer(
+                    buyer,
+                    self.escrow_agent,
+                    total_cost,
+                    memo_escrow
+                )
+
+                if not escrow_success:
+                    success = False
+                else:
+                    # 2. Distribute Funds from Escrow
+                    try:
+                        # 2a. Pay Seller
+                        memo_trade = f"goods_trade:{tx.item_id}"
+                        trade_success = self.settlement.transfer(
+                            self.escrow_agent,
+                            seller,
+                            trade_value,
+                            memo_trade
+                        )
+
+                        if not trade_success:
+                            # Critical Failure: Funds stuck in escrow. Rollback buyer.
+                            self.logger.critical(f"ESCROW_FAIL | Trade transfer to seller failed. Rolling back {total_cost} to buyer {buyer.id}.")
+                            self.settlement.transfer(self.escrow_agent, buyer, total_cost, "escrow_reversal:trade_failure")
+                            success = False
+                        else:
+                            # 2b. Pay Tax to Government
+                            if tax_amount > 0:
+                                memo_tax = f"sales_tax:{tx.item_id}"
+                                # Push tax to Government via Settlement
+                                tax_success = self.settlement.transfer(
+                                    self.escrow_agent,
+                                    government,
+                                    tax_amount,
+                                    memo_tax
+                                )
+
+                                if not tax_success:
+                                    # Critical Failure: Tax transfer failed. Rollback everything.
+                                    self.logger.critical(f"ESCROW_FAIL | Tax transfer to government failed. Rolling back trade and escrow.")
+                                    # Revert seller payment
+                                    self.settlement.transfer(seller, self.escrow_agent, trade_value, "reversal:tax_failure")
+                                    # Return all to buyer
+                                    self.settlement.transfer(self.escrow_agent, buyer, total_cost, "escrow_reversal:tax_failure")
+                                    success = False
+                                else:
+                                    success = True
+                                    # Explicitly record tax revenue since we bypassed collect_tax
+                                    # Using a mock result as record_revenue expects TaxCollectionResult
+                                    if hasattr(government, 'record_revenue'):
+                                        government.record_revenue({
+                                            "success": True,
+                                            "amount_collected": tax_amount,
+                                            "tax_type": f"sales_tax_{tx.transaction_type}",
+                                            "payer_id": buyer.id,
+                                            "payee_id": government.id,
+                                            "error_message": None
+                                        })
+                            else:
+                                success = True
+
+                    except Exception as e:
+                        self.logger.exception(f"ESCROW_EXCEPTION | Unexpected error during distribution: {e}")
+                        success = False
 
             elif tx.transaction_type in ["labor", "research_labor"]:
                 # Income Tax Logic
diff --git a/tests/unit/test_transaction_processor.py b/tests/unit/test_transaction_processor.py
index a663b1e..5b0ea38 100644
--- a/tests/unit/test_transaction_processor.py
+++ b/tests/unit/test_transaction_processor.py
@@ -1,9 +1,9 @@
 import pytest
-from unittest.mock import MagicMock
+from unittest.mock import MagicMock, call
 from simulation.systems.transaction_manager import TransactionManager
 from simulation.models import Transaction
 
-def test_transaction_manager_uses_settlement_for_goods():
+def test_transaction_manager_uses_escrow_for_goods():
     # Setup dependencies
     registry = MagicMock()
     accounting = MagicMock()
@@ -12,6 +12,7 @@ def test_transaction_manager_uses_settlement_for_goods():
     config = MagicMock()
     config.SALES_TAX_RATE = 0.1
     config.GOODS = {"apple": {}}
+    escrow_agent = MagicMock()
 
     # Initialize Manager
     tm = TransactionManager(
@@ -20,6 +21,7 @@ def test_transaction_manager_uses_settlement_for_goods():
         settlement_system=settlement,
         central_bank_system=central_bank,
         config=config,
+        escrow_agent=escrow_agent,
         handlers={}
     )
 
@@ -29,7 +31,7 @@ def test_transaction_manager_uses_settlement_for_goods():
     state.government = gov
     state.market_data = {}
     state.time = 0
-    state.effects_queue = [] # Ensure this exists
+    state.effects_queue = []
 
     # Setup Agents
     buyer = MagicMock()
@@ -55,29 +57,44 @@ def test_transaction_manager_uses_settlement_for_goods():
     )
     state.transactions = [tx]
 
-    # Mock Settlement Success
+    # Mock Settlement Success for all steps
     settlement.transfer.return_value = True
 
     # Execute
     tm.execute(state)
 
-    # Verify Settlement Called
-    settlement.transfer.assert_called_once()
-    args = settlement.transfer.call_args
-    # args: buyer, seller, amount, memo
-    assert args[0][0] == buyer
-    assert args[0][1] == seller
-    assert args[0][2] == 10.0 # 1.0 * 10.0
+    # Verify 3-Step Escrow Logic
+    # 1. Buyer -> Escrow (Total Cost: 10 + 1 = 11)
+    # 2. Escrow -> Seller (Trade Value: 10)
+    # 3. Escrow -> Gov (Tax: 1)
+
+    assert settlement.transfer.call_count == 3
+    calls = settlement.transfer.call_args_list
 
-    # Verify Tax Collection (0.1 rate)
-    gov.collect_tax.assert_called_once()
+    # Step 1
+    assert calls[0][0][0] == buyer
+    assert calls[0][0][1] == escrow_agent
+    assert calls[0][0][2] == 11.0
+
+    # Step 2
+    assert calls[1][0][0] == escrow_agent
+    assert calls[1][0][1] == seller
+    assert calls[1][0][2] == 10.0
+
+    # Step 3
+    assert calls[2][0][0] == escrow_agent
+    assert calls[2][0][1] == gov
+    assert calls[2][0][2] == 1.0
 
     # Verify State Commitment
     registry.update_ownership.assert_called_once()
     accounting.record_transaction.assert_called_once()
 
+    # Verify Gov Revenue Recorded
+    gov.record_revenue.assert_called_once()
+
 
-def test_transaction_manager_skips_state_update_on_failure():
+def test_transaction_manager_escrow_fails_insufficient_funds():
     # Setup dependencies
     registry = MagicMock()
     accounting = MagicMock()
@@ -86,6 +103,7 @@ def test_transaction_manager_skips_state_update_on_failure():
     config = MagicMock()
     config.SALES_TAX_RATE = 0.1
     config.GOODS = {"apple": {}}
+    escrow_agent = MagicMock()
 
     # Initialize Manager
     tm = TransactionManager(
@@ -94,12 +112,14 @@ def test_transaction_manager_skips_state_update_on_failure():
         settlement_system=settlement,
         central_bank_system=central_bank,
         config=config,
+        escrow_agent=escrow_agent,
         handlers={}
     )
 
     # Setup State
     state = MagicMock()
-    state.government = MagicMock()
+    gov = MagicMock()
+    state.government = gov
     state.market_data = {}
     state.time = 0
 
@@ -124,16 +144,22 @@ def test_transaction_manager_skips_state_update_on_failure():
     )
     state.transactions = [tx]
 
-    # Mock Settlement FAILURE
-    settlement.transfer.return_value = False
+    # Mock Settlement FAILURE (Step 1)
+    settlement.transfer.side_effect = [False]
 
     # Execute
     tm.execute(state)
 
-    # Verify Settlement Attempted
+    # Verify Step 1 Attempted
     settlement.transfer.assert_called_once()
+    args = settlement.transfer.call_args
+    assert args[0][0] == buyer
+    assert args[0][1] == escrow_agent
+
+    # Verify NO further steps
+    assert settlement.transfer.call_count == 1
 
-    # Verify State Commitment SKIPPED
+    # Verify NO State Commitment
     registry.update_ownership.assert_not_called()
     accounting.record_transaction.assert_not_called()
 
@@ -145,13 +171,15 @@ def test_transaction_manager_routes_to_central_bank():
     settlement = MagicMock()
     central_bank = MagicMock() # Minting Authority
     config = MagicMock()
+    escrow_agent = MagicMock()
 
     tm = TransactionManager(
         registry=registry,
         accounting_system=accounting,
         settlement_system=settlement,
         central_bank_system=central_bank,
-        config=config
+        config=config,
+        escrow_agent=escrow_agent
     )
 
     state = MagicMock()
@@ -197,6 +225,7 @@ def test_transaction_manager_uses_handler():
     settlement = MagicMock()
     central_bank = MagicMock()
     config = MagicMock()
+    escrow_agent = MagicMock()
 
     handler = MagicMock() # Specialized Handler
     handler.handle.return_value = True
@@ -207,6 +236,7 @@ def test_transaction_manager_uses_handler():
         settlement_system=settlement,
         central_bank_system=central_bank,
         config=config,
+        escrow_agent=escrow_agent,
         handlers={"special_saga": handler}
     )
 
