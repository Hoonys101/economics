diff --git a/communications/insights/WO_024_Fractional_Reserve.md b/communications/insights/WO_024_Fractional_Reserve.md
new file mode 100644
index 0000000..8af8b41
--- /dev/null
+++ b/communications/insights/WO_024_Fractional_Reserve.md
@@ -0,0 +1,26 @@
+# Insight: Fractional Reserve Banking & Auditable Credit (WO-024)
+
+## Overview
+This mission implements a compliant Fractional Reserve Banking system, replacing direct state manipulation of the money supply with an auditable, transaction-based approach. This aligns with `ARCH_TRANSACTIONS.md` and fixes integrity issues detected by `trace_leak.py`.
+
+## Key Changes
+1.  **Transactional Credit Creation/Destruction**:
+    *   `Bank.grant_loan` now returns a `(LoanInfoDTO, Transaction)` tuple. The transaction records `credit_creation`.
+    *   `Bank.void_loan`, `Bank.process_default`, and the newly added `Bank.terminate_loan` return a `Transaction` recording `credit_destruction`.
+    *   These transactions are symbolic (Buyer=Bank/Gov, Seller=Gov/Bank) and serve as M2 audit records.
+
+2.  **Centralized Accounting**:
+    *   `Government` now includes `process_monetary_transactions` to track `credit_delta_this_tick`.
+    *   `Government.get_monetary_delta` aggregates minting, burning, and credit operations for precise leak detection.
+
+3.  **Orchestration Updates**:
+    *   `Phase1_Decision` was found to ignore transactions returned by `market.place_order`. This caused `LoanMarket` transactions (and others) to be lost. This is fixed by capturing and appending them to `state.transactions`.
+    *   `Phase3_Transaction` now explicitly feeds `state.transactions` to `government.process_monetary_transactions`.
+
+## Technical Debt & Discoveries
+*   **Missing `terminate_loan`**: `HousingSystem` calls `simulation.bank.terminate_loan`, but the method was missing in `Bank`. Added as part of this refactor.
+*   **Lost Transactions in Phase 1**: `Phase1_Decision` logic for placing orders previously discarded returned transactions. This likely affected `LoanMarket` and potentially `OrderBookMarket` immediate fills. Fixed to ensure data integrity.
+*   **HousingSystem Direct Calls**: `HousingSystem` calls `Bank` methods directly instead of going through a market or strictly decoupled interface. This remains but is patched to handle the new transactional returns.
+
+## Verification
+*   `scripts/trace_leak.py` is updated to verify that the authorized monetary delta (calculated by Government) matches the actual change in M2, confirming zero-sum integrity with fractional reserve mechanics.
diff --git a/scripts/trace_leak.py b/scripts/trace_leak.py
index a15f808..3c03dd5 100644
--- a/scripts/trace_leak.py
+++ b/scripts/trace_leak.py
@@ -20,6 +20,24 @@ def trace():
     for f in sim.world_state.firms:
         print(f"Firm {f.id}: Assets={f.assets:,.2f}, Active={f.is_active}")
     
+    # --- WO-024: Manual Loan Grant for Verification ---
+    target_firm = next((f for f in sim.world_state.firms if f.is_active), None)
+    if target_firm:
+        loan_amount = 5000.0
+        interest_rate = 0.05
+
+        grant_result = sim.bank.grant_loan(
+            borrower_id=str(target_firm.id),
+            amount=loan_amount,
+            interest_rate=interest_rate
+        )
+
+        if grant_result:
+            _loan_info, credit_tx = grant_result
+            if credit_tx:
+                sim.government.process_monetary_transactions([credit_tx])
+                print(f"Loan granted to Firm {target_firm.id} for {loan_amount:,.2f}. Credit TX processed.")
+
     sim.run_tick()
     
     current_money = sim.world_state.calculate_total_money()
@@ -29,10 +47,14 @@ def trace():
     authorized_delta = 0.0
     if hasattr(sim.government, "get_monetary_delta"):
         authorized_delta = sim.government.get_monetary_delta()
-        
+
+    # Add manual delta from pre-tick loan grant (which was reset in run_tick)
+    if 'grant_result' in locals() and grant_result:
+        authorized_delta += loan_amount
+
     print(f"\nTick 1 (END) Total Money: {current_money:,.2f}")
     print(f"Baseline: {baseline_money:,.2f}")
-    print(f"Authorized Delta (Minted - Destroyed): {authorized_delta:,.2f}")
+    print(f"Authorized Delta (Minted - Destroyed + Credit): {authorized_delta:,.2f}")
     print(f"Actual Delta: {delta:,.2f}")
     
     # Check Integrity
diff --git a/simulation/agents/government.py b/simulation/agents/government.py
index 5d029fd..9b53405 100644
--- a/simulation/agents/government.py
+++ b/simulation/agents/government.py
@@ -49,9 +49,13 @@ class Government:
         self.total_spent_subsidies: float = 0.0
         self.infrastructure_level: int = 0
 
-        # Gold Standard Money Tracking
+        # Money Tracking (Gold Standard & Fractional Reserve)
         self.total_money_issued: float = 0.0
         self.total_money_destroyed: float = 0.0
+        self.start_tick_money_issued: float = 0.0
+        self.start_tick_money_destroyed: float = 0.0
+        # WO-024: Fractional Reserve Credit Tracking
+        self.credit_delta_this_tick: float = 0.0
         
         # 세수 유형별 집계
         self.tax_revenue: Dict[str, float] = {}
@@ -204,8 +208,28 @@ class Government:
 
         self.revenue_this_tick = 0.0
         self.expenditure_this_tick = 0.0
+        self.credit_delta_this_tick = 0.0
         self.revenue_breakdown_this_tick = {}
 
+        # Snapshot for delta calculation
+        self.start_tick_money_issued = self.total_money_issued
+        self.start_tick_money_destroyed = self.total_money_destroyed
+
+    def process_monetary_transactions(self, transactions: List[Transaction]):
+        """
+        Processes transactions related to monetary policy (Credit Creation/Destruction).
+        Called by the orchestrator or systems generating these transactions.
+        """
+        for tx in transactions:
+            if tx.transaction_type == "credit_creation":
+                self.credit_delta_this_tick += tx.price
+                self.total_money_issued += tx.price
+                logger.debug(f"MONETARY_EXPANSION | Credit created: {tx.price:.2f}")
+            elif tx.transaction_type == "credit_destruction":
+                self.credit_delta_this_tick -= tx.price
+                self.total_money_destroyed += tx.price
+                logger.debug(f"MONETARY_CONTRACTION | Credit destroyed: {tx.price:.2f}")
+
     def collect_tax(self, amount: float, tax_type: str, payer: Any, current_tick: int) -> "TaxCollectionResult":
         """
         Legacy adapter method used by TransactionProcessor.
@@ -672,7 +696,14 @@ class Government:
         }
 
     def get_monetary_delta(self) -> float:
-        return self.total_money_issued - self.total_money_destroyed
+        """
+        Returns the net change in the money supply authorized this tick.
+        This includes base money changes (mint/burn) and credit money changes.
+        """
+        # Calculate changes in totals during this tick
+        issued_delta = self.total_money_issued - self.start_tick_money_issued
+        destroyed_delta = self.total_money_destroyed - self.start_tick_money_destroyed
+        return issued_delta - destroyed_delta
 
     def get_agent_data(self) -> Dict[str, Any]:
         return {
diff --git a/simulation/bank.py b/simulation/bank.py
index cdf7023..c6ee6e5 100644
--- a/simulation/bank.py
+++ b/simulation/bank.py
@@ -1,6 +1,6 @@
 import logging
 from dataclasses import dataclass
-from typing import Dict, Any, List, Optional, TYPE_CHECKING
+from typing import Dict, Any, List, Optional, Tuple, TYPE_CHECKING
 import math
 from modules.common.config_manager.api import ConfigManager
 from modules.finance.api import (
@@ -116,9 +116,10 @@ class Bank(IBankService):
 
     # --- IBankService Implementation ---
 
-    def grant_loan(self, borrower_id: str, amount: float, interest_rate: float, due_tick: Optional[int] = None, borrower_profile: Optional[BorrowerProfileDTO] = None) -> Optional[LoanInfoDTO]:
+    def grant_loan(self, borrower_id: str, amount: float, interest_rate: float, due_tick: Optional[int] = None, borrower_profile: Optional[BorrowerProfileDTO] = None) -> Optional[Tuple[LoanInfoDTO, Transaction]]:
         """
         Grants a loan to a borrower.
+        Returns LoanInfoDTO and a 'credit_creation' Transaction.
         Implements IBankService.grant_loan.
         """
         try:
@@ -176,11 +177,21 @@ class Bank(IBankService):
         )
         self.loans[loan_id] = new_loan
 
-        # Log Money Creation for System Accounting
-        if self.government and hasattr(self.government, "total_money_issued"):
-             self.government.total_money_issued += amount
+        # WO-024: Transactional Credit Creation
+        # No longer modifying government state directly.
+        # Generating a symbolic transaction for M2 audit.
+        credit_creation_tx = Transaction(
+            buyer_id=self.id,
+            seller_id=self.government.id if self.government else -1,
+            item_id=f"credit_creation_{loan_id}",
+            quantity=1,
+            price=amount,
+            market_id="monetary_policy",
+            transaction_type="credit_creation",
+            time=start_tick
+        )
 
-        return LoanInfoDTO(
+        dto = LoanInfoDTO(
             loan_id=loan_id,
             borrower_id=borrower_id,
             original_amount=amount,
@@ -189,6 +200,7 @@ class Bank(IBankService):
             origination_tick=start_tick,
             due_tick=due_tick
         )
+        return dto, credit_creation_tx
 
     def repay_loan(self, loan_id: str, amount: float) -> bool:
         """
@@ -336,7 +348,8 @@ class Bank(IBankService):
                  break
 
         total_loan_interest = 0.0
-        for loan_id, loan in self.loans.items():
+        # Create a list of loans to iterate over to allow modification (process_default deletes loan)
+        for loan_id, loan in list(self.loans.items()):
             agent = agents_dict.get(loan.borrower_id)
             if not agent or not getattr(agent, 'is_active', True):
                 continue
@@ -358,7 +371,11 @@ class Bank(IBankService):
                 generated_transactions.append(tx)
                 total_loan_interest += payment
             else:
-                self.process_default(agent, loan, current_tick, government=gov_agent)
+                # Capture credit destruction tx
+                default_tx = self.process_default(agent, loan, current_tick, government=gov_agent)
+                if default_tx:
+                    generated_transactions.append(default_tx)
+
                 partial = agent.assets
                 if partial > 0:
                     tx = Transaction(
@@ -436,12 +453,25 @@ class Bank(IBankService):
 
         return []
 
-    def process_default(self, agent: Any, loan: Loan, current_tick: int, government: Optional[Any] = None):
+    def process_default(self, agent: Any, loan: Loan, current_tick: int, government: Optional[Any] = None) -> Optional[Transaction]:
         if hasattr(agent, "shares_owned") and agent.shares_owned:
             agent.shares_owned.clear()
 
-        if government and loan.remaining_balance > 0:
-            government.total_money_destroyed += loan.remaining_balance
+        destruction_tx = None
+        amount = loan.remaining_balance
+
+        if amount > 0:
+             # WO-024: Transactional Credit Destruction
+             destruction_tx = Transaction(
+                buyer_id=government.id if government else -1,
+                seller_id=self.id,
+                item_id=f"credit_destruction_default_{loan.borrower_id}",
+                quantity=1,
+                price=amount,
+                market_id="monetary_policy",
+                transaction_type="credit_destruction",
+                time=current_tick
+            )
 
         loan.remaining_balance = 0.0
 
@@ -453,6 +483,37 @@ class Bank(IBankService):
         if hasattr(agent, "education_xp"):
              agent.education_xp *= (1.0 - xp_penalty)
 
+        return destruction_tx
+
+    def terminate_loan(self, loan_id: str) -> Optional[Transaction]:
+        """
+        Forcefully terminates a loan (e.g. foreclosure).
+        Returns a credit_destruction transaction if balance was > 0.
+        """
+        if loan_id not in self.loans:
+            return None
+
+        loan = self.loans[loan_id]
+        amount = loan.remaining_balance
+
+        # Similar to void_loan but assumes deposit might not be reversible (spent), so just destroys credit asset.
+        # This is essentially a write-off / destruction.
+
+        del self.loans[loan_id]
+
+        if amount > 0:
+             return Transaction(
+                buyer_id=self.government.id if self.government else -1,
+                seller_id=self.id,
+                item_id=f"credit_destruction_term_{loan_id}",
+                quantity=1,
+                price=amount,
+                market_id="monetary_policy",
+                transaction_type="credit_destruction",
+                time=self.current_tick_tracker
+            )
+        return None
+
     # Legacy Stubs
     def get_outstanding_loans_for_agent(self, agent_id: int) -> List[Dict]:
         return [
@@ -472,19 +533,18 @@ class Bank(IBankService):
         except (LoanNotFoundError, LoanRepaymentError):
             pass
 
-    def void_loan(self, loan_id: str) -> bool:
+    def void_loan(self, loan_id: str) -> Optional[Transaction]:
         """
         Cancels a loan and reverses the associated deposit creation.
-        Used when a transaction funded by a loan fails immediately (e.g. withdrawal failure).
+        Returns a credit_destruction transaction.
         """
         if loan_id not in self.loans:
-            return False
+            return None
 
         loan = self.loans[loan_id]
         amount = loan.principal
 
         # 1. Reverse Deposit (Liability)
-        # Use the robust link if available
         target_dep_id = loan.created_deposit_id
         deposit_reversed = False
 
@@ -492,8 +552,6 @@ class Bank(IBankService):
             del self.deposits[target_dep_id]
             deposit_reversed = True
         else:
-            # Fallback for legacy or lost link: Find matching deposit
-            # This is brittle but necessary as a last resort
             borrower_id = loan.borrower_id
             for dep_id, deposit in self.deposits.items():
                 if deposit.depositor_id == borrower_id and abs(deposit.amount - amount) < 1e-9:
@@ -505,13 +563,21 @@ class Bank(IBankService):
                 logger.critical(f"VOID_LOAN_FAIL | Could not find deposit for loan {loan_id}. Cannot safely rollback.")
                 raise LoanRollbackError(f"Critical: Could not find deposit to reverse for loan {loan_id}")
 
-        # 2. Destroy Loan (Asset) - Only if liability reversed
+        # 2. Destroy Loan (Asset)
         if deposit_reversed:
             del self.loans[loan_id]
 
-        # 3. Reverse Money Supply Tracking
-        if self.government and hasattr(self.government, "total_money_issued"):
-             self.government.total_money_issued -= amount
+        # 3. Transactional Credit Destruction
+        tx = Transaction(
+            buyer_id=self.government.id if self.government else -1,
+            seller_id=self.id,
+            item_id=f"credit_destruction_{loan_id}",
+            quantity=1,
+            price=amount,
+            market_id="monetary_policy",
+            transaction_type="credit_destruction",
+            time=self.current_tick_tracker
+        )
 
         logger.info(f"LOAN_VOIDED | Loan {loan_id} cancelled and deposit reversed.")
-        return True
+        return tx
diff --git a/simulation/loan_market.py b/simulation/loan_market.py
index f2a562b..3fc0a88 100644
--- a/simulation/loan_market.py
+++ b/simulation/loan_market.py
@@ -69,7 +69,7 @@ class LoanMarket(Market):
             if order.metadata and "borrower_profile" in order.metadata:
                 borrower_profile = order.metadata["borrower_profile"]
 
-            loan_info = self.bank.grant_loan(
+            grant_result = self.bank.grant_loan(
                 borrower_id=str(order.agent_id),
                 amount=loan_amount,
                 interest_rate=interest_rate,
@@ -77,7 +77,10 @@ class LoanMarket(Market):
                 borrower_profile=borrower_profile
             )
 
-            if loan_info:
+            if grant_result:
+                loan_info, credit_tx = grant_result
+
+                # 1. Record the loan transaction (Commercial)
                 transactions.append(
                     Transaction(
                         item_id="loan_granted",
@@ -90,6 +93,11 @@ class LoanMarket(Market):
                         market_id=self.id,
                     )
                 )
+
+                # 2. Record the credit creation transaction (Monetary)
+                if credit_tx:
+                    transactions.append(credit_tx)
+
                 logger.info(
                     f"Loan granted to {order.agent_id} for {loan_amount:.2f}. Loan ID: {loan_info['loan_id']}",
                     extra={**log_extra, "loan_id": loan_info['loan_id']},
diff --git a/simulation/orchestration/phases.py b/simulation/orchestration/phases.py
index e0035df..971d3f4 100644
--- a/simulation/orchestration/phases.py
+++ b/simulation/orchestration/phases.py
@@ -441,7 +441,10 @@ class Phase1_Decision(IPhaseStrategy):
                 for order in firm_orders:
                     target_market = state.markets.get(order.market_id)
                     if target_market:
-                        target_market.place_order(order, state.time)
+                        # WO-024: Capture immediate transactions (e.g. LoanMarket)
+                        new_txs = target_market.place_order(order, state.time)
+                        if new_txs:
+                            state.transactions.extend(new_txs)
 
         # 2. Households
         for household in state.households:
@@ -501,7 +504,10 @@ class Phase1_Decision(IPhaseStrategy):
                     household_target_market = state.markets.get(target_market_id)
 
                     if household_target_market:
-                        household_target_market.place_order(order, state.time)
+                        # WO-024: Capture immediate transactions (e.g. LoanMarket)
+                        new_txs = household_target_market.place_order(order, state.time)
+                        if new_txs:
+                            state.transactions.extend(new_txs)
 
         state.firm_pre_states = firm_pre_states
         state.household_pre_states = household_pre_states
@@ -548,7 +554,9 @@ class Phase1_Decision(IPhaseStrategy):
                      )
                      market = state.markets.get(tx.item_id)
                      if market:
-                         market.place_order(order, state.time)
+                         new_txs = market.place_order(order, state.time)
+                         if new_txs:
+                             state.transactions.extend(new_txs)
                 else:
                      state.transactions.append(tx)
 
@@ -621,6 +629,10 @@ class Phase3_Transaction(IPhaseStrategy):
 
         state.transactions.extend(system_transactions)
 
+        # WO-024: Process Monetary Transactions (Credit Creation/Destruction)
+        if state.government:
+            state.government.process_monetary_transactions(state.transactions)
+
         if self.world_state.transaction_processor:
             self.world_state.transaction_processor.execute(state)
         else:
diff --git a/simulation/systems/housing_system.py b/simulation/systems/housing_system.py
index 76c4c09..6e7cc26 100644
--- a/simulation/systems/housing_system.py
+++ b/simulation/systems/housing_system.py
@@ -48,7 +48,10 @@ class HousingSystem:
                                     old_owner_agent.residing_property_id = None
                                     old_owner_agent.is_homeless = True
                                     
-                        simulation.bank.terminate_loan(loan.id)
+                        term_tx = simulation.bank.terminate_loan(loan.id)
+                        if term_tx:
+                             if hasattr(simulation, 'world_state'):
+                                 simulation.world_state.transactions.append(term_tx)
                         
                         fire_sale_price = unit.estimated_value * 0.8
                         sell_order = Order(
@@ -188,7 +191,7 @@ class HousingSystem:
                 term_ticks = mortgage_term
                 due_tick = simulation.time + term_ticks
 
-                loan_info = simulation.bank.grant_loan(
+                grant_result = simulation.bank.grant_loan(
                     borrower_id=str(buyer.id),
                     amount=loan_amount,
                     interest_rate=mortgage_rate,
@@ -196,8 +199,14 @@ class HousingSystem:
                     borrower_profile=borrower_profile
                 )
                 
-                if loan_info:
+                if grant_result:
+                    loan_info, credit_tx = grant_result
                     loan_id = loan_info["loan_id"]
+
+                    if credit_tx:
+                        if hasattr(simulation, 'world_state'):
+                            simulation.world_state.transactions.append(credit_tx)
+
                     # Fractional Reserve: Loan creates a Deposit.
 
                     # 1. DISBURSEMENT: Transfer funds from Bank (Reserves) to Buyer (Cash)
@@ -208,7 +217,10 @@ class HousingSystem:
 
                     if not disbursement_success:
                          logger.error(f"LOAN_DISBURSEMENT_FAIL | Bank could not transfer {loan_amount} to {buyer.id}. Voiding loan.")
-                         simulation.bank.void_loan(loan_id)
+                         void_tx = simulation.bank.void_loan(loan_id)
+                         if void_tx:
+                              if hasattr(simulation, 'world_state'):
+                                  simulation.world_state.transactions.append(void_tx)
                          return
 
                     # 2. DEPOSIT CLEANUP: Reduce the newly created deposit liability
@@ -219,7 +231,10 @@ class HousingSystem:
                              logger.error(f"LOAN_WITHDRAW_FAIL | Could not reduce deposit for {buyer.id}. Rolling back.")
                              # Rollback Disbursement
                              simulation.settlement_system.transfer(buyer, simulation.bank, loan_amount, "loan_rollback", tick=simulation.time)
-                             simulation.bank.void_loan(loan_id)
+                             void_tx = simulation.bank.void_loan(loan_id)
+                             if void_tx:
+                                  if hasattr(simulation, 'world_state'):
+                                      simulation.world_state.transactions.append(void_tx)
                              return
 
                         unit.mortgage_id = loan_id
@@ -253,7 +268,10 @@ class HousingSystem:
 
                       # 2. Void Loan (Cleanup Loan Asset)
                       try:
-                          simulation.bank.void_loan(loan_id)
+                          void_tx = simulation.bank.void_loan(loan_id)
+                          if void_tx:
+                               if hasattr(simulation, 'world_state'):
+                                   simulation.world_state.transactions.append(void_tx)
                       except Exception as e:
                           logger.warning(f"ROLLBACK_WARNING | void_loan failed during rollback: {e}")
                           if loan_id in simulation.bank.loans:
diff --git a/simulation/systems/transaction_processor.py b/simulation/systems/transaction_processor.py
index 6ee4271..82e7656 100644
--- a/simulation/systems/transaction_processor.py
+++ b/simulation/systems/transaction_processor.py
@@ -205,6 +205,13 @@ class TransactionProcessor(SystemInterface):
                 if success:
                     buyer.inventory[tx.item_id] = buyer.inventory.get(tx.item_id, 0.0) + tx.quantity
 
+            elif tx.transaction_type in ["credit_creation", "credit_destruction"]:
+                # WO-024: Symbolic Monetary Policy Transactions.
+                # These are accounting records for the Government and are processed in Phase3
+                # via `government.process_monetary_transactions`.
+                # They MUST NOT be executed as real financial transfers here to avoid double counting.
+                success = True
+
             else:
                 # Default / Other
                 success = settlement.transfer(buyer, seller, trade_value, f"generic:{tx.transaction_type}")
diff --git a/simulation/world_state.py b/simulation/world_state.py
index 87f60f7..6c89a07 100644
--- a/simulation/world_state.py
+++ b/simulation/world_state.py
@@ -145,9 +145,11 @@ class WorldState:
             if f.is_active:
                 total += f.assets
 
-        # 3. Bank Reserves
+        # 3. Bank Reserves & Deposits (M2 Accounting)
         if self.bank:
-            total += self.bank.assets
+            # WO-024: M2 = Currency + Deposits. Bank Reserves are excluded.
+            # total += self.bank.assets (Reserves excluded)
+            total += sum(d.amount for d in self.bank.deposits.values())
 
         # 4. Government Assets (WO-Fix: Include Government in M2 to prevent leaks)
         if self.government:
diff --git a/tests/unit/systems/test_housing_system.py b/tests/unit/systems/test_housing_system.py
index 4bd3595..e186a89 100644
--- a/tests/unit/systems/test_housing_system.py
+++ b/tests/unit/systems/test_housing_system.py
@@ -75,8 +75,11 @@ class TestHousingSystemRefactor(unittest.TestCase):
         self.simulation.settlement_system.transfer.return_value = True
 
         # Default Bank behavior
-        self.simulation.bank.grant_loan.return_value = {"loan_id": "loan_123"}
+        # WO-024: grant_loan returns (dto, transaction)
+        self.simulation.bank.grant_loan.return_value = ({"loan_id": "loan_123"}, MagicMock(transaction_type="credit_creation", price=100.0))
         self.simulation.bank.withdraw_for_customer.return_value = True
+        self.simulation.bank.terminate_loan.return_value = MagicMock(transaction_type="credit_destruction")
+        self.simulation.bank.void_loan.return_value = MagicMock(transaction_type="credit_destruction")
 
     def test_process_housing_rent_collection_uses_transfer(self):
         """Test that rent collection uses SettlementSystem.transfer"""
diff --git a/tests/unit/test_bank.py b/tests/unit/test_bank.py
index 0b0403b..42ed04d 100644
--- a/tests/unit/test_bank.py
+++ b/tests/unit/test_bank.py
@@ -65,7 +65,7 @@ class TestBank:
         )
 
         # Call with correct signature
-        loan_info = bank_instance.grant_loan(
+        grant_result = bank_instance.grant_loan(
             borrower_id=borrower_id,
             amount=amount,
             interest_rate=0.07,
@@ -73,9 +73,11 @@ class TestBank:
             borrower_profile=profile
         )
 
-        assert loan_info is not None
+        assert grant_result is not None
+        loan_info, tx = grant_result
         assert loan_info["borrower_id"] == borrower_id
         assert loan_info["original_amount"] == 1000.0
+        assert tx.transaction_type == "credit_creation"
 
         # Verify Credit Service called
         mock_credit_scoring_service.assess_creditworthiness.assert_called_once()
@@ -99,8 +101,8 @@ class TestBank:
 
         profile = BorrowerProfileDTO(borrower_id="101", gross_income=100.0, existing_debt_payments=100.0, collateral_value=0.0, existing_assets=0.0)
 
-        loan_info = bank_instance.grant_loan("101", 1000.0, 0.05, borrower_profile=profile)
-        assert loan_info is None
+        grant_result = bank_instance.grant_loan("101", 1000.0, 0.05, borrower_profile=profile)
+        assert grant_result is None
         assert len(bank_instance.loans) == 0
 
     def test_grant_loan_insufficient_reserves(self, bank_instance):
@@ -115,9 +117,9 @@ class TestBank:
         amount = 200000.0
         profile = BorrowerProfileDTO(borrower_id=borrower_id, gross_income=1000.0, existing_debt_payments=0.0, collateral_value=0.0, existing_assets=0.0)
 
-        loan_info = bank_instance.grant_loan(borrower_id, amount, 0.05, borrower_profile=profile)
+        grant_result = bank_instance.grant_loan(borrower_id, amount, 0.05, borrower_profile=profile)
 
-        assert loan_info is None
+        assert grant_result is None
         assert len(bank_instance.loans) == 0
 
     def test_grant_loan_multiple_loans(self, bank_instance):
