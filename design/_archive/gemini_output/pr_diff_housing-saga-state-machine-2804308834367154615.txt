diff --git a/communications/insights/150503.md b/communications/insights/150503.md
new file mode 100644
index 0000000..e480bda
--- /dev/null
+++ b/communications/insights/150503.md
@@ -0,0 +1,21 @@
+# Mission 150503: Housing Transaction Saga Handler Refactoring
+
+## 1. Overview
+Refactored `HousingTransactionSagaHandler` from a monolithic atomic transaction to a 5-step State Machine (`INITIATED`, `CREDIT_CHECK`, `APPROVED`, `ESCROW_LOCKED`, `TRANSFER_TITLE`). This improves robustness, allows for multi-tick transactions, and supports graceful rollback/compensation.
+
+## 2. Technical Decisions
+- **Persistence**: `SettlementSystem` now maintains `active_sagas` (`Dict[UUID, HousingTransactionSagaStateDTO]`) and processes them each tick via `process_sagas`.
+- **Registry & LoanMarket Updates**:
+    - `IRealEstateRegistry` updated to support `set_under_contract`, `add_lien`, `remove_lien`.
+    - `ILoanMarket` updated to support `stage_mortgage`, `check_status`, `convert_staged_to_loan`.
+    - `Bank` service updated to include `terminate_loan` for compensation/rollback.
+- **Dependency Handling**: `HousingTransactionSagaHandler` orchestrates the flow, calling `LoanMarket` and `Registry`. Calls to `Registry.add_lien` are handled within the Saga Handler after loan conversion, to keep `LoanMarket` focused on credit logic.
+
+## 3. Technical Debt & Insights
+- **Synchronous "Staging"**: `LoanMarket.stage_mortgage` currently creates the loan synchronously in the Bank (active state). "Staging" is effectively "Created but not funded". If the saga fails, the loan is terminated (`void_staged_application`). In a true async system, "Staged" might be a separate pending state in the Bank.
+- **DTO Safety**: `HousingTransactionSagaStateDTO` is a `TypedDict`. Accessing optional keys (like `staged_loan_id` or `mortgage_approval`) requires care (using `.get()` or ensuring flow logic guarantees presence).
+- **Agent Compensation**: `SettlementSystem.find_and_compensate_by_agent` was added to support cleaning up sagas if an agent goes bankrupt. It relies on passing a handler or context, which might require tighter integration with `Phase_Recovery`.
+
+## 4. Verification
+- Verified State Machine transitions and rollback logic via `scripts/verify_saga_state_machine.py` (custom script).
+- Verified `LoanMarket` existing functionality via `tests/unit/markets/test_loan_market_mortgage.py`.
diff --git a/modules/finance/api.py b/modules/finance/api.py
index baf9652..3127c15 100644
--- a/modules/finance/api.py
+++ b/modules/finance/api.py
@@ -2,6 +2,7 @@ from typing import Protocol, Dict, List, Any, Optional, TypedDict, Literal, Tupl
 from dataclasses import dataclass
 import abc
 from abc import ABC, abstractmethod
+from uuid import UUID
 
 if TYPE_CHECKING:
     from modules.simulation.api import IGovernment, EconomicIndicatorsDTO
@@ -270,6 +271,14 @@ class IBankService(IFinancialEntity, Protocol):
         """
         ...
 
+    @abc.abstractmethod
+    def terminate_loan(self, loan_id: str) -> Optional["Transaction"]:
+        """
+        Forcefully terminates a loan (e.g. foreclosure or voiding).
+        Returns a credit_destruction transaction if balance was > 0.
+        """
+        ...
+
 class IFiscalMonitor(Protocol):
     """Interface for the fiscal health analysis component."""
     def get_debt_to_gdp_ratio(self, government: "IGovernment", indicators: "EconomicIndicatorsDTO") -> float: ...
@@ -361,12 +370,34 @@ class IRealEstateRegistry(ABC):
         """
         Checks if a property is currently involved in an active purchase Saga.
         This is the single source of truth for the "under contract" status.
-
-        Implementation Note: This method should query the Saga persistence layer
-        for any non-terminal Saga state associated with the property_id.
         """
         ...
 
+    @abstractmethod
+    def set_under_contract(self, property_id: int, saga_id: UUID) -> bool:
+        """Locks a property, preventing other sales. Returns False if already locked."""
+        ...
+
+    @abstractmethod
+    def release_contract(self, property_id: int, saga_id: UUID) -> bool:
+        """Releases the lock on a property."""
+        ...
+
+    @abstractmethod
+    def add_lien(self, property_id: int, loan_id: str, lienholder_id: int, principal: float) -> Optional[str]:
+        """Adds a lien to a property, returns a unique lien_id."""
+        ...
+
+    @abstractmethod
+    def remove_lien(self, property_id: int, lien_id: str) -> bool:
+        """Removes a lien from a property."""
+        ...
+
+    @abstractmethod
+    def transfer_ownership(self, property_id: int, new_owner_id: int) -> bool:
+        """Finalizes the transfer of the property."""
+        ...
+
 class ISagaRepository(ABC):
     """
     Interface for querying the state of active Sagas.
diff --git a/modules/finance/saga_handler.py b/modules/finance/saga_handler.py
index e0408ed..316c921 100644
--- a/modules/finance/saga_handler.py
+++ b/modules/finance/saga_handler.py
@@ -1,18 +1,17 @@
-from typing import Any, Optional, cast, List, Tuple
+from typing import Any, Optional, cast, List, Tuple, Literal
 import logging
 from uuid import UUID
 
-from modules.housing.api import IHousingTransactionSagaHandler
-from modules.housing.dtos import (
+from modules.finance.sagas.housing_api import (
+    IHousingTransactionSagaHandler,
     HousingTransactionSagaStateDTO,
-    MortgageApprovalDTO
+    MortgageApprovalDTO,
+    IPropertyRegistry,
+    ILoanMarket
 )
-# Use new API for application DTO construction
 from modules.market.housing_planner_api import MortgageApplicationDTO
-
 from modules.simulation.api import ISimulationState
 from simulation.finance.api import ISettlementSystem, IFinancialEntity
-from simulation.systems.api import IRegistry
 from simulation.models import Transaction
 
 logger = logging.getLogger(__name__)
@@ -20,147 +19,268 @@ logger = logging.getLogger(__name__)
 class HousingTransactionSagaHandler(IHousingTransactionSagaHandler):
     def __init__(self, simulation: ISimulationState):
         self.simulation = simulation
-        # Access systems via simulation
         self.settlement_system: ISettlementSystem = simulation.settlement_system
-        self.registry: IRegistry = simulation.registry
-        # We access loan market via simulation.markets
+        # Note: Registry in simulation must implement IPropertyRegistry methods
+        self.registry = simulation.registry
         self.loan_market = simulation.markets.get("loan")
 
     def execute_step(self, saga: HousingTransactionSagaStateDTO) -> HousingTransactionSagaStateDTO:
         status = saga['status']
+        logger.debug(f"SAGA_EXECUTE | Saga {saga['saga_id']} processing step: {status}")
+
+        current_tick = self.simulation.time
+        # Prevent double processing in same tick
+        if saga['last_processed_tick'] == current_tick and status != "INITIATED":
+             return saga
 
         try:
             if status == "INITIATED":
                 return self._handle_initiated(saga)
-            # Legacy states handling (if saga resumes from persistence in old state)
-            elif status in ["LOAN_APPROVED", "DOWN_PAYMENT_COMPLETE", "MORTGAGE_DISBURSEMENT_COMPLETE"]:
-                logger.warning(f"Resuming saga {saga['saga_id']} from intermediate state {status}. Attempting to complete via legacy path or aborting.")
-                # For safety in this refactor, we fail them to force rollback or clean state.
-                saga['status'] = "FAILED_ROLLED_BACK"
-                saga['error_message'] = "Intermediate state not supported in Atomic V2"
+            elif status == "CREDIT_CHECK":
+                return self._handle_credit_check(saga)
+            elif status == "APPROVED":
+                return self._handle_approved(saga)
+            elif status == "ESCROW_LOCKED":
+                return self._handle_escrow_locked(saga)
+            elif status == "TRANSFER_TITLE":
+                return self._handle_transfer_title(saga)
+            elif status in ["COMPLETED", "FAILED_ROLLED_BACK"]:
                 return saga
+            else:
+                logger.error(f"SAGA_UNKNOWN_STATE | Saga {saga['saga_id']} in unknown state {status}")
+                return self.compensate_step(saga)
 
         except Exception as e:
             logger.exception(f"SAGA_CRITICAL_FAIL | Saga {saga['saga_id']} failed at {status}. {e}")
-            saga['status'] = "FAILED_ROLLED_BACK"
             saga['error_message'] = str(e)
+            return self.compensate_step(saga)
+        finally:
+            saga['last_processed_tick'] = current_tick
+
+    def compensate_step(self, saga: HousingTransactionSagaStateDTO) -> HousingTransactionSagaStateDTO:
+        status = saga['status']
+        logger.warning(f"SAGA_COMPENSATE | Rolling back saga {saga['saga_id']} from {status}")
+
+        try:
+            # 1. Reverse Settlement if needed
+            if status == "TRANSFER_TITLE":
+                 # If failed at TITLE transfer, funds were moved in ESCROW_LOCKED.
+                 self._reverse_settlement(saga)
+
+            # 2. Cleanup Financials (Loan & Lien)
+            if saga.get('mortgage_approval'):
+                 # Remove Lien
+                 lien_id = saga['mortgage_approval']['lien_id']
+                 if hasattr(self.registry, 'remove_lien'):
+                    self.registry.remove_lien(saga['property_id'], lien_id)
+
+                 # Void Loan
+                 loan_id = saga['mortgage_approval']['loan_id']
+                 if hasattr(self.loan_market, 'void_staged_application'):
+                    self.loan_market.void_staged_application(loan_id)
+
+            # 3. Cleanup Staged Loan (if no approval yet)
+            elif saga.get('staged_loan_id'):
+                 if hasattr(self.loan_market, 'void_staged_application'):
+                    self.loan_market.void_staged_application(saga['staged_loan_id'])
+
+            # 4. Release Property Lock
+            if hasattr(self.registry, 'release_contract'):
+                self.registry.release_contract(saga['property_id'], saga['saga_id'])
+
+            saga['status'] = "FAILED_ROLLED_BACK"
+
+        except Exception as e:
+            logger.critical(f"SAGA_ROLLBACK_FAIL | Failed to rollback saga {saga['saga_id']}. {e}")
+            saga['status'] = "FAILED_ROLLED_BACK"
 
         return saga
 
     def _handle_initiated(self, saga: HousingTransactionSagaStateDTO) -> HousingTransactionSagaStateDTO:
-        # 1. Resolve Seller ID if not set
+        # 1. Lock Property
+        if hasattr(self.registry, 'set_under_contract'):
+             success = self.registry.set_under_contract(saga['property_id'], saga['saga_id'])
+             if not success:
+                 saga['error_message'] = "Property already under contract"
+                 # Can't rollback lock if we didn't get it, but compensate handles cleanup
+                 return self.compensate_step(saga)
+
+        # 2. Resolve Seller
         if saga['seller_id'] == -1:
-             prop_id = saga['property_id']
-             # Access real_estate_units from simulation
              units = getattr(self.simulation, 'real_estate_units', [])
-             if not units and hasattr(self.simulation, 'world_state'):
-                 units = getattr(self.simulation.world_state, 'real_estate_units', [])
-
-             unit = next((u for u in units if hasattr(u, 'id') and u.id == prop_id), None)
+             unit = next((u for u in units if hasattr(u, 'id') and u.id == saga['property_id']), None)
              if unit:
                  saga['seller_id'] = unit.owner_id
-                 logger.debug(f"SAGA_INIT | Resolved seller {unit.owner_id} for property {prop_id}")
              else:
-                 logger.error(f"SAGA_FAIL | Property {prop_id} not found in registry.")
-                 saga['status'] = "FAILED_ROLLED_BACK"
                  saga['error_message'] = "Property not found"
-                 return saga
+                 return self.compensate_step(saga)
 
-        # 2. Prepare Mortgage Application (New API)
+        # 3. Prepare Application
         principal = saga['offer_price'] - saga['down_payment_amount']
-        buyer_id = saga['buyer_id']
-        household = self.simulation.agents.get(buyer_id)
+        buyer = self.simulation.agents.get(saga['buyer_id'])
 
-        # Estimate Income/Debt
         income = 0.0
-        if household and hasattr(household, 'current_wage'):
+        if buyer and hasattr(buyer, 'current_wage'):
              ticks_per_year = getattr(self.simulation.config_module, 'TICKS_PER_YEAR', 100)
-             income = household.current_wage * ticks_per_year
-
-        # For debt, we pass 0.0 if unknown, or let LoanMarket/Bank query internally.
-        # LoanMarket.evaluate logic handles internal query fallback.
+             income = buyer.current_wage * ticks_per_year
 
         app_dto: MortgageApplicationDTO = {
-            "applicant_id": buyer_id,
+            "applicant_id": saga['buyer_id'],
             "principal": principal,
             "purpose": "MORTGAGE",
             "property_id": saga['property_id'],
             "property_value": saga['offer_price'],
             "applicant_income": income,
-            "applicant_existing_debt": 0.0, # Placeholder
+            "applicant_existing_debt": 0.0,
             "loan_term": 360
         }
-
-        # Store in saga (compatibility cast)
         saga['loan_application'] = app_dto # type: ignore
 
-        # 3. Stage Mortgage
-        if not self.loan_market or not hasattr(self.loan_market, 'stage_mortgage'):
-             logger.error("LoanMarket missing or incompatible (no stage_mortgage)")
-             saga['status'] = "FAILED_ROLLED_BACK"
-             saga['error_message'] = "System Error: LoanMarket incompatible"
-             return saga
+        # 4. Stage Mortgage
+        staged_id_info = self.loan_market.stage_mortgage(app_dto)
+        if not staged_id_info:
+             saga['error_message'] = "Loan staging rejected"
+             return self.compensate_step(saga)
 
-        loan_id = self.loan_market.stage_mortgage(app_dto)
+        # stage_mortgage returns dict, get 'loan_id'
+        saga['staged_loan_id'] = staged_id_info['loan_id']
 
-        if loan_id is None:
-             saga['status'] = "LOAN_REJECTED"
-             saga['error_message'] = "Loan rejected or staging failed"
-             return saga
+        saga['status'] = "CREDIT_CHECK"
+        return saga
 
-        # Record Approval
+    def _handle_credit_check(self, saga: HousingTransactionSagaStateDTO) -> HousingTransactionSagaStateDTO:
+        # Asynchronous check
+        status = self.loan_market.check_staged_application_status(saga['staged_loan_id'])
+
+        if status == "APPROVED":
+            saga['status'] = "APPROVED"
+        elif status == "REJECTED":
+            saga['error_message'] = "Credit check rejected"
+            return self.compensate_step(saga)
+        else:
+            # PENDING, wait next tick
+            pass
+
+        return saga
+
+    def _handle_approved(self, saga: HousingTransactionSagaStateDTO) -> HousingTransactionSagaStateDTO:
+        # Finalize Loan & Create Lien
+        # 1. Convert/Retrieve Loan Info
+        loan_info = self.loan_market.convert_staged_to_loan(saga['staged_loan_id'])
+        if not loan_info:
+             saga['error_message'] = "Failed to convert staged loan"
+             return self.compensate_step(saga)
+
+        loan_id = loan_info['loan_id']
+        principal = loan_info['original_amount']
+
+        # 2. Add Lien via Registry
+        # Need lienholder_id (Bank ID).
+        # LoanInfo might not have it, but we know it's the Bank.
+        bank_id = self.simulation.bank.id if self.simulation.bank else -1
+
+        lien_id = self.registry.add_lien(saga['property_id'], loan_id, bank_id, principal)
+        if not lien_id:
+             saga['error_message'] = "Failed to create lien"
+             return self.compensate_step(saga)
+
+        # 3. Store Approval
         saga['mortgage_approval'] = {
             "loan_id": loan_id,
+            "lien_id": lien_id,
             "approved_principal": principal,
-            "monthly_payment": 0.0 # Not needed for settlement
+            "monthly_payment": 0.0 # Placeholder
         }
 
-        # 4. Atomic Settlement (Seamless Payment)
+        saga['status'] = "ESCROW_LOCKED"
+        return saga
+
+    def _handle_escrow_locked(self, saga: HousingTransactionSagaStateDTO) -> HousingTransactionSagaStateDTO:
+        # Execute Transfers (Settlement)
         # Bank -> Buyer (Principal)
-        # Buyer -> Seller (Full Price)
+        # Buyer -> Seller (Offer Price)
 
         bank = self.simulation.bank
-        buyer = household
+        buyer = self.simulation.agents.get(saga['buyer_id'])
         seller = self.simulation.agents.get(saga['seller_id'])
-
         if saga['seller_id'] == -1 and hasattr(self.simulation, 'government'):
              seller = self.simulation.government
 
-        if not buyer or not seller or not bank:
-             # Abort and Void Loan
-             self._void_loan(loan_id)
-             saga['status'] = "FAILED_ROLLED_BACK"
-             saga['error_message'] = "Agents not found for settlement"
-             return saga
+        if not buyer or not seller:
+             saga['error_message'] = "Agents missing for settlement"
+             return self.compensate_step(saga)
+
+        principal = saga['mortgage_approval']['approved_principal']
+        offer_price = saga['offer_price']
 
         transfers: List[Tuple[IFinancialEntity, IFinancialEntity, float]] = [
             (bank, buyer, principal),
-            (buyer, seller, saga['offer_price'])
+            (buyer, seller, offer_price)
         ]
 
-        if not hasattr(self.settlement_system, 'execute_multiparty_settlement'):
-             logger.error("SettlementSystem missing execute_multiparty_settlement")
-             self._void_loan(loan_id)
-             saga['status'] = "FAILED_ROLLED_BACK"
+        success = self.settlement_system.execute_multiparty_settlement(transfers, self.simulation.time)
+
+        if success:
+             saga['status'] = "TRANSFER_TITLE"
+             # Optionally process next step immediately?
+             # Or wait next tick? State machine usually one step per tick unless we want fast track.
+             # Draft says "If fund transfers are successful, transition to TRANSFER_TITLE."
+             # It doesn't explicitly say "wait".
+             # But returning ensures state is persisted.
              return saga
+        else:
+             saga['error_message'] = "Settlement failed"
+             return self.compensate_step(saga)
 
-        success = self.settlement_system.execute_multiparty_settlement(transfers, self.simulation.time)
+    def _handle_transfer_title(self, saga: HousingTransactionSagaStateDTO) -> HousingTransactionSagaStateDTO:
+        # Finalize Ownership
+        success = self.registry.transfer_ownership(saga['property_id'], saga['buyer_id'])
 
         if success:
-             # 5. Finalize
-             self._finalize_transaction(saga, loan_id)
+             self._log_transaction(saga)
+             # Release lock is done implicitly by completion?
+             # Or should we explicit release?
+             # Draft: "Call PropertyRegistry.transfer_ownership... Transition to COMPLETED."
+             # Usually ownership transfer overrides contract lock or lock is ignored for new owner.
+             # But good hygiene: release lock.
+             self.registry.release_contract(saga['property_id'], saga['saga_id'])
+
              saga['status'] = "COMPLETED"
-             logger.info(f"SAGA_SUCCESS | Atomic purchase complete for {buyer_id} prop {saga['property_id']}")
         else:
-             # 6. Rollback (Void Loan)
-             # Settlement already rolled back transfers. We just need to kill the staged loan.
-             self._void_loan(loan_id)
-             saga['status'] = "FAILED_ROLLED_BACK"
-             saga['error_message'] = "Settlement failed (Funds or Validation)"
+             saga['error_message'] = "Title transfer failed"
+             return self.compensate_step(saga)
 
         return saga
 
-    def _finalize_transaction(self, saga: HousingTransactionSagaStateDTO, loan_id: int):
+    def _reverse_settlement(self, saga: HousingTransactionSagaStateDTO):
+        # Reverse the transfers done in ESCROW_LOCKED
+        # Seller -> Buyer (Offer Price)
+        # Buyer -> Bank (Principal)
+
+        bank = self.simulation.bank
+        buyer = self.simulation.agents.get(saga['buyer_id'])
+        seller = self.simulation.agents.get(saga['seller_id'])
+        if saga['seller_id'] == -1 and hasattr(self.simulation, 'government'):
+             seller = self.simulation.government
+
+        if not buyer or not seller:
+             logger.error("Cannot reverse settlement: agents missing")
+             return
+
+        principal = saga['mortgage_approval']['approved_principal']
+        offer_price = saga['offer_price']
+
+        transfers = [
+            (seller, buyer, offer_price),
+            (buyer, bank, principal)
+        ]
+
+        self.settlement_system.execute_multiparty_settlement(transfers, self.simulation.time)
+        logger.info(f"SAGA_ROLLBACK | Reversed settlement for saga {saga['saga_id']}")
+
+    def _log_transaction(self, saga: HousingTransactionSagaStateDTO):
+        loan_id = saga['mortgage_approval']['loan_id'] if saga.get('mortgage_approval') else None
+
         tx_record = Transaction(
             buyer_id=saga['buyer_id'],
             seller_id=saga['seller_id'],
@@ -173,48 +293,9 @@ class HousingTransactionSagaHandler(IHousingTransactionSagaHandler):
             metadata={"mortgage_id": loan_id}
         )
 
-        buyer = self.simulation.agents.get(saga['buyer_id'])
-        seller = self.simulation.agents.get(saga['seller_id'])
-        if saga['seller_id'] == -1 and hasattr(self.simulation, 'government'):
-             seller = self.simulation.government
-
-        # Registry update
-        self.registry.update_ownership(tx_record, buyer, seller, self.simulation.world_state if hasattr(self.simulation, 'world_state') else self.simulation)
-
-        # Record Transaction
+        # We don't need to call registry.update_ownership again because we called transfer_ownership.
+        # But we need to log it for history.
         if hasattr(self.simulation, 'world_state'):
              self.simulation.world_state.transactions.append(tx_record)
-
-    def _void_loan(self, loan_id: int):
-         # Call Bank.terminate_loan or void_loan
-         # loan_id is int, Bank methods usually take str (e.g. "loan_123")
-         # We assume LoanMarket returned the numeric part or hash.
-         # Actually Bank uses "loan_X" strings.
-         # LoanMarket.stage_mortgage returned int.
-         # This implies LoanMarket parsed it.
-         # To void, we need to reconstruct the string ID or iterate?
-         # Bank.terminate_loan(loan_id: str).
-
-         # Issue: LoanMarket.stage_mortgage returns INT. Bank has STRING keys "loan_1".
-         # We need the string ID.
-         # I should update LoanMarket.stage_mortgage to return string or SagaHandler to handle string?
-         # HousingTransactionSagaStateDTO uses int for loan_id (in MortgageApprovalDTO).
-
-         # Best effort: Try to find loan in bank with matching numeric part or just "loan_{loan_id}"
-
-         # Access Bank loans directly to find it?
-         bank = self.simulation.bank
-         lid_str = f"loan_{loan_id}"
-         if lid_str in bank.loans:
-             bank.terminate_loan(lid_str)
-         else:
-             # Try search
-             found = None
-             for k in bank.loans.keys():
-                 if str(loan_id) in k: # risky
-                     found = k
-                     break
-             if found:
-                 bank.terminate_loan(found)
-             else:
-                 logger.warning(f"SAGA_VOID_FAIL | Could not find loan to void: {loan_id}")
+        elif hasattr(self.simulation, 'transactions'):
+             self.simulation.transactions.append(tx_record)
diff --git a/modules/finance/sagas/housing_api.py b/modules/finance/sagas/housing_api.py
new file mode 100644
index 0000000..202d636
--- /dev/null
+++ b/modules/finance/sagas/housing_api.py
@@ -0,0 +1,138 @@
+from typing import TypedDict, Literal, Optional, Protocol, List, Dict
+from uuid import UUID
+from dataclasses import dataclass
+
+from modules.market.housing_planner_api import MortgageApplicationDTO
+
+# --- DTOs for Saga State & Payloads ---
+
+class MortgageApprovalDTO(TypedDict):
+    """
+    Represents the confirmed details of an approved mortgage.
+    """
+    loan_id: str  # Bank-issued unique loan identifier (string)
+    lien_id: str  # Registry-issued unique lien identifier
+    approved_principal: float
+    monthly_payment: float
+
+class HousingTransactionSagaStateDTO(TypedDict):
+    """
+    State object for the multi-tick housing purchase Saga.
+    This object is persisted across ticks to manage the transaction lifecycle.
+    """
+    saga_id: UUID
+    status: Literal[
+        # Staging & Validation
+        "INITIATED",            # -> Awaiting credit check
+        "CREDIT_CHECK",         # -> Loan Approved or Rejected
+        "APPROVED",             # -> Awaiting funds lock in escrow
+        # Execution & Settlement
+        "ESCROW_LOCKED",        # -> Awaiting final title transfer
+        "TRANSFER_TITLE",       # -> Completed or Failed
+        # Terminal States
+        "COMPLETED",
+        "FAILED_ROLLED_BACK"
+    ]
+    buyer_id: int
+    seller_id: int
+    property_id: int
+    offer_price: float
+    down_payment_amount: float
+
+    # State-specific payloads, populated as the saga progresses
+    loan_application: Optional[MortgageApplicationDTO]
+    mortgage_approval: Optional[MortgageApprovalDTO]
+
+    # Tracking IDs for compensation
+    staged_loan_id: Optional[str]
+
+    # Error logging
+    error_message: Optional[str]
+    last_processed_tick: int
+
+# --- System Interfaces ---
+
+class IProperty(Protocol):
+    id: int
+    owner_id: int
+    is_under_contract: bool
+    liens: List[str]
+
+class IPropertyRegistry(Protocol):
+    """
+    Interface for a system managing property ownership and status.
+    Alias or refinement of IRealEstateRegistry for the Saga context.
+    """
+    def set_under_contract(self, property_id: int, saga_id: UUID) -> bool:
+        """Locks a property, preventing other sales. Returns False if already locked."""
+        ...
+
+    def release_contract(self, property_id: int, saga_id: UUID) -> bool:
+        """Releases the lock on a property."""
+        ...
+
+    def add_lien(self, property_id: int, loan_id: str) -> Optional[str]:
+        """Adds a lien to a property, returns a unique lien_id."""
+        ...
+
+    def remove_lien(self, property_id: int, lien_id: str) -> bool:
+        """Removes a lien from a property."""
+        ...
+
+    def transfer_ownership(self, property_id: int, new_owner_id: int) -> bool:
+        """Finalizes the transfer of the property."""
+        ...
+
+class ILoanMarket(Protocol):
+    """
+    Interface for the loan market.
+    """
+    def stage_mortgage_application(self, application: MortgageApplicationDTO) -> Optional[str]:
+        """
+        Submits an application for asynchronous credit check.
+        Returns a unique `staged_loan_id` for tracking, or None if invalid.
+        """
+        ...
+
+    def check_staged_application_status(self, staged_loan_id: str) -> Literal["PENDING", "APPROVED", "REJECTED"]:
+        """Checks the status of a pending mortgage application."""
+        ...
+
+    def convert_staged_to_loan(self, staged_loan_id: str) -> Optional[MortgageApprovalDTO]:
+        """
+        Finalizes an approved application, creating an official loan and lien.
+        Returns the final loan details or None on failure.
+        """
+        ...
+
+    def void_staged_application(self, staged_loan_id: str) -> bool:
+        """Cancels a pending or approved application before funds are disbursed."""
+        ...
+
+class IHousingTransactionSagaHandler(Protocol):
+    """
+    The refactored Saga Handler, now a state machine processor.
+    """
+    def execute_step(self, saga: HousingTransactionSagaStateDTO) -> HousingTransactionSagaStateDTO:
+        """Processes a single step of the saga based on its current status."""
+        ...
+
+    def compensate_step(self, saga: HousingTransactionSagaStateDTO) -> HousingTransactionSagaStateDTO:
+        """Triggers the rollback/compensation logic for the saga's current status."""
+        ...
+
+class ISagaManager(Protocol):
+    """
+    A new system responsible for managing all active sagas.
+    """
+    def process_sagas(self) -> None:
+        """Iterates through all active sagas and executes the next step."""
+        ...
+
+    def register_saga(self, saga_state: HousingTransactionSagaStateDTO) -> None:
+        """Adds a new saga to the manager."""
+        ...
+
+    def find_and_compensate_by_agent(self, agent_id: int) -> None:
+        """Finds all sagas involving a specific agent and triggers their compensation."""
+        ...
diff --git a/modules/market/housing_planner_api.py b/modules/market/housing_planner_api.py
index 1938bda..907637d 100644
--- a/modules/market/housing_planner_api.py
+++ b/modules/market/housing_planner_api.py
@@ -35,6 +35,15 @@ class HousingDecisionDTO(TypedDict):
     offer_price: Optional[float]
     mortgage_application: Optional[MortgageApplicationDTO]
 
+class MortgageApprovalDTO(TypedDict):
+    """
+    Represents the confirmed details of an approved mortgage.
+    """
+    loan_id: str  # Bank-issued unique loan identifier (string)
+    lien_id: str  # Registry-issued unique lien identifier
+    approved_principal: float
+    monthly_payment: float
+
 class HousingBubbleMetricsDTO(TypedDict):
     """
     Data structure for monitoring housing market stability.
@@ -81,6 +90,24 @@ class ILoanMarket(ABC):
          """
          ...
 
+    @abstractmethod
+    def check_staged_application_status(self, staged_loan_id: str) -> Literal["PENDING", "APPROVED", "REJECTED"]:
+        """Checks the status of a pending mortgage application."""
+        ...
+
+    @abstractmethod
+    def convert_staged_to_loan(self, staged_loan_id: str) -> Optional[dict]:
+        """
+        Finalizes an approved application, creating an official loan.
+        Returns the final loan details (LoanInfoDTO dict) or None on failure.
+        """
+        ...
+
+    @abstractmethod
+    def void_staged_application(self, staged_loan_id: str) -> bool:
+        """Cancels a pending or approved application before funds are disbursed."""
+        ...
+
 class IBubbleObservatory(ABC):
     """
     Interface for the new market monitoring system.
diff --git a/simulation/loan_market.py b/simulation/loan_market.py
index f08b197..c07c5e0 100644
--- a/simulation/loan_market.py
+++ b/simulation/loan_market.py
@@ -1,4 +1,4 @@
-from typing import List, Any, Optional, override, TYPE_CHECKING
+from typing import List, Any, Optional, override, TYPE_CHECKING, Literal
 import logging
 
 from simulation.models import Order, Transaction
@@ -175,6 +175,38 @@ class LoanMarket(Market, ILoanMarket):
 
         return loan_info
 
+    def check_staged_application_status(self, staged_loan_id: str) -> Literal["PENDING", "APPROVED", "REJECTED"]:
+        """Checks the status of a pending mortgage application."""
+        # Check if loan exists in Bank
+        if hasattr(self.bank, 'loans') and staged_loan_id in self.bank.loans:
+             return "APPROVED"
+        return "REJECTED"
+
+    def convert_staged_to_loan(self, staged_loan_id: str) -> Optional[dict]:
+        """
+        Finalizes an approved application.
+        Returns LoanInfoDTO dict.
+        """
+        if hasattr(self.bank, 'loans') and staged_loan_id in self.bank.loans:
+             loan = self.bank.loans[staged_loan_id]
+             return {
+                 "loan_id": staged_loan_id,
+                 "borrower_id": str(loan.borrower_id),
+                 "original_amount": loan.principal,
+                 "outstanding_balance": loan.remaining_balance,
+                 "interest_rate": loan.annual_interest_rate,
+                 "origination_tick": loan.origination_tick,
+                 "due_tick": loan.start_tick + loan.term_ticks
+             }
+        return None
+
+    def void_staged_application(self, staged_loan_id: str) -> bool:
+        """Cancels a pending or approved application."""
+        if hasattr(self.bank, 'terminate_loan'):
+             self.bank.terminate_loan(staged_loan_id)
+             return True
+        return False
+
     def request_mortgage(self, application: MortgageApplicationDTO, household_agent: Any = None, current_tick: int = 0) -> Optional[MortgageApprovalDTO]:
         """
         Legacy/Compat method.
diff --git a/simulation/systems/registry.py b/simulation/systems/registry.py
index 081da94..a9231b2 100644
--- a/simulation/systems/registry.py
+++ b/simulation/systems/registry.py
@@ -1,5 +1,6 @@
-from typing import Any, List, Optional
+from typing import Any, List, Optional, Dict
 import logging
+from uuid import UUID
 from modules.finance.api import LienDTO
 from simulation.systems.api import IRegistry
 from simulation.models import Transaction
@@ -17,6 +18,63 @@ class Registry(IRegistry):
 
     def __init__(self, logger: Optional[logging.Logger] = None):
         self.logger = logger if logger else logging.getLogger(__name__)
+        self.contract_locks: Dict[int, UUID] = {}
+        self.real_estate_units: List[Any] = []
+
+    def set_real_estate_units(self, units: List[Any]) -> None:
+        self.real_estate_units = units
+
+    def is_under_contract(self, property_id: int) -> bool:
+        return property_id in self.contract_locks
+
+    def set_under_contract(self, property_id: int, saga_id: UUID) -> bool:
+        if property_id in self.contract_locks:
+             return False
+        self.contract_locks[property_id] = saga_id
+        return True
+
+    def release_contract(self, property_id: int, saga_id: UUID) -> bool:
+        if self.contract_locks.get(property_id) == saga_id:
+             del self.contract_locks[property_id]
+             return True
+        return False
+
+    def add_lien(self, property_id: int, loan_id: str, lienholder_id: int, principal: float) -> Optional[str]:
+        unit = next((u for u in self.real_estate_units if u.id == property_id), None)
+        if not unit:
+             return None
+
+        # Check if already has this loan lien
+        if any(l['loan_id'] == loan_id for l in unit.liens):
+             return f"lien_{loan_id}"
+
+        lien_id = f"lien_{loan_id}"
+        new_lien: LienDTO = {
+            "loan_id": loan_id,
+            "lienholder_id": lienholder_id,
+            "principal_remaining": principal,
+            "lien_type": "MORTGAGE"
+        }
+        unit.liens.append(new_lien)
+        return lien_id
+
+    def remove_lien(self, property_id: int, lien_id: str) -> bool:
+        unit = next((u for u in self.real_estate_units if u.id == property_id), None)
+        if not unit:
+             return False
+
+        original_len = len(unit.liens)
+        # Remove if lien_id matches generated ID or raw loan_id
+        unit.liens = [l for l in unit.liens if f"lien_{l['loan_id']}" != lien_id and l['loan_id'] != lien_id]
+
+        return len(unit.liens) < original_len
+
+    def transfer_ownership(self, property_id: int, new_owner_id: int) -> bool:
+        unit = next((u for u in self.real_estate_units if u.id == property_id), None)
+        if not unit:
+             return False
+        unit.owner_id = new_owner_id
+        return True
 
     def update_ownership(self, transaction: Transaction, buyer: Any, seller: Any, state: SimulationState) -> None:
         """
diff --git a/simulation/systems/settlement_system.py b/simulation/systems/settlement_system.py
index 48e5fbc..660e13d 100644
--- a/simulation/systems/settlement_system.py
+++ b/simulation/systems/settlement_system.py
@@ -1,5 +1,6 @@
 from typing import Optional, Dict, Any, cast, TYPE_CHECKING, Tuple, List
 import logging
+from uuid import UUID
 
 from simulation.finance.api import ISettlementSystem, ITransaction
 from modules.finance.api import (
@@ -7,7 +8,8 @@ from modules.finance.api import (
     IPortfolioHandler, PortfolioDTO, PortfolioAsset, IHeirProvider, LienDTO
 )
 from simulation.dtos.settlement_dtos import LegacySettlementAccount
-from modules.market.housing_purchase_api import HousingPurchaseSagaDTO
+from modules.finance.sagas.housing_api import HousingTransactionSagaStateDTO, IHousingTransactionSagaHandler
+from modules.finance.saga_handler import HousingTransactionSagaHandler
 from modules.market.housing_planner_api import MortgageApplicationDTO
 
 if TYPE_CHECKING:
@@ -29,18 +31,19 @@ class SettlementSystem(ISettlementSystem):
         self.bank = bank # TD-179: Reference to Bank for Seamless Payments
         self.total_liquidation_losses: float = 0.0
         self.settlement_accounts: Dict[int, LegacySettlementAccount] = {} # TD-160
-        self.sagas: Dict[str, HousingPurchaseSagaDTO] = {} # Housing Saga Storage
+        self.active_sagas: Dict[UUID, HousingTransactionSagaStateDTO] = {}
 
-    def submit_saga(self, saga: HousingPurchaseSagaDTO) -> bool:
+    def submit_saga(self, saga: Any) -> bool:
         """
         Submits a new saga to be processed.
         """
         if not saga or 'saga_id' not in saga:
             return False
-        self.sagas[saga['saga_id']] = saga
+        # Cast to new DTO type hint
+        self.active_sagas[saga['saga_id']] = saga
         self.logger.info(
-            f"SAGA_SUBMITTED | Saga {saga['saga_id']} submitted for buyer {saga['data']['household_id']}.",
-            extra={"tick": saga['start_tick'], "saga_id": saga['saga_id']}
+            f"SAGA_SUBMITTED | Saga {saga['saga_id']} submitted.",
+            extra={"saga_id": saga['saga_id']}
         )
         return True
 
@@ -49,170 +52,58 @@ class SettlementSystem(ISettlementSystem):
         Processes active sagas. Implements the Housing Transaction Saga state machine.
         Called by TickOrchestrator.
         """
-        if not self.sagas:
+        if not self.active_sagas:
             return
 
-        tick = simulation_state.time
+        handler = HousingTransactionSagaHandler(simulation_state)
 
         # Iterate over copy to allow modification/deletion
-        for saga_id, saga in list(self.sagas.items()):
+        for saga_id, saga in list(self.active_sagas.items()):
             try:
-                self._process_single_saga(saga, simulation_state, tick)
+                # Delegate to Handler
+                updated_saga = handler.execute_step(saga)
+                self.active_sagas[saga_id] = updated_saga
 
                 # Cleanup Terminal States
-                if saga['status'] in ["COMPLETED", "FAILED_ROLLED_BACK", "LOAN_REJECTED", "FAILED_COMPENSATED"]:
-                    if saga['status'] == "COMPLETED":
+                status = updated_saga['status']
+                if status in ["COMPLETED", "FAILED_ROLLED_BACK"]:
+                    if status == "COMPLETED":
                         self.logger.info(f"SAGA_ARCHIVED | Saga {saga_id} completed successfully.")
                     else:
-                        self.logger.info(f"SAGA_ARCHIVED | Saga {saga_id} ended with {saga['status']}.")
+                        self.logger.info(f"SAGA_ARCHIVED | Saga {saga_id} ended with {status}.")
 
-                    del self.sagas[saga_id]
-            except Exception as e:
-                self.logger.error(f"SAGA_PROCESS_ERROR | Saga {saga_id} failed. {e}")
-                saga['status'] = "FAILED_COMPENSATED" # Fail safe
-
-    def _process_single_saga(self, saga: HousingPurchaseSagaDTO, state: Any, tick: int):
-        status = saga['status']
-        data = saga['data']
-
-        # Step 1: STARTED -> LOAN_APPLICATION_PENDING -> LOAN_APPROVED/REJECTED
-        if status == "STARTED":
-            # Action: Invoke ILoanMarket.apply_for_mortgage
-            loan_market = state.markets.get("loan_market") or state.markets.get("loan")
-
-            if not loan_market:
-                self.logger.error("SAGA_FAIL | Loan Market not found.")
-                saga['status'] = "FAILED_ROLLED_BACK"
-                return
-
-            # Update status to indicate processing (Tick T)
-            saga['status'] = "LOAN_APPLICATION_PENDING"
-
-            # Execute Application
-            try:
-                # Assuming synchronous return for now as per current LoanMarket impl
-                # If async, we would leave it in PENDING and check next tick.
-                loan_dto = loan_market.apply_for_mortgage(data['mortgage_application'])
-
-                if loan_dto:
-                    # Success
-                    data['approved_loan_id'] = loan_dto['loan_id']
-                    # Transition to APPROVED
-                    saga['status'] = "LOAN_APPROVED"
-                    self.logger.info(f"SAGA_LOAN_APPROVED | Loan {loan_dto['loan_id']} approved for Saga {saga['saga_id']}")
-                else:
-                    # Failure (LTV/DTI)
-                    saga['status'] = "LOAN_REJECTED"
-                    self.logger.info(f"SAGA_LOAN_REJECTED | Loan denied for Saga {saga['saga_id']}")
+                    del self.active_sagas[saga_id]
 
             except Exception as e:
-                self.logger.error(f"SAGA_LOAN_ERROR | {e}")
-                saga['status'] = "FAILED_ROLLED_BACK"
-
-        # Step 2: LOAN_APPROVED -> PROPERTY_TRANSFER_PENDING -> COMPLETED
-        elif status == "LOAN_APPROVED":
-            # Wait for Tick T+1 (Strict Separation)
-            if tick <= saga['start_tick']:
-                return
-
-            # Action: Atomic Settlement
-            buyer_id = data['household_id']
-            seller_id = data['seller_id']
-            offer_price = data['offer_price']
-            down_payment = data['down_payment']
-            loan_principal = data['mortgage_application']['principal']
-
-            buyer = state.agents.get(buyer_id)
-            seller = state.agents.get(seller_id)
-
-            # Handle Government/Bank as seller (-1)
-            if seller_id == -1:
-                if state.government:
-                     seller = state.government
-                else:
-                     # Bank or System
-                     pass
-
-            if not buyer or (seller_id != -1 and not seller):
-                self.logger.error(f"SAGA_SETTLEMENT_FAIL | Agents not found. Buyer: {buyer_id}, Seller: {seller_id}")
-                saga['status'] = "FAILED_COMPENSATED"
-                self._void_loan(state, data['approved_loan_id'])
-                return
-
-            # Execute Multiparty Settlement
-            # 1. Bank -> Buyer (Loan Principal)
-            # 2. Buyer -> Seller (Offer Price)
-            # Note: Buyer pays Down Payment implicitly because they receive Principal and pay Full Price.
-            # Net effect on Buyer: +Principal - Price = -(Price - Principal) = -DownPayment.
-
-            transfers = [
-                (self.bank, buyer, loan_principal),
-                (buyer, seller, offer_price)
-            ]
-
-            success = self.execute_multiparty_settlement(transfers, tick)
-
-            if success:
-                saga['status'] = "PROPERTY_TRANSFER_PENDING"
-
-                # Trigger Transaction logging which Registry will pick up to update ownership
-                # Pass loan principal and lender ID for lien creation in metadata
-                lender_id = self.bank.id if self.bank else 0
-                self._log_property_transfer(state, data['property_id'], buyer_id, seller_id, offer_price,
-                                          data['approved_loan_id'], loan_principal, lender_id)
-
-                saga['status'] = "COMPLETED"
-                self.logger.info(f"SAGA_COMPLETED | Property {data['property_id']} transferred to {buyer_id}.")
-            else:
-                self.logger.error(f"SAGA_SETTLEMENT_FAIL | Multiparty settlement failed.")
-                saga['status'] = "FAILED_COMPENSATED"
-                self._void_loan(state, data['approved_loan_id'])
+                self.logger.error(f"SAGA_PROCESS_ERROR | Saga {saga_id} failed. {e}")
+                # Try to compensate
+                try:
+                    handler.compensate_step(saga)
+                except Exception:
+                    pass
+                del self.active_sagas[saga_id]
 
-    def _log_property_transfer(self, state: Any, property_id: int, buyer_id: int, seller_id: int, price: float,
-                             loan_id: Any, loan_principal: float = 0.0, lender_id: int = 0):
+    def find_and_compensate_by_agent(self, agent_id: int, handler: Optional[IHousingTransactionSagaHandler] = None) -> None:
         """
-        Logs the property transaction. The Registry will pick this up to update ownership/liens.
-        Also manually updates critical Agent state if Registry is not immediate, to prevent same-tick inconsistency.
+        Finds all sagas involving a specific agent and triggers their compensation.
+        Note: handler must be provided if calling outside process_sagas (where handler is local).
         """
-        metadata = {
-            "mortgage_id": loan_id,
-            "executed": True,
-            "loan_principal": loan_principal,
-            "lender_id": lender_id
-        }
-
-        # Create Transaction Object
-        from simulation.models import Transaction
-        tx_obj = Transaction(
-            buyer_id=buyer_id,
-            seller_id=seller_id,
-            item_id=f"unit_{property_id}",
-            quantity=1.0,
-            price=price,
-            market_id="housing",
-            transaction_type="housing",
-            time=state.time,
-            metadata=metadata
-        )
-        state.transactions.append(tx_obj)
+        if not self.active_sagas:
+            return
 
-        # Force Registry Update Immediately (if available) to ensure consistency
-        if hasattr(state, 'registry') and state.registry:
-             buyer = state.agents.get(buyer_id)
-             seller = state.agents.get(seller_id)
-             state.registry.update_ownership(tx_obj, buyer, seller, state)
-        else:
-             # Fallback: We rely on TickOrchestrator to run Registry later.
-             # BUT, for immediate consistency (Saga completed), we might need to trust the Registry will catch up.
-             pass
+        if not handler:
+             self.logger.error("SAGA_COMPENSATE_FAIL | No handler provided for find_and_compensate_by_agent")
+             return
 
-    def _void_loan(self, state: Any, loan_id: Any):
-        if not loan_id:
-            return
-        if self.bank and hasattr(self.bank, 'terminate_loan'):
-             # Try to find the full loan ID string if loan_id is int
-             # But here we likely have the ID returned by stage_mortgage
-             self.bank.terminate_loan(str(loan_id)) # Best effort
+        for saga_id, saga in list(self.active_sagas.items()):
+            if saga['buyer_id'] == agent_id or saga['seller_id'] == agent_id:
+                self.logger.warning(f"SAGA_AGENT_DEATH | Triggering compensation for Saga {saga_id} due to agent {agent_id} death.")
+                try:
+                    updated_saga = handler.compensate_step(saga)
+                    if updated_saga['status'] == "FAILED_ROLLED_BACK":
+                        del self.active_sagas[saga_id]
+                except Exception as e:
+                    self.logger.critical(f"SAGA_AGENT_DEATH_FAIL | Failed to compensate saga {saga_id}. {e}")
 
     def create_settlement(
         self,
