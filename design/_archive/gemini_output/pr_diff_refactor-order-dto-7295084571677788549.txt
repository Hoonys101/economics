diff --git a/communications/insights/TDL-028_Market_Order_Refactor.md b/communications/insights/TDL-028_Market_Order_Refactor.md
new file mode 100644
index 0000000..edad9b2
--- /dev/null
+++ b/communications/insights/TDL-028_Market_Order_Refactor.md
@@ -0,0 +1,28 @@
+# Insight Report: Market Order Refactor (TDL-028)
+
+## 1. Phenomenon
+The legacy `Order` class was a mutable data structure used inconsistently across the codebase (sometimes as a raw dictionary, sometimes as a class). This led to:
+- **Side-effect risks**: Decision engines could accidentally mutate orders after submission.
+- **Type instability**: Inconsistent field names (`order_type` vs `side`, `price` vs `price_limit`).
+- **Testing friction**: Difficulty in mocking and verifying order intent.
+
+## 2. Cause
+The initial implementation prioritized rapid prototyping, leading to "God Objects" and leaky abstractions where market logic and agent logic shared mutable state references.
+
+## 3. Solution (Refactoring Strategy)
+We implemented the **Phase 6/7 Standardized Order Protocol**:
+1.  **Immutable Contract**: Introduced `OrderDTO` (frozen dataclass) in `modules/market/api.py`.
+2.  **Field Standardization**: Renamed `order_type` -> `side` and `price` -> `price_limit` to align with financial industry standards (FIX protocol style).
+3.  **Market Adaptation**: Refactored `OrderBookMarket` to accept immutable DTOs but convert them internally to a mutable `MarketOrder` representation for matching and partial fills.
+4.  **Decision Engine Updates**: Updated `AIDrivenFirmDecisionEngine`, `FinanceManager`, `SalesManager`, `OperationsManager`, and `HRManager` to use `dataclasses.replace` for "modifying" orders (e.g., repricing logic), ensuring purity.
+
+## 4. Technical Debt & Lessons Learned
+- **FrozenInstanceError**: The transition to immutable DTOs exposed several locations where code assumed in-place mutation (e.g., `_apply_pricing_logic`). Using `dataclasses.replace` is the correct pattern.
+- **Internal State vs. External Contract**: `OrderBookMarket` *must* maintain internal mutable state (`quantity` reduction during matching). Trying to force the *market internal logic* to be fully immutable is inefficient. The pattern of `External Immutable DTO -> Internal Mutable Entity` worked best.
+- **Legacy Aliases**: Providing `@property` aliases in `OrderDTO` (`price` -> `price_limit`) helped during the transition but should be deprecated in Phase 8.
+- **Integration Tests**: Verify end-to-end flows early. Unit tests passed because mocks accepted the new DTOs, but integration tests failed because the *instantiation* code in legacy components hadn't been updated.
+
+## 5. Verification
+- **Unit Tests**: Passed.
+- **Integration Tests**: `tests/integration/test_decision_engine_integration.py` Passed.
+- **System Integrity**: `scripts/trace_leak.py` confirmed 0.0000 leak, ensuring the refactor didn't break financial atomicity.
diff --git a/modules/government/taxation/__init__.py b/modules/government/taxation/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/modules/market/__init__.py b/modules/market/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/modules/market/api.py b/modules/market/api.py
new file mode 100644
index 0000000..2f36208
--- /dev/null
+++ b/modules/market/api.py
@@ -0,0 +1,34 @@
+from dataclasses import dataclass, field
+from typing import Optional, Dict, Any
+import uuid
+
+@dataclass(frozen=True)
+class OrderDTO:
+    """Standardized Market Order Data Transfer Object.
+    Replaces legacy dictionary/tuple usage in decision engines.
+    Immutable to prevent side-effects during processing.
+    """
+    agent_id: int | str
+    side: str  # "BUY" or "SELL" (formerly order_type)
+    item_id: str
+    quantity: float
+    price_limit: float # (formerly price) - Max for BUY, Min for SELL
+    market_id: str
+
+    # Phase 6/7 Extensions
+    target_agent_id: Optional[int] = None  # Brand Loyalty / Supply Chain
+    brand_info: Optional[Dict[str, Any]] = None # Quality, Awareness
+    metadata: Optional[Dict[str, Any]] = None # Side-effects (e.g. Loans)
+
+    # Auto-generated ID
+    id: str = field(default_factory=lambda: str(uuid.uuid4()), init=False)
+
+    @property
+    def price(self) -> float:
+        """Alias for legacy compatibility during migration."""
+        return self.price_limit
+
+    @property
+    def order_type(self) -> str:
+        """Alias for legacy compatibility during migration."""
+        return self.side
diff --git a/scripts/verify_brand_economy.py b/scripts/verify_brand_economy.py
index 4862610..f4f4894 100644
--- a/scripts/verify_brand_economy.py
+++ b/scripts/verify_brand_economy.py
@@ -97,8 +97,8 @@ def verify_brand_economy():
         "brand_awareness": firm_b.brand_manager.brand_awareness,
         "perceived_quality": firm_b.brand_manager.perceived_quality
     }
-    order_a = Order(1, "SELL", "widget", 10.0, 15.0, "goods_market", brand_info=brand_info_a)
-    order_b = Order(2, "SELL", "widget", 10.0, 10.0, "goods_market", brand_info=brand_info_b)
+    order_a = Order(agent_id=1, side="SELL", item_id="widget", quantity=10.0, price_limit=15.0, market_id="goods_market", brand_info=brand_info_a)
+    order_b = Order(agent_id=2, side="SELL", item_id="widget", quantity=10.0, price_limit=10.0, market_id="goods_market", brand_info=brand_info_b)
     
     market.place_order(order_a, 1)
     market.place_order(order_b, 1)
@@ -144,8 +144,8 @@ def verify_brand_economy():
     logger.info("--- Step D: Execution (Targeted Orders) ---")
     
     # Place targeted buy orders
-    buy_snob = Order(101, "BUY", "widget", 1.0, 20.0, "goods_market", target_agent_id=target_snob)
-    buy_miser = Order(102, "BUY", "widget", 1.0, 20.0, "goods_market", target_agent_id=target_miser)
+    buy_snob = Order(agent_id=101, side="BUY", item_id="widget", quantity=1.0, price_limit=20.0, market_id="goods_market", target_agent_id=target_snob)
+    buy_miser = Order(agent_id=102, side="BUY", item_id="widget", quantity=1.0, price_limit=20.0, market_id="goods_market", target_agent_id=target_miser)
     
     market.place_order(buy_snob, 1)
     market.place_order(buy_miser, 1)
diff --git a/scripts/verify_stock_market.py b/scripts/verify_stock_market.py
index 7e301a9..33daee9 100644
--- a/scripts/verify_stock_market.py
+++ b/scripts/verify_stock_market.py
@@ -175,7 +175,7 @@ def run_verification():
         # Force a household to sell at a lower price to ensure match
         sell_qty = buy_order.quantity
         sim.stock_market.place_order(
-            Order(sim.households[0].id, "SELL", f"stock_{firm.id}", sell_qty, buy_order.price * 0.9, "stock"),
+            Order(agent_id=sim.households[0].id, side="SELL", item_id=f"stock_{firm.id}", quantity=sell_qty, price_limit=buy_order.price * 0.9, market_id="stock"),
             15
         )
         
diff --git a/simulation/decisions/ai_driven_firm_engine.py b/simulation/decisions/ai_driven_firm_engine.py
index 3a8d25f..6b54080 100644
--- a/simulation/decisions/ai_driven_firm_engine.py
+++ b/simulation/decisions/ai_driven_firm_engine.py
@@ -2,6 +2,7 @@ from __future__ import annotations
 from typing import TYPE_CHECKING, List, Dict, Any, Optional, Tuple
 import logging
 import random
+from dataclasses import replace
 
 from simulation.models import Order
 from simulation.ai.enums import Tactic, Aggressiveness
@@ -83,11 +84,14 @@ class AIDrivenFirmDecisionEngine(BaseDecisionEngine):
             return base_cost / prod_factor
 
         # A. Cost-Plus Fallback
-        for order in orders:
+        for i, order in enumerate(orders):
             if not hasattr(order, 'item_id'):
                 continue
 
-            if order.order_type in ["SELL", "SET_PRICE"]:
+            # Check using aliased property or field? Use field for safety.
+            side = getattr(order, 'side', None) or getattr(order, 'order_type', None)
+
+            if side in ["SELL", "SET_PRICE"]:
                 # Check signal reliability
                 is_unreliable = True
                 if market_snapshot and 'market_signals' in market_snapshot:
@@ -107,12 +111,16 @@ class AIDrivenFirmDecisionEngine(BaseDecisionEngine):
                     if not isinstance(margin, (int, float)): margin = 0.2
                     new_price = unit_cost * (1 + margin)
 
-                    if abs(order.price - new_price) > 0.01:
+                    # Use price_limit (new field) or price (legacy alias)
+                    current_price = getattr(order, 'price_limit', order.price)
+
+                    if abs(current_price - new_price) > 0.01:
                          self.logger.info(
-                             f"COST_PLUS_FALLBACK | Firm {firm_state.id} repricing {order.item_id} from {order.price:.2f} to {new_price:.2f} (Cost: {unit_cost:.2f})",
+                             f"COST_PLUS_FALLBACK | Firm {firm_state.id} repricing {order.item_id} from {current_price:.2f} to {new_price:.2f} (Cost: {unit_cost:.2f})",
                              extra={"tick": context.current_time, "tags": ["pricing", "cost_plus"]}
                          )
-                         order.price = new_price
+                         # Replace immutable order with updated price
+                         orders[i] = replace(order, price_limit=new_price)
 
         # B. Fire-Sale Logic
         fire_sale_orders = []
@@ -164,10 +172,10 @@ class AIDrivenFirmDecisionEngine(BaseDecisionEngine):
 
                          fire_sale_orders.append(Order(
                              agent_id=firm_state.id,
-                             order_type="SELL",
+                             side="SELL",
                              item_id=item_id,
                              quantity=surplus,
-                             price=fire_sale_price,
+                             price_limit=fire_sale_price,
                              market_id=item_id
                          ))
 
diff --git a/simulation/decisions/firm/finance_manager.py b/simulation/decisions/firm/finance_manager.py
index 37e41a2..ea6f01f 100644
--- a/simulation/decisions/firm/finance_manager.py
+++ b/simulation/decisions/firm/finance_manager.py
@@ -42,13 +42,13 @@ class FinanceManager:
         is_distressed = (z_score < z_score_threshold) or (firm.consecutive_loss_turns >= loss_limit)
 
         if is_distressed:
-            return Order(firm.id, "SET_DIVIDEND", "internal", 0.0, 0.0, "internal")
+            return Order(agent_id=firm.id, side="SET_DIVIDEND", item_id="internal", quantity=0.0, price_limit=0.0, market_id="internal")
 
         base_rate = config.dividend_rate_min
         max_rate = config.dividend_rate_max
         new_rate = base_rate + (aggressiveness * (max_rate - base_rate))
 
-        return Order(firm.id, "SET_DIVIDEND", "internal", new_rate, 0.0, "internal")
+        return Order(agent_id=firm.id, side="SET_DIVIDEND", item_id="internal", quantity=new_rate, price_limit=0.0, market_id="internal")
 
     def _manage_debt(self, firm: FirmStateDTO, aggressiveness: float, context: DecisionContext) -> List[Order]:
         """
@@ -104,8 +104,15 @@ class FinanceManager:
                 spread = context.config.default_loan_spread
                 wtp_rate = base_rate + spread
 
-                order = Order(firm.id, "LOAN_REQUEST", "loan", borrow_amount, wtp_rate, "loan")
-                order.metadata = {"borrower_profile": borrower_profile}
+                order = Order(
+                    agent_id=firm.id,
+                    side="LOAN_REQUEST",
+                    item_id="loan",
+                    quantity=borrow_amount,
+                    price_limit=wtp_rate,
+                    market_id="loan",
+                    metadata={"borrower_profile": borrower_profile}
+                )
                 orders.append(order)
 
         elif current_leverage > target_leverage:
@@ -114,7 +121,7 @@ class FinanceManager:
 
             if repay_amount > 10.0 and current_debt > 0:
                  orders.append(
-                    Order(firm.id, "REPAYMENT", "loan", repay_amount, 1.0, "loan")
+                    Order(agent_id=firm.id, side="REPAYMENT", item_id="loan", quantity=repay_amount, price_limit=1.0, market_id="loan")
                 )
 
         return orders
diff --git a/simulation/decisions/firm/hr_manager.py b/simulation/decisions/firm/hr_manager.py
index d2ce5b7..8b532ad 100644
--- a/simulation/decisions/firm/hr_manager.py
+++ b/simulation/decisions/firm/hr_manager.py
@@ -69,12 +69,12 @@ class HRManager:
 
                     # Generate FIRE order
                     orders.append(Order(
-                        firm.id,
-                        "FIRE",
-                        "internal",
-                        1,
-                        severance_pay,
-                        "internal",
+                        agent_id=firm.id,
+                        side="FIRE",
+                        item_id="internal",
+                        quantity=1,
+                        price_limit=severance_pay,
+                        market_id="internal",
                         target_agent_id=emp_id
                     ))
 
@@ -96,7 +96,7 @@ class HRManager:
         if to_hire > 0:
             for _ in range(to_hire):
                  orders.append(
-                     Order(firm.id, "BUY", "labor", 1, offer_wage, "labor")
+                     Order(agent_id=firm.id, side="BUY", item_id="labor", quantity=1, price_limit=offer_wage, market_id="labor")
                  )
 
         return orders
diff --git a/simulation/decisions/firm/operations_manager.py b/simulation/decisions/firm/operations_manager.py
index ca1b1e5..536b222 100644
--- a/simulation/decisions/firm/operations_manager.py
+++ b/simulation/decisions/firm/operations_manager.py
@@ -79,7 +79,7 @@ class OperationsManager:
                      last_price = mat_info.get("initial_price", 10.0)
 
                 bid_price = last_price * 1.05
-                orders.append(Order(firm.id, "BUY", mat, deficit, bid_price, mat))
+                orders.append(Order(agent_id=firm.id, side="BUY", item_id=mat, quantity=deficit, price_limit=bid_price, market_id=mat))
 
         return orders
 
@@ -108,14 +108,14 @@ class OperationsManager:
             return orders
 
         # Generate Internal Order
-        orders.append(Order(firm.id, "INVEST_AUTOMATION", "internal", actual_spend, 0.0, "internal"))
+        orders.append(Order(agent_id=firm.id, side="INVEST_AUTOMATION", item_id="internal", quantity=actual_spend, price_limit=0.0, market_id="internal"))
 
         # WO-044-Track-B: Automation Tax
         automation_tax_rate = config.automation_tax_rate
         tax_amount = actual_spend * automation_tax_rate
 
         if tax_amount > 0:
-            orders.append(Order(firm.id, "PAY_TAX", "automation_tax", tax_amount, 0.0, "internal"))
+            orders.append(Order(agent_id=firm.id, side="PAY_TAX", item_id="automation_tax", quantity=tax_amount, price_limit=0.0, market_id="internal"))
 
         return orders
 
@@ -139,7 +139,7 @@ class OperationsManager:
         if budget < 10.0:
             return None
 
-        return Order(firm.id, "INVEST_RD", "internal", budget, 0.0, "internal")
+        return Order(agent_id=firm.id, side="INVEST_RD", item_id="internal", quantity=budget, price_limit=0.0, market_id="internal")
 
     def _manage_capex(self, firm: FirmStateDTO, aggressiveness: float, current_time: int, config: FirmConfigDTO) -> Optional[Order]:
         """
@@ -156,7 +156,7 @@ class OperationsManager:
         if budget < 100.0:
             return None
 
-        return Order(firm.id, "INVEST_CAPEX", "internal", budget, 0.0, "internal")
+        return Order(agent_id=firm.id, side="INVEST_CAPEX", item_id="internal", quantity=budget, price_limit=0.0, market_id="internal")
 
     def _manage_production_target(self, firm: FirmStateDTO, config: FirmConfigDTO) -> Optional[Order]:
         """
@@ -181,6 +181,6 @@ class OperationsManager:
             new_target = min(max_target, new_target)
 
         if new_target != target:
-            return Order(firm.id, "SET_TARGET", "internal", new_target, 0.0, "internal")
+            return Order(agent_id=firm.id, side="SET_TARGET", item_id="internal", quantity=new_target, price_limit=0.0, market_id="internal")
 
         return None
diff --git a/simulation/decisions/firm/sales_manager.py b/simulation/decisions/firm/sales_manager.py
index 729cc94..c893331 100644
--- a/simulation/decisions/firm/sales_manager.py
+++ b/simulation/decisions/firm/sales_manager.py
@@ -53,7 +53,7 @@ class SalesManager:
         target_price = max(target_price, 0.1)
 
         # 1. Internal Order to update price state
-        orders.append(Order(firm.id, "SET_PRICE", item_id, target_price, 0.0, "internal"))
+        orders.append(Order(agent_id=firm.id, side="SET_PRICE", item_id=item_id, quantity=0.0, price_limit=target_price, market_id="internal"))
 
         # 2. Market Order to sell
         qty = min(current_inventory, config.max_sell_quantity)
@@ -61,10 +61,10 @@ class SalesManager:
         # We generate a direct SELL order here.
         orders.append(Order(
              agent_id=firm.id,
-             order_type="SELL",
+             side="SELL",
              item_id=item_id,
              quantity=qty,
-             price=target_price,
+             price_limit=target_price,
              market_id=item_id # Assumes market_id == item_id
         ))
 
diff --git a/simulation/initialization/initializer.py b/simulation/initialization/initializer.py
index f119d72..751aa90 100644
--- a/simulation/initialization/initializer.py
+++ b/simulation/initialization/initializer.py
@@ -302,10 +302,10 @@ class SimulationInitializer(SimulationInitializerInterface):
                 sell_order = Order(
                     agent_id=sim.government.id,
                     item_id=f"unit_{unit.id}",
-                    price=unit.estimated_value,
+                    price_limit=unit.estimated_value,
                     quantity=1.0,
                     market_id="housing",
-                    order_type="SELL"
+                    side="SELL"
                 )
                 if "housing" in sim.markets:
                     sim.markets["housing"].place_order(sell_order, sim.time)
diff --git a/simulation/markets/order_book_market.py b/simulation/markets/order_book_market.py
index af8605c..bac6568 100644
--- a/simulation/markets/order_book_market.py
+++ b/simulation/markets/order_book_market.py
@@ -2,12 +2,42 @@ from typing import List, Dict, Any, Optional, override, Tuple
 import logging
 from collections import deque
 import math
+from dataclasses import dataclass
 
 from simulation.models import Order, Transaction
 from simulation.core_markets import Market
 
 logger = logging.getLogger(__name__)
 
+@dataclass
+class MarketOrder:
+    """Internal mutable representation of an order in the order book."""
+    agent_id: int | str
+    side: str
+    item_id: str
+    quantity: float
+    price: float
+    original_id: str
+    target_agent_id: Optional[int] = None
+    brand_info: Optional[Dict[str, Any]] = None
+
+    @classmethod
+    def from_dto(cls, dto: Order) -> 'MarketOrder':
+        return cls(
+            agent_id=dto.agent_id,
+            side=dto.side,
+            item_id=dto.item_id,
+            quantity=dto.quantity,
+            price=dto.price_limit,
+            original_id=dto.id,
+            target_agent_id=dto.target_agent_id,
+            brand_info=dto.brand_info
+        )
+
+    @property
+    def order_type(self) -> str:
+        return self.side
+
 
 class OrderBookMarket(Market):
     """호가창(Order Book) 기반의 시장을 시뮬레이션하는 클래스.
@@ -26,8 +56,8 @@ class OrderBookMarket(Market):
         super().__init__(market_id=market_id, logger=logger) # Call parent constructor to set self.id and logger
         self.id = market_id
         self.config_module = config_module
-        self.buy_orders: Dict[str, List[Order]] = {}
-        self.sell_orders: Dict[str, List[Order]] = {}
+        self.buy_orders: Dict[str, List[MarketOrder]] = {}
+        self.sell_orders: Dict[str, List[MarketOrder]] = {}
         self.daily_avg_price: Dict[str, float] = {}
         self.daily_total_volume: Dict[str, float] = {}
         self.last_traded_prices: Dict[str, float] = {}
@@ -110,43 +140,46 @@ class OrderBookMarket(Market):
             extra={"market_id": self.id, "tags": ["market_clear"]},
         )
 
-    def place_order(self, order: Order, current_time: int):
+    def place_order(self, order_dto: Order, current_time: int):
         """시장에 주문을 제출합니다. 매칭은 별도의 메서드로 처리됩니다.
         WO-136: Checks dynamic circuit breakers before accepting.
 
         Args:
-            order (Order): 제출할 주문 객체.
+            order_dto (Order): 제출할 주문 객체 (OrderDTO).
             current_time (int): 현재 시뮬레이션 틱 (시간) 입니다.
         """
         # WO-136: Circuit Breaker Check
-        min_price, max_price = self.get_dynamic_price_bounds(order.item_id)
-        if order.price < min_price or order.price > max_price:
+        min_price, max_price = self.get_dynamic_price_bounds(order_dto.item_id)
+        if order_dto.price_limit < min_price or order_dto.price_limit > max_price:
             # Check if bounds are active (max_price < inf)
             if max_price < float('inf'):
                 self.logger.warning(
-                    f"CIRCUIT_BREAKER | Order rejected. Price {order.price:.2f} out of bounds [{min_price:.2f}, {max_price:.2f}]",
+                    f"CIRCUIT_BREAKER | Order rejected. Price {order_dto.price_limit:.2f} out of bounds [{min_price:.2f}, {max_price:.2f}]",
                     extra={
                         "tick": current_time,
                         "market_id": self.id,
-                        "agent_id": order.agent_id,
-                        "item_id": order.item_id,
-                        "price": order.price,
+                        "agent_id": order_dto.agent_id,
+                        "item_id": order_dto.item_id,
+                        "price": order_dto.price_limit,
                         "bounds": (min_price, max_price)
                     }
                 )
                 return # Reject order
 
+        # Convert to mutable MarketOrder
+        order = MarketOrder.from_dto(order_dto)
+
         log_extra = {
             "tick": current_time,
             "market_id": self.id,
             "agent_id": order.agent_id,
             "item_id": order.item_id,
-            "order_type": order.order_type,
+            "side": order.side,
             "price": order.price,
             "quantity": order.quantity,
         }
         self.logger.debug(
-            f"Placing order: {order.order_type} {order.quantity} of {order.item_id} at {order.price} by {order.agent_id}",
+            f"Placing order: {order.side} {order.quantity} of {order.item_id} at {order.price} by {order.agent_id}",
             extra=log_extra,
         )
         self._add_order(order, log_extra)
@@ -188,15 +221,15 @@ class OrderBookMarket(Market):
 
         return all_transactions
 
-    def _add_order(self, order: Order, log_extra: Dict[str, Any]):
-        # Determine which order book to use based on order type
-        if order.order_type == "BUY":
+    def _add_order(self, order: MarketOrder, log_extra: Dict[str, Any]):
+        # Determine which order book to use based on side
+        if order.side == "BUY":
             target_order_book = self.buy_orders
-        elif order.order_type == "SELL":
+        elif order.side == "SELL":
             target_order_book = self.sell_orders
         else:
             self.logger.warning(
-                f"Unknown order type for _add_order: {order.order_type}",
+                f"Unknown side for _add_order: {order.side}",
                 extra=log_extra,
             )
             return
@@ -205,7 +238,7 @@ class OrderBookMarket(Market):
             target_order_book[order.item_id] = []
         target_order_book[order.item_id].append(order)
         # Sort orders: BUY by price (desc), SELL by price (asc)
-        if order.order_type == "BUY":
+        if order.side == "BUY":
             target_order_book[order.item_id].sort(key=lambda o: o.price, reverse=True)
         else:
             target_order_book[order.item_id].sort(key=lambda o: o.price)
@@ -240,12 +273,8 @@ class OrderBookMarket(Market):
                 general_buys.append(order)
         
         # 2. Process Targeted Buys
-        # Targeted buys ignore price sorting? No, usually handled FIFO or by price within target.
-        # But here we just iterate list. Detailed sorting within target isn't critical for V1.
-        
-        # Create a map of Sell orders for fast lookup by AgentID
-        # Dictionary of AgentID -> List[Order]
-        sell_map: Dict[int, List[Order]] = {}
+        # Dictionary of AgentID -> List[MarketOrder]
+        sell_map: Dict[int, List[MarketOrder]] = {}
         for s_order in sell_orders_list:
              if s_order.agent_id not in sell_map:
                  sell_map[s_order.agent_id] = []
@@ -296,19 +325,15 @@ class OrderBookMarket(Market):
                          
                  else:
                      # Price mismatch (Buyer willing to pay X, Seller wants Y, X < Y)
-                     # Transaction fails. Buyer waits or enters general pool?
-                     # Spec says "Strict Targeting -> Fails".
                      pass
              else:
                  # Target sold out or not present
                  pass
              
              if b_order.quantity > 0.001:
-                 # Failed to fill completely
                  remaining_targeted_buys.append(b_order)
 
         # Fallback: Add remaining targeted buys to general pool
-        # This fixes "Starvation by Brand Loyalty" where buyers wouldn't buy from others if target failed.
         if remaining_targeted_buys:
             general_buys.extend(remaining_targeted_buys)
             # Re-sort general buys by price desc to maintain priority
@@ -375,10 +400,6 @@ class OrderBookMarket(Market):
                  break
         
         # Re-save lists to cleanup empty orders
-        # (Actually the main lists hold references, but we need to ensure self.buy_orders refers to the updated state)
-        # Simplification: Just keep non-empty orders in the main list.
-        # We need to combine remaining_targeted and remaining_general
-        
         new_buy_list = [o for o in (remaining_targeted_buys + general_buys) if o.quantity > 0.001]
         new_buy_list.sort(key=lambda o: o.price, reverse=True) # Maintain sorted invariant
         
@@ -438,11 +459,11 @@ class OrderBookMarket(Market):
             ],
         }
 
-    def get_all_bids(self, item_id: str) -> List[Order]:
+    def get_all_bids(self, item_id: str) -> List[MarketOrder]:
         """주어진 아이템의 모든 매수 주문을 반환합니다."""
         return self.buy_orders.get(item_id, [])
 
-    def get_all_asks(self, item_id: str) -> List[Order]:
+    def get_all_asks(self, item_id: str) -> List[MarketOrder]:
         """주어진 아이템의 모든 매도 주문을 반환합니다."""
         return self.sell_orders.get(item_id, [])
 
diff --git a/simulation/models.py b/simulation/models.py
index 631571c..757e60a 100644
--- a/simulation/models.py
+++ b/simulation/models.py
@@ -1,23 +1,10 @@
 from dataclasses import dataclass, field
 from typing import Optional, Dict, Any, List
 import uuid
+from modules.market.api import OrderDTO
 
-
-@dataclass
-class Order:
-    """시장에 제출되는 개별 주문을 나타내는 데이터 클래스"""
-
-    agent_id: int | str
-    order_type: str
-    item_id: str
-    quantity: float
-    price: float
-    market_id: str
-    target_agent_id: Optional[int] = None  # Phase 6: Targeted Orders (Brand Loyalty)
-    brand_info: Optional[Dict[str, Any]] = None # Phase 6: Brand Metadata (awareness, quality)
-    metadata: Optional[Dict[str, Any]] = None # WO-078: Metadata for side-effects (e.g. BorrowerProfile)
-    id: str = field(default_factory=lambda: str(uuid.uuid4()), init=False)
-
+# Alias for backward compatibility and migration
+Order = OrderDTO
 
 @dataclass
 class Transaction:
diff --git a/tests/integration/scenarios/diagnosis/test_agent_decision.py b/tests/integration/scenarios/diagnosis/test_agent_decision.py
index 16d1c90..2d24551 100644
--- a/tests/integration/scenarios/diagnosis/test_agent_decision.py
+++ b/tests/integration/scenarios/diagnosis/test_agent_decision.py
@@ -11,10 +11,10 @@ def test_household_makes_decision(simple_household):
     # Mock the decision engine to return a specific action
     expected_order = Order(
         agent_id=simple_household.id,
-        order_type="BUY",
+        side="BUY",
         item_id="basic_food",
         quantity=1.0,
-        price=10.0,
+        price_limit=10.0,
         market_id="basic_food"
     )
     # make_decisions returns (orders, tactic)
@@ -30,19 +30,19 @@ def test_household_makes_decision(simple_household):
 
     # Assert
     assert len(orders) == 1
-    assert orders[0].order_type == "BUY"
+    assert orders[0].side == "BUY"
     assert orders[0].item_id == "basic_food"
-    assert orders[0].price == 10.0
+    assert orders[0].price_limit == 10.0
 
 def test_firm_makes_decision(simple_firm):
     """Spec 0: 에이전트가 주문을 생성하는지 검증 (Firm)"""
     # Arrange
     expected_order = Order(
         agent_id=simple_firm.id,
-        order_type="SELL",
+        side="SELL",
         item_id="basic_food",
         quantity=5.0,
-        price=12.0,
+        price_limit=12.0,
         market_id="basic_food"
     )
     # make_decisions returns (orders, tactic)
@@ -60,5 +60,5 @@ def test_firm_makes_decision(simple_firm):
 
     # Assert
     assert len(orders) == 1
-    assert orders[0].order_type == "SELL"
+    assert orders[0].side == "SELL"
     assert orders[0].item_id == "basic_food"
diff --git a/tests/integration/scenarios/diagnosis/test_market_mechanics.py b/tests/integration/scenarios/diagnosis/test_market_mechanics.py
index 6a2694e..d643ac8 100644
--- a/tests/integration/scenarios/diagnosis/test_market_mechanics.py
+++ b/tests/integration/scenarios/diagnosis/test_market_mechanics.py
@@ -11,17 +11,17 @@ def test_order_book_matching(simple_market):
     buy_order = Order(
         agent_id=1,
         item_id="basic_food",
-        price=10.0,
+        price_limit=10.0,
         quantity=1.0,
-        order_type="BUY",
+        side="BUY",
         market_id="basic_food"
     )
     sell_order = Order(
         agent_id=101,
         item_id="basic_food",
-        price=9.0, # Sell for less than buy -> Match expected
+        price_limit=9.0, # Sell for less than buy -> Match expected
         quantity=1.0,
-        order_type="SELL",
+        side="SELL",
         market_id="basic_food"
     )
 
diff --git a/tests/integration/scenarios/verify_real_estate_sales.py b/tests/integration/scenarios/verify_real_estate_sales.py
index a27a40a..fd607fe 100644
--- a/tests/integration/scenarios/verify_real_estate_sales.py
+++ b/tests/integration/scenarios/verify_real_estate_sales.py
@@ -145,9 +145,9 @@ class TestRealEstateSales(unittest.TestCase):
         # Since we initialized Engine with mock config, it creates a government agent.
         gov_id = engine.government.id
 
-        buy_order = Order(agent_id=engine.households[0].id, item_id="unit_0", price=10000.0, quantity=1, order_type="BUY", market_id="housing")
+        buy_order = Order(agent_id=engine.households[0].id, item_id="unit_0", price_limit=10000.0, quantity=1, side="BUY", market_id="housing")
         # Use valid government ID for Sell Order
-        sell_order = Order(agent_id=gov_id, item_id="unit_0", price=10000.0, quantity=1, order_type="SELL", market_id="housing")
+        sell_order = Order(agent_id=gov_id, item_id="unit_0", price_limit=10000.0, quantity=1, side="SELL", market_id="housing")
         
         # Inject orders directly for matching simulation
         engine.markets["housing"].place_order(buy_order, 0)
diff --git a/tests/integration/test_decision_engine_integration.py b/tests/integration/test_decision_engine_integration.py
index bcd279d..d879879 100644
--- a/tests/integration/test_decision_engine_integration.py
+++ b/tests/integration/test_decision_engine_integration.py
@@ -155,10 +155,10 @@ class TestDecisionEngineIntegration:
             [
                 Order(
                     agent_id=firm.id,
-                    order_type="SELL",
+                    side="SELL",
                     item_id="food",
                     quantity=10.0,
-                    price=15.0,
+                    price_limit=15.0,
                     market_id="goods_market",
                 )
             ],
@@ -190,10 +190,10 @@ class TestDecisionEngineIntegration:
             [
                 Order(
                     agent_id=household.id,
-                    order_type="BUY",
+                    side="BUY",
                     item_id="food",
                     quantity=1.0,
-                    price=1.6,
+                    price_limit=1.6,
                     market_id="goods_market",
                 )
             ],
@@ -228,10 +228,10 @@ class TestDecisionEngineIntegration:
             [
                 Order(
                     agent_id=household.id,
-                    order_type="SELL",
+                    side="SELL",
                     item_id="labor",
                     quantity=1,
-                    price=10,
+                    price_limit=10,
                     market_id="labor_market",
                 )
             ],
@@ -262,10 +262,10 @@ class TestDecisionEngineIntegration:
             [
                 Order(
                     agent_id=firm.id,
-                    order_type="BUY",
+                    side="BUY",
                     item_id="labor",
                     quantity=1,
-                    price=10,
+                    price_limit=10,
                     market_id="labor_market",
                 )
             ],
@@ -291,10 +291,10 @@ class TestDecisionEngineIntegration:
         """가계와 기업의 주문이 상품 시장에서 올바르게 매칭되는지 통합 테스트합니다."""
         firm_sell_order = Order(
             agent_id=firm.id,
-            order_type="SELL",
+            side="SELL",
             item_id="food",
             quantity=5.0,
-            price=10.0,
+            price_limit=10.0,
             market_id="goods_market",
         )
         goods_market.place_order(firm_sell_order, current_time=1)
@@ -305,10 +305,10 @@ class TestDecisionEngineIntegration:
 
         household_buy_order = Order(
             agent_id=household.id,
-            order_type="BUY",
+            side="BUY",
             item_id="food",
             quantity=5.0,
-            price=10.0,
+            price_limit=10.0,
             market_id="goods_market",
         )
         goods_market.place_order(household_buy_order, current_time=1)
@@ -334,10 +334,10 @@ class TestDecisionEngineIntegration:
         household.needs["survival_need"] = 10.0
         household_sell_order = Order(
             agent_id=household.id,
-            order_type="SELL",
+            side="SELL",
             item_id="labor",
             quantity=1,
-            price=10,
+            price_limit=10,
             market_id="labor_market",
         )
         labor_market.place_order(household_sell_order, current_time=1)
@@ -346,10 +346,10 @@ class TestDecisionEngineIntegration:
         firm.employees = []
         firm_buy_order = Order(
             agent_id=firm.id,
-            order_type="BUY",
+            side="BUY",
             item_id="labor",
             quantity=1,
-            price=10,
+            price_limit=10,
             market_id="labor_market",
         )
         labor_market.place_order(firm_buy_order, current_time=1)
