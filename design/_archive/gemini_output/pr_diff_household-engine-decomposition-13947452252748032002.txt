diff --git a/communications/insights/HH_Engine_Refactor_Insights.md b/communications/insights/HH_Engine_Refactor_Insights.md
new file mode 100644
index 00000000..36efe83e
--- /dev/null
+++ b/communications/insights/HH_Engine_Refactor_Insights.md
@@ -0,0 +1,20 @@
+# Insights and Technical Debt - Household Engine Refactor
+
+## Insights
+1.  **Orchestrator-Engine Pattern**: Decomposing `Household` into stateless engines (`Lifecycle`, `Needs`, `Budget`, `Consumption`) significantly improved modularity. The `Household` class is now a pure orchestrator, managing state DTOs and delegating logic.
+2.  **Factory Pattern**: Introducing `HouseholdFactory` centralized the creation logic, which was previously scattered across `DemographicManager` and `Household.clone`. This allows for better encapsulation of initialization rules and dependency injection.
+3.  **Zero-Sum Integrity**: By ensuring `HouseholdFactory.create_newborn` initializes agents with 0.0 assets and relying on `DemographicManager` (and `SettlementSystem`) to transfer the initial gift, we enforce strict zero-sum financial integrity. No money is created "out of thin air" during birth.
+4.  **Order Generation**: Moving the responsibility of generating orders for basic needs (like food) from `ConsumptionEngine` to `BudgetEngine` (as part of the `BudgetPlan`) clarifies the roles. `BudgetEngine` plans (allocates and decides what to buy), and `ConsumptionEngine` executes (places orders and consumes).
+
+## Technical Debt / Future Work
+1.  **Housing Logic in BudgetEngine**: The `BudgetEngine` implementation includes `_plan_housing` which delegates to `HousingPlanner`. However, the integration with `HousingSystem` via `Household` orchestrator is still somewhat coupled. Future refactoring could further decouple this by having `HousingSystem` act on the `HousingActionDTO` directly without `Household` mediation if possible, or standardizing the interface.
+2.  **Mocking Challenges**: Tests mocking `EconStateDTO` faced issues with `spec=` not automatically mocking interface-typed fields like `wallet`. We had to explicitly assign mocks. A robust `MockFactory` that handles this automatically for all DTOs would be beneficial.
+3.  **Configuration DTO Mismatch**: `HouseholdConfigDTO` lacked `initial_needs` which was required by `AgentCoreConfigDTO`. We worked around this by accessing the raw config module. Ideally, `HouseholdConfigDTO` should be the single source of truth for all household-related config, or `AgentCoreConfigDTO` should be decoupled from specific agent config classes.
+4.  **Legacy `clone` Method**: `Household.clone` is deprecated but still exists for legacy test compatibility. It should be removed once all tests are migrated to use `HouseholdFactory`.
+
+## Guardrail Compliance
+-   **Zero-Sum Integrity**: Verified. New agents start with 0 assets.
+-   **Engine Purity**: Verified. Engines are stateless classes/functions.
+-   **Orchestrator Pattern**: Verified. `Household` delegates to engines.
+-   **Protocol over Class**: Verified. Engines implement Protocols.
+-   **DTO Purity**: Verified. Input/Output DTOs used.
diff --git a/modules/household/engines/budget.py b/modules/household/engines/budget.py
index 49d20b97..8502eaae 100644
--- a/modules/household/engines/budget.py
+++ b/modules/household/engines/budget.py
@@ -7,6 +7,7 @@ from modules.household.dtos import EconStateDTO, HouseholdSnapshotDTO
 from modules.market.housing_planner import HousingPlanner
 from modules.housing.dtos import HousingDecisionRequestDTO
 from modules.system.api import DEFAULT_CURRENCY
+from simulation.models import Order
 
 logger = logging.getLogger(__name__)
 
@@ -124,45 +125,67 @@ class BudgetEngine(IBudgetEngine):
         needs: List[PrioritizedNeed],
         abstract_plan: List[Any],
         market_snapshot: Any,
-        config: Any = None # Optional for backward compatibility in internal calls, but should be passed
+        config: Any = None
     ) -> BudgetPlan:
         # Simple Budgeting:
         # 1. Total Wealth = Cash
         total_cash = state.wallet.get_balance(DEFAULT_CURRENCY)
-
         allocations = {}
         spent = 0.0
+        final_orders: List[Order] = []
 
         # 2. Allocate for Needs (Survival first)
         for need in needs:
             # Estimate cost.
-            # E.g. Survival -> Food.
             if need.need_id == "survival":
                 # Estimate food cost.
                 food_price = config.default_food_price_estimate if config else DEFAULT_FOOD_PRICE_ESTIMATE
                 goods_market = getattr(market_snapshot, "goods", {})
 
                 # Check different keys for food
-                m = goods_market.get("basic_food") or goods_market.get("food")
+                target_item = "basic_food"
+                m = goods_market.get("basic_food")
+                if not m:
+                     m = goods_market.get("food")
+                     target_item = "food" if m else "basic_food"
+
                 if m:
                     # MarketSnapshotDTO uses GoodsMarketUnitDTO which has avg_price
                     food_price = getattr(m, "avg_price", food_price) or getattr(m, "current_price", food_price)
 
                 # Quantity: Place enough for buffer?
-                # Placeholder: Allocate fixed amount
+                # Placeholder: Allocate fixed amount based on config
                 amount_to_allocate = config.survival_budget_allocation if config else DEFAULT_SURVIVAL_BUDGET
+                allocated_cash = 0.0
+
                 if total_cash - spent >= amount_to_allocate:
-                    allocations["food"] = amount_to_allocate
-                    spent += amount_to_allocate
+                    allocated_cash = amount_to_allocate
                 else:
-                    allocations["food"] = max(0.0, total_cash - spent)
-                    spent = total_cash
-
-            # Other needs...
+                    allocated_cash = max(0.0, total_cash - spent)
+
+                allocations["food"] = allocated_cash
+                spent += allocated_cash
+
+                # Create Order for Food
+                if allocated_cash > 0 and food_price > 0:
+                    qty = allocated_cash / food_price
+                    # Use wallet.owner_id if available, assuming standard Wallet implementation
+                    agent_id = getattr(state.wallet, "owner_id", None)
+                    if agent_id:
+                        order = Order(
+                            agent_id=agent_id,
+                            side="BUY",
+                            item_id=target_item,
+                            quantity=qty,
+                            price_limit=food_price * 1.1, # 10% buffer
+                            market_id="goods_market"
+                        )
+                        final_orders.append(order)
+
+            # Other needs can be added here...
 
         # 3. Allocate for Abstract Plan (AI Orders)
         # If AI says "Buy Stock", allocate.
-        approved_orders = []
         for order in abstract_plan:
             if order.side == "BUY":
                 cost = order.quantity * order.price_limit
@@ -170,12 +193,12 @@ class BudgetEngine(IBudgetEngine):
                     item_type = "investment" if "stock" in order.item_id else "goods"
                     allocations[item_type] = allocations.get(item_type, 0.0) + cost
                     spent += cost
-                    approved_orders.append(order)
+                    final_orders.append(order)
             elif order.side == "SELL":
-                approved_orders.append(order)
+                final_orders.append(order)
 
         return BudgetPlan(
             allocations=allocations,
             discretionary_spending=max(0.0, total_cash - spent),
-            orders=approved_orders
+            orders=final_orders
         )
diff --git a/modules/household/engines/consumption.py b/modules/household/engines/consumption.py
index 699d55d3..b93ef827 100644
--- a/modules/household/engines/consumption.py
+++ b/modules/household/engines/consumption.py
@@ -69,34 +69,10 @@ class ConsumptionEngine(IConsumptionEngine):
             new_bio_state.needs["survival"] = max(0.0, survival_need - utility)
             # Log consumption?
 
-        # 3. Order Generation based on Budget Plan and Needs
-
-        # Add orders from Budget Plan (AI Orders)
+        # 3. Order Generation based on Budget Plan
+        # Orders are now generated by BudgetEngine (including food/needs)
         orders.extend(budget_plan.orders)
 
-        # Add Need-based Orders if inventory was insufficient AND budget allocated funds
-        food_alloc = budget_plan.allocations.get("food", 0.0)
-
-        if survival_need > 0 and food_inventory < 1.0 and food_alloc > 0:
-            # Buy food
-            food_price = DEFAULT_FOOD_PRICE
-            goods_market = getattr(market_snapshot, "goods", {})
-            m = goods_market.get("basic_food") or goods_market.get("food")
-            if m:
-                 food_price = getattr(m, "avg_price", DEFAULT_FOOD_PRICE) or getattr(m, "current_price", DEFAULT_FOOD_PRICE)
-
-            qty_to_buy = food_alloc / food_price
-            if qty_to_buy > 0:
-                order = Order(
-                    agent_id=new_econ_state.portfolio.owner_id,
-                    side="BUY",
-                    item_id="basic_food",
-                    quantity=qty_to_buy,
-                    price_limit=food_price * PRICE_LIMIT_MULTIPLIER,
-                    market_id="goods_market"
-                )
-                orders.append(order)
-
         # 4. Targeted Order Refinement (DecisionUnit logic)
         if stress_scenario_config and stress_scenario_config.is_active and stress_scenario_config.scenario_name == 'phase29_depression':
              multiplier = stress_scenario_config.demand_shock_multiplier
diff --git a/simulation/core_agents.py b/simulation/core_agents.py
index a0e93a88..5b2a599b 100644
--- a/simulation/core_agents.py
+++ b/simulation/core_agents.py
@@ -6,6 +6,7 @@ from collections import deque, defaultdict
 import random
 import copy
 import math
+import warnings
 
 from simulation.decisions.base_decision_engine import BaseDecisionEngine
 from simulation.models import Order, Skill, Talent
@@ -873,7 +874,11 @@ class Household(
         """
         Creates a clone (child) of this household.
         Used by LifecycleManager/DemographicManager.
+
+        @deprecated: Use HouseholdFactory.create_newborn instead.
         """
+        warnings.warn("Household.clone() is deprecated. Use HouseholdFactory.create_newborn() instead.", DeprecationWarning, stacklevel=2)
+
         # 1. Get Offspring Demographics from Lifecycle Engine
         offspring_demo = self.lifecycle_engine.create_offspring_demographics(
             self._bio_state, new_id, current_tick
diff --git a/simulation/factories/__init__.py b/simulation/factories/__init__.py
new file mode 100644
index 00000000..e69de29b
diff --git a/simulation/factories/agent_factory.py b/simulation/factories/agent_factory.py
new file mode 100644
index 00000000..61cf36cf
--- /dev/null
+++ b/simulation/factories/agent_factory.py
@@ -0,0 +1,218 @@
+from __future__ import annotations
+from typing import Optional, Dict, Any, List, TYPE_CHECKING
+import logging
+import random
+import copy
+
+from simulation.core_agents import Household
+from simulation.models import Talent
+from simulation.utils.config_factory import create_config_dto
+from simulation.dtos.config_dtos import HouseholdConfigDTO
+from modules.simulation.api import AgentCoreConfigDTO, AgentStateDTO
+from modules.system.api import DEFAULT_CURRENCY
+from simulation.ai.enums import Personality
+
+if TYPE_CHECKING:
+    from simulation.dtos.api import SimulationState
+    from simulation.systems.demographic_manager import DemographicManager
+
+logger = logging.getLogger(__name__)
+
+class HouseholdFactory:
+    """
+    Factory for creating Household agents.
+    Encapsulates creation logic, configuration setup, and initial state hydration.
+    """
+
+    def __init__(self, config_module: Any):
+        self.config_module = config_module
+
+    def create_household(
+        self,
+        agent_id: int,
+        simulation: Any,
+        initial_age: float,
+        gender: str,
+        initial_assets: float = 0.0,
+        generation: int = 0,
+        parent_id: Optional[int] = None,
+        spouse_id: Optional[int] = None,
+        personality: Optional[Personality] = None,
+        talent: Optional[Talent] = None,
+        decision_engine: Optional[Any] = None,
+        initial_needs: Optional[Dict[str, float]] = None
+    ) -> Household:
+        """
+        Creates a fully initialized Household agent.
+        """
+
+        # 1. Config Setup
+        hh_config_dto = create_config_dto(self.config_module, HouseholdConfigDTO)
+
+        # 2. Core Config
+        # Value Orientation: Try getting from engine, else config default
+        vo = "Growth"
+        if decision_engine and hasattr(decision_engine, 'value_orientation'):
+            vo = decision_engine.value_orientation
+        else:
+            vo = getattr(self.config_module, 'DEFAULT_VALUE_ORIENTATION', 'Growth')
+
+        # Get initial needs from config if not provided
+        default_initial_needs = getattr(self.config_module, "INITIAL_NEEDS", {})
+
+        core_config = AgentCoreConfigDTO(
+            id=agent_id,
+            name=f"Household_{agent_id}",
+            value_orientation=vo,
+            initial_needs=initial_needs if initial_needs else default_initial_needs.copy(),
+            logger=simulation.logger,
+            memory_interface=None
+        )
+
+        # 3. Defaults if not provided
+        if talent is None:
+            talent = Talent(base_learning_rate=1.0, max_potential={})
+
+        if personality is None:
+            personality = random.choice(list(Personality))
+
+        # 4. Instantiate Household
+        agent = Household(
+            core_config=core_config,
+            engine=decision_engine,
+            talent=talent,
+            goods_data=simulation.goods_data,
+            personality=personality,
+            config_dto=hh_config_dto,
+            loan_market=simulation.markets.get("loan_market"),
+            risk_aversion=1.0,
+            initial_age=initial_age,
+            gender=gender,
+            parent_id=parent_id,
+            generation=generation,
+            initial_assets_record=initial_assets
+        )
+
+        # 5. Hydrate State (Assets)
+        initial_state = AgentStateDTO(
+            assets={DEFAULT_CURRENCY: initial_assets},
+            inventory={},
+            is_active=True
+        )
+        agent.load_state(initial_state)
+
+        # 6. Additional Initializations
+        if spouse_id:
+            agent.spouse_id = spouse_id
+
+        agent.education_level = 0
+        base_wage = getattr(self.config_module, "INITIAL_WAGE", 10.0)
+        agent.expected_wage = base_wage
+
+        return agent
+
+    def create_newborn(
+        self,
+        parent: Household,
+        simulation: Any,
+        new_id: int
+    ) -> Household:
+        """
+        Creates a newborn household (child) from a parent.
+        Handles inheritance of traits (personality, talent, brain).
+        """
+        # 1. Demographics
+        initial_age = 0.0
+        gender = random.choice(["M", "F"])
+        generation = parent.generation + 1
+
+        # 2. Inheritance Logic (Talent, Personality)
+        child_talent = self._inherit_talent(parent.talent)
+        child_personality = self._inherit_personality(parent.personality)
+
+        # 3. Engine Creation (Brain)
+        new_decision_engine = self._create_decision_engine_for_newborn(parent, simulation, new_id)
+
+        # 4. Initial Assets (Zero - Gift transfer happens externally via SettlementSystem)
+        initial_assets = 0.0
+
+        # 5. Config
+        initial_needs = getattr(self.config_module, "NEWBORN_INITIAL_NEEDS", None)
+
+        # 6. Create Agent
+        child = self.create_household(
+            agent_id=new_id,
+            simulation=simulation,
+            initial_age=initial_age,
+            gender=gender,
+            initial_assets=initial_assets,
+            generation=generation,
+            parent_id=parent.id,
+            spouse_id=None,
+            personality=child_personality,
+            talent=child_talent,
+            decision_engine=new_decision_engine,
+            initial_needs=initial_needs
+        )
+
+        # 7. Brain Inheritance (Weights)
+        if hasattr(simulation, "ai_training_manager") and simulation.ai_training_manager:
+            simulation.ai_training_manager.inherit_brain(parent, child)
+        else:
+            # logger might not be configured if strictly imported, but factory uses simulation.logger usually
+            # But here we use 'logger' defined in module
+            logger.warning("AITrainingManager not found for brain inheritance.")
+
+        return child
+
+    def _inherit_talent(self, parent_talent: Talent) -> Talent:
+        """Inherit talent with mutation."""
+        new_talent = copy.deepcopy(parent_talent)
+        mutation_range = 0.1
+        new_talent.base_learning_rate *= random.uniform(1.0 - mutation_range, 1.0 + mutation_range)
+        return new_talent
+
+    def _inherit_personality(self, parent_personality: Personality) -> Personality:
+        """Inherit personality with potential mutation."""
+        if random.random() < getattr(self.config_module, "MITOSIS_MUTATION_PROBABILITY", 0.1):
+            return random.choice(list(Personality))
+        return parent_personality
+
+    def _create_decision_engine_for_newborn(self, parent: Household, simulation: Any, agent_id: int) -> Any:
+        """Creates the decision engine for the newborn."""
+
+        newborn_engine_type = getattr(self.config_module, "NEWBORN_ENGINE_TYPE", "AIDriven")
+        # Check strategy override
+        strategy = getattr(simulation, "strategy", None)
+        if strategy and hasattr(strategy, "newborn_engine_type") and strategy.newborn_engine_type:
+            newborn_engine_type = strategy.newborn_engine_type
+
+        if str(newborn_engine_type).upper() == "RULE_BASED":
+            from simulation.decisions.rule_based_household_engine import RuleBasedHouseholdDecisionEngine
+            return RuleBasedHouseholdDecisionEngine(
+                config_module=self.config_module,
+                logger=simulation.logger
+            )
+        else:
+            # AI Driven
+            from simulation.ai.household_ai import HouseholdAI
+            from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
+
+            ai_trainer = getattr(simulation, "ai_trainer", None)
+
+            base_ai_engine = None
+            if ai_trainer:
+                base_ai_engine = ai_trainer.get_engine(parent.value_orientation)
+
+            new_ai = HouseholdAI(
+                agent_id=str(agent_id),
+                ai_decision_engine=base_ai_engine,
+            )
+
+            engine = AIDrivenHouseholdDecisionEngine(
+                ai_engine=new_ai,
+                config_module=self.config_module,
+                logger=simulation.logger
+            )
+            engine.loan_market = simulation.markets.get("loan_market")
+            return engine
diff --git a/simulation/systems/demographic_manager.py b/simulation/systems/demographic_manager.py
index c433f1ae..af5720fc 100644
--- a/simulation/systems/demographic_manager.py
+++ b/simulation/systems/demographic_manager.py
@@ -35,6 +35,11 @@ class DemographicManager:
         self.strategy = strategy
         self.logger = logging.getLogger("simulation.systems.demographic_manager")
         self.settlement_system: Optional[Any] = None # Injected via Initializer
+
+        # Initialize Factory
+        from simulation.factories.agent_factory import HouseholdFactory
+        self.household_factory = HouseholdFactory(config_module)
+
         self.initialized = True
         self.logger.info("DemographicManager initialized.")
 
@@ -97,12 +102,7 @@ class DemographicManager:
             child_id = simulation.next_agent_id
             simulation.next_agent_id += 1
 
-            # Asset Transfer (e.g. 10% of parent assets as startup gift?)
-            # Or just cost of birth (hospital fee)?
-            # Phase 19 Spec doesn't specify asset transfer amount,
-            # but usually children start with 0 or small amount.
-            # Let's assume standard INITIAL_ASSETS or small portion from parent.
-            # "Initial 자산은 부모 자산의 일부 이전"
+            # Asset Transfer calculation
             parent_assets = 0.0
             if hasattr(parent, 'wallet'):
                 parent_assets = parent.wallet.get_balance(DEFAULT_CURRENCY)
@@ -114,125 +114,9 @@ class DemographicManager:
             # TD-233: Round to 2 decimals to prevent floating point leaks
             initial_gift = round(max(0.0, min(parent_assets * 0.1, parent_assets)), 2)
 
-            # WO-124: Removed direct asset modification. Transfer happens via SettlementSystem after creation.
-
             try:
-                # Create Instance
-                # We need to clone parent's structure but reset state
-                # Assuming Household.__init__ takes similar args.
-                # We need to access simulation.goods_data etc.
-                # Ideally Simulation passes factory or we use parent's references.
-
-                # 1. Talent Inheritance & Mutation
-                # Safely access parent talent or use default
-                if isinstance(parent, ITalented):
-                    child_talent = self._inherit_talent(parent.talent)
-                else:
-                    from simulation.models import Talent
-                    child_talent = Talent(base_learning_rate=1.0, max_potential={})
-
-                # 2. Brain (HouseholdAI) - Inherit weights/policy
-                # This requires creating a new decision engine.
-                # We can use parent.clone() logic but customized.
-
-                # Create Decision Engine (similar to parent's type)
-                # We need simulation.ai_trainer to get engine
-                # Accessing simulation.ai_trainer...
-                ai_trainer = simulation.ai_trainer
-
-                # Value Orientation Inheritance (with mutation?)
-                value_orientation = parent.value_orientation # Strict inheritance for now
-
-                # Get base engine
-                base_ai_engine = ai_trainer.get_engine(value_orientation)
-
-                # Create HouseholdAI wrapper
-                from simulation.ai.household_ai import HouseholdAI
-                from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
-
-                # Inherit Personality (with mutation)
-                child_personality = self._inherit_personality(parent.personality)
-
-                new_ai = HouseholdAI(
-                    agent_id=str(child_id),
-                    ai_decision_engine=base_ai_engine,
-                    # Inherit parameters maybe?
-                )
-
-                # Create Decision Engine
-                # WO-110: Allow selecting engine type for newborns (AIDriven vs RuleBased)
-                # WO-136: Use Strategy DTO if available
-                newborn_engine_type = getattr(self.config_module, "NEWBORN_ENGINE_TYPE", "AIDriven")
-                if self.strategy and self.strategy.newborn_engine_type:
-                    newborn_engine_type = self.strategy.newborn_engine_type
-
-                if str(newborn_engine_type).upper() == "RULE_BASED":
-                    from simulation.decisions.rule_based_household_engine import RuleBasedHouseholdDecisionEngine
-                    new_decision_engine = RuleBasedHouseholdDecisionEngine(
-                        config_module=self.config_module,
-                        logger=simulation.logger
-                    )
-                else:
-                    new_decision_engine = AIDrivenHouseholdDecisionEngine(
-                        ai_engine=new_ai,
-                        config_module=self.config_module,
-                        logger=simulation.logger
-                    )
-                    new_decision_engine.loan_market = simulation.markets.get("loan_market")
-
-                # Load initial needs from config
-                initial_needs_for_newborn = getattr(self.config_module, "NEWBORN_INITIAL_NEEDS", {})
-                if not initial_needs_for_newborn:
-                    self.logger.warning("NEWBORN_INITIAL_NEEDS not found in config. Newborns may be inactive.")
-
-                hh_config_dto = create_config_dto(self.config_module, HouseholdConfigDTO)
-
-                core_config = AgentCoreConfigDTO(
-                    id=child_id,
-                    name=f"Household_{child_id}",
-                    value_orientation=value_orientation,
-                    initial_needs=initial_needs_for_newborn.copy(),
-                    logger=simulation.logger,
-                    memory_interface=None
-                )
-
-                # WO-124: Instantiate with 0 assets. Gift is transferred via SettlementSystem.
-                child = Household(
-                    core_config=core_config,
-                    engine=new_decision_engine,
-                    talent=child_talent,
-                    goods_data=simulation.goods_data,
-                    personality=child_personality,
-                    config_dto=hh_config_dto,
-                    loan_market=simulation.markets.get("loan_market"),
-                    risk_aversion=parent.risk_aversion, # Inherit risk aversion
-                    initial_age=0.0, # Explicitly set age 0 for newborn
-                )
-
-                # Hydrate State
-                initial_state = AgentStateDTO(
-                    assets={DEFAULT_CURRENCY: 0.0},
-                    inventory={},
-                    is_active=True
-                )
-                child.load_state(initial_state)
-
-                # Initialize Phase 19 Attributes
-                child.initialize_demographics(
-                    age=0.0,
-                    gender=child.gender, # Kept from init
-                    parent_id=parent.id,
-                    generation=parent.generation + 1
-                )
-                child.education_level = 0 # Start at 0
-                child.expected_wage = self._calculate_expected_wage(child.education_level)
-
-                # Brain Weight Inheritance
-                if hasattr(simulation, "ai_training_manager"):
-                    simulation.ai_training_manager.inherit_brain(parent, child)
-                else:
-                    # Fallback if manager not found (e.g. mocked simulation)
-                    self.logger.warning("AITrainingManager not found for brain inheritance.")
+                # Use Factory for creation
+                child = self.household_factory.create_newborn(parent, simulation, child_id)
 
                 # Register linkage and finalize
                 parent.children_ids.append(child_id)
@@ -263,40 +147,6 @@ class DemographicManager:
 
         return new_children
 
-    def _inherit_talent(self, parent_talent: Any) -> Any:
-        """
-        Inherit talent with mutation.
-        """
-        # Assuming Talent class has base_learning_rate etc.
-        # Deep copy
-        from simulation.core_agents import Talent
-        import copy
-
-        new_talent = copy.deepcopy(parent_talent)
-
-        # Mutation
-        mutation_range = 0.1
-        new_talent.base_learning_rate *= random.uniform(1.0 - mutation_range, 1.0 + mutation_range)
-
-        return new_talent
-
-    def _inherit_personality(self, parent_personality: Any) -> Any:
-        """
-        Inherit personality with potential mutation.
-        """
-        # Mutation Probability
-        if random.random() < getattr(self.config_module, "MITOSIS_MUTATION_PROBABILITY", 0.1):
-            from simulation.ai.enums import Personality
-            available = list(Personality)
-            return random.choice(available)
-        return parent_personality
-
-    def _calculate_expected_wage(self, education_level: int) -> float:
-        base_wage = getattr(self.config_module, "INITIAL_WAGE", 10.0)
-        multipliers = getattr(self.config_module, "EDUCATION_COST_MULTIPLIERS", {})
-        mult = multipliers.get(education_level, 1.0)
-        return base_wage * mult
-
     def handle_inheritance(self, deceased_agent: Household, simulation: Any):
         """
         [DEPRECATED] This method is deprecated and should not be used.
diff --git a/tests/modules/household/engines/test_budget.py b/tests/modules/household/engines/test_budget.py
new file mode 100644
index 00000000..ef4f97ea
--- /dev/null
+++ b/tests/modules/household/engines/test_budget.py
@@ -0,0 +1,68 @@
+import pytest
+from unittest.mock import MagicMock, Mock
+from modules.household.engines.budget import BudgetEngine
+from modules.household.api import BudgetInputDTO, PrioritizedNeed
+from modules.household.dtos import EconStateDTO
+from simulation.dtos.config_dtos import HouseholdConfigDTO
+from modules.system.api import DEFAULT_CURRENCY
+from simulation.models import Order
+
+@pytest.fixture
+def budget_engine():
+    return BudgetEngine()
+
+@pytest.fixture
+def mock_config():
+    config = MagicMock(spec=HouseholdConfigDTO)
+    config.default_food_price_estimate = 10.0
+    config.survival_budget_allocation = 50.0
+    config.household_min_wage_demand = 10.0
+    return config
+
+@pytest.fixture
+def econ_state():
+    wallet = MagicMock()
+    wallet.get_balance.return_value = 100.0
+    wallet.owner_id = 1
+
+    state = MagicMock(spec=EconStateDTO)
+    state.wallet = wallet
+    state.is_employed = False
+    state.shadow_reservation_wage = 10.0
+    state.market_wage_history = []
+    state.is_homeless = True
+    state.current_wage = 0.0
+    state.residing_property_id = None
+    state.copy.return_value = state
+    return state
+
+def test_allocate_budget_creates_orders_for_needs(budget_engine, econ_state, mock_config):
+    prioritized_needs = [
+        PrioritizedNeed(need_id="survival", urgency=1.0, deficit=50.0)
+    ]
+    abstract_plan = []
+    market_snapshot = MagicMock()
+    # Mock goods market
+    market_snapshot.goods = {"basic_food": MagicMock(avg_price=10.0)}
+    market_snapshot.labor.avg_wage = 15.0
+
+    input_dto = BudgetInputDTO(
+        econ_state=econ_state,
+        prioritized_needs=prioritized_needs,
+        abstract_plan=abstract_plan,
+        market_snapshot=market_snapshot,
+        config=mock_config,
+        current_tick=1
+    )
+
+    output = budget_engine.allocate_budget(input_dto)
+
+    assert "food" in output.budget_plan.allocations
+    assert output.budget_plan.allocations["food"] == 50.0
+
+    # Verify Order creation
+    assert len(output.budget_plan.orders) == 1
+    order = output.budget_plan.orders[0]
+    assert order.item_id == "basic_food"
+    assert order.side == "BUY"
+    assert order.quantity == 5.0 # 50.0 / 10.0
diff --git a/tests/modules/household/engines/test_consumption.py b/tests/modules/household/engines/test_consumption.py
new file mode 100644
index 00000000..12f41330
--- /dev/null
+++ b/tests/modules/household/engines/test_consumption.py
@@ -0,0 +1,53 @@
+import pytest
+from unittest.mock import MagicMock
+from modules.household.engines.consumption import ConsumptionEngine
+from modules.household.api import ConsumptionInputDTO, BudgetPlan
+from modules.household.dtos import EconStateDTO, BioStateDTO
+from simulation.models import Order
+from simulation.dtos.config_dtos import HouseholdConfigDTO
+
+@pytest.fixture
+def consumption_engine():
+    return ConsumptionEngine()
+
+@pytest.fixture
+def input_dto():
+    econ_state = MagicMock(spec=EconStateDTO)
+    econ_state.wallet = MagicMock()
+    econ_state.inventory = {"basic_food": 0.0}
+    econ_state.wallet.get_balance.return_value = 100.0
+    econ_state.copy.return_value = econ_state
+    econ_state.durable_assets = []
+
+    bio_state = MagicMock(spec=BioStateDTO)
+    bio_state.needs = {"survival": 50.0}
+    bio_state.copy.return_value = bio_state
+
+    # Budget Plan WITH orders (from BudgetEngine)
+    order = Order(agent_id=1, side="BUY", item_id="basic_food", quantity=5.0, price_limit=11.0, market_id="goods_market")
+    budget_plan = BudgetPlan(
+        allocations={"food": 50.0},
+        discretionary_spending=50.0,
+        orders=[order]
+    )
+
+    config = MagicMock(spec=HouseholdConfigDTO)
+    config.panic_selling_asset_threshold = 0.0
+
+    return ConsumptionInputDTO(
+        econ_state=econ_state,
+        bio_state=bio_state,
+        budget_plan=budget_plan,
+        market_snapshot=MagicMock(),
+        config=config,
+        current_tick=1,
+        stress_scenario_config=None
+    )
+
+def test_generate_orders_uses_budget_orders(consumption_engine, input_dto):
+    output = consumption_engine.generate_orders(input_dto)
+
+    # Should contain the order from budget plan
+    assert len(output.orders) == 1
+    assert output.orders[0].item_id == "basic_food"
+    assert output.orders[0].quantity == 5.0
diff --git a/tests/simulation/factories/test_agent_factory.py b/tests/simulation/factories/test_agent_factory.py
new file mode 100644
index 00000000..8bd60125
--- /dev/null
+++ b/tests/simulation/factories/test_agent_factory.py
@@ -0,0 +1,76 @@
+import pytest
+from unittest.mock import MagicMock
+from simulation.factories.agent_factory import HouseholdFactory
+from simulation.core_agents import Household
+from simulation.models import Talent
+from simulation.ai.enums import Personality
+from simulation.dtos.config_dtos import HouseholdConfigDTO
+
+@pytest.fixture
+def mock_config_module():
+    config = MagicMock()
+    config.INITIAL_HOUSEHOLD_AGE_RANGE = (20, 40)
+    config.INITIAL_NEEDS = {"survival": 0.0}
+    config.TICKS_PER_YEAR = 100
+    config.PRICE_MEMORY_LENGTH = 10
+    config.WAGE_MEMORY_LENGTH = 10
+    config.INITIAL_APTITUDE_DISTRIBUTION = (0.5, 0.1)
+    config.CONFORMITY_RANGES = {}
+    config.VALUE_ORIENTATION_MAPPING = {}
+    config.INITIAL_HOUSEHOLD_ASSETS_MEAN = 100.0
+    config.NEWBORN_INITIAL_NEEDS = {"survival": 0.0}
+    config.MITOSIS_MUTATION_PROBABILITY = 0.0
+    config.INITIAL_WAGE = 10.0
+    config.DEFAULT_VALUE_ORIENTATION = "Growth"
+    return config
+
+def test_create_household(mock_config_module):
+    factory = HouseholdFactory(mock_config_module)
+    simulation = MagicMock()
+    simulation.goods_data = []
+    simulation.logger = MagicMock()
+
+    mock_engine = MagicMock()
+    mock_engine.value_orientation = "Growth"
+
+    agent = factory.create_household(
+        agent_id=1,
+        simulation=simulation,
+        initial_age=25.0,
+        gender="M",
+        initial_assets=100.0,
+        decision_engine=mock_engine
+    )
+
+    assert isinstance(agent, Household)
+    assert agent.id == 1
+    assert agent.age == 25.0
+    assert agent.gender == "M"
+    assert agent.assets == 100.0
+
+def test_create_newborn(mock_config_module):
+    factory = HouseholdFactory(mock_config_module)
+    simulation = MagicMock()
+    simulation.goods_data = []
+    simulation.logger = MagicMock()
+    simulation.ai_trainer.get_engine.return_value = None
+    simulation.markets.get.return_value = None
+
+    parent = MagicMock(spec=Household)
+    parent.id = 1
+    parent.generation = 1
+    parent.talent = Talent(base_learning_rate=1.0, max_potential={})
+    parent.personality = Personality.CONSERVATIVE
+    parent.value_orientation = "Growth"
+
+    child = factory.create_newborn(
+        parent=parent,
+        simulation=simulation,
+        new_id=2
+    )
+
+    assert isinstance(child, Household)
+    assert child.id == 2
+    assert child.age == 0.0
+    assert child.generation == 2
+    assert child.parent_id == 1
