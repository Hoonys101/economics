diff --git a/communications/insights/TD-198.md b/communications/insights/TD-198.md
new file mode 100644
index 0000000..24f5a9e
--- /dev/null
+++ b/communications/insights/TD-198.md
@@ -0,0 +1,25 @@
+# [TD-198] MortgageApplicationDTO Unification
+
+## Context
+There were two conflicting definitions of `MortgageApplicationDTO`:
+1. `modules/market/housing_planner_api.py` (Canonical)
+2. `modules/market/housing_purchase_api.py` (Duplicate, with different keys)
+
+This caused confusion and required compatibility layers in `LoanMarket`.
+
+## Resolution
+- Removed the duplicate definition from `modules/market/housing_purchase_api.py` and `modules/housing/dtos.py`.
+- Unified all usages to import from `modules/market/housing_planner_api.py`.
+- Updated `LoanMarket`, `SettlementSystem`, and consumers to use the canonical keys:
+    - `principal` (vs `loan_principal`)
+    - `property_value` (vs `offer_price`)
+    - `applicant_income` (vs `applicant_gross_income`)
+    - `applicant_existing_debt` (Total debt balance)
+
+## Technical Debt / Insights
+- **Precision Loss**: The canonical DTO uses `applicant_existing_debt` (Total Balance) and does not have a field for `applicant_existing_debt_payments` (Monthly). The `LoanMarket` now estimates monthly payments based on total debt if the Bank service cannot provide exact figures. This is acceptable for now but might be a limitation if third-party debt (non-bank) with specific payment schedules needs to be modeled.
+- **Legacy Compatibility**: `LoanMarket` had extensive fallback logic which was removed. This cleans up the code but requires all callers to strict adhere to the canonical DTO.
+- **Saga Data**: `HousingPurchaseSagaDataDTO` now embeds the canonical `MortgageApplicationDTO`. This ensures the Saga carries the exact data structure used by the planner and the bank.
+
+## Action Items
+- Verify if `applicant_existing_debt` needs to be split into `total_debt` and `monthly_debt_service` in the future if accurate DTI calculations for external debt are required.
diff --git a/modules/housing/dtos.py b/modules/housing/dtos.py
index 34a1da8..b6e92a1 100644
--- a/modules/housing/dtos.py
+++ b/modules/housing/dtos.py
@@ -4,23 +4,10 @@ from dataclasses import dataclass
 
 from modules.household.dtos import HouseholdStateDTO
 from modules.system.api import HousingMarketSnapshotDTO
+from modules.market.housing_planner_api import MortgageApplicationDTO
 
 # --- Mortgage & Saga DTOs ---
 
-class MortgageApplicationDTO(TypedDict):
-    """
-    Formal loan application sent to the LoanMarket.
-    Generated by the Saga Handler, not the Household.
-    """
-    applicant_id: int
-    # The amount of the loan requested
-    principal: float
-    property_id: int
-    # Total price of the property, for LTV calculation
-    property_value: float
-    # Term in ticks/months for DTI calculation
-    loan_term: int
-
 class MortgageApprovalDTO(TypedDict):
     """
     Response from the LoanMarket upon successful loan approval.
diff --git a/modules/market/housing_purchase_api.py b/modules/market/housing_purchase_api.py
index 24d6f68..4a24748 100644
--- a/modules/market/housing_purchase_api.py
+++ b/modules/market/housing_purchase_api.py
@@ -3,23 +3,11 @@ from abc import ABC, abstractmethod
 from modules.household.dtos import HouseholdStateDTO
 from modules.system.api import HousingMarketSnapshotDTO
 from modules.finance.api import LoanInfoDTO as LoanDTO
+from modules.market.housing_planner_api import MortgageApplicationDTO
 
 # Pre-existing DTOs (Aliases if needed, or imported elsewhere)
 # from modules.market.housing_planner_api import HousingOfferRequestDTO, HousingDecisionDTO
 
-class MortgageApplicationDTO(TypedDict):
-    """
-    Formal mortgage application sent to the LoanMarket.
-    Contains all data required for LTV/DTI checks.
-    """
-    applicant_id: int
-    property_id: int
-    offer_price: float
-    loan_principal: float
-    applicant_gross_income: float
-    applicant_existing_debt_payments: float
-    loan_term: int
-
 class HousingPurchaseSagaDataDTO(TypedDict):
     """
     The data payload for the housing purchase saga.
diff --git a/scripts/verify_housing_transaction_integrity.py b/scripts/verify_housing_transaction_integrity.py
index cd66ac3..716754b 100644
--- a/scripts/verify_housing_transaction_integrity.py
+++ b/scripts/verify_housing_transaction_integrity.py
@@ -8,7 +8,8 @@ from uuid import uuid4
 sys.path.append(os.getcwd())
 
 from simulation.systems.settlement_system import SettlementSystem
-from modules.market.housing_purchase_api import HousingPurchaseSagaDTO, HousingPurchaseSagaDataDTO, MortgageApplicationDTO
+from modules.market.housing_purchase_api import HousingPurchaseSagaDTO, HousingPurchaseSagaDataDTO
+from modules.market.housing_planner_api import MortgageApplicationDTO
 from simulation.models import Transaction
 
 class TestAtomicHousingPurchaseV3(unittest.TestCase):
@@ -67,11 +68,12 @@ class TestAtomicHousingPurchaseV3(unittest.TestCase):
         saga_id = str(uuid4())
         mortgage_app = MortgageApplicationDTO(
             applicant_id=101,
+            principal=80000.0,
+            purpose="MORTGAGE",
             property_id=500,
-            offer_price=100000.0,
-            loan_principal=80000.0,
-            applicant_gross_income=60000.0,
-            applicant_existing_debt_payments=0.0,
+            property_value=100000.0,
+            applicant_income=60000.0,
+            applicant_existing_debt=0.0,
             loan_term=360
         )
         saga_data = HousingPurchaseSagaDataDTO(
@@ -145,11 +147,12 @@ class TestAtomicHousingPurchaseV3(unittest.TestCase):
         saga_id = str(uuid4())
         mortgage_app = MortgageApplicationDTO(
             applicant_id=101,
+            principal=80000.0,
+            purpose="MORTGAGE",
             property_id=500,
-            offer_price=100000.0,
-            loan_principal=80000.0,
-            applicant_gross_income=10000.0, # Low income
-            applicant_existing_debt_payments=0.0,
+            property_value=100000.0,
+            applicant_income=10000.0, # Low income
+            applicant_existing_debt=0.0,
             loan_term=360
         )
         saga_data = HousingPurchaseSagaDataDTO(
diff --git a/simulation/loan_market.py b/simulation/loan_market.py
index ae18d90..f08b197 100644
--- a/simulation/loan_market.py
+++ b/simulation/loan_market.py
@@ -6,8 +6,7 @@ from simulation.core_markets import Market
 from modules.finance.api import IBankService, LoanNotFoundError, LoanRepaymentError, BorrowerProfileDTO
 from modules.housing.dtos import MortgageApprovalDTO
 # Import from new API
-# from modules.market.housing_planner_api import ILoanMarket, MortgageApplicationDTO
-from modules.market.housing_purchase_api import ILoanMarket, MortgageApplicationDTO
+from modules.market.housing_planner_api import ILoanMarket, MortgageApplicationDTO
 from modules.finance.api import LoanInfoDTO as LoanDTO
 
 if TYPE_CHECKING:
@@ -46,28 +45,15 @@ class LoanMarket(Market, ILoanMarket):
         Performs hard LTV/DTI checks. Returns True if approved, False if rejected.
         Implements ILoanMarket.evaluate_mortgage_application.
         """
-        # Compatibility with different DTO versions/definitions
-        # housing_purchase_api.MortgageApplicationDTO uses: offer_price, loan_principal
-        # housing_planner_api.MortgageApplicationDTO uses: property_value, principal
-
-        if 'loan_principal' in application:
-            principal = application['loan_principal']
-            prop_value = application.get('offer_price', 0.0) # Or property_id resolution?
-            # Actually offer_price is likely property value for LTV purposes
-            # But wait, property_value might be different. DTO has 'offer_price'.
-            # If property_value is not in DTO, we use offer_price.
-            if prop_value == 0 and 'property_id' in application:
-                 # Should we look up? No, evaluation should be self-contained ideally.
-                 pass
-        else:
-            principal = application.get('principal', 0.0)
-            prop_value = application.get('property_value', 0.0)
+        # Canonical Keys from housing_planner_api:
+        # principal, property_value, applicant_income, applicant_existing_debt
+
+        principal = application.get('principal', 0.0)
+        prop_value = application.get('property_value', 0.0)
 
         if prop_value <= 0:
-             # Fallback if property_value missing but offer_price exists (alias)
-             prop_value = application.get('offer_price', 0.0)
-             if prop_value <= 0:
-                 return False
+             logger.warning(f"LOAN_DENIED | Invalid property value {prop_value}")
+             return False
 
         # 1. LTV Check
         ltv = principal / prop_value
@@ -103,11 +89,8 @@ class LoanMarket(Market, ILoanMarket):
         # 2. DTI Check
         applicant_id = application['applicant_id']
 
-        # Support new DTO keys
-        annual_income = application.get('applicant_gross_income', application.get('applicant_income', 0.0))
-        existing_debt_payments = application.get('applicant_existing_debt_payments', 0.0)
+        annual_income = application.get('applicant_income', 0.0)
         existing_debt_total = application.get('applicant_existing_debt', 0.0)
-
         loan_term = application.get('loan_term', 360)
 
         # Get Interest Rate
@@ -125,26 +108,23 @@ class LoanMarket(Market, ILoanMarket):
              new_payment = principal * (monthly_rate * (1 + monthly_rate)**loan_term) / ((1 + monthly_rate)**loan_term - 1)
 
         # Estimate Existing Debt Payment
-        if existing_debt_payments > 0:
-             existing_payment = existing_debt_payments
-        else:
-             # Fallback: estimate from total debt if payments not provided
-             # Use existing Bank query to get accurate debt payments if possible
-             existing_payment = 0.0
-             try:
-                  debt_status = self.bank.get_debt_status(str(applicant_id))
-                  for l in debt_status['loans']:
-                      r = l['interest_rate'] / 12.0
-                      if r == 0:
-                          payment = l['outstanding_balance'] / 360
-                      else:
-                          payment = l['outstanding_balance'] * r
-                      existing_payment += payment
-             except Exception:
-                  if monthly_rate == 0:
-                       existing_payment = existing_debt_total / 360
+        # Use existing Bank query to get accurate debt payments if possible
+        existing_payment = 0.0
+        try:
+              debt_status = self.bank.get_debt_status(str(applicant_id))
+              for l in debt_status['loans']:
+                  r = l['interest_rate'] / 12.0
+                  if r == 0:
+                      payment = l['outstanding_balance'] / 360 # Default term assumption? Or use remaining term?
                   else:
-                       existing_payment = existing_debt_total * monthly_rate
+                      payment = l['outstanding_balance'] * r # Simplified
+                  existing_payment += payment
+        except Exception:
+              # Fallback: estimate from total debt reported in application
+              if monthly_rate == 0:
+                   existing_payment = existing_debt_total / 360
+              else:
+                   existing_payment = existing_debt_total * monthly_rate
 
         total_monthly_obligation = existing_payment + new_payment
         monthly_income = annual_income / 12.0
@@ -165,7 +145,6 @@ class LoanMarket(Market, ILoanMarket):
         Processes a mortgage application with regulatory checks.
         Returns LoanInfoDTO if approved, None otherwise.
         """
-        # Refactored to use stage_mortgage which now returns LoanDTO (dict)
         return self.stage_mortgage(application)
 
     def stage_mortgage(self, application: MortgageApplicationDTO) -> Optional[LoanDTO]:
@@ -184,14 +163,7 @@ class LoanMarket(Market, ILoanMarket):
         else:
              interest_rate = getattr(self.config_module, 'DEFAULT_MORTGAGE_INTEREST_RATE', 0.05)
 
-        due_tick = None
-        # Ideally calculate based on loan_term if current tick known, but Bank handles defaults.
-
-        # Support DTO key variation
-        if 'loan_principal' in application:
-            principal = application['loan_principal']
-        else:
-            principal = application.get('principal', 0.0)
+        principal = application.get('principal', 0.0)
 
         loan_info = self.bank.stage_loan(
             borrower_id=str(application['applicant_id']),
diff --git a/simulation/systems/settlement_system.py b/simulation/systems/settlement_system.py
index 810a3dc..b35c9f7 100644
--- a/simulation/systems/settlement_system.py
+++ b/simulation/systems/settlement_system.py
@@ -7,7 +7,8 @@ from modules.finance.api import (
     IPortfolioHandler, PortfolioDTO, PortfolioAsset, IHeirProvider
 )
 from simulation.dtos.settlement_dtos import LegacySettlementAccount
-from modules.market.housing_purchase_api import HousingPurchaseSagaDTO, MortgageApplicationDTO
+from modules.market.housing_purchase_api import HousingPurchaseSagaDTO
+from modules.market.housing_planner_api import MortgageApplicationDTO
 
 if TYPE_CHECKING:
     from simulation.firms import Firm
@@ -119,7 +120,7 @@ class SettlementSystem(ISettlementSystem):
             seller_id = data['seller_id']
             offer_price = data['offer_price']
             down_payment = data['down_payment']
-            loan_principal = data['mortgage_application']['loan_principal']
+            loan_principal = data['mortgage_application']['principal']
 
             buyer = state.agents.get(buyer_id)
             seller = state.agents.get(seller_id)
diff --git a/tests/unit/markets/test_loan_market_mortgage.py b/tests/unit/markets/test_loan_market_mortgage.py
new file mode 100644
index 0000000..1207c5d
--- /dev/null
+++ b/tests/unit/markets/test_loan_market_mortgage.py
@@ -0,0 +1,114 @@
+import pytest
+from unittest.mock import MagicMock, patch
+from typing import Any
+
+from simulation.loan_market import LoanMarket
+from simulation.bank import Bank
+from modules.market.housing_planner_api import MortgageApplicationDTO
+from modules.finance.api import LoanInfoDTO
+
+class TestLoanMarketMortgage:
+    @pytest.fixture
+    def mock_bank(self):
+        bank = MagicMock(spec=Bank)
+        # Mock get_interest_rate
+        bank.get_interest_rate.return_value = 0.05
+        # Mock debt status
+        bank.get_debt_status.return_value = {'loans': []}
+        return bank
+
+    @pytest.fixture
+    def mock_config_module(self):
+        config = MagicMock()
+        config.DEFAULT_MORTGAGE_INTEREST_RATE = 0.05
+        # Create nested regulations mock
+        config.regulations = MagicMock()
+        config.regulations.max_ltv_ratio = 0.8
+        config.regulations.max_dti_ratio = 0.43
+        return config
+
+    @pytest.fixture
+    def loan_market(self, mock_bank, mock_config_module):
+        with patch("simulation.loan_market.logger"):
+            return LoanMarket(
+                market_id="test_market",
+                bank=mock_bank,
+                config_module=mock_config_module
+            )
+
+    def test_evaluate_mortgage_success(self, loan_market):
+        app = MortgageApplicationDTO(
+            applicant_id=1,
+            principal=80000.0,
+            purpose="MORTGAGE",
+            property_id=100,
+            property_value=100000.0,
+            applicant_income=60000.0,
+            applicant_existing_debt=0.0,
+            loan_term=360
+        )
+        assert loan_market.evaluate_mortgage_application(app) is True
+
+    def test_evaluate_mortgage_fail_ltv(self, loan_market):
+        app = MortgageApplicationDTO(
+            applicant_id=1,
+            principal=90000.0, # 90% LTV
+            purpose="MORTGAGE",
+            property_id=100,
+            property_value=100000.0,
+            applicant_income=200000.0, # High income, so DTI is fine
+            applicant_existing_debt=0.0,
+            loan_term=360
+        )
+        assert loan_market.evaluate_mortgage_application(app) is False
+
+    def test_evaluate_mortgage_fail_dti(self, loan_market):
+        app = MortgageApplicationDTO(
+            applicant_id=1,
+            principal=80000.0,
+            purpose="MORTGAGE",
+            property_id=100,
+            property_value=100000.0,
+            applicant_income=10000.0, # Low income
+            applicant_existing_debt=0.0,
+            loan_term=360
+        )
+        assert loan_market.evaluate_mortgage_application(app) is False
+
+    def test_stage_mortgage_success(self, loan_market, mock_bank):
+        app = MortgageApplicationDTO(
+            applicant_id=1,
+            principal=80000.0,
+            purpose="MORTGAGE",
+            property_id=100,
+            property_value=100000.0,
+            applicant_income=60000.0,
+            applicant_existing_debt=0.0,
+            loan_term=360
+        )
+
+        mock_bank.stage_loan.return_value = {
+            "loan_id": "loan_123",
+            "original_amount": 80000.0
+        }
+
+        result = loan_market.stage_mortgage(app)
+        assert result is not None
+        assert result["loan_id"] == "loan_123"
+        mock_bank.stage_loan.assert_called_once()
+
+    def test_stage_mortgage_fail_eval(self, loan_market, mock_bank):
+        app = MortgageApplicationDTO(
+            applicant_id=1,
+            principal=90000.0, # LTV Fail
+            purpose="MORTGAGE",
+            property_id=100,
+            property_value=100000.0,
+            applicant_income=60000.0,
+            applicant_existing_debt=0.0,
+            loan_term=360
+        )
+
+        result = loan_market.stage_mortgage(app)
+        assert result is None
+        mock_bank.stage_loan.assert_not_called()
