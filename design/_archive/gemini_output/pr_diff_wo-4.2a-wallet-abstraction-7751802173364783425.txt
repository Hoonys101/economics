diff --git a/communications/insights/WO-4.2A.md b/communications/insights/WO-4.2A.md
new file mode 100644
index 0000000..17cf827
--- /dev/null
+++ b/communications/insights/WO-4.2A.md
@@ -0,0 +1,20 @@
+# WO-4.2A Wallet Abstraction Insights
+
+## Technical Debt & Observations
+
+1.  **SettlementSystem Central Bank Detection**:
+    The `SettlementSystem` identifies the Central Bank via `agent.__class__.__name__ == "CentralBank"` or `str(agent.id) == "CENTRAL_BANK"`. This loose coupling facilitates mocking (as seen in `trace_leak.py`) but relies on string magic which can be fragile.
+
+2.  **Audit Log Semantics**:
+    The `SettlementSystem.create_and_transfer` method (used for Minting) deposits funds into the recipient's wallet but does *not* withdraw from the Central Bank's wallet. This means the Global Wallet Audit Log's sum represents the **Net Money Supply** (Total Assets in circulation), rather than a strict zero-sum ledger including Central Bank liabilities.
+    *   **Implication**: `trace_leak.py` must account for "Authorized Creation" events when verifying the log. Zero-sum integrity holds true for all *transfers* between non-CB agents.
+
+3.  **Legacy Asset Properties**:
+    Agents (`Household`, `Firm`, `Government`) still expose an `assets` property returning a dictionary. This is maintained for compatibility but delegates reads to `Wallet.get_all_balances()`. While functional, this retains an API surface area that encourages dictionary-like thinking. Future refactoring should encourage using `wallet` methods directly.
+
+4.  **Static vs Runtime Verification**:
+    The previous `trace_leak.py` used static AST analysis. The new version runs a simulation scenario. This is more effective for verifying logic but requires keeping the mock agents aligned with real agent interfaces.
+
+## Verification Status
+- `trace_leak.py` passes all zero-sum integrity checks, confirming that transfers are balanced and minting/burning is accounted for.
+- `Wallet` class correctly prevents unauthorized negative balances (except for Central Bank).
diff --git a/modules/finance/api.py b/modules/finance/api.py
index 6a028fc..0962653 100644
--- a/modules/finance/api.py
+++ b/modules/finance/api.py
@@ -9,6 +9,7 @@ if TYPE_CHECKING:
     from modules.simulation.api import IGovernment, EconomicIndicatorsDTO
     from simulation.models import Order, Transaction
     from modules.common.dtos import Claim
+    from modules.finance.wallet.api import IWallet
 
 # Forward reference for type hinting
 class Firm: pass
@@ -172,6 +173,9 @@ class IFinancialEntity(Protocol):
     @property
     def id(self) -> int: ...
 
+    @property
+    def wallet(self) -> IWallet: ...
+
     @property
     def assets(self) -> float: ...
 
diff --git a/modules/finance/wallet/__init__.py b/modules/finance/wallet/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/modules/finance/wallet/api.py b/modules/finance/wallet/api.py
new file mode 100644
index 0000000..ebe67a6
--- /dev/null
+++ b/modules/finance/wallet/api.py
@@ -0,0 +1,56 @@
+from __future__ import annotations
+from typing import Dict, Protocol, runtime_checkable, List
+from abc import abstractmethod
+from dataclasses import dataclass
+from modules.system.api import CurrencyCode, DEFAULT_CURRENCY
+
+@dataclass(frozen=True)
+class WalletOpLogDTO:
+    """A record of a single atomic operation on a wallet."""
+    tick: int
+    agent_id: int
+    currency: CurrencyCode
+    delta: float
+    memo: str
+    resulting_balance: float
+
+@runtime_checkable
+class IWallet(Protocol):
+    """
+    Defines the public interface for a currency wallet.
+    It provides methods for atomic balance manipulation and observation.
+    """
+    owner_id: int
+
+    @abstractmethod
+    def get_balance(self, currency: CurrencyCode = DEFAULT_CURRENCY) -> float:
+        """Retrieves the balance for a specific currency."""
+        ...
+
+    @abstractmethod
+    def get_all_balances(self) -> Dict[CurrencyCode, float]:
+        """Returns a copy of all currency balances."""
+        ...
+
+    @abstractmethod
+    def add(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY, memo: str = "", tick: int = -1) -> None:
+        """Atomically adds an amount to a currency's balance."""
+        ...
+
+    @abstractmethod
+    def subtract(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY, memo: str = "", tick: int = -1) -> None:
+        """Atomically subtracts an amount from a currency's balance."""
+        ...
+
+    # --- Operator Overloading Signatures ---
+    @abstractmethod
+    def __add__(self, other: IWallet) -> IWallet: ...
+
+    @abstractmethod
+    def __sub__(self, other: IWallet) -> IWallet: ...
+
+    @abstractmethod
+    def __iadd__(self, other: IWallet) -> IWallet: ...
+
+    @abstractmethod
+    def __isub__(self, other: IWallet) -> IWallet: ...
diff --git a/modules/finance/wallet/audit.py b/modules/finance/wallet/audit.py
new file mode 100644
index 0000000..b44b66f
--- /dev/null
+++ b/modules/finance/wallet/audit.py
@@ -0,0 +1,5 @@
+from typing import List
+from .api import WalletOpLogDTO
+
+# Shared mutable log for global auditing
+GLOBAL_WALLET_LOG: List[WalletOpLogDTO] = []
diff --git a/modules/finance/wallet/wallet.py b/modules/finance/wallet/wallet.py
new file mode 100644
index 0000000..a02d8e7
--- /dev/null
+++ b/modules/finance/wallet/wallet.py
@@ -0,0 +1,110 @@
+from __future__ import annotations
+import copy
+from collections import defaultdict
+from typing import Dict, List, Optional
+from .api import IWallet, WalletOpLogDTO, CurrencyCode, DEFAULT_CURRENCY
+from .audit import GLOBAL_WALLET_LOG
+
+class InsufficientFundsError(Exception):
+    """Raised when a wallet operation would result in a negative balance."""
+    pass
+
+class Wallet(IWallet):
+    """
+    An encapsulated, auditable container for an agent's multi-currency assets.
+    """
+    def __init__(
+        self,
+        owner_id: int,
+        initial_balances: Optional[Dict[CurrencyCode, float]] = None,
+        audit_log: Optional[List[WalletOpLogDTO]] = None,
+        allow_negative_balance: bool = False
+    ):
+        self.owner_id = owner_id
+        if initial_balances is None:
+            initial_balances = {}
+        self._balances: Dict[CurrencyCode, float] = defaultdict(float, initial_balances)
+        self._audit_log = audit_log if audit_log is not None else GLOBAL_WALLET_LOG
+        self.allow_negative_balance = allow_negative_balance
+
+    def get_balance(self, currency: CurrencyCode = DEFAULT_CURRENCY) -> float:
+        return self._balances[currency]
+
+    def get_all_balances(self) -> Dict[CurrencyCode, float]:
+        return copy.copy(self._balances)
+
+    def add(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY, memo: str = "", tick: int = -1) -> None:
+        if amount < 0:
+            raise ValueError("Cannot add a negative amount. Use subtract.")
+        self._balances[currency] += amount
+        self._log_operation(tick, currency, amount, memo)
+
+    def subtract(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY, memo: str = "", tick: int = -1) -> None:
+        if amount < 0:
+            raise ValueError("Cannot subtract a negative amount. Use add.")
+
+        if not self.allow_negative_balance:
+            current_balance = self._balances[currency]
+            if current_balance < amount:
+                # Use a small epsilon for float comparison if needed, but keeping simple for now
+                raise InsufficientFundsError(
+                    f"Agent {self.owner_id}: Cannot subtract {amount} {currency}. "
+                    f"Balance is only {current_balance}."
+                )
+
+        self._balances[currency] -= amount
+        self._log_operation(tick, currency, -amount, memo)
+
+    def _log_operation(self, tick: int, currency: CurrencyCode, delta: float, memo: str):
+        log_entry = WalletOpLogDTO(
+            tick=tick,
+            agent_id=self.owner_id,
+            currency=currency,
+            delta=delta,
+            memo=memo,
+            resulting_balance=self._balances[currency]
+        )
+        self._audit_log.append(log_entry)
+
+    # --- Operator Overloading ---
+    def __add__(self, other: IWallet) -> IWallet:
+        # Returns a new wallet with summed balances?
+        # The design document had these signatures but didn't specify behavior.
+        # Assuming it returns a new generic wallet with combined balances.
+        # This is rarely used in core logic, mostly for reporting or temp calculations.
+        new_balances = self.get_all_balances()
+        other_balances = other.get_all_balances()
+        for curr, amt in other_balances.items():
+            new_balances[curr] = new_balances.get(curr, 0.0) + amt
+
+        return Wallet(0, new_balances) # 0 ID for temp wallet
+
+    def __sub__(self, other: IWallet) -> IWallet:
+        new_balances = self.get_all_balances()
+        other_balances = other.get_all_balances()
+        for curr, amt in other_balances.items():
+            new_balances[curr] = new_balances.get(curr, 0.0) - amt
+
+        return Wallet(0, new_balances)
+
+    def __iadd__(self, other: IWallet) -> IWallet:
+        # Merges other wallet into this one (transfer in?)
+        # BUT this bypasses atomic logging if we just iterate.
+        # Should we log? The spec is for readability.
+        # "maintain readability in agent logic".
+        # I will implement it as a series of adds.
+        other_balances = other.get_all_balances()
+        for curr, amt in other_balances.items():
+            if amt > 0:
+                self.add(amt, curr, memo="Wallet Merge")
+            elif amt < 0:
+                 # Should not happen for balances usually, but if it's a delta wallet...
+                 self.subtract(abs(amt), curr, memo="Wallet Merge")
+        return self
+
+    def __isub__(self, other: IWallet) -> IWallet:
+        other_balances = other.get_all_balances()
+        for curr, amt in other_balances.items():
+             if amt > 0:
+                 self.subtract(amt, curr, memo="Wallet Subtract")
+        return self
diff --git a/modules/household/dtos.py b/modules/household/dtos.py
index 5100e46..0614521 100644
--- a/modules/household/dtos.py
+++ b/modules/household/dtos.py
@@ -8,6 +8,7 @@ from simulation.ai.api import Personality
 from simulation.models import Share, Skill, Talent, Order
 from simulation.portfolio import Portfolio
 from modules.system.api import CurrencyCode # Added for Phase 33
+from modules.finance.wallet.api import IWallet
 
 if TYPE_CHECKING:
     from simulation.core_markets import Market
@@ -37,7 +38,8 @@ class BioStateDTO:
 class EconStateDTO:
     """Internal state for EconComponent."""
     # Assets & Inventory
-    assets: Dict[CurrencyCode, float] # Changed for Phase 33
+    wallet: IWallet # Changed for WO-4.2A Wallet Abstraction
+    # assets: Dict[CurrencyCode, float] # DEPRECATED, access via wallet
     inventory: Dict[str, float]
     inventory_quality: Dict[str, float]
     durable_assets: List[Dict[str, Any]]
@@ -89,8 +91,27 @@ class EconStateDTO:
     credit_frozen_until_tick: int = 0
     initial_assets_record: float = 0.0
 
+    @property
+    def assets(self) -> Dict[CurrencyCode, float]:
+        """Legacy compatibility accessor."""
+        return self.wallet.get_all_balances()
+
     def copy(self) -> "EconStateDTO":
         new_state = copy.copy(self)
+        # Wallet is mutable but we probably shouldn't deep copy it for simulation logic unless intent is cloning.
+        # But DTO copy is used for decision making snapshots usually?
+        # If it's for snapshot, it should be a copy.
+        # But Wallet is an object.
+        # DTO copy is shallow for attributes not explicitly handled.
+        # If we want read-only snapshot, Wallet interface might need to be careful.
+        # For now, we keep reference or new wallet?
+        # Typically copy() is used for creating new state for next tick or planning.
+        # But Wallet is the source of truth.
+        # Ideally, we pass the SAME wallet reference if it's the agent's wallet.
+        # Or if this is a snapshot, we should pass a ReadOnly wallet wrapper or just the balance.
+        # However, EconStateDTO is the internal state of EconComponent.
+        # So we keep the reference.
+
         new_state.inventory = self.inventory.copy()
         new_state.inventory_quality = self.inventory_quality.copy()
         # Deep copy durable assets as they are dicts
diff --git a/modules/household/mixins/_financials.py b/modules/household/mixins/_financials.py
index 4c3a54a..76cd529 100644
--- a/modules/household/mixins/_financials.py
+++ b/modules/household/mixins/_financials.py
@@ -22,31 +22,24 @@ class HouseholdFinancialsMixin:
     logger: Logger
     config: "HouseholdConfigDTO"
     _econ_state: "EconStateDTO"
-    _assets: Dict[CurrencyCode, float]
 
     @override
     def _internal_add_assets(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
-        if currency not in self._econ_state.assets:
-            self._econ_state.assets[currency] = 0.0
-        self._econ_state.assets[currency] += amount
-        self._assets = self._econ_state.assets
+        self._econ_state.wallet.add(amount, currency, memo="Internal Add")
 
     @override
     def _internal_sub_assets(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
-        if currency not in self._econ_state.assets:
-            self._econ_state.assets[currency] = 0.0
-        self._econ_state.assets[currency] -= amount
-        self._assets = self._econ_state.assets
+        self._econ_state.wallet.subtract(amount, currency, memo="Internal Sub")
 
     @override
-    def adjust_assets(self, delta: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
+    def adjust_assets(self, delta: float, currency: CurrencyCode = DEFAULT_CURRENCY, memo: str = "", tick: int = -1) -> None:
         """
         Adjusts assets by delta (positive or negative).
         """
-        if currency not in self._econ_state.assets:
-            self._econ_state.assets[currency] = 0.0
-        self._econ_state.assets[currency] += delta
-        self._assets = self._econ_state.assets
+        if delta > 0:
+            self._econ_state.wallet.add(delta, currency, memo, tick)
+        elif delta < 0:
+            self._econ_state.wallet.subtract(abs(delta), currency, memo, tick)
 
     def modify_inventory(self, item_id: str, quantity: float) -> None:
         if item_id not in self._econ_state.inventory:
diff --git a/simulation/agents/central_bank.py b/simulation/agents/central_bank.py
index fff0991..cbaeb8f 100644
--- a/simulation/agents/central_bank.py
+++ b/simulation/agents/central_bank.py
@@ -2,6 +2,8 @@ import logging
 from typing import Any, List, Optional, Dict, TYPE_CHECKING
 import numpy as np
 from modules.finance.api import InsufficientFundsError
+from modules.finance.wallet.wallet import Wallet
+from modules.finance.wallet.api import IWallet
 
 if TYPE_CHECKING:
     from modules.memory.api import MemoryV2Interface
@@ -23,7 +25,11 @@ class CentralBank:
         self.strategy = strategy
 
         # Balance Sheet
-        self.assets: Dict[str, Any] = {"bonds": [], "cash": 0.0}
+        self.bonds: List[Any] = []
+        self.wallet = Wallet(0, allow_negative_balance=True) # 0 ID for CB? Or hash of string? owner_id is int.
+        # self.id is "CENTRAL_BANK" (str). IWallet expects int owner_id.
+        # I'll use a fixed ID for CB, e.g. 0 or 999999 (Treasury uses 999999 in memory).
+        # Let's use 0 for CB.
 
         # Initial Rate
         self.base_rate = getattr(config_module, "INITIAL_BASE_ANNUAL_RATE", 0.05)
@@ -51,10 +57,10 @@ class CentralBank:
         Purchases government bonds, adding them to the Central Bank's balance sheet.
         This is a key part of Quantitative Easing (QE).
         """
-        self.assets["bonds"].append(bond)
+        self.bonds.append(bond)
         logger.info(
             f"CENTRAL_BANK_QE | Purchased bond {bond.id} for {bond.face_value:.2f}. "
-            f"Total bonds held: {len(self.assets['bonds'])}",
+            f"Total bonds held: {len(self.bonds)}",
             extra={"tags": ["central_bank", "qe"]}
         )
 
@@ -185,19 +191,18 @@ class CentralBank:
 
     def _internal_add_assets(self, amount: float) -> None:
         """[INTERNAL ONLY] Increase cash reserves."""
-        self.assets['cash'] = self.assets.get('cash', 0) + amount
+        self.wallet.add(amount, memo="Internal Add")
 
     def _internal_sub_assets(self, amount: float) -> None:
         """[INTERNAL ONLY] Decrease cash reserves."""
-        current_cash = self.assets.get('cash', 0)
         # Central Bank can withdraw (create money) even if it results in negative cash
         # This represents expansion of the monetary base.
-        self.assets['cash'] = current_cash - amount
+        self.wallet.subtract(amount, memo="Internal Sub")
 
     def deposit(self, amount: float) -> None:
         """Deposits a given amount into the central bank's cash reserves."""
         if amount > 0:
-            self._internal_add_assets(amount)
+            self.wallet.add(amount, memo="Deposit")
 
     def mint(self, amount: float) -> None:
         """
@@ -212,4 +217,4 @@ class CentralBank:
         As a Fiat Currency Issuer, the Central Bank can have a negative balance (creating money).
         """
         if amount > 0:
-            self._internal_sub_assets(amount)
+            self.wallet.subtract(amount, memo="Withdraw")
diff --git a/simulation/agents/government.py b/simulation/agents/government.py
index 3049c57..0032b2f 100644
--- a/simulation/agents/government.py
+++ b/simulation/agents/government.py
@@ -20,6 +20,8 @@ from modules.government.components.welfare_manager import WelfareManager
 from modules.government.components.infrastructure_manager import InfrastructureManager
 from modules.government.constants import *
 from modules.system.api import CurrencyCode, DEFAULT_CURRENCY, ICurrencyHolder # Added for Phase 33
+from modules.finance.wallet.wallet import Wallet
+from modules.finance.wallet.api import IWallet
 
 if TYPE_CHECKING:
     from simulation.finance.api import ISettlementSystem
@@ -36,11 +38,15 @@ class Government(ICurrencyHolder):
 
     def __init__(self, id: int, initial_assets: float = 0.0, config_module: Any = None, strategy: Optional["ScenarioStrategy"] = None):
         self.id = id
-        self._assets: Dict[CurrencyCode, float] = {}
+
+        initial_balance_dict = {}
         if isinstance(initial_assets, dict):
-            self._assets = initial_assets.copy()
+            initial_balance_dict = initial_assets.copy()
         else:
-            self._assets[DEFAULT_CURRENCY] = float(initial_assets)
+            initial_balance_dict[DEFAULT_CURRENCY] = float(initial_assets)
+
+        self.wallet = Wallet(self.id, initial_balance_dict)
+
         self.config_module = config_module
         self.settlement_system: Optional["ISettlementSystem"] = None
         
@@ -164,34 +170,30 @@ class Government(ICurrencyHolder):
         self.portfolio = Portfolio(self.id)
 
         logger.info(
-            f"Government {self.id} initialized with assets: {self.assets}",
+            f"Government {self.id} initialized with assets: {self.wallet.get_all_balances()}",
             extra={"tick": 0, "agent_id": self.id, "tags": ["init", "government"]},
         )
 
     @property
     def assets(self) -> Dict[CurrencyCode, float]:
         """Returns the government's liquid assets."""
-        return self._assets
+        return self.wallet.get_all_balances()
 
     def get_assets_by_currency(self) -> Dict[CurrencyCode, float]:
         """Implementation of ICurrencyHolder."""
-        return self._assets.copy()
+        return self.wallet.get_all_balances()
 
     def _internal_add_assets(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
         """
         [INTERNAL ONLY] Increase assets.
         """
-        if currency not in self._assets:
-            self._assets[currency] = 0.0
-        self._assets[currency] += amount
+        self.wallet.add(amount, currency, memo="Internal Add")
 
     def _internal_sub_assets(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
         """
         [INTERNAL ONLY] Decrease assets.
         """
-        if currency not in self._assets:
-            self._assets[currency] = 0.0
-        self._assets[currency] -= amount
+        self.wallet.subtract(amount, currency, memo="Internal Sub")
 
     def update_sensory_data(self, dto: GovernmentStateDTO):
         """
@@ -489,10 +491,14 @@ class Government(ICurrencyHolder):
         # WO-057 Deficit Spending: Update total_debt based on FinanceSystem
         if self.finance_system:
              self.total_debt = sum(b.face_value for b in self.finance_system.outstanding_bonds)
-        elif self.assets < 0:
-             self.total_debt = abs(self.assets)
         else:
-             self.total_debt = 0.0
+             # Legacy check: if assets are negative? With Wallet, they won't be unless allowed.
+             # Check if Wallet allows negative?
+             current_balance = self.wallet.get_balance(DEFAULT_CURRENCY)
+             if current_balance < 0:
+                 self.total_debt = abs(current_balance)
+             else:
+                 self.total_debt = 0.0
 
         self.tax_history.append(revenue_snapshot)
         if len(self.tax_history) > self.history_window_size:
@@ -549,14 +555,13 @@ class Government(ICurrencyHolder):
     def deposit(self, amount: float) -> None:
         """Deposits a given amount into the government's assets."""
         if amount > 0:
-            self._internal_add_assets(amount)
+            self.wallet.add(amount)
 
     def withdraw(self, amount: float) -> None:
         """Withdraws a given amount from the government's assets."""
         if amount > 0:
-            if self.assets < amount:
-                raise InsufficientFundsError(f"Government {self.id} has insufficient funds for withdrawal of {amount:.2f}. Available: {self.assets:.2f}")
-            self._internal_sub_assets(amount)
+            # Wallet checks sufficiency
+            self.wallet.subtract(amount)
 
     # WO-054: Public Education System
     def run_public_education(self, agents: List[Any], config_module: Any, current_tick: int) -> List[Transaction]:
diff --git a/simulation/bank.py b/simulation/bank.py
index ae58a10..fb1bc93 100644
--- a/simulation/bank.py
+++ b/simulation/bank.py
@@ -15,6 +15,8 @@ from modules.finance.api import (
     BorrowerProfileDTO
 )
 from modules.system.api import CurrencyCode, DEFAULT_CURRENCY, ICurrencyHolder # Added for Phase 33
+from modules.finance.wallet.wallet import Wallet
+from modules.finance.wallet.api import IWallet
 from simulation.models import Order, Transaction
 from simulation.portfolio import Portfolio
 import config
@@ -63,11 +65,15 @@ class Bank(IBankService, ICurrencyHolder):
 
     def __init__(self, id: int, initial_assets: float, config_manager: ConfigManager, settlement_system: Optional["ISettlementSystem"] = None, credit_scoring_service: Optional[ICreditScoringService] = None):
         self._id = id
-        self._assets: Dict[CurrencyCode, float] = {}
+
+        initial_balance_dict = {}
         if isinstance(initial_assets, dict):
-            self._assets = initial_assets.copy()
+            initial_balance_dict = initial_assets.copy()
         else:
-            self._assets[DEFAULT_CURRENCY] = float(initial_assets)
+            initial_balance_dict[DEFAULT_CURRENCY] = float(initial_assets)
+
+        self.wallet = Wallet(self.id, initial_balance_dict)
+
         self.config_manager = config_manager
         self.settlement_system = settlement_system
         self.credit_scoring_service = credit_scoring_service
@@ -87,7 +93,7 @@ class Bank(IBankService, ICurrencyHolder):
         # Current tick tracker (updated via run_tick usually, but need it for grant_loan defaults if available)
         self.current_tick_tracker = 0
 
-        logger.info(f"Bank {self.id} initialized. Assets: {self._assets}")
+        logger.info(f"Bank {self.id} initialized. Assets: {self.wallet.get_all_balances()}")
 
     @property
     def id(self) -> int:
@@ -100,23 +106,20 @@ class Bank(IBankService, ICurrencyHolder):
     @property
     def assets(self) -> Dict[CurrencyCode, float]:
         """Returns the bank's liquid assets (reserves)."""
-        return self._assets
+        return self.wallet.get_all_balances()
 
     def get_assets_by_currency(self) -> Dict[CurrencyCode, float]:
         """Implementation of ICurrencyHolder."""
-        return self._assets.copy()
+        return self.wallet.get_all_balances()
 
     def _internal_add_assets(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
         """[INTERNAL ONLY] Increase assets. Do not call directly."""
-        if currency not in self._assets:
-            self._assets[currency] = 0.0
-        self._assets[currency] += amount
+        self.wallet.add(amount, currency, memo="Internal Add")
 
     def _internal_sub_assets(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
         """[INTERNAL ONLY] Decrease assets. Do not call directly."""
-        if currency not in self._assets:
-            self._assets[currency] = 0.0
-        self._assets[currency] -= amount
+        # Wallet checks funds
+        self.wallet.subtract(amount, currency, memo="Internal Sub")
 
     def get_interest_rate(self) -> float:
         return self.base_rate
@@ -156,7 +159,7 @@ class Bank(IBankService, ICurrencyHolder):
 
         # Step 2: Solvency Check (Reserve Requirement)
         gold_standard_mode = self._get_config("gold_standard_mode", False)
-        usd_assets = self._assets.get(DEFAULT_CURRENCY, 0.0)
+        usd_assets = self.wallet.get_balance(DEFAULT_CURRENCY)
         if gold_standard_mode:
             if usd_assets < amount:
                 return None
@@ -244,7 +247,7 @@ class Bank(IBankService, ICurrencyHolder):
 
         # Step 2: Liquidity Check (Direct Funding from Reserves)
         # Since this is a direct transfer of reserves, we must have the cash.
-        usd_assets = self._assets.get(DEFAULT_CURRENCY, 0.0)
+        usd_assets = self.wallet.get_balance(DEFAULT_CURRENCY)
         if usd_assets < amount:
             logger.warning(f"LOAN_DENIED | Bank {self.id} insufficient liquidity for direct funding. Assets: {usd_assets:.2f} < Req: {amount:.2f}")
             return None
@@ -394,14 +397,11 @@ class Bank(IBankService, ICurrencyHolder):
 
     def deposit(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
         if amount > 0:
-            self._internal_add_assets(amount, currency=currency)
+            self.wallet.add(amount, currency, memo="Deposit")
 
     def withdraw(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
         if amount > 0:
-            current_bal = self._assets.get(currency, 0.0)
-            if current_bal < amount:
-                 raise InsufficientFundsError(f"Insufficient funds in {currency}")
-            self._internal_sub_assets(amount, currency=currency)
+            self.wallet.subtract(amount, currency, memo="Withdraw")
 
     def get_debt_summary(self, agent_id: int) -> Dict[str, float]:
         """Legacy method used by TickScheduler etc. until refactored."""
@@ -520,7 +520,7 @@ class Bank(IBankService, ICurrencyHolder):
         WO-109: Generate 'lender_of_last_resort' transactions if insolvent.
         This replaces the old direct-modification `check_solvency`.
         """
-        usd_assets = self._assets.get(DEFAULT_CURRENCY, 0.0)
+        usd_assets = self.wallet.get_balance(DEFAULT_CURRENCY)
         if usd_assets < 0:
             solvency_buffer = self._get_config("bank.solvency_buffer", getattr(config, "BANK_SOLVENCY_BUFFER", 1000.0))
             borrow_amount = abs(usd_assets) + solvency_buffer
diff --git a/simulation/base_agent.py b/simulation/base_agent.py
index d92962e..f5a32a6 100644
--- a/simulation/base_agent.py
+++ b/simulation/base_agent.py
@@ -3,6 +3,8 @@ from typing import Dict, Any, Optional, TYPE_CHECKING
 import logging
 from modules.finance.api import InsufficientFundsError
 from modules.system.api import CurrencyCode, DEFAULT_CURRENCY, ICurrencyHolder # Added for Phase 33
+from modules.finance.wallet.wallet import Wallet
+from modules.finance.wallet.api import IWallet
 
 if TYPE_CHECKING:
     from modules.memory.api import MemoryV2Interface
@@ -21,11 +23,15 @@ class BaseAgent(ICurrencyHolder, ABC):
         memory_interface: Optional["MemoryV2Interface"] = None,
     ):
         self.id = id
-        self._assets: Dict[CurrencyCode, float] = {}
+
+        initial_balance_dict = {}
         if isinstance(initial_assets, dict):
-            self._assets = initial_assets.copy()
+            initial_balance_dict = initial_assets.copy()
         else:
-            self._assets[DEFAULT_CURRENCY] = float(initial_assets)
+            initial_balance_dict[DEFAULT_CURRENCY] = float(initial_assets)
+
+        self._wallet = Wallet(self.id, initial_balance_dict)
+
         self.needs = initial_needs
         self.decision_engine = decision_engine
         self.value_orientation = value_orientation
@@ -45,45 +51,44 @@ class BaseAgent(ICurrencyHolder, ABC):
         self.memory: Dict[str, Any] = {}
         self.memory_v2 = memory_interface
 
+    @property
+    def wallet(self) -> IWallet:
+        return self._wallet
+
     @property
     def assets(self) -> Dict[CurrencyCode, float]:
         """Current assets keyed by currency (Read-Only)."""
-        return self._assets
+        return self._wallet.get_all_balances()
 
     def get_assets_by_currency(self) -> Dict[CurrencyCode, float]:
         """Implementation of ICurrencyHolder."""
-        return self._assets.copy()
+        return self._wallet.get_all_balances()
 
     def _internal_add_assets(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
         """
         [INTERNAL ONLY] Increase assets.
         """
-        if currency not in self._assets:
-            self._assets[currency] = 0.0
-        self._assets[currency] += amount
+        self._wallet.add(amount, currency, memo="Internal Add")
 
     def _internal_sub_assets(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
         """
         [INTERNAL ONLY] Decrease assets.
         """
-        if currency not in self._assets:
-             self._assets[currency] = 0.0
-        self._assets[currency] -= amount
+        # Checks are handled by Wallet.subtract unless allow_negative_balance is True
+        self._wallet.subtract(amount, currency, memo="Internal Sub")
 
     def deposit(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
         """Deposits a given amount into the entity's account."""
         if amount > 0:
-            self._internal_add_assets(amount, currency)
+            self._wallet.add(amount, currency, memo="Deposit")
 
     def withdraw(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
         """
         Withdraws a given amount from the entity's account.
         """
         if amount > 0:
-            current_bal = self._assets.get(currency, 0.0)
-            if current_bal < amount:
-                raise InsufficientFundsError(f"Agent {self.id} has insufficient funds for withdrawal of {amount:.2f} {currency}. Available: {current_bal:.2f}")
-            self._internal_sub_assets(amount, currency)
+            # Wallet raises InsufficientFundsError automatically
+            self._wallet.subtract(amount, currency, memo="Withdraw")
 
     def get_agent_data(self) -> Dict[str, Any]:
         """AI 의사결정에 필요한 에이전트의 현재 상태 데이터를 반환합니다."""
diff --git a/simulation/components/finance_department.py b/simulation/components/finance_department.py
index 9876b57..fd42eee 100644
--- a/simulation/components/finance_department.py
+++ b/simulation/components/finance_department.py
@@ -25,7 +25,7 @@ class FinanceDepartment:
         self.config = config
 
         # Centralized Assets (WO-103 Phase 1)
-        self._balance: Dict[CurrencyCode, float] = {DEFAULT_CURRENCY: initial_capital}
+        # self._balance replaced by self.firm.wallet (BaseAgent.wallet)
 
         # Financial State
         self.retained_earnings: float = 0.0 # This might stay float as a net equity measure
@@ -55,19 +55,15 @@ class FinanceDepartment:
 
     @property
     def balance(self) -> Dict[CurrencyCode, float]:
-        return self._balance
+        return self.firm.wallet.get_all_balances()
 
     def credit(self, amount: float, description: str = "", currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
         """Adds funds to the firm's cash reserves."""
-        if currency not in self._balance:
-            self._balance[currency] = 0.0
-        self._balance[currency] += amount
+        self.firm.wallet.add(amount, currency, memo=description)
 
     def debit(self, amount: float, description: str = "", currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
         """Deducts funds from the firm's cash reserves."""
-        if currency not in self._balance:
-            self._balance[currency] = 0.0
-        self._balance[currency] -= amount
+        self.firm.wallet.subtract(amount, currency, memo=description)
 
     def record_revenue(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY):
         if currency not in self.revenue_this_turn:
@@ -112,7 +108,8 @@ class FinanceDepartment:
     def generate_maintenance_transaction(self, government: IFinancialEntity, current_time: int) -> Optional[Transaction]:
         """Generates maintenance fee transaction."""
         fee = self.config.firm_maintenance_fee
-        payment = min(self._balance.get(DEFAULT_CURRENCY, 0.0), fee)
+        current_balance = self.firm.wallet.get_balance(DEFAULT_CURRENCY)
+        payment = min(current_balance, fee)
 
         if payment > 0:
             self.record_expense(payment)
@@ -233,7 +230,7 @@ class FinanceDepartment:
         weekly_burn_rate = maintenance_fee + (avg_wage * len(employees))
         required_reserves = weekly_burn_rate * reserve_period
 
-        usd_balance = self._balance.get(DEFAULT_CURRENCY, 0.0)
+        usd_balance = self.firm.wallet.get_balance(DEFAULT_CURRENCY)
         distributable_cash = usd_balance - required_reserves
 
         transactions = []
@@ -272,7 +269,7 @@ class FinanceDepartment:
         self.firm.total_debt += amount
 
     def calculate_altman_z_score(self) -> float:
-        usd_balance = self._balance.get(DEFAULT_CURRENCY, 0.0)
+        usd_balance = self.firm.wallet.get_balance(DEFAULT_CURRENCY)
         total_assets = usd_balance + self.firm.capital_stock + self.get_inventory_value()
         if total_assets == 0: return 0.0
         working_capital = usd_balance - getattr(self.firm, 'total_debt', 0.0)
@@ -297,7 +294,7 @@ class FinanceDepartment:
 
     def check_cash_crunch(self) -> bool:
         threshold = 0.1 * self.last_daily_expenses
-        return self._balance.get(DEFAULT_CURRENCY, 0.0) < threshold
+        return self.firm.wallet.get_balance(DEFAULT_CURRENCY) < threshold
 
     def trigger_emergency_liquidation(self) -> List[Order]:
         orders = []
@@ -313,7 +310,7 @@ class FinanceDepartment:
         return orders
 
     def calculate_valuation(self) -> float:
-        usd_balance = self._balance.get(DEFAULT_CURRENCY, 0.0)
+        usd_balance = self.firm.wallet.get_balance(DEFAULT_CURRENCY)
         net_assets = usd_balance + self.get_inventory_value() + self.firm.capital_stock
         avg_profit = sum(self.profit_history) / len(self.profit_history) if self.profit_history else 0.0
         self.firm.valuation = net_assets + max(0.0, avg_profit) * self.config.valuation_per_multiplier
@@ -327,7 +324,7 @@ class FinanceDepartment:
         return total_val
 
     def get_financial_snapshot(self) -> Dict[str, float]:
-        usd_balance = self._balance.get(DEFAULT_CURRENCY, 0.0)
+        usd_balance = self.firm.wallet.get_balance(DEFAULT_CURRENCY)
         total_assets = usd_balance + self.get_inventory_value() + getattr(self.firm, 'capital_stock', 0.0)
         current_liabilities = getattr(self.firm, "total_debt", 0.0)
         avg_profit = self.current_profit.get(DEFAULT_CURRENCY, 0.0)
@@ -351,7 +348,7 @@ class FinanceDepartment:
         outstanding_shares = self.firm.total_shares - self.firm.treasury_shares
         if outstanding_shares <= 0: return 0.0
         debt = getattr(self.firm, 'total_debt', 0.0)
-        net_assets = self._balance.get(DEFAULT_CURRENCY, 0.0) - debt
+        net_assets = self.firm.wallet.get_balance(DEFAULT_CURRENCY) - debt
         return max(0.0, net_assets) / outstanding_shares
 
     def get_market_cap(self, stock_price: Optional[float] = None) -> float:
@@ -359,15 +356,15 @@ class FinanceDepartment:
         return (self.firm.total_shares - self.firm.treasury_shares) * stock_price
 
     def get_assets(self) -> float:
-        return self._balance.get(DEFAULT_CURRENCY, 0.0)
+        return self.firm.wallet.get_balance(DEFAULT_CURRENCY)
 
     def invest_in_automation(self, amount: float, government: Optional[IFinancialEntity] = None) -> bool:
-        if self._balance.get(DEFAULT_CURRENCY, 0.0) < amount: return False
+        if self.firm.wallet.get_balance(DEFAULT_CURRENCY) < amount: return False
         if not self.firm.settlement_system or not government: return False
         return self.firm.settlement_system.transfer(self.firm, government, amount, "Automation", currency=DEFAULT_CURRENCY)
 
     def invest_in_rd(self, amount: float, government: Optional[IFinancialEntity] = None) -> bool:
-        if self._balance.get(DEFAULT_CURRENCY, 0.0) < amount: return False
+        if self.firm.wallet.get_balance(DEFAULT_CURRENCY) < amount: return False
         if not self.firm.settlement_system or not government: return False
         if self.firm.settlement_system.transfer(self.firm, government, amount, "R&D", currency=DEFAULT_CURRENCY):
             self.record_expense(amount)
@@ -375,7 +372,7 @@ class FinanceDepartment:
         return False
 
     def invest_in_capex(self, amount: float, government: Optional[IFinancialEntity] = None) -> bool:
-        if self._balance.get(DEFAULT_CURRENCY, 0.0) < amount: return False
+        if self.firm.wallet.get_balance(DEFAULT_CURRENCY) < amount: return False
         if not self.firm.settlement_system or not government: return False
         return self.firm.settlement_system.transfer(self.firm, government, amount, "CAPEX", currency=DEFAULT_CURRENCY)
 
@@ -383,14 +380,14 @@ class FinanceDepartment:
         self.firm.dividend_rate = rate
 
     def pay_severance(self, employee: Household, amount: float) -> bool:
-        if self._balance.get(DEFAULT_CURRENCY, 0.0) >= amount and self.firm.settlement_system:
+        if self.firm.wallet.get_balance(DEFAULT_CURRENCY) >= amount and self.firm.settlement_system:
             if self.firm.settlement_system.transfer(self.firm, employee, amount, "Severance", currency=DEFAULT_CURRENCY):
                 self.record_expense(amount)
                 return True
         return False
 
     def pay_ad_hoc_tax(self, amount: float, tax_type: str, government: Any, current_time: int) -> bool:
-        if self._balance.get(DEFAULT_CURRENCY, 0.0) >= amount and self.firm.settlement_system:
+        if self.firm.wallet.get_balance(DEFAULT_CURRENCY) >= amount and self.firm.settlement_system:
             if self.firm.settlement_system.transfer(self.firm, government, amount, tax_type, currency=DEFAULT_CURRENCY):
                 self.record_expense(amount)
                 return True
diff --git a/simulation/core_agents.py b/simulation/core_agents.py
index 5a1ba62..5738ae0 100644
--- a/simulation/core_agents.py
+++ b/simulation/core_agents.py
@@ -23,6 +23,7 @@ from simulation.ai.household_ai import HouseholdAI
 from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
 from simulation.systems.api import LifecycleContext, MarketInteractionContext, LearningUpdateContext, ILearningAgent
 from modules.system.api import DEFAULT_CURRENCY, CurrencyCode
+from modules.finance.wallet.wallet import Wallet
 import simulation
 
 # New Components
@@ -152,7 +153,7 @@ class Household(
         initial_assets_dict = {DEFAULT_CURRENCY: float(initial_assets)}
 
         self._econ_state = EconStateDTO(
-            assets=initial_assets_dict,
+            wallet=Wallet(id, initial_assets_dict),
             inventory={},
             inventory_quality={},
             durable_assets=[],
@@ -265,6 +266,9 @@ class Household(
             **kwargs,
         )
 
+        # Ensure BaseAgent uses the same wallet as EconStateDTO
+        self._wallet = self._econ_state.wallet
+
         # WO-123: Memory Logging - Record Birth
         if self.memory_v2:
             from modules.memory.V2.dtos import MemoryRecordDTO
diff --git a/simulation/firms.py b/simulation/firms.py
index 428407a..a846eff 100644
--- a/simulation/firms.py
+++ b/simulation/firms.py
@@ -146,37 +146,8 @@ class Firm(BaseAgent, ILearningAgent):
         self.has_bailout_loan = False
         self.decision_engine.loan_market = loan_market
 
-    @property
-    @override
-    def assets(self) -> Dict[CurrencyCode, float]:
-        """Returns the firm's liquid assets."""
-        return self.finance.balance
-
-    @assets.setter
-    def assets(self, value: Dict[CurrencyCode, float]) -> None:
-        """Sets the firm's liquid assets (Compatibility)."""
-        self.finance._balance = value # Direct internal access for override
-        self._assets = value
-
-    def _internal_add_assets(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
-        """[PROTECTED] Delegate to FinanceDepartment and sync legacy storage."""
-        if hasattr(self, 'finance'):
-            self.finance.credit(amount, "Settlement Transfer", currency=currency)
-            self._assets = self.finance.balance
-        else:
-            if currency not in self._assets:
-                self._assets[currency] = 0.0
-            self._assets[currency] += amount
-
-    def _internal_sub_assets(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
-        """[PROTECTED] Delegate to FinanceDepartment and sync legacy storage."""
-        if hasattr(self, 'finance'):
-            self.finance.debit(amount, "Settlement Transfer", currency=currency)
-            self._assets = self.finance.balance
-        else:
-            if currency not in self._assets:
-                self._assets[currency] = 0.0
-            self._assets[currency] -= amount
+    # assets property and _internal_* methods are inherited from BaseAgent which uses Wallet.
+    # We remove overrides to ensure single source of truth (Wallet).
 
     def init_ipo(self, stock_market: StockMarket):
         """Register firm in stock market order book."""
diff --git a/simulation/systems/settlement_system.py b/simulation/systems/settlement_system.py
index e5633e3..3a013fb 100644
--- a/simulation/systems/settlement_system.py
+++ b/simulation/systems/settlement_system.py
@@ -157,10 +157,15 @@ class SettlementSystem(ISettlementSystem):
             self.logger.warning(f"Agent {agent_id} does not implement IPortfolioHandler. Portfolio not captured.")
 
         # 2. Atomic Transfer: Cash
-        cash_balance_raw = agent.assets
-        cash_balance = cash_balance_raw
-        if isinstance(cash_balance_raw, dict):
-            cash_balance = cash_balance_raw.get(DEFAULT_CURRENCY, 0.0)
+        cash_balance = 0.0
+        if hasattr(agent, 'wallet'):
+            cash_balance = agent.wallet.get_balance(DEFAULT_CURRENCY)
+        else:
+            # Fallback
+            cash_balance_raw = agent.assets
+            cash_balance = cash_balance_raw
+            if isinstance(cash_balance_raw, dict):
+                cash_balance = cash_balance_raw.get(DEFAULT_CURRENCY, 0.0)
 
         if cash_balance > 0:
             agent.withdraw(cash_balance, currency=DEFAULT_CURRENCY)
@@ -368,18 +373,25 @@ class SettlementSystem(ISettlementSystem):
 
         # WO-178: Escheatment Logic
         if government_agent:
+            current_assets_val = 0.0
             try:
+                if hasattr(agent, 'wallet'):
+                    current_assets_val = agent.wallet.get_balance(DEFAULT_CURRENCY)
                 # TD-073: Check finance.balance first for Firms
-                if hasattr(agent, 'finance') and hasattr(agent.finance, 'balance'):
+                elif hasattr(agent, 'finance') and hasattr(agent.finance, 'balance'):
                     current_assets = agent.finance.balance
+                    if isinstance(current_assets, dict):
+                        current_assets_val = current_assets.get(DEFAULT_CURRENCY, 0.0)
+                    else:
+                        current_assets_val = current_assets
                 else:
                     current_assets = float(agent.assets) if hasattr(agent, 'assets') else 0.0
+                    if isinstance(current_assets, dict):
+                        current_assets_val = current_assets.get(DEFAULT_CURRENCY, 0.0)
+                    else:
+                        current_assets_val = current_assets
             except (TypeError, ValueError):
-                current_assets = 0.0
-
-            current_assets_val = current_assets
-            if isinstance(current_assets, dict):
-                current_assets_val = current_assets.get(DEFAULT_CURRENCY, 0.0)
+                current_assets_val = 0.0
 
             if current_assets_val > 0:
                 self.transfer(
@@ -418,14 +430,17 @@ class SettlementSystem(ISettlementSystem):
         # 2. Standard Agent Checks (Compatible with TD-073 Firm Refactor)
         current_cash = 0.0
 
-        # Check for Firm's finance component first
-        if hasattr(agent, 'finance') and hasattr(agent.finance, 'balance'):
+        # Priority: Wallet -> Finance -> EconState -> Assets
+        if hasattr(agent, 'wallet'):
+            current_cash = agent.wallet.get_balance(currency)
+        # Check for Firm's finance component first (Legacy fallback)
+        elif hasattr(agent, 'finance') and hasattr(agent.finance, 'balance'):
              current_cash_raw = agent.finance.balance
              if isinstance(current_cash_raw, dict):
                  current_cash = current_cash_raw.get(currency, 0.0)
              else:
                  current_cash = current_cash_raw
-        # Check for Household's EconComponent state
+        # Check for Household's EconComponent state (Legacy fallback)
         elif hasattr(agent, '_econ_state') and hasattr(agent._econ_state, 'assets'):
              current_cash_raw = agent._econ_state.assets
              if isinstance(current_cash_raw, dict):
diff --git a/trace_leak.py b/trace_leak.py
index 094e795..44238fe 100644
--- a/trace_leak.py
+++ b/trace_leak.py
@@ -1,49 +1,112 @@
-import ast
-import os
 import sys
+import logging
+from typing import Dict, Optional, List, Any
+from dataclasses import dataclass
 
-def check_file(filepath):
-    with open(filepath, "r") as f:
-        tree = ast.parse(f.read())
-
-    leaks = []
-
-    class Visitor(ast.NodeVisitor):
-        def visit_FunctionDef(self, node):
-            if node.name == "make_decision":
-                # Check for usage of input_dto.markets or similar
-                for child in ast.walk(node):
-                    if isinstance(child, ast.Attribute):
-                        if child.attr == "markets":
-                            # This is a potential leak if accessing input_dto.markets
-                            leaks.append(f"{filepath}:{child.lineno} Access to .markets attribute found in make_decision")
-
-                    # Also check for "markets.get" if "markets" was unpacked
-                    if isinstance(child, ast.Call):
-                         if isinstance(child.func, ast.Attribute) and child.func.attr == "get":
-                             if isinstance(child.func.value, ast.Name) and child.func.value.id == "markets":
-                                 leaks.append(f"{filepath}:{child.lineno} markets.get() call found")
-
-    Visitor().visit(tree)
-    return leaks
-
-files_to_check = [
-    "simulation/core_agents.py",
-    "simulation/firms.py"
-]
-
-all_leaks = []
-for f in files_to_check:
-    if os.path.exists(f):
-        all_leaks.extend(check_file(f))
+# Setup logging
+logging.basicConfig(level=logging.INFO)
+logger = logging.getLogger("TraceLeak")
+
+# Import Modules
+from modules.finance.wallet.audit import GLOBAL_WALLET_LOG
+from modules.finance.wallet.wallet import Wallet
+from modules.finance.wallet.api import IWallet, WalletOpLogDTO
+from modules.finance.api import IFinancialEntity
+from modules.system.api import DEFAULT_CURRENCY, CurrencyCode
+from simulation.systems.settlement_system import SettlementSystem
+
+# --- Mocks ---
+
+@dataclass
+class MockAgent:
+    id: int
+    initial_assets: float = 0.0
+
+    def __post_init__(self):
+        self.wallet = Wallet(self.id, {DEFAULT_CURRENCY: self.initial_assets})
+
+    @property
+    def assets(self) -> float:
+        return self.wallet.get_balance(DEFAULT_CURRENCY)
+
+    def deposit(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
+        if amount > 0:
+            self.wallet.add(amount, currency, memo="Deposit")
+
+    def withdraw(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
+        if amount > 0:
+            self.wallet.subtract(amount, currency, memo="Withdraw")
+
+# Define class with name "CentralBank" to satisfy SettlementSystem check
+class CentralBank(MockAgent):
+    def __post_init__(self):
+        self.wallet = Wallet(self.id, allow_negative_balance=True)
+
+    def mint(self, amount: float) -> None:
+        self.wallet.add(amount, memo="Mint")
+
+# --- Verification Logic ---
+
+def verify_audit_log(expected_net_change: float = 0.0):
+    logger.info("Verifying Global Audit Log...")
+
+    total_delta = 0.0
+    by_currency = {}
+
+    for entry in GLOBAL_WALLET_LOG:
+        total_delta += entry.delta
+        by_currency[entry.currency] = by_currency.get(entry.currency, 0.0) + entry.delta
+
+    logger.info(f"Total Logged Operations: {len(GLOBAL_WALLET_LOG)}")
+    logger.info(f"Net Global Delta: {total_delta}")
+    logger.info(f"By Currency: {by_currency}")
+
+    net_default = by_currency.get(DEFAULT_CURRENCY, 0.0)
+
+    if abs(net_default - expected_net_change) > 1e-9:
+        logger.error(f"INTEGRITY FAIL: Expected {expected_net_change}, Got {net_default}")
+        sys.exit(1)
     else:
-        print(f"File not found: {f}")
-
-if all_leaks:
-    print("Leaks found:")
-    for leak in all_leaks:
-        print(leak)
-    sys.exit(1)
-else:
-    print("No leaks found.")
-    sys.exit(0)
+        logger.info("INTEGRITY PASS: Zero-Sum Verified (Relative to Minting)")
+
+def main():
+    logger.info("Starting Trace Leak Overhaul Verification...")
+    GLOBAL_WALLET_LOG.clear()
+
+    # 1. Initialize Agents
+    alice = MockAgent(1, 100.0)
+    bob = MockAgent(2, 50.0)
+    cb = CentralBank(999)
+
+    settlement = SettlementSystem(logger=logger)
+
+    # 2. Transfer Alice -> Bob (50)
+    logger.info("--- Test 1: Simple Transfer (Alice -> Bob) ---")
+    success = settlement.transfer(alice, bob, 50.0, "Test Transfer", tick=1)
+    if not success:
+        logger.error("Transfer failed!")
+        sys.exit(1)
+
+    verify_audit_log(expected_net_change=0.0)
+
+    # 3. Central Bank Minting
+    logger.info("--- Test 2: CB Minting ---")
+    cb.mint(1000.0)
+    verify_audit_log(expected_net_change=1000.0)
+
+    # 4. CB Transfer to Alice (Helicopter Money)
+    logger.info("--- Test 3: CB -> Alice (Stimulus) ---")
+    # Should result in Net +200 if CB is recognized
+    settlement.create_and_transfer(cb, alice, 200.0, "Stimulus", tick=2)
+    verify_audit_log(expected_net_change=1200.0)
+
+    # 5. Liquidation (Destruction)
+    logger.info("--- Test 4: Liquidation (Alice) ---")
+    # Should result in Net -50
+    settlement.transfer_and_destroy(alice, cb, 50.0, "Tax Burn", tick=3)
+    verify_audit_log(expected_net_change=1150.0)
+
+    logger.info("Verification Complete!")
+
+if __name__ == "__main__":
+    main()
