diff --git a/communications/insights/TD-270_TD-271_Market_Decoupling_Report.md b/communications/insights/TD-270_TD-271_Market_Decoupling_Report.md
new file mode 100644
index 00000000..2fa4b153
--- /dev/null
+++ b/communications/insights/TD-270_TD-271_Market_Decoupling_Report.md
@@ -0,0 +1,40 @@
+# Technical Insight Report: Market Decoupling & Protocol Hardening (TD-270/271)
+
+## 1. Problem Phenomenon
+The legacy `OrderBookMarket` and `StockMarket` classes tightly coupled state management with matching logic. This made the matching logic difficult to test in isolation, reuse, or swap. Additionally, `IFinancialAgent` lacked a standardized way to access multi-currency balances and total wealth, leading to inconsistent implementations across `Household` and `Firm`. Finally, firm-owned real estate provided no direct operational benefit, creating a disconnect between asset ownership and productivity.
+
+## 2. Root Cause Analysis
+- **Coupled Logic:** Matching algorithms (Price-Time Priority, Targeted Matching) were embedded directly within the Market classes (`_match_orders_for_item`, `_match_orders_for_firm`), operating on internal mutable state.
+- **Protocol Gaps:** `IFinancialAgent` was designed primarily for transactional methods (`deposit`, `withdraw`) but lacked a uniform read interface for comprehensive financial state (`get_all_balances`).
+- **Missing Feature:** No mechanism existed to translate `owned_properties` into a production cost advantage for firms.
+
+## 3. Solution Implementation Details
+
+### Track 1: Stateless Matching Engines
+- **New Architecture:** Extracted matching logic into `simulation/markets/matching_engine.py`.
+- **DTOs:** Defined `OrderBookStateDTO`, `StockMarketStateDTO`, and `MatchingResultDTO` in `modules/market/api.py`.
+- **Stateless Engines:**
+    - `OrderBookMatchingEngine`: Implements generic order book matching (Goods/Labor) with Targeted (Brand) and General matching phases.
+    - `StockMatchingEngine`: Implements stock matching logic.
+- **Market Refactoring:** Updated `OrderBookMarket` and `StockMarket` to delegate matching to these engines. The Markets now construct a State DTO, invoke the engine, and apply the returned `MatchingResultDTO` (transactions and unfilled orders) back to their internal state.
+
+### Track 2: Protocol Hardening (TD-270)
+- **Interface Update:** Enhanced `IFinancialAgent` in `modules/finance/api.py` with:
+    - `get_all_balances() -> Dict[CurrencyCode, float]`
+    - `@property total_wealth -> float`
+- **Implementation:** Updated `Household` and `Firm` agents to implement these methods, ensuring consistent access to financial state across the simulation.
+
+### Track 3: Firm Real Estate Utilization (TD-271)
+- **Component:** Created `RealEstateUtilizationComponent` in `simulation/firms.py`.
+- **Logic:** Calculates a virtual revenue/cost reduction based on `owned_space * space_utility_factor * regional_rent_index`.
+- **Integration:**
+    - Updated `Firm.produce` to accept an `effects_queue`.
+    - Invokes `RealEstateUtilizationComponent.apply` during production.
+    - Records the bonus as internal revenue (`firm.record_revenue`) to reflect increased efficiency/reduced cost in profit calculations.
+    - Emits a `PRODUCTION_COST_REDUCTION` effect to the `effects_queue` for system visibility.
+    - Updated `Phase_Production` to inject the `effects_queue`.
+
+## 4. Lessons Learned & Technical Debt
+- **DTO Strictness:** `CanonicalOrderDTO` is strict about arguments. Legacy tests often used `Order(...)` aliases with old argument names (`order_type` vs `side`, `price` vs `price_limit`). Migration requires careful updates to tests.
+- **Statelessness vs. Metadata:** Stateless engines sometimes need metadata (like `created_tick` for order expiry) that isn't intrinsic to the matching logic but needs to be preserved. Passing this through `metadata` fields in DTOs is a viable pattern but requires careful handling during DTO-to-Domain object conversion.
+- **Audit Noise:** `audit_zero_sum.py` tracks "Real Wealth" which can be sensitive to valuation changes. Virtual revenues (like the Real Estate Bonus) affect Profit (and thus Valuation) but not Cash, potentially causing divergences in simplified wealth audit models if they assume Revenue == Cash. `trace_leak.py` (M2 tracking) remains the gold standard for monetary integrity.
diff --git a/modules/finance/api.py b/modules/finance/api.py
index a1406d4d..809a60d8 100644
--- a/modules/finance/api.py
+++ b/modules/finance/api.py
@@ -347,6 +347,15 @@ class IFinancialAgent(Protocol):
         """Returns the current balance for the specified currency."""
         ...
 
+    def get_all_balances(self) -> Dict[CurrencyCode, float]:
+        """Returns a copy of all currency balances."""
+        ...
+
+    @property
+    def total_wealth(self) -> float:
+        """Returns the total wealth in default currency estimation."""
+        ...
+
 
 class IBank(IFinancialAgent, Protocol):
     """
diff --git a/modules/market/api.py b/modules/market/api.py
index 0dc0075d..ab99e0dd 100644
--- a/modules/market/api.py
+++ b/modules/market/api.py
@@ -98,8 +98,36 @@ class HousingConfigDTO(TypedDict):
     mortgage_term_ticks: int
     # Note: Interest rate is handled by the banking/lending system config
 
+@dataclass
+class OrderBookStateDTO:
+    """State DTO for generic OrderBook markets (Goods, Labor)."""
+    buy_orders: Dict[str, List[CanonicalOrderDTO]]
+    sell_orders: Dict[str, List[CanonicalOrderDTO]]
+    market_id: str
+
+@dataclass
+class StockMarketStateDTO:
+    """State DTO for Stock Markets."""
+    buy_orders: Dict[int, List[CanonicalOrderDTO]] # firm_id -> orders
+    sell_orders: Dict[int, List[CanonicalOrderDTO]]
+    market_id: str
+
+@dataclass
+class MatchingResultDTO:
+    """Result DTO returned by stateless matching engines."""
+    transactions: List["Transaction"]
+    unfilled_buy_orders: Dict[str, List[CanonicalOrderDTO]] # item_id (or firm_id str) -> orders
+    unfilled_sell_orders: Dict[str, List[CanonicalOrderDTO]]
+    market_stats: Dict[str, Any] # e.g. last_traded_prices, volume
+
 # --- Interfaces ---
 
+class IMatchingEngine(Protocol):
+    """Protocol for stateless market matching engines."""
+    def match(self, state: Any, current_tick: int) -> MatchingResultDTO:
+        """Executes matching logic on the provided state snapshot."""
+        ...
+
 class ISpecializedTransactionHandler(Protocol):
     """
     Interface for handlers that manage specific, complex transaction types.
diff --git a/simulation/core_agents.py b/simulation/core_agents.py
index 4502d0c3..1c8a777b 100644
--- a/simulation/core_agents.py
+++ b/simulation/core_agents.py
@@ -698,6 +698,16 @@ class Household(
     def get_balance(self, currency: CurrencyCode = DEFAULT_CURRENCY) -> float:
         return self._econ_state.wallet.get_balance(currency)
 
+    @override
+    def get_all_balances(self) -> Dict[CurrencyCode, float]:
+        """Returns a copy of all currency balances."""
+        return self._econ_state.wallet.get_all_balances()
+
+    @property
+    def total_wealth(self) -> float:
+        """Returns the total wealth in default currency estimation."""
+        return self._econ_state.wallet.get_balance(DEFAULT_CURRENCY)
+
     @override
     def get_assets_by_currency(self) -> Dict[CurrencyCode, float]:
         return self._econ_state.wallet.get_all_balances()
diff --git a/simulation/firms.py b/simulation/firms.py
index baf59927..71ca97e3 100644
--- a/simulation/firms.py
+++ b/simulation/firms.py
@@ -36,6 +36,49 @@ from modules.inventory.manager import InventoryManager
 from simulation.systems.api import ILearningAgent, LearningUpdateContext
 from simulation.systems.tech.api import FirmTechInfoDTO
 
+class RealEstateUtilizationComponent:
+    """
+    TD-271: Converts firm-owned real estate into a production bonus.
+    Applies production cost reduction based on owned space and market conditions.
+    """
+    def apply(self, firm: "Firm", current_tick: int, market_data: Optional[Dict[str, Any]] = None) -> Optional[Dict[str, Any]]:
+        # 1. Calculate Owned Space
+        # Assuming 1 property = 1 unit of space for now (or configurable)
+        owned_space = len(firm.owned_properties)
+        if owned_space <= 0:
+            return None
+
+        # 2. Get Factors
+        # space_utility_factor: How much cost reduction per unit of space?
+        # Ideally from config. Assuming default 100.0 if not in config.
+        space_utility_factor = getattr(firm.config, "space_utility_factor", 100.0)
+
+        # regional_rent_index: From market data or default 1.0
+        regional_rent_index = 1.0
+        # Placeholder for market data integration
+
+        # 3. Calculate Cost Reduction (Bonus)
+        # Formula: owned_space * space_utility_factor * regional_rent_index
+        cost_reduction = owned_space * space_utility_factor * regional_rent_index
+
+        # 4. Apply Bonus
+        # Effectively reduces net cost by increasing revenue/profit internally
+        if cost_reduction > 0:
+             # We assume this is a virtual saving.
+             firm.record_revenue(cost_reduction, DEFAULT_CURRENCY)
+
+             return {
+                 "type": "PRODUCTION_COST_REDUCTION",
+                 "agent_id": firm.id,
+                 "amount": cost_reduction,
+                 "tick": current_tick,
+                 "details": {
+                     "owned_space": owned_space,
+                     "utility_factor": space_utility_factor
+                 }
+             }
+        return None
+
 if TYPE_CHECKING:
     from simulation.finance.api import ISettlementSystem
     from simulation.loan_market import LoanMarket
@@ -123,6 +166,9 @@ class Firm(ILearningAgent, IFinancialEntity, IFinancialAgent, ILiquidatable, IOr
         # Brand Manager (Kept as component for now, or could be moved to SalesState/Engine)
         self.brand_manager = BrandManager(self.id, self.config, self.logger)
         
+        # TD-271: Real Estate Utilization
+        self.real_estate_utilization_component = RealEstateUtilizationComponent()
+
         # Loan Market
         self.decision_engine.loan_market = loan_market
         
@@ -568,7 +614,7 @@ class Firm(ILearningAgent, IFinancialEntity, IFinancialAgent, ILiquidatable, IOr
 
         self.sales_engine.adjust_marketing_budget(self.sales_state, market_context, total_revenue)
 
-    def produce(self, current_time: int, technology_manager: Optional[Any] = None) -> None:
+    def produce(self, current_time: int, technology_manager: Optional[Any] = None, effects_queue: Optional[List[Dict[str, Any]]] = None) -> None:
         self.current_production = self.production_engine.produce(
             self.production_state,
             self, # IInventoryHandler
@@ -579,6 +625,11 @@ class Firm(ILearningAgent, IFinancialEntity, IFinancialAgent, ILiquidatable, IOr
             technology_manager
         )
 
+        # TD-271: Real Estate Utilization
+        effect = self.real_estate_utilization_component.apply(self, current_time)
+        if effect and effects_queue is not None:
+            effects_queue.append(effect)
+
     @override
     def clone(self, new_id: int, initial_assets_from_parent: float, current_tick: int) -> "Firm":
         cloned_decision_engine = copy.deepcopy(self.decision_engine)
@@ -933,6 +984,15 @@ class Firm(ILearningAgent, IFinancialEntity, IFinancialAgent, ILiquidatable, IOr
         """Implements IFinancialAgent.get_balance."""
         return self.wallet.get_balance(currency)
 
+    def get_all_balances(self) -> Dict[CurrencyCode, float]:
+        """Returns a copy of all currency balances."""
+        return self.wallet.get_all_balances()
+
+    @property
+    def total_wealth(self) -> float:
+        """Returns the total wealth in default currency estimation."""
+        return self.wallet.get_balance(DEFAULT_CURRENCY)
+
     @override
     def get_assets_by_currency(self) -> Dict[CurrencyCode, float]:
         """Implementation of ICurrencyHolder."""
diff --git a/simulation/markets/matching_engine.py b/simulation/markets/matching_engine.py
new file mode 100644
index 00000000..10169b87
--- /dev/null
+++ b/simulation/markets/matching_engine.py
@@ -0,0 +1,378 @@
+from typing import List, Dict, Any, Optional, Tuple, Protocol
+from dataclasses import replace
+import logging
+
+from modules.market.api import (
+    IMatchingEngine, OrderBookStateDTO, StockMarketStateDTO,
+    MatchingResultDTO, CanonicalOrderDTO
+)
+from simulation.models import Transaction
+
+logger = logging.getLogger(__name__)
+
+class OrderBookMatchingEngine(IMatchingEngine):
+    """
+    Stateless matching engine for Goods and Labor markets.
+    Implements price-time priority and targeted (brand loyalty) matching.
+    """
+
+    def match(self, state: OrderBookStateDTO, current_tick: int) -> MatchingResultDTO:
+        all_transactions: List[Transaction] = []
+        unfilled_buy_orders: Dict[str, List[CanonicalOrderDTO]] = {}
+        unfilled_sell_orders: Dict[str, List[CanonicalOrderDTO]] = {}
+        market_stats: Dict[str, Any] = {
+            "last_traded_prices": {},
+            "last_trade_ticks": {},
+            "daily_total_volume": {} # item_id -> float
+        }
+
+        # Get all unique item_ids from both buy and sell orders
+        all_item_ids = set(state.buy_orders.keys()) | set(state.sell_orders.keys())
+
+        for item_id in all_item_ids:
+            # Get orders for this item
+            buy_orders = state.buy_orders.get(item_id, [])
+            sell_orders = state.sell_orders.get(item_id, [])
+
+            # Skip if empty on either side
+            if not buy_orders or not sell_orders:
+                unfilled_buy_orders[item_id] = buy_orders
+                unfilled_sell_orders[item_id] = sell_orders
+                continue
+
+            # Execute matching for this item
+            transactions, remaining_buys, remaining_sells, stats = self._match_item(
+                item_id, buy_orders, sell_orders, state.market_id, current_tick
+            )
+
+            all_transactions.extend(transactions)
+            unfilled_buy_orders[item_id] = remaining_buys
+            unfilled_sell_orders[item_id] = remaining_sells
+
+            # Merge stats
+            for k, v in stats.items():
+                if k == "volume":
+                    if item_id not in market_stats["daily_total_volume"]:
+                        market_stats["daily_total_volume"][item_id] = 0.0
+                    market_stats["daily_total_volume"][item_id] += v
+                elif k == "last_price":
+                    market_stats["last_traded_prices"][item_id] = v
+                    market_stats["last_trade_ticks"][item_id] = current_tick
+
+        return MatchingResultDTO(
+            transactions=all_transactions,
+            unfilled_buy_orders=unfilled_buy_orders,
+            unfilled_sell_orders=unfilled_sell_orders,
+            market_stats=market_stats
+        )
+
+    def _match_item(
+        self,
+        item_id: str,
+        buy_orders: List[CanonicalOrderDTO],
+        sell_orders: List[CanonicalOrderDTO],
+        market_id: str,
+        current_tick: int
+    ) -> Tuple[List[Transaction], List[CanonicalOrderDTO], List[CanonicalOrderDTO], Dict[str, Any]]:
+
+        transactions: List[Transaction] = []
+        stats: Dict[str, Any] = {"volume": 0.0}
+
+        # 1. Separate targeted vs general buys
+        targeted_buys = [o for o in buy_orders if o.target_agent_id is not None]
+        general_buys = [o for o in buy_orders if o.target_agent_id is None]
+
+        # Sort general buys by price (desc)
+        general_buys.sort(key=lambda o: o.price_limit, reverse=True)
+
+        # Organize sells for targeted lookup
+        sell_map: Dict[int, List[CanonicalOrderDTO]] = {}
+        for s_order in sell_orders:
+             # Need mutable wrapper or copy to track quantity consumed
+             # Since CanonicalOrderDTO is frozen, we will create new instances or track reduction
+             # To keep it simple, let's convert to a mutable structure locally
+             # But wait, we need to return CanonicalOrderDTOs.
+             # We will track reduced quantities.
+             agent_id = int(s_order.agent_id) if isinstance(s_order.agent_id, (int, float)) else s_order.agent_id
+             # Assuming agent_id is int for firms/households usually.
+             if agent_id not in sell_map:
+                 sell_map[agent_id] = []
+             sell_map[agent_id].append(s_order)
+
+        # Helper to manage mutable state of orders during matching
+        # We'll use a wrapper class locally
+        class MutableOrder:
+            def __init__(self, dto: CanonicalOrderDTO):
+                self.dto = dto
+                self.remaining_qty = dto.quantity
+
+            def to_dto(self) -> CanonicalOrderDTO:
+                return replace(self.dto, quantity=self.remaining_qty)
+
+        # Convert all to mutable
+        mutable_targeted_buys = [MutableOrder(o) for o in targeted_buys]
+        mutable_general_buys = [MutableOrder(o) for o in general_buys]
+
+        mutable_sell_map: Dict[Any, List[MutableOrder]] = {}
+        all_mutable_sells: List[MutableOrder] = []
+
+        for s_list in sell_map.values():
+            s_list.sort(key=lambda o: o.price_limit) # Sort sells by price asc
+            m_list = [MutableOrder(o) for o in s_list]
+            mutable_sell_map[s_list[0].agent_id] = m_list
+            all_mutable_sells.extend(m_list)
+
+        # --- Phase 6: Targeted Matching ---
+
+        remaining_targeted_buys: List[MutableOrder] = []
+
+        for b_wrapper in mutable_targeted_buys:
+            target_id = b_wrapper.dto.target_agent_id
+            target_asks = mutable_sell_map.get(target_id)
+
+            if target_asks:
+                # Iterate through seller's asks
+                # Note: target_asks is already sorted by price ASC
+                for s_wrapper in target_asks:
+                    if b_wrapper.remaining_qty <= 1e-9: break
+                    if s_wrapper.remaining_qty <= 1e-9: continue
+
+                    # Price Check
+                    if b_wrapper.dto.price_limit >= s_wrapper.dto.price_limit:
+                        trade_price = s_wrapper.dto.price_limit # Pay Ask Price for Loyalty
+                        trade_qty = min(b_wrapper.remaining_qty, s_wrapper.remaining_qty)
+
+                        tx = Transaction(
+                             item_id=item_id,
+                             quantity=trade_qty,
+                             price=trade_price,
+                             buyer_id=b_wrapper.dto.agent_id,
+                             seller_id=s_wrapper.dto.agent_id,
+                             market_id=market_id,
+                             transaction_type="labor" if "labor" in market_id else ("housing" if "housing" in market_id else "goods"),
+                             time=current_tick,
+                             quality=s_wrapper.dto.brand_info.get("quality", 1.0) if s_wrapper.dto.brand_info else 1.0
+                        )
+                        transactions.append(tx)
+                        stats["last_price"] = trade_price
+                        stats["volume"] += trade_qty
+
+                        b_wrapper.remaining_qty -= trade_qty
+                        s_wrapper.remaining_qty -= trade_qty
+
+            if b_wrapper.remaining_qty > 1e-9:
+                remaining_targeted_buys.append(b_wrapper)
+
+        # Fallback: Add remaining targeted buys to general pool
+        if remaining_targeted_buys:
+            mutable_general_buys.extend(remaining_targeted_buys)
+            # Re-sort general buys by price desc to maintain priority
+            mutable_general_buys.sort(key=lambda o: o.dto.price_limit, reverse=True)
+
+        # Collect all remaining sells for general matching and sort
+        active_sells = [s for s in all_mutable_sells if s.remaining_qty > 1e-9]
+        active_sells.sort(key=lambda o: o.dto.price_limit)
+
+        # --- General Matching ---
+        idx_b = 0
+        idx_s = 0
+
+        while idx_b < len(mutable_general_buys) and idx_s < len(active_sells):
+            b_wrapper = mutable_general_buys[idx_b]
+            s_wrapper = active_sells[idx_s]
+
+            if b_wrapper.remaining_qty <= 1e-9:
+                idx_b += 1
+                continue
+            if s_wrapper.remaining_qty <= 1e-9:
+                idx_s += 1
+                continue
+
+            if b_wrapper.dto.price_limit >= s_wrapper.dto.price_limit:
+                # Labor/Housing Market Specific Pricing Logic
+                if market_id == "labor" or market_id == "research_labor":
+                    trade_price = b_wrapper.dto.price_limit
+                else:
+                    trade_price = (b_wrapper.dto.price_limit + s_wrapper.dto.price_limit) / 2
+
+                trade_qty = min(b_wrapper.remaining_qty, s_wrapper.remaining_qty)
+
+                tx = Transaction(
+                     item_id=item_id,
+                     quantity=trade_qty,
+                     price=trade_price,
+                     buyer_id=b_wrapper.dto.agent_id,
+                     seller_id=s_wrapper.dto.agent_id,
+                     market_id=market_id,
+                     transaction_type="labor" if "labor" in market_id else ("housing" if "housing" in market_id else "goods"),
+                     time=current_tick,
+                     quality=s_wrapper.dto.brand_info.get("quality", 1.0) if s_wrapper.dto.brand_info else 1.0
+                )
+                transactions.append(tx)
+                stats["last_price"] = trade_price
+                stats["volume"] += trade_qty
+
+                b_wrapper.remaining_qty -= trade_qty
+                s_wrapper.remaining_qty -= trade_qty
+            else:
+                 # Prices don't cross anymore (lists are sorted)
+                 break
+
+        # Convert remaining wrappers back to DTOs
+        final_buys = [b.to_dto() for b in mutable_general_buys if b.remaining_qty > 1e-9]
+        final_buys.sort(key=lambda o: o.price_limit, reverse=True)
+
+        final_sells = [s.to_dto() for s in active_sells if s.remaining_qty > 1e-9]
+        final_sells.sort(key=lambda o: o.price_limit)
+
+        return transactions, final_buys, final_sells, stats
+
+
+class StockMatchingEngine(IMatchingEngine):
+    """
+    Stateless matching engine for Stock Market.
+    Matches Buy and Sell orders for each firm.
+    """
+
+    def match(self, state: StockMarketStateDTO, current_tick: int) -> MatchingResultDTO:
+        all_transactions: List[Transaction] = []
+        unfilled_buy_orders: Dict[str, List[CanonicalOrderDTO]] = {}
+        unfilled_sell_orders: Dict[str, List[CanonicalOrderDTO]] = {}
+        market_stats: Dict[str, Any] = {
+            "last_prices": {},
+            "daily_volumes": {},
+            "daily_high": {},
+            "daily_low": {}
+        }
+
+        # Identify all firms
+        all_firm_ids = set(state.buy_orders.keys()) | set(state.sell_orders.keys())
+
+        for firm_id in all_firm_ids:
+            # Map firm_id back to str key if needed for output dict,
+            # but StockMarketStateDTO uses int keys for input.
+            # MatchingResultDTO uses str keys for generic compatibility.
+            # We will use "stock_{firm_id}" or just str(firm_id).
+            # Consistent with CanonicalOrderDTO.item_id logic: "stock_{firm_id}"
+
+            buy_orders = state.buy_orders.get(firm_id, [])
+            sell_orders = state.sell_orders.get(firm_id, [])
+
+            if not buy_orders or not sell_orders:
+                unfilled_buy_orders[str(firm_id)] = buy_orders
+                unfilled_sell_orders[str(firm_id)] = sell_orders
+                continue
+
+            transactions, remaining_buys, remaining_sells, stats = self._match_firm_stock(
+                firm_id, buy_orders, sell_orders, state.market_id, current_tick
+            )
+
+            all_transactions.extend(transactions)
+            unfilled_buy_orders[str(firm_id)] = remaining_buys
+            unfilled_sell_orders[str(firm_id)] = remaining_sells
+
+            # Merge stats
+            if "last_price" in stats:
+                market_stats["last_prices"][firm_id] = stats["last_price"]
+                market_stats["daily_volumes"][firm_id] = stats["volume"]
+                market_stats["daily_high"][firm_id] = stats["high"]
+                market_stats["daily_low"][firm_id] = stats["low"]
+
+        return MatchingResultDTO(
+            transactions=all_transactions,
+            unfilled_buy_orders=unfilled_buy_orders,
+            unfilled_sell_orders=unfilled_sell_orders,
+            market_stats=market_stats
+        )
+
+    def _match_firm_stock(
+        self,
+        firm_id: int,
+        buy_orders: List[CanonicalOrderDTO],
+        sell_orders: List[CanonicalOrderDTO],
+        market_id: str,
+        current_tick: int
+    ) -> Tuple[List[Transaction], List[CanonicalOrderDTO], List[CanonicalOrderDTO], Dict[str, Any]]:
+
+        transactions: List[Transaction] = []
+        stats: Dict[str, Any] = {"volume": 0.0}
+
+        # Sort Orders
+        # Buy: Price Desc
+        buy_orders.sort(key=lambda o: o.price_limit, reverse=True)
+        # Sell: Price Asc
+        sell_orders.sort(key=lambda o: o.price_limit)
+
+        # Mutable wrappers
+        class MutableOrder:
+            def __init__(self, dto: CanonicalOrderDTO):
+                self.dto = dto
+                self.remaining_qty = dto.quantity
+
+            def to_dto(self) -> CanonicalOrderDTO:
+                return replace(self.dto, quantity=self.remaining_qty)
+
+        m_buys = [MutableOrder(o) for o in buy_orders]
+        m_sells = [MutableOrder(o) for o in sell_orders]
+
+        idx_b = 0
+        idx_s = 0
+
+        last_price = None
+        high = -float('inf')
+        low = float('inf')
+
+        while idx_b < len(m_buys) and idx_s < len(m_sells):
+            b_order = m_buys[idx_b]
+            s_order = m_sells[idx_s]
+
+            if b_order.remaining_qty <= 1e-9:
+                idx_b += 1
+                continue
+            if s_order.remaining_qty <= 1e-9:
+                idx_s += 1
+                continue
+
+            if b_order.dto.price_limit >= s_order.dto.price_limit:
+                trade_price = (b_order.dto.price_limit + s_order.dto.price_limit) / 2
+                trade_qty = min(b_order.remaining_qty, s_order.remaining_qty)
+
+                # Validation check
+                if b_order.dto.agent_id is None or s_order.dto.agent_id is None:
+                    # Skip invalid order
+                    if b_order.dto.agent_id is None: idx_b += 1
+                    if s_order.dto.agent_id is None: idx_s += 1
+                    continue
+
+                tx = Transaction(
+                    buyer_id=b_order.dto.agent_id,
+                    seller_id=s_order.dto.agent_id,
+                    item_id=f"stock_{firm_id}",
+                    quantity=trade_qty,
+                    price=trade_price,
+                    market_id=market_id,
+                    transaction_type="stock",
+                    time=current_tick,
+                )
+                transactions.append(tx)
+
+                stats["volume"] += trade_qty
+                last_price = trade_price
+                high = max(high, trade_price)
+                low = min(low, trade_price)
+
+                b_order.remaining_qty -= trade_qty
+                s_order.remaining_qty -= trade_qty
+
+            else:
+                break
+
+        final_buys = [o.to_dto() for o in m_buys if o.remaining_qty > 1e-9]
+        final_sells = [o.to_dto() for o in m_sells if o.remaining_qty > 1e-9]
+
+        if last_price is not None:
+            stats["last_price"] = last_price
+            stats["high"] = high
+            stats["low"] = low
+
+        return transactions, final_buys, final_sells, stats
diff --git a/simulation/markets/order_book_market.py b/simulation/markets/order_book_market.py
index 071cada2..1fb6ab96 100644
--- a/simulation/markets/order_book_market.py
+++ b/simulation/markets/order_book_market.py
@@ -6,7 +6,8 @@ from dataclasses import dataclass
 
 from simulation.models import Order, Transaction
 from simulation.core_markets import Market
-from modules.market.api import CanonicalOrderDTO
+from modules.market.api import CanonicalOrderDTO, OrderBookStateDTO
+from simulation.markets.matching_engine import OrderBookMatchingEngine
 
 logger = logging.getLogger(__name__)
 
@@ -90,6 +91,9 @@ class OrderBookMarket(Market):
         # Store last 20 trade prices per item for volatility calculation
         self.price_history: Dict[str, deque] = {}
 
+        # Phase 10: Stateless Matching Engine
+        self.matching_engine = OrderBookMatchingEngine()
+
         self.logger.info(
             f"OrderBookMarket {self.id} initialized.",
             extra={"tick": 0, "market_id": self.id, "tags": ["init", "market"]},
@@ -254,10 +258,49 @@ class OrderBookMarket(Market):
             },
         )
 
-        for item_id in all_item_ids:
-            item_transactions = self._match_orders_for_item(item_id, current_time)
-            all_transactions.extend(item_transactions)
-            self.matched_transactions.extend(item_transactions)
+        # 1. Prepare State DTO
+        buy_orders_dto = {
+            item_id: [order.to_dto(self.id) for order in orders]
+            for item_id, orders in self._buy_orders.items()
+        }
+        sell_orders_dto = {
+            item_id: [order.to_dto(self.id) for order in orders]
+            for item_id, orders in self._sell_orders.items()
+        }
+
+        state = OrderBookStateDTO(
+            buy_orders=buy_orders_dto,
+            sell_orders=sell_orders_dto,
+            market_id=self.id
+        )
+
+        # 2. Execute Matching via Engine
+        result = self.matching_engine.match(state, current_time)
+
+        # 3. Apply Results
+        all_transactions = result.transactions
+        self.matched_transactions.extend(all_transactions)
+
+        # Update Order Books (Replace with unfilled)
+        self._buy_orders = {
+            item_id: [MarketOrder.from_dto(dto) for dto in dtos]
+            for item_id, dtos in result.unfilled_buy_orders.items()
+        }
+        self._sell_orders = {
+            item_id: [MarketOrder.from_dto(dto) for dto in dtos]
+            for item_id, dtos in result.unfilled_sell_orders.items()
+        }
+
+        # Update Market Stats
+        for item_id, price in result.market_stats.get("last_traded_prices", {}).items():
+            self.last_traded_prices[item_id] = price
+            self._update_price_history(item_id, price)
+
+        for item_id, tick in result.market_stats.get("last_trade_ticks", {}).items():
+            self.last_trade_ticks[item_id] = tick
+
+        for item_id, volume in result.market_stats.get("daily_total_volume", {}).items():
+             self.daily_total_volume[item_id] = self.daily_total_volume.get(item_id, 0.0) + volume
 
         return all_transactions
 
@@ -283,174 +326,6 @@ class OrderBookMarket(Market):
         else:
             target_order_book[order.item_id].sort(key=lambda o: o.price)
 
-    def _match_orders_for_item(
-        self, item_id: str, current_tick: int
-    ) -> List[Transaction]:
-        """주어진 아이템에 대해 매수/매도 주문을 매칭하고 거래를 체결합니다.
-        Phase 6: Targeted Orders (Brand Economy) are processed first.
-        """
-        transactions = []
-        log_extra = {
-            "tick": current_tick,
-            "market_id": self.id,
-            "item_id": item_id,
-        }
-
-        buy_orders_list = self._buy_orders.get(item_id, [])
-        sell_orders_list = self._sell_orders.get(item_id, [])
-
-        if not buy_orders_list or not sell_orders_list:
-            return transactions
-
-        # --- Phase 6: Targeted Matching ---
-        # 1. Separate targeted vs general buys
-        targeted_buys = []
-        general_buys = []
-        for order in buy_orders_list:
-            if order.target_agent_id is not None:
-                targeted_buys.append(order)
-            else:
-                general_buys.append(order)
-        
-        # 2. Process Targeted Buys
-        # Dictionary of AgentID -> List[MarketOrder]
-        sell_map: Dict[int, List[MarketOrder]] = {}
-        for s_order in sell_orders_list:
-             if s_order.agent_id not in sell_map:
-                 sell_map[s_order.agent_id] = []
-             sell_map[s_order.agent_id].append(s_order)
-             
-        remaining_targeted_buys = []
-        
-        for b_order in targeted_buys:
-             target_id = b_order.target_agent_id
-             # Check if target seller has stock
-             target_asks = sell_map.get(target_id)
-             
-             if target_asks and target_asks[0].quantity > 0:
-                 s_order = target_asks[0] # Pick best price ask from this seller (assuming sorted)
-                 
-                 # Price Check: Does buyer accept seller's price?
-                 if b_order.price >= s_order.price:
-                     trade_price = s_order.price # Brand Loyalty -> Pay Ask Price
-                     trade_quantity = min(b_order.quantity, s_order.quantity)
-                     
-                     transaction = Transaction(
-                         item_id=item_id,
-                         quantity=trade_quantity,
-                         price=trade_price,
-                         buyer_id=b_order.agent_id,
-                         seller_id=s_order.agent_id,
-                         market_id=self.id,
-                         transaction_type="labor" if "labor" in self.id else ("housing" if "housing" in self.id else "goods"),
-                         time=current_tick,
-                         quality=s_order.brand_info.get("quality", 1.0) if s_order.brand_info else 1.0
-                     )
-                     self.last_traded_prices[item_id] = trade_price
-                     # WO-136: Update Price History
-                     self._update_price_history(item_id, trade_price)
-                     transactions.append(transaction)
-                     
-                     self.logger.info(
-                         f"MATCHED_TARGETED | {trade_quantity:.2f} of {item_id} at {trade_price:.2f}. "
-                         f"Buyer {b_order.agent_id} -> Seller {s_order.agent_id} (Targeted)",
-                         extra={**log_extra, "buyer_id":b_order.agent_id, "seller_id":s_order.agent_id, "match_type": "targeted"}
-                     )
-                     
-                     b_order.quantity -= trade_quantity
-                     s_order.quantity -= trade_quantity
-                     
-                     if s_order.quantity <= 0.001:
-                         target_asks.pop(0) # Remove exhausted ask
-                         
-                 else:
-                     # Price mismatch (Buyer willing to pay X, Seller wants Y, X < Y)
-                     pass
-             else:
-                 # Target sold out or not present
-                 pass
-             
-             if b_order.quantity > 0.001:
-                 remaining_targeted_buys.append(b_order)
-
-        # Fallback: Add remaining targeted buys to general pool
-        if remaining_targeted_buys:
-            general_buys.extend(remaining_targeted_buys)
-            # Re-sort general buys by price desc to maintain priority
-            general_buys.sort(key=lambda o: o.price, reverse=True)
-
-        # Re-flatten sell map to list for general matching
-        remaining_sells = []
-        for s_list in sell_map.values():
-            remaining_sells.extend(s_list)
-        # Sort by price (asc) for general matching
-        remaining_sells.sort(key=lambda o: o.price)
-        
-        # General Matching Loop
-        idx_b = 0
-        idx_s = 0
-        
-        while idx_b < len(general_buys) and idx_s < len(remaining_sells):
-            b_order = general_buys[idx_b]
-            s_order = remaining_sells[idx_s]
-            
-            if b_order.quantity <= 0.001:
-                idx_b += 1
-                continue
-            if s_order.quantity <= 0.001:
-                idx_s += 1
-                continue
-                
-            if b_order.price >= s_order.price:
-                # Labor Market Logic
-                if self.id == "labor" or self.id == "research_labor":
-                    trade_price = b_order.price
-                else:
-                    trade_price = (b_order.price + s_order.price) / 2
-                
-                trade_quantity = min(b_order.quantity, s_order.quantity)
-                
-                transaction = Transaction(
-                    item_id=item_id,
-                    quantity=trade_quantity,
-                    price=trade_price,
-                    buyer_id=b_order.agent_id,
-                    seller_id=s_order.agent_id,
-                    market_id=self.id,
-                    transaction_type="labor" if "labor" in self.id else ("housing" if "housing" in self.id else "goods"),
-                    time=current_tick,
-                    quality=s_order.brand_info.get("quality", 1.0) if s_order.brand_info else 1.0
-                )
-                self.last_traded_prices[item_id] = trade_price
-                self.last_trade_ticks[item_id] = current_tick
-                # WO-136: Update Price History
-                self._update_price_history(item_id, trade_price)
-                transactions.append(transaction)
-                
-                self.logger.info(
-                    f"MATCHED_GENERAL | {trade_quantity:.2f} of {item_id} at {trade_price:.2f}. "
-                    f"Buyer {b_order.agent_id} -> Seller {s_order.agent_id}",
-                    extra={**log_extra, "buyer_id":b_order.agent_id, "seller_id":s_order.agent_id, "match_type": "general"}
-                )
-                
-                b_order.quantity -= trade_quantity
-                s_order.quantity -= trade_quantity
-            else:
-                 # Prices don't cross anymore (lists are sorted)
-                 break
-        
-        # Re-save lists to cleanup empty orders
-        new_buy_list = [o for o in (remaining_targeted_buys + general_buys) if o.quantity > 0.001]
-        new_buy_list.sort(key=lambda o: o.price, reverse=True) # Maintain sorted invariant
-        
-        new_sell_list = [o for o in remaining_sells if o.quantity > 0.001]
-        new_sell_list.sort(key=lambda o: o.price)
-        
-        self._buy_orders[item_id] = new_buy_list
-        self._sell_orders[item_id] = new_sell_list
-
-        return transactions
-
     def get_best_ask(self, item_id: str) -> float | None:
         """주어진 아이템의 최저 판매 가격(best ask)을 반환합니다."""
         if item_id in self._sell_orders and self._sell_orders[item_id]:
diff --git a/simulation/markets/stock_market.py b/simulation/markets/stock_market.py
index f4a7c020..43d9a1c8 100644
--- a/simulation/markets/stock_market.py
+++ b/simulation/markets/stock_market.py
@@ -12,8 +12,9 @@ from dataclasses import dataclass, replace
 
 from simulation.models import Transaction, Order
 from simulation.core_markets import Market
-from modules.market.api import CanonicalOrderDTO
+from modules.market.api import CanonicalOrderDTO, StockMarketStateDTO
 from modules.finance.api import IShareholderRegistry, IShareholderView
+from simulation.markets.matching_engine import StockMatchingEngine
 
 logger = logging.getLogger(__name__)
 
@@ -55,6 +56,9 @@ class StockMarket(Market):
         self.daily_high: Dict[int, float] = {}       # 일일 최고가
         self.daily_low: Dict[int, float] = {}        # 일일 최저가
 
+        # Phase 10: Stateless Matching Engine
+        self.matching_engine = StockMatchingEngine()
+
     def update_shareholder(self, agent_id: int, firm_id: int, quantity: float) -> None:
         """
         주주 명부를 갱신합니다. (보유량 설정)
@@ -198,112 +202,72 @@ class StockMarket(Market):
     def match_orders(self, tick: int) -> List[Transaction]:
         """
         모든 기업의 주식 주문을 매칭하여 거래를 성사시킵니다.
-        
-        Args:
-            tick: 현재 시뮬레이션 틱
-            
-        Returns:
-            성사된 주식 거래 목록
+        Delegates to Stateless Matching Engine.
         """
-        all_transactions: List[Transaction] = []
-        
-        # 모든 기업에 대해 매칭 수행
-        all_firm_ids = set(self.buy_orders.keys()) | set(self.sell_orders.keys())
         
-        for firm_id in all_firm_ids:
-            transactions = self._match_orders_for_firm(firm_id, tick)
-            all_transactions.extend(transactions)
-        
-        return all_transactions
+        # 1. Construct State DTO
+        def to_dto_with_metadata(managed: ManagedOrder) -> CanonicalOrderDTO:
+            dto = replace(managed.order, quantity=managed.remaining_quantity)
+            new_metadata = dto.metadata.copy() if dto.metadata else {}
+            new_metadata['created_tick'] = managed.created_tick
+            return replace(dto, metadata=new_metadata)
 
-    def _match_orders_for_firm(self, firm_id: int, tick: int) -> List[Transaction]:
-        """특정 기업의 주식 주문을 매칭합니다."""
-        transactions: List[Transaction] = []
+        buy_orders_dto = {
+            firm_id: [to_dto_with_metadata(managed) for managed in orders]
+            for firm_id, orders in self.buy_orders.items()
+        }
+        sell_orders_dto = {
+            firm_id: [to_dto_with_metadata(managed) for managed in orders]
+            for firm_id, orders in self.sell_orders.items()
+        }
         
-        buy_orders = self.buy_orders.get(firm_id, [])
-        sell_orders = self.sell_orders.get(firm_id, [])
+        state = StockMarketStateDTO(
+            buy_orders=buy_orders_dto,
+            sell_orders=sell_orders_dto,
+            market_id=self.id
+        )
         
-        while buy_orders and sell_orders:
-            best_buy_managed = buy_orders[0]
-            best_sell_managed = sell_orders[0]
+        # 2. Execute Matching via Engine
+        result = self.matching_engine.match(state, tick)
 
-            best_buy_dto = best_buy_managed.order
-            best_sell_dto = best_sell_managed.order
+        # 3. Apply Results
+        # Update Stats
+        for firm_id_str, price in result.market_stats.get("last_prices", {}).items():
+            firm_id = int(firm_id_str)
+            self.last_prices[firm_id] = price
             
-            # 매수가 >= 매도가 이면 거래 성립
-            if best_buy_dto.price_limit >= best_sell_dto.price_limit:
-                # 거래 가격: 두 호가의 평균
-                trade_price = (best_buy_dto.price_limit + best_sell_dto.price_limit) / 2
-                trade_quantity = min(best_buy_managed.remaining_quantity, best_sell_managed.remaining_quantity)
-
-                # Validation (Tech Debt Fix)
-                if best_buy_dto.agent_id is None or best_sell_dto.agent_id is None:
-                    self.logger.critical(
-                        f"STOCK_MATCH_FATAL | NULL ID in matched order! "
-                        f"BuyerID: {best_buy_dto.agent_id}, SellerID: {best_sell_dto.agent_id}. Skipping match.",
-                        extra={"tick": tick, "firm_id": firm_id}
-                    )
-                    # Skip this match and possibly pop the problematic order?
-                    # For safety, we just break or continue.
-                    # If we don't pop, we infinite loop.
-                    # We should pop the invalid one.
-                    if best_buy_dto.agent_id is None:
-                        buy_orders.pop(0)
-                    if best_sell_dto.agent_id is None:
-                        sell_orders.pop(0)
-                    continue
-                
-                # 거래 생성
-                transaction = Transaction(
-                    buyer_id=best_buy_dto.agent_id,
-                    seller_id=best_sell_dto.agent_id,
-                    item_id=f"stock_{firm_id}",
-                    quantity=trade_quantity,
-                    price=trade_price,
-                    market_id=self.id,
-                    transaction_type="stock",
-                    time=tick,
-                )
-                transactions.append(transaction)
-                
-                # 가격 및 거래량 업데이트
-                self.last_prices[firm_id] = trade_price
-                self.daily_volumes[firm_id] = self.daily_volumes.get(firm_id, 0) + trade_quantity
-                
-                # 일일 고저가 업데이트
-                if firm_id not in self.daily_high or trade_price > self.daily_high[firm_id]:
-                    self.daily_high[firm_id] = trade_price
-                if firm_id not in self.daily_low or trade_price < self.daily_low[firm_id]:
-                    self.daily_low[firm_id] = trade_price
-                
-                self.logger.info(
-                    f"Stock trade: {trade_quantity:.1f} shares of firm {firm_id} "
-                    f"at {trade_price:.2f} (buyer: {best_buy_dto.agent_id}, seller: {best_sell_dto.agent_id})",
-                    extra={
-                        "tick": tick,
-                        "firm_id": firm_id,
-                        "quantity": trade_quantity,
-                        "price": trade_price,
-                        "buyer_id": best_buy_dto.agent_id,
-                        "seller_id": best_sell_dto.agent_id,
-                        "tags": ["stock", "trade"]
-                    }
-                )
-                
-                # 주문 수량 조정 (ManagedOrder 내부 상태 변경)
-                best_buy_managed.remaining_quantity -= trade_quantity
-                best_sell_managed.remaining_quantity -= trade_quantity
-                
-                # 완료된 주문 제거
-                if best_buy_managed.remaining_quantity <= 0:
-                    buy_orders.pop(0)
-                if best_sell_managed.remaining_quantity <= 0:
-                    sell_orders.pop(0)
-            else:
-                # 더 이상 매칭 가능한 주문 없음
-                break
+        for firm_id_str, volume in result.market_stats.get("daily_volumes", {}).items():
+            firm_id = int(firm_id_str)
+            self.daily_volumes[firm_id] = self.daily_volumes.get(firm_id, 0.0) + volume
+
+        for firm_id_str, high in result.market_stats.get("daily_high", {}).items():
+            firm_id = int(firm_id_str)
+            if firm_id not in self.daily_high or high > self.daily_high[firm_id]:
+                self.daily_high[firm_id] = high
+
+        for firm_id_str, low in result.market_stats.get("daily_low", {}).items():
+            firm_id = int(firm_id_str)
+            if firm_id not in self.daily_low or low < self.daily_low[firm_id]:
+                self.daily_low[firm_id] = low
+
+        # Reconstruct ManagedOrders
+        def from_dto(dto: CanonicalOrderDTO) -> ManagedOrder:
+            created_tick = dto.metadata.get('created_tick', tick) if dto.metadata else tick
+            # Remove created_tick from metadata to keep DTO clean? Or keep it?
+            # Keeping it doesn't hurt.
+            return ManagedOrder(order=dto, remaining_quantity=dto.quantity, created_tick=created_tick)
+
+        self.buy_orders = defaultdict(list)
+        for firm_id_str, dtos in result.unfilled_buy_orders.items():
+            firm_id = int(firm_id_str)
+            self.buy_orders[firm_id] = [from_dto(dto) for dto in dtos]
+
+        self.sell_orders = defaultdict(list)
+        for firm_id_str, dtos in result.unfilled_sell_orders.items():
+            firm_id = int(firm_id_str)
+            self.sell_orders[firm_id] = [from_dto(dto) for dto in dtos]
         
-        return transactions
+        return result.transactions
 
     def clear_expired_orders(self, current_tick: int) -> int:
         """
diff --git a/simulation/orchestration/phases/production.py b/simulation/orchestration/phases/production.py
index 32b4d079..020dad39 100644
--- a/simulation/orchestration/phases/production.py
+++ b/simulation/orchestration/phases/production.py
@@ -41,6 +41,10 @@ class Phase_Production(IPhaseStrategy):
         # 3. Trigger Firm Production
         for firm in state.firms:
             if firm.is_active:
-                firm.produce(state.time, technology_manager=self.world_state.technology_manager)
+                firm.produce(
+                    state.time,
+                    technology_manager=self.world_state.technology_manager,
+                    effects_queue=state.effects_queue
+                )
 
         return state
diff --git a/tests/unit/test_markets_v2.py b/tests/unit/test_markets_v2.py
index 98eb5cd1..3643b4eb 100644
--- a/tests/unit/test_markets_v2.py
+++ b/tests/unit/test_markets_v2.py
@@ -29,10 +29,10 @@ class TestPlaceOrderToBook:
         """단일 매수 주문이 오더북에 올바르게 추가되는지 테스트합니다."""
         order = Order(
             agent_id=1,
-            order_type="BUY",
+            side="BUY",
             item_id="food",
             quantity=10,
-            price=100,
+            price_limit=100,
             market_id="test_market",
         )
         market.place_order(order, 1)
@@ -47,26 +47,26 @@ class TestPlaceOrderToBook:
         """여러 매수 주문이 가격 내림차순으로 정렬되는지 테스트합니다."""
         order1 = Order(
             agent_id=1,
-            order_type="BUY",
+            side="BUY",
             item_id="food",
             quantity=10,
-            price=100,
+            price_limit=100,
             market_id="test_market",
         )
         order2 = Order(
             agent_id=2,
-            order_type="BUY",
+            side="BUY",
             item_id="food",
             quantity=5,
-            price=110,
+            price_limit=110,
             market_id="test_market",
         )
         order3 = Order(
             agent_id=3,
-            order_type="BUY",
+            side="BUY",
             item_id="food",
             quantity=8,
-            price=105,
+            price_limit=105,
             market_id="test_market",
         )
 
@@ -82,26 +82,26 @@ class TestPlaceOrderToBook:
         """여러 매도 주문이 가격 오름차순으로 정렬되는지 테스트합니다."""
         order1 = Order(
             agent_id=1,
-            order_type="SELL",
+            side="SELL",
             item_id="food",
             quantity=10,
-            price=100,
+            price_limit=100,
             market_id="test_market",
         )
         order2 = Order(
             agent_id=2,
-            order_type="SELL",
+            side="SELL",
             item_id="food",
             quantity=5,
-            price=90,
+            price_limit=90,
             market_id="test_market",
         )
         order3 = Order(
             agent_id=3,
-            order_type="SELL",
+            side="SELL",
             item_id="food",
             quantity=8,
-            price=95,
+            price_limit=95,
             market_id="test_market",
         )
 
@@ -118,26 +118,26 @@ class TestPlaceOrderToBook:
         # 이 테스트는 현재 bisect 구현 상 통과함 (stable sort와 유사하게 동작)
         order1 = Order(
             agent_id=1,
-            order_type="BUY",
+            side="BUY",
             item_id="food",
             quantity=10,
-            price=100,
+            price_limit=100,
             market_id="test_market",
         )
         order2 = Order(
             agent_id=2,
-            order_type="BUY",
+            side="BUY",
             item_id="food",
             quantity=5,
-            price=110,
+            price_limit=110,
             market_id="test_market",
         )
         order3 = Order(
             agent_id=3,
-            order_type="BUY",
+            side="BUY",
             item_id="food",
             quantity=8,
-            price=100,
+            price_limit=100,
             market_id="test_market",
         )  # order1과 가격 동일
 
@@ -158,20 +158,20 @@ class TestOrderMatching:
         # Arrange: 매도 110, 매수 100 (가격 불일치)
         sell_order = Order(
             agent_id=1,
-            order_type="SELL",
+            side="SELL",
             item_id="food",
             quantity=10,
-            price=110,
+            price_limit=110,
             market_id="test_market",
         )
         market.place_order(sell_order, current_time=1)
 
         buy_order = Order(
             agent_id=2,
-            order_type="BUY",
+            side="BUY",
             item_id="food",
             quantity=10,
-            price=100,
+            price_limit=100,
             market_id="test_market",
         )
         market.place_order(buy_order, current_time=2)
@@ -194,20 +194,20 @@ class TestOrderMatching:
         """매수 주문 1개와 매도 주문 1개가 완전히 체결되는 경우를 테스트합니다."""
         sell_order = Order(
             agent_id=2,
-            order_type="SELL",
+            side="SELL",
             item_id="food",
             quantity=10,
-            price=100,
+            price_limit=100,
             market_id="test_market",
         )
         market.place_order(sell_order, current_time=1)
 
         buy_order = Order(
             agent_id=1,
-            order_type="BUY",
+            side="BUY",
             item_id="food",
             quantity=10,
-            price=105,
+            price_limit=105,
             market_id="test_market",
         )
         market.place_order(buy_order, current_time=2)
@@ -229,20 +229,20 @@ class TestOrderMatching:
         """새로운 매수 주문이 부분 체결된 후 나머지가 오더북에 등록되는 경우를 테스트합니다."""
         sell_order = Order(
             agent_id=2,
-            order_type="SELL",
+            side="SELL",
             item_id="food",
             quantity=5,
-            price=100,
+            price_limit=100,
             market_id="test_market",
         )
         market.place_order(sell_order, current_time=1)
 
         buy_order = Order(
             agent_id=1,
-            order_type="BUY",
+            side="BUY",
             item_id="food",
             quantity=10,
-            price=105,
+            price_limit=105,
             market_id="test_market",
         )
         market.place_order(buy_order, current_time=2)
@@ -265,18 +265,18 @@ class TestOrderMatching:
         """새로운 큰 주문 하나가 여러 개의 작은 주문과 체결되는 경우를 테스트합니다."""
         sell1 = Order(
             agent_id=2,
-            order_type="SELL",
+            side="SELL",
             item_id="food",
             quantity=5,
-            price=98,
+            price_limit=98,
             market_id="test_market",
         )
         sell2 = Order(
             agent_id=3,
-            order_type="SELL",
+            side="SELL",
             item_id="food",
             quantity=5,
-            price=100,
+            price_limit=100,
             market_id="test_market",
         )
         market.place_order(sell1, current_time=1)
@@ -284,10 +284,10 @@ class TestOrderMatching:
 
         buy_order = Order(
             agent_id=1,
-            order_type="BUY",
+            side="BUY",
             item_id="food",
             quantity=12,
-            price=105,
+            price_limit=105,
             market_id="test_market",
         )
         market.place_order(buy_order, current_time=3)
