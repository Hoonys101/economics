diff --git a/communications/insights/TD-205_Transaction_Engine.md b/communications/insights/TD-205_Transaction_Engine.md
new file mode 100644
index 00000000..319afc0a
--- /dev/null
+++ b/communications/insights/TD-205_Transaction_Engine.md
@@ -0,0 +1,33 @@
+# Mission TD-205: Transaction Engine Implementation Insights
+
+## Overview
+Implemented the `TransactionEngine` with strict SRP decoupling as requested. The engine orchestrates `TransactionValidator`, `TransactionExecutor`, and `TransactionLedger` to handle financial transactions.
+
+## Technical Debt & Insights
+
+### 1. Wallet Atomicity (Critical)
+The current `IWallet` interface supports atomic operations on a *single* wallet, but not across *two* wallets.
+The `TransactionExecutor` implements transfers as:
+```python
+source_wallet.subtract(amount)
+dest_wallet.add(amount)
+```
+If `dest_wallet.add()` raises an exception (unlikely for addition, but possible), the source wallet has already been debited, leading to money destruction.
+**Mitigation**: In a database-backed system, this would be wrapped in a transaction. For this in-memory simulation, we rely on the stability of `wallet.add`. A rollback mechanism could be implemented in `TransactionExecutor`'s except block.
+
+### 2. ID Type Mismatch
+- `TransactionDTO` uses `str` for `source_account_id` and `destination_account_id`.
+- `BaseAgent` and `IAgentRegistry` primarily use `int` for agent IDs.
+- `RegistryAccountAccessor` implements a heuristic to convert numeric strings to integers. This works for now but is fragile if ID schemas change.
+**Recommendation**: Standardize Agent IDs to strings system-wide or enforce strictly typed IDs in DTOs.
+
+### 3. Ledger Persistence
+`SimpleTransactionLedger` currently writes to the python `logging` system. This is ephemeral.
+**Recommendation**: Implement a `FileTransactionLedger` or `SQLiteTransactionLedger` to persist transaction history for post-simulation auditing.
+
+### 4. Adoption Strategy (High Impact)
+The system currently relies on `BaseAgent.deposit()` and `BaseAgent.withdraw()` which wrap `Wallet` methods directly. These bypass the `TransactionEngine` and its validation/logging.
+**Refactoring Required**: A project-wide refactor is needed to replace direct wallet manipulation with `TransactionEngine.process_transaction()`. This is a significant task (TD-XXX).
+
+### 5. Dependency Injection Success
+By defining `IAccountAccessor`, we successfully avoided circular dependencies between `finance.transaction` and `simulation.agents`. The `RegistryAccountAccessor` acts as the bridge (Adapter pattern) in the composition root, keeping the core logic pure.
diff --git a/modules/finance/transaction/adapter.py b/modules/finance/transaction/adapter.py
new file mode 100644
index 00000000..4900a2fd
--- /dev/null
+++ b/modules/finance/transaction/adapter.py
@@ -0,0 +1,39 @@
+from typing import Any
+from modules.finance.transaction.api import IAccountAccessor, InvalidAccountError
+from modules.finance.wallet.api import IWallet
+from modules.system.api import IAgentRegistry
+
+class RegistryAccountAccessor(IAccountAccessor):
+    def __init__(self, registry: IAgentRegistry):
+        self.registry = registry
+
+    def _get_agent(self, account_id: str) -> Any:
+        # account_id in transaction is str, but agent id can be int.
+        # We need to handle this conversion if registry expects int.
+        # Agent IDs are often ints.
+
+        agent_id: Any = account_id
+        if isinstance(account_id, str) and account_id.isdigit():
+             agent_id = int(account_id)
+
+        agent = self.registry.get_agent(agent_id)
+        if agent is None:
+            # Try original string if conversion happened
+            if agent_id != account_id:
+                agent = self.registry.get_agent(account_id)
+
+        return agent
+
+    def get_wallet(self, account_id: str) -> IWallet:
+        agent = self._get_agent(account_id)
+        if agent is None:
+            raise InvalidAccountError(f"Account (Agent) not found: {account_id}")
+
+        if not hasattr(agent, 'wallet'):
+             raise InvalidAccountError(f"Agent {account_id} does not have a wallet.")
+
+        return agent.wallet
+
+    def exists(self, account_id: str) -> bool:
+        agent = self._get_agent(account_id)
+        return agent is not None and hasattr(agent, 'wallet')
diff --git a/modules/finance/transaction/api.py b/modules/finance/transaction/api.py
new file mode 100644
index 00000000..55f9acbe
--- /dev/null
+++ b/modules/finance/transaction/api.py
@@ -0,0 +1,168 @@
+from typing import Protocol, TypedDict, Literal, runtime_checkable
+from modules.finance.wallet.api import IWallet
+
+# ==============================================================================
+# DATA TRANSFER OBJECTS (DTOs)
+# ==============================================================================
+
+class TransactionDTO(TypedDict):
+    """
+    A pure data container describing a single transaction request.
+    This object is immutable once created and is passed between components.
+    """
+    transaction_id: str
+    source_account_id: str
+    destination_account_id: str
+    amount: float
+    currency: str  # e.g., "GOLD", "USD"
+    description: str
+
+
+class TransactionResultDTO(TypedDict):
+    """
+    A data container representing the final outcome of a transaction attempt.
+    This is what the TransactionEngine returns to the caller.
+    """
+    transaction: TransactionDTO
+    status: Literal['COMPLETED', 'FAILED', 'CRITICAL_FAILURE']
+    message: str
+    timestamp: float # Simulation timestamp
+
+
+# ==============================================================================
+# EXCEPTIONS
+# ==============================================================================
+
+class TransactionError(Exception):
+    """Base exception for all transaction-related errors."""
+    pass
+
+
+class ValidationError(TransactionError):
+    """Raised by the validator when a business rule is violated."""
+    pass
+
+
+class InsufficientFundsError(ValidationError):
+    """Raised when the source account has an insufficient balance."""
+    pass
+
+
+class InvalidAccountError(ValidationError):
+    """Raised when the source or destination account is invalid or inactive."""
+    pass
+
+
+class NegativeAmountError(ValidationError):
+    """Raised when the transaction amount is not a positive number."""
+    pass
+
+
+class ExecutionError(TransactionError):
+    """
+    Raised by the executor for critical failures after validation has passed.
+    This may indicate an inconsistent state.
+    """
+    pass
+
+
+# ==============================================================================
+# COMPONENT INTERFACES (Protocols)
+# ==============================================================================
+
+@runtime_checkable
+class IAccountAccessor(Protocol):
+    """
+    Interface for accessing account information and performing operations.
+    Decouples the transaction system from the agent registry.
+    """
+    def get_wallet(self, account_id: str) -> IWallet:
+        """
+        Retrieves the wallet for the given account ID.
+        Raises InvalidAccountError if the account does not exist.
+        """
+        ...
+
+    def exists(self, account_id: str) -> bool:
+        """Checks if an account exists."""
+        ...
+
+
+class ITransactionValidator(Protocol):
+    """
+    Interface for a component that validates a transaction against business rules.
+    It should not modify any state.
+    """
+    def validate(self, transaction: TransactionDTO) -> None:
+        """
+        Checks if the transaction is valid.
+
+        Args:
+            transaction: The transaction data to validate.
+
+        Raises:
+            ValidationError or its subclasses if the transaction is invalid.
+        """
+        ...
+
+
+class ITransactionExecutor(Protocol):
+    """
+    Interface for a component that executes a transaction.
+    It assumes the transaction has already been validated.
+    """
+    def execute(self, transaction: TransactionDTO) -> None:
+        """
+        Performs the state change for the transaction (e.g., debit/credit).
+
+        Args:
+            transaction: The validated transaction data to execute.
+
+        Raises:
+            ExecutionError if the state change fails unexpectedly.
+        """
+        ...
+
+
+class ITransactionLedger(Protocol):
+    """
+    Interface for a Data Access Object (DAO) that records transaction results.
+    This is the persistence layer.
+    """
+    def record(self, result: TransactionResultDTO) -> None:
+        """
+        Saves the result of a transaction to a persistent store.
+
+        Args:
+            result: The final result object of the transaction.
+        """
+        ...
+
+
+class ITransactionEngine(Protocol):
+    """
+    Interface for the main engine that orchestrates the entire transaction process.
+    This is the primary entry point for external modules.
+    """
+    def process_transaction(
+        self,
+        source_account_id: str,
+        destination_account_id: str,
+        amount: float,
+        currency: str,
+        description: str
+    ) -> TransactionResultDTO:
+        """
+        Processes a complete financial transaction from validation to recording.
+
+        Args:
+            source_account_id: The ID of the account to debit.
+            destination_account_id: The ID of the account to credit.
+            amount: The amount to transfer.
+            currency: The currency of the transaction.
+            description: A human-readable description of the transaction.
+
+        Returns:
+            A DTO containing the full transaction details and its final status.
+        """
+        ...
diff --git a/modules/finance/transaction/engine.py b/modules/finance/transaction/engine.py
new file mode 100644
index 00000000..a005f2a4
--- /dev/null
+++ b/modules/finance/transaction/engine.py
@@ -0,0 +1,198 @@
+import uuid
+import logging
+from typing import Optional, Callable
+
+from modules.finance.transaction.api import (
+    ITransactionEngine,
+    ITransactionValidator,
+    ITransactionExecutor,
+    ITransactionLedger,
+    IAccountAccessor,
+    TransactionDTO,
+    TransactionResultDTO,
+    TransactionError,
+    ValidationError,
+    InsufficientFundsError,
+    InvalidAccountError,
+    NegativeAmountError,
+    ExecutionError
+)
+
+# ==============================================================================
+# DEFAULT IMPLEMENTATIONS
+# ==============================================================================
+
+class TransactionValidator(ITransactionValidator):
+    def __init__(self, account_accessor: IAccountAccessor):
+        self.account_accessor = account_accessor
+
+    def validate(self, transaction: TransactionDTO) -> None:
+        if transaction['amount'] <= 0:
+            raise NegativeAmountError(f"Transaction amount must be positive. Got: {transaction['amount']}")
+
+        if not self.account_accessor.exists(transaction['source_account_id']):
+            raise InvalidAccountError(f"Source account does not exist: {transaction['source_account_id']}")
+
+        if not self.account_accessor.exists(transaction['destination_account_id']):
+            raise InvalidAccountError(f"Destination account does not exist: {transaction['destination_account_id']}")
+
+        # Check sufficient funds
+        try:
+            wallet = self.account_accessor.get_wallet(transaction['source_account_id'])
+            # Note: IWallet.get_balance might raise exception if currency not found,
+            # but usually it returns 0.0 or we should handle it.
+            # Assuming get_balance returns float.
+            balance = wallet.get_balance(transaction['currency'])
+            if balance < transaction['amount']:
+                raise InsufficientFundsError(
+                    f"Insufficient funds in source account {transaction['source_account_id']}. "
+                    f"Required: {transaction['amount']}, Available: {balance}"
+                )
+        except Exception as e:
+            if isinstance(e, TransactionError):
+                raise e
+            # Re-raise unexpected errors as InvalidAccountError or generic ValidationError if accessing wallet fails
+            raise InvalidAccountError(f"Failed to access source wallet: {e}") from e
+
+
+class TransactionExecutor(ITransactionExecutor):
+    def __init__(self, account_accessor: IAccountAccessor):
+        self.account_accessor = account_accessor
+
+    def execute(self, transaction: TransactionDTO) -> None:
+        try:
+            source_wallet = self.account_accessor.get_wallet(transaction['source_account_id'])
+            dest_wallet = self.account_accessor.get_wallet(transaction['destination_account_id'])
+
+            # Atomic transfer is not natively supported by IWallet in one go between two wallets,
+            # but we can do subtract then add.
+            # If subtract fails, add is not reached.
+            # If add fails, we have a problem (inconsistent state).
+            # However, IWallet.add usually shouldn't fail for simple addition.
+            # IWallet.subtract raises InsufficientFundsError, but we already validated.
+            # But race conditions could happen if not single-threaded. Simulation is usually single-threaded.
+
+            source_wallet.subtract(
+                transaction['amount'],
+                transaction['currency'],
+                memo=f"Transfer to {transaction['destination_account_id']}: {transaction['description']}"
+            )
+
+            dest_wallet.add(
+                transaction['amount'],
+                transaction['currency'],
+                memo=f"Transfer from {transaction['source_account_id']}: {transaction['description']}"
+            )
+
+        except Exception as e:
+            raise ExecutionError(f"Transaction execution failed: {e}") from e
+
+
+class SimpleTransactionLedger(ITransactionLedger):
+    def __init__(self, logger: Optional[logging.Logger] = None):
+        self.logger = logger or logging.getLogger(__name__)
+
+    def record(self, result: TransactionResultDTO) -> None:
+        # In a real system, this would write to a DB.
+        # For now, we log it.
+        level = logging.INFO if result['status'] == 'COMPLETED' else logging.ERROR
+        self.logger.log(
+            level,
+            f"Transaction Record: ID={result['transaction']['transaction_id']}, "
+            f"Status={result['status']}, Message={result['message']}"
+        )
+
+
+class TransactionEngine(ITransactionEngine):
+    def __init__(
+        self,
+        validator: ITransactionValidator,
+        executor: ITransactionExecutor,
+        ledger: ITransactionLedger,
+        clock_callback: Optional[Callable[[], float]] = None # To get current time/tick
+    ):
+        self.validator = validator
+        self.executor = executor
+        self.ledger = ledger
+        self.clock_callback = clock_callback
+
+    def _get_timestamp(self) -> float:
+        if self.clock_callback:
+            return self.clock_callback()
+        return 0.0
+
+    def process_transaction(
+        self,
+        source_account_id: str,
+        destination_account_id: str,
+        amount: float,
+        currency: str,
+        description: str
+    ) -> TransactionResultDTO:
+
+        transaction_id = str(uuid.uuid4())
+        transaction_dto = TransactionDTO(
+            transaction_id=transaction_id,
+            source_account_id=source_account_id,
+            destination_account_id=destination_account_id,
+            amount=amount,
+            currency=currency,
+            description=description
+        )
+
+        # 2. Validation Stage
+        try:
+            self.validator.validate(transaction_dto)
+        except ValidationError as e:
+            failed_result = TransactionResultDTO(
+                transaction=transaction_dto,
+                status='FAILED',
+                message=str(e),
+                timestamp=self._get_timestamp()
+            )
+            self.ledger.record(failed_result)
+            return failed_result
+        except Exception as e:
+             # Unexpected error during validation
+            failed_result = TransactionResultDTO(
+                transaction=transaction_dto,
+                status='FAILED',
+                message=f"Unexpected validation error: {e}",
+                timestamp=self._get_timestamp()
+            )
+            self.ledger.record(failed_result)
+            return failed_result
+
+        # 3. Execution Stage
+        try:
+            self.executor.execute(transaction_dto)
+        except ExecutionError as e:
+            critical_failure_result = TransactionResultDTO(
+                transaction=transaction_dto,
+                status='CRITICAL_FAILURE',
+                message=str(e),
+                timestamp=self._get_timestamp()
+            )
+            self.ledger.record(critical_failure_result)
+            return critical_failure_result
+        except Exception as e:
+             # Unexpected error during execution
+            critical_failure_result = TransactionResultDTO(
+                transaction=transaction_dto,
+                status='CRITICAL_FAILURE',
+                message=f"Unexpected execution error: {e}",
+                timestamp=self._get_timestamp()
+            )
+            self.ledger.record(critical_failure_result)
+            return critical_failure_result
+
+        # 4. Recording & Success
+        successful_result = TransactionResultDTO(
+            transaction=transaction_dto,
+            status='COMPLETED',
+            message='Transaction successful.',
+            timestamp=self._get_timestamp()
+        )
+        self.ledger.record(successful_result)
+
+        return successful_result
diff --git a/tests/unit/test_transaction_engine.py b/tests/unit/test_transaction_engine.py
new file mode 100644
index 00000000..b180f17c
--- /dev/null
+++ b/tests/unit/test_transaction_engine.py
@@ -0,0 +1,233 @@
+import pytest
+from unittest.mock import Mock, MagicMock
+
+from modules.finance.transaction.api import (
+    TransactionDTO,
+    InsufficientFundsError,
+    InvalidAccountError,
+    NegativeAmountError,
+    ExecutionError,
+    IAccountAccessor,
+    ITransactionLedger
+)
+from modules.finance.transaction.engine import (
+    TransactionValidator,
+    TransactionExecutor,
+    TransactionEngine
+)
+from modules.finance.wallet.api import IWallet
+from modules.finance.transaction.adapter import RegistryAccountAccessor
+from modules.system.api import IAgentRegistry
+
+# ==============================================================================
+# Validator Tests
+# ==============================================================================
+
+def test_validator_success():
+    mock_accessor = Mock(spec=IAccountAccessor)
+    mock_accessor.exists.return_value = True
+    mock_wallet = Mock(spec=IWallet)
+    mock_wallet.get_balance.return_value = 100.0
+    mock_accessor.get_wallet.return_value = mock_wallet
+
+    validator = TransactionValidator(mock_accessor)
+
+    dto = TransactionDTO(
+        transaction_id="1",
+        source_account_id="src",
+        destination_account_id="dst",
+        amount=50.0,
+        currency="USD",
+        description="test"
+    )
+
+    # Should not raise
+    validator.validate(dto)
+
+def test_validator_negative_amount():
+    mock_accessor = Mock(spec=IAccountAccessor)
+    validator = TransactionValidator(mock_accessor)
+
+    dto = TransactionDTO(
+        transaction_id="1",
+        source_account_id="src",
+        destination_account_id="dst",
+        amount=-10.0,
+        currency="USD",
+        description="test"
+    )
+
+    with pytest.raises(NegativeAmountError):
+        validator.validate(dto)
+
+def test_validator_insufficient_funds():
+    mock_accessor = Mock(spec=IAccountAccessor)
+    mock_accessor.exists.return_value = True
+    mock_wallet = Mock(spec=IWallet)
+    mock_wallet.get_balance.return_value = 10.0
+    mock_accessor.get_wallet.return_value = mock_wallet
+
+    validator = TransactionValidator(mock_accessor)
+
+    dto = TransactionDTO(
+        transaction_id="1",
+        source_account_id="src",
+        destination_account_id="dst",
+        amount=50.0,
+        currency="USD",
+        description="test"
+    )
+
+    with pytest.raises(InsufficientFundsError):
+        validator.validate(dto)
+
+def test_validator_invalid_account():
+    mock_accessor = Mock(spec=IAccountAccessor)
+    mock_accessor.exists.side_effect = lambda id: id == "existing"
+
+    validator = TransactionValidator(mock_accessor)
+
+    dto = TransactionDTO(
+        transaction_id="1",
+        source_account_id="non_existing",
+        destination_account_id="existing",
+        amount=50.0,
+        currency="USD",
+        description="test"
+    )
+
+    with pytest.raises(InvalidAccountError):
+        validator.validate(dto)
+
+
+# ==============================================================================
+# Executor Tests
+# ==============================================================================
+
+def test_executor_success():
+    mock_accessor = Mock(spec=IAccountAccessor)
+    src_wallet = Mock(spec=IWallet)
+    dst_wallet = Mock(spec=IWallet)
+
+    def get_wallet_side_effect(id):
+        if id == "src": return src_wallet
+        if id == "dst": return dst_wallet
+        raise InvalidAccountError()
+
+    mock_accessor.get_wallet.side_effect = get_wallet_side_effect
+
+    executor = TransactionExecutor(mock_accessor)
+
+    dto = TransactionDTO(
+        transaction_id="1",
+        source_account_id="src",
+        destination_account_id="dst",
+        amount=50.0,
+        currency="USD",
+        description="test"
+    )
+
+    executor.execute(dto)
+
+    src_wallet.subtract.assert_called_once()
+    dst_wallet.add.assert_called_once()
+
+def test_executor_failure():
+    mock_accessor = Mock(spec=IAccountAccessor)
+    src_wallet = Mock(spec=IWallet)
+    # Simulate failure during subtract
+    src_wallet.subtract.side_effect = Exception("DB Error")
+    mock_accessor.get_wallet.return_value = src_wallet
+
+    executor = TransactionExecutor(mock_accessor)
+
+    dto = TransactionDTO(
+        transaction_id="1",
+        source_account_id="src",
+        destination_account_id="dst",
+        amount=50.0,
+        currency="USD",
+        description="test"
+    )
+
+    with pytest.raises(ExecutionError):
+        executor.execute(dto)
+
+
+# ==============================================================================
+# Engine Tests
+# ==============================================================================
+
+def test_engine_process_transaction_success():
+    mock_validator = Mock()
+    mock_executor = Mock()
+    mock_ledger = Mock(spec=ITransactionLedger)
+
+    engine = TransactionEngine(mock_validator, mock_executor, mock_ledger)
+
+    result = engine.process_transaction("src", "dst", 100.0, "USD", "test")
+
+    assert result['status'] == 'COMPLETED'
+    mock_validator.validate.assert_called_once()
+    mock_executor.execute.assert_called_once()
+    mock_ledger.record.assert_called_once()
+    assert mock_ledger.record.call_args[0][0]['status'] == 'COMPLETED'
+
+def test_engine_process_transaction_validation_fail():
+    mock_validator = Mock()
+    mock_validator.validate.side_effect = InsufficientFundsError("Not enough money")
+    mock_executor = Mock()
+    mock_ledger = Mock(spec=ITransactionLedger)
+
+    engine = TransactionEngine(mock_validator, mock_executor, mock_ledger)
+
+    result = engine.process_transaction("src", "dst", 100.0, "USD", "test")
+
+    assert result['status'] == 'FAILED'
+    assert "Not enough money" in result['message']
+    mock_executor.execute.assert_not_called()
+    mock_ledger.record.assert_called_once()
+    assert mock_ledger.record.call_args[0][0]['status'] == 'FAILED'
+
+def test_engine_process_transaction_execution_fail():
+    mock_validator = Mock()
+    mock_executor = Mock()
+    mock_executor.execute.side_effect = ExecutionError("Critical fail")
+    mock_ledger = Mock(spec=ITransactionLedger)
+
+    engine = TransactionEngine(mock_validator, mock_executor, mock_ledger)
+
+    result = engine.process_transaction("src", "dst", 100.0, "USD", "test")
+
+    assert result['status'] == 'CRITICAL_FAILURE'
+    assert "Critical fail" in result['message']
+    mock_ledger.record.assert_called_once()
+    assert mock_ledger.record.call_args[0][0]['status'] == 'CRITICAL_FAILURE'
+
+# ==============================================================================
+# Adapter Tests
+# ==============================================================================
+
+def test_adapter_registry_accessor():
+    mock_registry = Mock(spec=IAgentRegistry)
+    mock_agent = Mock()
+    mock_wallet = Mock(spec=IWallet)
+    mock_agent.wallet = mock_wallet
+
+    mock_registry.get_agent.return_value = mock_agent
+
+    accessor = RegistryAccountAccessor(mock_registry)
+
+    # Test get_wallet with digit string, expect int conversion
+    wallet = accessor.get_wallet("123")
+    assert wallet == mock_wallet
+    mock_registry.get_agent.assert_called_with(123)
+
+    # Test exists
+    assert accessor.exists("123")
+
+    # Test not found
+    mock_registry.get_agent.return_value = None
+    assert not accessor.exists("999")
+    with pytest.raises(InvalidAccountError):
+        accessor.get_wallet("999")
