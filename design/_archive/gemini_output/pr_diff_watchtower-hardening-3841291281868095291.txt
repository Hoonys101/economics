diff --git a/communications/insights/mission_watchtower_hardening.md b/communications/insights/mission_watchtower_hardening.md
new file mode 100644
index 00000000..d92a423a
--- /dev/null
+++ b/communications/insights/mission_watchtower_hardening.md
@@ -0,0 +1,41 @@
+# Technical Insight Report: Watchtower Hardening (Track A)
+
+## 1. Problem Phenomenon
+- **Symptoms**:
+    - The Watchtower Dashboard displayed instantaneous (noisy) values for key economic indicators like GDP, CPI, and M2 Leak, making trend analysis difficult.
+    - Demographic metrics were incomplete, showing Death Rate but missing Birth Rate, preventing a complete view of population dynamics.
+- **Stack Trace/Logs**: N/A (Feature Gap, not a crash).
+
+## 2. Root Cause Analysis
+- **Missing Data Processing**: The `EconomicIndicatorTracker` only stored raw history in lists but did not compute moving averages for real-time consumption.
+- **Missing Repository Method**: The `AgentRepository` lacked a query method to track "New Agents" (Births) comparable to the existing `get_attrition_counts` (Deaths/Bankruptcy).
+- **Service Gap**: `DashboardService` was calculating `m2_leak` locally based on instantaneous snapshots rather than using a smoothed metric from the Tracker.
+
+## 3. Solution Implementation Details
+### A. Tracker Hardening (`EconomicIndicatorTracker`)
+- **Deque Implementation**: Added `collections.deque(maxlen=50)` for `gdp`, `cpi` (goods_price_index), and `m2_leak`.
+- **Logic**: Updated `track()` to accept `m2_leak` (calculated in Orchestrator) and append values to history.
+- **API**: Added `get_smoothed_values()` to return the simple moving average (SMA) of the history.
+
+### B. Repository Upgrade (`AgentRepository`)
+- **New Method**: Implemented `get_birth_counts(start_tick, end_tick, run_id)`.
+- **Logic**: Defines "Births" as the count of agents present at `end_tick` who were **NOT** present at `start_tick`. This effectively counts new survivors in the window.
+- **Query**:
+  ```sql
+  SELECT COUNT(DISTINCT agent_id)
+  FROM agent_states
+  WHERE time = ? AND agent_type = 'household'
+  AND agent_id NOT IN (
+      SELECT agent_id FROM agent_states
+      WHERE time = ? AND agent_type = 'household'
+  )
+  ```
+
+### C. Orchestration Integration
+- **TickOrchestrator**: Updated `_finalize_tick` to pass the calculated M2 delta to the tracker.
+- **DashboardService**: Updated `get_snapshot` to prefer smoothed values from the tracker and fetch birth counts from the repository.
+
+## 4. Lessons Learned & Technical Debt
+- **Performance Risk**: The `agent_states` table only has an index on `time`. The `get_birth_counts` query uses a `NOT IN` subquery which works well for small-to-medium datasets but may degrade performance as the simulation grows (O(N*M)).
+- **Debt Item (TD-XXX)**: Add an index on `agent_states(agent_id, time)` or `agent_states(agent_id)` to optimize agent existence checks.
+- **Metric Definitions**: The "Birth" definition is "Net New Survivors". Agents born and died within the same window (e.g., 5 ticks) are not counted. This mirrors the "Death" logic (Agents present at start, gone at end) but omits high-frequency churn. This is acceptable for a "Watchtower" (Macro) view but might be insufficient for detailed demographic debugging.
diff --git a/design/2_operations/ledgers/TECH_DEBT_LEDGER.md b/design/2_operations/ledgers/TECH_DEBT_LEDGER.md
index af9f30c1..6b3a89dd 100644
--- a/design/2_operations/ledgers/TECH_DEBT_LEDGER.md
+++ b/design/2_operations/ledgers/TECH_DEBT_LEDGER.md
@@ -39,7 +39,7 @@
 | TD-255 | 2026-02-06 | Housing Saga DTO Purity Breach | Raw Agent Mutation Leaks | [Structural Audit](../../3_work_artifacts/reports/inbound/structural-god-class-check-2584000745385775058_audit_structural_001.md) | **MEDIUM** |
 | TD-256 | 2026-02-06 | Lack of Inventory Abstraction (Direct Mutation) | Goods Transfer Atomicity Risks | [Economic Audit](../../3_work_artifacts/reports/inbound/economic-jules-001-12984982393375704591_audit_economic_JULES_001.md) | **MEDIUM** |
 | TD-258 | 2026-02-06 | Manual Transaction Injection in Saga | Bypass of Transaction Pipeline | [Review](../../_archive/gemini_output/pr_review_pulse-integrity-fix-5507545585466336807.md) | **LOW** |
-| (No Active Items) | | | | | |
+| TD-261 | 2026-02-06 | `agent_states` Index Performance Risk | O(N*M) Subquery Degradation in Birth Tracking | [Insight](../../communications/insights/mission_watchtower_hardening.md) | **MEDIUM** |
 
 ## ğŸ“¦ 6. DATA & DTO CONTRACTS
 
diff --git a/modules/simulation/api.py b/modules/simulation/api.py
index 11ffa936..b334aeeb 100644
--- a/modules/simulation/api.py
+++ b/modules/simulation/api.py
@@ -60,6 +60,24 @@ class IGovernment(Protocol):
     revenue_this_tick: float
     total_debt: float
 
+@runtime_checkable
+class IEconomicIndicatorTracker(Protocol):
+    """Protocol for the EconomicIndicatorTracker to enable smoothed metrics access."""
+    def get_smoothed_values(self) -> Dict[str, float]:
+        ...
+
+    def get_latest_indicators(self) -> Dict[str, Any]:
+        ...
+
+@runtime_checkable
+class IAgentRepository(Protocol):
+    """Protocol for the AgentRepository to enable demographic queries."""
+    def get_birth_counts(self, start_tick: int, end_tick: int, run_id: Any = None) -> int:
+        ...
+
+    def get_attrition_counts(self, start_tick: int, end_tick: int, run_id: Any = None) -> Dict[str, int]:
+        ...
+
 class IConfig(Protocol):
     STARVATION_THRESHOLD: float
 
diff --git a/simulation/db/agent_repository.py b/simulation/db/agent_repository.py
index cea7cb7f..f282d740 100644
--- a/simulation/db/agent_repository.py
+++ b/simulation/db/agent_repository.py
@@ -205,6 +205,41 @@ class AgentRepository(BaseRepository):
 
         return result
 
+    def get_birth_counts(self, start_tick: int, end_tick: int, run_id: Optional[int] = None) -> int:
+        """
+        Calculates the number of NEW households that appeared between start_tick and end_tick.
+        Specifically, counts agents present at end_tick who were NOT present at start_tick.
+        """
+        query_suffix = ""
+        if run_id:
+            query_suffix = " AND run_id = ?"
+
+        query = f"""
+            SELECT COUNT(DISTINCT agent_id)
+            FROM agent_states
+            WHERE time = ? AND agent_type = 'household' {query_suffix}
+            AND agent_id NOT IN (
+                SELECT agent_id FROM agent_states
+                WHERE time = ? AND agent_type = 'household' {query_suffix}
+            )
+        """
+
+        # Params: [end_tick, (run_id), start_tick, (run_id)]
+        params = [end_tick]
+        if run_id:
+            params.append(run_id)
+        params.append(start_tick)
+        if run_id:
+            params.append(run_id)
+
+        try:
+            self.cursor.execute(query, params)
+            result = self.cursor.fetchone()
+            return result[0] if result else 0
+        except sqlite3.Error as e:
+            logger.error(f"Error getting birth counts: {e}")
+            return 0
+
     def clear_data(self):
         """
         agent_states í…Œì´ë¸”ì˜ ë°ì´í„°ë¥¼ ì‚­ì œí•©ë‹ˆë‹¤.
diff --git a/simulation/metrics/economic_tracker.py b/simulation/metrics/economic_tracker.py
index e1e7a201..b3f010f5 100644
--- a/simulation/metrics/economic_tracker.py
+++ b/simulation/metrics/economic_tracker.py
@@ -2,6 +2,7 @@ from __future__ import annotations
 from typing import List, Dict, Any, TYPE_CHECKING
 import logging
 import statistics
+from collections import deque
 
 if TYPE_CHECKING:
     from simulation.world_state import WorldState
@@ -48,6 +49,13 @@ class EconomicIndicatorTracker:
             "quintile_4_avg_assets": [],
             "quintile_5_avg_assets": [],
         }
+
+        # Watchtower Hardening: SMA History (Window=50)
+        self.history_window = 50
+        self.gdp_history = deque(maxlen=self.history_window)
+        self.cpi_history = deque(maxlen=self.history_window)
+        self.m2_leak_history = deque(maxlen=self.history_window)
+
         self.config_module = config_module  # Store config_module
         self.exchange_engine = CurrencyExchangeEngine(config_module) # TD-213: Initialize Exchange Engine
 
@@ -194,6 +202,7 @@ class EconomicIndicatorTracker:
         firms: List[Firm],
         markets: Dict[str, Market],
         money_supply: float = 0.0,
+        m2_leak: float = 0.0,
     ) -> None:
         """í˜„ì¬ ì‹œë®¬ë ˆì´ì…˜ í‹±ì˜ ê²½ì œ ì§€í‘œë¥¼ ê³„ì‚°í•˜ê³  ê¸°ë¡í•©ë‹ˆë‹¤."""
         self.logger.debug(
@@ -422,6 +431,22 @@ class EconomicIndicatorTracker:
                 # Ensure we have a list for this key
                 self.metrics.setdefault(key, []).append(value)
 
+        # Update SMA Histories
+        self.gdp_history.append(record.get("gdp", 0.0))
+        self.cpi_history.append(record.get("goods_price_index", 0.0))
+        self.m2_leak_history.append(m2_leak)
+
+    def get_smoothed_values(self) -> Dict[str, float]:
+        """
+        Returns the Simple Moving Average (SMA) of key indicators.
+        Window size is defined by self.history_window (default 50).
+        """
+        return {
+            "gdp_sma": statistics.mean(self.gdp_history) if self.gdp_history else 0.0,
+            "cpi_sma": statistics.mean(self.cpi_history) if self.cpi_history else 0.0,
+            "m2_leak_sma": statistics.mean(self.m2_leak_history) if self.m2_leak_history else 0.0
+        }
+
     def get_latest_indicators(self) -> Dict[str, Any]:
         """ê°€ì¥ ìµœê·¼ì— ê¸°ë¡ëœ ê²½ì œ ì§€í‘œë“¤ì„ ë”•ì…”ë„ˆë¦¬ í˜•íƒœë¡œ ë°˜í™˜í•©ë‹ˆë‹¤."""
         latest_indicators = {}
diff --git a/simulation/orchestration/dashboard_service.py b/simulation/orchestration/dashboard_service.py
index 2931a315..ea0d869b 100644
--- a/simulation/orchestration/dashboard_service.py
+++ b/simulation/orchestration/dashboard_service.py
@@ -11,6 +11,7 @@ from simulation.dtos.watchtower import (
 )
 from simulation.orchestration.persistence_bridge import PersistenceBridge
 from modules.system.api import DEFAULT_CURRENCY
+from modules.simulation.api import IEconomicIndicatorTracker, IAgentRepository
 
 logger = logging.getLogger(__name__)
 
@@ -27,7 +28,12 @@ class DashboardService:
         gov = state.governments[0] if state.governments else None
 
         # --- 1. System Integrity ---
+        # Use smoothed M2 leak if available (Watchtower Hardening)
         m2_leak = self._calculate_m2_leak(state)
+        if isinstance(tracker, IEconomicIndicatorTracker):
+             smoothed = tracker.get_smoothed_values()
+             if smoothed.get("m2_leak_sma") is not None:
+                 m2_leak = smoothed.get("m2_leak_sma")
 
         # FPS Calculation
         current_time = datetime.now()
@@ -42,12 +48,15 @@ class DashboardService:
 
         # --- 2. Macro Economy ---
         latest = tracker.get_latest_indicators() if tracker else {}
+        smoothed = {}
+        if isinstance(tracker, IEconomicIndicatorTracker):
+            smoothed = tracker.get_smoothed_values()
 
-        # GDP (Nominal)
-        gdp = latest.get("gdp", 0.0)
+        # GDP (Nominal) - Smoothed
+        gdp = smoothed.get("gdp_sma", latest.get("gdp", 0.0))
 
-        # CPI (Goods Price Index)
-        cpi = latest.get("goods_price_index", 1.0)
+        # CPI (Goods Price Index) - Smoothed
+        cpi = smoothed.get("cpi_sma", latest.get("goods_price_index", 1.0))
 
         # Unemployment
         unemploy = latest.get("unemployment_rate", 0.0)
@@ -121,15 +130,22 @@ class DashboardService:
         birth_rate = 0.0
         death_rate = 0.0
 
+        # Accessing repo.agents which should implement IAgentRepository
         repo = getattr(state, "repository", None)
-        if repo and active_count > 0:
+        agent_repo = None
+        if repo and hasattr(repo, "agents"):
+             agent_repo = repo.agents
+
+        if agent_repo and isinstance(agent_repo, IAgentRepository) and active_count > 0:
             start_tick = max(0, state.time - 5)
             # Fetch attrition stats for death rate
-            attrition = repo.agents.get_attrition_counts(start_tick, state.time, run_id=state.run_id)
+            attrition = agent_repo.get_attrition_counts(start_tick, state.time, run_id=state.run_id)
             death_count = attrition.get("death_count", 0)
             death_rate = (death_count / active_count) * 100.0
 
-            # TODO: Implement Birth Rate tracking in Repository or Tracker
+            # Birth Rate Tracking (Watchtower Hardening)
+            birth_count = agent_repo.get_birth_counts(start_tick, state.time, run_id=state.run_id)
+            birth_rate = (birth_count / active_count) * 100.0
 
         snapshot = WatchtowerSnapshotDTO(
             tick=state.time,
diff --git a/simulation/orchestration/tick_orchestrator.py b/simulation/orchestration/tick_orchestrator.py
index 4542e62b..a0e346cd 100644
--- a/simulation/orchestration/tick_orchestrator.py
+++ b/simulation/orchestration/tick_orchestrator.py
@@ -186,19 +186,8 @@ class TickOrchestrator:
         # Persistence has already happened in Phase 5.
         state.transactions.clear()
 
-        # Track Economics
-        if state.tracker:
-             # TD-024: Ensure money_supply is scalar for tracker compatibility
-             money_supply_scalar = state.get_total_system_money_for_diagnostics(DEFAULT_CURRENCY)
-             state.tracker.track(
-                 time=state.time,
-                 households=state.households,
-                 firms=state.firms,
-                 markets=state.markets,
-                 money_supply=money_supply_scalar
-             )
-
-        # Money Supply Verification (Post-Tick)
+        # Money Supply Verification (Post-Tick) & M2 Leak Calculation
+        m2_leak_delta = 0.0
         if state.time >= 1:
             # WO-220: Repair Currency Holders Sync
             # Rebuilds state.currency_holders from state.agents to ensure M2 integrity.
@@ -219,12 +208,12 @@ class TickOrchestrator:
             if hasattr(state.government, "get_monetary_delta"):
                 expected_money += state.government.get_monetary_delta(DEFAULT_CURRENCY)
 
-            delta = current_money - expected_money
+            m2_leak_delta = current_money - expected_money
 
-            msg = f"MONEY_SUPPLY_CHECK | Current: {current_money:.2f}, Expected: {expected_money:.2f}, Delta: {delta:.4f}"
-            extra_data = {"tick": state.time, "current": current_money, "expected": expected_money, "delta": delta, "tags": ["money_supply"]}
+            msg = f"MONEY_SUPPLY_CHECK | Current: {current_money:.2f}, Expected: {expected_money:.2f}, Delta: {m2_leak_delta:.4f}"
+            extra_data = {"tick": state.time, "current": current_money, "expected": expected_money, "delta": m2_leak_delta, "tags": ["money_supply"]}
 
-            if abs(delta) > 1.0:
+            if abs(m2_leak_delta) > 1.0:
                  state.logger.warning(msg, extra=extra_data)
             else:
                  state.logger.info(msg, extra=extra_data)
@@ -235,6 +224,19 @@ class TickOrchestrator:
                 authorized_delta = state.government.get_monetary_delta(DEFAULT_CURRENCY)
                 state.baseline_money_supply += authorized_delta
 
+        # Track Economics
+        if state.tracker:
+             # TD-024: Ensure money_supply is scalar for tracker compatibility
+             money_supply_scalar = state.get_total_system_money_for_diagnostics(DEFAULT_CURRENCY)
+             state.tracker.track(
+                 time=state.time,
+                 households=state.households,
+                 firms=state.firms,
+                 markets=state.markets,
+                 money_supply=money_supply_scalar,
+                 m2_leak=m2_leak_delta
+             )
+
     def prepare_market_data(self) -> Dict[str, Any]:
         """
         Legacy/External access to market data preparation.
diff --git a/tests/unit/test_watchtower_hardening.py b/tests/unit/test_watchtower_hardening.py
new file mode 100644
index 00000000..a88167ac
--- /dev/null
+++ b/tests/unit/test_watchtower_hardening.py
@@ -0,0 +1,140 @@
+import unittest
+import sqlite3
+import statistics
+from unittest.mock import MagicMock
+from simulation.metrics.economic_tracker import EconomicIndicatorTracker
+from simulation.db.agent_repository import AgentRepository
+from simulation.dtos.api import AgentStateData
+from collections import deque
+
+class TestWatchtowerHardening(unittest.TestCase):
+
+    def setUp(self):
+        # Tracker Setup
+        self.config_module = MagicMock()
+        self.tracker = EconomicIndicatorTracker(self.config_module)
+
+        # Repository Setup (In-Memory DB)
+        self.conn = sqlite3.connect(":memory:")
+        self._create_tables()
+        self.repo = AgentRepository(self.conn)
+
+    def tearDown(self):
+        self.conn.close()
+
+    def _create_tables(self):
+        # Minimal schema for AgentRepository
+        cursor = self.conn.cursor()
+        cursor.execute("""
+            CREATE TABLE IF NOT EXISTS agent_states (
+                id INTEGER PRIMARY KEY AUTOINCREMENT,
+                run_id INTEGER NOT NULL,
+                time INTEGER NOT NULL,
+                agent_id INTEGER NOT NULL,
+                agent_type TEXT NOT NULL,
+                assets REAL NOT NULL,
+                is_active BOOLEAN NOT NULL,
+                is_employed BOOLEAN,
+                employer_id INTEGER,
+                needs_survival REAL,
+                needs_labor REAL,
+                inventory_food REAL,
+                current_production REAL,
+                num_employees INTEGER,
+                education_xp REAL,
+                generation INTEGER
+            )
+        """)
+        self.conn.commit()
+
+    def test_tracker_sma_logic(self):
+        # Window is 50. Let's feed 50 values.
+        # GDP: 1, 2, ..., 50
+        # CPI: 1, 1, ..., 1 (all 1s)
+        # M2 Leak: 0.1, 0.2, ...
+
+        expected_gdp_sum = 0
+        expected_m2_sum = 0
+
+        for i in range(1, 61): # Feed 60 values (window 50)
+            gdp = float(i)
+            cpi = 1.0
+            m2_leak = float(i) * 0.1
+
+            # Mock track inputs
+            # We only care about the SMA update part which uses the passed args or updated metrics
+            # tracker.track calls record["gdp"] = ...
+            # We can manually append to deques to test get_smoothed_values,
+            # OR we can Mock the track method's internal logic.
+            # But track does a lot of calculation.
+            # Easiest is to directly manipulate the deques or subclass.
+
+            # Let's test the deque logic directly since we verified the code does append.
+            # But better: use the public method get_smoothed_values.
+
+            self.tracker.gdp_history.append(gdp)
+            self.tracker.cpi_history.append(cpi)
+            self.tracker.m2_leak_history.append(m2_leak)
+
+        smoothed = self.tracker.get_smoothed_values()
+
+        # Last 50 values: 11 to 60
+        last_50_gdp = list(range(11, 61))
+        expected_gdp_sma = statistics.mean(last_50_gdp)
+
+        self.assertEqual(smoothed["gdp_sma"], expected_gdp_sma)
+        self.assertEqual(smoothed["cpi_sma"], 1.0)
+
+        last_50_m2 = [x * 0.1 for x in range(11, 61)]
+        expected_m2_sma = statistics.mean(last_50_m2)
+        self.assertAlmostEqual(smoothed["m2_leak_sma"], expected_m2_sma)
+
+    def test_repo_birth_counts(self):
+        # T=1: Agent 1, 2
+        # T=2: Agent 1, 2, 3 (New: 3)
+        # T=3: Agent 1, 3, 4 (New: 4, 2 died)
+
+        def create_agent(tick, agent_id, run_id=1):
+            return AgentStateData(
+                run_id=run_id, time=tick, agent_id=agent_id, agent_type='household',
+                assets=100.0, is_active=True, is_employed=False, employer_id=None,
+                needs_survival=0, needs_labor=0, inventory_food=0, current_production=0,
+                num_employees=0, education_xp=0, generation=1
+            )
+
+        # Insert T=1
+        self.repo.save_agent_state(create_agent(1, 1))
+        self.repo.save_agent_state(create_agent(1, 2))
+
+        # Insert T=2
+        self.repo.save_agent_state(create_agent(2, 1))
+        self.repo.save_agent_state(create_agent(2, 2))
+        self.repo.save_agent_state(create_agent(2, 3))
+
+        # Insert T=3
+        self.repo.save_agent_state(create_agent(3, 1))
+        self.repo.save_agent_state(create_agent(3, 3))
+        self.repo.save_agent_state(create_agent(3, 4))
+
+        # Test 1 -> 2 (Expected: 1 birth - Agent 3)
+        births_1_2 = self.repo.get_birth_counts(start_tick=1, end_tick=2, run_id=1)
+        self.assertEqual(births_1_2, 1)
+
+        # Test 2 -> 3 (Expected: 1 birth - Agent 4)
+        births_2_3 = self.repo.get_birth_counts(start_tick=2, end_tick=3, run_id=1)
+        self.assertEqual(births_2_3, 1)
+
+        # Test 1 -> 3 (Expected: 2 births - Agent 3, 4)
+        # Logic: Agents at T=3 (1, 3, 4) NOT IN Agents at T=1 (1, 2) => {3, 4} => 2
+        births_1_3 = self.repo.get_birth_counts(start_tick=1, end_tick=3, run_id=1)
+        self.assertEqual(births_1_3, 2)
+
+        # Test Run ID isolation
+        # Insert T=2 for Run=2
+        self.repo.save_agent_state(create_agent(2, 99, run_id=2))
+        # Should not affect Run=1 query
+        births_1_2_run1 = self.repo.get_birth_counts(start_tick=1, end_tick=2, run_id=1)
+        self.assertEqual(births_1_2_run1, 1)
+
+if __name__ == '__main__':
+    unittest.main()
