diff --git a/communications/insights/IMPL-CORE-DECOMP-P2.md b/communications/insights/IMPL-CORE-DECOMP-P2.md
new file mode 100644
index 00000000..f1951866
--- /dev/null
+++ b/communications/insights/IMPL-CORE-DECOMP-P2.md
@@ -0,0 +1,45 @@
+# Insight Report: God-Class Decomposition (Part 2 - Factories)
+
+## 1. Overview
+This report documents the execution of Phase 2 of the God-Class decomposition, focusing on extracting creation and cloning logic from `Firm` and `Household` orchestrators into dedicated factories, and extracting domain logic into stateless engines (`BrandEngine`, `ConsumptionEngine`).
+
+## 2. Architecture Changes
+
+### 2.1. Factories (Simulation Layer)
+- **`simulation/factories/household_factory.py`**: Created to consolidate household creation logic. Merged logic from `modules/household/factory.py` and `simulation/factories/agent_factory.py`. Uses `HouseholdFactoryContext` for dependency injection.
+- **`simulation/factories/firm_factory.py`**: Created to handle `Firm` creation and cloning. Implements deep copy logic for mitosis, ensuring inventory quality is preserved (fixing a potential bug in the legacy `Firm.clone` method).
+- **`simulation/factories/agent_factory.py`**: Deprecated. Retained as a wrapper/stub for legacy test compatibility but issues a `DeprecationWarning`.
+
+### 2.2. Domain Engines (Module Layer)
+- **`modules/firm/engines/brand_engine.py`**: Created stateless `BrandEngine`. Replaces the stateful `BrandManager` component. Operates directly on `SalesState` which now includes brand metrics (`adstock`, `brand_awareness`, `perceived_quality`).
+- **`modules/household/engines/consumption_engine.py`**: Renamed from `consumption.py`. Enhanced to include `apply_leisure_effect` logic, allowing `Household` to delegate this calculation.
+
+### 2.3. Orchestrator Updates
+- **`Household` (`simulation/core_agents.py`)**:
+    - Removed `clone()` method.
+    - Delegated `apply_leisure_effect` to `ConsumptionEngine`.
+    - Line count reduced (~1058 lines). Still a God Class, but responsibilities are cleaner.
+- **`Firm` (`simulation/firms.py`)**:
+    - Removed `clone()` method.
+    - Removed `BrandManager` component.
+    - Integrated `BrandEngine` (stateless).
+    - Line count is ~1400 lines (due to imports and verbose DTO mapping). Further decomposition of `finance_engine` and `production_engine` logic needed to reach <800 lines.
+
+## 3. Dependency Injection & Integration
+- **`DemographicManager`**: Refactored to accept `IHouseholdFactory` via constructor injection. Removed internal factory instantiation.
+- **`Initializer`**: Updated to instantiate `HouseholdFactory` early (after markets and AI trainer) and inject it into `DemographicManager` and `AgentLifecycleManager`.
+
+## 4. Testing & Verification
+- **Unit Tests**:
+    - `tests/unit/test_firms.py`: Updated to assert against `sales_state` instead of `brand_manager`.
+    - `tests/simulation/factories/test_agent_factory.py`: Updated to handle Zero-Sum Integrity (assets not auto-loaded via state) by explicitly depositing funds in tests.
+    - `tests/unit/test_household_factory.py`: Verified new factory logic.
+- **Integrity**: Zero-Sum constraints on asset initialization are enforced by the factory (requiring explicit transfer logic) and `Household.load_state`.
+
+## 5. Technical Debt & Future Work
+- **Firm System Integration**: `FirmSystem` still manually instantiates `Firm` agents. It should be refactored to use `FirmFactory`.
+- **God Class Size**: Both `Firm` and `Household` remain large. Next phases should focus on extracting `FinanceEngine` (Firm) and `BudgetEngine` (Household) logic more aggressively, moving state management entirely to DTOs and making orchestrators thin shells.
+- **Legacy Factory Cleanup**: `simulation/factories/agent_factory.py` should be removed once all tests are updated to use the new factory directly.
+
+## 6. Conclusion
+Phase 2 successfully decoupled creation logic and extracted key domain logic. The architecture is more modular, with clearer separation of concerns between state (DTOs), logic (Engines), and lifecycle management (Factories).
diff --git a/design/2_operations/ledgers/TECH_DEBT_LEDGER.md b/design/2_operations/ledgers/TECH_DEBT_LEDGER.md
index b8f3d497..5b1a2f99 100644
--- a/design/2_operations/ledgers/TECH_DEBT_LEDGER.md
+++ b/design/2_operations/ledgers/TECH_DEBT_LEDGER.md
@@ -203,3 +203,14 @@
 - **Risk**: Inconsistency in future parity audits due to lack of defined methodology.
 - **Solution**: Restore or recreate the `AUDIT_PARITY.md` manual.
 - **Reported**: `PROJECT_PARITY_AUDIT_REPORT_20260212.md`
+
+---
+- **Source**: `communications/insights/IMPL-CORE-DECOMP-P2.md`
+- **Entry Date**: 2026-02-12
+- **Type**: Refactoring / Architectural Debt
+- **Description**: The God-Class decomposition (Phase 2) was successful, but follow-up actions are required:
+  - The `FirmSystem` manager still manually instantiates `Firm` agents and needs to be refactored to use the new `FirmFactory`.
+  - `Firm` and `Household` orchestrators are still overly large (~1400 and ~1058 lines respectively). Further decomposition of finance and production logic is needed.
+  - The legacy `simulation/factories/agent_factory.py` is deprecated but still in use by some tests. It should be fully eliminated.
+- **Status**: `OPEN`
+---
diff --git a/modules/firm/engines/brand_engine.py b/modules/firm/engines/brand_engine.py
new file mode 100644
index 00000000..ace2b248
--- /dev/null
+++ b/modules/firm/engines/brand_engine.py
@@ -0,0 +1,57 @@
+from __future__ import annotations
+from typing import TYPE_CHECKING, Optional
+import math
+import logging
+
+if TYPE_CHECKING:
+    from simulation.dtos.config_dtos import FirmConfigDTO
+    from simulation.components.state.firm_state_models import SalesState
+
+logger = logging.getLogger(__name__)
+
+class BrandEngine:
+    """
+    Stateless engine for managing firm brand equity (Adstock, Awareness, Perceived Quality).
+    Replaces stateful BrandManager.
+    """
+
+    def update(
+        self,
+        state: SalesState,
+        config: FirmConfigDTO,
+        marketing_spend: float,
+        actual_quality: float,
+        firm_id: int # For logging
+    ) -> None:
+        """
+        Updates brand assets in the SalesState based on marketing spend and quality.
+        """
+        # 1. Adstock Update
+        # Decay old adstock, add new spend (converted to adstock units)
+        decay_rate = config.marketing_decay_rate
+        efficiency = config.marketing_efficiency
+
+        # Adstock = (Previous * Decay) + (Spend * Efficiency)
+        state.adstock = (state.adstock * decay_rate) + (marketing_spend * efficiency)
+
+        # 2. Awareness Calculation (Sigmoid/S-Curve)
+        # Using simple 1 - exp(-adstock) as per Spec
+        # Awareness approaches 1.0 as Adstock -> Infinity
+        state.brand_awareness = 1.0 - math.exp(-state.adstock)
+
+        # 3. Perceived Quality Update (EMA)
+        # Q_perc_t = (Q_actual * alpha) + (Q_perc_t-1 * (1-alpha))
+        alpha = config.perceived_quality_alpha
+
+        # Ensure actual_quality is float
+        if actual_quality is None:
+            actual_quality = 0.0
+
+        state.perceived_quality = (actual_quality * alpha) + (state.perceived_quality * (1.0 - alpha))
+
+        logger.debug(
+            f"BRAND_UPDATE | Firm {firm_id}: Spend={marketing_spend:.1f}, "
+            f"Adstock={state.adstock:.3f}, Awareness={state.brand_awareness:.3f}, "
+            f"ActQ={actual_quality:.2f}, PercQ={state.perceived_quality:.2f}",
+            extra={"agent_id": firm_id, "tick": -1, "tags": ["brand"]}
+        )
diff --git a/modules/household/api.py b/modules/household/api.py
index 9718d7d2..7c677b46 100644
--- a/modules/household/api.py
+++ b/modules/household/api.py
@@ -142,6 +142,16 @@ class IConsumptionEngine(Protocol):
     """Transforms a budget plan into concrete consumption and market orders."""
     def generate_orders(self, input_dto: ConsumptionInputDTO) -> ConsumptionOutputDTO: ...
 
+    def apply_leisure_effect(
+        self,
+        leisure_hours: float,
+        consumed_items: Dict[str, float],
+        social_state: SocialStateDTO,
+        econ_state: EconStateDTO,
+        bio_state: BioStateDTO,
+        config: HouseholdConfigDTO
+    ) -> Tuple[SocialStateDTO, EconStateDTO, LeisureEffectDTO]: ...
+
 # --- Deprecated / Legacy Support ---
 # OrchestrationContextDTO is kept if needed for transition, but Engines use specific inputs.
 class OrchestrationContextDTO(TypedDict):
diff --git a/modules/household/engines/consumption.py b/modules/household/engines/consumption_engine.py
similarity index 67%
rename from modules/household/engines/consumption.py
rename to modules/household/engines/consumption_engine.py
index b93ef827..53e58c8f 100644
--- a/modules/household/engines/consumption.py
+++ b/modules/household/engines/consumption_engine.py
@@ -1,9 +1,12 @@
 from __future__ import annotations
-from typing import List, Dict, Any, Optional
+from typing import List, Dict, Any, Optional, Tuple
 import logging
+import copy
 
 from modules.household.api import IConsumptionEngine, ConsumptionInputDTO, ConsumptionOutputDTO
-from modules.household.dtos import EconStateDTO, BioStateDTO
+from modules.household.dtos import EconStateDTO, BioStateDTO, SocialStateDTO
+from simulation.dtos.config_dtos import HouseholdConfigDTO
+from simulation.dtos import LeisureEffectDTO
 from simulation.models import Order
 from modules.system.api import DEFAULT_CURRENCY
 
@@ -97,3 +100,50 @@ class ConsumptionEngine(IConsumptionEngine):
             orders=orders,
             social_state=None # Add if leisure effect implemented
         )
+
+    def apply_leisure_effect(
+        self,
+        leisure_hours: float,
+        consumed_items: Dict[str, float],
+        social_state: SocialStateDTO,
+        econ_state: EconStateDTO,
+        bio_state: BioStateDTO,
+        config: HouseholdConfigDTO
+    ) -> Tuple[SocialStateDTO, EconStateDTO, LeisureEffectDTO]:
+
+        has_children = len(bio_state.children_ids) > 0
+        has_education = consumed_items.get("education_service", 0.0) > 0
+        has_luxury = (consumed_items.get("luxury_food", 0.0) > 0 or consumed_items.get("clothing", 0.0) > 0)
+
+        leisure_type = "SELF_DEV"
+        if has_children and has_education: leisure_type = "PARENTING"
+        elif has_luxury: leisure_type = "ENTERTAINMENT"
+
+        # Update Social State
+        new_social_state = copy.deepcopy(social_state)
+        new_social_state.last_leisure_type = leisure_type
+
+        # Calculate Gains
+        leisure_coeffs = config.leisure_coeffs
+        coeffs = leisure_coeffs.get(leisure_type, {})
+        utility_per_hour = coeffs.get("utility_per_hour", 0.0)
+        xp_gain_per_hour = coeffs.get("xp_gain_per_hour", 0.0)
+        productivity_gain = coeffs.get("productivity_gain", 0.0)
+
+        utility_gained = leisure_hours * utility_per_hour
+        xp_gained = leisure_hours * xp_gain_per_hour
+        prod_gained = leisure_hours * productivity_gain
+
+        # Update Econ State (Skill)
+        new_econ_state = copy.deepcopy(econ_state)
+        if leisure_type == "SELF_DEV" and prod_gained > 0:
+            new_econ_state.labor_skill += prod_gained
+
+        effect_dto = LeisureEffectDTO(
+            leisure_type=leisure_type,
+            leisure_hours=leisure_hours,
+            utility_gained=utility_gained,
+            xp_gained=xp_gained
+        )
+
+        return new_social_state, new_econ_state, effect_dto
diff --git a/simulation/brands/brand_manager.py b/simulation/brands/brand_manager.py
deleted file mode 100644
index 06855ff7..00000000
--- a/simulation/brands/brand_manager.py
+++ /dev/null
@@ -1,56 +0,0 @@
-from __future__ import annotations
-from typing import Dict, Any, Optional, TYPE_CHECKING
-import math
-import logging
-
-if TYPE_CHECKING:
-    from simulation.dtos.config_dtos import FirmConfigDTO
-
-class BrandManager:
-    """
-    Manages a firm's intangible assets: Adstock, Brand Awareness, and Perceived Quality.
-    Based on Phase 6 Spec.
-    """
-    def __init__(self, firm_id: int, config: FirmConfigDTO, logger: Optional[logging.Logger] = None):
-        self.firm_id = firm_id
-        self.config = config
-        self.logger = logger or logging.getLogger(__name__)
-
-        self.adstock = 0.0          # Marketing memory
-        self.brand_awareness = 0.0  # 0.0 ~ 1.0 (S-curve of adstock)
-        self.perceived_quality = 0.0 # Market perception weighting actual quality
-
-    def update(self, marketing_spend: float, actual_quality: float) -> None:
-        """
-        Updates brand assets based on this tick's marketing spend and product quality.
-        """
-        # 1. Adstock Update
-        # Decay old adstock, add new spend (converted to adstock units)
-        decay_rate = self.config.marketing_decay_rate
-        efficiency = self.config.marketing_efficiency
-        
-        # Adstock = (Previous * Decay) + (Spend * Efficiency)
-        self.adstock = (self.adstock * decay_rate) + (marketing_spend * efficiency)
-
-        # 2. Awareness Calculation (Sigmoid/S-Curve)
-        # Using simple 1 - exp(-adstock) as per Spec
-        # Awareness approaches 1.0 as Adstock -> Infinity
-        self.brand_awareness = 1.0 - math.exp(-self.adstock)
-
-        # 3. Perceived Quality Update (EMA)
-        # Q_perc_t = (Q_actual * alpha) + (Q_perc_t-1 * (1-alpha))
-        alpha = self.config.perceived_quality_alpha
-        
-        # Ensure actual_quality is float
-        if actual_quality is None:
-            actual_quality = 0.0
-
-        self.perceived_quality = (actual_quality * alpha) + (self.perceived_quality * (1.0 - alpha))
-
-        if self.logger:
-             self.logger.debug(
-                f"BRAND_UPDATE | Firm {self.firm_id}: Spend={marketing_spend:.1f}, "
-                f"Adstock={self.adstock:.3f}, Awareness={self.brand_awareness:.3f}, "
-                f"ActQ={actual_quality:.2f}, PercQ={self.perceived_quality:.2f}",
-                extra={"agent_id": self.firm_id, "tick": -1, "tags": ["brand"]}
-             )
diff --git a/simulation/components/state/firm_state_models.py b/simulation/components/state/firm_state_models.py
index 90799bd7..ba94641d 100644
--- a/simulation/components/state/firm_state_models.py
+++ b/simulation/components/state/firm_state_models.py
@@ -98,6 +98,11 @@ class SalesState:
     marketing_budget_rate: float = 0.05
     prev_awareness: float = 0.0
 
+    # Brand State
+    adstock: float = 0.0
+    brand_awareness: float = 0.0
+    perceived_quality: float = 0.0
+
     last_prices: Dict[str, float] = field(default_factory=dict) # Prices remain float? Spec says prices can be Decimal/float but transactions are int.
     # Wait, spec says: "Price determination... store as high-precision Decimal".
     # But last_prices is mostly for memory.
diff --git a/simulation/core_agents.py b/simulation/core_agents.py
index b6c618f6..68f01187 100644
--- a/simulation/core_agents.py
+++ b/simulation/core_agents.py
@@ -6,7 +6,6 @@ from collections import deque, defaultdict
 import random
 import copy
 import math
-import warnings
 
 from simulation.decisions.base_decision_engine import BaseDecisionEngine
 from simulation.models import Order, Skill, Talent
@@ -36,7 +35,7 @@ from modules.household.engines.lifecycle import LifecycleEngine
 from modules.household.engines.needs import NeedsEngine
 from modules.household.engines.social import SocialEngine
 from modules.household.engines.budget import BudgetEngine
-from modules.household.engines.consumption import ConsumptionEngine
+from modules.household.engines.consumption_engine import ConsumptionEngine
 
 # API & DTOs
 from modules.household.api import (
@@ -901,98 +900,6 @@ class Household(
             ambition=self._social_state.ambition
         )
 
-    def clone(self, new_id: int, initial_assets_from_parent: int, current_tick: int) -> "Household":
-        """
-        Creates a clone (child) of this household.
-        Used by LifecycleManager/DemographicManager.
-
-        @deprecated: Use HouseholdFactory.create_newborn instead.
-        """
-        warnings.warn("Household.clone() is deprecated. Use HouseholdFactory.create_newborn() instead.", DeprecationWarning, stacklevel=2)
-
-        # 1. Get Offspring Demographics from Lifecycle Engine
-        offspring_demo = self.lifecycle_engine.create_offspring_demographics(
-            self._bio_state, new_id, current_tick
-        )
-
-        # 2. Econ Inheritance (Manual Logic as no EconEngine)
-        # We can implement this helper or keep simplified logic here.
-        # Since EconComponent had `prepare_clone_state`, we should ideally replicate it.
-        # It was simple: 20% of skills, 80% of expected wage.
-        new_skills = {}
-        for domain, skill in self._econ_state.skills.items():
-            new_skills[domain] = Skill(
-                domain=domain,
-                value=skill.value * 0.2,
-                observability=skill.observability
-            )
-
-        # 3. Create Child Instance
-        # ... Reuse init logic via factory or constructor
-        # Since this method is on the class instance, we can't easily use "self.__class__".
-        # We assume "Household" is the class.
-
-        # We need to construct params.
-        # This duplicates __init__ logic a bit or DemographicsManager logic.
-        # DemographicsManager calls this method.
-        # But DemographicsManager ALSO instantiates Household directly in `process_births`.
-        # Wait, I found `process_births` calling `Household(...)` directly in `DemographicManager`.
-        # But `HouseholdReproductionMixin` had `clone`.
-        # The grep showed `clone` usage in tests.
-        # `DemographicManager` comment said "We can use parent.clone() logic but customized."
-        # If `DemographicManager` creates child manually, then `clone` might not be used by it!
-        # `DemographicManager.process_births` code:
-        # child = Household(...)
-        # So `Household.clone` is primarily for tests or legacy.
-        # I will implement `clone` to satisfy tests.
-
-        # Construct Core Config
-        core_config = AgentCoreConfigDTO(
-            id=new_id,
-            name=f"Household_{new_id}",
-            value_orientation=self.value_orientation,
-            initial_needs=self._bio_state.needs.copy(),
-            logger=self.logger,
-            memory_interface=None
-        )
-
-        # New Decision Engine (Basic AI)
-        # We need a decision engine instance.
-        # For simplicity in `clone`, we can reuse parent's engine type or create new.
-        # Tests might expect working engine.
-        # Reuse parent's strategy if possible?
-        # Creating a new AI engine is complex without `ai_trainer`.
-        # I'll try to clone parent's engine or pass `self.decision_engine` (bad).
-        # Tests using `clone` usually mock things.
-        # I'll implement a basic functional clone.
-
-        new_household = Household(
-            core_config=core_config,
-            engine=self.decision_engine, # Warning: Shared engine reference! But engines should be stateless or specific.
-            # If Engine is stateful (AI), this is bad.
-            # But verifying tests will tell.
-            talent=self._econ_state.talent, # Copy talent?
-            goods_data=self.goods_data,
-            personality=self._social_state.personality,
-            config_dto=self.config,
-            loan_market=self.decision_engine.loan_market,
-            risk_aversion=self.risk_aversion,
-            initial_age=offspring_demo["initial_age"],
-            gender=offspring_demo["gender"],
-            parent_id=offspring_demo["parent_id"],
-            generation=offspring_demo["generation"],
-            initial_assets_record=initial_assets_from_parent
-        )
-
-        # Set Econ State
-        new_household._econ_state.skills = new_skills
-        new_household._econ_state.expected_wage_pennies = int(self._econ_state.expected_wage_pennies * 0.8)
-
-        # Hydrate Assets
-        if initial_assets_from_parent > 0:
-            new_household._deposit(initial_assets_from_parent, DEFAULT_CURRENCY)
-
-        return new_household
 
     def initialize_demographics(
         self,
@@ -1067,38 +974,18 @@ class Household(
                 self._econ_state.perceived_avg_prices[item_id] = new_perceived_price
 
     def apply_leisure_effect(self, leisure_hours: float, consumed_items: Dict[str, float]) -> LeisureEffectDTO:
-        # Legacy SocialComponent.apply_leisure_effect logic.
-        # Ideally in ConsumptionEngine.
-        # Implementing here for now.
-        has_children = len(self._bio_state.children_ids) > 0
-        has_education = consumed_items.get("education_service", 0.0) > 0
-        has_luxury = (consumed_items.get("luxury_food", 0.0) > 0 or consumed_items.get("clothing", 0.0) > 0)
-
-        leisure_type = "SELF_DEV"
-        if has_children and has_education: leisure_type = "PARENTING"
-        elif has_luxury: leisure_type = "ENTERTAINMENT"
-
-        self._social_state.last_leisure_type = leisure_type
-
-        leisure_coeffs = self.config.leisure_coeffs
-        coeffs = leisure_coeffs.get(leisure_type, {})
-        utility_per_hour = coeffs.get("utility_per_hour", 0.0)
-        xp_gain_per_hour = coeffs.get("xp_gain_per_hour", 0.0)
-        productivity_gain = coeffs.get("productivity_gain", 0.0)
-
-        utility_gained = leisure_hours * utility_per_hour
-        xp_gained = leisure_hours * xp_gain_per_hour
-        prod_gained = leisure_hours * productivity_gain
-
-        if leisure_type == "SELF_DEV" and prod_gained > 0:
-            self._econ_state.labor_skill += prod_gained
-
-        return LeisureEffectDTO(
-            leisure_type=leisure_type,
-            leisure_hours=leisure_hours,
-            utility_gained=utility_gained,
-            xp_gained=xp_gained
+        # Delegate to ConsumptionEngine
+        new_social, new_econ, result_dto = self.consumption_engine.apply_leisure_effect(
+            leisure_hours,
+            consumed_items,
+            self._social_state,
+            self._econ_state,
+            self._bio_state,
+            self.config
         )
+        self._social_state = new_social
+        self._econ_state = new_econ
+        return result_dto
 
     def consume(self, item_id: str, amount: float, current_tick: int) -> None:
         """
diff --git a/simulation/factories/agent_factory.py b/simulation/factories/agent_factory.py
index 390f7513..b2531075 100644
--- a/simulation/factories/agent_factory.py
+++ b/simulation/factories/agent_factory.py
@@ -25,6 +25,8 @@ class HouseholdFactory:
     """
 
     def __init__(self, config_module: Any):
+        import warnings
+        warnings.warn("simulation.factories.agent_factory.HouseholdFactory is deprecated. Use simulation.factories.household_factory.HouseholdFactory instead.", DeprecationWarning, stacklevel=2)
         self.config_module = config_module
 
     def create_household(
@@ -95,12 +97,16 @@ class HouseholdFactory:
 
         # 5. Hydrate State (Assets)
         initial_state = AgentStateDTO(
-            assets={DEFAULT_CURRENCY: int(initial_assets)},
+            assets={}, # Assets handled separately via deposit for legacy compatibility
             inventory={},
             is_active=True
         )
         agent.load_state(initial_state)
 
+        # Legacy support: Directly deposit assets if provided, as load_state ignores them.
+        if initial_assets > 0:
+            agent._deposit(int(initial_assets), DEFAULT_CURRENCY)
+
         # 6. Additional Initializations
         if spouse_id:
             agent.spouse_id = spouse_id
diff --git a/simulation/factories/firm_factory.py b/simulation/factories/firm_factory.py
new file mode 100644
index 00000000..c3dcd892
--- /dev/null
+++ b/simulation/factories/firm_factory.py
@@ -0,0 +1,113 @@
+from __future__ import annotations
+from typing import Optional, Dict, Any, TYPE_CHECKING
+import logging
+import copy
+from dataclasses import replace
+
+from simulation.firms import Firm
+from simulation.dtos.config_dtos import FirmConfigDTO
+from modules.simulation.api import AgentCoreConfigDTO, AgentStateDTO
+from modules.system.api import DEFAULT_CURRENCY
+from simulation.ai.enums import Personality
+
+if TYPE_CHECKING:
+    from simulation.loan_market import LoanMarket
+
+logger = logging.getLogger(__name__)
+
+class FirmFactory:
+    """
+    Factory for creating Firm agents.
+    Encapsulates creation logic and cloning.
+    """
+
+    def __init__(self, config_module: Any):
+        self.config_module = config_module
+
+    def create_firm(
+        self,
+        agent_id: int,
+        name: str,
+        config_dto: FirmConfigDTO,
+        specialization: str,
+        productivity_factor: float,
+        sector: str = "FOOD",
+        personality: Optional[Personality] = None,
+        initial_inventory: Optional[Dict[str, float]] = None,
+        loan_market: Optional[LoanMarket] = None,
+        decision_engine: Optional[Any] = None,
+        simulation: Optional[Any] = None # For logger/memory access if needed
+    ) -> Firm:
+        """
+        Creates a new Firm agent.
+        """
+        # Core Config
+        core_config = AgentCoreConfigDTO(
+            id=agent_id,
+            name=name,
+            value_orientation="Growth", # Firms usually default to Growth?
+            initial_needs={}, # Firms don't have bio needs
+            logger=logger if not simulation else simulation.logger,
+            memory_interface=None if not simulation else getattr(simulation, "persistence_manager", None)
+        )
+
+        firm = Firm(
+            core_config=core_config,
+            engine=decision_engine, # Must be provided or created externally for now
+            specialization=specialization,
+            productivity_factor=productivity_factor,
+            config_dto=config_dto,
+            initial_inventory=initial_inventory,
+            loan_market=loan_market,
+            sector=sector,
+            personality=personality
+        )
+
+        return firm
+
+    def clone_firm(self, source_firm: Firm, new_id: int, initial_assets_from_parent: int, current_tick: int) -> Firm:
+        """
+        Deep copy / Mitosis logic for Firms.
+        Replaces Firm.clone().
+        """
+        cloned_decision_engine = copy.deepcopy(source_firm.decision_engine)
+
+        # Create new Core Config based on source but with new ID
+        new_core_config = replace(source_firm.get_core_config(), id=new_id, name=f"Firm_{new_id}")
+
+        new_firm = Firm(
+            core_config=new_core_config,
+            engine=cloned_decision_engine,
+            specialization=source_firm.specialization,
+            productivity_factor=source_firm.productivity_factor,
+            config_dto=source_firm.config,
+            initial_inventory=source_firm.get_all_items(),
+            loan_market=source_firm.decision_engine.loan_market,
+            personality=source_firm.personality
+        )
+
+        # Hydrate State
+        # Note: We manually hydrate to ensure clean state
+        initial_state = AgentStateDTO(
+            assets={DEFAULT_CURRENCY: initial_assets_from_parent},
+            inventory=copy.deepcopy(source_firm._inventory),
+            is_active=True
+        )
+        new_firm.load_state(initial_state)
+
+        # Handle internal inventories not covered by AgentStateDTO legacy load
+        new_firm._input_inventory = copy.deepcopy(source_firm._input_inventory)
+        new_firm._input_inventory_quality = copy.deepcopy(source_firm._input_inventory_quality)
+
+        # Preserve quality for main inventory (Fixing potential bug in legacy clone)
+        new_firm.inventory_quality = copy.deepcopy(source_firm.inventory_quality)
+
+        new_firm.logger.info(
+            f"Firm {source_firm.id} was cloned to new Firm {new_id}",
+            extra={
+                "original_agent_id": source_firm.id,
+                "new_agent_id": new_id,
+                "tags": ["lifecycle", "clone"],
+            },
+        )
+        return new_firm
diff --git a/simulation/factories/household_factory.py b/simulation/factories/household_factory.py
new file mode 100644
index 00000000..98356922
--- /dev/null
+++ b/simulation/factories/household_factory.py
@@ -0,0 +1,332 @@
+from __future__ import annotations
+from typing import Optional, Dict, Any, List, TYPE_CHECKING
+import logging
+import random
+import copy
+
+from simulation.core_agents import Household
+from simulation.models import Talent
+from modules.simulation.api import AgentCoreConfigDTO, AgentStateDTO
+from modules.system.api import DEFAULT_CURRENCY
+from simulation.ai.api import Personality
+from modules.household.api import HouseholdFactoryContext, IHouseholdFactory
+
+logger = logging.getLogger(__name__)
+
+class HouseholdFactory(IHouseholdFactory):
+    """
+    Factory for creating Household agents.
+    Encapsulates creation logic, configuration setup, and initial state hydration.
+    """
+
+    def __init__(self, context: HouseholdFactoryContext):
+        self.context = context
+
+    def create_household(
+        self,
+        agent_id: int,
+        initial_age: float,
+        gender: str,
+        initial_assets: int = 0,
+        generation: int = 0,
+        parent_id: Optional[int] = None,
+        spouse_id: Optional[int] = None,
+        personality: Optional[Personality] = None,
+        talent: Optional[Talent] = None,
+        decision_engine: Optional[Any] = None,
+        initial_needs: Optional[Dict[str, float]] = None
+    ) -> Household:
+        """
+        Standard initialization for a Household agent.
+        """
+        # 1. Config Setup (Used from context)
+        hh_config_dto = self.context.household_config_dto
+        core_config_module = self.context.core_config_module
+
+        # 2. Core Config
+        # Value Orientation: Try getting from engine, else config default
+        vo = "Growth"
+        if decision_engine and hasattr(decision_engine, 'value_orientation'):
+            vo = decision_engine.value_orientation
+        else:
+            vo = getattr(core_config_module, 'DEFAULT_VALUE_ORIENTATION', 'Growth')
+
+        # Get initial needs from config if not provided
+        default_initial_needs = getattr(core_config_module, "INITIAL_NEEDS", {})
+
+        core_config = AgentCoreConfigDTO(
+            id=agent_id,
+            name=f"Household_{agent_id}",
+            value_orientation=vo,
+            initial_needs=initial_needs if initial_needs else default_initial_needs.copy(),
+            logger=logger,
+            memory_interface=self.context.memory_system
+        )
+
+        # 3. Defaults if not provided
+        if talent is None:
+            talent = Talent(base_learning_rate=1.0, max_potential={})
+
+        if personality is None:
+            personality = random.choice(list(Personality))
+
+        # 4. Instantiate Household
+        # Note: We pass markets and goods_data from context
+        agent = Household(
+            core_config=core_config,
+            engine=decision_engine,
+            talent=talent,
+            goods_data=self.context.goods_data,
+            personality=personality,
+            config_dto=hh_config_dto,
+            loan_market=self.context.loan_market,
+            risk_aversion=1.0,
+            initial_age=initial_age,
+            gender=gender,
+            parent_id=parent_id,
+            generation=generation,
+            initial_assets_record=int(initial_assets)
+        )
+
+        # 5. Hydrate State (Assets)
+        # Note: Assets are not loaded directly via load_state to ensure SSoT integrity.
+        # Transfers must be handled by the caller (create_newborn, create_immigrant, etc.)
+        initial_state = AgentStateDTO(
+            assets={DEFAULT_CURRENCY: 0},
+            inventory={},
+            is_active=True
+        )
+        agent.load_state(initial_state)
+
+        # 6. Additional Initializations
+        if spouse_id:
+            agent.spouse_id = spouse_id
+
+        agent.education_level = 0
+        base_wage = getattr(core_config_module, "INITIAL_WAGE", 10.0)
+        agent.expected_wage = int(base_wage * 100) # Convert to pennies
+
+        # Inject dependencies
+        agent.decision_engine.markets = self.context.markets
+        agent.decision_engine.goods_data = self.context.goods_data
+        if hasattr(agent, 'settlement_system'):
+            agent.settlement_system = self.context.settlement_system
+
+        # Register with AI Training Manager
+        if self.context.ai_training_manager:
+            self.context.ai_training_manager.agents.append(agent)
+
+        return agent
+
+    def create_newborn(
+        self,
+        parent: Household,
+        new_id: int,
+        initial_assets: int = 0, # This is the gift amount (can be optional/calculated)
+        current_tick: int = 0,
+        simulation: Any = None # Compatibility with old signature, but prefer using self.context
+    ) -> Household:
+        """
+        Creates a newborn household (child) from a parent.
+        Handles inheritance of traits (personality, talent, brain).
+        Enforces Zero-Sum integrity for initial assets (gift).
+        """
+        # 1. Demographics
+        initial_age = 0.0
+        gender = random.choice(["M", "F"])
+        generation = parent.generation + 1
+
+        # 2. Inheritance Logic (Talent, Personality)
+        child_talent = self._inherit_talent(parent.talent)
+        child_personality = self._inherit_personality(parent.personality)
+
+        # 3. Engine Creation (Brain)
+        new_decision_engine = self._create_decision_engine_for_newborn(parent, new_id)
+
+        # 4. Config
+        initial_needs = getattr(self.context.core_config_module, "NEWBORN_INITIAL_NEEDS", None)
+
+        # 5. Create Agent with 0 assets (to be funded via transfer)
+        child = self.create_household(
+            agent_id=new_id,
+            initial_age=initial_age,
+            gender=gender,
+            initial_assets=0,
+            generation=generation,
+            parent_id=parent.id,
+            spouse_id=None,
+            personality=child_personality,
+            talent=child_talent,
+            decision_engine=new_decision_engine,
+            initial_needs=initial_needs
+        )
+
+        # 6. Brain Inheritance (Weights)
+        if self.context.ai_training_manager:
+            self.context.ai_training_manager.inherit_brain(parent, child)
+        else:
+            logger.warning("AITrainingManager not found for brain inheritance.")
+
+        # 7. Zero-Sum Transfer of Gift (if handled here)
+        # Note: If initial_assets is provided, we assume caller wants us to handle transfer.
+        # If caller handles it (like DemographicManager sometimes does), initial_assets should be 0.
+        # But wait, create_newborn signature usually implies logic internal.
+        if initial_assets > 0:
+            if self.context.settlement_system:
+                self.context.settlement_system.transfer(
+                    sender=parent,
+                    receiver=child,
+                    amount=initial_assets,
+                    transaction_type="BIRTH_GIFT",
+                    tick=current_tick
+                )
+            else:
+                logger.error("SettlementSystem missing for birth gift transfer.")
+
+        return child
+
+    def clone_household(self, source_hh: Household, new_id: int, initial_assets: int, current_tick: int) -> Household:
+        """
+        Deep copy / Mitosis logic.
+        Delegates to create_newborn for now as per domain logic (mitosis).
+        If exact clone is needed, different logic would be applied.
+        """
+        return self.create_newborn(source_hh, new_id, initial_assets, current_tick)
+
+    def create_immigrant(
+        self,
+        new_id: int,
+        current_tick: int,
+        initial_assets: int
+    ) -> Household:
+        """Creates a new household representing an immigrant."""
+        # Random demographics
+        age_range = getattr(self.context.core_config_module, "initial_household_age_range", (20, 60))
+        initial_age = random.uniform(*age_range)
+        gender = random.choice(["M", "F"])
+
+        # Logic for immigrant decision engine
+        engine = self._create_default_decision_engine(new_id)
+
+        immigrant = self.create_household(
+            agent_id=new_id,
+            initial_age=initial_age,
+            gender=gender,
+            initial_assets=initial_assets, # Record only
+            decision_engine=engine
+        )
+
+        # Transfer Assets (Minting / Import)
+        if initial_assets > 0:
+            if self.context.central_bank:
+                self.context.settlement_system.create_and_transfer(
+                    source_authority=self.context.central_bank,
+                    destination=immigrant,
+                    amount=int(initial_assets),
+                    reason="IMMIGRATION_GRANT",
+                    tick=current_tick
+                )
+            else:
+                logger.warning(f"CentralBank not found for immigrant {new_id}. Using direct deposit fallback.")
+                immigrant._deposit(int(initial_assets))
+
+        return immigrant
+
+    def create_initial_population(
+        self,
+        num_agents: int
+    ) -> List[Household]:
+        """Creates the initial population of households for the simulation."""
+        agents = []
+        mean_assets = int(getattr(self.context.core_config_module, "initial_household_assets_mean", 1000) * 100) # Pennies
+
+        for i in range(num_agents):
+            agent_id = i
+
+            assets = int(random.gauss(mean_assets, mean_assets * 0.2))
+            assets = max(0, assets)
+
+            age_range = getattr(self.context.core_config_module, "initial_household_age_range", (20, 60))
+            initial_age = random.uniform(*age_range)
+            gender = random.choice(["M", "F"])
+
+            engine = self._create_default_decision_engine(agent_id)
+
+            agent = self.create_household(
+                agent_id=agent_id,
+                initial_age=initial_age,
+                gender=gender,
+                initial_assets=assets,
+                decision_engine=engine
+            )
+
+            # Genesis Funding
+            if assets > 0:
+                if self.context.central_bank:
+                    self.context.settlement_system.create_and_transfer(
+                        source_authority=self.context.central_bank,
+                        destination=agent,
+                        amount=assets,
+                        reason="GENESIS_POPULATION",
+                        tick=0
+                    )
+                else:
+                    # Fallback for genesis if CB missing (unlikely in proper setup)
+                    agent._deposit(assets)
+
+            agents.append(agent)
+
+        return agents
+
+    def _inherit_talent(self, parent_talent: Talent) -> Talent:
+        """Inherit talent with mutation."""
+        new_talent = copy.deepcopy(parent_talent)
+        mutation_range = 0.1
+        new_talent.base_learning_rate *= random.uniform(1.0 - mutation_range, 1.0 + mutation_range)
+        return new_talent
+
+    def _inherit_personality(self, parent_personality: Personality) -> Personality:
+        """Inherit personality with potential mutation."""
+        if random.random() < getattr(self.context.core_config_module, "MITOSIS_MUTATION_PROBABILITY", 0.1):
+            return random.choice(list(Personality))
+        return parent_personality
+
+    def _create_decision_engine_for_newborn(self, parent: Household, agent_id: int) -> Any:
+        """Creates the decision engine for the newborn."""
+        return self._create_engine_logic(agent_id, parent_value_orientation=parent.value_orientation)
+
+    def _create_default_decision_engine(self, agent_id: int) -> Any:
+        return self._create_engine_logic(agent_id)
+
+    def _create_engine_logic(self, agent_id: int, parent_value_orientation: Optional[str] = None) -> Any:
+        newborn_engine_type = getattr(self.context.core_config_module, "NEWBORN_ENGINE_TYPE", "AIDriven")
+
+        if str(newborn_engine_type).upper() == "RULE_BASED":
+            from simulation.decisions.rule_based_household_engine import RuleBasedHouseholdDecisionEngine
+            return RuleBasedHouseholdDecisionEngine(
+                config_module=self.context.core_config_module,
+                logger=logger
+            )
+        else:
+            # AI Driven
+            from simulation.ai.household_ai import HouseholdAI
+            from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
+
+            base_ai_engine = None
+            if self.context.ai_training_manager:
+                # Use parent VO if available, else random or default
+                vo = parent_value_orientation or "Growth"
+                base_ai_engine = self.context.ai_training_manager.get_engine(vo)
+
+            new_ai = HouseholdAI(
+                agent_id=str(agent_id),
+                ai_decision_engine=base_ai_engine,
+            )
+
+            engine = AIDrivenHouseholdDecisionEngine(
+                ai_engine=new_ai,
+                config_module=self.context.core_config_module,
+                logger=logger
+            )
+            engine.loan_market = self.context.loan_market
+            return engine
diff --git a/simulation/firms.py b/simulation/firms.py
index f59c26f4..94ad1ac7 100644
--- a/simulation/firms.py
+++ b/simulation/firms.py
@@ -6,7 +6,6 @@ import copy
 import math
 
 from simulation.models import Order, Transaction
-from simulation.brands.brand_manager import BrandManager
 from simulation.core_agents import Household
 from simulation.markets.order_book_market import OrderBookMarket
 from simulation.decisions.base_decision_engine import BaseDecisionEngine
@@ -27,6 +26,7 @@ from simulation.components.engines.production_engine import ProductionEngine
 from simulation.components.engines.sales_engine import SalesEngine
 from simulation.components.engines.asset_management_engine import AssetManagementEngine
 from simulation.components.engines.rd_engine import RDEngine
+from modules.firm.engines.brand_engine import BrandEngine
 
 from simulation.dtos.context_dtos import PayrollProcessingContext, FinancialTransactionContext, SalesContext
 from simulation.dtos.hr_dtos import HRPayrollContextDTO, TaxPolicyDTO
@@ -162,6 +162,7 @@ class Firm(ILearningAgent, IFinancialAgent, ILiquidatable, IOrchestratorAgent, I
         self.sales_engine = SalesEngine()
         self.asset_management_engine: IAssetManagementEngine = AssetManagementEngine()
         self.rd_engine: IRDEngine = RDEngine()
+        self.brand_engine = BrandEngine()
 
         # Initialize core attributes in State
         self.production_state.specialization = specialization
@@ -184,9 +185,6 @@ class Firm(ILearningAgent, IFinancialAgent, ILiquidatable, IOrchestratorAgent, I
             for item_id, qty in initial_inventory.items():
                 self.add_item(item_id, qty)
 
-        # Brand Manager (Kept as component for now, or could be moved to SalesState/Engine)
-        self.brand_manager = BrandManager(self.id, self.config, self.logger)
-        
         # TD-271: Real Estate Utilization
         self.real_estate_utilization_component = RealEstateUtilizationComponent()
 
@@ -760,8 +758,8 @@ class Firm(ILearningAgent, IFinancialAgent, ILiquidatable, IOrchestratorAgent, I
         sales_dto = SalesStateDTO(
             inventory_last_sale_tick=self.sales_state.inventory_last_sale_tick.copy(),
             price_history=self.sales_state.last_prices.copy(),
-            brand_awareness=self.brand_manager.brand_awareness,
-            perceived_quality=self.brand_manager.perceived_quality,
+            brand_awareness=self.sales_state.brand_awareness,
+            perceived_quality=self.sales_state.perceived_quality,
             marketing_budget=float(self.sales_state.marketing_budget_pennies)
         )
         
@@ -824,42 +822,6 @@ class Firm(ILearningAgent, IFinancialAgent, ILiquidatable, IOrchestratorAgent, I
         if effect and effects_queue is not None:
             effects_queue.append(effect)
 
-    @override
-    def clone(self, new_id: int, initial_assets_from_parent: int, current_tick: int) -> "Firm":
-        cloned_decision_engine = copy.deepcopy(self.decision_engine)
-
-        new_core_config = replace(self.get_core_config(), id=new_id, name=f"Firm_{new_id}")
-
-        new_firm = Firm(
-            core_config=new_core_config,
-            engine=cloned_decision_engine,
-            specialization=self.specialization,
-            productivity_factor=self.productivity_factor,
-            config_dto=self.config,
-            initial_inventory=self.get_all_items(),
-            loan_market=self.decision_engine.loan_market,
-            personality=self.personality
-        )
-
-        # Hydrate State
-        initial_state = AgentStateDTO(
-            assets={DEFAULT_CURRENCY: initial_assets_from_parent},
-            inventory=copy.deepcopy(self._inventory),
-            is_active=True
-        )
-        new_firm.load_state(initial_state)
-        new_firm._input_inventory = copy.deepcopy(self._input_inventory)
-        new_firm._input_inventory_quality = copy.deepcopy(self._input_inventory_quality)
-
-        new_firm.logger.info(
-            f"Firm {self.id} was cloned to new Firm {new_id}",
-            extra={
-                "original_agent_id": self.id,
-                "new_agent_id": new_id,
-                "tags": ["lifecycle", "clone"],
-            },
-        )
-        return new_firm
 
     @override
     def get_agent_data(self) -> Dict[str, Any]:
@@ -944,8 +906,8 @@ class Firm(ILearningAgent, IFinancialAgent, ILiquidatable, IOrchestratorAgent, I
         sales_dto = SalesStateDTO(
             inventory_last_sale_tick=self.sales_state.inventory_last_sale_tick.copy(),
             price_history=self.sales_state.last_prices.copy(),
-            brand_awareness=self.brand_manager.brand_awareness,
-            perceived_quality=self.brand_manager.perceived_quality,
+            brand_awareness=self.sales_state.brand_awareness,
+            perceived_quality=self.sales_state.perceived_quality,
             marketing_budget=float(self.sales_state.marketing_budget_pennies)
         )
 
@@ -1236,8 +1198,8 @@ class Firm(ILearningAgent, IFinancialAgent, ILiquidatable, IOrchestratorAgent, I
 
     def _build_sales_post_ask_context(self, item_id: str, price: float, quantity: float, market_id: str, current_tick: int) -> SalesPostAskContextDTO:
         brand_snapshot = {
-            "brand_awareness": self.brand_manager.brand_awareness,
-            "perceived_quality": self.brand_manager.perceived_quality,
+            "brand_awareness": self.sales_state.brand_awareness,
+            "perceived_quality": self.sales_state.perceived_quality,
             "quality": self.get_quality(item_id),
         }
         return SalesPostAskContextDTO(
@@ -1319,7 +1281,13 @@ class Firm(ILearningAgent, IFinancialAgent, ILiquidatable, IOrchestratorAgent, I
             transactions.append(tx_marketing)
 
         # Brand Update
-        self.brand_manager.update(float(self.sales_state.marketing_budget_pennies), self.productivity_factor / 10.0)
+        self.brand_engine.update(
+            self.sales_state,
+            self.config,
+            float(self.sales_state.marketing_budget_pennies),
+            self.productivity_factor / 10.0,
+            self.id
+        )
 
         # WO-4.6: Finance cleanup is now handled in Post-Sequence via reset()
         # This ensures expenses_this_tick accumulates for the full tick duration.
diff --git a/simulation/initialization/initializer.py b/simulation/initialization/initializer.py
index ee5d9beb..5434faed 100644
--- a/simulation/initialization/initializer.py
+++ b/simulation/initialization/initializer.py
@@ -94,7 +94,7 @@ from modules.system.event_bus.event_bus import EventBus
 from modules.governance.judicial.system import JudicialSystem
 from modules.system.registry import AgentRegistry
 from modules.household.api import HouseholdFactoryContext
-from modules.household.factory import HouseholdFactory
+from simulation.factories.household_factory import HouseholdFactory
 from simulation.utils.config_factory import create_config_dto
 from simulation.dtos.config_dtos import HouseholdConfigDTO
 
@@ -430,16 +430,24 @@ class SimulationInitializer(SimulationInitializerInterface):
         # Note: New agents must be explicitly added to this list by lifecycle managers.
         sim.ai_training_manager = AITrainingManager(sim.households + sim.firms, self.config)
         sim.ma_manager = MAManager(sim, self.config, settlement_system=sim.settlement_system)
-        sim.demographic_manager = DemographicManager(config_module=self.config, strategy=sim.strategy)
-        sim.demographic_manager.settlement_system = sim.settlement_system # Inject SettlementSystem
-        sim.immigration_manager = ImmigrationManager(config_module=self.config, settlement_system=sim.settlement_system)
-        sim.inheritance_manager = InheritanceManager(config_module=self.config)
-        sim.housing_system = HousingSystem(config_module=self.config)
+
         sim.persistence_manager = PersistenceManager(
             run_id=0,
             config_module=self.config,
             repository=self.repository
         )
+
+
+        sim.demographic_manager = DemographicManager(
+            config_module=self.config,
+            strategy=sim.strategy,
+            household_factory=household_factory
+        )
+        sim.demographic_manager.settlement_system = sim.settlement_system # Inject SettlementSystem
+
+        sim.immigration_manager = ImmigrationManager(config_module=self.config, settlement_system=sim.settlement_system)
+        sim.inheritance_manager = InheritanceManager(config_module=self.config)
+        sim.housing_system = HousingSystem(config_module=self.config)
         sim.analytics_system = AnalyticsSystem()
         sim.firm_system = FirmSystem(config_module=self.config, strategy=sim.strategy)
         sim.technology_manager = TechnologyManager(config_module=self.config, logger=self.logger, strategy=sim.strategy)
diff --git a/simulation/systems/demographic_manager.py b/simulation/systems/demographic_manager.py
index 99343946..c73e917c 100644
--- a/simulation/systems/demographic_manager.py
+++ b/simulation/systems/demographic_manager.py
@@ -8,6 +8,7 @@ from simulation.utils.config_factory import create_config_dto
 from simulation.dtos.config_dtos import HouseholdConfigDTO
 from modules.system.api import DEFAULT_CURRENCY
 from modules.simulation.api import AgentCoreConfigDTO, AgentStateDTO, ITalented
+from modules.household.api import IHouseholdFactory
 
 if TYPE_CHECKING:
     from simulation.dtos.strategy import ScenarioStrategy
@@ -27,7 +28,7 @@ class DemographicManager:
             cls._instance = super(DemographicManager, cls).__new__(cls)
         return cls._instance
 
-    def __init__(self, config_module: Any = None, strategy: Optional["ScenarioStrategy"] = None):
+    def __init__(self, config_module: Any = None, strategy: Optional["ScenarioStrategy"] = None, household_factory: Optional[IHouseholdFactory] = None):
         if hasattr(self, "initialized") and self.initialized:
             return
 
@@ -37,8 +38,10 @@ class DemographicManager:
         self.settlement_system: Optional[Any] = None # Injected via Initializer
 
         # Initialize Factory
-        from simulation.factories.agent_factory import HouseholdFactory
-        self.household_factory = HouseholdFactory(config_module)
+        self.household_factory = household_factory
+        # If no factory injected, we warn (since internal creation is complex without context)
+        if not self.household_factory:
+             self.logger.warning("DemographicManager initialized without a HouseholdFactory. Births may fail.")
 
         self.initialized = True
         self.logger.info("DemographicManager initialized.")
diff --git a/tests/modules/household/engines/test_consumption.py b/tests/modules/household/engines/test_consumption.py
index 12f41330..061025bb 100644
--- a/tests/modules/household/engines/test_consumption.py
+++ b/tests/modules/household/engines/test_consumption.py
@@ -1,6 +1,6 @@
 import pytest
 from unittest.mock import MagicMock
-from modules.household.engines.consumption import ConsumptionEngine
+from modules.household.engines.consumption_engine import ConsumptionEngine
 from modules.household.api import ConsumptionInputDTO, BudgetPlan
 from modules.household.dtos import EconStateDTO, BioStateDTO
 from simulation.models import Order
diff --git a/tests/unit/test_firms.py b/tests/unit/test_firms.py
index 1f93b854..db87cd1d 100644
--- a/tests/unit/test_firms.py
+++ b/tests/unit/test_firms.py
@@ -167,9 +167,8 @@ class TestFirmSales:
             sector="FOOD",
             assets=0
         )
-        firm.brand_manager = Mock()
-        firm.brand_manager.brand_awareness = 0.5
-        firm.brand_manager.perceived_quality = 1.0
+        firm.sales_state.brand_awareness = 0.5
+        firm.sales_state.perceived_quality = 1.0
 
         firm.sales_state.marketing_budget_pennies = 100 # 100 pennies
         firm.sales_state.marketing_budget_rate = 0.1
