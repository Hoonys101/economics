diff --git a/communications/insights/Money_Leak_Resolution.md b/communications/insights/Money_Leak_Resolution.md
new file mode 100644
index 0000000..76e5d90
--- /dev/null
+++ b/communications/insights/Money_Leak_Resolution.md
@@ -0,0 +1,45 @@
+# Money Leak Resolution (TD-177)
+
+## Executive Summary
+The persistent 8,000 unit money leak has been diagnosed as a synchronization issue in the Transaction Processing phase, specifically related to Housing Market loans. The `trace_leak.py` script was updated to account for untracked authorized creation, but the housing loan creation remains structurally untracked in the current tick.
+
+## Phenomenon
+- **Leak Magnitude**: 8,000 units per tick (variable based on housing activity).
+- **Observed Behavior**: `Actual Delta` (Physical Money Supply Change) exceeds `Authorized Delta` (Government/CB tracked creation).
+- **Trace Results**:
+    - Infrastructure Spending: 5,000.00 (Funded by assets/transfers, not creation).
+    - CB Bond Purchases: 0.00 (No authorized creation via Bonds).
+    - Housing Loan: 8,000.00 (Observed in logs).
+
+## Root Cause Analysis
+The leak stems from the **Order of Operations in `Phase3_Transaction`**:
+
+1. `Phase3` collects initial transactions (including `Bank.run_tick`).
+2. `Government.process_monetary_transactions` runs on this set.
+3. `TransactionProcessor.execute` runs.
+4. `TransactionProcessor` delegates to `HousingTransactionHandler`.
+5. `HousingTransactionHandler` calls `Bank.grant_loan`, which generates a **new** `credit_creation` transaction (value 8,000).
+6. This new transaction is appended to `state.transactions` *after* step 2.
+7. Consequently, `Government` never processes this new transaction in the current tick.
+8. `Government.total_money_issued` is not incremented.
+9. `get_monetary_delta()` reports 0 for this creation.
+10. `SettlementSystem` executes the transfer immediately (Bank Reserves -> Escrow), increasing M2 by 8,000.
+11. **Result**: Physical M2 increases by 8,000, but Authorized Delta does not. -> **LEAK**.
+
+## Technical Debt & Side Findings
+
+### 1. `Government.reset_tick_flow` is Orphaned
+- **Issue**: The method `reset_tick_flow`, responsible for resetting tick-based counters (like `start_tick_money_issued`), is defined but **never called** in the codebase.
+- **Impact**: `get_monetary_delta` likely returns cumulative values rather than tick-specific deltas. In single-tick traces (where start=0), this masks the issue, but in multi-tick runs, it would yield incorrect data.
+
+### 2. Synchronous Bond Issuance Auditing
+- **Issue**: `FinanceSystem.issue_treasury_bonds_synchronous` performs settlements but does not persist the resulting `Transaction` objects to `world_state.transactions` (it ignores the return value of `settlement.transfer`).
+- **Impact**: While it correctly updates `total_money_issued` (avoiding a leak), it leaves no transaction record in the ledger for that specific bond purchase.
+
+### 3. Infrastructure Spending
+- **Observation**: Infrastructure spending (5,000) was detected but did not contribute to the leak in this specific trace because it was funded by existing Government assets (likely initial assets or tax), not by new money creation.
+
+## Recommendations
+1. **Fix Phase 3 Ordering**: Modify `Phase3_Transaction` to perform a second pass of `process_monetary_transactions` on any new transactions generated by the `TransactionProcessor`.
+2. **Hook Reset Logic**: Call `Government.reset_tick_flow()` in `Phase0_PreSequence` or `TickOrchestrator` to ensure accurate delta tracking.
+3. **Persist Sync Bonds**: Update `FinanceSystem.issue_treasury_bonds_synchronous` to capture and store generated transactions.
diff --git a/scripts/trace_leak.py b/scripts/trace_leak.py
index e705382..dd881c1 100644
--- a/scripts/trace_leak.py
+++ b/scripts/trace_leak.py
@@ -57,6 +57,44 @@ def trace():
     if 'grant_result' in locals() and grant_result:
         authorized_delta += loan_amount
 
+    # --- JULES UPDATE: Account for Fiscal Activities (Infrastructure / Bond Sales) ---
+    # Scan transactions for Central Bank bond purchases (Money Creation)
+    # Scan transactions for Infrastructure Spending (Diagnostic)
+
+    cb_bond_buys = 0.0
+    infra_spending = 0.0
+
+    cb_id = sim.central_bank.id if sim.central_bank else None
+
+    if hasattr(sim.world_state, "transactions"):
+        for tx in sim.world_state.transactions:
+            # Check if tx is object or dict
+            if isinstance(tx, dict):
+                 t_type = tx.get("transaction_type")
+                 t_buyer = tx.get("buyer_id")
+                 t_price = tx.get("price", 0.0)
+                 t_qty = tx.get("quantity", 0.0)
+            else:
+                 t_type = getattr(tx, "transaction_type", None)
+                 t_buyer = getattr(tx, "buyer_id", None)
+                 t_price = getattr(tx, "price", 0.0)
+                 t_qty = getattr(tx, "quantity", 0.0)
+
+            # Bond Purchase by Central Bank (Credit Creation)
+            if t_type == "bond_purchase" and str(t_buyer) == str(cb_id):
+                cb_bond_buys += t_price
+
+            # Infrastructure Spending (Transfer, but useful diagnostic)
+            if t_type == "infrastructure_spending":
+                infra_spending += (t_price * t_qty)
+
+    if cb_bond_buys > 0:
+        print(f"Detected Untracked CB Bond Purchases: {cb_bond_buys:,.2f}")
+        authorized_delta += cb_bond_buys
+
+    if infra_spending > 0:
+        print(f"Detected Infrastructure Spending: {infra_spending:,.2f}")
+
     print(f"\nTick 1 (END) Total Money: {current_money:,.2f}")
     print(f"Baseline: {baseline_money:,.2f}")
     print(f"Authorized Delta (Minted - Destroyed + Credit): {authorized_delta:,.2f}")
