diff --git a/communications/insights/phase23-legacy-cleanup.md b/communications/insights/phase23-legacy-cleanup.md
new file mode 100644
index 00000000..d8088c3a
--- /dev/null
+++ b/communications/insights/phase23-legacy-cleanup.md
@@ -0,0 +1,58 @@
+# Phase 23 Legacy API Cleanup & Integrity Enforcement
+
+## 1. Architectural Insights
+
+### Legacy DTO Cleaned: `StockOrder`
+- **Action**: Removed legacy support for `StockOrder` duck-typing in `modules/market/api.py`.
+- **Reason**: The system now strictly enforces `CanonicalOrderDTO`. The legacy `StockOrder` class was previously removed from models but adapter logic persisted.
+- **Impact**: Eliminates ambiguity in order processing and ensures all market interactions use the standardized immutable DTO.
+
+### Protocol Purity: `MonetaryTransactionHandler`
+- **Action**: Refactored `MonetaryTransactionHandler` to remove `hasattr` checks on `Government` for `total_money_issued` and `total_money_destroyed`.
+- **Logic Separation**: Shifted the responsibility of tracking money creation/destruction entirely to `MonetaryLedger` (via `Phase3_Transaction`), which now scans successful transactions.
+- **Expansion Logic**: Updated `MonetaryLedger` to explicitly recognize `lender_of_last_resort` and `asset_liquidation` as monetary expansion events, ensuring accurate M2 tracking without manual intervention from handlers.
+- **Protocol Usage**: Enforced `IInvestor` and `IPropertyOwner` protocols for side-effect handling (e.g., updating portfolios during liquidation), replacing legacy `hasattr` checks on `Household` and `Firm`.
+
+### Test Modernization
+- **Action**: Rewrote `tests/unit/test_transaction_handlers.py`.
+- **Legacy Removal**: Removed tests that verified deprecated 3-step Escrow logic for `GoodsTransactionHandler`.
+- **New Standard**: Updated tests to verify `SettlementSystem.settle_atomic` usage, ensuring that transaction atomicity is correctly exercised by handlers.
+
+## 2. Test Evidence
+
+### Monetary Ledger Expansion Tracking
+New tests verify that `lender_of_last_resort` and `asset_liquidation` correctly increase `total_money_issued` in the ledger.
+
+```text
+tests/unit/modules/government/components/test_monetary_ledger_expansion.py::TestMonetaryLedgerExpansion::test_asset_liquidation_expansion PASSED
+tests/unit/modules/government/components/test_monetary_ledger_expansion.py::TestMonetaryLedgerExpansion::test_lender_of_last_resort_expansion PASSED
+tests/unit/modules/government/components/test_monetary_ledger_expansion.py::TestMonetaryLedgerExpansion::test_other_types_no_expansion PASSED
+```
+
+### Transaction Handlers (Atomic Settlement)
+Verified that handlers correctly delegate to `settle_atomic` instead of manual transfers.
+
+```text
+tests/unit/test_transaction_handlers.py::TestGoodsTransactionHandler::test_goods_settle_fail PASSED
+tests/unit/test_transaction_handlers.py::TestGoodsTransactionHandler::test_goods_success_atomic PASSED
+tests/unit/test_transaction_handlers.py::TestLaborTransactionHandler::test_labor_atomic_settlement PASSED
+```
+
+### Market Adapter (DTO Purity)
+Verified that the adapter still handles dictionaries correctly while legacy object support is removed.
+
+```text
+tests/unit/test_market_adapter.py::TestMarketAdapter::test_pass_through PASSED
+tests/unit/test_market_adapter.py::TestMarketAdapter::test_convert_dict_legacy_format PASSED
+tests/unit/test_market_adapter.py::TestMarketAdapter::test_convert_dict_canonical_format PASSED
+tests/unit/test_market_adapter.py::TestMarketAdapter::test_invalid_input PASSED
+```
+
+### Monetary Ledger Repayment (Regression Check)
+Ensured existing repayment logic remains intact.
+
+```text
+tests/unit/test_monetary_ledger_repayment.py::TestMonetaryLedgerRepayment::test_bond_repayment_split PASSED
+tests/unit/test_monetary_ledger_repayment.py::TestMonetaryLedgerRepayment::test_bond_repayment_legacy_fallback PASSED
+tests/unit/test_monetary_ledger_repayment.py::TestMonetaryLedgerRepayment::test_interest_is_not_destroyed PASSED
+```
diff --git a/modules/finance/api.py b/modules/finance/api.py
index 35c551f6..a1e7e154 100644
--- a/modules/finance/api.py
+++ b/modules/finance/api.py
@@ -903,3 +903,15 @@ class SolvencyEngine(Protocol):
             A DTO reporting solvency status, net worth, and key ratios.
         """
         ...
+
+@runtime_checkable
+class IIncomeTracker(Protocol):
+    """Protocol for entities that track their income sources."""
+    def add_labor_income(self, amount: int) -> None:
+        ...
+
+@runtime_checkable
+class IConsumptionTracker(Protocol):
+    """Protocol for entities that track their consumption expenditure."""
+    def add_consumption_expenditure(self, amount: int, item_id: Optional[str] = None) -> None:
+        ...
diff --git a/modules/finance/transaction/handlers/__init__.py b/modules/finance/transaction/handlers/__init__.py
deleted file mode 100644
index 538452cd..00000000
--- a/modules/finance/transaction/handlers/__init__.py
+++ /dev/null
@@ -1,2 +0,0 @@
-from .goods import GoodsTransactionHandler
-from .labor import LaborTransactionHandler
diff --git a/modules/finance/transaction/handlers/goods.py b/modules/finance/transaction/handlers/goods.py
deleted file mode 100644
index 36c77611..00000000
--- a/modules/finance/transaction/handlers/goods.py
+++ /dev/null
@@ -1,122 +0,0 @@
-from typing import Any
-import logging
-from simulation.models import Transaction
-from simulation.dtos.api import SimulationState
-from simulation.systems.api import ISpecializedTransactionHandler
-from modules.finance.utils.currency_math import round_to_pennies
-from modules.finance.transaction.handlers.protocols import ISolvent, ITaxCollector, IConsumptionTracker
-
-logger = logging.getLogger(__name__)
-
-class GoodsTransactionHandler(ISpecializedTransactionHandler):
-    """
-    Handles 'goods' transactions using atomic escrow and sales tax logic.
-    """
-
-    def handle(self, tx: Transaction, buyer: Any, seller: Any, state: SimulationState) -> bool:
-        settlement = state.settlement_system
-        government = state.government
-        escrow_agent = state.escrow_agent
-        config = state.config_module
-        sys_logger = state.logger or logger
-
-        if not settlement:
-            sys_logger.error("GoodsTransactionHandler: Settlement system not available in state.")
-            return False
-
-        if not escrow_agent:
-            sys_logger.error("GoodsTransactionHandler: Escrow agent not available in state.")
-            return False
-
-        if not government:
-            sys_logger.error("GoodsTransactionHandler: Government not available in state.")
-            return False
-
-        trade_value = int(tx.quantity * tx.price)
-        if tx.total_pennies > 0:
-            trade_value = tx.total_pennies
-
-        # Sales Tax Logic
-        sales_tax_rate = getattr(config, "SALES_TAX_RATE", 0.05)
-        tax_amount = round_to_pennies(trade_value * sales_tax_rate)
-        total_cost = trade_value + tax_amount
-
-        # Solvency Check (Legacy compatibility)
-        # Using Protocol check instead of hasattr
-        if isinstance(buyer, ISolvent):
-             try:
-                 if buyer.assets < total_cost:
-                     buyer.check_solvency(government)
-             except Exception:
-                 pass
-
-        # --- 3-Step Escrow Logic (Atomic) ---
-        # 1. Secure Total Amount in Escrow
-        memo_escrow = f"escrow_hold:{tx.item_id}"
-        escrow_success = settlement.transfer(
-            buyer,
-            escrow_agent,
-            total_cost,
-            memo_escrow
-        )
-
-        if not escrow_success:
-            return False
-
-        # 2. Distribute Funds from Escrow
-        try:
-            # 2a. Pay Seller
-            memo_trade = f"goods_trade:{tx.item_id}"
-            trade_success = settlement.transfer(
-                escrow_agent,
-                seller,
-                trade_value,
-                memo_trade
-            )
-
-            if not trade_success:
-                # Critical Failure: Funds stuck in escrow. Rollback buyer.
-                sys_logger.critical(f"ESCROW_FAIL | Trade transfer to seller failed. Rolling back {total_cost} to buyer {buyer.id}.")
-                settlement.transfer(escrow_agent, buyer, total_cost, "escrow_reversal:trade_failure")
-                return False
-
-            # 2b. Pay Tax to Government
-            if tax_amount > 0:
-                memo_tax = f"sales_tax:{tx.item_id}"
-                # Push tax to Government via Settlement
-                tax_success = settlement.transfer(
-                    escrow_agent,
-                    government,
-                    tax_amount,
-                    memo_tax
-                )
-
-                if not tax_success:
-                    # Critical Failure: Tax transfer failed. Rollback everything.
-                    sys_logger.critical(f"ESCROW_FAIL | Tax transfer to government failed. Rolling back trade and escrow.")
-                    # Revert seller payment
-                    settlement.transfer(seller, escrow_agent, trade_value, "reversal:tax_failure")
-                    # Return all to buyer
-                    settlement.transfer(escrow_agent, buyer, total_cost, "escrow_reversal:tax_failure")
-                    return False
-
-                # Explicitly record tax revenue since we bypassed collect_tax
-                if isinstance(government, ITaxCollector):
-                    government.record_revenue({
-                        "success": True,
-                        "amount_collected": tax_amount,
-                        "tax_type": f"sales_tax_{tx.transaction_type}",
-                        "payer_id": buyer.id,
-                        "payee_id": government.id,
-                        "error_message": None
-                    })
-
-            # Track Consumption Expenditure (Confirmed Success)
-            if isinstance(buyer, IConsumptionTracker):
-                buyer.add_consumption_expenditure(total_cost, item_id=tx.item_id)
-
-            return True
-
-        except Exception as e:
-            sys_logger.exception(f"ESCROW_EXCEPTION | Unexpected error during distribution: {e}")
-            return False
diff --git a/modules/finance/transaction/handlers/labor.py b/modules/finance/transaction/handlers/labor.py
deleted file mode 100644
index 2d42d7a2..00000000
--- a/modules/finance/transaction/handlers/labor.py
+++ /dev/null
@@ -1,117 +0,0 @@
-from typing import Any
-import logging
-from simulation.models import Transaction
-from simulation.dtos.api import SimulationState
-from simulation.systems.api import ISpecializedTransactionHandler
-from modules.finance.utils.currency_math import round_to_pennies
-from modules.government.constants import DEFAULT_BASIC_FOOD_PRICE
-from modules.finance.transaction.handlers.protocols import ITaxCollector, IIncomeTracker
-
-logger = logging.getLogger(__name__)
-
-class LaborTransactionHandler(ISpecializedTransactionHandler):
-    """
-    Handles 'labor' and 'research_labor' transactions, including income tax withholding.
-    """
-
-    def handle(self, tx: Transaction, buyer: Any, seller: Any, state: SimulationState) -> bool:
-        settlement = state.settlement_system
-        government = state.government
-        config = state.config_module
-        sys_logger = state.logger or logger
-        current_time = state.time
-
-        if not settlement:
-            sys_logger.error("LaborTransactionHandler: Settlement system not available in state.")
-            return False
-
-        if not government:
-            sys_logger.error("LaborTransactionHandler: Government not available in state.")
-            return False
-
-        # Calculate trade value (SSoT: total_pennies)
-        trade_value = 0
-        if tx.total_pennies > 0:
-            trade_value = tx.total_pennies
-        else:
-            trade_value = int(tx.quantity * tx.price)
-
-        # Market Data Access
-        goods_market_data = state.market_data.get("goods_market", {}) if state.market_data else {}
-
-        # Income Tax Logic
-        tax_payer = getattr(config, "INCOME_TAX_PAYER", "HOUSEHOLD")
-
-        # Standardized price handling for survival cost calculation
-        avg_food_price_pennies = 0
-        if "basic_food_current_sell_price" in goods_market_data:
-            val = goods_market_data["basic_food_current_sell_price"]
-            if isinstance(val, float):
-                 avg_food_price_pennies = round_to_pennies(val * 100)
-            else:
-                 avg_food_price_pennies = int(val)
-        else:
-            val = getattr(config, "GOODS_INITIAL_PRICE", {}).get("basic_food", DEFAULT_BASIC_FOOD_PRICE)
-            if isinstance(val, float):
-                 avg_food_price_pennies = round_to_pennies(val * 100)
-            else:
-                 avg_food_price_pennies = int(val)
-
-        daily_food_need = getattr(config, "HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK", 1.0)
-
-        # Survival cost in pennies, max 1000 pennies ($10) as baseline protection
-        survival_cost = int(max(avg_food_price_pennies * daily_food_need, 1000))
-
-        # Calculate Tax (Standardized method call on Gov)
-        # Note: calculate_income_tax is on Government agent.
-        tax_amount = 0
-        if isinstance(government, ITaxCollector):
-            tax_amount = int(government.calculate_income_tax(trade_value, survival_cost))
-        else:
-             sys_logger.warning("LaborTransactionHandler: Government does not implement ITaxCollector.")
-
-        if tax_payer == "FIRM":
-            # Firm pays Wage to Household AND Tax to Gov Atomically
-            credits = [(seller, trade_value, f"labor_wage:{tx.transaction_type}")]
-            if tax_amount > 0:
-                credits.append((government, tax_amount, "income_tax_firm"))
-
-            success = settlement.settle_atomic(
-                debit_agent=buyer,
-                credits_list=credits,
-                tick=current_time
-            )
-
-            if success and tax_amount > 0 and isinstance(government, ITaxCollector):
-                government.record_revenue({
-                    "success": True,
-                    "amount_collected": tax_amount,
-                    "tax_type": "income_tax_firm",
-                    "payer_id": buyer.id,
-                    "payee_id": government.id
-                })
-        else:
-            # Household pays tax (Withholding model)
-            # Pay GROSS wage to household
-            success = settlement.transfer(buyer, seller, trade_value, f"labor_wage_gross:{tx.transaction_type}")
-            if success and tax_amount > 0:
-                # Then collect tax from household
-                tax_success = settlement.settle_atomic(
-                    debit_agent=seller,
-                    credits_list=[(government, tax_amount, "income_tax_household")],
-                    tick=current_time
-                )
-
-                if tax_success and isinstance(government, ITaxCollector):
-                    government.record_revenue({
-                        "success": True,
-                        "amount_collected": tax_amount,
-                        "tax_type": "income_tax_household",
-                        "payer_id": seller.id,
-                        "payee_id": government.id
-                    })
-
-        if success and isinstance(seller, IIncomeTracker):
-            seller.add_labor_income(trade_value)
-
-        return success
diff --git a/modules/finance/transaction/handlers/protocols.py b/modules/finance/transaction/handlers/protocols.py
deleted file mode 100644
index 46faabff..00000000
--- a/modules/finance/transaction/handlers/protocols.py
+++ /dev/null
@@ -1,33 +0,0 @@
-from typing import Protocol, runtime_checkable, Any, Optional
-
-@runtime_checkable
-class ISolvent(Protocol):
-    """Protocol for agents that can check their own solvency."""
-    @property
-    def assets(self) -> float:
-        ...
-
-    def check_solvency(self, government: Any) -> None:
-        ...
-
-@runtime_checkable
-class ITaxCollector(Protocol):
-    """Protocol for entities that can calculate and collect taxes (e.g., Government)."""
-
-    def calculate_income_tax(self, income: int, deduction: int) -> int:
-        ...
-
-    def record_revenue(self, data: Any) -> None:
-        ...
-
-@runtime_checkable
-class IIncomeTracker(Protocol):
-    """Protocol for entities that track their income sources."""
-    def add_labor_income(self, amount: int) -> None:
-        ...
-
-@runtime_checkable
-class IConsumptionTracker(Protocol):
-    """Protocol for entities that track their consumption expenditure."""
-    def add_consumption_expenditure(self, amount: int, item_id: Optional[str] = None) -> None:
-        ...
diff --git a/modules/government/components/monetary_ledger.py b/modules/government/components/monetary_ledger.py
index bc618322..36164ee7 100644
--- a/modules/government/components/monetary_ledger.py
+++ b/modules/government/components/monetary_ledger.py
@@ -48,7 +48,7 @@ class MonetaryLedger:
             # TD-030 Revert: Since M2 definition now excludes Bank Reserves, transfers from Bank to Public (Interest/Profit)
             # must be tracked as M2 Expansion.
             # UPDATE: Re-aligning with Memory and Tests -> Neutral transfers.
-            if tx.transaction_type in ["credit_creation", "money_creation", "bank_dividend"]:
+            if tx.transaction_type in ["credit_creation", "money_creation", "bank_dividend", "lender_of_last_resort", "asset_liquidation"]:
                 is_expansion = True
 
             # 2. CB Buying (OMO Purchase / Bond Purchase) -> Expansion
diff --git a/modules/market/api.py b/modules/market/api.py
index 1bf10c83..507756b8 100644
--- a/modules/market/api.py
+++ b/modules/market/api.py
@@ -107,24 +107,6 @@ def convert_legacy_order_to_canonical(order: Any) -> CanonicalOrderDTO:
             currency=order.get("currency", DEFAULT_CURRENCY)
         )
 
-    # Handle Legacy StockOrder (duck typing to avoid circular import)
-    if hasattr(order, "firm_id") and hasattr(order, "order_type") and hasattr(order, "price"):
-        # Determine price_pennies based on type of order.price
-        if isinstance(order.price, float):
-            price_pennies = int(order.price * 100)
-        else:
-            price_pennies = int(order.price)
-
-        return CanonicalOrderDTO(
-            agent_id=order.agent_id,
-            side=order.order_type,
-            item_id=f"stock_{order.firm_id}",
-            quantity=order.quantity,
-            price_pennies=price_pennies,
-            price_limit=float(order.price),
-            market_id=getattr(order, "market_id", "stock_market"),
-        )
-
     raise ValueError(f"Cannot convert object of type {type(order)} to CanonicalOrderDTO")
 
 # --- Data Transfer Objects (DTOs) ---
diff --git a/simulation/systems/handlers/goods_handler.py b/simulation/systems/handlers/goods_handler.py
index 2f1a878d..0377405d 100644
--- a/simulation/systems/handlers/goods_handler.py
+++ b/simulation/systems/handlers/goods_handler.py
@@ -146,3 +146,7 @@ class GoodsTransactionHandler(ITransactionHandler):
                 is_food = (tx.item_id == "basic_food")
                 if hasattr(buyer, "record_consumption"):
                     buyer.record_consumption(tx.quantity, is_food=is_food)
+
+            # Track Consumption Expenditure (Financial)
+            if hasattr(buyer, "add_consumption_expenditure"):
+                buyer.add_consumption_expenditure(buyer_total_cost, item_id=tx.item_id)
diff --git a/simulation/systems/handlers/monetary_handler.py b/simulation/systems/handlers/monetary_handler.py
index 7536c109..f8ea463c 100644
--- a/simulation/systems/handlers/monetary_handler.py
+++ b/simulation/systems/handlers/monetary_handler.py
@@ -15,6 +15,10 @@ class MonetaryTransactionHandler(ITransactionHandler):
     - asset_liquidation (Minting + Asset Transfer)
     - bond_purchase / omo_purchase (Minting / QE)
     - bond_repayment / omo_sale (Burning / QT)
+
+    Zero-Sum Integrity:
+    - Transfers are handled by SettlementSystem.
+    - Money Creation/Destruction (M2 Delta) is tracked by MonetaryLedger via Phase3_Transaction.
     """
 
     def handle(self, tx: Transaction, buyer: Any, seller: Any, context: TransactionContext) -> bool:
@@ -26,26 +30,14 @@ class MonetaryTransactionHandler(ITransactionHandler):
             context.logger.error("MonetaryHandler: Central Bank missing in context.")
             return False
 
-        # Central Bank System wrapper usually handles mint/burn but context has central_bank agent.
-        # We need to access mint/burn methods if they exist on CentralBank agent or use SettlementSystem helpers.
-        # SettlementSystem has 'create_and_transfer' and 'transfer_and_destroy'.
-
         success = False
 
         if tx_type == "lender_of_last_resort":
             # Minting: Central Bank (Buyer/Source) -> Bank/Agent (Seller/Target)
-            # Typically Buyer is System/Gov/CB. Seller is the one receiving money.
-            # TransactionProcessor logic: "success = settlement.transfer(buyer, seller, ...)"
-            # Wait, TP used settlement.transfer.
-            # If buyer is CentralBank, settlement.transfer should handle minting if it detects CB?
-            # SettlementSystem._execute_withdrawal checks if agent is CB and allows infinite withdraw.
-            # So simple transfer from CB works for minting.
-
             success = context.settlement_system.transfer(
                 buyer, seller, int(trade_value), "lender_of_last_resort"
             )
-            if success and hasattr(buyer, "total_money_issued"):
-                buyer.total_money_issued += trade_value
+            # Ledger accounting is done in Phase3_Transaction via MonetaryLedger
 
         elif tx_type == "asset_liquidation":
             # Minting: Gov/CB (Buyer) -> Agent (Seller)
@@ -53,9 +45,6 @@ class MonetaryTransactionHandler(ITransactionHandler):
                 buyer, seller, int(trade_value), "asset_liquidation"
             )
             if success:
-                if hasattr(buyer, "total_money_issued"):
-                    buyer.total_money_issued += trade_value
-
                 # Asset Transfer Logic (Stock/RE)
                 self._apply_asset_liquidation_effects(tx, buyer, seller, context)
 
@@ -69,9 +58,7 @@ class MonetaryTransactionHandler(ITransactionHandler):
             success = context.settlement_system.transfer(
                 buyer, seller, int(trade_value), tx_type
             )
-            if success and context.central_bank and buyer.id == context.central_bank.id:
-                 if hasattr(context.government, "total_money_issued"):
-                     context.government.total_money_issued += trade_value
+            if success:
                  context.logger.info(
                      f"QE | Central Bank purchased bond/asset {trade_value:.2f}.",
                      extra={"tick": context.time, "tag": "QE"}
@@ -83,9 +70,7 @@ class MonetaryTransactionHandler(ITransactionHandler):
             success = context.settlement_system.transfer(
                 buyer, seller, int(trade_value), tx_type
             )
-            if success and context.central_bank and seller.id == context.central_bank.id:
-                if hasattr(context.government, "total_money_destroyed"):
-                    context.government.total_money_destroyed += trade_value
+            if success:
                 context.logger.info(
                     f"QT | Central Bank sold bond/asset {trade_value:.2f}.",
                     extra={"tick": context.time, "tag": "QT"}
@@ -111,12 +96,6 @@ class MonetaryTransactionHandler(ITransactionHandler):
         # 1. Seller Holdings
         if isinstance(seller, IInvestor):
             seller.portfolio.remove(firm_id, tx.quantity)
-        elif isinstance(seller, Household) and hasattr(seller, "shares_owned"):
-             # Legacy Fallback
-            current_shares = seller.shares_owned.get(firm_id, 0)
-            seller.shares_owned[firm_id] = max(0, current_shares - tx.quantity)
-            if seller.shares_owned[firm_id] <= 0 and firm_id in seller.shares_owned:
-                del seller.shares_owned[firm_id]
         elif isinstance(seller, Firm) and seller.id == firm_id:
             seller.treasury_shares = max(0, seller.treasury_shares - tx.quantity)
 
@@ -124,21 +103,23 @@ class MonetaryTransactionHandler(ITransactionHandler):
         if isinstance(buyer, IInvestor):
             price_pennies = int(tx.total_pennies / tx.quantity) if tx.quantity > 0 else 0
             buyer.portfolio.add(firm_id, tx.quantity, price_pennies)
-        elif isinstance(buyer, Household) and hasattr(buyer, "shares_owned"):
-            # Legacy Fallback
-            buyer.shares_owned[firm_id] = buyer.shares_owned.get(firm_id, 0) + tx.quantity
         elif isinstance(buyer, Firm) and buyer.id == firm_id:
             buyer.treasury_shares += tx.quantity
             buyer.total_shares -= tx.quantity
 
         # 3. Market Registry
         if context.stock_market:
+            # Update Shareholder Registry via StockMarket facade if available
+            buyer_qty = 0.0
             if isinstance(buyer, IInvestor) and firm_id in buyer.portfolio.holdings:
-                 context.stock_market.update_shareholder(buyer.id, firm_id, buyer.portfolio.holdings[firm_id].quantity)
+                 buyer_qty = buyer.portfolio.holdings[firm_id].quantity
+
+            seller_qty = 0.0
             if isinstance(seller, IInvestor) and firm_id in seller.portfolio.holdings:
-                context.stock_market.update_shareholder(seller.id, firm_id, seller.portfolio.holdings[firm_id].quantity)
-            else:
-                context.stock_market.update_shareholder(seller.id, firm_id, 0.0)
+                 seller_qty = seller.portfolio.holdings[firm_id].quantity
+
+            context.stock_market.update_shareholder(buyer.id, firm_id, buyer_qty)
+            context.stock_market.update_shareholder(seller.id, firm_id, seller_qty)
 
     def _handle_real_estate_side_effect(self, tx: Transaction, buyer: Any, seller: Any, context: TransactionContext):
         try:
diff --git a/tests/integration/test_reporting_pennies.py b/tests/integration/test_reporting_pennies.py
index 93ef1c97..8d720385 100644
--- a/tests/integration/test_reporting_pennies.py
+++ b/tests/integration/test_reporting_pennies.py
@@ -2,12 +2,12 @@ import pytest
 from unittest.mock import MagicMock, Mock
 from simulation.core_agents import Household
 from modules.household.dtos import EconStateDTO
-from modules.finance.transaction.handlers.goods import GoodsTransactionHandler
-from modules.finance.transaction.handlers.labor import LaborTransactionHandler
+from simulation.systems.handlers.goods_handler import GoodsTransactionHandler
+from simulation.systems.handlers.labor_handler import LaborTransactionHandler
 from simulation.models import Transaction
 from simulation.metrics.economic_tracker import EconomicIndicatorTracker
 from modules.simulation.dtos.api import HouseholdConfigDTO
-from modules.finance.transaction.handlers.protocols import IIncomeTracker, IConsumptionTracker
+from modules.finance.api import IIncomeTracker, IConsumptionTracker
 
 @pytest.fixture
 def mock_config():
@@ -103,10 +103,11 @@ class TestReportingPennies:
     def test_goods_handler_calls_tracker(self, household):
         handler = GoodsTransactionHandler()
         state = MagicMock()
-        state.settlement_system.transfer.return_value = True
+        state.settlement_system.settle_atomic.return_value = True
         state.escrow_agent = MagicMock()
         state.government = MagicMock()
         state.config_module.SALES_TAX_RATE = 0.0
+        state.taxation_system.calculate_tax_intents.return_value = [] # No tax for simplicity
 
         tx = Transaction(
             buyer_id=household.id, seller_id=2, item_id="food",
@@ -129,11 +130,12 @@ class TestReportingPennies:
     def test_labor_handler_calls_tracker(self, household):
         handler = LaborTransactionHandler()
         state = MagicMock()
-        state.settlement_system.transfer.return_value = True
+        state.settlement_system.settle_atomic.return_value = True
         state.government = MagicMock()
         state.config_module.INCOME_TAX_PAYER = "FIRM" # Simple case
         state.config_module.HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK = 1.0
         state.config_module.GOODS_INITIAL_PRICE = {}
+        state.taxation_system.calculate_tax_intents.return_value = []
 
         tx = Transaction(
             buyer_id=2, seller_id=household.id, item_id="labor",
diff --git a/tests/unit/modules/government/components/test_monetary_ledger_expansion.py b/tests/unit/modules/government/components/test_monetary_ledger_expansion.py
new file mode 100644
index 00000000..ea8f0c43
--- /dev/null
+++ b/tests/unit/modules/government/components/test_monetary_ledger_expansion.py
@@ -0,0 +1,46 @@
+import unittest
+from unittest.mock import MagicMock
+from modules.government.components.monetary_ledger import MonetaryLedger
+from simulation.models import Transaction
+from modules.system.api import DEFAULT_CURRENCY
+
+class TestMonetaryLedgerExpansion(unittest.TestCase):
+    def setUp(self):
+        self.ledger = MonetaryLedger()
+        self.ledger.reset_tick_flow()
+
+    def test_lender_of_last_resort_expansion(self):
+        tx = MagicMock(spec=Transaction)
+        tx.transaction_type = "lender_of_last_resort"
+        tx.price = 5000
+        tx.quantity = 1
+        tx.currency = DEFAULT_CURRENCY
+
+        self.ledger.process_transactions([tx])
+
+        self.assertEqual(self.ledger.total_money_issued[DEFAULT_CURRENCY], 5000)
+        self.assertEqual(self.ledger.credit_delta_this_tick[DEFAULT_CURRENCY], 5000)
+
+    def test_asset_liquidation_expansion(self):
+        tx = MagicMock(spec=Transaction)
+        tx.transaction_type = "asset_liquidation"
+        tx.price = 10000
+        tx.quantity = 1
+        tx.currency = DEFAULT_CURRENCY
+
+        self.ledger.process_transactions([tx])
+
+        self.assertEqual(self.ledger.total_money_issued[DEFAULT_CURRENCY], 10000)
+        self.assertEqual(self.ledger.credit_delta_this_tick[DEFAULT_CURRENCY], 10000)
+
+    def test_other_types_no_expansion(self):
+        tx = MagicMock(spec=Transaction)
+        tx.transaction_type = "goods"
+        tx.price = 100
+        tx.quantity = 1
+        tx.currency = DEFAULT_CURRENCY
+
+        self.ledger.process_transactions([tx])
+
+        self.assertEqual(self.ledger.total_money_issued[DEFAULT_CURRENCY], 0)
+        self.assertEqual(self.ledger.credit_delta_this_tick.get(DEFAULT_CURRENCY, 0), 0)
diff --git a/tests/unit/test_transaction_handlers.py b/tests/unit/test_transaction_handlers.py
index 38a7dd7c..929cbc16 100644
--- a/tests/unit/test_transaction_handlers.py
+++ b/tests/unit/test_transaction_handlers.py
@@ -1,24 +1,29 @@
 import unittest
 from unittest.mock import MagicMock, ANY
-from modules.finance.transaction.handlers import GoodsTransactionHandler, LaborTransactionHandler
-from modules.finance.transaction.handlers.protocols import ISolvent, ITaxCollector
+from simulation.systems.handlers.goods_handler import GoodsTransactionHandler
+from simulation.systems.handlers.labor_handler import LaborTransactionHandler
+from modules.finance.api import IFinancialAgent
 from simulation.models import Transaction
 from simulation.dtos.api import SimulationState
 from simulation.agents.government import Government
+from modules.government.taxation.system import TaxationSystem
 
 class TestGoodsTransactionHandler(unittest.TestCase):
     def setUp(self):
         self.handler = GoodsTransactionHandler()
         self.settlement = MagicMock()
 
-        # Mock Government with Government class spec
+        # Mock Government
         self.government = MagicMock(spec=Government)
         self.government.id = 99
 
         self.escrow_agent = MagicMock()
         self.config = MagicMock()
         self.logger = MagicMock()
-        self.state = MagicMock(spec=SimulationState)
+        self.taxation_system = MagicMock(spec=TaxationSystem)
+
+        # Use simple MagicMock for state to avoid spec issues
+        self.state = MagicMock()
         self.state.settlement_system = self.settlement
         self.state.government = self.government
         self.state.escrow_agent = self.escrow_agent
@@ -26,20 +31,21 @@ class TestGoodsTransactionHandler(unittest.TestCase):
         self.state.logger = self.logger
         self.state.time = 100
         self.state.market_data = {}
+        self.state.taxation_system = self.taxation_system
 
-        # Mock Buyer with ISolvent protocol
-        self.buyer = MagicMock(spec=ISolvent)
+        # Mock Buyer with IFinancialAgent protocol
+        self.buyer = MagicMock(spec=IFinancialAgent)
         self.buyer.id = 1
-        # Set assets to sufficient amount by default to avoid issues
         self.buyer.assets = 10000
+        self.buyer.get_balance.return_value = 10000
 
         self.seller = MagicMock()
         self.seller.id = 2
 
         # Setup config
-        self.config.SALES_TAX_RATE = 0.10 # 10% for easy math
+        self.config.SALES_TAX_RATE = 0.10
 
-    def test_goods_success(self):
+    def test_goods_success_atomic(self):
         # Transaction: 10 units @ 100 pennies = 1000 pennies
         tx = Transaction(
             buyer_id=1, seller_id=2, item_id="apple", quantity=10, price=100,
@@ -47,156 +53,122 @@ class TestGoodsTransactionHandler(unittest.TestCase):
             total_pennies=1000
         )
 
-        # Expectation:
-        # Trade Value = 1000
-        # Tax = 1000 * 0.10 = 100
-        # Total Cost = 1100
+        # Mock Tax Intents
+        intent_mock = MagicMock()
+        intent_mock.amount = 100
+        intent_mock.reason = "sales_tax:apple"
+        intent_mock.payer_id = 1
+        intent_mock.payee_id = 99
+
+        self.taxation_system.calculate_tax_intents.return_value = [intent_mock]
 
-        self.settlement.transfer.return_value = True
+        # Settle Atomic Success
+        self.settlement.settle_atomic.return_value = True
 
         success = self.handler.handle(tx, self.buyer, self.seller, self.state)
 
         self.assertTrue(success)
 
-        # Verify Escrow Transfer (Buyer -> Escrow)
-        self.settlement.transfer.assert_any_call(self.buyer, self.escrow_agent, 1100, "escrow_hold:apple")
-
-        # Verify Trade Transfer (Escrow -> Seller)
-        self.settlement.transfer.assert_any_call(self.escrow_agent, self.seller, 1000, "goods_trade:apple")
-
-        # Verify Tax Transfer (Escrow -> Gov)
-        self.settlement.transfer.assert_any_call(self.escrow_agent, self.government, 100, "sales_tax:apple")
+        # Verify settle_atomic called
+        # Credits: [(seller, 1000, "goods_trade:apple"), (government, 100, "sales_tax:apple")]
+        call_args = self.settlement.settle_atomic.call_args
+        self.assertIsNotNone(call_args)
+        args, kwargs = call_args
 
-        # Verify Gov Record Revenue
-        self.government.record_revenue.assert_called_once()
+        # Check debit agent is buyer
+        self.assertEqual(args[0], self.buyer)
 
-    def test_goods_escrow_fail(self):
-        tx = Transaction(
-            buyer_id=1, seller_id=2, item_id="apple", quantity=10, price=100,
-            transaction_type="goods", time=100, market_id="goods_market",
-            total_pennies=1000
-        )
+        # Check credits
+        credits = args[1]
+        self.assertEqual(len(credits), 2)
 
-        # Escrow transfer fails
-        self.settlement.transfer.side_effect = [False]
+        # Check seller credit
+        self.assertIn((self.seller, 1000, "goods_trade:apple"), credits)
+        # Check gov credit
+        self.assertIn((self.government, 100, "sales_tax:apple"), credits)
 
-        success = self.handler.handle(tx, self.buyer, self.seller, self.state)
-
-        self.assertFalse(success)
-        # Should stop after first transfer attempt
-        self.assertEqual(self.settlement.transfer.call_count, 1)
+        # Verify Gov Record Revenue
+        self.government.record_revenue.assert_called()
 
-    def test_goods_trade_fail_rollback(self):
+    def test_goods_settle_fail(self):
         tx = Transaction(
             buyer_id=1, seller_id=2, item_id="apple", quantity=10, price=100,
             transaction_type="goods", time=100, market_id="goods_market",
             total_pennies=1000
         )
 
-        # 1. Escrow (Success), 2. Trade (Fail), 3. Rollback (Success)
-        self.settlement.transfer.side_effect = [True, False, True]
+        self.taxation_system.calculate_tax_intents.return_value = []
+        self.settlement.settle_atomic.return_value = False
 
         success = self.handler.handle(tx, self.buyer, self.seller, self.state)
 
         self.assertFalse(success)
 
-        # Verify calls
-        # 1. Buyer -> Escrow (1100)
-        # 2. Escrow -> Seller (1000) (FAILED)
-        # 3. Escrow -> Buyer (1100) (ROLLBACK)
-        self.settlement.transfer.assert_any_call(self.escrow_agent, self.buyer, 1100, "escrow_reversal:trade_failure")
-
 class TestLaborTransactionHandler(unittest.TestCase):
     def setUp(self):
         self.handler = LaborTransactionHandler()
         self.settlement = MagicMock()
 
-        # Mock Government with Government spec to allow 'id' attribute access and ITaxCollector compliance
         self.government = MagicMock(spec=Government)
-        # MagicMock with spec doesn't automatically set attributes unless defined in class or created on mock.
-        # But access checks are strict. Government has id.
         self.government.id = 99
 
         self.config = MagicMock()
         self.logger = MagicMock()
-        self.state = MagicMock(spec=SimulationState)
+        self.taxation_system = MagicMock(spec=TaxationSystem)
+
+        self.state = MagicMock()
         self.state.settlement_system = self.settlement
         self.state.government = self.government
         self.state.config_module = self.config
         self.state.logger = self.logger
         self.state.time = 100
         self.state.market_data = {}
+        self.state.taxation_system = self.taxation_system
 
         self.buyer = MagicMock()
         self.buyer.id = 1
         self.seller = MagicMock()
         self.seller.id = 2
 
-        # Defaults
         self.config.INCOME_TAX_PAYER = "HOUSEHOLD"
         self.config.HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK = 1.0
-        self.config.GOODS_INITIAL_PRICE = {"basic_food": 500} # 500 pennies
+        self.config.GOODS_INITIAL_PRICE = {"basic_food": 500}
 
-    def test_labor_household_tax_payer(self):
-        # Transaction: 1 unit labor @ 2000 pennies
+    def test_labor_atomic_settlement(self):
         tx = Transaction(
             buyer_id=1, seller_id=2, item_id="labor", quantity=1, price=2000,
             transaction_type="labor", time=100, market_id="labor_market",
             total_pennies=2000
         )
 
-        # Mock Gov tax calc
-        self.government.calculate_income_tax.return_value = 200 # 10%
-        self.settlement.transfer.return_value = True
-        self.settlement.settle_atomic.return_value = True # For tax settlement
-
-        success = self.handler.handle(tx, self.buyer, self.seller, self.state)
-
-        self.assertTrue(success)
-
-        # Verify Wage Transfer (Buyer -> Seller) Gross
-        self.settlement.transfer.assert_called_with(self.buyer, self.seller, 2000, "labor_wage_gross:labor")
-
-        # Verify Tax Collection (Gov collects from Seller/Household via settle_atomic)
-        self.settlement.settle_atomic.assert_called_with(
-            debit_agent=self.seller,
-            credits_list=[(self.government, 200, "income_tax_household")],
-            tick=100
-        )
-
-        # Verify Record Revenue called
-        self.government.record_revenue.assert_called()
-
-    def test_labor_firm_tax_payer(self):
-        self.config.INCOME_TAX_PAYER = "FIRM"
-
-        tx = Transaction(
-            buyer_id=1, seller_id=2, item_id="labor", quantity=1, price=2000,
-            transaction_type="labor", time=100, market_id="labor_market",
-            total_pennies=2000
-        )
+        # Mock Tax Intents: Seller pays tax
+        intent_mock = MagicMock()
+        intent_mock.amount = 200
+        intent_mock.reason = "income_tax_household"
+        intent_mock.payer_id = 2 # Seller
+        intent_mock.payee_id = 99 # Gov
 
-        self.government.calculate_income_tax.return_value = 200
+        self.taxation_system.calculate_tax_intents.return_value = [intent_mock]
         self.settlement.settle_atomic.return_value = True
 
         success = self.handler.handle(tx, self.buyer, self.seller, self.state)
 
         self.assertTrue(success)
 
-        # Verify Wage Transfer (Firm pays Wage to Household AND Tax to Gov Atomically)
-        # Expected credits_list: [(seller, 2000, "labor_wage:labor"), (government, 200, "income_tax_firm")]
+        # Verify Atomic Settlement
+        # Seller Net = 2000 - 200 = 1800
+        # Credits: [(Gov, 200, "income_tax_household"), (Seller, 1800, "labor_wage:labor")]
 
         call_args = self.settlement.settle_atomic.call_args
         self.assertIsNotNone(call_args)
-        kwargs = call_args.kwargs
+        args, kwargs = call_args
 
-        self.assertEqual(kwargs['debit_agent'], self.buyer)
-        credits = kwargs['credits_list']
+        self.assertEqual(args[0], self.buyer)
+        credits = args[1]
         self.assertEqual(len(credits), 2)
 
-        # Check credits content roughly
-        self.assertIn((self.seller, 2000, "labor_wage:labor"), credits)
-        self.assertIn((self.government, 200, "income_tax_firm"), credits)
+        # Check credits content
+        self.assertIn((self.government, 200, "income_tax_household"), credits)
+        self.assertIn((self.seller, 1800, "labor_wage:labor"), credits)
 
-        # Verify Record Revenue called
         self.government.record_revenue.assert_called()
