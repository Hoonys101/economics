diff --git a/communications/insights/fix_core_init.md b/communications/insights/fix_core_init.md
new file mode 100644
index 00000000..2bcf07a0
--- /dev/null
+++ b/communications/insights/fix_core_init.md
@@ -0,0 +1,68 @@
+# Insight Report: Fix Core Simulation Initialization
+
+## Architectural Insights
+
+### 1. Command Processing Strategy
+A critical architectural decision was made regarding `Simulation._process_commands`. Initially, there was a risk of "Double Execution" where commands were executed in `_process_commands` and then re-enqueued for `Phase0_Intercept` to execute again.
+
+To resolve this while adhering to the specification that `Simulation` must use the injected `CommandService`, the following strategy was implemented:
+- **Immediate Execution**: `Simulation._process_commands` now drains both the external `command_queue` and internal `god_command_queue`.
+- **Atomic Batching**: It aggregates these commands and executes them via `self.command_service.execute_command_batch`.
+- **Baseline Integrity**: The result of the batch execution (specifically `m2_delta`) is used to immediately update `self.world_state.baseline_money_supply`.
+- **No Re-enqueue**: Executed commands are **NOT** put back into `god_command_queue`. This prevents `Phase0_Intercept` (which runs later in `TickOrchestrator`) from re-executing them. `Phase0_Intercept` will simply find an empty queue and pass.
+
+This approach satisfies strict causality (commands happen before tick logic) and financial integrity (M2 baseline is updated), while fixing the `NameError` and "Dead Dependency" issues.
+
+### 2. Dependency Injection
+`CommandService` is now treated as a core system component, instantiated early in `SimulationInitializer` and injected into `Simulation`. This follows the pattern used for `GlobalRegistry` and `SettlementSystem`.
+
+### 3. Test Alignment
+Integration tests (`test_cockpit_integration.py`) were updated to reflect the new behavior. Previously, they asserted that commands were *forwarded* to the queue. Now, they assert that commands are *executed* (by verifying calls to the mocked `CommandService`).
+
+## Test Evidence
+
+### `tests/integration/test_wo058_production.py`
+```
+tests/integration/test_wo058_production.py::test_bootstrapper_injection
+-------------------------------- live log call ---------------------------------
+INFO     simulation.systems.bootstrapper:bootstrapper.py:97 BOOTSTRAPPER | Injected 50.0 units to Firm 100
+INFO     simulation.systems.bootstrapper:bootstrapper.py:107 BOOTSTRAPPER | Injected 9999500 capital to Firm 100 via Settlement.
+INFO     simulation.systems.bootstrapper:bootstrapper.py:97 BOOTSTRAPPER | Injected 50.0 units to Firm 101
+INFO     simulation.systems.bootstrapper:bootstrapper.py:107 BOOTSTRAPPER | Injected 9997500 capital to Firm 101 via Settlement.
+INFO     simulation.systems.bootstrapper:bootstrapper.py:113 BOOTSTRAPPER | Injected resources into 1 firms.
+INFO     simulation.systems.bootstrapper:bootstrapper.py:55 BOOTSTRAPPER | Force-assigned 1 workers to Firm 100
+INFO     simulation.systems.bootstrapper:bootstrapper.py:55 BOOTSTRAPPER | Force-assigned 0 workers to Firm 101
+INFO     simulation.systems.bootstrapper:bootstrapper.py:57 BOOTSTRAPPER | Total force-assigned workers: 1
+PASSED                                                                   [ 50%]
+tests/integration/test_wo058_production.py::test_production_kickstart
+-------------------------------- live log call ---------------------------------
+INFO     simulation.systems.bootstrapper:bootstrapper.py:97 BOOTSTRAPPER | Injected 50.0 units to Firm 100
+INFO     simulation.systems.bootstrapper:bootstrapper.py:107 BOOTSTRAPPER | Injected 9997000 capital to Firm 100 via Settlement.
+INFO     simulation.systems.bootstrapper:bootstrapper.py:113 BOOTSTRAPPER | Injected resources into 1 firms.
+INFO     simulation.systems.bootstrapper:bootstrapper.py:55 BOOTSTRAPPER | Force-assigned 1 workers to Firm 100
+INFO     simulation.systems.bootstrapper:bootstrapper.py:57 BOOTSTRAPPER | Total force-assigned workers: 1
+PASSED                                                                   [100%]
+```
+
+### `tests/integration/test_cockpit_integration.py`
+```
+tests/integration/test_cockpit_integration.py::test_simulation_processes_pause_resume
+-------------------------------- live log call ---------------------------------
+INFO     simulation.engine:engine.py:121 Simulation PAUSED by command.
+INFO     simulation.engine:engine.py:121 Simulation RESUMED by command.
+PASSED                                                                   [ 33%]
+tests/integration/test_cockpit_integration.py::test_simulation_processes_set_base_rate PASSED [ 66%]
+tests/integration/test_cockpit_integration.py::test_simulation_processes_set_tax_rate PASSED [100%]
+```
+
+### `tests/unit/test_tax_incidence.py`
+```
+tests/unit/test_tax_incidence.py::TestTaxIncidence::test_firm_payer_scenario
+-------------------------------- live log call ---------------------------------
+INFO     simulation.agents.government:government.py:163 Government 999 initialized with assets: defaultdict(<class 'int'>, {'USD': 0})
+PASSED                                                                   [ 50%]
+tests/unit/test_tax_incidence.py::TestTaxIncidence::test_household_payer_scenario
+-------------------------------- live log call ---------------------------------
+INFO     simulation.agents.government:government.py:163 Government 999 initialized with assets: defaultdict(<class 'int'>, {'USD': 0})
+PASSED                                                                   [100%]
+```
diff --git a/design/1_governance/architecture/mechanisms/COMMAND_EXECUTION.md b/design/1_governance/architecture/mechanisms/COMMAND_EXECUTION.md
new file mode 100644
index 00000000..38436848
--- /dev/null
+++ b/design/1_governance/architecture/mechanisms/COMMAND_EXECUTION.md
@@ -0,0 +1,9 @@
+# Command Execution Strategy (v2)
+
+## Immediate Batch Execution Pattern
+To prevent "Double Execution" where commands are processed by `Simulation` and then re-processed by `Phase0_Intercept`:
+
+1.  **Drain & Batch**: `Simulation` drains the `god_command_queue` immediately at the start of a tick.
+2.  **Atomic Execution**: Commands are executed via `CommandService.execute_command_batch`.
+3.  **No Re-enqueue**: Executed commands are **never** put back into the queue. `Phase0_Intercept` will find an empty queue.
+4.  **Baseline Integrity**: The `m2_delta` returned from the batch execution is immediately applied to `world_state.baseline_money_supply` to ensure zero-sum consistency.
diff --git a/simulation/engine.py b/simulation/engine.py
index a1f126dd..28fc117a 100644
--- a/simulation/engine.py
+++ b/simulation/engine.py
@@ -14,6 +14,8 @@ from simulation.action_processor import ActionProcessor
 from simulation.models import Transaction
 from simulation.dtos.commands import GodCommandDTO
 from modules.system.services.command_service import CommandService
+from modules.simulation.api import EconomicIndicatorsDTO, SystemStateDTO
+from modules.system.api import DEFAULT_CURRENCY
 
 from simulation.db.logger import SimulationLogger
 import simulation
@@ -103,6 +105,7 @@ class Simulation:
 
     def _process_commands(self) -> None:
         """Processes all pending commands from the world state command queue."""
+        commands = []
         # Check External Queue (from Dashboard/Server)
         if hasattr(self.world_state, "command_queue") and self.world_state.command_queue:
             while not self.world_state.command_queue.empty():
@@ -122,10 +125,9 @@ class Simulation:
                         self.step_requested = True
                         logger.info("Simulation STEP requested.")
 
-                    # Forward everything else (including other TRIGGER_EVENTs) to God Command Queue for Phase 0
+                    # Forward everything else (including other TRIGGER_EVENTs) to commands list
                     else:
-                        if hasattr(self.world_state, "god_command_queue"):
-                            self.world_state.god_command_queue.append(cmd)
+                        commands.append(cmd)
                 except Exception:
                     break
 
@@ -143,35 +145,25 @@ class Simulation:
         
         results = self.command_service.execute_command_batch(commands, tick, baseline_m2)
 
-        # Log results
+        # Log results and Update Baseline
+        total_net_injection = 0
+        all_success = True
+
         for result in results:
             if not result.success:
                 logger.error(f"Command {result.command_id} failed: {result.failure_reason}")
+                all_success = False
             else:
                 logger.info(f"Command {result.command_id} succeeded.")
-
-        # 3. Local Handling for PAUSE/RESUME/STEP and Phase 0 forwarding
-        god_commands = []
-        for cmd in commands:
-            # Check for PAUSE_STATE
-            if cmd.command_type == "PAUSE_STATE":
-                val = getattr(cmd, "new_value", True)
-                self.is_paused = bool(val)
-                logger.info(f"Simulation {'PAUSED' if self.is_paused else 'RESUMED'} via GodCommand.")
-            
-            # Check for STEP (via TRIGGER_EVENT)
-            elif cmd.command_type == "TRIGGER_EVENT" and cmd.parameter_key == "STEP":
-                self.step_requested = True
-                logger.info("Simulation STEP requested via GodCommand.")
-            
-            # Forward everything else to god_command_queue for Phase 0 execution in TickOrchestrator
-            else:
-                god_commands.append(cmd)
-
-        if god_commands:
-            # Re-enqueue to list for TickOrchestrator's Phase0 processing
-            self.world_state.god_command_queue.extend(god_commands)
-            logger.debug(f"Forwarded {len(god_commands)} commands to TickOrchestrator.")
+                if result.audit_report and "m2_delta" in result.audit_report:
+                     total_net_injection += result.audit_report["m2_delta"]
+
+        if all_success and total_net_injection != 0:
+             # Update Baseline
+             self.world_state.baseline_money_supply += total_net_injection
+             logger.info(
+                 f"Baseline Money Supply updated by {total_net_injection}. New Baseline: {self.world_state.baseline_money_supply}"
+             )
     def run_tick(self, injectable_sensory_dto: Optional[GovernmentSensoryDTO] = None) -> None:
         self._process_commands()
 
diff --git a/simulation/initialization/initializer.py b/simulation/initialization/initializer.py
index 6543a248..8dadb858 100644
--- a/simulation/initialization/initializer.py
+++ b/simulation/initialization/initializer.py
@@ -154,6 +154,14 @@ class SimulationInitializer(SimulationInitializerInterface):
         # 3. Agent Registry
         agent_registry = AgentRegistry()
 
+        # Instantiate CommandService
+        from modules.system.services.command_service import CommandService
+        command_service = CommandService(
+            registry=global_registry,
+            settlement_system=settlement_system,
+            agent_registry=agent_registry
+        )
+
         # 4. Create the Simulation shell with injected dependencies
         sim = Simulation(
             config_manager=self.config_manager,
@@ -162,7 +170,8 @@ class SimulationInitializer(SimulationInitializerInterface):
             repository=self.repository,
             registry=global_registry,
             settlement_system=settlement_system,
-            agent_registry=agent_registry
+            agent_registry=agent_registry,
+            command_service=command_service
         )
 
         # Attach lock file to simulation to keep it open (and locked) until shutdown
diff --git a/tests/integration/test_cockpit_integration.py b/tests/integration/test_cockpit_integration.py
index 877d701b..62d92e64 100644
--- a/tests/integration/test_cockpit_integration.py
+++ b/tests/integration/test_cockpit_integration.py
@@ -100,39 +100,50 @@ def test_simulation_processes_set_base_rate(mock_simulation_deps):
         m.setattr("simulation.engine.SimulationLogger", MagicMock())
 
         cmd_service = MagicMock(spec=CommandService)
+        cmd_service.execute_command_batch.return_value = []
         sim = Simulation(cm, config_module, logger, repo, registry, settlement_system, agent_registry, cmd_service)
         sim.world_state = ws
 
         # Enqueue SET_PARAM central_bank.base_rate
-        cmd = GodCommandDTO(
+        cmd1 = GodCommandDTO(
             command_type="SET_PARAM",
             target_domain="CentralBank",
             parameter_key="central_bank.base_rate",
             new_value=0.15,
             command_id=uuid4()
         )
-        ws.command_queue.put(cmd)
+        ws.command_queue.put(cmd1)
+
+        sim.run_tick()
+
+        # Verify Execution: Queue drained, CommandService called
+        assert len(ws.god_command_queue) == 0
+        cmd_service.execute_command_batch.assert_called()
+        # Verify the batch contained our command
+        args, _ = cmd_service.execute_command_batch.call_args
+        assert len(args[0]) == 1
+        assert args[0][0].parameter_key == "central_bank.base_rate"
+
+        cmd_service.execute_command_batch.reset_mock()
 
         # Enqueue SET_BASE_RATE via SET_PARAM
-        cmd = GodCommandDTO(
+        cmd2 = GodCommandDTO(
             command_type="SET_PARAM",
             target_domain="CentralBank",
             parameter_key="base_rate",
             new_value=0.15
         )
-        ws.command_queue.put(cmd)
+        ws.command_queue.put(cmd2)
 
         # Run tick
-        # Note: Since TickOrchestrator is mocked, it won't execute Phase 0.
-        # We verify that Simulation forwarded the command to god_command_queue.
         sim.run_tick()
 
-        assert len(ws.god_command_queue) == 1
-        assert ws.god_command_queue[0].command_type == "SET_PARAM"
-        assert ws.god_command_queue[0].new_value == 0.15
-        
-        # Check if Registry.set was called (via CommandService which we would need to verify if not mocked)
-        # Note: In this test, TickOrchestrator is mocked, so we just check if it was forwarded correctly to god_command_queue.
+        # Verify Execution
+        assert len(ws.god_command_queue) == 0
+        cmd_service.execute_command_batch.assert_called()
+        args, _ = cmd_service.execute_command_batch.call_args
+        assert len(args[0]) == 1
+        assert args[0][0].new_value == 0.15
 
 def test_simulation_processes_set_tax_rate(mock_simulation_deps):
     cm, config_module, logger, repo, registry, settlement_system, agent_registry, ws = mock_simulation_deps
@@ -144,6 +155,7 @@ def test_simulation_processes_set_tax_rate(mock_simulation_deps):
         m.setattr("simulation.engine.SimulationLogger", MagicMock())
 
         cmd_service = MagicMock(spec=CommandService)
+        cmd_service.execute_command_batch.return_value = []
         sim = Simulation(cm, config_module, logger, repo, registry, settlement_system, agent_registry, cmd_service)
         sim.world_state = ws
 
@@ -158,12 +170,14 @@ def test_simulation_processes_set_tax_rate(mock_simulation_deps):
         ws.command_queue.put(cmd)
 
         sim.run_tick()
-        assert len(ws.god_command_queue) == 1
-        assert ws.god_command_queue[0].parameter_key == "corporate_tax_rate"
-        assert ws.god_command_queue[0].new_value == 0.25
 
-        # Clear queue for next step
-        ws.god_command_queue.clear()
+        assert len(ws.god_command_queue) == 0
+        cmd_service.execute_command_batch.assert_called()
+        args, _ = cmd_service.execute_command_batch.call_args
+        assert len(args[0]) == 1
+        assert args[0][0].parameter_key == "corporate_tax_rate"
+
+        cmd_service.execute_command_batch.reset_mock()
 
         # Enqueue SET_TAX_RATE (Income)
         cmd = GodCommandDTO(
@@ -176,6 +190,9 @@ def test_simulation_processes_set_tax_rate(mock_simulation_deps):
         ws.command_queue.put(cmd)
 
         sim.run_tick()
-        assert len(ws.god_command_queue) == 1
-        assert ws.god_command_queue[0].parameter_key == "income_tax_rate"
-        assert ws.god_command_queue[0].new_value == 0.15
+
+        assert len(ws.god_command_queue) == 0
+        cmd_service.execute_command_batch.assert_called()
+        args, _ = cmd_service.execute_command_batch.call_args
+        assert len(args[0]) == 1
+        assert args[0][0].parameter_key == "income_tax_rate"
diff --git a/tests/integration/test_wo058_production.py b/tests/integration/test_wo058_production.py
index 18125f0d..cb202877 100644
--- a/tests/integration/test_wo058_production.py
+++ b/tests/integration/test_wo058_production.py
@@ -1,6 +1,7 @@
 import pytest
 from unittest.mock import Mock, MagicMock
 from simulation.engine import Simulation
+from modules.system.services.command_service import CommandService
 from simulation.systems.bootstrapper import Bootstrapper
 from simulation.core_agents import Household, Talent
 from simulation.firms import Firm
@@ -129,7 +130,17 @@ def test_bootstrapper_injection(mock_config, mock_repo, mock_ai_trainer, mock_co
     mock_registry = MagicMock()
     mock_settlement = MagicMock()
     mock_agent_registry = MagicMock()
-    sim = Simulation(config_manager=mock_config_manager, config_module=mock_config, logger=Mock(), repository=mock_repo, registry=mock_registry, settlement_system=mock_settlement, agent_registry=mock_agent_registry)
+    mock_command_service = MagicMock(spec=CommandService)
+    sim = Simulation(
+        config_manager=mock_config_manager,
+        config_module=mock_config,
+        logger=Mock(),
+        repository=mock_repo,
+        registry=mock_registry,
+        settlement_system=mock_settlement,
+        agent_registry=mock_agent_registry,
+        command_service=mock_command_service
+    )
     sim.world_state.households = households
     sim.world_state.firms = firms
     sim.world_state.ai_trainer = mock_ai_trainer
@@ -187,7 +198,17 @@ def test_production_kickstart(mock_config, mock_repo, mock_ai_trainer, mock_conf
     mock_registry = MagicMock()
     mock_settlement = MagicMock()
     mock_agent_registry = MagicMock()
-    sim = Simulation(config_manager=mock_config_manager, config_module=mock_config, logger=Mock(), repository=mock_repo, registry=mock_registry, settlement_system=mock_settlement, agent_registry=mock_agent_registry)
+    mock_command_service = MagicMock(spec=CommandService)
+    sim = Simulation(
+        config_manager=mock_config_manager,
+        config_module=mock_config,
+        logger=Mock(),
+        repository=mock_repo,
+        registry=mock_registry,
+        settlement_system=mock_settlement,
+        agent_registry=mock_agent_registry,
+        command_service=mock_command_service
+    )
     sim.world_state.households = households
     sim.world_state.firms = firms
     sim.world_state.ai_trainer = mock_ai_trainer
diff --git a/tests/unit/test_tax_incidence.py b/tests/unit/test_tax_incidence.py
index 31a06098..9fa7300d 100644
--- a/tests/unit/test_tax_incidence.py
+++ b/tests/unit/test_tax_incidence.py
@@ -98,7 +98,11 @@ class TestTaxIncidence(unittest.TestCase):
             config_manager=mock_config_manager,
             config_module=cfg,
             logger=logger,
-            repository=self.repository
+            repository=self.repository,
+            registry=MagicMock(),
+            settlement_system=MagicMock(),
+            agent_registry=MagicMock(),
+            command_service=MagicMock()
         )
         sim.world_state.households = [h]
         sim.world_state.firms = [f]
