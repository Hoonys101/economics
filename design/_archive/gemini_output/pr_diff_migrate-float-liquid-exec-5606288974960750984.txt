diff --git a/communications/insights/MISSION_FLOAT_LIQUIDATION_EXEC.md b/communications/insights/MISSION_FLOAT_LIQUIDATION_EXEC.md
new file mode 100644
index 00000000..9c40661a
--- /dev/null
+++ b/communications/insights/MISSION_FLOAT_LIQUIDATION_EXEC.md
@@ -0,0 +1,35 @@
+# Architectural Insights: MISSION_FLOAT_LIQUIDATION_EXEC
+
+## Overview
+This mission successfully executed the "Global Float-to-Int Migration" for critical financial structures, ensuring Zero-Sum Integrity by standardizing on integer `pennies` for all monetary values.
+
+## Architectural Changes
+
+1.  **Strict Integer Protocol for `ICurrencyHolder`**:
+    *   The `ICurrencyHolder` protocol now explicitly mandates `get_balance() -> int` and `get_assets_by_currency() -> Dict[CurrencyCode, int]`.
+    *   This enforces that all agents (Household, Firm, Bank, Government, CentralBank) expose their financial state as integer pennies, eliminating floating-point drift at the interface level.
+
+2.  **DTO Modernization**:
+    *   `GoodsInfoDTO.initial_price` (and `GoodsDTO`) migrated from `float` to `int`. This aligns with the configuration data which was already using integer pennies.
+    *   `MarketContextDTO`, `MarketSignalDTO`, `HousingMarketUnitDTO`, and `MarketHistoryDTO` updated to use `int` for price fields (`best_bid`, `best_ask`, `price`, etc.). This ensures that market signals processed by agents are consistent with the underlying matching engine (which already used pennies).
+
+3.  **Default Value Refactoring**:
+    *   Hardcoded default prices (e.g., `10.0`, `5.0`) in various components (`core_agents.py`, `firms.py`, `asset_manager.py`, `production_strategy.py`, `utils.py`) were refactored to integer pennies (e.g., `1000`, `500`). This prevents implicit float contamination when market data is missing.
+
+4.  **Liquidation Logic Precision**:
+    *   `InventoryLiquidationHandler` logic was corrected. Previously, it risked double-converting pennies to dollars and back. Now it strictly respects that input prices are in pennies and outputs integer pennies for settlement.
+    *   `LiquidationManager` now explicitly casts claim amounts (which might be calculated as floats from tenure) to `int` before requesting transfers from the Settlement System.
+
+5.  **Test Modernization**:
+    *   Integration tests `test_liquidation_waterfall.py` were updated to reflect integer arithmetic (truncation) and proper penny scaling, ensuring that verification logic matches the strict integer production logic.
+
+## Technical Debt Resolved
+*   **TD-FLOAT-DTO**: DTOs no longer "lie" about types or encourage float usage for prices.
+*   **TD-DEFAULT-DRIFT**: Fallback values are now type-safe integers.
+
+## Test Evidence
+All tests passed, verifying no regressions in the liquidation waterfall or general system stability.
+
+```
+================= 848 passed, 1 skipped, 10 warnings in 16.89s =================
+```
diff --git a/modules/__init__.py b/modules/__init__.py
new file mode 100644
index 00000000..e69de29b
diff --git a/modules/system/api.py b/modules/system/api.py
index 964ef9c3..7feeec27 100644
--- a/modules/system/api.py
+++ b/modules/system/api.py
@@ -16,7 +16,7 @@ class MarketContextDTO:
     Contains strictly external market data (prices, rates, signals).
     """
     market_data: Dict[str, Any]
-    market_signals: Dict[str, float]
+    market_signals: Dict[str, int]
     tick: int
     # Represents currency exchange rates relative to base currency
     exchange_rates: Optional[Dict[str, float]] = None
@@ -25,11 +25,11 @@ class MarketContextDTO:
 class MarketSignalDTO:
     market_id: str
     item_id: str
-    best_bid: Optional[float]
-    best_ask: Optional[float]
-    last_traded_price: Optional[float]
+    best_bid: Optional[int]
+    best_ask: Optional[int]
+    last_traded_price: Optional[int]
     last_trade_tick: int
-    price_history_7d: List[float]
+    price_history_7d: List[int]
     volatility_7d: float
     order_book_depth_buy: int
     order_book_depth_sell: int
@@ -40,9 +40,9 @@ class MarketSignalDTO:
 @dataclass(frozen=True)
 class HousingMarketUnitDTO:
     unit_id: str
-    price: float
+    price: int
     quality: float
-    rent_price: Optional[float] = None
+    rent_price: Optional[int] = None
 
 @dataclass(frozen=True)
 class HousingMarketSnapshotDTO:
@@ -220,10 +220,10 @@ class ICurrencyHolder(Protocol):
     Protocol for agents/systems that hold currency.
     Used for M2 Money Supply calculation.
     """
-    def get_balance(self, currency: CurrencyCode = DEFAULT_CURRENCY) -> float:
+    def get_balance(self, currency: CurrencyCode = DEFAULT_CURRENCY) -> int:
         ...
 
-    def get_assets_by_currency(self) -> Dict[CurrencyCode, float]:
+    def get_assets_by_currency(self) -> Dict[CurrencyCode, int]:
         ...
 
 class IAssetRecoverySystem(Protocol):
diff --git a/simulation/api.py b/simulation/api.py
index b6142125..13c26809 100644
--- a/simulation/api.py
+++ b/simulation/api.py
@@ -49,7 +49,7 @@ class GoodsInfoDTO:
     category: str
     is_durable: bool
     is_essential: bool
-    initial_price: float
+    initial_price: int
     base_need_satisfaction: float
     quality_modifier: float
     type: str
@@ -63,12 +63,12 @@ class MarketHistoryDTO:
     """
     avg_price: float
     trade_volume: float
-    best_ask: float
-    best_bid: float
+    best_ask: int
+    best_bid: int
     avg_ask: float
     avg_bid: float
-    worst_ask: float
-    worst_bid: float
+    worst_ask: int
+    worst_bid: int
 
 # MarketSnapshotDTO is now imported from modules.system.api
 from modules.system.api import MarketSnapshotDTO
diff --git a/simulation/core_agents.py b/simulation/core_agents.py
index a20a3c51..1bf5688d 100644
--- a/simulation/core_agents.py
+++ b/simulation/core_agents.py
@@ -142,7 +142,7 @@ class Household(
 
         perceived_prices = {}
         for g in goods_data:
-             perceived_prices[g["id"]] = g.get("initial_price", 10.0)
+             perceived_prices[g["id"]] = g.get("initial_price", 1000)
 
         adaptation_rate = self.config.adaptation_rate_normal
         if personality == Personality.IMPULSIVE:
diff --git a/simulation/decisions/firm/production_strategy.py b/simulation/decisions/firm/production_strategy.py
index a4bd254c..2f71d046 100644
--- a/simulation/decisions/firm/production_strategy.py
+++ b/simulation/decisions/firm/production_strategy.py
@@ -55,9 +55,11 @@ class ProductionStrategy:
                     last_price = mat_market_data.get(fallback_price_key, 0.0)
                 if last_price <= 0:
                     mat_info = goods_map.get(mat, {})
-                    last_price = mat_info.get('initial_price', 10.0)
+                    last_price = mat_info.get('initial_price', 1000)
                 bid_price = last_price * 1.05
-                orders.append(Order(agent_id=firm.id, side='BUY', item_id=mat, quantity=deficit, price_pennies=int(bid_price * 100), price_limit=bid_price, market_id=mat))
+                # last_price is already in pennies, so bid_price is in pennies.
+                # Do NOT multiply by 100 again.
+                orders.append(Order(agent_id=firm.id, side='BUY', item_id=mat, quantity=deficit, price_pennies=int(bid_price), price_limit=bid_price, market_id=mat))
         return orders
 
     def _manage_automation(self, firm: FirmStateDTO, aggressiveness: float, guidance: Dict[str, Any], current_time: int, config: FirmConfigDTO) -> List[Order]:
diff --git a/simulation/decisions/household/asset_manager.py b/simulation/decisions/household/asset_manager.py
index 4f196857..899a0339 100644
--- a/simulation/decisions/household/asset_manager.py
+++ b/simulation/decisions/household/asset_manager.py
@@ -107,7 +107,7 @@ class AssetManager:
         risk_free_rate = loan_market.get('interest_rate', config.default_mortgage_rate)
         equity_return = getattr(config, 'expected_startup_roi', 0.15)
         goods_market = market_data.get('goods_market', {})
-        food_price = goods_market.get('basic_food_current_sell_price', 5.0)
+        food_price = goods_market.get('basic_food_current_sell_price', 500)
         daily_consumption = getattr(config, 'household_food_consumption_per_tick', 2.0)
         monthly_survival_cost = food_price * daily_consumption * 30.0
         if household.expected_inflation:
@@ -159,9 +159,9 @@ class AssetManager:
         avg_dividend_yield = market_data.get('avg_dividend_yield', 0.05)
         risk_free_rate = market_data.get('loan_market', {}).get('interest_rate', 0.03)
         goods_market = market_data.get('goods_market', {})
-        food_price = goods_market.get('basic_food_current_sell_price', 5.0)
+        food_price = goods_market.get('basic_food_current_sell_price', 500)
         if not food_price or food_price <= 0:
-            food_price = config.goods.get('basic_food', {}).get('initial_price', 5.0)
+            food_price = config.goods.get('basic_food', {}).get('initial_price', 500)
         daily_consumption = getattr(config, 'household_food_consumption_per_tick', 2.0)
         survival_cost = food_price * daily_consumption * 30.0
         risk_aversion = self._get_risk_aversion(household.personality)
diff --git a/simulation/dtos/api.py b/simulation/dtos/api.py
index 9b04a1a4..216913f4 100644
--- a/simulation/dtos/api.py
+++ b/simulation/dtos/api.py
@@ -107,7 +107,7 @@ class GoodsDTO(TypedDict, total=False):
     category: str
     is_durable: bool
     is_essential: bool
-    initial_price: float
+    initial_price: int
     base_need_satisfaction: float
     quality_modifier: float
     # Fields from goods.json
@@ -118,12 +118,12 @@ class GoodsDTO(TypedDict, total=False):
 class MarketHistoryDTO(TypedDict, total=False):
     avg_price: float
     trade_volume: float
-    best_ask: float
-    best_bid: float
+    best_ask: int
+    best_bid: int
     avg_ask: float
     avg_bid: float
-    worst_ask: float
-    worst_bid: float
+    worst_ask: int
+    worst_bid: int
 
 # Phase 1: MarketSnapshotDTO moved to modules.system.api
 from modules.system.api import (
diff --git a/simulation/factories/golden_agents.py b/simulation/factories/golden_agents.py
index 32486773..47d7ae88 100644
--- a/simulation/factories/golden_agents.py
+++ b/simulation/factories/golden_agents.py
@@ -17,7 +17,7 @@ class GoldenAgent(IPropertyOwner, IResident, IMortgageBorrower, IWelfareRecipien
         self._assets: Dict[CurrencyCode, int] = {DEFAULT_CURRENCY: initial_assets}
 
         # IMortgageBorrower
-        self.current_wage: float = 0.0
+        self.current_wage: int = 0
 
         # IPropertyOwner
         self.owned_properties: List[int] = []
diff --git a/simulation/firms.py b/simulation/firms.py
index ba87ff82..345328c4 100644
--- a/simulation/firms.py
+++ b/simulation/firms.py
@@ -178,7 +178,7 @@ class Firm(ILearningAgent, IFinancialFirm, IFinancialAgent, ILiquidatable, IOrch
         return LiquidationConfigDTO(
             haircut=self.config.fire_sale_discount,
             initial_prices=initial_prices,
-            default_price=10.0,
+            default_price=1000,
             market_prices=self.last_prices.copy()
         )
 
diff --git a/simulation/orchestration/utils.py b/simulation/orchestration/utils.py
index 26a8dd94..95d195a7 100644
--- a/simulation/orchestration/utils.py
+++ b/simulation/orchestration/utils.py
@@ -67,7 +67,7 @@ def prepare_market_data(state: SimulationState) -> Dict[str, Any]:
                 latest = tracker.get_latest_indicators()
                 avg_price = latest.get(f"{good_name}_avg_price", 0)
             if avg_price <= 0:
-                avg_price = state.config_module.GOODS[good_name].get("initial_price", 10.0)
+                avg_price = state.config_module.GOODS[good_name].get("initial_price", 1000)
 
             goods_market_data[f"{good_name}_current_sell_price"] = avg_price
 
@@ -101,7 +101,7 @@ def prepare_market_data(state: SimulationState) -> Dict[str, Any]:
             total_price += price
             count += 1
 
-    avg_goods_price_for_market_data = total_price / count if count > 0 else 10.0
+    avg_goods_price_for_market_data = total_price / count if count > 0 else 1000
 
     stock_market_data = {}
     if state.stock_market:
@@ -112,7 +112,7 @@ def prepare_market_data(state: SimulationState) -> Dict[str, Any]:
                 price = state.stock_market.get_best_ask(firm.id) or 0
             if price <= 0:
                 asset_val = float(firm.get_balance(DEFAULT_CURRENCY))
-                price = asset_val / firm.total_shares if firm.total_shares > 0 else 10.0
+                price = asset_val / firm.total_shares if firm.total_shares > 0 else 1000
             stock_market_data[firm_item_id] = {"avg_price": price}
 
     rent_prices = [u.rent_price for u in state.real_estate_units if u.owner_id is not None]
diff --git a/simulation/systems/liquidation_handlers.py b/simulation/systems/liquidation_handlers.py
index 692a3fba..5b9b9fa1 100644
--- a/simulation/systems/liquidation_handlers.py
+++ b/simulation/systems/liquidation_handlers.py
@@ -75,8 +75,8 @@ class InventoryLiquidationHandler(ILiquidationHandler):
 
         if total_value > 0:
             # Transfer Funds: PublicManager -> Agent
-            # Convert float dollars to int pennies for SettlementSystem
-            amount_pennies = int(total_value * 100)
+            # Value is already in pennies (since price is in pennies)
+            amount_pennies = int(total_value)
 
             success = self.settlement_system.transfer(
                 self.public_manager,
diff --git a/simulation/systems/liquidation_manager.py b/simulation/systems/liquidation_manager.py
index c75aaf33..518a5712 100644
--- a/simulation/systems/liquidation_manager.py
+++ b/simulation/systems/liquidation_manager.py
@@ -173,7 +173,9 @@ class LiquidationManager:
 
         if creditor:
             memo = f"Liquidation Payout: {claim.description}" + (" (Partial)" if partial else "")
-            success = self.settlement_system.transfer(agent, creditor, amount, memo, currency=DEFAULT_CURRENCY)
+            # MIGRATION: Ensure amount is int pennies
+            amount_pennies = int(amount)
+            success = self.settlement_system.transfer(agent, creditor, amount_pennies, memo, currency=DEFAULT_CURRENCY)
             if not success:
                  logger.error(f"LIQUIDATION_PAYMENT_FAIL | Failed to transfer {amount:.2f} to {creditor.id}")
         else:
diff --git a/tests/integration/test_liquidation_waterfall.py b/tests/integration/test_liquidation_waterfall.py
index 85c1fdb7..0dff5068 100644
--- a/tests/integration/test_liquidation_waterfall.py
+++ b/tests/integration/test_liquidation_waterfall.py
@@ -170,8 +170,9 @@ class TestLiquidationWaterfallIntegration(unittest.TestCase):
             amount = args[2]
             paid_amounts[payee.id] = amount
 
-        self.assertAlmostEqual(paid_amounts[101], expected_A)
-        self.assertAlmostEqual(paid_amounts[102], expected_B)
+        # MIGRATION: int truncation
+        self.assertAlmostEqual(paid_amounts[101], int(expected_A), delta=1.0)
+        self.assertAlmostEqual(paid_amounts[102], int(expected_B), delta=1.0)
 
         # Verify Shareholders got nothing (no calls to shareholder agents)
         # Note: In this test setup, households list is empty so no shareholders loop ran anyway,
@@ -246,9 +247,10 @@ class TestLiquidationWaterfallIntegration(unittest.TestCase):
             amt = call[0][2]
             paid_map[payee.id] = amt
 
-        self.assertAlmostEqual(paid_map[101], severance)
+        # MIGRATION: int truncation
+        self.assertAlmostEqual(paid_map[101], int(severance), delta=1.0)
         self.assertAlmostEqual(paid_map["bank"], 5000.0)
-        self.assertAlmostEqual(paid_map[201], equity_payout)
+        self.assertAlmostEqual(paid_map[201], int(equity_payout), delta=1.0)
 
     def test_asset_rich_cash_poor_liquidation(self):
         """
@@ -268,7 +270,7 @@ class TestLiquidationWaterfallIntegration(unittest.TestCase):
         self._setup_registry()
         self.firm.finance.balance = {DEFAULT_CURRENCY: 0.0}
         self.firm.inventory = {"apples": 100.0}
-        self.firm.last_prices = {"apples": 10.0}
+        self.firm.last_prices = {"apples": 1000}
 
         # Mock public manager managed inventory update
         self.mock_public_manager.managed_inventory = {"apples": 0.0}
diff --git a/tests/unit/systems/handlers/test_liquidation_handlers.py b/tests/unit/systems/handlers/test_liquidation_handlers.py
index a663edf8..74ef9035 100644
--- a/tests/unit/systems/handlers/test_liquidation_handlers.py
+++ b/tests/unit/systems/handlers/test_liquidation_handlers.py
@@ -44,11 +44,11 @@ class TestInventoryLiquidationHandler(unittest.TestCase):
         self.firm.get_liquidation_config.return_value = LiquidationConfigDTO(
             haircut=0.2,
             initial_prices={},
-            default_price=10.0,
-            market_prices={"apple": 5.0}
+            default_price=1000,
+            market_prices={"apple": 500}
         )
 
-        # 10 * 5.0 * (1 - 0.2) = 50 * 0.8 = 40.0
+        # 10 * 500 * (1 - 0.2) = 5000 * 0.8 = 4000.0
 
         self.mock_settlement.transfer.return_value = True
 
@@ -69,12 +69,12 @@ class TestInventoryLiquidationHandler(unittest.TestCase):
         self.firm.get_all_items.return_value = {"unknown": 10}
         self.firm.get_liquidation_config.return_value = LiquidationConfigDTO(
             haircut=0.2,
-            initial_prices={"unknown": 10.0},
-            default_price=10.0,
+            initial_prices={"unknown": 1000},
+            default_price=1000,
             market_prices={}
         )
-        # default price 10.0
-        # 10 * 10.0 * 0.8 = 80.0
+        # default price 1000
+        # 10 * 1000 * 0.8 = 8000.0
 
         self.mock_settlement.transfer.return_value = True
         self.handler.liquidate(self.firm, self.state)
@@ -93,8 +93,8 @@ class TestInventoryLiquidationHandler(unittest.TestCase):
         self.firm.get_liquidation_config.return_value = LiquidationConfigDTO(
             haircut=0.2,
             initial_prices={},
-            default_price=10.0,
-            market_prices={"apple": 5.0}
+            default_price=1000,
+            market_prices={"apple": 500}
         )
 
         self.mock_settlement.transfer.return_value = False
diff --git a/tests/unit/systems/test_liquidation_manager.py b/tests/unit/systems/test_liquidation_manager.py
index 936b94cb..87a76e14 100644
--- a/tests/unit/systems/test_liquidation_manager.py
+++ b/tests/unit/systems/test_liquidation_manager.py
@@ -86,15 +86,15 @@ class TestLiquidationManager(unittest.TestCase):
         self.firm.liquidate_assets.assert_called_once_with(self.state.time)
 
         # Verify Transfers
-        # Expect transfers for both claims
+        # Expect transfers for both claims (Values cast to int by manager)
         self.mock_settlement.transfer.assert_has_calls([
-            call(self.firm, agent_101, 100.0, "Liquidation Payout: Wage", currency=DEFAULT_CURRENCY),
-            call(self.firm, agent_gov, 50.0, "Liquidation Payout: Tax", currency=DEFAULT_CURRENCY)
+            call(self.firm, agent_101, 100, "Liquidation Payout: Wage", currency=DEFAULT_CURRENCY),
+            call(self.firm, agent_gov, 50, "Liquidation Payout: Tax", currency=DEFAULT_CURRENCY)
         ], any_order=True)
 
     def test_bank_claim_handling(self):
         # Setup Bank Debt
-        self.firm.total_debt = 500.0
+        self.firm.total_debt = 500
 
         # Mock Decision Engine structure since Firm is a spec mock
         self.firm.decision_engine = MagicMock()
@@ -114,7 +114,7 @@ class TestLiquidationManager(unittest.TestCase):
 
         # Check transfer to bank
         self.mock_settlement.transfer.assert_called_with(
-            self.firm, bank_agent, 500.0, "Liquidation Payout: Secured Loan", currency=DEFAULT_CURRENCY
+            self.firm, bank_agent, 500, "Liquidation Payout: Secured Loan", currency=DEFAULT_CURRENCY
         )
 
     def test_asset_liquidation_integration(self):
@@ -123,9 +123,9 @@ class TestLiquidationManager(unittest.TestCase):
         self.firm.get_all_items = MagicMock(return_value={"apple": 10})
         self.firm.get_liquidation_config.return_value = LiquidationConfigDTO(
             haircut=0.2,
-            initial_prices={"default": 10.0},
-            default_price=10.0,
-            market_prices={"apple": 5.0}
+            initial_prices={"default": 1000},
+            default_price=1000,
+            market_prices={"apple": 500}
         )
 
         self.mock_settlement.transfer.return_value = True
@@ -133,7 +133,7 @@ class TestLiquidationManager(unittest.TestCase):
         self.manager.initiate_liquidation(self.firm, self.state)
 
         # Check transfer for asset liquidation
-        # 10 * 5.0 * 0.8 = 40.0
+        # 10 * 500 * 0.8 = 4000.0
         # Note: Code uses "Agent {id}" not "Firm {id}"
         self.mock_settlement.transfer.assert_any_call(
             self.mock_public,
