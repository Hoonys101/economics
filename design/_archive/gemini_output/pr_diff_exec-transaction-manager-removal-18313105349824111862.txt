diff --git a/communications/insights/exec-transaction-manager-removal.md b/communications/insights/exec-transaction-manager-removal.md
new file mode 100644
index 00000000..ff14b99a
--- /dev/null
+++ b/communications/insights/exec-transaction-manager-removal.md
@@ -0,0 +1,71 @@
+# Mission Report: Legacy TransactionManager Removal
+
+## 1. Architectural Insights
+
+### Transaction Processor as SSoT
+The refactoring confirms `TransactionProcessor` as the Single Source of Truth (SSoT) for transaction orchestration. It effectively decouples the "How" (processing logic) from the "What" (transaction data) by using specialized handlers (`ITransactionHandler`).
+
+-   **Modular Handlers**: Logic previously inline in `TransactionManager` (e.g., OMO, Public Manager, Tax) is now cleanly encapsulated in `MonetaryTransactionHandler`, `PublicManagerTransactionHandler`, `LaborTransactionHandler`, etc.
+-   **Zero-Sum Integrity**: `TransactionProcessor` relies on `SettlementSystem` (and `settle_atomic`) which enforces zero-sum transfers, preventing magic money creation.
+-   **Protocol Compliance**: The new architecture strictly adheres to protocols like `ITransactionHandler`, improving type safety and testability.
+
+### Regressions Fixed
+During migration, I identified and fixed a regression in `MonetaryTransactionHandler` where `omo_sale` transactions (Quantitative Tightening) were not updating the `government.total_money_destroyed` ledger. This ensures accurate tracking of monetary contraction.
+
+### Test Fidelity Improvements
+The tests (`test_public_manager_integration.py`, `test_omo_system.py`, `test_tax_incidence.py`) were refactored to:
+-   Use `TransactionProcessor` instead of the legacy manager.
+-   Instantiate proper handlers and register them.
+-   Correctly mock dependencies (like `TaxationSystem` initialization via config).
+-   Enforce stricter asset types (Pennies vs Dollars) in mock agents (e.g. `MockAgent` in `test_public_manager_integration.py`).
+
+## 2. Test Evidence
+
+The following output demonstrates that all affected integration and unit tests pass with `TransactionProcessor`.
+
+```
+============================= test session starts ==============================
+platform linux -- Python 3.12.3, pytest-8.3.4, pluggy-1.5.0
+rootdir: /home/jules/simulation
+configfile: pytest.ini
+plugins: asyncio-0.25.3, cov-6.0.0, anyio-4.8.0, html-4.1.1, metadata-3.1.1, timeout-2.3.1
+asyncio: mode=Mode.STRICT, default_loop_scope=function
+collected 7 items
+
+tests/integration/test_public_manager_integration.py::TestPublicManagerIntegration::test_full_liquidation_cycle
+-------------------------------- live log call ---------------------------------
+WARNING  PublicManager:public_manager.py:69 Processing bankruptcy for Agent 99 at tick 1. Recovering inventory.
+INFO     PublicManager:public_manager.py:74 Recovered 10.0 of gold.
+INFO     PublicManager:public_manager.py:115 Generated liquidation order for 10.0 of gold at 100.0.
+PASSED                                                                   [ 14%]
+tests/integration/test_omo_system.py::test_execute_omo_purchase_order_creation PASSED [ 28%]
+tests/integration/test_omo_system.py::test_execute_omo_sale_order_creation PASSED [ 42%]
+tests/integration/test_omo_system.py::test_process_omo_purchase_transaction PASSED [ 57%]
+tests/integration/test_omo_system.py::test_process_omo_sale_transaction PASSED [ 71%]
+tests/unit/test_tax_incidence.py::TestTaxIncidence::test_firm_payer_scenario
+-------------------------------- live log call ---------------------------------
+INFO     simulation.agents.government:government.py:163 Government 999 initialized with assets: defaultdict(<class 'int'>, {'USD': 0})
+INFO     TestTaxIncidence:engine.py:126 Transaction Record: ID=atomic_0_0, Status=COMPLETED, Message=Transaction successful (Batch)
+INFO     TestTaxIncidence:engine.py:126 Transaction Record: ID=atomic_0_1, Status=COMPLETED, Message=Transaction successful (Batch)
+PASSED                                                                   [ 85%]
+tests/unit/test_tax_incidence.py::TestTaxIncidence::test_household_payer_scenario
+-------------------------------- live log call ---------------------------------
+INFO     simulation.agents.government:government.py:163 Government 999 initialized with assets: defaultdict(<class 'int'>, {'USD': 0})
+INFO     TestTaxIncidence:engine.py:126 Transaction Record: ID=atomic_0_0, Status=COMPLETED, Message=Transaction successful (Batch)
+INFO     TestTaxIncidence:engine.py:126 Transaction Record: ID=atomic_0_1, Status=COMPLETED, Message=Transaction successful (Batch)
+PASSED                                                                   [100%]
+
+=============================== warnings summary ===============================
+../home/jules/.local/share/pipx/venvs/pytest/lib/python3.12/site-packages/_pytest/config/__init__.py:1428
+  /home/jules/.local/share/pipx/venvs/pytest/lib/python3.12/site-packages/_pytest/config/__init__.py:1428: PytestConfigWarning: Unknown config option: asyncio_default_fixture_loop_scope
+
+    self._warn_or_fail_if_strict(f"Unknown config option: {key}\n")
+
+../home/jules/.local/share/pipx/venvs/pytest/lib/python3.12/site-packages/_pytest/config/__init__.py:1428
+  /home/jules/.local/share/pipx/venvs/pytest/lib/python3.12/site-packages/_pytest/config/__init__.py:1428: PytestConfigWarning: Unknown config option: asyncio_mode
+
+    self._warn_or_fail_if_strict(f"Unknown config option: {key}\n")
+
+-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
+======================== 7 passed, 2 warnings in 0.30s =========================
+```
diff --git a/simulation/systems/handlers/monetary_handler.py b/simulation/systems/handlers/monetary_handler.py
index 09410bd6..af7485bb 100644
--- a/simulation/systems/handlers/monetary_handler.py
+++ b/simulation/systems/handlers/monetary_handler.py
@@ -78,6 +78,13 @@ class MonetaryTransactionHandler(ITransactionHandler):
             success = context.settlement_system.transfer(
                 buyer, seller, int(trade_value), tx_type
             )
+            if success and context.central_bank and seller.id == context.central_bank.id:
+                if hasattr(context.government, "total_money_destroyed"):
+                    context.government.total_money_destroyed += trade_value
+                context.logger.info(
+                    f"QT | Central Bank sold bond/asset {trade_value:.2f}.",
+                    extra={"tick": context.time, "tag": "QT"}
+                )
 
         return success is not None
 
diff --git a/simulation/systems/transaction_manager.py b/simulation/systems/transaction_manager.py
deleted file mode 100644
index 28539e9c..00000000
--- a/simulation/systems/transaction_manager.py
+++ /dev/null
@@ -1,204 +0,0 @@
-from typing import List, Dict, Any, Optional, TYPE_CHECKING
-import logging
-
-from simulation.systems.api import (
-    SystemInterface,
-    IMintingAuthority,
-    IAccountingSystem,
-    IRegistry,
-    ISpecializedTransactionHandler
-)
-from simulation.dtos.api import SimulationState
-from simulation.models import Transaction
-from simulation.core_agents import Household
-from simulation.firms import Firm
-from modules.finance.utils.currency_math import round_to_pennies
-from modules.government.constants import DEFAULT_BASIC_FOOD_PRICE
-from modules.finance.transaction.handlers import GoodsTransactionHandler, LaborTransactionHandler
-
-logger = logging.getLogger(__name__)
-
-class TransactionManager(SystemInterface):
-    """
-    Orchestrates the transaction processing pipeline.
-    Replaces the monolithic TransactionProcessor.
-    Follows the 6-layer architecture (TD-124).
-    """
-
-    def __init__(
-        self,
-        registry: IRegistry,
-        accounting_system: IAccountingSystem,
-        settlement_system: Any, # ISettlementSystem
-        central_bank_system: IMintingAuthority,
-        config: Any,
-        escrow_agent: Any, # IFinancialEntity
-        handlers: Optional[Dict[str, ISpecializedTransactionHandler]] = None,
-        logger: Optional[logging.Logger] = None
-    ):
-        self.registry = registry
-        self.accounting = accounting_system
-        self.settlement = settlement_system
-        self.central_bank = central_bank_system
-        self.config = config
-        self.escrow_agent = escrow_agent
-        self.handlers = handlers if handlers else {}
-        self.logger = logger if logger else logging.getLogger(__name__)
-
-        # Default Handlers
-        if "goods" not in self.handlers:
-            self.handlers["goods"] = GoodsTransactionHandler()
-        if "labor" not in self.handlers:
-            self.handlers["labor"] = LaborTransactionHandler()
-        if "research_labor" not in self.handlers:
-            self.handlers["research_labor"] = LaborTransactionHandler()
-
-    def execute(self, state: SimulationState) -> None:
-        """
-        Processes all transactions in the current tick.
-        """
-        transactions = state.transactions
-        agents = state.agents
-        government = state.government
-        current_time = state.time
-
-        # WO-109: Look up inactive agents
-        inactive_agents = getattr(state, "inactive_agents", {})
-
-        for tx in transactions:
-            # Phase 3: Public Manager Support
-            if tx.seller_id == "PUBLIC_MANAGER" or tx.seller_id == -1:
-                buyer = agents.get(tx.buyer_id) or inactive_agents.get(tx.buyer_id)
-                if not buyer:
-                    continue
-
-                trade_value = int(tx.quantity * tx.price)
-
-                # Debit Buyer & Credit Public Manager
-                try:
-                    # Manually withdraw from buyer (simulating payment to system)
-                    buyer.withdraw(trade_value)
-
-                    # Credit Public Manager Treasury
-                    if hasattr(state, "public_manager") and state.public_manager:
-                        state.public_manager.deposit_revenue(trade_value)
-                        state.public_manager.confirm_sale(tx.item_id, tx.quantity)
-
-                    # Trigger state updates (Ownership, etc.)
-                    # Pass seller as None (Registry handles None seller safely by skipping seller updates)
-                    self.registry.update_ownership(tx, buyer, None, state)
-
-                    # Record for accounting (Seller=None)
-                    self.accounting.record_transaction(tx, buyer, None, trade_value, 0.0)
-
-                except Exception as e:
-                    import traceback
-                    self.logger.error(f"PUBLIC_MANAGER transaction failed: {e}\n{traceback.format_exc()}")
-
-                continue
-
-            buyer = agents.get(tx.buyer_id) or inactive_agents.get(tx.buyer_id)
-            seller = agents.get(tx.seller_id) or inactive_agents.get(tx.seller_id)
-
-            if not buyer and not seller:
-                continue
-
-            trade_value = int(tx.quantity * tx.price)
-            if tx.total_pennies > 0:
-                 trade_value = tx.total_pennies
-
-            tax_amount = 0
-            success = False
-
-            # ==================================================================
-            # 1. Specialized Handlers (Sagas)
-            # ==================================================================
-            if tx.transaction_type in self.handlers:
-                success = self.handlers[tx.transaction_type].handle(tx, buyer, seller, state)
-
-            # ==================================================================
-            # 2. Financial Layer (Routing)
-            # ==================================================================
-            elif tx.transaction_type == "lender_of_last_resort":
-                # Minting: Central Bank -> Bank
-                # Note: 'buyer' is typically Government/System, 'seller' is Bank receiving funds.
-                success = self.central_bank.mint_and_transfer(seller, trade_value, "lender_of_last_resort")
-                if success and hasattr(buyer, "total_money_issued"):
-                    buyer.total_money_issued += trade_value
-
-            elif tx.transaction_type == "omo_purchase":
-                 # OMO Purchase: CB buys from Agent. Minting.
-                 # Buyer: CentralBank (ID=-2), Seller: Agent
-                 success = self.central_bank.mint_and_transfer(seller, trade_value, "omo_purchase")
-                 if success:
-                     if hasattr(government, "total_money_issued"):
-                         government.total_money_issued += trade_value
-                     # Notify CentralBankSystem for logging
-                     self.central_bank.process_omo_settlement(tx)
-
-            elif tx.transaction_type == "omo_sale":
-                 # OMO Sale: Agent buys from CB. Burning.
-                 # Buyer: Agent, Seller: CentralBank
-                 success = self.central_bank.transfer_and_burn(buyer, trade_value, "omo_sale")
-                 if success:
-                     if hasattr(government, "total_money_destroyed"):
-                         government.total_money_destroyed += trade_value
-                     # Notify CentralBankSystem for logging
-                     self.central_bank.process_omo_settlement(tx)
-
-            elif tx.transaction_type == "asset_liquidation":
-                # Minting: Central Bank -> Agent (Liquidation)
-                success = self.central_bank.mint_and_transfer(seller, trade_value, "asset_liquidation")
-                # Registry handles asset transfer/destruction implicitly or explicitly via update_ownership
-                # if needed. TransactionProcessor handled asset transfer for stock/real_estate here.
-                # If success, we should update ownership (Registry) in the State Commitment phase.
-
-            elif tx.transaction_type == "inheritance_distribution":
-                 # Handled by handlers['inheritance_distribution'] usually.
-                 # If handler is missing, log error?
-                 if "inheritance_distribution" not in self.handlers:
-                     self.logger.error("TransactionManager: Missing handler for inheritance_distribution")
-                 continue
-
-            elif tx.transaction_type == "escheatment":
-                 # Buyer: Agent (Deceased/Closed), Seller: Government
-                 # Atomic Collection via Government (handles transfer and confirmed recording)
-                 result = government.collect_tax(trade_value, "escheatment", buyer, current_time)
-                 success = result['success']
-
-            elif tx.transaction_type == "dividend":
-                success = self.settlement.transfer(seller, buyer, trade_value, "dividend_payment")
-
-            elif tx.transaction_type == "tax":
-                 # Atomic Collection via Government
-                 result = government.collect_tax(trade_value, tx.item_id, buyer, current_time)
-                 success = result['success']
-
-            elif tx.transaction_type == "interest_payment":
-                 success = self.settlement.transfer(buyer, seller, trade_value, "interest_payment")
-
-            elif tx.transaction_type == "infrastructure_spending":
-                 success = self.settlement.transfer(buyer, seller, trade_value, "infrastructure_spending")
-
-            elif tx.transaction_type == "emergency_buy":
-                 success = self.settlement.transfer(buyer, seller, trade_value, "emergency_buy")
-
-            else:
-                # Default Transfer (Zero-Sum)
-                memo_id = tx.item_id if tx.item_id else tx.transaction_type
-                success = self.settlement.transfer(buyer, seller, trade_value, f"generic:{tx.transaction_type}:{memo_id}")
-
-            # ==================================================================
-            # 3. State Commitment (Registry & Accounting)
-            # ==================================================================
-            if success:
-                # Update Non-Financial State (Ownership, Inventory, Employment)
-                # Registry handles logic based on transaction type
-                self.registry.update_ownership(tx, buyer, seller, state)
-
-                # Update Ledgers (Revenue, Expenses, Income Counters)
-                self.accounting.record_transaction(tx, buyer, seller, trade_value, tax_amount)
-
-                # WO-109: Deferred Effects
-                if tx.metadata and tx.metadata.get("triggers_effect"):
-                    state.effects_queue.append(tx.metadata)
diff --git a/tests/integration/test_omo_system.py b/tests/integration/test_omo_system.py
index 1e999caa..afb38741 100644
--- a/tests/integration/test_omo_system.py
+++ b/tests/integration/test_omo_system.py
@@ -2,7 +2,8 @@ import pytest
 from unittest.mock import MagicMock, Mock
 from typing import List, Any, Dict
 from simulation.systems.central_bank_system import CentralBankSystem
-from simulation.systems.transaction_manager import TransactionManager
+from simulation.systems.transaction_processor import TransactionProcessor
+from simulation.systems.handlers.monetary_handler import MonetaryTransactionHandler
 from simulation.systems.settlement_system import SettlementSystem
 from simulation.models import Order, Transaction
 from modules.finance.api import OMOInstructionDTO, IFinancialEntity, IFinancialAgent, InsufficientFundsError
@@ -102,18 +103,23 @@ def omo_setup():
     }
     state.government = gov_agent
     state.transactions = []
-
-    tx_manager = TransactionManager(
-        registry=MagicMock(),
-        accounting_system=MagicMock(),
-        settlement_system=settlement,
-        central_bank_system=cb_system,
-        config=MagicMock(),
-        escrow_agent=MagicMock(),
-        logger=logger
-    )
-
-    return cb_system, tx_manager, state, cb_agent, gov_agent, household, settlement
+    state.time = 1
+    state.settlement_system = settlement
+    state.central_bank = cb_agent
+    state.logger = logger
+    state.bank = None
+    state.inactive_agents = {}
+    state.taxation_system = None
+    state.stock_market = None
+    state.real_estate_units = []
+    state.market_data = {}
+    state.shareholder_registry = None
+
+    tp = TransactionProcessor(config_module=MagicMock())
+    tp.register_handler("omo_purchase", MonetaryTransactionHandler())
+    tp.register_handler("omo_sale", MonetaryTransactionHandler())
+
+    return cb_system, tp, state, cb_agent, gov_agent, household, settlement
 
 def test_execute_omo_purchase_order_creation(omo_setup):
     cb_system, _, _, _, _, _, _ = omo_setup
@@ -150,7 +156,7 @@ def test_execute_omo_sale_order_creation(omo_setup):
     assert orders[0].market_id == "security_market"
 
 def test_process_omo_purchase_transaction(omo_setup):
-    cb_system, tx_manager, state, cb_agent, gov_agent, household, settlement = omo_setup
+    cb_system, tp, state, cb_agent, gov_agent, household, settlement = omo_setup
 
     # Household sells bond to CB (OMO Purchase by CB)
     # CB pays Household (Minting new money)
@@ -173,17 +179,14 @@ def test_process_omo_purchase_transaction(omo_setup):
 
     # Audit M2 before (Sum of non-CB agents)
     # M2 = Household(500) + Gov(1000) = 1500
-    initial_m2 = settlement.audit_total_m2(expected_total=None) # Returns bool, but logs value.
-    # We can calculate manually for assertion or trust audit_total_m2 logic.
-    # Let's calculate manually using settlement.get_balance
     m2_before = settlement.get_balance(household.id) + settlement.get_balance(gov_agent.id)
 
-    tx_manager.execute(state)
+    tp.execute(state)
 
     # Verify Household got paid via SSoT
     assert settlement.get_balance(household.id) == initial_hh_assets + trade_price
 
-    # Verify Gov Ledger Updated (Minting) - TransactionManager updates this manually on gov agent
+    # Verify Gov Ledger Updated (Minting)
     assert gov_agent.total_money_issued == initial_money_issued + trade_price
 
     # Verify Zero-Sum Integrity (M2 Expansion)
@@ -195,7 +198,7 @@ def test_process_omo_purchase_transaction(omo_setup):
     assert settlement.audit_total_m2(expected_total=m2_after) is True
 
 def test_process_omo_sale_transaction(omo_setup):
-    cb_system, tx_manager, state, cb_agent, gov_agent, household, settlement = omo_setup
+    cb_system, tp, state, cb_agent, gov_agent, household, settlement = omo_setup
 
     # Household buys bond from CB (OMO Sale by CB)
     # Household pays CB (Burning money)
@@ -217,7 +220,7 @@ def test_process_omo_sale_transaction(omo_setup):
 
     m2_before = settlement.get_balance(household.id) + settlement.get_balance(gov_agent.id)
 
-    tx_manager.execute(state)
+    tp.execute(state)
 
     # Verify Household paid via SSoT
     assert settlement.get_balance(household.id) == initial_hh_assets - trade_price
diff --git a/tests/integration/test_public_manager_integration.py b/tests/integration/test_public_manager_integration.py
index 0d763b6b..620585db 100644
--- a/tests/integration/test_public_manager_integration.py
+++ b/tests/integration/test_public_manager_integration.py
@@ -2,12 +2,14 @@ import pytest
 from unittest.mock import MagicMock
 from simulation.models import Transaction, Order
 from modules.system.execution.public_manager import PublicManager
-from simulation.systems.transaction_manager import TransactionManager
+from simulation.systems.transaction_processor import TransactionProcessor
+from simulation.systems.handlers.public_manager_handler import PublicManagerTransactionHandler
 from simulation.systems.registry import Registry
 from simulation.systems.accounting import AccountingSystem
 from modules.system.api import MarketSignalDTO, DEFAULT_CURRENCY
+from modules.simulation.api import IInventoryHandler, InventorySlot
 
-class MockAgent:
+class MockAgent(IInventoryHandler):
     def __init__(self, agent_id, assets=0.0):
         self.id = agent_id
         self.assets = assets
@@ -17,7 +19,7 @@ class MockAgent:
 
     def withdraw(self, amount, currency=DEFAULT_CURRENCY):
         if self.assets < amount:
-            raise Exception("Insufficient funds")
+            raise Exception(f"Insufficient funds: {self.assets} < {amount}")
         self.assets -= amount
 
     def deposit(self, amount, currency=DEFAULT_CURRENCY):
@@ -33,6 +35,28 @@ class MockAgent:
     def total_wealth(self):
         return self.assets
 
+    def add_item(self, item_id, quantity, quality=1.0, slot=None):
+        self.inventory[item_id] = self.inventory.get(item_id, 0.0) + quantity
+
+    def consume(self, item_id, quantity, time):
+        pass
+
+    @property
+    def current_consumption(self):
+        return 0.0
+
+    @current_consumption.setter
+    def current_consumption(self, value):
+        pass
+
+    @property
+    def current_food_consumption(self):
+        return 0.0
+
+    @current_food_consumption.setter
+    def current_food_consumption(self, value):
+        pass
+
 class TestPublicManagerIntegration:
     def test_full_liquidation_cycle(self):
         # 1. Setup PublicManager
@@ -88,52 +112,76 @@ class TestPublicManagerIntegration:
 
         # 4. Simulate Market Matching (Phase 2/5)
         # Assume market matched it perfectly
-        buyer = MockAgent(2, assets=5000.0)
+        buyer = MockAgent(2, assets=500000.0) # Enough assets for 100000 pennies
 
         tx = Transaction(
             item_id="gold",
             quantity=10.0,
             price=100.0,
             buyer_id=buyer.id,
-            seller_id=-1,
+            seller_id="PUBLIC_MANAGER", # Explicitly set seller to PM
             market_id="gold",
             transaction_type="goods",
             time=1
         , total_pennies=100000)
 
         # 5. Execute Transaction (Phase 3)
-        # Setup TransactionManager dependencies
-        # Mock Registry to avoid side effects (Inventory update) failing on MockAgent
-        registry = MagicMock()
-        accounting = MagicMock() # Mock accounting
-        settlement = MagicMock() # Mock settlement (won't be used for PublicManager)
-
-        tm = TransactionManager(registry, accounting, settlement, MagicMock(), config, MagicMock())
+        # Setup TransactionProcessor
+        tp = TransactionProcessor(config_module=config)
+        tp.register_public_manager_handler(PublicManagerTransactionHandler())
+
+        # Mock Settlement System
+        settlement = MagicMock()
+
+        def transfer_side_effect(buyer_agent, seller_agent, amount, memo):
+             buyer_agent.withdraw(amount)
+             if seller_agent == pm:
+                 pm.deposit_revenue(amount)
+             return True
+
+        def settle_atomic_side_effect(payer, credits, time):
+             total_amount = sum(c[1] for c in credits)
+             payer.withdraw(total_amount)
+             for payee, amount, memo in credits:
+                 if payee == pm:
+                     pm.deposit_revenue(amount)
+             return True
+
+        settlement.transfer.side_effect = transfer_side_effect
+        settlement.settle_atomic.side_effect = settle_atomic_side_effect
 
         # Setup State
         state = MagicMock()
         state.transactions = [tx]
         state.agents = {buyer.id: buyer}
+        state.inactive_agents = {}
         state.public_manager = pm
         state.market_data = {}
         state.config_module = config
         state.time = 1
+        state.settlement_system = settlement
+        state.taxation_system = None # Should be auto-initialized by TP
+        state.stock_market = None
+        state.real_estate_units = []
+        state.logger = MagicMock()
+        state.bank = None
+        state.central_bank = None
+        state.shareholder_registry = None
 
-        tm.execute(state)
+        # Mock Government in state because settle_atomic calculates tax credits to government
+        state.government = MagicMock()
 
-        # 6. Verify Outcome
-        # Buyer assets should decrease: 10 * 100 = 1000
-        assert buyer.get_balance(DEFAULT_CURRENCY) == 4000.0
+        tp.execute(state)
 
+        # 6. Verify Outcome
         # PublicManager treasury should increase
-        assert pm.system_treasury[DEFAULT_CURRENCY] == 1000.0
+        assert pm.system_treasury[DEFAULT_CURRENCY] == 100000.0
 
         # PublicManager inventory should decrease (via confirm_sale)
         assert pm.managed_inventory["gold"] == 0.0
 
-        # Buyer inventory should increase (via Registry)
-        # Since we mocked Registry, we check if Registry was called
-        registry.update_ownership.assert_called()
+        # Buyer inventory should increase
+        assert buyer.inventory["gold"] == 10.0
 
-        # Accounting recorded?
-        assert accounting.record_transaction.called
+        # Buyer assets check
+        assert buyer.assets == 400000.0
diff --git a/tests/unit/test_tax_incidence.py b/tests/unit/test_tax_incidence.py
index 4021404a..8744de8b 100644
--- a/tests/unit/test_tax_incidence.py
+++ b/tests/unit/test_tax_incidence.py
@@ -38,9 +38,15 @@ class TestTaxIncidence(unittest.TestCase):
             action_proposal_engine=self.action_proposal_engine,
             state_builder=self.state_builder
         )
+        # Preserve original config
+        self.original_income_tax_payer = getattr(cfg, "INCOME_TAX_PAYER", "HOUSEHOLD")
+        self.original_income_tax_rate = getattr(cfg, "INCOME_TAX_RATE", 0.0)
 
     def tearDown(self):
         self.repository.close()
+        # Restore config
+        cfg.INCOME_TAX_PAYER = self.original_income_tax_payer
+        cfg.INCOME_TAX_RATE = self.original_income_tax_rate
 
     def _create_household(self, id: int, assets: float):
         mock_de = MagicMock(spec=IDecisionEngine)
@@ -114,6 +120,9 @@ class TestTaxIncidence(unittest.TestCase):
         sim.world_state.government = gov
         sim.world_state.agents[999] = gov
 
+        # Ensure gov uses the test-configured tax rate (since cfg might be read during init)
+        gov.income_tax_rate = cfg.INCOME_TAX_RATE
+
         # SettlementSystem
         from simulation.systems.settlement_system import SettlementSystem
         sim.settlement_system = SettlementSystem(logger=logger)
@@ -122,8 +131,10 @@ class TestTaxIncidence(unittest.TestCase):
         f.settlement_system = sim.settlement_system
         gov.settlement_system = sim.settlement_system
 
-        # TransactionManager components
-        from simulation.systems.transaction_manager import TransactionManager
+        # TransactionProcessor components
+        from simulation.systems.transaction_processor import TransactionProcessor
+        from simulation.systems.handlers.labor_handler import LaborTransactionHandler
+        from simulation.systems.handlers.financial_handler import FinancialTransactionHandler
         from simulation.systems.registry import Registry
         from simulation.systems.accounting import AccountingSystem
         from simulation.systems.central_bank_system import CentralBankSystem
@@ -140,22 +151,19 @@ class TestTaxIncidence(unittest.TestCase):
             return sim.world_state.agents.get(aid)
         mock_agent_registry.get_agent.side_effect = get_agent_side_effect
         sim.settlement_system.agent_registry = mock_agent_registry
-        sim.world_state.transaction_processor = TransactionManager(
-            registry=sim.registry,
-            accounting_system=sim.accounting_system,
-            settlement_system=sim.settlement_system,
-            central_bank_system=sim.central_bank_system,
-            escrow_agent=MagicMock(),
-            config=cfg,
-            handlers={},
-            logger=logger
-        )
+
+        sim.transaction_processor = TransactionProcessor(config_module=cfg)
+        sim.transaction_processor.register_handler("labor", LaborTransactionHandler())
+        sim.transaction_processor.register_handler("tax", FinancialTransactionHandler())
+        sim.world_state.transaction_processor = sim.transaction_processor
 
         return sim
 
     def test_household_payer_scenario(self):
         """가계가 세금을 납부하는 경우 (원천징수)"""
         cfg.INCOME_TAX_PAYER = "HOUSEHOLD"
+        cfg.INCOME_TAX_RATE = 0.1 # Match TAX_RATE_BASE for 1.0 adjustment
+
         h = self._create_household(1, 100000)
         f = self._create_firm(101, 500000)
         sim = self._setup_simulation(h, f)
@@ -176,6 +184,8 @@ class TestTaxIncidence(unittest.TestCase):
     def test_firm_payer_scenario(self):
         """기업이 세금을 납부하는 경우 (추가 납부)"""
         cfg.INCOME_TAX_PAYER = "FIRM"
+        cfg.INCOME_TAX_RATE = 0.1 # Match TAX_RATE_BASE for 1.0 adjustment
+
         h = self._create_household(1, 100000)
         f = self._create_firm(101, 500000)
         sim = self._setup_simulation(h, f)
