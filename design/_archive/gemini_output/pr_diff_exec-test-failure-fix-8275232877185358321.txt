diff --git a/communications/insights/exec-test-failure-fix.md b/communications/insights/exec-test-failure-fix.md
new file mode 100644
index 00000000..c88121e2
--- /dev/null
+++ b/communications/insights/exec-test-failure-fix.md
@@ -0,0 +1,47 @@
+# Execution Insight: Restore Test Suite (Fix 10 Failures)
+
+## Architectural Insights
+
+During the resolution of the test failures, the following architectural observations and decisions were made:
+
+1.  **`websockets` Protocol Strictness (v14.0+)**:
+    The `SimulationServer`'s authentication hook (`_process_request`) was returning a tuple `(status, headers, body)` to reject connections. In modern `websockets` versions (specifically v14.0+ and the installed v16.0), the `process_request` hook *strictly* requires a `Response` object (imported from `websockets`) or `None`. Returning a tuple caused `AssertionError` in the library internals, leading to silent failures or incorrect behavior in tests. The server was updated to return `Response(status, reason, headers, body)`.
+
+2.  **Protocol Mocking vs. Implementation Reality**:
+    Unit tests for `LaborTransactionHandler` mocked `government` using `MagicMock(spec=ITaxCollector)`. However, the handler implementation relies on `government` being an `IAgent` (specifically accessing `.id`), which `ITaxCollector` does not mandate. This caused `AttributeError: Mock object has no attribute 'id'`. The fix involved using `MagicMock(spec=Government)` which satisfies the `ITaxCollector` protocol via inheritance/implementation and provides the necessary agent attributes.
+
+3.  **Deprecation of `Government.collect_tax`**:
+    The `Government` class no longer implements `collect_tax`. Tax collection has moved to a pattern using `SettlementSystem.settle_atomic` for the funds transfer followed by `Government.record_revenue` for accounting. Tests in `test_tax_collection.py` that attempted to call `collect_tax` were verifying a non-existent API and were removed.
+
+4.  **`HouseholdFactory` Contract Violation**:
+    The `HouseholdFactory.create_newborn` method was calling `SettlementSystem.transfer` using keyword arguments `sender`, `receiver`, and `transaction_type`. The `ISettlementSystem` protocol defines `debit_agent`, `credit_agent`, and `memo`. This mismatch would cause runtime failures if the arguments were not strictly positional (or if the implementation enforced kwargs). The factory was updated to use the correct argument names.
+
+5.  **Test Logic in `test_audit_integrity.py`**:
+    The `test_birth_gift_rounding` test mocked `HouseholdFactory` but asserted that `SettlementSystem.transfer` was called. Since the factory is responsible for the transfer, mocking the factory prevented the transfer from happening, causing the test to fail. The test was updated to verify the *inputs* to the mocked factory (`initial_assets` correctly rounded) rather than the side-effect it suppresses.
+
+## Test Evidence
+
+The following output demonstrates that the 10 previously failing tests (and related tests in the same files) now pass successfully.
+
+```text
+$ python3 -m pytest tests/unit/test_transaction_handlers.py tests/unit/test_tax_collection.py tests/security/test_websocket_auth.py tests/system/test_server_auth.py tests/system/test_audit_integrity.py
+
+tests/unit/test_transaction_handlers.py::TestGoodsTransactionHandler::test_goods_escrow_fail PASSED [  6%]
+tests/unit/test_transaction_handlers.py::TestGoodsTransactionHandler::test_goods_success PASSED [ 12%]
+tests/unit/test_transaction_handlers.py::TestGoodsTransactionHandler::test_goods_trade_fail_rollback PASSED [ 18%]
+tests/unit/test_transaction_handlers.py::TestLaborTransactionHandler::test_labor_firm_tax_payer PASSED [ 25%]
+tests/unit/test_transaction_handlers.py::TestLaborTransactionHandler::test_labor_household_tax_payer PASSED [ 31%]
+tests/unit/test_tax_collection.py::test_atomic_wealth_tax_collection_success PASSED [ 37%]
+tests/unit/test_tax_collection.py::test_atomic_wealth_tax_collection_insufficient_funds PASSED [ 43%]
+tests/security/test_websocket_auth.py::test_auth_success PASSED [ 50%]
+tests/security/test_websocket_auth.py::test_auth_missing_token PASSED [ 56%]
+tests/security/test_websocket_auth.py::test_auth_invalid_token PASSED [ 62%]
+tests/system/test_server_auth.py::test_auth_success PASSED [ 68%]
+tests/system/test_server_auth.py::test_auth_failure_invalid_token PASSED [ 75%]
+tests/system/test_server_auth.py::test_auth_failure_missing_token PASSED [ 81%]
+tests/system/test_audit_integrity.py::TestEconomicIntegrityAudit::test_birth_gift_rounding PASSED [ 87%]
+tests/system/test_audit_integrity.py::TestEconomicIntegrityAudit::test_inheritance_distribution PASSED [ 93%]
+tests/system/test_audit_integrity.py::TestEconomicIntegrityAudit::test_public_manager_tax_atomicity PASSED [100%]
+
+============================== 16 passed in 3.75s ==============================
+```
diff --git a/modules/system/server.py b/modules/system/server.py
index 1cd9817e..db51ee32 100644
--- a/modules/system/server.py
+++ b/modules/system/server.py
@@ -5,6 +5,7 @@ import logging
 import http
 import secrets
 import websockets
+from websockets import Response, Headers
 from modules.system.security import verify_god_mode_token
 from dataclasses import asdict, is_dataclass
 from typing import Optional, List, Dict
@@ -82,9 +83,8 @@ class SimulationServer:
         token = request.headers.get("X-GOD-MODE-TOKEN")
         if not verify_god_mode_token(token, self.god_mode_token):
             logger.warning(f"Unauthorized connection attempt to {request.path}. Token provided: {'Yes' if token else 'No'}")
-            # Return tuple (status, headers, body) to reject
-            # headers can be a list of tuples or dict.
-            return (http.HTTPStatus.UNAUTHORIZED, [], b"Unauthorized: Invalid God Token")
+            # Websockets 14.0+ requires a Response object for rejection
+            return Response(http.HTTPStatus.UNAUTHORIZED, "Unauthorized", Headers(), b"Unauthorized: Invalid God Token")
 
         # Log successful authentication
         logger.debug(f"Authorized connection established for {request.path}")
diff --git a/simulation/factories/household_factory.py b/simulation/factories/household_factory.py
index c2e29c08..1f310a1c 100644
--- a/simulation/factories/household_factory.py
+++ b/simulation/factories/household_factory.py
@@ -175,10 +175,10 @@ class HouseholdFactory(IHouseholdFactory):
         if initial_assets > 0:
             if self.context.settlement_system:
                 self.context.settlement_system.transfer(
-                    sender=parent,
-                    receiver=child,
+                    debit_agent=parent,
+                    credit_agent=child,
                     amount=initial_assets,
-                    transaction_type="BIRTH_GIFT",
+                    memo="BIRTH_GIFT",
                     tick=current_tick
                 )
             else:
diff --git a/tests/system/test_audit_integrity.py b/tests/system/test_audit_integrity.py
index b5b418b5..7de012a3 100644
--- a/tests/system/test_audit_integrity.py
+++ b/tests/system/test_audit_integrity.py
@@ -90,15 +90,18 @@ class TestEconomicIntegrityAudit(unittest.TestCase):
         # Execute
         dm.process_births(simulation, birth_requests)
 
-        # Expected Gift: 10% of 10000 = 1000 pennies
-        args = self.settlement_system.transfer.call_args
+        # Verify that create_newborn was called with correct initial_assets (integer)
+        # We don't check settlement_system.transfer because the factory is mocked, so it won't execute the transfer.
+        # The logic for rounding happens in DemographicManager before calling create_newborn.
+
+        args = mock_factory_instance.create_newborn.call_args
         if args:
-            # args[0] are positional args: (debit, credit, amount, memo)
-            amount = args[0][2]
-            self.assertEqual(amount, 1000)
-            self.assertIsInstance(amount, int)
+            kwargs = args.kwargs
+            initial_assets = kwargs.get('initial_assets')
+            self.assertEqual(initial_assets, 1000)
+            self.assertIsInstance(initial_assets, int)
         else:
-            self.fail("No transfer call detected")
+            self.fail("create_newborn not called")
 
     def test_inheritance_distribution(self):
         """
diff --git a/tests/unit/test_tax_collection.py b/tests/unit/test_tax_collection.py
index 2398e076..2e0b4681 100644
--- a/tests/unit/test_tax_collection.py
+++ b/tests/unit/test_tax_collection.py
@@ -112,39 +112,3 @@ def test_atomic_wealth_tax_collection_insufficient_funds():
     # Stats unchanged
     assert gov.total_collected_tax[DEFAULT_CURRENCY] == 0
     assert gov.tax_revenue.get("wealth_tax", 0) == 0
-
-def test_government_collect_tax_adapter_success():
-    config = MockConfig()
-    gov = Government(id="GOV", initial_assets=0, config_module=config)
-    settlement = MockSettlementSystem()
-    gov.settlement_system = settlement
-
-    payer = MockAgent(id="PAYER", assets=10000)
-    amount = 1000
-
-    collected = gov.collect_tax(amount, "test_tax", payer, current_tick=1)
-
-    assert collected['amount_collected'] == 1000
-    assert collected['success'] is True
-    assert payer.get_balance() == 9000
-    assert gov.get_balance() == 1000
-    assert gov.total_collected_tax[DEFAULT_CURRENCY] == 1000
-    assert gov.tax_revenue["test_tax"] == 1000
-
-def test_government_collect_tax_adapter_failure():
-    config = MockConfig()
-    gov = Government(id="GOV", initial_assets=0, config_module=config)
-    settlement = MockSettlementSystem()
-    gov.settlement_system = settlement
-
-    payer = MockAgent(id="PAYER", assets=500) # Less than 1000
-    amount = 1000
-
-    collected = gov.collect_tax(amount, "test_tax", payer, current_tick=1)
-
-    assert collected['amount_collected'] == 0
-    assert collected['success'] is False
-    assert payer.get_balance() == 500
-    assert gov.get_balance() == 0
-    assert gov.total_collected_tax[DEFAULT_CURRENCY] == 0
-    assert "test_tax" not in gov.tax_revenue
diff --git a/tests/unit/test_transaction_handlers.py b/tests/unit/test_transaction_handlers.py
index 17405f00..38a7dd7c 100644
--- a/tests/unit/test_transaction_handlers.py
+++ b/tests/unit/test_transaction_handlers.py
@@ -4,14 +4,15 @@ from modules.finance.transaction.handlers import GoodsTransactionHandler, LaborT
 from modules.finance.transaction.handlers.protocols import ISolvent, ITaxCollector
 from simulation.models import Transaction
 from simulation.dtos.api import SimulationState
+from simulation.agents.government import Government
 
 class TestGoodsTransactionHandler(unittest.TestCase):
     def setUp(self):
         self.handler = GoodsTransactionHandler()
         self.settlement = MagicMock()
 
-        # Mock Government with ITaxCollector protocol
-        self.government = MagicMock(spec=ITaxCollector)
+        # Mock Government with Government class spec
+        self.government = MagicMock(spec=Government)
         self.government.id = 99
 
         self.escrow_agent = MagicMock()
@@ -110,8 +111,11 @@ class TestLaborTransactionHandler(unittest.TestCase):
         self.handler = LaborTransactionHandler()
         self.settlement = MagicMock()
 
-        # Mock Government with ITaxCollector protocol
-        self.government = MagicMock(spec=ITaxCollector)
+        # Mock Government with Government spec to allow 'id' attribute access and ITaxCollector compliance
+        self.government = MagicMock(spec=Government)
+        # MagicMock with spec doesn't automatically set attributes unless defined in class or created on mock.
+        # But access checks are strict. Government has id.
+        self.government.id = 99
 
         self.config = MagicMock()
         self.logger = MagicMock()
@@ -144,6 +148,7 @@ class TestLaborTransactionHandler(unittest.TestCase):
         # Mock Gov tax calc
         self.government.calculate_income_tax.return_value = 200 # 10%
         self.settlement.transfer.return_value = True
+        self.settlement.settle_atomic.return_value = True # For tax settlement
 
         success = self.handler.handle(tx, self.buyer, self.seller, self.state)
 
@@ -152,8 +157,15 @@ class TestLaborTransactionHandler(unittest.TestCase):
         # Verify Wage Transfer (Buyer -> Seller) Gross
         self.settlement.transfer.assert_called_with(self.buyer, self.seller, 2000, "labor_wage_gross:labor")
 
-        # Verify Tax Collection (Gov collects from Seller/Household)
-        self.government.collect_tax.assert_called_with(200, "income_tax_household", self.seller, 100)
+        # Verify Tax Collection (Gov collects from Seller/Household via settle_atomic)
+        self.settlement.settle_atomic.assert_called_with(
+            debit_agent=self.seller,
+            credits_list=[(self.government, 200, "income_tax_household")],
+            tick=100
+        )
+
+        # Verify Record Revenue called
+        self.government.record_revenue.assert_called()
 
     def test_labor_firm_tax_payer(self):
         self.config.INCOME_TAX_PAYER = "FIRM"
@@ -165,15 +177,26 @@ class TestLaborTransactionHandler(unittest.TestCase):
         )
 
         self.government.calculate_income_tax.return_value = 200
-        self.settlement.transfer.return_value = True
+        self.settlement.settle_atomic.return_value = True
 
         success = self.handler.handle(tx, self.buyer, self.seller, self.state)
 
         self.assertTrue(success)
 
-        # Verify Wage Transfer (Buyer -> Seller) Net? No, code says "trade_value" (Gross)
-        # "Firm pays Wage to Household"
-        self.settlement.transfer.assert_called_with(self.buyer, self.seller, 2000, "labor_wage:labor")
+        # Verify Wage Transfer (Firm pays Wage to Household AND Tax to Gov Atomically)
+        # Expected credits_list: [(seller, 2000, "labor_wage:labor"), (government, 200, "income_tax_firm")]
+
+        call_args = self.settlement.settle_atomic.call_args
+        self.assertIsNotNone(call_args)
+        kwargs = call_args.kwargs
+
+        self.assertEqual(kwargs['debit_agent'], self.buyer)
+        credits = kwargs['credits_list']
+        self.assertEqual(len(credits), 2)
+
+        # Check credits content roughly
+        self.assertIn((self.seller, 2000, "labor_wage:labor"), credits)
+        self.assertIn((self.government, 200, "income_tax_firm"), credits)
 
-        # Verify Tax Collection (Gov collects from Buyer/Firm)
-        self.government.collect_tax.assert_called_with(200, "income_tax_firm", self.buyer, 100)
+        # Verify Record Revenue called
+        self.government.record_revenue.assert_called()
