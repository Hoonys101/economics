diff --git a/communications/insights/mission-ui-02.md b/communications/insights/mission-ui-02.md
new file mode 100644
index 00000000..6a12a126
--- /dev/null
+++ b/communications/insights/mission-ui-02.md
@@ -0,0 +1,56 @@
+# Technical Insight Report: Mission UI-02 (Dynamic Registry Controls)
+
+## 1. Executive Summary
+This mission implemented dynamic UI controls for the Simulation Cockpit, enabling real-time manipulation of `GlobalRegistry` parameters. Key deliverables include a schema-driven rendering engine (`dashboard/components/controls.py`), a YAML-based schema definition (`config/domains/registry_schema.yaml`), and robustness enhancements to `TelemetryCollector`.
+
+## 2. Key Architectural Decisions
+
+### 2.1 Schema-Driven UI with Units
+Instead of hardcoding widgets, we adopted a schema-driven approach. `config/domains/registry_schema.yaml` serves as the single source of truth for parameter metadata (min/max, description, category, unit). This allows domain experts to expose new parameters without touching frontend code. We added a `unit` field (e.g., "%", "x") to improve clarity.
+
+### 2.2 Telemetry Robustness (Flat Key Support)
+A significant impedance mismatch was identified between `GlobalRegistry` (which supports flat KV pairs like `government.tax_rate`) and `TelemetryCollector` (which assumed object traversal via dot notation).
+- **Decision**: Enhanced `TelemetryCollector._resolve_path` to attempt a full-key lookup before falling back to object traversal. This ensures compatibility with both storage patterns.
+
+### 2.3 Command Synchronization & Jitter Prevention
+Streamlit's execution model introduces potential "jitter" when backend state updates concurrently with user interaction.
+- **Solution**: Implemented a "Sync Logic" in `controls.py`. Local session state is updated from telemetry *only if* the user is not actively modifying that specific parameter (determined by `pending_commands` queue). This ensures backend updates (e.g., adaptive policy changes) are reflected in the UI without overwriting user input during adjustment.
+- **Debouncing**: Leveraged Streamlit's native `st.slider(on_change=...)` behavior, which triggers only on handle release, preventing command floods.
+
+### 2.4 Mismatch Handling & God-Mode Lock
+- **God-Mode**: The sidebar toggle acts as a master switch. When disabled, all dynamic controls are rendered in a read-only state.
+- **Registry Mismatch**: If a parameter defined in the schema is missing from the live registry (telemetry), the widget is automatically disabled and labeled with "‚ö†Ô∏è N/A" to prevent invalid commands.
+
+### 2.5 Hot-Reloading
+`RegistryService` re-instantiates and reloads the YAML schema on every Streamlit script execution. This supports hot-reloading: developers can edit `registry_schema.yaml` while the dashboard is running, and changes appear immediately upon the next refresh.
+
+## 3. Technical Debt & Future Work
+
+### 3.1 Shadow Value Issue
+Currently, `CommandService` updates `GlobalRegistry` using `set(key, value)`. If the simulation engine uses object attributes (e.g., `government.tax_rate`) instead of querying the registry, a "shadow value" is created where the Registry holds the desired state, but the Agent holds the actual state.
+- **Mitigation**: Future refactoring should ensure Agents bind their parameters to `GlobalRegistry` or `CommandService` should propagate changes to Agents explicitly.
+
+### 3.2 Telemetry Latency
+The UI relies on `telemetry_buffer` which is updated via WebSocket. There is a slight latency between command commit and visual feedback. The "Pending" state in the UI helps mitigate this perception.
+
+## 4. Test Evidence
+
+### Unit Tests
+Executed `pytest` on relevant modules. All tests passed, covering schema loading, telemetry robustness, and UI control logic (including mismatch handling).
+
+```text
+tests/unit/dashboard/services/test_schema_loader.py::TestSchemaLoader::test_load_schema_file_not_found PASSED
+tests/unit/dashboard/services/test_schema_loader.py::TestSchemaLoader::test_load_schema_invalid_structure PASSED
+tests/unit/dashboard/services/test_schema_loader.py::TestSchemaLoader::test_load_schema_success PASSED
+tests/unit/dashboard/services/test_schema_loader.py::TestSchemaLoader::test_load_schema_yaml_error PASSED
+tests/unit/modules/system/test_telemetry_robustness.py::TestTelemetryRobustness::test_flat_key_resolution PASSED
+tests/unit/modules/system/test_telemetry_robustness.py::TestTelemetryRobustness::test_mixed_resolution PASSED
+tests/unit/dashboard/components/test_controls.py::TestControls::test_missing_registry_value_disables_widget PASSED
+tests/unit/dashboard/components/test_controls.py::TestControls::test_on_change_generates_command PASSED
+tests/unit/dashboard/components/test_controls.py::TestControls::test_render_dynamic_controls_tabs PASSED
+```
+
+### Frontend Verification
+Verified using Playwright script `verification/verify_controls.py`.
+- **Scenario**: Start app, verify initial state, enable God Mode, verify controls appear.
+- **Screenshot**: `verification/step2_god_mode.png` confirms controls are visible and unlocked when God Mode is enabled.
diff --git a/config/domains/registry_schema.yaml b/config/domains/registry_schema.yaml
new file mode 100644
index 00000000..3e737567
--- /dev/null
+++ b/config/domains/registry_schema.yaml
@@ -0,0 +1,54 @@
+- key: government.corporate_tax_rate
+  label: Corporate Tax Rate
+  description: The tax rate applied to corporate profits.
+  widget_type: slider
+  data_type: float
+  min_value: 0.0
+  max_value: 0.5
+  step: 0.01
+  category: Fiscal
+  unit: "%"
+
+- key: government.income_tax_rate
+  label: Income Tax Rate
+  description: The base tax rate applied to household income.
+  widget_type: slider
+  data_type: float
+  min_value: 0.0
+  max_value: 0.5
+  step: 0.01
+  category: Fiscal
+  unit: "%"
+
+- key: central_bank.base_rate
+  label: Base Interest Rate
+  description: The central bank's base lending rate.
+  widget_type: slider
+  data_type: float
+  min_value: 0.0
+  max_value: 0.20
+  step: 0.0025
+  category: Monetary
+  unit: "%"
+
+- key: government.welfare_budget_multiplier
+  label: Welfare Budget Multiplier
+  description: Multiplier for welfare spending.
+  widget_type: number_input
+  data_type: float
+  min_value: 0.0
+  max_value: 5.0
+  step: 0.1
+  category: Social
+  unit: "x"
+
+- key: simulation.execution_speed
+  label: Execution Speed
+  description: Simulation execution speed multiplier (0.1x to 10x).
+  widget_type: slider
+  data_type: float
+  min_value: 0.1
+  max_value: 10.0
+  step: 0.1
+  category: System
+  unit: "x"
diff --git a/dashboard/components/controls.py b/dashboard/components/controls.py
new file mode 100644
index 00000000..0f61b416
--- /dev/null
+++ b/dashboard/components/controls.py
@@ -0,0 +1,155 @@
+import streamlit as st
+import logging
+from typing import Dict, Any, List, Optional
+from dashboard.services.registry_service import RegistryService
+from dashboard.dtos import ParameterSchemaDTO
+from simulation.dtos.commands import GodCommandDTO
+
+logger = logging.getLogger(__name__)
+
+def render_dynamic_controls(container=None, use_tabs=True):
+    """
+    Renders dynamic UI controls based on registry schema.
+    Handles user interaction and queues GodCommandDTOs.
+    """
+    parent = container if container else st
+
+    # 1. Load Schema
+    registry_service = RegistryService()
+    schemas: List[ParameterSchemaDTO] = registry_service.get_all_metadata()
+
+    if not schemas:
+        parent.info("No registry schema loaded.")
+        return
+
+    # 2. Get Telemetry (Current State)
+    telemetry = st.session_state.get("telemetry_buffer", {})
+    registry_data = telemetry.get("registry", {})
+
+    # 3. Group by Category
+    categories = sorted(list(set(s['category'] for s in schemas)))
+
+    if use_tabs:
+        tabs = parent.tabs([f"üèõÔ∏è {c}" for c in categories])
+        for i, category in enumerate(categories):
+            with tabs[i]:
+                _render_category_content(category, schemas, registry_data)
+    else:
+        for category in categories:
+            with parent.expander(f"üèõÔ∏è {category}", expanded=True):
+                _render_category_content(category, schemas, registry_data)
+
+def _render_category_content(category: str, schemas: List[ParameterSchemaDTO], registry_data: Dict[str, Any]):
+    cat_schemas = [s for s in schemas if s['category'] == category]
+    for schema in cat_schemas:
+        _render_widget(schema, registry_data)
+
+def _render_widget(schema: ParameterSchemaDTO, registry_data: Dict[str, Any]):
+    """
+    Renders a single widget for a parameter.
+    """
+    key = schema['key']
+    label = schema['label']
+    desc = schema['description']
+    unit = schema.get('unit', '')
+
+    ui_key = f"ui_{key}"
+
+    # Resolve current value from registry (Telemetry)
+    current_val = registry_data.get(key)
+
+    # Fallback logic for flat keys not in registry data (simulated)
+    if current_val is None:
+         parts = key.split('.')
+         if len(parts) > 1 and parts[0] in registry_data:
+             root = registry_data[parts[0]]
+             if isinstance(root, dict) and parts[1] in root:
+                 current_val = root[parts[1]]
+
+    # Mismatch Handling: If value not found, mark as missing
+    is_missing = (current_val is None)
+    if is_missing:
+         current_val = schema['min_value'] # Fallback default
+         label = f"{label} (‚ö†Ô∏è N/A)"
+
+    # Append unit to label
+    if unit:
+        label = f"{label} [{unit}]"
+
+    # Initial value logic (Sync with session state)
+    if ui_key not in st.session_state:
+        st.session_state[ui_key] = current_val
+    else:
+        # Sync logic: If not pending (user interaction), update from telemetry
+        pending_keys = {cmd.parameter_key for cmd in st.session_state.get("pending_commands", [])}
+        if key not in pending_keys and not is_missing:
+             if current_val != st.session_state[ui_key]:
+                 st.session_state[ui_key] = current_val
+
+    # Lock logic
+    is_god_mode = st.session_state.get("god_mode_active", False)
+    # If missing, force disable
+    is_locked = (not is_god_mode) or is_missing
+
+    # Widget Generation
+    widget_type = schema['widget_type']
+
+    def on_change():
+        new_val = st.session_state[ui_key]
+
+        cmd = GodCommandDTO(
+            target_domain=schema['category'],
+            parameter_key=key,
+            new_value=new_val,
+            command_type="SET_PARAM"
+        )
+
+        if "pending_commands" not in st.session_state:
+            st.session_state["pending_commands"] = []
+
+        # Deduplicate
+        st.session_state["pending_commands"] = [
+            c for c in st.session_state["pending_commands"]
+            if c.parameter_key != key
+        ]
+        st.session_state["pending_commands"].append(cmd)
+
+        st.toast(f"Queued: {label} -> {new_val}")
+
+    col1, col2 = st.columns([0.9, 0.1])
+
+    with col1:
+        if widget_type == "slider":
+            st.slider(
+                label=label,
+                min_value=float(schema['min_value']),
+                max_value=float(schema['max_value']),
+                step=float(schema['step']) if schema['step'] else 0.1,
+                key=ui_key,
+                on_change=on_change,
+                help=desc,
+                disabled=is_locked
+            )
+        elif widget_type == "number_input":
+            st.number_input(
+                label=label,
+                min_value=float(schema['min_value']),
+                max_value=float(schema['max_value']),
+                step=float(schema['step']) if schema['step'] else 1.0,
+                key=ui_key,
+                on_change=on_change,
+                help=desc,
+                disabled=is_locked
+            )
+        elif widget_type == "toggle":
+            st.toggle(
+                label=label,
+                key=ui_key,
+                on_change=on_change,
+                help=desc,
+                disabled=is_locked
+            )
+
+    with col2:
+        if is_locked:
+            st.markdown("üîí")
diff --git a/dashboard/components/main_cockpit.py b/dashboard/components/main_cockpit.py
index 143005cf..be4b96d0 100644
--- a/dashboard/components/main_cockpit.py
+++ b/dashboard/components/main_cockpit.py
@@ -1,6 +1,7 @@
 import streamlit as st
 import pandas as pd
 from typing import Dict, Any
+from dashboard.components.controls import render_dynamic_controls
 
 def render_main_cockpit():
     st.title("üëÅÔ∏è Watchtower Cockpit")
@@ -42,6 +43,10 @@ def render_main_cockpit():
     else:
         st.success(f"‚úÖ System Integrity Normal (Leak: {leak:.4f}) - FPS: {fps:.1f}")
 
+    # Controls Section
+    st.divider()
+    render_dynamic_controls(use_tabs=True)
+
     # Wealth Distribution Heatmap (Placeholder)
     st.subheader("Wealth Distribution")
     pop_dist = data.get("population", {}).get("distribution", {})
diff --git a/dashboard/components/sidebar.py b/dashboard/components/sidebar.py
index c7e77751..5705aaa3 100644
--- a/dashboard/components/sidebar.py
+++ b/dashboard/components/sidebar.py
@@ -1,7 +1,6 @@
 import streamlit as st
-from dashboard.services.registry_service import RegistryService
 from dashboard.services.socket_manager import SocketManager
-from simulation.dtos.commands import GodCommandDTO
+from dashboard.components.controls import render_dynamic_controls
 
 def render_sidebar():
     st.sidebar.title("üéÆ Global Controls")
@@ -14,62 +13,16 @@ def render_sidebar():
     st.sidebar.markdown(f"**Engine Status:** :{color}[{status}]")
 
     # Intervention Toggle
-    god_mode = st.sidebar.toggle("God Mode (Intervention)", value=False)
+    # Use key to persist state and share with other components
+    god_mode = st.sidebar.toggle("God Mode (Intervention)", value=False, key="god_mode_active")
 
     st.sidebar.divider()
 
     if not god_mode:
         st.sidebar.info("Enable God Mode to adjust parameters.")
+        # We return here, so sidebar doesn't show controls.
+        # But main_cockpit will still render them.
         return
 
-    # Registry Service
-    registry_service = RegistryService()
-    metadata_list = registry_service.get_all_metadata()
-
-    # Group by domain
-    domains = sorted(list(set(m.domain for m in metadata_list)))
-
-    if "pending_commands" not in st.session_state:
-        st.session_state.pending_commands = []
-
-    for domain in domains:
-        st.sidebar.subheader(f"üèõÔ∏è {domain}")
-        domain_meta = [m for m in metadata_list if m.domain == domain]
-
-        for meta in domain_meta:
-            key = f"param_{meta.key}"
-
-            # Helper to create DTO on change
-            def on_change(m=meta, k=key):
-                new_val = st.session_state[k]
-                cmd = GodCommandDTO(
-                    target_domain=m.domain,
-                    parameter_key=m.key,
-                    new_value=new_val,
-                    command_type="SET_PARAM"
-                )
-                st.session_state.pending_commands.append(cmd)
-                st.toast(f"Queued: {m.key} -> {new_val}")
-
-            # Determine initial value
-            if key not in st.session_state:
-                st.session_state[key] = meta.min_value
-
-            if meta.data_type == "int":
-                st.sidebar.number_input(
-                    label=meta.description,
-                    min_value=int(meta.min_value),
-                    max_value=int(meta.max_value),
-                    step=int(meta.step),
-                    key=key,
-                    on_change=on_change
-                )
-            else:
-                st.sidebar.slider(
-                    label=meta.description,
-                    min_value=float(meta.min_value),
-                    max_value=float(meta.max_value),
-                    step=float(meta.step),
-                    key=key,
-                    on_change=on_change
-                )
+    # Use shared dynamic controls component
+    render_dynamic_controls(container=st.sidebar, use_tabs=False)
diff --git a/dashboard/dtos.py b/dashboard/dtos.py
new file mode 100644
index 00000000..b0e387ec
--- /dev/null
+++ b/dashboard/dtos.py
@@ -0,0 +1,18 @@
+from typing import TypedDict, Any, List, Optional, Union, Literal
+
+class ParameterSchemaDTO(TypedDict):
+    """
+    UI ÏúÑÏ†Ø ÏÉùÏÑ±ÏùÑ ÏúÑÌïú Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï†ïÏùò.
+    Matches the schema in config/domains/registry_schema.yaml.
+    """
+    key: str
+    label: str
+    description: str
+    widget_type: Literal["slider", "toggle", "number_input", "select"]
+    data_type: Literal["int", "float", "bool", "str"]
+    min_value: Optional[Union[float, int]]
+    max_value: Optional[Union[float, int]]
+    step: Optional[Union[float, int]]
+    options: Optional[List[Any]]
+    category: str
+    unit: Optional[str]
diff --git a/dashboard/services/registry_service.py b/dashboard/services/registry_service.py
index a6efeae8..99e975c8 100644
--- a/dashboard/services/registry_service.py
+++ b/dashboard/services/registry_service.py
@@ -1,57 +1,24 @@
 from typing import List, Optional
-from dataclasses import dataclass
-
-@dataclass
-class RegistryMetadata:
-    key: str
-    domain: str
-    min_value: float
-    max_value: float
-    step: float
-    description: str
-    data_type: str = "float" # float, int, bool
+from dashboard.dtos import ParameterSchemaDTO
+from dashboard.services.schema_loader import SchemaLoader
 
 class RegistryService:
     """
     Service to provide metadata for simulation parameters.
-    Currently uses a hardcoded shim until GlobalRegistry is fully integrated.
+    Loads from schema configuration via SchemaLoader.
     """
 
-    _SHIM_METADATA = [
-        RegistryMetadata(
-            key="corporate_tax_rate",
-            domain="Government",
-            min_value=0.0,
-            max_value=1.0,
-            step=0.01,
-            description="Corporate Tax Rate",
-            data_type="float"
-        ),
-         RegistryMetadata(
-            key="base_rate",
-            domain="Finance",
-            min_value=0.0,
-            max_value=0.20,
-            step=0.0025,
-            description="Central Bank Base Interest Rate",
-            data_type="float"
-        ),
-        RegistryMetadata(
-            key="welfare_budget",
-            domain="Government",
-            min_value=0,
-            max_value=10000000,
-            step=10000,
-            description="Total Welfare Budget (Pennies)",
-            data_type="int"
-        )
-    ]
+    def __init__(self):
+        self._schema_cache: Optional[List[ParameterSchemaDTO]] = None
 
-    def get_all_metadata(self) -> List[RegistryMetadata]:
-        return self._SHIM_METADATA
+    def get_all_metadata(self) -> List[ParameterSchemaDTO]:
+        if self._schema_cache is None:
+            self._schema_cache = SchemaLoader.load_schema()
+        return self._schema_cache
 
-    def get_metadata(self, key: str) -> Optional[RegistryMetadata]:
-        for meta in self._SHIM_METADATA:
-            if meta.key == key:
+    def get_metadata(self, key: str) -> Optional[ParameterSchemaDTO]:
+        metadata_list = self.get_all_metadata()
+        for meta in metadata_list:
+            if meta['key'] == key:
                 return meta
         return None
diff --git a/dashboard/services/schema_loader.py b/dashboard/services/schema_loader.py
new file mode 100644
index 00000000..146de0be
--- /dev/null
+++ b/dashboard/services/schema_loader.py
@@ -0,0 +1,33 @@
+import yaml
+import logging
+from typing import List
+from dashboard.dtos import ParameterSchemaDTO
+
+logger = logging.getLogger(__name__)
+
+class SchemaLoader:
+    """
+    Loads registry schema from YAML configuration.
+    """
+
+    DEFAULT_SCHEMA_PATH = "config/domains/registry_schema.yaml"
+
+    @staticmethod
+    def load_schema(filepath: str = DEFAULT_SCHEMA_PATH) -> List[ParameterSchemaDTO]:
+        try:
+            with open(filepath, 'r') as f:
+                data = yaml.safe_load(f)
+                if not isinstance(data, list):
+                    logger.error(f"Schema file {filepath} must contain a list of objects.")
+                    return []
+                # Validate minimal structure if needed, or rely on TypedDict typing (runtime doesn't enforce TypedDict)
+                return data
+        except FileNotFoundError:
+            logger.error(f"Schema file not found at {filepath}")
+            return []
+        except yaml.YAMLError as e:
+            logger.error(f"Error parsing YAML schema: {e}")
+            return []
+        except Exception as e:
+            logger.error(f"Unexpected error loading schema: {e}")
+            return []
diff --git a/modules/system/telemetry.py b/modules/system/telemetry.py
index 13f0bd05..94e913fe 100644
--- a/modules/system/telemetry.py
+++ b/modules/system/telemetry.py
@@ -123,6 +123,18 @@ class TelemetryCollector:
         if not path:
             return None
 
+        # Strategy 1: Try full path as a Key-Value pair (FOUND-01 Support)
+        # This handles cases where keys are stored flat (e.g. "government.tax_rate")
+        try:
+            # We use a distinct default to check existence, assuming registry doesn't store this sentinel
+            sentinel = object()
+            val = self._registry.get(path, default=sentinel)
+            if val is not sentinel:
+                return lambda: self._registry.get(path)
+        except Exception:
+            pass
+
+        # Strategy 2: Try object traversal (Deep Access)
         try:
             accessor = self._create_accessor(path)
             # Validation: try to access once
diff --git a/tests/unit/dashboard/components/test_controls.py b/tests/unit/dashboard/components/test_controls.py
new file mode 100644
index 00000000..06a6550f
--- /dev/null
+++ b/tests/unit/dashboard/components/test_controls.py
@@ -0,0 +1,121 @@
+import unittest
+from unittest.mock import MagicMock, patch
+from dashboard.components.controls import render_dynamic_controls
+from dashboard.dtos import ParameterSchemaDTO
+from simulation.dtos.commands import GodCommandDTO
+
+class TestControls(unittest.TestCase):
+    def setUp(self):
+        self.mock_st = MagicMock()
+        self.mock_registry_service = MagicMock()
+
+        # Patch modules
+        self.st_patcher = patch("dashboard.components.controls.st", self.mock_st)
+        self.registry_patcher = patch("dashboard.components.controls.RegistryService", return_value=self.mock_registry_service)
+
+        self.mock_st_module = self.st_patcher.start()
+        self.mock_registry_service_cls = self.registry_patcher.start()
+
+        # Setup session state
+        self.mock_st.session_state = {}
+
+        # Configure st.columns to return a list of mocks
+        self.mock_st.columns.return_value = [MagicMock(), MagicMock()]
+
+    def tearDown(self):
+        self.st_patcher.stop()
+        self.registry_patcher.stop()
+
+    def test_render_dynamic_controls_tabs(self):
+        # Mock Schema with unit
+        schema = [
+            ParameterSchemaDTO(
+                key="gov.tax", label="Tax", description="Tax Rate",
+                widget_type="slider", data_type="float",
+                min_value=0.0, max_value=1.0, step=0.1, category="Fiscal", options=None, unit="%"
+            )
+        ]
+        self.mock_registry_service.get_all_metadata.return_value = schema
+
+        # Mock Telemetry
+        self.mock_st.session_state = {
+            "telemetry_buffer": {"registry": {"gov.tax": 0.5}}
+        }
+
+        # Call function
+        render_dynamic_controls(use_tabs=True)
+
+        # Verify tabs created
+        self.mock_st.tabs.assert_called()
+        args, _ = self.mock_st.tabs.call_args
+        self.assertIn("üèõÔ∏è Fiscal", args[0])
+
+        # Verify slider created with unit in label
+        self.mock_st.slider.assert_called()
+        _, kwargs = self.mock_st.slider.call_args
+        self.assertIn("Tax [%]", kwargs['label']) # Adjusted for implementation
+        self.assertEqual(kwargs['min_value'], 0.0)
+        self.assertEqual(kwargs['key'], "ui_gov.tax")
+
+    def test_on_change_generates_command(self):
+        # ... setup schema ...
+        schema = [
+            ParameterSchemaDTO(
+                key="gov.tax", label="Tax", description="Desc",
+                widget_type="slider", data_type="float",
+                min_value=0.0, max_value=1.0, step=0.1, category="Fiscal", options=None, unit="%"
+            )
+        ]
+        self.mock_registry_service.get_all_metadata.return_value = schema
+
+        self.mock_st.session_state = {
+            "telemetry_buffer": {"registry": {"gov.tax": 0.8}},
+            "ui_gov.tax": 0.8,
+            "pending_commands": []
+        }
+
+        # Render to register callback
+        render_dynamic_controls()
+
+        # Extract callback
+        _, kwargs = self.mock_st.slider.call_args
+        on_change = kwargs['on_change']
+
+        # Simulate interaction
+        on_change()
+
+        # Verify command
+        pending = self.mock_st.session_state["pending_commands"]
+        self.assertEqual(len(pending), 1)
+        cmd = pending[0]
+        self.assertIsInstance(cmd, GodCommandDTO)
+        self.assertEqual(cmd.parameter_key, "gov.tax")
+        self.assertEqual(cmd.new_value, 0.8)
+
+    def test_missing_registry_value_disables_widget(self):
+        # Schema for key that is missing in telemetry
+        schema = [
+            ParameterSchemaDTO(
+                key="missing.key", label="Ghost Param", description="Desc",
+                widget_type="slider", data_type="float",
+                min_value=0.0, max_value=1.0, step=0.1, category="Fiscal", options=None, unit=""
+            )
+        ]
+        self.mock_registry_service.get_all_metadata.return_value = schema
+
+        # Empty telemetry
+        self.mock_st.session_state = {
+            "telemetry_buffer": {"registry": {}},
+            "god_mode_active": True # Enable god mode, but widget should still be disabled/warned
+        }
+
+        render_dynamic_controls()
+
+        self.mock_st.slider.assert_called()
+        _, kwargs = self.mock_st.slider.call_args
+
+        # Check label warning
+        self.assertIn("Ghost Param (‚ö†Ô∏è N/A)", kwargs['label'])
+
+        # Check disabled state (True because it is missing)
+        self.assertTrue(kwargs['disabled'])
diff --git a/tests/unit/dashboard/services/test_schema_loader.py b/tests/unit/dashboard/services/test_schema_loader.py
new file mode 100644
index 00000000..74bc358e
--- /dev/null
+++ b/tests/unit/dashboard/services/test_schema_loader.py
@@ -0,0 +1,51 @@
+import unittest
+from unittest.mock import patch, mock_open
+from dashboard.services.schema_loader import SchemaLoader
+import logging
+import yaml
+
+# Disable logging during tests
+logging.disable(logging.CRITICAL)
+
+class TestSchemaLoader(unittest.TestCase):
+    @patch('dashboard.services.schema_loader.yaml.safe_load')
+    def test_load_schema_success(self, mock_yaml_load):
+        mock_data = [{
+            'key': 'test.param',
+            'label': 'Test Param',
+            'description': 'A test parameter',
+            'widget_type': 'slider',
+            'data_type': 'float',
+            'min_value': 0.0,
+            'max_value': 1.0,
+            'step': 0.1,
+            'category': 'Test'
+        }]
+        mock_yaml_load.return_value = mock_data
+
+        with patch("builtins.open", mock_open(read_data="content")):
+            schema = SchemaLoader.load_schema("dummy.yaml")
+            self.assertEqual(len(schema), 1)
+            self.assertEqual(schema[0]['key'], "test.param")
+
+    def test_load_schema_file_not_found(self):
+        with patch("builtins.open", side_effect=FileNotFoundError):
+            schema = SchemaLoader.load_schema("nonexistent.yaml")
+            self.assertEqual(schema, [])
+
+    @patch('dashboard.services.schema_loader.yaml.safe_load')
+    def test_load_schema_invalid_structure(self, mock_yaml_load):
+        # Returns dict instead of list
+        mock_yaml_load.return_value = {"key": "val"}
+
+        with patch("builtins.open", mock_open(read_data="content")):
+            schema = SchemaLoader.load_schema("invalid.yaml")
+            self.assertEqual(schema, [])
+
+    @patch('dashboard.services.schema_loader.yaml.safe_load')
+    def test_load_schema_yaml_error(self, mock_yaml_load):
+        mock_yaml_load.side_effect = yaml.YAMLError("parse error")
+
+        with patch("builtins.open", mock_open(read_data="invalid")):
+            schema = SchemaLoader.load_schema("invalid.yaml")
+            self.assertEqual(schema, [])
diff --git a/tests/unit/modules/system/test_telemetry_robustness.py b/tests/unit/modules/system/test_telemetry_robustness.py
new file mode 100644
index 00000000..1e0f28ca
--- /dev/null
+++ b/tests/unit/modules/system/test_telemetry_robustness.py
@@ -0,0 +1,60 @@
+import unittest
+from unittest.mock import Mock
+from modules.system.telemetry import TelemetryCollector
+
+class MockRegistry:
+    def __init__(self, data):
+        self._data = data
+
+    def get(self, key, default=None):
+        return self._data.get(key, default)
+
+class TestTelemetryRobustness(unittest.TestCase):
+    def test_flat_key_resolution(self):
+        """
+        Verify that TelemetryCollector can resolve flat keys like 'government.tax_rate'
+        even if 'government' object doesn't exist.
+        """
+        # Registry has flat keys
+        data = {
+            "government.tax_rate": 0.25,
+            "finance.base_rate": 0.05
+        }
+        registry = MockRegistry(data)
+        collector = TelemetryCollector(registry)
+
+        # Subscribe using full key
+        collector.subscribe(["government.tax_rate"], frequency_interval=1)
+
+        # Harvest
+        snapshot = collector.harvest(1)
+
+        self.assertIn("government.tax_rate", snapshot["data"])
+        self.assertEqual(snapshot["data"]["government.tax_rate"], 0.25)
+        self.assertEqual(len(snapshot["errors"]), 0)
+
+    def test_mixed_resolution(self):
+        """
+        Verify mixed usage: Flat keys and Object traversal.
+        """
+        class Gov:
+            def __init__(self):
+                self.policy = "growth"
+
+        data = {
+            "government.tax_rate": 0.25, # Flat key
+            "government": Gov()          # Object key
+        }
+        registry = MockRegistry(data)
+        collector = TelemetryCollector(registry)
+
+        # Subscribe
+        collector.subscribe(["government.tax_rate"]) # Should prefer flat key if exists?
+        # Strategy 1 checks full key first. So it gets 0.25.
+
+        collector.subscribe(["government.policy"])   # Should fallback to object traversal
+
+        snapshot = collector.harvest(1)
+
+        self.assertEqual(snapshot["data"]["government.tax_rate"], 0.25)
+        self.assertEqual(snapshot["data"]["government.policy"], "growth")
