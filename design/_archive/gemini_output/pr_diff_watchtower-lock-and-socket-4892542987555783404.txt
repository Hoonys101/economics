diff --git a/communications/insights/watchtower_fix.md b/communications/insights/watchtower_fix.md
new file mode 100644
index 00000000..2a697839
--- /dev/null
+++ b/communications/insights/watchtower_fix.md
@@ -0,0 +1,31 @@
+# Technical Insight Report: Watchtower Observability Recovery (TD-263)
+
+## 1. Problem Phenomenon
+- **Symptoms**:
+    - `server.py` failed to restart with `sqlite3.OperationalError: database is locked`.
+    - Port 8000 remained in `TIME_WAIT` or `LISTEN` state by "ghost" processes.
+    - WebSocket connections on the dashboard would repeatedly disconnect and reconnect without clear error messages.
+    - "Closed database" errors appearing in logs when the server was killed abruptly.
+
+## 2. Root Cause Analysis
+- **Zombie Processes**: Previous server instances were not shutting down cleanly, leaving Python processes active. These processes held locks on `simulation_data.db`.
+- **Race Condition in Initialization**: `utils/simulation_builder.py` indiscriminately called `repository.clear_all_data()` (which performs a heavy `VACUUM` operation) upon startup. If a zombie process was holding a read lock (via WebSocket) or write lock, the new process would crash or hang.
+- **Missing Application-Level Locking**: There was no mechanism to prevent multiple `server.py` instances from running simultaneously and competing for the same SQLite file.
+- **SQLite Concurrency Settings**: The default SQLite connection settings were strict (default timeout) and didn't explicitly enforce `WAL` (Write-Ahead Logging) mode in the connection parameters for optimal concurrency.
+
+## 3. Solution Implementation Details
+- **Process Isolation**: Implemented a file-based lock (`simulation.lock`) using `fcntl` in `utils/simulation_builder.py`. The server now refuses to start if another instance holds the lock.
+- **Database Hardening**:
+    - Updated `simulation/db/database.py` to set `PRAGMA journal_mode=WAL` explicitly on connection.
+    - Increased connection timeout to 10.0 seconds to tolerate transient locks.
+    - Added `detect_types` for better type safety.
+- **Graceful Shutdown**:
+    - Added `signal` handlers (`SIGINT`, `SIGTERM`) in `server.py` to set a global `is_running` flag, allowing the simulation loop to exit cleanly.
+    - Wrapped `lifespan` startup in a `try-except` block to prevent partial initialization from leaving zombie resources.
+    - Ensured `sim.finalize_simulation()` is called exactly once.
+- **Observability**: Updated frontend `useWatchtowerStore.ts` to log specific WebSocket close codes and reasons, aiding future debugging.
+
+## 4. Lessons Learned & Technical Debt
+- **Lesson**: SQLite `VACUUM` is a blocking operation and should be used with caution in auto-starting sequences.
+- **Lesson**: For long-running async services, relying solely on `uvicorn`'s default signal handling might not be enough if background threads/tasks are heavy. Explicit cancellation logic is required.
+- **Technical Debt**: The `Simulation` class "facade" pattern is slightly leaky; `server.py` interacts with `dashboard_service` which interacts with `sim`. A cleaner separation of concerns for lifecycle management (e.g., a `SimulationManager`) would be better.
diff --git a/reports/snapshots/snapshot_tick_00001_20260206_091503.json b/reports/snapshots/snapshot_tick_00001_20260206_091503.json
new file mode 100644
index 00000000..dd65f8c2
--- /dev/null
+++ b/reports/snapshots/snapshot_tick_00001_20260206_091503.json
@@ -0,0 +1,17 @@
+{
+  "tick": 1,
+  "status": "RUNNING",
+  "integrity": {
+    "m2_leak": 0.0,
+    "fps": 78.51758793969849
+  },
+  "macro": {
+    "gdp": 0.0,
+    "cpi": 1.0,
+    "unemploy": 5.0,
+    "gini": 0.0
+  },
+  "finance": {
+    "rates": {
+      "base": 5.0,
+      "call":
\ No newline at end of file
diff --git a/server.py b/server.py
index 815ac290..d93ee016 100644
--- a/server.py
+++ b/server.py
@@ -1,5 +1,8 @@
 import asyncio
 import logging
+import signal
+import sys
+import os
 from contextlib import asynccontextmanager
 from dataclasses import asdict
 
@@ -18,6 +21,15 @@ dashboard_service = None
 background_task = None
 is_running = False
 
+def handle_signal(sig, frame):
+    """
+    Handle termination signals to ensure the loop stops.
+    Uvicorn will handle the main shutdown, but this ensures our loop flag is cleared.
+    """
+    global is_running
+    logger.info(f"Received signal {sig}. Initiating shutdown...")
+    is_running = False
+
 async def simulation_loop():
     global sim, is_running
     logger.info("Starting simulation loop...")
@@ -41,12 +53,17 @@ async def lifespan(app: FastAPI):
 
     # Startup
     logger.info("Initializing simulation...")
-    # overrides can be passed here if needed
-    sim = create_simulation()
-    dashboard_service = DashboardService(sim)
+    try:
+        # overrides can be passed here if needed
+        sim = create_simulation()
+        dashboard_service = DashboardService(sim)
 
-    is_running = True
-    background_task = asyncio.create_task(simulation_loop())
+        is_running = True
+        background_task = asyncio.create_task(simulation_loop())
+    except Exception as e:
+        logger.critical(f"Failed to initialize simulation: {e}", exc_info=True)
+        # We should probably re-raise so the server doesn't start in a broken state
+        raise e
 
     yield
 
@@ -62,7 +79,10 @@ async def lifespan(app: FastAPI):
             pass
 
     if sim:
-        sim.finalize_simulation()
+        try:
+            sim.finalize_simulation()
+        except Exception as e:
+            logger.error(f"Error during simulation finalization: {e}", exc_info=True)
 
 app = FastAPI(lifespan=lifespan)
 
@@ -91,4 +111,9 @@ def read_root():
 
 if __name__ == "__main__":
     import uvicorn
-    uvicorn.run(app, host="0.0.0.0", port=8000)
+    # Register signal handlers to set the flag
+    signal.signal(signal.SIGINT, handle_signal)
+    signal.signal(signal.SIGTERM, handle_signal)
+
+    port = int(os.getenv("PORT", 8000))
+    uvicorn.run(app, host="0.0.0.0", port=port)
diff --git a/simulation.lock b/simulation.lock
new file mode 100644
index 00000000..e69de29b
diff --git a/simulation/db/database.py b/simulation/db/database.py
index 8a8d42db..315dc4e2 100644
--- a/simulation/db/database.py
+++ b/simulation/db/database.py
@@ -24,7 +24,15 @@ class DatabaseManager:
         데이터베이스 연결을 반환합니다. 연결이 없으면 새로 생성하고 테이블을 초기화합니다.
         """
         if self._conn is None:
-            self._conn = sqlite3.connect(DATABASE_NAME, check_same_thread=False)
+            self._conn = sqlite3.connect(
+                DATABASE_NAME,
+                check_same_thread=False,
+                timeout=10.0,
+                detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES
+            )
+            # Enable WAL mode for better concurrency
+            self._conn.execute("PRAGMA journal_mode=WAL")
+
             create_tables(self._conn)
         return self._conn
 
diff --git a/simulation_data.db-shm b/simulation_data.db-shm
deleted file mode 100644
index 345360e4..00000000
Binary files a/simulation_data.db-shm and /dev/null differ
diff --git a/simulation_data.db-wal b/simulation_data.db-wal
deleted file mode 100644
index d35b6fd4..00000000
Binary files a/simulation_data.db-wal and /dev/null differ
diff --git a/utils/simulation_builder.py b/utils/simulation_builder.py
index 92b4d38a..2a52a45b 100644
--- a/utils/simulation_builder.py
+++ b/utils/simulation_builder.py
@@ -1,8 +1,14 @@
 import random
 import logging
+import sys
 from typing import Dict, Any
 from pathlib import Path
 
+try:
+    import fcntl
+except ImportError:
+    fcntl = None
+
 import config
 from modules.common.config.impl import ConfigManagerImpl
 from simulation.utils.config_factory import create_config_dto
@@ -31,6 +37,18 @@ def create_simulation(overrides: Dict[str, Any] = None) -> Simulation:
     """Create simulation instance with optional config overrides."""
     logger.info("Initializing simulation.", extra={"tags": ["setup"]})
 
+    # Acquire lock to prevent multiple simulation instances
+    lock_file = None
+    if fcntl:
+        lock_file = open("simulation.lock", "w")
+        try:
+            fcntl.flock(lock_file, fcntl.LOCK_EX | fcntl.LOCK_NB)
+        except IOError:
+            logger.error("Another simulation instance is already running (locked by simulation.lock).")
+            raise RuntimeError("Simulation is already running.")
+    else:
+        logger.warning("File locking is not supported on this platform. Concurrency check skipped.")
+
     if overrides:
         for key, value in overrides.items():
             setattr(config, key, value)
@@ -317,4 +335,8 @@ def create_simulation(overrides: Dict[str, Any] = None) -> Simulation:
     )
     sim = initializer.build_simulation()
 
+    # Attach lock file to simulation object to maintain lock during lifecycle
+    if lock_file:
+        sim._lock_file = lock_file
+
     return sim
diff --git a/watchtower/src/store/useWatchtowerStore.ts b/watchtower/src/store/useWatchtowerStore.ts
index 8a6a6575..598366ac 100644
--- a/watchtower/src/store/useWatchtowerStore.ts
+++ b/watchtower/src/store/useWatchtowerStore.ts
@@ -54,8 +54,8 @@ export const useWatchtowerStore = create<WatchtowerState>((set) => ({
         }
       };
 
-      ws.onclose = () => {
-        console.log('Disconnected from Watchtower');
+      ws.onclose = (event) => {
+        console.log(`Disconnected from Watchtower. Code: ${event.code}, Reason: ${event.reason}`);
         set({ isConnected: false });
         ws = null;
 
