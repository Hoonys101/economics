diff --git a/communications/insights/TD-213-B.md b/communications/insights/TD-213-B.md
new file mode 100644
index 00000000..55eb9435
--- /dev/null
+++ b/communications/insights/TD-213-B.md
@@ -0,0 +1,43 @@
+# Mission Insight Report: TD-213-B Multi-Currency Migration for Firms
+
+## Overview
+This mission successfully migrated the `Firm` agent and its `FinanceDepartment` to a multi-currency architecture. The `FinanceDepartment` now implements the `IFinanceDepartment` protocol and manages balances, revenue, and expenses in multiple currencies.
+
+## Architectural Changes
+
+### 1. Data Contracts (DTOs)
+- **New DTOs**: `MoneyDTO` and `MultiCurrencyWalletDTO` were introduced in `modules/finance/dtos.py`.
+- **System DTOs**: `MarketSignalDTO` now uses `MoneyDTO` for price fields. `OrderDTO` includes `monetary_amount`.
+- **Impact**: Contracts are now explicit about currency, preventing implicit float assumptions.
+
+### 2. FinanceDepartment
+- **Interface**: Implements `IFinanceDepartment`.
+- **Balance Management**: Wraps `firm.wallet` to provide multi-currency `deposit`, `withdraw`, and `get_balance`.
+- **Valuation**: `calculate_valuation` now accepts `exchange_rates` and converts all asset holdings (cash, inventory, capital) to the firm's primary currency (currently defaulted to USD).
+- **Transactions**: `generate_financial_transactions` distributes dividends in the currency they were earned (e.g., EUR profit pays EUR dividends).
+
+### 3. Firm Facade
+- **`get_agent_data`**: The `assets` field now returns a `MultiCurrencyWalletDTO` (wrapping the balance dict). This is a **Breaking Change** for any AI model or observer expecting a flat float or raw dict without the wrapper structure, although `balance` was already a dict.
+- **Delegation**: `calculate_valuation` and `get_book_value_per_share` delegates to `FinanceDepartment`. The facade converts the returned `MoneyDTO` to a float (primary currency amount) to maintain backward compatibility for existing simulation loops.
+
+### 4. Diagnostics
+- **`WorldState.get_total_system_money_for_diagnostics`**: Updated to utilize `EconomicIndicatorTracker`'s `CurrencyExchangeEngine` to convert all system assets to the target currency before summing. This ensures global money supply metrics remain accurate in a multi-currency regime.
+
+## Technical Debt & Insights
+
+1. **Implicit Single-Currency Logic in Departments**:
+   - `ProductionDepartment` (produce) and `SalesDepartment` (marketing ROI) contained logic that assumed `finance.balance` or `finance.revenue_this_turn` were floats or should be treated as single-currency.
+   - **Fix**: Patched to explicitly extract `DEFAULT_CURRENCY` values using `.get()`.
+   - **Debt**: These departments are not yet fully multi-currency aware. They ignore holdings/revenues in other currencies for operational decisions. Future work (`TD-213-C`?) should upgrade `SalesDepartment` to calculate global ROI.
+
+2. **Test Coupling**:
+   - Unit tests for `Firm` were tightly coupled to `FinanceDepartment` implementation details (e.g., expecting `float` returns).
+   - **Insight**: Tests accessing internal components must be updated alongside the component. Moving to DTOs in internal interfaces increases type safety but requires rigorous test updates.
+
+3. **Exchange Rate Availability**:
+   - `Firm.generate_transactions` needs real-time exchange rates to calculate valuation and total revenue.
+   - **Solution**: Rates are fetched from `EconomicIndicatorTracker` via `MarketContext` in `Phase_FirmProductionAndSalaries`. This dependency on the tracker highlights the need for a robust `MarketContext` propagation mechanism in the simulation loop.
+
+## Verification
+- Unit tests (`tests/unit/test_finance_department_currency.py`, `tests/unit/test_firms.py`) pass.
+- Diagnostic calculation (`tests/unit/test_diagnostics.py`) verified.
diff --git a/modules/finance/api.py b/modules/finance/api.py
index d2de9b28..2cff225f 100644
--- a/modules/finance/api.py
+++ b/modules/finance/api.py
@@ -1,9 +1,10 @@
 from __future__ import annotations
-from typing import Protocol, Dict, List, Any, Optional, TypedDict, Literal, Tuple, runtime_checkable, TYPE_CHECKING
+from typing import Protocol, Dict, List, Any, Optional, TypedDict, Literal, Tuple, runtime_checkable, TYPE_CHECKING, Union
 from dataclasses import dataclass
 import abc
 from abc import ABC, abstractmethod
 from uuid import UUID
+from modules.finance.dtos import MoneyDTO, MultiCurrencyWalletDTO
 
 if TYPE_CHECKING:
     from modules.simulation.api import IGovernment, EconomicIndicatorsDTO
@@ -16,6 +17,69 @@ if TYPE_CHECKING:
 class Firm: pass
 class Household: pass # Assuming Household agent also interacts with the bank
 
+class IFinanceDepartment(Protocol):
+    """
+    Interface for a Firm's financial operations, designed for a multi-currency environment.
+    """
+
+    @property
+    @abstractmethod
+    def balance(self) -> Dict[CurrencyCode, float]:
+        """Provides direct access to the raw balances dict."""
+        ...
+
+    @abstractmethod
+    def get_balance(self, currency: CurrencyCode) -> float:
+        """Gets the balance for a specific currency."""
+        ...
+
+    @abstractmethod
+    def deposit(self, amount: float, currency: CurrencyCode):
+        """Deposits a specific amount of a given currency."""
+        ...
+
+    @abstractmethod
+    def withdraw(self, amount: float, currency: CurrencyCode):
+        """Withdraws a specific amount of a given currency. Raises InsufficientFundsError if needed."""
+        ...
+
+    @abstractmethod
+    def get_financial_snapshot(self) -> Dict[str, Union[MoneyDTO, MultiCurrencyWalletDTO, float]]:
+        """Returns a comprehensive, currency-aware snapshot of the firm's financials."""
+        ...
+
+    @abstractmethod
+    def calculate_valuation(self, exchange_rates: Dict[CurrencyCode, float]) -> MoneyDTO:
+        """
+        Calculates the firm's total valuation, converted to its primary currency.
+        Requires current exchange rates.
+        """
+        ...
+
+    @abstractmethod
+    def generate_financial_transactions(
+        self,
+        government: Any,
+        all_households: List[Any],
+        current_time: int,
+        exchange_rates: Dict[CurrencyCode, float]
+    ) -> List[Any]: # Returns List[Transaction]
+        """
+        Generates all standard financial transactions (taxes, dividends, maintenance)
+        in a currency-aware manner.
+        """
+        ...
+
+    @abstractmethod
+    def set_dividend_rate(self, new_rate: float) -> None:
+        """Sets the dividend rate."""
+        ...
+
+    @abstractmethod
+    def pay_ad_hoc_tax(self, amount: float, currency: CurrencyCode, reason: str, government: Any, current_time: int) -> None:
+        """Pays a one-time tax of a specific currency."""
+        ...
+
 @dataclass
 class BondDTO:
     """Data Transfer Object for government bonds."""
@@ -89,8 +153,17 @@ class DebtStatusDTO(TypedDict):
     next_payment_due_tick: Optional[int]
 
 class InsufficientFundsError(Exception):
-    """Raised when a withdrawal is attempted with insufficient funds."""
-    pass
+    """
+    Custom exception to be raised when an operation cannot be completed due to lack of funds.
+    """
+    def __init__(self, message: str, required: Optional[MoneyDTO] = None, available: Optional[MoneyDTO] = None):
+        self.required = required
+        self.available = available
+        if required and available:
+             msg = f"{message} Required: {required['amount']:.2f} {required['currency']}, Available: {available['amount']:.2f} {available['currency']}"
+        else:
+             msg = message
+        super().__init__(msg)
 
 class LoanNotFoundError(Exception):
     """Raised when a specified loan is not found."""
diff --git a/modules/finance/dtos.py b/modules/finance/dtos.py
new file mode 100644
index 00000000..b050de48
--- /dev/null
+++ b/modules/finance/dtos.py
@@ -0,0 +1,18 @@
+from typing import TypedDict, Dict, Optional, List, TypeAlias
+
+CurrencyCode: TypeAlias = str
+
+class MoneyDTO(TypedDict):
+    """Represents a monetary value with its associated currency."""
+    amount: float
+    currency: CurrencyCode
+
+class MultiCurrencyWalletDTO(TypedDict):
+    """Represents a complete portfolio of assets, keyed by currency."""
+    balances: Dict[CurrencyCode, float]
+
+class InvestmentOrderDTO(TypedDict):
+    """Defines an internal order for investment (e.g., R&D, Capex)."""
+    order_type: str # e.g., "INVEST_RD", "INVEST_AUTOMATION"
+    investment: MoneyDTO
+    target_agent_id: Optional[int] # For M&A, etc.
diff --git a/modules/market/api.py b/modules/market/api.py
index 65d0daf6..fcfb5f25 100644
--- a/modules/market/api.py
+++ b/modules/market/api.py
@@ -1,6 +1,7 @@
 from dataclasses import dataclass, field
 from typing import Optional, Dict, Any, TypedDict, Protocol, TYPE_CHECKING
 import uuid
+from modules.finance.dtos import MoneyDTO
 
 if TYPE_CHECKING:
     from simulation.dtos.api import SimulationState
@@ -25,6 +26,9 @@ class OrderDTO:
     brand_info: Optional[Dict[str, Any]] = None # Quality, Awareness
     metadata: Optional[Dict[str, Any]] = None # Side-effects (e.g. Loans)
 
+    # TD-213: Multi-Currency Support
+    monetary_amount: Optional[MoneyDTO] = None
+
     # Auto-generated ID
     id: str = field(default_factory=lambda: str(uuid.uuid4()), init=False)
 
diff --git a/modules/system/api.py b/modules/system/api.py
index ff50fbaf..2504cefb 100644
--- a/modules/system/api.py
+++ b/modules/system/api.py
@@ -2,6 +2,7 @@ from __future__ import annotations
 from dataclasses import dataclass, field
 from typing import TypedDict, List, Dict, Optional, Any, Protocol, TYPE_CHECKING, TypeAlias, runtime_checkable
 from abc import ABC, abstractmethod
+from modules.finance.dtos import MoneyDTO
 
 # --- Phase 33: Multi-Polar WorldState Foundation ---
 CurrencyCode: TypeAlias = str
@@ -32,9 +33,9 @@ class MarketSignalDTO:
     """
     market_id: str
     item_id: str
-    best_bid: Optional[float]
-    best_ask: Optional[float]
-    last_traded_price: Optional[float]
+    best_bid: Optional[MoneyDTO]
+    best_ask: Optional[MoneyDTO]
+    last_traded_price: Optional[MoneyDTO]
     last_trade_tick: int  # Tick of the last trade
     price_history_7d: List[float]  # Rolling 7-tick price history
     volatility_7d: float  # Standard deviation of price_history_7d
diff --git a/scripts/fixture_harvester.py b/scripts/fixture_harvester.py
index d6fce581..a2d51e2e 100644
--- a/scripts/fixture_harvester.py
+++ b/scripts/fixture_harvester.py
@@ -31,6 +31,7 @@ from unittest.mock import MagicMock
 from modules.household.dtos import HouseholdStateDTO
 from simulation.dtos.firm_state_dto import FirmStateDTO
 from simulation.ai.api import Personality
+from modules.system.api import DEFAULT_CURRENCY
 
 # Attempt to import the new generic loader
 try:
@@ -314,6 +315,16 @@ class GoldenLoader:
             if not hasattr(mock, 'hr'):
                 mock.hr = MagicMock()
             mock.hr.employees = []
+
+            # Mock Finance & Wallet for multi-currency
+            mock.finance = MagicMock()
+            mock.wallet = MagicMock()
+            assets_val = f_data.get("assets", 0.0)
+            mock.finance.balance = {DEFAULT_CURRENCY: assets_val}
+            mock.finance.get_balance.side_effect = lambda c: assets_val if c == DEFAULT_CURRENCY else 0.0
+            mock.wallet.get_balance.side_effect = lambda c: assets_val if c == DEFAULT_CURRENCY else 0.0
+            mock.wallet.get_all_balances.return_value = {DEFAULT_CURRENCY: assets_val}
+
             mock.get_financial_snapshot = MagicMock(return_value={
                 "total_assets": f_data.get("assets", 0),
                 "working_capital": f_data.get("assets", 0),
diff --git a/simulation/ai/firm_ai.py b/simulation/ai/firm_ai.py
index 29c00b90..41953715 100644
--- a/simulation/ai/firm_ai.py
+++ b/simulation/ai/firm_ai.py
@@ -68,7 +68,10 @@ class FirmAI(BaseAIEngine):
         assets_raw = agent_data.get("assets", 0)
         cash = assets_raw
         if isinstance(assets_raw, dict):
-            cash = assets_raw.get(DEFAULT_CURRENCY, 0.0)
+            if "balances" in assets_raw:
+                cash = assets_raw["balances"].get(DEFAULT_CURRENCY, 0.0)
+            else:
+                cash = assets_raw.get(DEFAULT_CURRENCY, 0.0)
 
         cash_idx = self._discretize(cash, [100, 500, 1000, 5000, 10000])
 
@@ -187,12 +190,18 @@ class FirmAI(BaseAIEngine):
         current_assets_raw = current_state.get("assets", 0.0)
         current_assets = current_assets_raw
         if isinstance(current_assets_raw, dict):
-            current_assets = current_assets_raw.get(DEFAULT_CURRENCY, 0.0)
+            if "balances" in current_assets_raw:
+                current_assets = current_assets_raw["balances"].get(DEFAULT_CURRENCY, 0.0)
+            else:
+                current_assets = current_assets_raw.get(DEFAULT_CURRENCY, 0.0)
 
         prev_assets_raw = prev_state.get("assets", 0.0)
         prev_assets = prev_assets_raw
         if isinstance(prev_assets_raw, dict):
-            prev_assets = prev_assets_raw.get(DEFAULT_CURRENCY, 0.0)
+            if "balances" in prev_assets_raw:
+                prev_assets = prev_assets_raw["balances"].get(DEFAULT_CURRENCY, 0.0)
+            else:
+                prev_assets = prev_assets_raw.get(DEFAULT_CURRENCY, 0.0)
 
         delta_assets = current_assets - prev_assets
 
diff --git a/simulation/components/finance_department.py b/simulation/components/finance_department.py
index fd42eee7..d0eb467d 100644
--- a/simulation/components/finance_department.py
+++ b/simulation/components/finance_department.py
@@ -1,35 +1,33 @@
 from __future__ import annotations
-from typing import List, Dict, Any, Optional, TYPE_CHECKING
+from typing import List, Dict, Any, Optional, TYPE_CHECKING, Union
 import logging
 from collections import deque
 from simulation.models import Transaction, Order
-from modules.finance.api import InsufficientFundsError
-from modules.system.api import CurrencyCode, DEFAULT_CURRENCY # Added for Phase 33
+from modules.finance.api import IFinancialEntity, InsufficientFundsError, IFinanceDepartment
+from modules.finance.dtos import MoneyDTO, MultiCurrencyWalletDTO
+from modules.system.api import CurrencyCode, DEFAULT_CURRENCY
 
 if TYPE_CHECKING:
     from simulation.firms import Firm
     from simulation.dtos.config_dtos import FirmConfigDTO
     from simulation.core_agents import Household
-    from modules.finance.api import IFinancialEntity
 
 logger = logging.getLogger(__name__)
 
-class FinanceDepartment:
+class FinanceDepartment(IFinanceDepartment):
     """
     Manages assets, maintenance fees, corporate taxes, dividend distribution, and tracks financial metrics.
     Centralized Asset Management (WO-103 Phase 1).
-    Refactored for Multi-Currency support (Phase 33).
+    Refactored for Multi-Currency support (Phase 33, TD-213-B).
     """
     def __init__(self, firm: Firm, config: FirmConfigDTO, initial_capital: float = 0.0):
         self.firm = firm
         self.config = config
-
-        # Centralized Assets (WO-103 Phase 1)
-        # self._balance replaced by self.firm.wallet (BaseAgent.wallet)
+        self.primary_currency: CurrencyCode = DEFAULT_CURRENCY # Could be from config in future
 
         # Financial State
-        self.retained_earnings: float = 0.0 # This might stay float as a net equity measure
-        self.dividends_paid_last_tick: float = 0.0
+        self.retained_earnings: float = 0.0 # Kept as float (primary currency equivalent)
+        self.dividends_paid_last_tick: float = 0.0 # Primary currency equivalent
         self.consecutive_loss_turns: int = 0
         self.current_profit: Dict[CurrencyCode, float] = {DEFAULT_CURRENCY: 0.0}
 
@@ -40,12 +38,12 @@ class FinanceDepartment:
         self.expenses_this_tick: Dict[CurrencyCode, float] = {DEFAULT_CURRENCY: 0.0}
 
         # History
-        self.profit_history: deque[float] = deque(maxlen=self.config.profit_history_ticks)
-        self.last_revenue: float = 0.0
-        self.last_marketing_spend: float = 0.0
+        self.profit_history: deque[float] = deque(maxlen=self.config.profit_history_ticks) # In primary currency
+        self.last_revenue: float = 0.0 # In primary currency
+        self.last_marketing_spend: float = 0.0 # In primary currency
 
         # Solvency Support
-        self.last_daily_expenses: float = 10.0
+        self.last_daily_expenses: float = 10.0 # In primary currency
         self.last_sales_volume: float = 1.0
         self.sales_volume_this_tick: float = 0.0
 
@@ -57,13 +55,31 @@ class FinanceDepartment:
     def balance(self) -> Dict[CurrencyCode, float]:
         return self.firm.wallet.get_all_balances()
 
+    def get_balance(self, currency: CurrencyCode) -> float:
+        return self.firm.wallet.get_balance(currency)
+
+    def deposit(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
+        """Deposits a specific amount of a given currency."""
+        self.firm.wallet.add(amount, currency)
+
+    def withdraw(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
+        """Withdraws a specific amount of a given currency. Raises InsufficientFundsError."""
+        current_bal = self.firm.wallet.get_balance(currency)
+        if current_bal < amount:
+            raise InsufficientFundsError(
+                f"Insufficient funds for withdrawal",
+                required=MoneyDTO(amount=amount, currency=currency),
+                available=MoneyDTO(amount=current_bal, currency=currency)
+            )
+        self.firm.wallet.subtract(amount, currency)
+
     def credit(self, amount: float, description: str = "", currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
-        """Adds funds to the firm's cash reserves."""
-        self.firm.wallet.add(amount, currency, memo=description)
+        """Legacy helper: Adds funds to the firm's cash reserves."""
+        self.deposit(amount, currency)
 
     def debit(self, amount: float, description: str = "", currency: CurrencyCode = DEFAULT_CURRENCY) -> None:
-        """Deducts funds from the firm's cash reserves."""
-        self.firm.wallet.subtract(amount, currency, memo=description)
+        """Legacy helper: Deducts funds from the firm's cash reserves."""
+        self.withdraw(amount, currency)
 
     def record_revenue(self, amount: float, currency: CurrencyCode = DEFAULT_CURRENCY):
         if currency not in self.revenue_this_turn:
@@ -85,13 +101,28 @@ class FinanceDepartment:
         self.expenses_this_tick[currency] += amount
         self.current_profit[currency] -= amount
 
+    def _convert_to_primary(self, amount: float, currency: CurrencyCode, exchange_rates: Dict[CurrencyCode, float]) -> float:
+        """Helper to convert any currency to primary currency."""
+        if currency == self.primary_currency:
+            return amount
+        # Rate is 1 unit of Currency = X units of DEFAULT_CURRENCY?
+        # Typically exchange rates are relative to DEFAULT_CURRENCY (USD).
+        # Assuming exchange_rates[CUR] is price of CUR in USD.
+        # If primary is USD, then amount * rate.
+        rate = exchange_rates.get(currency, 0.0)
+        # If rate is 0/missing, assume 0 value or 1.0 parity? Spec says use exchange_rates.
+        # Assuming exchange_rates has valid rates.
+        return amount * rate
+
     def generate_holding_cost_transaction(self, government: IFinancialEntity, current_time: int) -> Optional[Transaction]:
         """Generates inventory holding cost transaction."""
-        inventory_value = self.get_inventory_value()
+        # This uses get_inventory_value which currently assumes hardcoded price logic.
+        # We'll stick to primary currency for internal cost calculation for now.
+        inventory_value = self.get_inventory_value() # Returns float (assumed primary)
         holding_cost = inventory_value * self.config.inventory_holding_cost_rate
 
         if holding_cost > 0:
-            self.record_expense(holding_cost)
+            self.record_expense(holding_cost, self.primary_currency)
             return Transaction(
                 buyer_id=self.firm.id,
                 seller_id=government.id,
@@ -101,18 +132,18 @@ class FinanceDepartment:
                 market_id="system",
                 transaction_type="holding_cost",
                 time=current_time,
-                currency=DEFAULT_CURRENCY
+                currency=self.primary_currency
             )
         return None
 
     def generate_maintenance_transaction(self, government: IFinancialEntity, current_time: int) -> Optional[Transaction]:
         """Generates maintenance fee transaction."""
         fee = self.config.firm_maintenance_fee
-        current_balance = self.firm.wallet.get_balance(DEFAULT_CURRENCY)
+        current_balance = self.firm.wallet.get_balance(self.primary_currency)
         payment = min(current_balance, fee)
 
         if payment > 0:
-            self.record_expense(payment)
+            self.record_expense(payment, self.primary_currency)
             return Transaction(
                 buyer_id=self.firm.id,
                 seller_id=government.id,
@@ -122,14 +153,17 @@ class FinanceDepartment:
                 market_id="system",
                 transaction_type="tax",
                 time=current_time,
-                currency=DEFAULT_CURRENCY
+                currency=self.primary_currency
             )
         return None
 
     def generate_marketing_transaction(self, government: IFinancialEntity, current_time: int, amount: float) -> Optional[Transaction]:
-        """Generates marketing spend transaction."""
+        """
+        Generates marketing spend transaction.
+        Amount is expected to be in primary currency.
+        """
         if amount > 0:
-            self.record_expense(amount)
+            self.record_expense(amount, self.primary_currency)
             return Transaction(
                 buyer_id=self.firm.id,
                 seller_id=government.id,
@@ -139,16 +173,25 @@ class FinanceDepartment:
                 market_id="system",
                 transaction_type="marketing",
                 time=current_time,
-                currency=DEFAULT_CURRENCY
+                currency=self.primary_currency
             )
         return None
 
-    def process_profit_distribution(self, households: List[Household], government: IFinancialEntity, current_time: int) -> List[Transaction]:
-        """Public Shareholders Dividend & Bailout Repayment."""
+    def process_profit_distribution(self, households: List[Household], government: IFinancialEntity, current_time: int, exchange_rates: Dict[CurrencyCode, float]) -> List[Transaction]:
+        """Public Shareholders Dividend & Bailout Repayment (Multi-Currency)."""
         transactions = []
+
+        # Calculate total profit in primary currency for history tracking
+        total_profit_primary = 0.0
+        for cur, profit in self.current_profit.items():
+            total_profit_primary += self._convert_to_primary(profit, cur, exchange_rates)
+
+        self.profit_history.append(total_profit_primary)
+
+        # Bailout Repayment (Only in Primary Currency usually, but let's check debt currency)
+        # Assuming debt is in primary currency (USD)
         usd_profit = self.current_profit.get(DEFAULT_CURRENCY, 0.0)
 
-        # 1. Bailout Repayment
         if getattr(self.firm, 'has_bailout_loan', False) and usd_profit > 0:
             repayment_ratio = self.config.bailout_repayment_ratio
             repayment = usd_profit * repayment_ratio
@@ -170,18 +213,22 @@ class FinanceDepartment:
             if hasattr(self.firm, 'total_debt'):
                 self.firm.total_debt -= repayment
             self.current_profit[DEFAULT_CURRENCY] -= repayment
-            usd_profit -= repayment
+            usd_profit -= repayment # Update local var
 
             if getattr(self.firm, 'total_debt', 0.0) <= 0:
                 self.firm.has_bailout_loan = False
 
-        # 2. Dividends
-        distributable_profit = max(0, usd_profit * self.firm.dividend_rate)
+        # Dividends (Multi-Currency)
         self.dividends_paid_last_tick = 0.0
 
-        if distributable_profit > 0:
-            total_shares = self.firm.total_shares
-            if total_shares > 0:
+        total_shares = self.firm.total_shares
+
+        for cur, profit in self.current_profit.items():
+            distributable_profit = max(0, profit * self.firm.dividend_rate)
+            if distributable_profit > 0 and total_shares > 0:
+                # Add to total paid (converted)
+                self.dividends_paid_last_tick += self._convert_to_primary(distributable_profit, cur, exchange_rates)
+
                 for household in households:
                     shares = household._econ_state.portfolio.to_legacy_dict().get(self.firm.id, 0.0)
                     if shares > 0:
@@ -196,13 +243,12 @@ class FinanceDepartment:
                                 market_id="financial",
                                 transaction_type="dividend",
                                 time=current_time,
-                                currency=DEFAULT_CURRENCY
+                                currency=cur
                             )
                         )
-                        self.dividends_paid_last_tick += dividend_amount
 
         # Reset period counters
-        for cur in self.current_profit:
+        for cur in list(self.current_profit.keys()): # List copy to avoid runtime error if we modify keys
              self.current_profit[cur] = 0.0
              self.revenue_this_turn[cur] = 0.0
              self.cost_this_turn[cur] = 0.0
@@ -211,55 +257,14 @@ class FinanceDepartment:
 
         return transactions
 
-    def distribute_profit_private(self, agents: Dict[int, Any], government: IFinancialEntity, current_time: int) -> List[Transaction]:
-        """Phase 14-1: Private Owner Dividend Transaction Generation"""
-        if self.firm.owner_id is None:
-            return []
-
-        owner = agents.get(self.firm.owner_id)
-        if owner is None:
-            return []
-
-        maintenance_fee = self.config.firm_maintenance_fee
-        avg_wage = 0.0
-        employees = self.firm.hr.employees
-        if employees:
-            avg_wage = sum(self.firm.hr.employee_wages.values()) / len(employees)
-
-        reserve_period = 20
-        weekly_burn_rate = maintenance_fee + (avg_wage * len(employees))
-        required_reserves = weekly_burn_rate * reserve_period
-
-        usd_balance = self.firm.wallet.get_balance(DEFAULT_CURRENCY)
-        distributable_cash = usd_balance - required_reserves
-
-        transactions = []
-        if distributable_cash > 0:
-            transactions.append(
-                Transaction(
-                    buyer_id=self.firm.id,
-                    seller_id=owner.id,
-                    item_id="private_dividend",
-                    quantity=1.0,
-                    price=distributable_cash,
-                    market_id="financial",
-                    transaction_type="dividend",
-                    time=current_time,
-                    currency=DEFAULT_CURRENCY
-                )
-            )
-            self.dividends_paid_last_tick += distributable_cash
-
-        return transactions
-
-    def generate_financial_transactions(self, government: IFinancialEntity, households: List[Household], current_time: int) -> List[Transaction]:
+    def generate_financial_transactions(self, government: IFinancialEntity, households: List[Household], current_time: int, exchange_rates: Dict[CurrencyCode, float]) -> List[Transaction]:
         """Consolidates all financial outflow generation logic."""
         transactions = []
         tx_holding = self.generate_holding_cost_transaction(government, current_time)
         if tx_holding: transactions.append(tx_holding)
         tx_maint = self.generate_maintenance_transaction(government, current_time)
         if tx_maint: transactions.append(tx_maint)
-        txs_public = self.process_profit_distribution(households, government, current_time)
+        txs_public = self.process_profit_distribution(households, government, current_time, exchange_rates)
         transactions.extend(txs_public)
         return transactions
 
@@ -269,7 +274,8 @@ class FinanceDepartment:
         self.firm.total_debt += amount
 
     def calculate_altman_z_score(self) -> float:
-        usd_balance = self.firm.wallet.get_balance(DEFAULT_CURRENCY)
+        # Assuming primary currency for score
+        usd_balance = self.firm.wallet.get_balance(self.primary_currency)
         total_assets = usd_balance + self.firm.capital_stock + self.get_inventory_value()
         if total_assets == 0: return 0.0
         working_capital = usd_balance - getattr(self.firm, 'total_debt', 0.0)
@@ -284,17 +290,33 @@ class FinanceDepartment:
         return self.last_daily_expenses / max(1.0, target)
 
     def check_bankruptcy(self):
-        if self.current_profit.get(DEFAULT_CURRENCY, 0.0) < 0:
+        # Bankruptcy based on primary currency profit or total?
+        # Logic says: "consecutive loss turns".
+        # We track profit history in primary currency.
+        # But here we check self.current_profit before reset?
+        # Wait, check_bankruptcy is usually called BEFORE profit distribution/reset?
+        # If check_bankruptcy assumes current_profit is not yet reset, we need to sum it up.
+
+        # NOTE: logic in original was: `if self.current_profit.get(DEFAULT_CURRENCY, 0.0) < 0:`
+        # We should check total profit converted.
+        # But we might not have exchange rates here easily.
+        # Let's rely on primary currency profit for simplicity/robustness if rates not avail.
+        # OR, assuming check_bankruptcy is called in a context where we just check primary.
+
+        primary_profit = self.current_profit.get(self.primary_currency, 0.0)
+
+        if primary_profit < 0:
             self.consecutive_loss_turns += 1
         else:
             self.consecutive_loss_turns = 0
+
         threshold = getattr(self.config, "bankruptcy_consecutive_loss_threshold", 20)
         if self.consecutive_loss_turns >= threshold:
             self.firm.is_bankrupt = True
 
     def check_cash_crunch(self) -> bool:
         threshold = 0.1 * self.last_daily_expenses
-        return self.firm.wallet.get_balance(DEFAULT_CURRENCY) < threshold
+        return self.firm.wallet.get_balance(self.primary_currency) < threshold
 
     def trigger_emergency_liquidation(self) -> List[Order]:
         orders = []
@@ -304,17 +326,32 @@ class FinanceDepartment:
             order = Order(
                 agent_id=self.firm.id, side="SELL", item_id=good,
                 quantity=qty, price_limit=price * 0.8, market_id=good,
-                currency=DEFAULT_CURRENCY
+                currency=self.primary_currency
             )
             orders.append(order)
         return orders
 
-    def calculate_valuation(self) -> float:
-        usd_balance = self.firm.wallet.get_balance(DEFAULT_CURRENCY)
-        net_assets = usd_balance + self.get_inventory_value() + self.firm.capital_stock
+    def calculate_valuation(self, exchange_rates: Dict[CurrencyCode, float] = None) -> MoneyDTO:
+        """
+        Calculates the firm's total valuation, converted to its primary currency.
+        """
+        if exchange_rates is None:
+            exchange_rates = {DEFAULT_CURRENCY: 1.0}
+
+        total_assets_val = 0.0
+        # Cash
+        for cur, amount in self.firm.wallet.get_all_balances().items():
+            total_assets_val += self._convert_to_primary(amount, cur, exchange_rates)
+
+        # Inventory & Capital Stock (Assuming priced in primary)
+        total_assets_val += self.get_inventory_value() + self.firm.capital_stock
+
         avg_profit = sum(self.profit_history) / len(self.profit_history) if self.profit_history else 0.0
-        self.firm.valuation = net_assets + max(0.0, avg_profit) * self.config.valuation_per_multiplier
-        return self.firm.valuation
+        valuation_amt = total_assets_val + max(0.0, avg_profit) * self.config.valuation_per_multiplier
+
+        self.firm.valuation = valuation_amt # Store float in firm for legacy/cache
+
+        return MoneyDTO(amount=valuation_amt, currency=self.primary_currency)
 
     def get_inventory_value(self) -> float:
         total_val = 0.0
@@ -323,20 +360,37 @@ class FinanceDepartment:
              total_val += qty * price
         return total_val
 
-    def get_financial_snapshot(self) -> Dict[str, float]:
+    def get_financial_snapshot(self) -> Dict[str, Union[MoneyDTO, MultiCurrencyWalletDTO, float]]:
+        """
+        Returns a comprehensive, currency-aware snapshot.
+        """
+        wallet_dto = MultiCurrencyWalletDTO(balances=self.firm.wallet.get_all_balances())
+
+        # Total assets (estimated in primary for float fields, or return wallet)
+        # Spec says: Dict[str, MoneyDTO | MultiCurrencyWalletDTO]
+        # But existing code expects keys like "working_capital" as floats maybe?
+        # We will provide structured data.
+
+        # Calculating legacy float metrics for backward compat where feasible
         usd_balance = self.firm.wallet.get_balance(DEFAULT_CURRENCY)
         total_assets = usd_balance + self.get_inventory_value() + getattr(self.firm, 'capital_stock', 0.0)
         current_liabilities = getattr(self.firm, "total_debt", 0.0)
-        avg_profit = self.current_profit.get(DEFAULT_CURRENCY, 0.0)
+
+        avg_profit = 0.0
         if self.profit_history:
             recent = list(self.profit_history)[-10:]
             avg_profit = sum(recent) / len(recent)
+
         return {
+            "wallet": wallet_dto,
+            "total_assets_est": MoneyDTO(amount=total_assets, currency=DEFAULT_CURRENCY), # Approximate
+            "working_capital_est": MoneyDTO(amount=total_assets - current_liabilities, currency=DEFAULT_CURRENCY),
+            "retained_earnings": MoneyDTO(amount=self.retained_earnings, currency=self.primary_currency),
+            "average_profit": MoneyDTO(amount=avg_profit, currency=self.primary_currency),
+            "total_debt": MoneyDTO(amount=current_liabilities, currency=DEFAULT_CURRENCY),
+            # Legacy keys (float) if needed by other systems (optional but helpful)
             "total_assets": total_assets,
             "working_capital": total_assets - current_liabilities,
-            "retained_earnings": self.retained_earnings,
-            "average_profit": avg_profit,
-            "total_debt": current_liabilities
         }
 
     def issue_shares(self, quantity: float, price: float) -> float:
@@ -344,51 +398,61 @@ class FinanceDepartment:
         self.firm.total_shares += quantity
         return quantity * price
 
-    def get_book_value_per_share(self) -> float:
+    def get_book_value_per_share(self) -> MoneyDTO:
         outstanding_shares = self.firm.total_shares - self.firm.treasury_shares
-        if outstanding_shares <= 0: return 0.0
+        if outstanding_shares <= 0:
+            return MoneyDTO(amount=0.0, currency=self.primary_currency)
+
         debt = getattr(self.firm, 'total_debt', 0.0)
-        net_assets = self.firm.wallet.get_balance(DEFAULT_CURRENCY) - debt
-        return max(0.0, net_assets) / outstanding_shares
+        # Net Assets in primary currency
+        net_assets = self.firm.wallet.get_balance(self.primary_currency) - debt
+        # Note: This ignores other currency holdings if not converted.
+        # Ideally should convert all, but requires exchange rates which we don't have here easily.
+        # Assuming book value is roughly primary currency based.
+
+        val = max(0.0, net_assets) / outstanding_shares
+        return MoneyDTO(amount=val, currency=self.primary_currency)
 
     def get_market_cap(self, stock_price: Optional[float] = None) -> float:
-        if stock_price is None: stock_price = self.get_book_value_per_share()
+        # Returns float (primary currency)
+        if stock_price is None:
+            bv = self.get_book_value_per_share()
+            stock_price = bv['amount']
         return (self.firm.total_shares - self.firm.treasury_shares) * stock_price
 
     def get_assets(self) -> float:
-        return self.firm.wallet.get_balance(DEFAULT_CURRENCY)
+        """Legacy accessor: returns primary currency balance."""
+        return self.firm.wallet.get_balance(self.primary_currency)
 
     def invest_in_automation(self, amount: float, government: Optional[IFinancialEntity] = None) -> bool:
-        if self.firm.wallet.get_balance(DEFAULT_CURRENCY) < amount: return False
+        if self.firm.wallet.get_balance(self.primary_currency) < amount: return False
         if not self.firm.settlement_system or not government: return False
-        return self.firm.settlement_system.transfer(self.firm, government, amount, "Automation", currency=DEFAULT_CURRENCY)
+        return self.firm.settlement_system.transfer(self.firm, government, amount, "Automation", currency=self.primary_currency)
 
     def invest_in_rd(self, amount: float, government: Optional[IFinancialEntity] = None) -> bool:
-        if self.firm.wallet.get_balance(DEFAULT_CURRENCY) < amount: return False
+        if self.firm.wallet.get_balance(self.primary_currency) < amount: return False
         if not self.firm.settlement_system or not government: return False
-        if self.firm.settlement_system.transfer(self.firm, government, amount, "R&D", currency=DEFAULT_CURRENCY):
-            self.record_expense(amount)
+        if self.firm.settlement_system.transfer(self.firm, government, amount, "R&D", currency=self.primary_currency):
+            self.record_expense(amount, self.primary_currency)
             return True
         return False
 
     def invest_in_capex(self, amount: float, government: Optional[IFinancialEntity] = None) -> bool:
-        if self.firm.wallet.get_balance(DEFAULT_CURRENCY) < amount: return False
+        if self.firm.wallet.get_balance(self.primary_currency) < amount: return False
         if not self.firm.settlement_system or not government: return False
-        return self.firm.settlement_system.transfer(self.firm, government, amount, "CAPEX", currency=DEFAULT_CURRENCY)
+        return self.firm.settlement_system.transfer(self.firm, government, amount, "CAPEX", currency=self.primary_currency)
 
-    def set_dividend_rate(self, rate: float) -> None:
-        self.firm.dividend_rate = rate
+    def set_dividend_rate(self, new_rate: float) -> None:
+        self.firm.dividend_rate = new_rate
 
     def pay_severance(self, employee: Household, amount: float) -> bool:
-        if self.firm.wallet.get_balance(DEFAULT_CURRENCY) >= amount and self.firm.settlement_system:
-            if self.firm.settlement_system.transfer(self.firm, employee, amount, "Severance", currency=DEFAULT_CURRENCY):
-                self.record_expense(amount)
+        if self.firm.wallet.get_balance(self.primary_currency) >= amount and self.firm.settlement_system:
+            if self.firm.settlement_system.transfer(self.firm, employee, amount, "Severance", currency=self.primary_currency):
+                self.record_expense(amount, self.primary_currency)
                 return True
         return False
 
-    def pay_ad_hoc_tax(self, amount: float, tax_type: str, government: Any, current_time: int) -> bool:
-        if self.firm.wallet.get_balance(DEFAULT_CURRENCY) >= amount and self.firm.settlement_system:
-            if self.firm.settlement_system.transfer(self.firm, government, amount, tax_type, currency=DEFAULT_CURRENCY):
-                self.record_expense(amount)
-                return True
-        return False
+    def pay_ad_hoc_tax(self, amount: float, currency: CurrencyCode, reason: str, government: Any, current_time: int) -> None:
+        if self.firm.wallet.get_balance(currency) >= amount and self.firm.settlement_system:
+            if self.firm.settlement_system.transfer(self.firm, government, amount, reason, currency=currency):
+                self.record_expense(amount, currency)
diff --git a/simulation/components/sales_department.py b/simulation/components/sales_department.py
index d4f3a9ac..f2341a9a 100644
--- a/simulation/components/sales_department.py
+++ b/simulation/components/sales_department.py
@@ -1,5 +1,6 @@
 from __future__ import annotations
 from typing import TYPE_CHECKING, Dict, Any
+from modules.system.api import DEFAULT_CURRENCY
 
 if TYPE_CHECKING:
     from simulation.firms import Firm
@@ -52,15 +53,18 @@ class SalesDepartment:
         """Adjust marketing budget rate based on ROI."""
         delta_spend = self.firm.marketing_budget  # Current tick spend
 
+        # Extract primary currency revenue (approximate ROI for now)
+        current_revenue_usd = self.firm.finance.revenue_this_turn.get(DEFAULT_CURRENCY, 0.0)
+
         # Skip first tick or zero previous spend
         # Note: We use last_marketing_spend from PREVIOUS tick to calculate ROI of THAT spend.
         # But we also need to avoid division by zero.
         if delta_spend <= 0 or self.firm.finance.last_marketing_spend <= 0:
-            self.firm.finance.last_revenue = self.firm.finance.revenue_this_turn
+            self.firm.finance.last_revenue = current_revenue_usd
             self.firm.finance.last_marketing_spend = self.firm.marketing_budget
             return
 
-        delta_revenue = self.firm.finance.revenue_this_turn - self.firm.finance.last_revenue
+        delta_revenue = current_revenue_usd - self.firm.finance.last_revenue
         efficiency = delta_revenue / self.firm.finance.last_marketing_spend
 
         # Decision Rules
@@ -78,7 +82,7 @@ class SalesDepartment:
             self.firm.marketing_budget_rate = max(min_rate, self.firm.marketing_budget_rate * 0.9)
 
         # Update tracking
-        self.firm.finance.last_revenue = self.firm.finance.revenue_this_turn
+        self.firm.finance.last_revenue = current_revenue_usd
         self.firm.finance.last_marketing_spend = self.firm.marketing_budget
 
     def set_price(self, item_id: str, price: float) -> None:
diff --git a/simulation/firms.py b/simulation/firms.py
index bd4e7e9e..233f4032 100644
--- a/simulation/firms.py
+++ b/simulation/firms.py
@@ -24,6 +24,7 @@ from simulation.components.production_department import ProductionDepartment
 from simulation.components.sales_department import SalesDepartment
 from simulation.utils.shadow_logger import log_shadow
 from modules.finance.api import InsufficientFundsError
+from modules.finance.dtos import MoneyDTO, MultiCurrencyWalletDTO
 from simulation.systems.api import ILearningAgent, LearningUpdateContext
 
 if TYPE_CHECKING:
@@ -273,7 +274,7 @@ class Firm(BaseAgent, ILearningAgent):
     def get_agent_data(self) -> Dict[str, Any]:
         """AI 의사결정에 필요한 에이전트의 현재 상태 데이터를 반환합니다."""
         return {
-            "assets": self.finance.balance, # Direct Access
+            "assets": MultiCurrencyWalletDTO(balances=self.finance.balance), # Direct Access wrapped in DTO
             "needs": self.needs.copy(),
             "inventory": self.inventory.copy(),
             "input_inventory": self.input_inventory.copy(), # WO-030
@@ -395,24 +396,33 @@ class Firm(BaseAgent, ILearningAgent):
         """
         [REFACTORED] Routes internal orders to the correct department.
         """
+        # Helper to extract amount from monetary_amount if present, else fallback to quantity
+        def get_amount(o: Order) -> float:
+            return o.monetary_amount['amount'] if o.monetary_amount else o.quantity
+
+        # Helper to get currency
+        def get_currency(o: Order) -> CurrencyCode:
+             return o.monetary_amount['currency'] if o.monetary_amount else DEFAULT_CURRENCY
+
         if order.order_type == "SET_TARGET":
             self.production.set_production_target(order.quantity)
 
         elif order.order_type == "INVEST_AUTOMATION":
-            self.production.invest_in_automation(order.quantity, government)
+            self.production.invest_in_automation(get_amount(order), government)
 
         elif order.order_type == "PAY_TAX":
             # Finance still handles this directly as it's purely financial
-            amount = order.quantity
+            amount = get_amount(order)
+            currency = get_currency(order)
             reason = order.item_id
             if government:
-                self.finance.pay_ad_hoc_tax(amount, reason, government, current_time)
+                self.finance.pay_ad_hoc_tax(amount, currency, reason, government, current_time)
 
         elif order.order_type == "INVEST_RD":
-            self.production.invest_in_rd(order.quantity, government, current_time)
+            self.production.invest_in_rd(get_amount(order), government, current_time)
 
         elif order.order_type == "INVEST_CAPEX":
-            self.production.invest_in_capex(order.quantity, government)
+            self.production.invest_in_capex(get_amount(order), government)
 
         elif order.order_type == "SET_DIVIDEND":
             self.finance.set_dividend_rate(order.quantity)
@@ -471,11 +481,14 @@ class Firm(BaseAgent, ILearningAgent):
             details=f"Item={self.specialization}, D={demand:.1f}, S={supply:.1f}, Ratio={excess_demand_ratio:.2f}"
         )
 
-    def generate_transactions(self, government: Optional[Any], market_data: Dict[str, Any], all_households: List[Household], current_time: int) -> List[Transaction]:
+    def generate_transactions(self, government: Optional[Any], market_data: Dict[str, Any], all_households: List[Household], current_time: int, exchange_rates: Dict[CurrencyCode, float] = None) -> List[Transaction]:
         """
         Generates all financial transactions for the tick (Wages, Taxes, Dividends, etc.).
         Phase 3 Architecture.
         """
+        if exchange_rates is None:
+            exchange_rates = {DEFAULT_CURRENCY: 1.0}
+
         transactions = []
 
         # 1. Wages & Income Tax (HR)
@@ -483,19 +496,25 @@ class Firm(BaseAgent, ILearningAgent):
         transactions.extend(tx_payroll)
 
         # 2. Finance Transactions (Holding, Maint, Corp Tax, Dividends, Bailout Repayment)
-        tx_finance = self.finance.generate_financial_transactions(government, all_households, current_time)
+        tx_finance = self.finance.generate_financial_transactions(government, all_households, current_time, exchange_rates)
         transactions.extend(tx_finance)
 
         # 3. Marketing (Direct Calculation here as per old update_needs)
-        usd_balance = self.finance.balance.get(DEFAULT_CURRENCY, 0.0)
-        usd_revenue = self.finance.revenue_this_turn.get(DEFAULT_CURRENCY, 0.0)
+        # Using primary currency for marketing budget logic
+        primary_cur = self.finance.primary_currency
+        primary_balance = self.finance.get_balance(primary_cur)
 
-        if usd_balance > 100.0:
-            marketing_spend = max(10.0, usd_revenue * self.marketing_budget_rate)
+        # Calculate total revenue in primary currency
+        total_revenue = 0.0
+        for cur, amount in self.finance.revenue_this_turn.items():
+            total_revenue += self.finance._convert_to_primary(amount, cur, exchange_rates)
+
+        if primary_balance > 100.0:
+            marketing_spend = max(10.0, total_revenue * self.marketing_budget_rate)
         else:
             marketing_spend = 0.0
 
-        if usd_balance < marketing_spend:
+        if primary_balance < marketing_spend:
              marketing_spend = 0.0
 
         if marketing_spend > 0:
@@ -543,18 +562,18 @@ class Firm(BaseAgent, ILearningAgent):
     # --- Delegated Methods (Facade Pattern) ---
 
     def get_book_value_per_share(self) -> float:
-        """Delegates to FinanceDepartment."""
-        return self.finance.get_book_value_per_share()
+        """Delegates to FinanceDepartment. Returns float (primary currency) for backward compatibility."""
+        return self.finance.get_book_value_per_share()['amount']
 
     def get_market_cap(self, stock_price: Optional[float] = None) -> float:
         """Delegates to FinanceDepartment."""
         return self.finance.get_market_cap(stock_price)
 
-    def calculate_valuation(self) -> float:
-        """Delegates to FinanceDepartment."""
-        return self.finance.calculate_valuation()
+    def calculate_valuation(self, exchange_rates: Dict[CurrencyCode, float] = None) -> float:
+        """Delegates to FinanceDepartment. Returns float (primary currency) for backward compatibility."""
+        return self.finance.calculate_valuation(exchange_rates)['amount']
 
-    def get_financial_snapshot(self) -> Dict[str, float]:
+    def get_financial_snapshot(self) -> Dict[str, Any]:
         """Delegates to FinanceDepartment."""
         return self.finance.get_financial_snapshot()
 
diff --git a/simulation/orchestration/phases.py b/simulation/orchestration/phases.py
index 4de6cbbc..59ae4aee 100644
--- a/simulation/orchestration/phases.py
+++ b/simulation/orchestration/phases.py
@@ -495,13 +495,21 @@ class Phase_FirmProductionAndSalaries(IPhaseStrategy):
     def execute(self, state: SimulationState) -> SimulationState:
         market_data_prev = state.market_data
 
+        # TD-213: Fetch exchange rates for multi-currency transactions
+        exchange_rates = None
+        if state.tracker and hasattr(state.tracker, "capture_market_context"):
+            ctx = state.tracker.capture_market_context()
+            if ctx:
+                exchange_rates = ctx.exchange_rates
+
         for firm in state.firms:
              if firm.is_active:
                  firm_txs = firm.generate_transactions(
                      government=state.government,
                      market_data=market_data_prev,
                      all_households=state.households,
-                     current_time=state.time
+                     current_time=state.time,
+                     exchange_rates=exchange_rates
                  )
                  if firm_txs:
                      state.transactions.extend(firm_txs)
diff --git a/simulation/world_state.py b/simulation/world_state.py
index 7fcceb0a..6862be7c 100644
--- a/simulation/world_state.py
+++ b/simulation/world_state.py
@@ -193,9 +193,19 @@ class WorldState:
     def get_total_system_money_for_diagnostics(self, target_currency: CurrencyCode = "USD") -> float:
         """
         Provides a single float value for total system money for backward compatibility
-        with diagnostic tools. Tracks only a single currency and ignores exchange rates.
+        with diagnostic tools. Converts all currencies to the target currency.
         """
         all_money = self.calculate_total_money()
+
+        # Use tracker's exchange engine if available
+        if self.tracker and hasattr(self.tracker, "exchange_engine"):
+            total = 0.0
+            for cur, amount in all_money.items():
+                converted = self.tracker.exchange_engine.convert(amount, cur, target_currency)
+                total += converted
+            return total
+
+        # Fallback if no exchange engine: just return the target currency balance
         return all_money.get(target_currency, 0.0)
 
     def resolve_agent_id(self, role: str) -> Optional[int]:
diff --git a/tests/unit/test_diagnostics.py b/tests/unit/test_diagnostics.py
new file mode 100644
index 00000000..3a0f6e18
--- /dev/null
+++ b/tests/unit/test_diagnostics.py
@@ -0,0 +1,34 @@
+import pytest
+from unittest.mock import Mock
+from simulation.world_state import WorldState
+from modules.system.api import DEFAULT_CURRENCY
+
+def test_get_total_system_money_diagnostics():
+    # Mock WorldState dependencies
+    mock_tracker = Mock()
+    mock_exchange = Mock()
+    mock_tracker.exchange_engine = mock_exchange
+
+    ws = WorldState(Mock(), Mock(), Mock(), Mock())
+    ws.tracker = mock_tracker
+
+    # Mock calculate_total_money (we mock the method on the instance)
+    ws.calculate_total_money = Mock(return_value={
+        DEFAULT_CURRENCY: 1000.0,
+        "EUR": 500.0
+    })
+
+    # Mock conversion: 1 EUR = 1.1 USD
+    def convert(amount, from_c, to_c):
+        if from_c == "EUR" and to_c == DEFAULT_CURRENCY:
+            return amount * 1.1
+        if from_c == DEFAULT_CURRENCY and to_c == DEFAULT_CURRENCY:
+            return amount
+        return 0.0
+
+    mock_exchange.convert.side_effect = convert
+
+    total = ws.get_total_system_money_for_diagnostics(DEFAULT_CURRENCY)
+
+    # 1000 + 500*1.1 = 1550
+    assert total == pytest.approx(1550.0)
diff --git a/tests/unit/test_finance_department_currency.py b/tests/unit/test_finance_department_currency.py
new file mode 100644
index 00000000..0ac4c68b
--- /dev/null
+++ b/tests/unit/test_finance_department_currency.py
@@ -0,0 +1,102 @@
+import pytest
+from unittest.mock import Mock, MagicMock
+from simulation.components.finance_department import FinanceDepartment
+from modules.finance.dtos import MoneyDTO
+from modules.system.api import DEFAULT_CURRENCY
+from modules.finance.api import InsufficientFundsError
+
+class MockWallet:
+    def __init__(self):
+        self.balances = {DEFAULT_CURRENCY: 1000.0, "EUR": 500.0}
+
+    def get_all_balances(self):
+        return self.balances
+
+    def get_balance(self, currency):
+        return self.balances.get(currency, 0.0)
+
+    def add(self, amount, currency, memo=""):
+        self.balances[currency] = self.balances.get(currency, 0.0) + amount
+
+    def subtract(self, amount, currency, memo=""):
+        self.balances[currency] = self.balances.get(currency, 0.0) - amount
+
+@pytest.fixture
+def firm_mock():
+    firm = Mock()
+    firm.wallet = MockWallet()
+    firm.id = 1
+    firm.total_shares = 100
+    firm.treasury_shares = 0
+    firm.dividend_rate = 0.1
+    firm.inventory = {}
+    firm.capital_stock = 100.0
+    firm.last_prices = {}
+    firm.settlement_system = None
+    firm.has_bailout_loan = False
+    firm.total_debt = 0.0
+    return firm
+
+@pytest.fixture
+def config_mock():
+    config = Mock()
+    config.profit_history_ticks = 10
+    config.inventory_holding_cost_rate = 0.01
+    config.firm_maintenance_fee = 10.0
+    config.valuation_per_multiplier = 10.0
+    config.bailout_repayment_ratio = 0.1
+    return config
+
+def test_multi_currency_balance(firm_mock, config_mock):
+    finance = FinanceDepartment(firm_mock, config_mock)
+    assert finance.get_balance(DEFAULT_CURRENCY) == 1000.0
+    assert finance.get_balance("EUR") == 500.0
+
+def test_deposit_withdraw(firm_mock, config_mock):
+    finance = FinanceDepartment(firm_mock, config_mock)
+    finance.deposit(100.0, "EUR")
+    assert finance.get_balance("EUR") == 600.0
+
+    finance.withdraw(50.0, "EUR")
+    assert finance.get_balance("EUR") == 550.0
+
+    with pytest.raises(InsufficientFundsError):
+        finance.withdraw(1000.0, "EUR")
+
+def test_valuation(firm_mock, config_mock):
+    finance = FinanceDepartment(firm_mock, config_mock)
+    exchange_rates = {DEFAULT_CURRENCY: 1.0, "EUR": 1.1} # 1 EUR = 1.1 USD
+
+    # 1000 USD + 500 EUR * 1.1 = 1000 + 550 = 1550 USD cash
+    # Inventory 0
+    # Capital Stock 100
+    # Total Assets = 1650
+    # Profit 0
+    # Valuation = 1650
+
+    val = finance.calculate_valuation(exchange_rates)
+    assert val['currency'] == DEFAULT_CURRENCY
+    assert val['amount'] == pytest.approx(1650.0)
+
+def test_generate_transactions_dividends(firm_mock, config_mock):
+    finance = FinanceDepartment(firm_mock, config_mock)
+    finance.current_profit = {DEFAULT_CURRENCY: 100.0, "EUR": 50.0}
+
+    # Mock households
+    h1 = Mock()
+    h1.id = 101
+    h1._econ_state.portfolio.to_legacy_dict.return_value = {1: 50.0} # owns 50%
+
+    exchange_rates = {DEFAULT_CURRENCY: 1.0, "EUR": 1.1}
+
+    transactions = finance.process_profit_distribution([h1], Mock(), 1, exchange_rates)
+
+    # Expect dividend in USD: 100 * 0.1 = 10 total. H1 gets 5.
+    # Expect dividend in EUR: 50 * 0.1 = 5 total. H1 gets 2.5.
+
+    assert len(transactions) == 2
+    usd_tx = next(t for t in transactions if t.currency == DEFAULT_CURRENCY)
+    eur_tx = next(t for t in transactions if t.currency == "EUR")
+
+    assert usd_tx.price == 5.0
+    assert eur_tx.price == 2.5
diff --git a/tests/unit/test_firms.py b/tests/unit/test_firms.py
index 35c5cf89..7b79462d 100644
--- a/tests/unit/test_firms.py
+++ b/tests/unit/test_firms.py
@@ -1,10 +1,10 @@
-
 import pytest
 from unittest.mock import Mock, MagicMock
 import math
 from simulation.firms import Firm
 from simulation.components.production_department import ProductionDepartment
 from simulation.components.sales_department import SalesDepartment
+from modules.system.api import DEFAULT_CURRENCY
 
 class TestFirmBookValue:
     @pytest.fixture
@@ -24,6 +24,7 @@ class TestFirmBookValue:
         dto.labor_alpha = 0.7
         dto.capital_depreciation_rate = 0.05
         dto.goods = {"test": {"quality_sensitivity": 0.5}}
+        dto.valuation_per_multiplier = 10.0 # Default if not set in factory
         return dto
 
     @pytest.fixture
@@ -42,49 +43,43 @@ class TestFirmBookValue:
     def test_book_value_no_liabilities(self, firm):
         # Assets 1000, Shares 100, Treasury 100
         firm.treasury_shares = 0
-        assert firm.finance.get_book_value_per_share() == 10.0
+        # Accessing FinanceDepartment directly returns MoneyDTO
+        result = firm.finance.get_book_value_per_share()
+        assert result['amount'] == 10.0
+        assert result['currency'] == DEFAULT_CURRENCY
 
     def test_book_value_with_liabilities(self, firm, mock_decision_engine):
         # Setup Liabilities
-        mock_loan_market = Mock()
-        mock_bank = Mock()
-
-        mock_decision_engine.loan_market = mock_loan_market
-        mock_loan_market.bank = mock_bank
         firm.treasury_shares = 0
 
-        # Mock both legacy and new interface to be safe
-        mock_bank.get_debt_summary.return_value = {"total_principal": 200.0}
-        mock_bank.get_debt_status.return_value = {"total_outstanding_debt": 200.0}
+        # New FinanceDepartment uses firm.total_debt
+        firm.total_debt = 200.0
 
         # Net Assets = 1000 - 200 = 800. Shares 100.
-        assert firm.finance.get_book_value_per_share() == 8.0
+        result = firm.finance.get_book_value_per_share()
+        assert result['amount'] == 8.0
 
     def test_book_value_with_treasury_shares(self, firm):
         firm.treasury_shares = 20.0
         # Assets 1000. Outstanding Shares 80.
-        assert firm.finance.get_book_value_per_share() == 12.5
+        result = firm.finance.get_book_value_per_share()
+        assert result['amount'] == 12.5
 
     def test_book_value_negative_net_assets(self, firm, mock_decision_engine):
          # Setup Huge Liabilities
-        mock_loan_market = Mock()
-        mock_bank = Mock()
-        mock_decision_engine.loan_market = mock_loan_market
-        mock_loan_market.bank = mock_bank
         firm.treasury_shares = 0
-
-        # Mock both legacy and new interface
-        mock_bank.get_debt_summary.return_value = {"total_principal": 2000.0}
-        mock_bank.get_debt_status.return_value = {"total_outstanding_debt": 2000.0}
+        firm.total_debt = 2000.0
 
         # Net Assets = 1000 - 2000 = -1000.
         # Should return 0.0
-        assert firm.finance.get_book_value_per_share() == 0.0
+        result = firm.finance.get_book_value_per_share()
+        assert result['amount'] == 0.0
 
     def test_book_value_zero_shares(self, firm):
         firm.total_shares = 0.0
         firm.treasury_shares = 0.0
-        assert firm.finance.get_book_value_per_share() == 0.0
+        result = firm.finance.get_book_value_per_share()
+        assert result['amount'] == 0.0
 
 class TestProductionDepartment:
     @pytest.fixture
@@ -115,6 +110,10 @@ class TestProductionDepartment:
         firm.base_quality = 1.0
         firm.hr.get_total_labor_skill.return_value = 5.0
         firm.hr.get_avg_skill.return_value = 1.0
+        # Mock finance balance for produce() check
+        firm.finance = Mock()
+        firm.finance.balance = {DEFAULT_CURRENCY: 1000.0}
+        firm.production_target = 100.0
         return firm
 
     def test_produce(self, firm, mock_config):
@@ -154,7 +153,8 @@ class TestSalesDepartment:
         firm.inventory_quality = {}
         firm.marketing_budget = 100.0
         firm.finance.last_marketing_spend = 50.0 # Lower spend last tick
-        firm.finance.revenue_this_turn = 200.0
+        # Update: revenue_this_turn is a dict
+        firm.finance.revenue_this_turn = {DEFAULT_CURRENCY: 200.0}
         firm.finance.last_revenue = 100.0
         firm.marketing_budget_rate = 0.1
         firm.logger = Mock()
@@ -172,7 +172,7 @@ class TestSalesDepartment:
     def test_adjust_marketing_budget_increase(self, firm, mock_config):
         # High ROI should increase the budget rate
         firm.finance.last_marketing_spend = 50.0
-        firm.finance.revenue_this_turn = 200.0
+        firm.finance.revenue_this_turn = {DEFAULT_CURRENCY: 200.0}
         firm.finance.last_revenue = 100.0
 
         sales_dept = SalesDepartment(firm, mock_config)
@@ -184,7 +184,7 @@ class TestSalesDepartment:
     def test_adjust_marketing_budget_decrease(self, firm, mock_config):
         # Low ROI should decrease the budget rate
         firm.finance.last_marketing_spend = 200.0 # High spend
-        firm.finance.revenue_this_turn = 110.0 # Low return
+        firm.finance.revenue_this_turn = {DEFAULT_CURRENCY: 110.0} # Low return
         firm.finance.last_revenue = 100.0
 
         sales_dept = SalesDepartment(firm, mock_config)
