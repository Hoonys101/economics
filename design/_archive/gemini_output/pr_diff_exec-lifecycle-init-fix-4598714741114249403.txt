diff --git a/communications/insights/exec-lifecycle-init-fix.md b/communications/insights/exec-lifecycle-init-fix.md
new file mode 100644
index 00000000..2f03812f
--- /dev/null
+++ b/communications/insights/exec-lifecycle-init-fix.md
@@ -0,0 +1,53 @@
+# Lifecycle Manager Initialization & Cycle Fix Report
+
+## Architectural Insights
+
+### Issue Identification
+The `AgentLifecycleManager` generates transactions during `Phase_Bankruptcy` (Phase 4). These transactions are intended to be processed in the **next tick** (Sacred Sequence). They were correctly placed into the `inter_tick_queue` of the `SimulationState` and subsequently drained into the `WorldState.inter_tick_queue`.
+
+However, the `TickOrchestrator` lacked a mechanism to retrieve these transactions from `WorldState.inter_tick_queue` at the start of the next tick. Consequently, lifecycle events (births, deaths, aging transitions) that generated financial or state-changing transactions were effectively silently dropped, leading to a "zombie" state where lifecycle logic executed but its side effects never materialized.
+
+### Resolution
+The `TickOrchestrator.run_tick` method was modified to explicitly check for items in `WorldState.inter_tick_queue` at the beginning of the tick cycle. If items are present, they are:
+1.  Logged via `LIFECYCLE_QUEUE` tag.
+2.  Promoted to `WorldState.transactions`.
+3.  Cleared from `inter_tick_queue`.
+
+This ensures that `Phase3_Transaction` (which processes `WorldState.transactions`) will pick up and execute these deferred transactions in the new tick, preserving the intended "Sacred Sequence" (Decision -> Matching -> Transaction).
+
+### Initialization Verification
+The initialization of `LifecycleManager` was verified in `SimulationInitializer.build_simulation`. It is correctly instantiated and assigned to `Simulation.lifecycle_manager` (delegating to `WorldState`), ensuring it is available for `Phase_Bankruptcy` execution.
+
+## Test Evidence
+
+### Reproduction & Verification Test
+A new integration test `tests/integration/test_lifecycle_cycle.py` was created to reproduce the issue and verify the fix. It mocks the `WorldState` and `LifecycleManager` to simulate a transaction generation and asserts its processing in the subsequent tick.
+
+**Test Output:**
+```
+tests/integration/test_lifecycle_cycle.py::TestLifecycleCycle::test_lifecycle_transactions_processed_in_next_tick_strong_verify PASSED [100%]
+
+=============================== warnings summary ===============================
+../home/jules/.local/share/pipx/venvs/pytest/lib/python3.12/site-packages/_pytest/config/__init__.py:1428
+  /home/jules/.local/share/pipx/venvs/pytest/lib/python3.12/site-packages/_pytest/config/__init__.py:1428: PytestConfigWarning: Unknown config option: asyncio_default_fixture_loop_scope
+
+    self._warn_or_fail_if_strict(f"Unknown config option: {key}\n")
+
+../home/jules/.local/share/pipx/venvs/pytest/lib/python3.12/site-packages/_pytest/config/__init__.py:1428
+  /home/jules/.local/share/pipx/venvs/pytest/lib/python3.12/site-packages/_pytest/config/__init__.py:1428: PytestConfigWarning: Unknown config option: asyncio_mode
+
+    self._warn_or_fail_if_strict(f"Unknown config option: {key}\n")
+
+-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
+======================== 1 passed, 2 warnings in 0.28s =========================
+```
+
+### Regression Testing
+Existing orchestration tests were run to ensure no side effects.
+
+```
+tests/orchestration/test_state_synchronization.py::TestStateSynchronization::test_transient_queue_accumulation PASSED [ 25%]
+tests/orchestration/test_state_synchronization.py::TestStateSynchronization::test_reassignment_guardrail PASSED [ 50%]
+tests/integration/test_tick_normalization.py::TestTickNormalization::test_run_tick_executes_phases PASSED [ 75%]
+tests/integration/test_lifecycle_cycle.py::TestLifecycleCycle::test_lifecycle_transactions_processed_in_next_tick_strong_verify PASSED [100%]
+```
diff --git a/simulation/orchestration/tick_orchestrator.py b/simulation/orchestration/tick_orchestrator.py
index 3841b4ba..3e6ffa65 100644
--- a/simulation/orchestration/tick_orchestrator.py
+++ b/simulation/orchestration/tick_orchestrator.py
@@ -84,6 +84,13 @@ class TickOrchestrator:
         if state.government and hasattr(state.government, "reset_tick_flow"):
             state.government.reset_tick_flow()
 
+        # LIFECYCLE FIX: Process Inter-Tick Queue (Lifecycle events from previous tick)
+        if state.inter_tick_queue:
+            count = len(state.inter_tick_queue)
+            state.logger.info(f"LIFECYCLE_QUEUE | Promoting {count} transactions from inter-tick queue.")
+            state.transactions.extend(state.inter_tick_queue)
+            state.inter_tick_queue.clear()
+
         # 1. Create the comprehensive state DTO for this tick
         sim_state = self._create_simulation_state_dto(injectable_sensory_dto)
 
diff --git a/tests/integration/test_lifecycle_cycle.py b/tests/integration/test_lifecycle_cycle.py
new file mode 100644
index 00000000..c5317dfa
--- /dev/null
+++ b/tests/integration/test_lifecycle_cycle.py
@@ -0,0 +1,152 @@
+import pytest
+from unittest.mock import MagicMock, patch, ANY
+from collections import deque
+from simulation.orchestration.tick_orchestrator import TickOrchestrator
+from simulation.models import Transaction
+from simulation.dtos.api import SimulationState
+from modules.system.api import DEFAULT_CURRENCY
+from simulation.world_state import WorldState
+
+class TestLifecycleCycle:
+    @pytest.fixture
+    def mock_world_state(self):
+        state = MagicMock(spec=WorldState)
+        state.time = 0
+        state.agents = {}
+        state.firms = []
+        state.households = []
+        state.markets = {}
+        # Important: use real lists for queues to track movement
+        state.transactions = []
+        state.inter_tick_queue = []
+        state.system_command_queue = []
+        state.god_command_queue = deque()
+        state.command_queue = MagicMock()
+        state.command_queue.empty.return_value = True
+
+        # Mocks
+        state.bank = MagicMock()
+        state.bank.get_assets_by_currency.return_value = {DEFAULT_CURRENCY: 0.0}
+
+        state.lifecycle_manager = MagicMock()
+        state.transaction_processor = MagicMock()
+
+        state.config_module = MagicMock()
+        state.logger = MagicMock()
+        state.tracker = MagicMock()
+        state.tracker.get_latest_indicators.return_value = {}
+
+        state.calculate_total_money.return_value = {DEFAULT_CURRENCY: 1000}
+        state.baseline_money_supply = 1000.0
+
+        state.inactive_agents = {}
+        state.effects_queue = []
+
+        # Missing attributes
+        state.stock_market = None
+        state.stock_tracker = None
+        state.goods_data = {}
+        state.ai_training_manager = None
+        state.ai_trainer = None
+        state.settlement_system = MagicMock()
+        state.taxation_system = MagicMock()
+        state.currency_holders = []
+        state.next_agent_id = 1
+        state.real_estate_units = []
+        state.stress_scenario_config = None
+        state.saga_orchestrator = MagicMock()
+        state.monetary_ledger = MagicMock()
+        state.shareholder_registry = MagicMock()
+        state.global_registry = MagicMock()
+        state.inequality_tracker = MagicMock()
+
+        state.technology_manager = MagicMock()
+        state.ma_manager = None
+        state.commerce_system = None
+        state.housing_system = MagicMock()
+        state.crisis_monitor = None
+        state.generational_wealth_audit = None
+        state.demographic_manager = None
+        state.immigration_manager = None
+        state.inheritance_manager = None
+        state.persistence_manager = None
+        state.analytics_system = None
+        state.firm_system = None
+        state.breeding_planner = None
+        state.finance_system = None
+        state.social_system = None
+        state.event_system = None
+        state.sensory_system = None
+        state.labor_market_analyzer = None
+        state.public_manager = None
+        state.dashboard_service = None
+        state.telemetry_exchange = None
+        state.judicial_system = None
+        state.escrow_agent = None
+        state.scenario_verifier = None
+
+        state.last_interest_rate = 0.05
+        state.inflation_buffer = deque()
+        state.unemployment_buffer = deque()
+        state.gdp_growth_buffer = deque()
+        state.wage_buffer = deque()
+        state.approval_buffer = deque()
+        state.last_avg_price_for_sma = 10.0
+        state.last_gdp_for_sma = 0.0
+
+        return state
+
+    @pytest.fixture
+    def orchestrator(self, mock_world_state):
+        processor = MagicMock()
+        return TickOrchestrator(mock_world_state, processor)
+
+    def test_lifecycle_transactions_processed_in_next_tick_strong_verify(self, orchestrator, mock_world_state):
+        # Capture processed transactions
+        processed_txs = []
+        def capture_txs(state, transactions):
+            # Iterate through the chain/iterable and capture items
+            tx_list = list(transactions)
+            processed_txs.extend(tx_list)
+            return []
+
+        mock_world_state.transaction_processor.execute.side_effect = capture_txs
+
+        # Setup
+        tx = Transaction(
+            buyer_id=1, seller_id=2, item_id="test", price=10.0, quantity=1,
+            market_id="test_market", transaction_type="test", time=0,
+            total_pennies=1000
+        )
+        mock_world_state.lifecycle_manager.execute.return_value = [tx]
+
+        # Mock dependencies
+        mock_world_state.social_system = MagicMock()
+        mock_world_state.sensory_system = MagicMock()
+        mock_world_state.government = MagicMock()
+        mock_world_state.government.get_assets_by_currency.return_value = {DEFAULT_CURRENCY: 0.0}
+        mock_world_state.government.get_monetary_delta.return_value = 0
+        mock_world_state.central_bank = MagicMock()
+        mock_world_state.central_bank.get_assets_by_currency.return_value = {DEFAULT_CURRENCY: 0.0}
+        mock_world_state.event_system = None
+        mock_world_state.persistence_manager = None
+
+        # === TICK 1 ===
+        orchestrator.run_tick()
+
+        # Verify NOT processed in Tick 1
+        assert tx not in processed_txs, "Transaction should NOT be processed in the same tick (Sacred Sequence)"
+        processed_txs.clear()
+
+        # Verify present in queue
+        assert tx in mock_world_state.inter_tick_queue, "Transaction should be in inter_tick_queue"
+
+        # Reset lifecycle manager return to ensure no new txs are generated in Tick 2
+        mock_world_state.lifecycle_manager.execute.return_value = []
+
+        # === TICK 2 ===
+        orchestrator.run_tick()
+
+        # Verify PROCESSED in Tick 2
+        assert tx in processed_txs, "Transaction from previous tick should be processed in current tick"
+        assert len(mock_world_state.inter_tick_queue) == 0, "Queue should be cleared"
