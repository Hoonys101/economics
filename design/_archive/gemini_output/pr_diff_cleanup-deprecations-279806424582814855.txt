diff --git a/communications/insights/cleanup-deprecations.md b/communications/insights/cleanup-deprecations.md
new file mode 100644
index 00000000..ed563ac6
--- /dev/null
+++ b/communications/insights/cleanup-deprecations.md
@@ -0,0 +1,55 @@
+# Insight: Cleanup Deprecated Code (Track B)
+
+## 1. Architectural Insights
+
+### TD-DEPR-GOV-TAX: Atomic Tax Collection
+Refactored `LaborTransactionHandler` to eliminate the use of `Government.collect_tax` (which wrapped `transfer` non-atomically).
+- **Before**: `transfer(wage)` -> if success -> `collect_tax(tax)`
+- **After**:
+    - For Firm Payer: `settle_atomic(debits=[Firm], credits=[Household, Government])`. This is a true atomic transaction bundling wage and tax.
+    - For Household Payer: `transfer(wage)` -> `settle_atomic(tax)`. This maintains the sequential nature required by fund availability but uses the new API.
+- **Cleanup**: The `Government.collect_tax` method has been removed entirely. Attempts to use it will raise `AttributeError`.
+
+### TD-DEPR-FACTORY: HouseholdFactory Standardization
+Refactored `DemographicManager` to use `simulation.factories.household_factory.HouseholdFactory` correctly.
+- **Fix**: The previous implementation was passing positional arguments blindly, resulting in type mismatches (`simulation` object passed as `new_id` int). Updated to use explicit keyword arguments (`parent=`, `new_id=`, `simulation=`).
+- **Cleanup**: Deleted the deprecated `modules/household/factory.py` which was an inconsistent duplicate.
+- **Integrity**: Initial asset transfer (birth gift) is now delegated to the Factory, ensuring encapsulation.
+
+### TD-DEPR-STOCK-DTO: StockOrder Removal
+Removed the legacy `StockOrder` class from `simulation/models.py`.
+- **Standardization**: All market orders must now use `CanonicalOrderDTO`.
+- **Adapter**: `tests/unit/test_market_adapter.py` was updated to remove legacy `StockOrder` input tests, while maintaining dictionary conversion tests for backward compatibility.
+
+## 2. Test Evidence
+
+### Government Tax Refactoring
+`pytest tests/integration/test_government_tax.py tests/unit/agents/test_government.py`
+
+```
+tests/integration/test_government_tax.py::TestGovernmentTax::test_record_revenue_delegation PASSED [  8%]
+tests/integration/test_government_tax.py::TestGovernmentTax::test_collect_tax_removed PASSED [ 16%]
+tests/unit/agents/test_government.py::test_calculate_income_tax_delegation PASSED [ 25%]
+tests/unit/agents/test_government.py::test_calculate_corporate_tax_delegation PASSED [ 33%]
+tests/unit/agents/test_government.py::test_collect_tax_removed PASSED [ 41%]
+tests/unit/agents/test_government.py::test_run_public_education_delegation PASSED [ 50%]
+tests/unit/agents/test_government.py::test_deficit_spending_allowed_within_limit PASSED [ 58%]
+tests/unit/agents/test_government.py::test_deficit_spending_blocked_if_bond_fails PASSED [ 66%]
+```
+
+### Market Adapter Refactoring
+`pytest tests/unit/test_market_adapter.py`
+
+```
+tests/unit/test_market_adapter.py::TestMarketAdapter::test_pass_through PASSED [ 75%]
+tests/unit/test_market_adapter.py::TestMarketAdapter::test_convert_dict_legacy_format PASSED [ 83%]
+tests/unit/test_market_adapter.py::TestMarketAdapter::test_convert_dict_canonical_format PASSED [ 91%]
+tests/unit/test_market_adapter.py::TestMarketAdapter::test_invalid_input PASSED [100%]
+```
+
+### Demographic Manager Refactoring
+`pytest tests/unit/systems/test_demographic_manager_newborn.py`
+
+```
+tests/unit/systems/test_demographic_manager_newborn.py::test_newborn_receives_initial_needs_from_config PASSED [100%]
+```
diff --git a/modules/finance/transaction/handlers/labor.py b/modules/finance/transaction/handlers/labor.py
index 87071f8f..2d42d7a2 100644
--- a/modules/finance/transaction/handlers/labor.py
+++ b/modules/finance/transaction/handlers/labor.py
@@ -71,21 +71,45 @@ class LaborTransactionHandler(ISpecializedTransactionHandler):
              sys_logger.warning("LaborTransactionHandler: Government does not implement ITaxCollector.")
 
         if tax_payer == "FIRM":
-            # Firm pays Wage to Household
-            success = settlement.transfer(buyer, seller, trade_value, f"labor_wage:{tx.transaction_type}")
-            if success and tax_amount > 0:
-                 # Then Firm pays Tax to Gov
-                 # Using collect_tax which should handle transfer and recording
-                if isinstance(government, ITaxCollector):
-                    government.collect_tax(tax_amount, "income_tax_firm", buyer, current_time)
+            # Firm pays Wage to Household AND Tax to Gov Atomically
+            credits = [(seller, trade_value, f"labor_wage:{tx.transaction_type}")]
+            if tax_amount > 0:
+                credits.append((government, tax_amount, "income_tax_firm"))
+
+            success = settlement.settle_atomic(
+                debit_agent=buyer,
+                credits_list=credits,
+                tick=current_time
+            )
+
+            if success and tax_amount > 0 and isinstance(government, ITaxCollector):
+                government.record_revenue({
+                    "success": True,
+                    "amount_collected": tax_amount,
+                    "tax_type": "income_tax_firm",
+                    "payer_id": buyer.id,
+                    "payee_id": government.id
+                })
         else:
             # Household pays tax (Withholding model)
             # Pay GROSS wage to household
             success = settlement.transfer(buyer, seller, trade_value, f"labor_wage_gross:{tx.transaction_type}")
             if success and tax_amount > 0:
                 # Then collect tax from household
-                if isinstance(government, ITaxCollector):
-                    government.collect_tax(tax_amount, "income_tax_household", seller, current_time)
+                tax_success = settlement.settle_atomic(
+                    debit_agent=seller,
+                    credits_list=[(government, tax_amount, "income_tax_household")],
+                    tick=current_time
+                )
+
+                if tax_success and isinstance(government, ITaxCollector):
+                    government.record_revenue({
+                        "success": True,
+                        "amount_collected": tax_amount,
+                        "tax_type": "income_tax_household",
+                        "payer_id": seller.id,
+                        "payee_id": government.id
+                    })
 
         if success and isinstance(seller, IIncomeTracker):
             seller.add_labor_income(trade_value)
diff --git a/modules/finance/transaction/handlers/protocols.py b/modules/finance/transaction/handlers/protocols.py
index a0fa3831..46faabff 100644
--- a/modules/finance/transaction/handlers/protocols.py
+++ b/modules/finance/transaction/handlers/protocols.py
@@ -17,9 +17,6 @@ class ITaxCollector(Protocol):
     def calculate_income_tax(self, income: int, deduction: int) -> int:
         ...
 
-    def collect_tax(self, amount: int, tax_type: str, payer: Any, current_tick: int) -> Any:
-        ...
-
     def record_revenue(self, data: Any) -> None:
         ...
 
diff --git a/modules/government/proxy.py b/modules/government/proxy.py
index ad596d62..4371980e 100644
--- a/modules/government/proxy.py
+++ b/modules/government/proxy.py
@@ -33,9 +33,3 @@ class GovernmentFiscalProxy(IFinancialAgent):
     @property
     def total_wealth(self) -> int:
         return self._government.total_wealth
-
-    def collect_tax(self, amount: float, tax_type: str, payer: Any, current_tick: int) -> TaxCollectionResult:
-        """
-        Proxies the tax collection request to the government.
-        """
-        return self._government.collect_tax(amount, tax_type, payer, current_tick)
diff --git a/modules/household/factory.py b/modules/household/factory.py
deleted file mode 100644
index 81e8ba63..00000000
--- a/modules/household/factory.py
+++ /dev/null
@@ -1,318 +0,0 @@
-from __future__ import annotations
-from typing import Optional, Dict, Any, List, TYPE_CHECKING
-import logging
-import random
-import copy
-
-from simulation.core_agents import Household
-from simulation.models import Talent
-from modules.simulation.api import AgentCoreConfigDTO, AgentStateDTO
-from modules.system.api import DEFAULT_CURRENCY
-from simulation.ai.api import Personality
-from modules.household.api import HouseholdFactoryContext, IHouseholdFactory
-
-logger = logging.getLogger(__name__)
-
-class HouseholdFactory:
-    """
-    Factory for creating Household agents.
-    Encapsulates creation logic, configuration setup, and initial state hydration.
-    """
-
-    def __init__(self, context: HouseholdFactoryContext):
-        self.context = context
-
-    def _create_base_household(
-        self,
-        agent_id: int,
-        initial_age: float,
-        gender: str,
-        initial_assets: int = 0,
-        generation: int = 0,
-        parent_id: Optional[int] = None,
-        spouse_id: Optional[int] = None,
-        personality: Optional[Personality] = None,
-        talent: Optional[Talent] = None,
-        decision_engine: Optional[Any] = None,
-        initial_needs: Optional[Dict[str, float]] = None
-    ) -> Household:
-        """
-        Internal method to create a fully initialized Household agent.
-        """
-        # 1. Config Setup (Used from context)
-        hh_config_dto = self.context.household_config_dto
-        core_config_module = self.context.core_config_module
-
-        # 2. Core Config
-        # Value Orientation: Try getting from engine, else config default
-        vo = "Growth"
-        if decision_engine and hasattr(decision_engine, 'value_orientation'):
-            vo = decision_engine.value_orientation
-        else:
-            vo = getattr(core_config_module, 'DEFAULT_VALUE_ORIENTATION', 'Growth')
-
-        # Get initial needs from config if not provided
-        default_initial_needs = getattr(core_config_module, "INITIAL_NEEDS", {})
-
-        core_config = AgentCoreConfigDTO(
-            id=agent_id,
-            name=f"Household_{agent_id}",
-            value_orientation=vo,
-            initial_needs=initial_needs if initial_needs else default_initial_needs.copy(),
-            logger=logger,
-            memory_interface=self.context.memory_system
-        )
-
-        # 3. Defaults if not provided
-        if talent is None:
-            talent = Talent(base_learning_rate=1.0, max_potential={})
-
-        if personality is None:
-            personality = random.choice(list(Personality))
-
-        # 4. Instantiate Household
-        # Note: We pass markets and goods_data from context
-        agent = Household(
-            core_config=core_config,
-            engine=decision_engine,
-            talent=talent,
-            goods_data=self.context.goods_data,
-            personality=personality,
-            config_dto=hh_config_dto,
-            loan_market=self.context.loan_market,
-            risk_aversion=1.0,
-            initial_age=initial_age,
-            gender=gender,
-            parent_id=parent_id,
-            generation=generation,
-            initial_assets_record=int(initial_assets)
-        )
-
-        # 5. Hydrate State (Assets)
-        # Note: Assets are not loaded directly via load_state to ensure SSoT integrity.
-        # Transfers must be handled by the caller (create_newborn, create_immigrant, etc.)
-        initial_state = AgentStateDTO(
-            assets={DEFAULT_CURRENCY: 0},
-            inventory={},
-            is_active=True
-        )
-        agent.load_state(initial_state)
-
-        # 6. Additional Initializations
-        if spouse_id:
-            agent.spouse_id = spouse_id
-
-        agent.education_level = 0
-        base_wage = getattr(core_config_module, "INITIAL_WAGE", 10.0)
-        agent.expected_wage = int(base_wage * 100) # Convert to pennies
-
-        # Inject dependencies
-        agent.decision_engine.markets = self.context.markets
-        agent.decision_engine.goods_data = self.context.goods_data
-        if hasattr(agent, 'settlement_system'):
-            agent.settlement_system = self.context.settlement_system
-
-        # Register with AI Training Manager
-        if self.context.ai_training_manager:
-            self.context.ai_training_manager.agents.append(agent)
-
-        return agent
-
-    def create_newborn(
-        self,
-        parent: Household,
-        new_id: int,
-        initial_assets: int, # This is the gift amount
-        current_tick: int
-    ) -> Household:
-        """
-        Creates a newborn household (child) from a parent.
-        Handles inheritance of traits (personality, talent, brain).
-        Enforces Zero-Sum integrity for initial assets (gift).
-        """
-        # 1. Demographics
-        initial_age = 0.0
-        gender = random.choice(["M", "F"])
-        generation = parent.generation + 1
-
-        # 2. Inheritance Logic (Talent, Personality)
-        child_talent = self._inherit_talent(parent.talent)
-        child_personality = self._inherit_personality(parent.personality)
-
-        # 3. Engine Creation (Brain)
-        new_decision_engine = self._create_decision_engine_for_newborn(parent, new_id)
-
-        # 4. Config
-        initial_needs = getattr(self.context.core_config_module, "NEWBORN_INITIAL_NEEDS", None)
-
-        # 5. Create Agent with 0 assets (to be funded via transfer)
-        child = self._create_base_household(
-            agent_id=new_id,
-            initial_age=initial_age,
-            gender=gender,
-            initial_assets=0,
-            generation=generation,
-            parent_id=parent.id,
-            spouse_id=None,
-            personality=child_personality,
-            talent=child_talent,
-            decision_engine=new_decision_engine,
-            initial_needs=initial_needs
-        )
-
-        # 6. Brain Inheritance (Weights)
-        if self.context.ai_training_manager:
-            self.context.ai_training_manager.inherit_brain(parent, child)
-        else:
-            logger.warning("AITrainingManager not found for brain inheritance.")
-
-        # 7. Zero-Sum Transfer of Gift
-        if initial_assets > 0:
-            # Transfer from Parent to Child
-            self.context.settlement_system.transfer(
-                sender=parent,
-                receiver=child,
-                amount=initial_assets,
-                transaction_type="BIRTH_GIFT",
-                tick=current_tick
-            )
-
-        return child
-
-    def create_immigrant(
-        self,
-        new_id: int,
-        current_tick: int,
-        initial_assets: int
-    ) -> Household:
-        """Creates a new household representing an immigrant."""
-        # Random demographics
-        age_range = getattr(self.context.core_config_module, "initial_household_age_range", (20, 60))
-        initial_age = random.uniform(*age_range)
-        gender = random.choice(["M", "F"])
-
-        # Logic for immigrant decision engine
-        engine = self._create_default_decision_engine(new_id)
-
-        immigrant = self._create_base_household(
-            agent_id=new_id,
-            initial_age=initial_age,
-            gender=gender,
-            initial_assets=initial_assets, # Record only
-            decision_engine=engine
-        )
-
-        # Transfer Assets (Minting / Import)
-        if initial_assets > 0:
-            if self.context.central_bank:
-                self.context.settlement_system.create_and_transfer(
-                    source_authority=self.context.central_bank,
-                    destination=immigrant,
-                    amount=int(initial_assets),
-                    reason="IMMIGRATION_GRANT",
-                    tick=current_tick
-                )
-            else:
-                logger.warning(f"CentralBank not found for immigrant {new_id}. Using direct deposit fallback.")
-                immigrant._deposit(int(initial_assets))
-
-        return immigrant
-
-    def create_initial_population(
-        self,
-        num_agents: int
-    ) -> List[Household]:
-        """Creates the initial population of households for the simulation."""
-        agents = []
-        mean_assets = int(getattr(self.context.core_config_module, "initial_household_assets_mean", 1000) * 100) # Pennies
-
-        for i in range(num_agents):
-            agent_id = i
-
-            assets = int(random.gauss(mean_assets, mean_assets * 0.2))
-            assets = max(0, assets)
-
-            age_range = getattr(self.context.core_config_module, "initial_household_age_range", (20, 60))
-            initial_age = random.uniform(*age_range)
-            gender = random.choice(["M", "F"])
-
-            engine = self._create_default_decision_engine(agent_id)
-
-            agent = self._create_base_household(
-                agent_id=agent_id,
-                initial_age=initial_age,
-                gender=gender,
-                initial_assets=assets,
-                decision_engine=engine
-            )
-
-            # Genesis Funding
-            if assets > 0:
-                if self.context.central_bank:
-                    self.context.settlement_system.create_and_transfer(
-                        source_authority=self.context.central_bank,
-                        destination=agent,
-                        amount=assets,
-                        reason="GENESIS_POPULATION",
-                        tick=0
-                    )
-                else:
-                    # Fallback for genesis if CB missing (unlikely in proper setup)
-                    agent._deposit(assets)
-
-            agents.append(agent)
-
-        return agents
-
-    def _inherit_talent(self, parent_talent: Talent) -> Talent:
-        """Inherit talent with mutation."""
-        new_talent = copy.deepcopy(parent_talent)
-        mutation_range = 0.1
-        new_talent.base_learning_rate *= random.uniform(1.0 - mutation_range, 1.0 + mutation_range)
-        return new_talent
-
-    def _inherit_personality(self, parent_personality: Personality) -> Personality:
-        """Inherit personality with potential mutation."""
-        if random.random() < getattr(self.context.core_config_module, "MITOSIS_MUTATION_PROBABILITY", 0.1):
-            return random.choice(list(Personality))
-        return parent_personality
-
-    def _create_decision_engine_for_newborn(self, parent: Household, agent_id: int) -> Any:
-        """Creates the decision engine for the newborn."""
-        return self._create_engine_logic(agent_id, parent_value_orientation=parent.value_orientation)
-
-    def _create_default_decision_engine(self, agent_id: int) -> Any:
-        return self._create_engine_logic(agent_id)
-
-    def _create_engine_logic(self, agent_id: int, parent_value_orientation: Optional[str] = None) -> Any:
-        newborn_engine_type = getattr(self.context.core_config_module, "NEWBORN_ENGINE_TYPE", "AIDriven")
-
-        if str(newborn_engine_type).upper() == "RULE_BASED":
-            from simulation.decisions.rule_based_household_engine import RuleBasedHouseholdDecisionEngine
-            return RuleBasedHouseholdDecisionEngine(
-                config_module=self.context.core_config_module,
-                logger=logger
-            )
-        else:
-            # AI Driven
-            from simulation.ai.household_ai import HouseholdAI
-            from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
-
-            base_ai_engine = None
-            if self.context.ai_training_manager:
-                # Use parent VO if available, else random or default
-                vo = parent_value_orientation or "Growth"
-                base_ai_engine = self.context.ai_training_manager.get_engine(vo)
-
-            new_ai = HouseholdAI(
-                agent_id=str(agent_id),
-                ai_decision_engine=base_ai_engine,
-            )
-
-            engine = AIDrivenHouseholdDecisionEngine(
-                ai_engine=new_ai,
-                config_module=self.context.core_config_module,
-                logger=logger
-            )
-            engine.loan_market = self.context.loan_market
-            return engine
diff --git a/scripts/verification/verify_integrity_v2.py b/scripts/verification/verify_integrity_v2.py
deleted file mode 100644
index 90291843..00000000
--- a/scripts/verification/verify_integrity_v2.py
+++ /dev/null
@@ -1,175 +0,0 @@
-import sys
-import os
-import logging
-from unittest.mock import MagicMock
-
-# Add project root to path
-sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../')))
-
-from simulation.systems.transaction_manager import TransactionManager
-from simulation.systems.registry import Registry
-from simulation.systems.accounting import AccountingSystem
-from simulation.systems.central_bank_system import CentralBankSystem
-from simulation.systems.settlement_system import SettlementSystem
-from simulation.systems.handlers import InheritanceHandler
-from simulation.models import Transaction
-from modules.system.constants import ID_CENTRAL_BANK
-from modules.system.api import DEFAULT_CURRENCY
-
-# Setup Logging
-logging.basicConfig(level=logging.INFO)
-logger = logging.getLogger("VERIFICATION")
-
-class MockWallet:
-    def __init__(self, agent):
-        self.agent = agent
-        self.owner_id = agent.id
-    def get_balance(self, currency=DEFAULT_CURRENCY):
-        return self.agent.assets
-    def add(self, amount, currency=DEFAULT_CURRENCY, memo=""):
-        pass
-    def subtract(self, amount, currency=DEFAULT_CURRENCY, memo=""):
-        pass
-    def get_all_balances(self):
-        return {DEFAULT_CURRENCY: self.agent.assets}
-
-def verify_zero_sum():
-    logger.info("Starting Zero-Sum Verification...")
-
-    # 1. Setup Systems
-    logger.info("Initializing Systems...")
-    settlement = SettlementSystem(logger=logger)
-    registry = Registry(logger=logger)
-    accounting = AccountingSystem(logger=logger)
-
-    # Mock Central Bank Agent
-    cb_agent = MagicMock()
-    cb_agent.id = ID_CENTRAL_BANK
-    cb_agent.assets = {"cash": 0.0} # Not used by Settlement check for CB
-
-    cb_system = CentralBankSystem(cb_agent, settlement, logger=logger)
-
-    handlers = {
-        "inheritance_distribution": InheritanceHandler()
-    }
-
-    config = MagicMock()
-    config.SALES_TAX_RATE = 0.0 # Simplify
-    config.INCOME_TAX_PAYER = "HOUSEHOLD"
-
-    tm = TransactionManager(
-        registry=registry,
-        accounting_system=accounting,
-        settlement_system=settlement,
-        central_bank_system=cb_system,
-        config=config,
-        handlers=handlers,
-        logger=logger,
-        escrow_agent=MagicMock()
-    )
-
-    # 2. Setup Agents
-    buyer = MagicMock()
-    buyer.id = 1
-    buyer.assets = 1000.0
-    # Mock withdraw/deposit
-    def b_withdraw(amt, currency=DEFAULT_CURRENCY): buyer.assets -= amt
-    def b_deposit(amt, currency=DEFAULT_CURRENCY): buyer.assets += amt
-    buyer.withdraw = b_withdraw
-    buyer.deposit = b_deposit
-    buyer.wallet = MockWallet(buyer)
-
-    seller = MagicMock()
-    seller.id = 2
-    seller.assets = 500.0
-    def s_withdraw(amt, currency=DEFAULT_CURRENCY): seller.assets -= amt
-    def s_deposit(amt, currency=DEFAULT_CURRENCY): seller.assets += amt
-    seller.withdraw = s_withdraw
-    seller.deposit = s_deposit
-    seller.wallet = MockWallet(seller)
-
-    # Government (for tax)
-    gov = MagicMock()
-    gov.id = "GOV"
-    gov.assets = 0.0
-    def g_deposit(amt, currency=DEFAULT_CURRENCY): gov.assets += amt
-    gov.deposit = g_deposit
-    gov.wallet = MockWallet(gov)
-    # Mock collect_tax to just deposit
-    def collect_tax(amount, type, payer, time):
-        # We need to transfer from payer to gov
-        if settlement.transfer(payer, gov, amount, "tax"):
-            return {'success': True}
-        return {'success': False}
-    gov.collect_tax = collect_tax
-
-    # State
-    state = MagicMock()
-    state.agents = {1: buyer, 2: seller, "GOV": gov}
-    state.government = gov
-    state.market_data = {}
-    state.time = 0
-    state.inactive_agents = {}
-
-    # 3. Execute Transaction (Goods Trade)
-    logger.info("Executing Goods Trade (100.0)...")
-    tx = Transaction(
-        buyer_id=1,
-        seller_id=2,
-        item_id="item_x",
-        price=10.0,
-        quantity=10.0,
-        market_id="goods",
-        transaction_type="goods",
-        time=0
-    , total_pennies=10000)
-    state.transactions = [tx]
-
-    initial_total = buyer.assets + seller.assets + gov.assets
-    tm.execute(state)
-    final_total = buyer.assets + seller.assets + gov.assets
-
-    logger.info(f"Buyer Assets: {settlement.get_balance(buyer.id)} (Expected 900.0)")
-    logger.info(f"Seller Assets: {settlement.get_balance(seller.id)} (Expected 600.0)")
-    logger.info(f"Gov Assets: {settlement.get_balance(gov.id)} (Expected 0.0)")
-    logger.info(f"Total Money: {initial_total} -> {final_total}")
-
-    if abs(initial_total - final_total) > 0.0001:
-        logger.error("ZERO-SUM VIOLATION!")
-        sys.exit(1)
-
-    assert settlement.get_balance(buyer.id) == 900.0
-    assert settlement.get_balance(seller.id) == 600.0
-
-    # 4. Execute Taxed Trade
-    logger.info("Executing Taxed Trade (100.0 + 10% Tax)...")
-    config.SALES_TAX_RATE = 0.1
-    tx2 = Transaction(
-        buyer_id=1,
-        seller_id=2,
-        item_id="item_y",
-        price=10.0,
-        quantity=10.0,
-        market_id="goods",
-        transaction_type="goods",
-        time=1
-    , total_pennies=10000)
-    state.transactions = [tx2]
-
-    # Recalculate initial total for taxed trade test segment if needed, 
-    # but here we just check final state.
-    tm.execute(state)
-    final_total_taxed = settlement.get_balance(buyer.id) + settlement.get_balance(seller.id) + settlement.get_balance(gov.id)
-
-    logger.info(f"Buyer Assets: {settlement.get_balance(buyer.id)} (Expected 790.0 - 100 trade - 10 tax)")
-    logger.info(f"Seller Assets: {settlement.get_balance(seller.id)} (Expected 700.0 - +100 trade)")
-    logger.info(f"Gov Assets: {settlement.get_balance(gov.id)} (Expected 10.0 - +10 tax)")
-
-    assert settlement.get_balance(buyer.id) == 790.0
-    assert settlement.get_balance(seller.id) == 700.0
-    assert settlement.get_balance(gov.id) == 10.0
-
-    logger.info("VERIFICATION SUCCESSFUL")
-
-if __name__ == "__main__":
-    verify_zero_sum()
diff --git a/simulation/agents/government.py b/simulation/agents/government.py
index 800159ad..3191e4ce 100644
--- a/simulation/agents/government.py
+++ b/simulation/agents/government.py
@@ -224,35 +224,6 @@ class Government(ICurrencyHolder, IFinancialAgent, ISensoryDataProvider):
     def process_monetary_transactions(self, transactions: List[Transaction]):
         self.monetary_ledger.process_transactions(transactions)
 
-    def collect_tax(self, amount: int, tax_type: str, payer: Any, current_tick: int) -> "TaxCollectionResult":
-        warnings.warn(
-            "Government.collect_tax is deprecated. Use settlement.settle_atomic and government.record_revenue() instead.",
-            DeprecationWarning,
-            stacklevel=2
-        )
-        payer_id = payer.id if hasattr(payer, 'id') else str(payer)
-        if not self.settlement_system:
-            logger.error("Government has no SettlementSystem linked. Cannot collect tax.")
-            return {
-                "success": False,
-                "amount_collected": 0,
-                "tax_type": tax_type,
-                "payer_id": payer_id,
-                "payee_id": self.id,
-                "error_message": "No SettlementSystem linked"
-            }
-        success = self.settlement_system.transfer(payer, self, amount, f"{tax_type} collection")
-        result = {
-            "success": bool(success),
-            "amount_collected": amount if success else 0,
-            "tax_type": tax_type,
-            "payer_id": payer_id,
-            "payee_id": self.id,
-            "error_message": None if success else "Transfer failed"
-        }
-        self.record_revenue(result)
-        return result
-
     def record_revenue(self, result: "TaxCollectionResult"):
         self.tax_service.record_revenue(result)
 
diff --git a/simulation/models.py b/simulation/models.py
index 0b0a07c3..58d9d0a8 100644
--- a/simulation/models.py
+++ b/simulation/models.py
@@ -27,25 +27,6 @@ class Transaction:
     metadata: Optional[Dict[str, Any]] = None  # WO-109: Metadata for side-effects
 
 
-@dataclass
-class StockOrder:
-    """
-    DEPRECATED: Use CanonicalOrderDTO instead.
-    Legacy DTO for Stock Market orders. Will be removed in Phase 10.
-    """
-
-    agent_id: int          # 주문 제출자 ID
-    order_type: str        # "BUY" or "SELL"
-    firm_id: int           # 대상 기업 ID
-    quantity: float        # 주문 수량
-    price: int             # Changed from float to int (pennies)
-    market_id: str = "stock_market"
-    id: str = field(default_factory=lambda: str(uuid.uuid4()), init=False)
-
-    def __post_init__(self):
-        warnings.warn("StockOrder is deprecated. Use CanonicalOrderDTO instead.", DeprecationWarning, stacklevel=2)
-
-
 @dataclass
 class Share:
     """주식 보유 정보를 담는 데이터 클래스"""
diff --git a/simulation/systems/demographic_manager.py b/simulation/systems/demographic_manager.py
index 076b3024..00102003 100644
--- a/simulation/systems/demographic_manager.py
+++ b/simulation/systems/demographic_manager.py
@@ -162,7 +162,14 @@ class DemographicManager(IDemographicManager):
                     )
                     self.household_factory = HouseholdFactory(context)
 
-                child = self.household_factory.create_newborn(parent, simulation, child_id)
+                # Pass explicit keyword arguments to match factory signature
+                child = self.household_factory.create_newborn(
+                    parent=parent,
+                    new_id=child_id,
+                    initial_assets=initial_gift_pennies,
+                    current_tick=getattr(simulation, 'time', 0),
+                    simulation=simulation
+                )
                 
                 # Update parent linkage
                 parent.children_ids.append(child_id)
@@ -172,13 +179,6 @@ class DemographicManager(IDemographicManager):
                 
                 new_children.append(child)
 
-                if initial_gift_pennies > 0:
-                    settlement = self.settlement_system or getattr(simulation, "settlement_system", None)
-                    if settlement:
-                         settlement.transfer(parent, child, initial_gift_pennies, "BIRTH_GIFT")
-                    else:
-                         self.logger.error("BIRTH_ERROR | SettlementSystem not found.")
-
                 self.logger.info(f"BIRTH | Parent {parent.id} -> Child {child.id}")
             except Exception as e:
                 self.logger.error(f"BIRTH_FAILED | {e}")
diff --git a/tests/integration/test_government_tax.py b/tests/integration/test_government_tax.py
index 4eb1ee5d..fdc3a395 100644
--- a/tests/integration/test_government_tax.py
+++ b/tests/integration/test_government_tax.py
@@ -15,11 +15,19 @@ class TestGovernmentTax:
         config.TAX_BRACKETS = [] # Add this to avoid error in TaxAgency init if it checks
 
         gov = Government(id=1, initial_assets=1000.0, config_module=config)
-        gov.tax_agency = MagicMock()
+        # Mocking internals for isolation
+        gov.tax_service = MagicMock()
         gov.settlement_system = MagicMock()
+
+        # We need to mock get_total_collected_tax because it's a property that calls tax_service
+        gov.tax_service.get_total_collected_tax.return_value = {"USD": 0.0}
+        gov.tax_service.get_revenue_this_tick.return_value = {"USD": 0.0}
+        gov.tax_service.get_tax_revenue.return_value = {}
+
         return gov
 
-    def test_record_revenue_success(self, government):
+    def test_record_revenue_delegation(self, government):
+        """Test that Government.record_revenue delegates to TaxService."""
         # Arrange
         result: TaxCollectionResult = {
             "success": True,
@@ -29,74 +37,14 @@ class TestGovernmentTax:
             "payee_id": 1,
             "error_message": None
         }
-        from modules.system.api import DEFAULT_CURRENCY
-        # Snapshot initial values (dicts)
-        initial_total = government.total_collected_tax.get(DEFAULT_CURRENCY, 0.0)
-        initial_revenue = government.revenue_this_tick.get(DEFAULT_CURRENCY, 0.0)
-
-        # Act
-        government.record_revenue(result)
-
-        # Assert
-        assert government.total_collected_tax[DEFAULT_CURRENCY] == initial_total + 100.0
-        assert government.revenue_this_tick[DEFAULT_CURRENCY] == initial_revenue + 100.0
-        assert government.tax_revenue["income_tax"] == 100.0
-
-    def test_record_revenue_failure(self, government):
-        # Arrange
-        result: TaxCollectionResult = {
-            "success": False,
-            "amount_collected": 0.0,
-            "tax_type": "income_tax",
-            "payer_id": 101,
-            "payee_id": 1,
-            "error_message": "Insufficient funds"
-        }
-        initial_total = government.total_collected_tax
 
         # Act
         government.record_revenue(result)
 
         # Assert
-        assert government.total_collected_tax == initial_total
-        assert "income_tax" not in government.tax_revenue
+        government.tax_service.record_revenue.assert_called_once_with(result)
 
-    def test_collect_tax_legacy(self, government):
-        # Arrange
-        payer = MagicMock()
-        payer.id = 101
-        amount = 50.0
-        tax_type = "wealth_tax"
-        current_tick = 10
-
-        government.settlement_system.transfer.return_value = True
-
-        # Act
-        with pytest.warns(DeprecationWarning, match="Government.collect_tax is deprecated"):
-            result = government.collect_tax(amount, tax_type, payer, current_tick)
-
-        # Assert
-        government.settlement_system.transfer.assert_called_once_with(
-            payer, government, amount, f"{tax_type} collection"
-        )
-
-        from modules.system.api import DEFAULT_CURRENCY
-        assert result["success"] is True
-        assert result["amount_collected"] == amount
-        assert result["tax_type"] == tax_type
-        # Verify total collected tax (dict)
-        assert government.total_collected_tax[DEFAULT_CURRENCY] == 50.0 # Should have called record_revenue internally
-
-    def test_collect_tax_no_settlement_system(self, government):
-        # Arrange
-        government.settlement_system = None
-        payer = MagicMock()
-        payer.id = 101
-
-        # Act
-        with pytest.warns(DeprecationWarning):
-            result = government.collect_tax(100.0, "tax", payer, 1)
-
-        # Assert
-        assert result["success"] is False
-        assert result["error_message"] == "No SettlementSystem linked"
+    def test_collect_tax_removed(self, government):
+        """Verify that collect_tax is removed."""
+        with pytest.raises(AttributeError):
+            government.collect_tax(100, "test", MagicMock(), 1)
diff --git a/tests/unit/agents/test_government.py b/tests/unit/agents/test_government.py
index 0a443758..3428aab6 100644
--- a/tests/unit/agents/test_government.py
+++ b/tests/unit/agents/test_government.py
@@ -87,31 +87,11 @@ def test_calculate_corporate_tax_delegation(government_setup):
         env["government"].corporate_tax_rate # Should pass the current rate (0.25)
     )
 
-def test_collect_tax_delegation(government_setup):
-    """Test if collect_tax uses SettlementSystem and TaxService.record_revenue."""
+def test_collect_tax_removed(government_setup):
+    """Verify that collect_tax is removed."""
     env = government_setup
-    amount = 1000
-    tax_type = 'income'
-    source_id = 101
-    current_tick = 50
-
-    # Ensure settlement_system is present
-    env["government"].settlement_system = Mock()
-    env["government"].settlement_system.transfer.return_value = True
-
-    env["government"].collect_tax(amount, tax_type, source_id, current_tick)
-
-    # Note: Government.collect_tax calls settlement_system.transfer(payer, self, amount, memo)
-    env["government"].settlement_system.transfer.assert_called_once_with(
-        source_id,
-        env["government"],
-        amount,
-        f"{tax_type} collection"
-    )
-
-    # And delegates recording to TaxService
-    env["mock_tax_service"].record_revenue.assert_called_once()
-    assert env["mock_tax_service"].record_revenue.call_args[0][0]['amount_collected'] == amount
+    with pytest.raises(AttributeError):
+        env["government"].collect_tax(100, "test", Mock(), 1)
 
 def test_run_public_education_delegation(government_setup):
     """Test if run_public_education delegates to MinistryOfEducation."""
diff --git a/tests/unit/systems/test_demographic_manager_newborn.py b/tests/unit/systems/test_demographic_manager_newborn.py
index 5439ada0..1d5bf0f7 100644
--- a/tests/unit/systems/test_demographic_manager_newborn.py
+++ b/tests/unit/systems/test_demographic_manager_newborn.py
@@ -187,11 +187,14 @@ def test_newborn_receives_initial_needs_from_config(mock_config, mock_simulation
     assert child.parent_id == parent_agent.id
     assert child.age == 0.0
 
-    # Verify asset transfer happened
+    # Verify asset transfer delegation
     expected_gift = parent_agent.assets * 0.1
-    # Check if transfer was called on the mock simulation's settlement system
-    # Since we didn't inject into manager.settlement_system in this test (it's None),
-    # the manager falls back to simulation.settlement_system (which is mock_simulation.settlement_system)
-    mock_simulation.settlement_system.transfer.assert_called_once_with(
-        parent_agent, child, expected_gift, "BIRTH_GIFT"
+    # DemographicManager delegates transfer to factory via initial_assets arg
+    # Note: next_agent_id was 101, then incremented to 102. The call used 101.
+    mock_factory.create_newborn.assert_called_once_with(
+        parent=parent_agent,
+        new_id=101,
+        initial_assets=int(expected_gift),
+        current_tick=mock_simulation.time,
+        simulation=mock_simulation
     )
diff --git a/tests/unit/test_market_adapter.py b/tests/unit/test_market_adapter.py
index f60ca172..69a5effa 100644
--- a/tests/unit/test_market_adapter.py
+++ b/tests/unit/test_market_adapter.py
@@ -1,7 +1,6 @@
 import pytest
 from dataclasses import dataclass
 from modules.market.api import CanonicalOrderDTO, convert_legacy_order_to_canonical
-from simulation.models import StockOrder
 
 class TestMarketAdapter:
 
@@ -10,18 +9,6 @@ class TestMarketAdapter:
         converted = convert_legacy_order_to_canonical(dto)
         assert converted is dto
 
-    def test_convert_stock_order(self):
-        legacy = StockOrder(agent_id=1, order_type='SELL', firm_id=100, quantity=5.0, price=45.0)
-        converted = convert_legacy_order_to_canonical(legacy)
-        assert isinstance(converted, CanonicalOrderDTO)
-        assert converted.agent_id == 1
-        assert converted.side == 'SELL'
-        assert converted.item_id == 'stock_100'
-        assert converted.quantity == 5.0
-        assert converted.price_limit == 45.0
-        assert converted.price_pennies == 4500
-        assert converted.market_id == 'stock_market'
-
     def test_convert_dict_legacy_format(self):
         legacy_dict = {'agent_id': 2, 'order_type': 'BUY', 'firm_id': 200, 'quantity': 20.0, 'price': 60.0, 'market_id': 'stock_market'}
         converted = convert_legacy_order_to_canonical(legacy_dict)
