diff --git a/communications/insights/WO-HousingRefactor.md b/communications/insights/WO-HousingRefactor.md
new file mode 100644
index 0000000..b8c5b83
--- /dev/null
+++ b/communications/insights/WO-HousingRefactor.md
@@ -0,0 +1,26 @@
+# Mission Insight Report: WO-HousingRefactor
+
+## Technical Debt & Architectural Gaps
+
+### 1. Registry vs. Handler Responsibility
+The original specification mandates that the `TransactionManager` calls `Registry.update_ownership` to handle state changes (ownership, mortgage ID). However, the current `TransactionProcessor` implementation (the acting manager) does **not** invoke the `Registry` in its execution loop. It only delegates to the specific `ITransactionHandler`.
+
+**Consequence:**
+To ensure functionality, the `HousingTransactionHandler` had to implement `_apply_housing_effects` locally, duplicating the logic found in `Registry._handle_housing_registry`. This violates the Single Responsibility Principle (SRP) but was necessary to ensure the transaction actually updates the simulation state.
+
+**Recommendation:**
+Refactor `TransactionProcessor` to explicitly call `Registry.update_ownership` after a successful handler execution, or officially deprecate the `Registry`'s update methods in favor of handler-encapsulated logic (as seen in `GoodsTransactionHandler`).
+
+### 2. Bank Loan Disbursement Logic
+The draft specification assumed `Bank.create_loan` (implemented as `grant_loan`) would allow directing funds immediately to Escrow. However, the existing `Bank.grant_loan` implementation automatically credits the loan principal to the **borrower's deposit account**.
+
+**Adaptation:**
+The `HousingTransactionHandler` saga was adapted to transfer the loan proceeds from the `Buyer` (who received the funds from the bank) to `Escrow`, rather than a direct Bank->Escrow transfer. This maintains financial integrity (zero-sum) but differs slightly from the idealized flow in the spec.
+
+### 3. Missing Mortgage ID in Registry
+The existing `Registry._handle_housing_registry` did not account for `mortgage_id` updates. This was patched in `simulation/systems/registry.py` to check `tx.metadata` for the ID.
+
+## Verification
+- Unit tests (`tests/market/test_housing_transaction_handler.py`) verify the Saga pattern, including compensation (rollback) logic for failures at Down Payment, Mortgage, or Disbursement stages.
+- Registry tests (`tests/systems/test_registry_housing.py`) confirm the `mortgage_id` update logic works when invoked.
+- Integration tests (`tests/unit/test_transaction_processor.py`) confirm the new handler is correctly registered and dispatched.
diff --git a/config/economy_params.yaml b/config/economy_params.yaml
index b9c268c..5833fa0 100644
--- a/config/economy_params.yaml
+++ b/config/economy_params.yaml
@@ -37,3 +37,10 @@ max_willingness_to_pay_multiplier: 2.5
 # WO-157: Code Blue - Dynamic Pricing
 sale_timeout_ticks: 20
 dynamic_price_reduction_factor: 0.95
+
+# ----------------------------------------------------------------------
+# Housing Market Configuration
+# ----------------------------------------------------------------------
+housing:
+  max_ltv_ratio: 0.8
+  mortgage_term_ticks: 300
diff --git a/modules/market/api.py b/modules/market/api.py
index 2f36208..65d0daf 100644
--- a/modules/market/api.py
+++ b/modules/market/api.py
@@ -1,7 +1,12 @@
 from dataclasses import dataclass, field
-from typing import Optional, Dict, Any
+from typing import Optional, Dict, Any, TypedDict, Protocol, TYPE_CHECKING
 import uuid
 
+if TYPE_CHECKING:
+    from simulation.dtos.api import SimulationState
+    from simulation.models import Transaction
+    from simulation.core_agents import Household
+
 @dataclass(frozen=True)
 class OrderDTO:
     """Standardized Market Order Data Transfer Object.
@@ -32,3 +37,35 @@ class OrderDTO:
     def order_type(self) -> str:
         """Alias for legacy compatibility during migration."""
         return self.side
+
+# --- Data Transfer Objects (DTOs) ---
+
+class HousingConfigDTO(TypedDict):
+    """Configuration parameters for housing market transactions."""
+    max_ltv_ratio: float
+    mortgage_term_ticks: int
+    # Note: Interest rate is handled by the banking/lending system config
+
+# --- Interfaces ---
+
+class ISpecializedTransactionHandler(Protocol):
+    """
+    Interface for handlers that manage specific, complex transaction types.
+    This is a pre-existing interface that we will implement.
+    """
+    def handle(
+        self,
+        tx: "Transaction",
+        buyer: "Household",
+        seller: Any, # Can be Household or Firm
+        state: "SimulationState"
+    ) -> bool:
+        """
+        Executes the specialized transaction logic.
+        Returns True on success, False on failure.
+        """
+        ...
+
+class IHousingTransactionHandler(ISpecializedTransactionHandler, Protocol):
+    """Explicit protocol for the housing transaction handler."""
+    ...
diff --git a/modules/market/handlers/housing_transaction_handler.py b/modules/market/handlers/housing_transaction_handler.py
new file mode 100644
index 0000000..496726c
--- /dev/null
+++ b/modules/market/handlers/housing_transaction_handler.py
@@ -0,0 +1,273 @@
+from typing import Any, Optional, Tuple, Dict
+import logging
+from simulation.systems.api import ITransactionHandler, TransactionContext
+from simulation.models import Transaction
+from modules.market.api import IHousingTransactionHandler, HousingConfigDTO
+from modules.finance.api import BorrowerProfileDTO
+from modules.system.escrow_agent import EscrowAgent
+from simulation.core_agents import Household
+from simulation.firms import Firm
+
+logger = logging.getLogger(__name__)
+
+class HousingTransactionHandler(ITransactionHandler, IHousingTransactionHandler):
+    """
+    Handles 'housing' market transactions using the Saga pattern.
+    Orchestrates atomic settlement involving Buyer, Seller, Bank, and Escrow.
+    """
+
+    def handle(self, tx: Transaction, buyer: Any, seller: Any, context: TransactionContext) -> bool:
+        """
+        Executes the housing transaction saga:
+        1. Validation
+        2. Down Payment (Buyer -> Escrow)
+        3. Mortgage Creation (Bank -> Loan)
+        4. Loan Disbursement (Bank -> Escrow)
+        5. Final Settlement (Escrow -> Seller)
+        """
+        # 1. Initialization & Validation
+        if not buyer or not seller:
+            context.logger.error(f"HOUSING | Invalid participants. Buyer: {buyer}, Seller: {seller}")
+            return False
+
+        # Find Escrow Agent
+        escrow_agent = next((a for a in context.agents.values() if isinstance(a, EscrowAgent)), None)
+        if not escrow_agent:
+            context.logger.critical("HOUSING | Escrow Agent not found in simulation agents.")
+            return False
+
+        # Parse Unit
+        try:
+            unit_id = int(tx.item_id.split("_")[1])
+            unit = next((u for u in context.real_estate_units if u.id == unit_id), None)
+            if not unit:
+                context.logger.error(f"HOUSING | Unit {unit_id} not found.")
+                return False
+        except (IndexError, ValueError):
+            context.logger.error(f"HOUSING | Invalid item_id format: {tx.item_id}")
+            return False
+
+        # Config
+        housing_config = getattr(context.config_module, "housing", {})
+        # Fallback defaults if config is missing (safety)
+        max_ltv = housing_config.get("max_ltv_ratio", 0.8)
+        mortgage_term = housing_config.get("mortgage_term_ticks", 300)
+
+        # Interest Rate (Bank Config or Global)
+        # Using context.config_module.bank_defaults if available or context.bank.base_rate logic?
+        # Bank.grant_loan takes interest_rate.
+        # We should query the bank for current rate or use config.
+        mortgage_rate = getattr(context.config_module, "MORTGAGE_INTEREST_RATE", 0.05) # Legacy/Global config fallback
+        if context.bank:
+             # Ideally bank has a mortgage rate product, but for now we use base rate + spread?
+             # Or stick to the config constant if it exists.
+             pass
+
+        sale_price = tx.price * tx.quantity
+        loan_amount = 0.0
+        down_payment = sale_price
+
+        # Determine Mortgage Eligibility
+        # Only Households get mortgages usually.
+        is_household = isinstance(buyer, Household)
+        use_mortgage = is_household and context.bank is not None
+
+        if use_mortgage:
+            loan_amount = sale_price * max_ltv
+            down_payment = sale_price - loan_amount
+
+        # Check Buyer Funds for Down Payment
+        if buyer.assets < down_payment:
+            context.logger.info(f"HOUSING | Buyer {buyer.id} insufficient funds for down payment {down_payment:.2f}")
+            return False
+
+        # 2. Saga Step A: Secure Down Payment (Buyer -> Escrow)
+        memo_down = f"escrow_hold:down_payment:{tx.item_id}"
+        if not context.settlement_system.transfer(buyer, escrow_agent, down_payment, memo_down, tick=context.time):
+            context.logger.warning(f"HOUSING | Failed to secure down payment from {buyer.id}")
+            return False
+
+        # --- Compensation Logic Needed from here ---
+
+        loan_id = None
+        new_loan_dto = None
+
+        try:
+            # 3. Saga Step B: Create Mortgage (if applicable)
+            if use_mortgage:
+                borrower_profile = self._create_borrower_profile(buyer, sale_price, context)
+                # Estimate due tick
+                due_tick = context.time + mortgage_term
+
+                grant_result = context.bank.grant_loan(
+                    borrower_id=str(buyer.id),
+                    amount=loan_amount,
+                    interest_rate=mortgage_rate,
+                    due_tick=due_tick,
+                    borrower_profile=borrower_profile
+                )
+
+                if not grant_result:
+                    context.logger.warning(f"HOUSING | Bank rejected mortgage for {buyer.id}")
+                    # Compensate Step A
+                    context.settlement_system.transfer(escrow_agent, buyer, down_payment, "escrow_reversal:loan_rejected", tick=context.time)
+                    return False
+
+                new_loan_dto, credit_tx = grant_result
+                loan_id = new_loan_dto.loan_id
+
+                # Append credit creation tx to queue
+                if credit_tx:
+                    context.transaction_queue.append(credit_tx)
+
+                # 4. Saga Step C: Disburse Loan (Bank -> Escrow)
+                # Note: Bank.grant_loan created a deposit for borrower.
+                # We need to transfer that deposit (or newly minted funds if Bank logic differs) to Escrow.
+                # Actually, grant_loan creates a deposit for the borrower.
+                # So the borrower now has `loan_amount` in their bank account (or existing assets).
+                # Wait, `grant_loan` calls `deposit_from_customer`. So Buyer has the money.
+                # BUT the Spec says "Disburse Loan Principal to Escrow".
+                # If the money is in Buyer's account, we must transfer from Buyer to Escrow?
+                # OR does the Bank transfer directly?
+                # The `grant_loan` implementation adds to `borrower_id` deposit.
+                # So `Buyer` now has the funds.
+                # The Spec Pseudo-code says: `settlement_system.transfer(bank, escrow_agent, ...)`
+                # This implies the loan funds come from Bank directly to Escrow.
+                # But current `grant_loan` implementation puts it in Buyer's deposit.
+                # So we should transfer from Buyer (using the loan funds) to Escrow?
+                # OR we treat `grant_loan` as just booking the loan, and the disbursement happens differently?
+                # `grant_loan` creates a Deposit.
+                # If I transfer from Bank to Escrow, I am double counting if I also keep the deposit for Buyer.
+                # Current `Bank.grant_loan` logic: `self.deposit_from_customer(bid_int, amount)`.
+                # This increases Buyer's deposit balance.
+                # So for the Saga "Disburse to Escrow", I should transfer from Buyer (using the newly acquired funds) to Escrow?
+                # Or maybe the Spec implies `grant_loan` shouldn't deposit to Buyer immediately but to Escrow?
+                # I cannot change `Bank.grant_loan`.
+                # So, effectively, the "Disbursement" step is moving the loan proceeds from Buyer's account (where Bank put them) to Escrow.
+                # Step C Modified: Transfer Loan Proceeds (Buyer -> Escrow).
+                # Wait, if I do that, the "Bank -> Escrow" semantic is lost.
+                # But financially it is same: Bank -> Buyer -> Escrow.
+                # The Spec says `transfer(bank, escrow_agent, ...)`. This would imply Bank sends cash to Escrow.
+                # If `grant_loan` already gave money to Buyer, and then we do Bank->Escrow, Bank pays twice?
+                # Yes.
+                # So I must transfer from Buyer -> Escrow.
+                # BUT wait, the Spec says "Disburse Loan Principal to Escrow... transfer(bank, escrow_agent)".
+                # This suggests the Spec assumes `create_loan` does NOT credit the buyer immediately, or the handler controls it.
+                # But existing `Bank.grant_loan` DOES credit the buyer.
+                # To align with existing Bank logic AND the goal (funds in Escrow):
+                # We should transfer the loan amount from Buyer to Escrow.
+                # The "Source" of funds is the Bank (via the loan), but the intermediate hop is the Buyer's account.
+
+                memo_disburse = f"escrow_hold:loan_proceeds:{tx.item_id}"
+                if not context.settlement_system.transfer(buyer, escrow_agent, loan_amount, memo_disburse, tick=context.time):
+                    context.logger.critical(f"HOUSING | Failed to move loan proceeds to escrow for {buyer.id}")
+                    # Compensate: Void Loan, Return Down Payment
+                    self._void_loan_safely(context, loan_id)
+                    context.settlement_system.transfer(escrow_agent, buyer, down_payment, "escrow_reversal:disbursement_failed", tick=context.time)
+                    return False
+
+            # 5. Saga Step D: Final Settlement (Escrow -> Seller)
+            # Escrow now holds `down_payment + loan_amount` (which equals `sale_price`).
+            memo_settle = f"final_settlement:{tx.item_id}"
+
+            # Check if Seller is Government (Tax Collection path?)
+            # Usually Housing Sale is Asset Transfer.
+            # If Seller is Government, we transfer to Government.
+
+            if not context.settlement_system.transfer(escrow_agent, seller, sale_price, memo_settle, tick=context.time):
+                context.logger.critical(f"HOUSING | CRITICAL: Failed to pay seller {seller.id} from escrow.")
+                # Compensate: This is messy.
+                # 1. Return Loan Proceeds to Buyer (so we can void loan? No, void loan expects deposit reversal).
+                # If we return to Buyer, we can void loan.
+                if use_mortgage:
+                    context.settlement_system.transfer(escrow_agent, buyer, loan_amount, "reversal:seller_payment_failed", tick=context.time)
+                    self._void_loan_safely(context, loan_id)
+
+                # 2. Return Down Payment
+                context.settlement_system.transfer(escrow_agent, buyer, down_payment, "reversal:seller_payment_failed", tick=context.time)
+                return False
+
+            # Success!
+            # 6. Apply Side Effects
+            self._apply_housing_effects(unit, buyer, seller, loan_id, context)
+
+            # Store mortgage_id in metadata for Registry/Observer
+            if loan_id:
+                if not tx.metadata: tx.metadata = {}
+                tx.metadata["mortgage_id"] = loan_id
+
+            context.logger.info(f"HOUSING | Success: Unit {unit.id} sold to {buyer.id}. Price: {sale_price}")
+            return True
+
+        except Exception as e:
+            context.logger.error(f"HOUSING | Unexpected error: {e}", exc_info=True)
+            # Generic Compensation Attempt (Best Effort)
+            try:
+                # If money in escrow, try to return to buyer?
+                escrow_bal = context.bank.get_balance(str(escrow_agent.id)) if context.bank else 0 # Approximate
+                # This is hard to know exactly how much of escrow balance is ours.
+                # We rely on specific rollback blocks above.
+                pass
+            except:
+                pass
+            return False
+
+    def _create_borrower_profile(self, buyer: Household, trade_value: float, context: TransactionContext) -> BorrowerProfileDTO:
+        gross_income = 0.0
+        if hasattr(buyer, "current_wage"):
+             # Estimate monthly income
+             work_hours = getattr(context.config_module, "WORK_HOURS_PER_DAY", 8.0)
+             ticks_per_year = getattr(context.config_module, "TICKS_PER_YEAR", 100.0)
+             ticks_per_month = ticks_per_year / 12.0
+             gross_income = buyer.current_wage * work_hours * ticks_per_month
+
+        existing_debt = 0.0
+        if context.bank:
+             try:
+                 status = context.bank.get_debt_status(buyer.id)
+                 existing_debt = status.total_outstanding_debt
+             except: pass
+
+        return BorrowerProfileDTO(
+            borrower_id=str(buyer.id),
+            gross_income=gross_income,
+            existing_debt_payments=existing_debt * 0.01, # Approx
+            collateral_value=trade_value,
+            existing_assets=buyer.assets
+        )
+
+    def _void_loan_safely(self, context: TransactionContext, loan_id: str):
+        if context.bank and loan_id:
+            try:
+                void_tx = context.bank.void_loan(loan_id)
+                if void_tx and context.transaction_queue is not None:
+                    context.transaction_queue.append(void_tx)
+            except Exception as e:
+                context.logger.error(f"HOUSING | Failed to void loan {loan_id}: {e}")
+
+    def _apply_housing_effects(self, unit: Any, buyer: Any, seller: Any, mortgage_id: Optional[str], context: TransactionContext):
+        """
+        Updates housing ownership and residency.
+        Mirrors Registry._handle_housing_registry but includes mortgage_id.
+        """
+        unit_id = unit.id
+
+        # Update Unit
+        unit.owner_id = buyer.id
+        unit.mortgage_id = mortgage_id
+
+        # Update Seller (if not None/Govt)
+        if seller and hasattr(seller, "owned_properties"):
+            if unit_id in seller.owned_properties:
+                seller.owned_properties.remove(unit_id)
+
+        # Update Buyer
+        if hasattr(buyer, "owned_properties"):
+            if unit_id not in buyer.owned_properties:
+                buyer.owned_properties.append(unit_id)
+
+            # Auto-move-in if homeless
+            if getattr(buyer, "residing_property_id", None) is None:
+                unit.occupant_id = buyer.id
+                buyer.residing_property_id = unit_id
+                buyer.is_homeless = False
diff --git a/simulation/initialization/initializer.py b/simulation/initialization/initializer.py
index f2ae7ad..efd9cb0 100644
--- a/simulation/initialization/initializer.py
+++ b/simulation/initialization/initializer.py
@@ -51,7 +51,7 @@ from simulation.systems.handlers.goods_handler import GoodsTransactionHandler
 from simulation.systems.handlers.labor_handler import LaborTransactionHandler
 from simulation.systems.handlers.stock_handler import StockTransactionHandler
 from simulation.systems.handlers.asset_transfer_handler import AssetTransferHandler
-from simulation.systems.handlers.housing_transaction_handler import HousingTransactionHandler
+from modules.market.handlers.housing_transaction_handler import HousingTransactionHandler
 from simulation.systems.handlers.inheritance_handler import InheritanceHandler
 from simulation.systems.handlers.monetary_handler import MonetaryTransactionHandler
 from simulation.systems.handlers.financial_handler import FinancialTransactionHandler
diff --git a/simulation/systems/handlers/housing_transaction_handler.py b/simulation/systems/handlers/housing_transaction_handler.py
deleted file mode 100644
index 02d5c47..0000000
--- a/simulation/systems/handlers/housing_transaction_handler.py
+++ /dev/null
@@ -1,247 +0,0 @@
-from typing import Any, Optional
-import logging
-from simulation.systems.api import ITransactionHandler, TransactionContext
-from simulation.models import Transaction
-from modules.finance.api import BorrowerProfileDTO
-from simulation.agents.government import Government
-
-logger = logging.getLogger(__name__)
-
-class HousingTransactionHandler(ITransactionHandler):
-    """
-    Handles 'housing' market transactions (Purchases & Mortgages).
-    Implements ITransactionHandler contract.
-    Refactored from HousingSystem.process_transaction.
-    """
-
-    def handle(self, transaction: Transaction, buyer: Any, seller: Any, context: TransactionContext) -> bool:
-        """
-        Executes the housing transaction:
-        1. Identifies Unit and Agents.
-        2. Application & Granting of Mortgage (if needed).
-        3. Disbursement of Loan (Bank -> Buyer).
-        4. Payment (Buyer -> Seller) via Escrow or Direct Transfer.
-        5. Updates Unit Mortgage State.
-        """
-        # 1. Resolve Seller if missing (e.g. ID -1 for Government/Bank)
-        if seller is None:
-            if transaction.seller_id == -1:
-                # Assuming -1 represents Government or Bank. HousingSystem implied Govt often acts as fallback.
-                seller = context.government
-            else:
-                context.logger.error(f"HOUSING | Seller {transaction.seller_id} not found.")
-                return False
-
-        if buyer is None:
-            context.logger.error(f"HOUSING | Buyer {transaction.buyer_id} not found.")
-            return False
-
-        try:
-            # Parse Unit ID
-            # Transaction item_id expected format: "unit_{id}"
-            unit_id_str = transaction.item_id.split("_")[1]
-            unit_id = int(unit_id_str)
-            unit = next((u for u in context.real_estate_units if u.id == unit_id), None)
-
-            if not unit:
-                context.logger.warning(f"HOUSING | Unit {transaction.item_id} not found in state.")
-                return False
-
-            # 2. Mortgage Logic
-            # Only Households get mortgages. Firms/Govt pay cash.
-            # We assume 'owned_properties' existence implies eligibility or checking type
-            is_household_buyer = hasattr(buyer, "owned_properties") and hasattr(buyer, "residing_property_id")
-
-            loan_id = None
-            loan_amount = 0.0
-
-            # Retrieve Config
-            ltv_ratio = getattr(context.config_module, "MORTGAGE_LTV_RATIO", 0.8)
-            mortgage_term = getattr(context.config_module, "MORTGAGE_TERM_TICKS", 300)
-            mortgage_rate = getattr(context.config_module, "MORTGAGE_INTEREST_RATE", 0.05)
-
-            trade_value = transaction.price * transaction.quantity
-
-            if is_household_buyer and context.bank:
-                loan_amount = trade_value * ltv_ratio
-
-                # Construct BorrowerProfileDTO
-                gross_income = 0.0
-                if hasattr(buyer, "current_wage"):
-                    work_hours = getattr(context.config_module, "WORK_HOURS_PER_DAY", 8.0)
-                    ticks_per_year = getattr(context.config_module, "TICKS_PER_YEAR", 100.0)
-                    ticks_per_month = ticks_per_year / 12.0
-                    gross_income = buyer.current_wage * work_hours * ticks_per_month
-
-                existing_debt_payments = 0.0
-                try:
-                    debt_status = context.bank.get_debt_status(buyer.id)
-                    total_debt = debt_status.get("total_outstanding_debt", 0.0)
-                    monthly_payment_rate = getattr(context.config_module, "ESTIMATED_DEBT_PAYMENT_RATIO", 0.01)
-                    existing_debt_payments = total_debt * monthly_payment_rate
-                except Exception:
-                    pass
-
-                borrower_profile = BorrowerProfileDTO(
-                    borrower_id=str(buyer.id),
-                    gross_income=gross_income,
-                    existing_debt_payments=existing_debt_payments,
-                    collateral_value=trade_value,
-                    existing_assets=buyer.assets
-                )
-
-                due_tick = context.time + mortgage_term
-
-                # Grant Loan
-                grant_result = context.bank.grant_loan(
-                    borrower_id=str(buyer.id),
-                    amount=loan_amount,
-                    interest_rate=mortgage_rate,
-                    due_tick=due_tick,
-                    borrower_profile=borrower_profile
-                )
-
-                if grant_result:
-                    loan_info, credit_tx = grant_result
-                    loan_id = loan_info["loan_id"]
-
-                    if credit_tx and context.transaction_queue is not None:
-                         context.transaction_queue.append(credit_tx)
-
-                    # 3. Disbursement: Bank -> Buyer
-                    disbursement_success = context.settlement_system.transfer(
-                        context.bank, buyer, loan_amount, "loan_disbursement", tick=context.time
-                    )
-
-                    if not disbursement_success:
-                         context.logger.error(f"LOAN_DISBURSEMENT_FAIL | Bank could not transfer {loan_amount} to {buyer.id}. Voiding loan.")
-                         void_tx = context.bank.void_loan(loan_id)
-                         if void_tx and context.transaction_queue is not None: context.transaction_queue.append(void_tx)
-                         return False
-
-                    # Deposit Cleanup (Liability Reduction)
-                    if hasattr(context.bank, "withdraw_for_customer"):
-                        withdraw_success = context.bank.withdraw_for_customer(buyer.id, loan_amount)
-                        if not withdraw_success:
-                             context.logger.error(f"LOAN_WITHDRAW_FAIL | Could not reduce deposit for {buyer.id}. Rolling back.")
-                             context.settlement_system.transfer(buyer, context.bank, loan_amount, "loan_rollback", tick=context.time)
-                             void_tx = context.bank.void_loan(loan_id)
-                             if void_tx and context.transaction_queue is not None: context.transaction_queue.append(void_tx)
-                             return False
-
-                    # Update Unit Mortgage State (Pre-emptively, rolled back if sale fails)
-                    unit.mortgage_id = loan_id
-                else:
-                    unit.mortgage_id = None
-            else:
-                unit.mortgage_id = None
-
-            # 4. Process Payment (Buyer -> Seller)
-            payment_success = False
-
-            # Check for Government Tax Collection path
-            if isinstance(seller, Government):
-                # Use collect_tax which uses SettlementSystem internally
-                # Note: collect_tax handles transfer.
-                tax_result = seller.collect_tax(trade_value, "asset_sale", buyer, context.time)
-                payment_success = tax_result["success"]
-            else:
-                # Standard Transfer
-                payment_success = context.settlement_system.transfer(
-                    buyer, seller, trade_value, f"purchase_unit_{unit.id}", tick=context.time
-                )
-
-            if not payment_success:
-                 context.logger.error(f"HOUSING_PAYMENT_FAIL | Buyer {buyer.id} could not pay {trade_value} to Seller {seller.id}. Rolling back.")
-
-                 # Rollback Loan
-                 if loan_id and context.bank:
-                      # Reverse Disbursement
-                      context.settlement_system.transfer(buyer, context.bank, loan_amount, "loan_rollback", tick=context.time)
-
-                      # Void Loan
-                      try:
-                          void_tx = context.bank.void_loan(loan_id)
-                          if void_tx and context.transaction_queue is not None: context.transaction_queue.append(void_tx)
-                      except Exception as e:
-                          context.logger.warning(f"ROLLBACK_WARNING | void_loan failed during rollback: {e}")
-
-                      unit.mortgage_id = None
-
-                 return False
-
-            # Success
-            # Side effect: Update ownership (Registry-like logic)
-            # The Registry had _handle_housing_registry logic:
-            # "unit.owner_id = buyer.id", update seller/buyer owned_properties, auto-move-in.
-            # HousingTransactionHandler here did NOT have explicit ownership update code in the try block logic I read before.
-            # Wait, let me check the previous file content again.
-
-            # The previous file content:
-            # ...
-            # 4. Process Payment ...
-            # ...
-            # return True
-
-            # It seems HousingTransactionHandler implementation I read missed the actual ownership update?!
-            # Or maybe I missed it?
-            # Let me re-read the previous file content from my context.
-            # I read it in tool output.
-            # It ends with:
-            # logger.info(f"REAL_ESTATE | Sold Unit {unit.id} to {buyer.id}. ...")
-            # return True
-
-            # It assumes caller or Registry updates ownership?
-            # But TransactionProcessor says "elif tx.transaction_type == 'housing': pass".
-            # It relied on Registry logic?
-            # Registry._handle_housing_registry does the update.
-            # BUT HousingTransactionHandler is an ISpecializedTransactionHandler.
-            # TransactionManager calls it:
-            # if tx.transaction_type in self.handlers: success = handler.handle(...)
-            # Then: "3. State Commitment (Registry & Accounting)... if success: registry.update_ownership(...)"
-
-            # Aha! TransactionManager calls registry.update_ownership AFTER handler returns success.
-            # The new TransactionProcessor (Dispatcher) in Spec has:
-            # "success = handler.handle(...)"
-            # "Post-processing (e.g., effects queue)..."
-            # It does NOT call registry.update_ownership explicitly in the loop example in Spec!
-            # The Spec for GoodsTransactionHandler puts side-effects INSIDE the handler.
-            # So I MUST put ownership update logic INSIDE HousingTransactionHandler.
-
-            self._apply_housing_effects(unit, buyer, seller, context)
-
-            context.logger.info(
-                f"REAL_ESTATE | Sold Unit {unit.id} to {buyer.id}. Price: {trade_value:.2f} Loan: {loan_amount}",
-                extra={"tick": context.time, "tags": ["real_estate"]}
-            )
-            return True
-
-        except Exception as e:
-            context.logger.error(f"HOUSING_ERROR | {e}", extra={"error": str(e)})
-            return False
-
-    def _apply_housing_effects(self, unit: Any, buyer: Any, seller: Any, context: TransactionContext):
-        """
-        Updates housing ownership and residency.
-        Migrated from Registry._handle_housing_registry.
-        """
-        unit_id = unit.id
-
-        # Update Unit
-        unit.owner_id = buyer.id
-
-        # Update Seller (if not None/Govt)
-        if seller and hasattr(seller, "owned_properties"):
-            if unit_id in seller.owned_properties:
-                seller.owned_properties.remove(unit_id)
-
-        # Update Buyer
-        if hasattr(buyer, "owned_properties"):
-            if unit_id not in buyer.owned_properties:
-                buyer.owned_properties.append(unit_id)
-
-            # Housing System Logic: Auto-move-in if homeless
-            if getattr(buyer, "residing_property_id", None) is None:
-                unit.occupant_id = buyer.id
-                buyer.residing_property_id = unit_id
-                buyer.is_homeless = False
diff --git a/simulation/systems/registry.py b/simulation/systems/registry.py
index f3d59d2..ddf2a7e 100644
--- a/simulation/systems/registry.py
+++ b/simulation/systems/registry.py
@@ -194,6 +194,10 @@ class Registry(IRegistry):
 
             # Update Unit
             unit.owner_id = buyer.id
+            if tx.metadata and "mortgage_id" in tx.metadata:
+                unit.mortgage_id = tx.metadata["mortgage_id"]
+            else:
+                unit.mortgage_id = None
 
             # Update Seller (if not None/Govt)
             if seller and hasattr(seller, "owned_properties"):
diff --git a/tests/market/test_housing_transaction_handler.py b/tests/market/test_housing_transaction_handler.py
new file mode 100644
index 0000000..9c0d59d
--- /dev/null
+++ b/tests/market/test_housing_transaction_handler.py
@@ -0,0 +1,176 @@
+import pytest
+from unittest.mock import MagicMock, call
+from modules.market.handlers.housing_transaction_handler import HousingTransactionHandler
+from simulation.models import Transaction
+from modules.system.escrow_agent import EscrowAgent
+from simulation.core_agents import Household
+
+@pytest.fixture
+def handler():
+    return HousingTransactionHandler()
+
+@pytest.fixture
+def context():
+    ctx = MagicMock()
+    ctx.settlement_system = MagicMock()
+    ctx.bank = MagicMock()
+    ctx.config_module = MagicMock()
+    # Mock nested structure config_module.housing
+    ctx.config_module.housing = {"max_ltv_ratio": 0.8, "mortgage_term_ticks": 300}
+    # Also support getattr(config, "housing", {})
+
+    ctx.real_estate_units = []
+    ctx.agents = {}
+    ctx.logger = MagicMock()
+    ctx.time = 0
+    ctx.transaction_queue = []
+    return ctx
+
+@pytest.fixture
+def buyer():
+    b = MagicMock(spec=Household)
+    b.id = 1
+    b.assets = 100000.0
+    b.owned_properties = []
+    b.residing_property_id = None
+    b.is_homeless = True
+    return b
+
+@pytest.fixture
+def seller():
+    s = MagicMock()
+    s.id = 2
+    s.owned_properties = [101]
+    return s
+
+@pytest.fixture
+def unit():
+    u = MagicMock()
+    u.id = 101
+    u.owner_id = 2
+    return u
+
+@pytest.fixture
+def escrow_agent():
+    e = MagicMock(spec=EscrowAgent)
+    e.id = 99
+    return e
+
+def test_housing_transaction_success(handler, context, buyer, seller, unit, escrow_agent):
+    # Setup
+    context.real_estate_units = [unit]
+    context.agents = {99: escrow_agent}
+
+    tx = Transaction(
+        buyer_id=1, seller_id=2, item_id="unit_101", price=1000.0, quantity=1.0,
+        market_id="housing", transaction_type="housing", time=0
+    )
+
+    # Mock Settlement Success: DownPayment(True), Disbursement(True), FinalSettlement(True)
+    context.settlement_system.transfer.side_effect = [True, True, True]
+
+    # Mock Bank Success
+    loan_dto = MagicMock()
+    loan_dto.loan_id = "loan_123"
+    context.bank.grant_loan.return_value = (loan_dto, None)
+
+    # Execute
+    result = handler.handle(tx, buyer, seller, context)
+
+    # Verify
+    assert result is True
+    # Down payment (20% of 1000 = 200)
+    # Loan (80% of 1000 = 800)
+
+    # 1. Down Payment: Buyer -> Escrow (200)
+    context.settlement_system.transfer.assert_any_call(buyer, escrow_agent, 200.0, "escrow_hold:down_payment:unit_101", tick=0)
+
+    # 2. Loan Grant called
+    context.bank.grant_loan.assert_called()
+
+    # 3. Disbursement: Buyer -> Escrow (800)
+    context.settlement_system.transfer.assert_any_call(buyer, escrow_agent, 800.0, "escrow_hold:loan_proceeds:unit_101", tick=0)
+
+    # 4. Final Settlement: Escrow -> Seller (1000)
+    context.settlement_system.transfer.assert_any_call(escrow_agent, seller, 1000.0, "final_settlement:unit_101", tick=0)
+
+    # 5. Side Effects
+    assert unit.owner_id == buyer.id
+    assert unit.mortgage_id == "loan_123"
+    assert 101 in buyer.owned_properties
+    assert 101 not in seller.owned_properties
+    assert tx.metadata["mortgage_id"] == "loan_123"
+
+def test_housing_transaction_insufficient_down_payment(handler, context, buyer, seller, unit, escrow_agent):
+    context.real_estate_units = [unit]
+    context.agents = {99: escrow_agent}
+    buyer.assets = 10.0 # Insufficient
+
+    tx = Transaction(
+        buyer_id=1, seller_id=2, item_id="unit_101", price=1000.0, quantity=1.0,
+        market_id="housing", transaction_type="housing", time=0
+    )
+
+    result = handler.handle(tx, buyer, seller, context)
+    assert result is False
+    context.settlement_system.transfer.assert_not_called()
+
+def test_housing_transaction_loan_rejected(handler, context, buyer, seller, unit, escrow_agent):
+    context.real_estate_units = [unit]
+    context.agents = {99: escrow_agent}
+
+    tx = Transaction(
+        buyer_id=1, seller_id=2, item_id="unit_101", price=1000.0, quantity=1.0,
+        market_id="housing", transaction_type="housing", time=0
+    )
+
+    # Down payment success
+    context.settlement_system.transfer.side_effect = [True, True] # Sequence
+
+    # Bank Rejects
+    context.bank.grant_loan.return_value = None
+
+    result = handler.handle(tx, buyer, seller, context)
+
+    assert result is False
+    # Verify Compensation: Return Down Payment
+    # transfer(escrow, buyer, 200, ...)
+    # Call args list:
+    # 1. Buyer->Escrow (Down)
+    # 2. Escrow->Buyer (Reversal)
+    calls = context.settlement_system.transfer.call_args_list
+    assert len(calls) >= 2
+    assert calls[1][0][0] == escrow_agent
+    assert calls[1][0][1] == buyer
+    assert "escrow_reversal" in calls[1][0][3]
+
+def test_housing_transaction_disbursement_failed(handler, context, buyer, seller, unit, escrow_agent):
+    context.real_estate_units = [unit]
+    context.agents = {99: escrow_agent}
+
+    tx = Transaction(
+        buyer_id=1, seller_id=2, item_id="unit_101", price=1000.0, quantity=1.0,
+        market_id="housing", transaction_type="housing", time=0
+    )
+
+    # 1. Down Payment Success
+    # 2. Loan Proceeds Transfer Fails
+    context.settlement_system.transfer.side_effect = [True, False, True]
+
+    loan_dto = MagicMock()
+    loan_dto.loan_id = "loan_123"
+    context.bank.grant_loan.return_value = (loan_dto, None)
+
+    result = handler.handle(tx, buyer, seller, context)
+
+    assert result is False
+    # Verify Compensation: Void Loan, Return Down Payment
+    context.bank.void_loan.assert_called_with("loan_123")
+
+    # Check transfer calls
+    # 1. Buyer->Escrow (Down) [Success]
+    # 2. Buyer->Escrow (Proceeds) [Fail]
+    # 3. Escrow->Buyer (Down Reversal)
+    assert context.settlement_system.transfer.call_count == 3
+    calls = context.settlement_system.transfer.call_args_list
+    assert "escrow_reversal" in calls[2][0][3]
diff --git a/tests/systems/test_registry_housing.py b/tests/systems/test_registry_housing.py
new file mode 100644
index 0000000..c26afe3
--- /dev/null
+++ b/tests/systems/test_registry_housing.py
@@ -0,0 +1,78 @@
+import pytest
+from unittest.mock import MagicMock
+from simulation.systems.registry import Registry
+from simulation.models import Transaction
+from simulation.core_agents import Household
+from simulation.dtos.api import SimulationState
+
+def test_registry_handle_housing_updates_mortgage():
+    registry = Registry()
+
+    # Setup
+    buyer = MagicMock(spec=Household)
+    buyer.id = 1
+    buyer.owned_properties = []
+    buyer.residing_property_id = None
+
+    seller = MagicMock()
+    seller.id = 2
+    seller.owned_properties = [101]
+
+    unit = MagicMock()
+    unit.id = 101
+    unit.owner_id = 2
+    unit.mortgage_id = None
+
+    real_estate_units = [unit]
+
+    state = MagicMock(spec=SimulationState)
+    state.real_estate_units = real_estate_units
+    state.time = 0
+
+    # Transaction with mortgage_id
+    tx = Transaction(
+        buyer_id=1, seller_id=2, item_id="unit_101", price=1000.0, quantity=1.0,
+        market_id="housing", transaction_type="housing", time=0
+    )
+    tx.metadata = {"mortgage_id": "loan_999"}
+
+    # Execute
+    registry.update_ownership(tx, buyer, seller, state)
+
+    # Verify
+    assert unit.owner_id == 1
+    assert unit.mortgage_id == "loan_999"
+    assert 101 in buyer.owned_properties
+    assert 101 not in seller.owned_properties
+
+def test_registry_handle_housing_clears_mortgage_if_missing():
+    registry = Registry()
+
+    buyer = MagicMock(spec=Household)
+    buyer.id = 1
+    buyer.owned_properties = []
+
+    seller = MagicMock()
+    seller.id = 2
+    seller.owned_properties = [101]
+
+    unit = MagicMock()
+    unit.id = 101
+    unit.owner_id = 2
+    unit.mortgage_id = "old_loan"
+
+    real_estate_units = [unit]
+    state = MagicMock(spec=SimulationState)
+    state.real_estate_units = real_estate_units
+    state.time = 0
+
+    tx = Transaction(
+        buyer_id=1, seller_id=2, item_id="unit_101", price=1000.0, quantity=1.0,
+        market_id="housing", transaction_type="housing", time=0
+    )
+    tx.metadata = {} # No mortgage_id
+
+    registry.update_ownership(tx, buyer, seller, state)
+
+    assert unit.owner_id == 1
+    assert unit.mortgage_id is None
diff --git a/tests/unit/test_transaction_processor.py b/tests/unit/test_transaction_processor.py
index 8a50893..e61ec3a 100644
--- a/tests/unit/test_transaction_processor.py
+++ b/tests/unit/test_transaction_processor.py
@@ -113,3 +113,24 @@ def test_public_manager_routing():
     tp.execute(state)
 
     pm_handler.handle.assert_called_once()
+
+def test_transaction_processor_dispatches_housing():
+    config = MagicMock()
+    tp = TransactionProcessor(config_module=config)
+
+    housing_handler = MagicMock()
+    tp.register_handler("housing", housing_handler)
+
+    state = MagicMock()
+    state.transactions = [
+        Transaction(
+            buyer_id=1, seller_id=2, item_id="unit_1", price=100, quantity=1,
+            market_id="housing", transaction_type="housing", time=0
+        )
+    ]
+    state.agents = {1: MagicMock(), 2: MagicMock()}
+    state.taxation_system = MagicMock()
+
+    tp.execute(state)
+
+    housing_handler.handle.assert_called_once()
