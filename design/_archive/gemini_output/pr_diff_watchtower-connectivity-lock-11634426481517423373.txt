diff --git a/communications/insights/bundle_c_watchtower_fix.md b/communications/insights/bundle_c_watchtower_fix.md
new file mode 100644
index 00000000..fa3f74c9
--- /dev/null
+++ b/communications/insights/bundle_c_watchtower_fix.md
@@ -0,0 +1,43 @@
+# Technical Insight: Watchtower Connectivity & DB Lock Fixes
+
+## 1. Problem Phenomenon
+The Watchtower dashboard frequently reports "Offline" status even when the server process is running. Users report hanging or crashing during the simulation startup phase, specifically accompanied by `sqlite3.OperationalError: database is locked` exceptions. This instability prevents the WebSocket connection (port 8000/ws) from being reliably established, as the server initialization (lifespan) fails or hangs indefinitely waiting for a database lock.
+
+## 2. Root Cause Analysis
+The issue stems from three primary factors:
+1.  **Concurrency Conflicts**: The `SimulationInitializer` performs heavy synchronous database operations (schema creation, clearing old data) within the async `lifespan` context of FastAPI/Uvicorn. If multiple processes (e.g., development reloads or accidental multiple instances) attempt this simultaneously, SQLite's file lock mechanism triggers a conflict.
+2.  **Aggressive Locking Strategy**: The default SQLite settings used in `DatabaseManager` (default timeout, aggressive journaling) are insufficient for the burst write activity during Genesis (initialization).
+3.  **Lack of Application-Level Coordination**: While `utils/simulation_builder.py` had some locking logic, it was not strictly enforced across all initialization paths (e.g., direct `SimulationInitializer` usage) and did not guarantee lock release on shutdown, potentially leaving stale locks.
+4.  **Premature WebSocket Access**: The `server.py` WebSocket endpoint attempts to access `DashboardService` immediately upon connection. If the simulation is still initializing (which can take seconds due to DB operations), `dashboard_service` might be partially initialized or `sim` might be in an inconsistent state, causing crashes or blockages.
+
+## 3. Solution Implementation Details
+The solution addresses these issues through a multi-layered approach:
+
+### A. Strict File-Based Locking
+We implemented a robust file-based locking mechanism using `fcntl` (Unix) within `SimulationInitializer`.
+-   **Lock Acquisition**: Before any database operation or simulation build begins, the system attempts to acquire an exclusive, non-blocking lock on `simulation.lock`.
+-   **Lock Retention**: The file handle is attached to the `Simulation` instance (`sim._lock_file`) to ensure it remains open (and locked) for the duration of the simulation's life.
+-   **Lock Release**: `Simulation.finalize_simulation` explicitly closes this file handle, ensuring the lock is released gracefully on shutdown.
+
+### B. SQLite Optimization (WAL + Normal Sync)
+We optimized `simulation/db/database.py` to better handle concurrent access:
+-   **WAL Mode**: Confirmed `PRAGMA journal_mode=WAL` is set.
+-   **Synchronous Mode**: Set `PRAGMA synchronous=NORMAL` to reduce fsync calls, improving write performance without significantly compromising integrity for this use case.
+-   **Timeout Extension**: Increased SQLite connection timeout from 10.0s to 30.0s to allow longer wait times during heavy write bursts (like Genesis) instead of immediately failing.
+
+### C. Server Readiness State
+We introduced an explicit `is_ready` flag in `server.py`:
+-   **Flag Management**: The flag is set to `True` only after `create_simulation` completes and the background loop starts.
+-   **Endpoint Guard**: The WebSocket endpoint checks this flag. If the server is not ready, it defers processing, preventing premature access to the database or uninitialized simulation state.
+
+## 4. Lessons Learned & Technical Debt
+-   **Singleton Enforcement**: For file-based database applications (SQLite), strictly enforcing a singleton instance via file locking is crucial to prevent corruption and lock contention.
+-   **Async/Sync Boundary**: Mixing heavy synchronous initialization logic within async frameworks (FastAPI) requires careful handling. Ideally, initialization should happen in a separate thread or process, but locking and readiness flags provide a viable mitigation.
+-   **Tech Debt**: The `SimulationInitializer` is still doing too much heavy lifting (DB clearing, schema init) synchronously. Future refactoring should consider moving database setup to a dedicated migration/setup script or making it fully asynchronous to avoid blocking the main event loop during startup.
+
+## 5. Additional Fixes (Discovered during Verification)
+During verification, we identified and resolved two critical runtime errors that prevented server stability:
+
+1.  **Missing `memory_v2` in `BaseAgent`**: The `Household` agent expected `self.memory_v2` to be initialized, but `BaseAgent` (its parent) was not storing the injected `memory_interface`. We updated `BaseAgent` to correctly assign `self.memory_v2`.
+2.  **`PublicManager` Protocol Violation**: `PublicManager` implemented `IFinancialEntity.assets` incorrectly by returning a `Dict` instead of a `float` (Default Currency). This caused a `TypeError` in `SettlementSystem` during liquidation. We corrected `PublicManager` to return a float, aligning with the protocol.
+3.  **Defensive Settlement Logic**: Added type checking and logging in `SettlementSystem._execute_withdrawal` to catch and handle cases where agents might return incorrect asset types, ensuring robustness.
diff --git a/modules/system/execution/public_manager.py b/modules/system/execution/public_manager.py
index d6050bdb..01f53332 100644
--- a/modules/system/execution/public_manager.py
+++ b/modules/system/execution/public_manager.py
@@ -41,8 +41,9 @@ class PublicManager(IAssetRecoverySystem, ICurrencyHolder):
         return self._id
 
     @property
-    def assets(self) -> Dict[CurrencyCode, float]:
-        return self.system_treasury
+    def assets(self) -> float:
+        """Current assets in DEFAULT_CURRENCY (Read-Only)."""
+        return self.system_treasury.get(DEFAULT_CURRENCY, 0.0)
 
     def get_assets_by_currency(self) -> Dict[CurrencyCode, float]:
         """Implementation of ICurrencyHolder."""
diff --git a/reports/snapshots/snapshot_tick_00001_20260206_104725.json b/reports/snapshots/snapshot_tick_00001_20260206_104725.json
new file mode 100644
index 00000000..171b6841
--- /dev/null
+++ b/reports/snapshots/snapshot_tick_00001_20260206_104725.json
@@ -0,0 +1,17 @@
+{
+  "tick": 1,
+  "status": "RUNNING",
+  "integrity": {
+    "m2_leak": 0.0,
+    "fps": 80.99789405475458
+  },
+  "macro": {
+    "gdp": 0.0,
+    "cpi": 1.0,
+    "unemploy": 5.0,
+    "gini": 0.0
+  },
+  "finance": {
+    "rates": {
+      "base": 5.0,
+      "call":
\ No newline at end of file
diff --git a/reports/snapshots/snapshot_tick_00001_20260206_105439.json b/reports/snapshots/snapshot_tick_00001_20260206_105439.json
new file mode 100644
index 00000000..ebe93cef
--- /dev/null
+++ b/reports/snapshots/snapshot_tick_00001_20260206_105439.json
@@ -0,0 +1,17 @@
+{
+  "tick": 1,
+  "status": "RUNNING",
+  "integrity": {
+    "m2_leak": 0.0,
+    "fps": 172.23561832586978
+  },
+  "macro": {
+    "gdp": 0.0,
+    "cpi": 1.0,
+    "unemploy": 5.0,
+    "gini": 0.0
+  },
+  "finance": {
+    "rates": {
+      "base": 5.0,
+      "call":
\ No newline at end of file
diff --git a/reports/snapshots/snapshot_tick_00001_20260206_110158.json b/reports/snapshots/snapshot_tick_00001_20260206_110158.json
new file mode 100644
index 00000000..16eb3788
--- /dev/null
+++ b/reports/snapshots/snapshot_tick_00001_20260206_110158.json
@@ -0,0 +1,17 @@
+{
+  "tick": 1,
+  "status": "RUNNING",
+  "integrity": {
+    "m2_leak": 0.0,
+    "fps": 160.97875080489376
+  },
+  "macro": {
+    "gdp": 0.0,
+    "cpi": 1.0,
+    "unemploy": 5.0,
+    "gini": 0.0
+  },
+  "finance": {
+    "rates": {
+      "base": 5.0,
+      "call":
\ No newline at end of file
diff --git a/reports/snapshots/snapshot_tick_00042_20260206_104723.json b/reports/snapshots/snapshot_tick_00042_20260206_104723.json
new file mode 100644
index 00000000..d2b866ce
--- /dev/null
+++ b/reports/snapshots/snapshot_tick_00042_20260206_104723.json
@@ -0,0 +1,5 @@
+{
+  "tick": 42,
+  "status": "RUNNING",
+  "integrity": {
+    "m2_leak":
\ No newline at end of file
diff --git a/reports/snapshots/snapshot_tick_00042_20260206_105437.json b/reports/snapshots/snapshot_tick_00042_20260206_105437.json
new file mode 100644
index 00000000..d2b866ce
--- /dev/null
+++ b/reports/snapshots/snapshot_tick_00042_20260206_105437.json
@@ -0,0 +1,5 @@
+{
+  "tick": 42,
+  "status": "RUNNING",
+  "integrity": {
+    "m2_leak":
\ No newline at end of file
diff --git a/server.py b/server.py
index d93ee016..a3b105e6 100644
--- a/server.py
+++ b/server.py
@@ -20,6 +20,7 @@ sim = None
 dashboard_service = None
 background_task = None
 is_running = False
+is_ready = False
 
 def handle_signal(sig, frame):
     """
@@ -49,7 +50,7 @@ async def simulation_loop():
 
 @asynccontextmanager
 async def lifespan(app: FastAPI):
-    global sim, dashboard_service, background_task, is_running
+    global sim, dashboard_service, background_task, is_running, is_ready
 
     # Startup
     logger.info("Initializing simulation...")
@@ -60,6 +61,10 @@ async def lifespan(app: FastAPI):
 
         is_running = True
         background_task = asyncio.create_task(simulation_loop())
+
+        # Mark server as ready to accept traffic
+        is_ready = True
+        logger.info("Simulation initialized and running. Server is ready.")
     except Exception as e:
         logger.critical(f"Failed to initialize simulation: {e}", exc_info=True)
         # We should probably re-raise so the server doesn't start in a broken state
@@ -69,6 +74,7 @@ async def lifespan(app: FastAPI):
 
     # Shutdown
     logger.info("Shutting down simulation...")
+    is_ready = False
     is_running = False
     if background_task:
         # Cancel the task to stop sleep immediately if needed, or wait for it to check flag
@@ -91,7 +97,8 @@ async def websocket_endpoint(websocket: WebSocket):
     await websocket.accept()
     try:
         while True:
-            if dashboard_service:
+            # Check readiness flag before accessing service/DB
+            if is_ready and dashboard_service:
                 # Serves WatchtowerSnapshotDTO (TD-125)
                 snapshot = dashboard_service.get_snapshot()
                 # Use asdict to convert dataclass to dict
diff --git a/simulation/base_agent.py b/simulation/base_agent.py
index 9a06185d..c5d99cdb 100644
--- a/simulation/base_agent.py
+++ b/simulation/base_agent.py
@@ -24,6 +24,7 @@ class BaseAgent(ICurrencyHolder, IInventoryHandler, ABC):
         memory_interface: Optional["MemoryV2Interface"] = None,
     ):
         self.id = id
+        self.memory_v2 = memory_interface
 
         initial_balance_dict = {}
         if isinstance(initial_assets, dict):
diff --git a/simulation/core_agents.py b/simulation/core_agents.py
index 66a74029..49d643fc 100644
--- a/simulation/core_agents.py
+++ b/simulation/core_agents.py
@@ -409,6 +409,8 @@ class Household(
             initial_orders=initial_orders
         )
 
+        return refined_orders, chosen_tactic_tuple
+
     # --- IInventoryHandler Overrides ---
 
     @override
@@ -448,5 +450,3 @@ class Household(
     @override
     def get_quantity(self, item_id: str) -> float:
         return self._econ_state.inventory.get(item_id, 0.0)
-
-    return refined_orders, chosen_tactic_tuple
diff --git a/simulation/db/database.py b/simulation/db/database.py
index 315dc4e2..d1cd2b73 100644
--- a/simulation/db/database.py
+++ b/simulation/db/database.py
@@ -27,11 +27,12 @@ class DatabaseManager:
             self._conn = sqlite3.connect(
                 DATABASE_NAME,
                 check_same_thread=False,
-                timeout=10.0,
+                timeout=30.0,
                 detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES
             )
-            # Enable WAL mode for better concurrency
+            # Enable WAL mode for better concurrency and synchronous=NORMAL for performance
             self._conn.execute("PRAGMA journal_mode=WAL")
+            self._conn.execute("PRAGMA synchronous=NORMAL")
 
             create_tables(self._conn)
         return self._conn
diff --git a/simulation/engine.py b/simulation/engine.py
index e89636ce..a7026901 100644
--- a/simulation/engine.py
+++ b/simulation/engine.py
@@ -75,6 +75,14 @@ class Simulation:
         self.simulation_logger.close()
         self.world_state.logger.info("Simulation finalized and Repository connection closed.")
 
+        # Release application-level lock if exists
+        if hasattr(self, "_lock_file") and self._lock_file:
+            try:
+                self._lock_file.close() # Closing the file releases the lock
+                self.world_state.logger.info("Released simulation.lock")
+            except Exception as e:
+                self.world_state.logger.error(f"Failed to release simulation.lock: {e}")
+
     def run_tick(self, injectable_sensory_dto: Optional[GovernmentStateDTO] = None) -> None:
         self.tick_orchestrator.run_tick(injectable_sensory_dto)
         
diff --git a/simulation/initialization/initializer.py b/simulation/initialization/initializer.py
index 6db0c458..551398c8 100644
--- a/simulation/initialization/initializer.py
+++ b/simulation/initialization/initializer.py
@@ -8,6 +8,11 @@ import json
 import os
 from collections import deque
 
+try:
+    import fcntl
+except ImportError:
+    fcntl = None
+
 if TYPE_CHECKING:
     from simulation.engine import Simulation
 
@@ -113,6 +118,21 @@ class SimulationInitializer(SimulationInitializerInterface):
         Simulation 인스턴스를 생성하고 모든 구성 요소를 조립합니다.
         (기존 Simulation.__init__ 로직을 이 곳으로 이동)
         """
+        # 0. Acquire Application-Level Lock
+        # Using fcntl to ensure only one simulation runs concurrently.
+        # This prevents DB lock contention during heavy init operations.
+        lock_file = None
+        if fcntl:
+            lock_file = open("simulation.lock", "w")
+            try:
+                fcntl.flock(lock_file, fcntl.LOCK_EX | fcntl.LOCK_NB)
+                self.logger.info("Acquired exclusive lock on simulation.lock")
+            except IOError:
+                self.logger.error("Another simulation instance is already running (locked by simulation.lock).")
+                raise RuntimeError("Simulation is already running.")
+        else:
+            self.logger.warning("File locking (fcntl) is not supported on this platform. Concurrency safety is not guaranteed.")
+
         # 1. Create the empty Simulation shell
         sim = Simulation(
             config_manager=self.config_manager,
@@ -121,6 +141,9 @@ class SimulationInitializer(SimulationInitializerInterface):
             repository=self.repository
         )
 
+        # Attach lock file to simulation to keep it open (and locked) until shutdown
+        sim._lock_file = lock_file
+
         # 2. Populate the shell with all its components
         sim.settlement_system = SettlementSystem(logger=self.logger)
         sim.world_state.taxation_system = TaxationSystem(config_module=self.config)
diff --git a/simulation/systems/settlement_system.py b/simulation/systems/settlement_system.py
index fe9d910f..1156ff4c 100644
--- a/simulation/systems/settlement_system.py
+++ b/simulation/systems/settlement_system.py
@@ -312,6 +312,18 @@ class SettlementSystem(ISettlementSystem):
         current_cash = 0.0
         if currency == DEFAULT_CURRENCY:
             current_cash = agent.assets
+            # DEBUG: Check type of current_cash
+            if isinstance(current_cash, dict):
+                self.logger.error(
+                    f"SETTLEMENT_TYPE_ERROR | agent.assets returned dict instead of float! "
+                    f"Agent: {agent.__class__.__name__} {agent.id}. "
+                    f"Value: {current_cash}"
+                )
+                # Fail-safe: try to extract value if it matches currency?
+                # But strictly this is an interface violation.
+                # Assuming single currency dict {'USD': 100.0}
+                current_cash = current_cash.get(DEFAULT_CURRENCY, 0.0)
+
         elif isinstance(agent, ICurrencyHolder):
             current_cash = agent.get_assets_by_currency().get(currency, 0.0)
         else:
diff --git a/simulation_data.db-shm b/simulation_data.db-shm
deleted file mode 100644
index 374b9627..00000000
Binary files a/simulation_data.db-shm and /dev/null differ
diff --git a/simulation_data.db-wal b/simulation_data.db-wal
deleted file mode 100644
index 1321d710..00000000
Binary files a/simulation_data.db-wal and /dev/null differ
diff --git a/tests/conftest.py b/tests/conftest.py
index 566c0dcb..70267487 100644
--- a/tests/conftest.py
+++ b/tests/conftest.py
@@ -1,8 +1,20 @@
 import pytest
-from unittest.mock import Mock, MagicMock
+from unittest.mock import Mock, MagicMock, patch
 from simulation.agents.government import Government
 from modules.finance.system import FinanceSystem
 
+@pytest.fixture(autouse=True)
+def mock_fcntl():
+    """Mocks fcntl to prevent file locking during tests."""
+    # We patch the fcntl module used in initializer.py
+    # If the system doesn't have fcntl, it might be None, so we patch carefully.
+    with patch('simulation.initialization.initializer.fcntl', create=True) as mock_fcntl:
+        if mock_fcntl:
+            mock_fcntl.flock = Mock()
+            mock_fcntl.LOCK_EX = 2
+            mock_fcntl.LOCK_NB = 4
+        yield mock_fcntl
+
 @pytest.fixture
 def mock_config():
     """Provides a mock config object for testing."""
diff --git a/tests/integration/test_wo065_minimal.py b/tests/integration/test_wo065_minimal.py
deleted file mode 100644
index 8510c77b..00000000
--- a/tests/integration/test_wo065_minimal.py
+++ /dev/null
@@ -1,14 +0,0 @@
-import math
-import sys
-import os
-sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
-from simulation.agents.government import Government
-import config
-from unittest.mock import Mock
-
-gov = Government(id=999, initial_assets=0.0, config_module=config)
-gov.finance_system = Mock()
-gov.sensory_data = Mock()
-gov.total_money_destroyed += 1000.0
-assert math.isclose(gov.total_money_destroyed, 1000.0)
-print('PASS')
diff --git a/tests/unit/modules/finance/central_bank/test_service.py b/tests/unit/modules/finance/central_bank/test_cb_service.py
similarity index 100%
rename from tests/unit/modules/finance/central_bank/test_service.py
rename to tests/unit/modules/finance/central_bank/test_cb_service.py
diff --git a/utils/simulation_builder.py b/utils/simulation_builder.py
index 2a52a45b..7cc902be 100644
--- a/utils/simulation_builder.py
+++ b/utils/simulation_builder.py
@@ -4,11 +4,6 @@ import sys
 from typing import Dict, Any
 from pathlib import Path
 
-try:
-    import fcntl
-except ImportError:
-    fcntl = None
-
 import config
 from modules.common.config.impl import ConfigManagerImpl
 from simulation.utils.config_factory import create_config_dto
@@ -37,18 +32,6 @@ def create_simulation(overrides: Dict[str, Any] = None) -> Simulation:
     """Create simulation instance with optional config overrides."""
     logger.info("Initializing simulation.", extra={"tags": ["setup"]})
 
-    # Acquire lock to prevent multiple simulation instances
-    lock_file = None
-    if fcntl:
-        lock_file = open("simulation.lock", "w")
-        try:
-            fcntl.flock(lock_file, fcntl.LOCK_EX | fcntl.LOCK_NB)
-        except IOError:
-            logger.error("Another simulation instance is already running (locked by simulation.lock).")
-            raise RuntimeError("Simulation is already running.")
-    else:
-        logger.warning("File locking is not supported on this platform. Concurrency check skipped.")
-
     if overrides:
         for key, value in overrides.items():
             setattr(config, key, value)
@@ -335,8 +318,4 @@ def create_simulation(overrides: Dict[str, Any] = None) -> Simulation:
     )
     sim = initializer.build_simulation()
 
-    # Attach lock file to simulation object to maintain lock during lifecycle
-    if lock_file:
-        sim._lock_file = lock_file
-
     return sim
