diff --git a/communications/insights/TD-Audit-Fixes.md b/communications/insights/TD-Audit-Fixes.md
new file mode 100644
index 00000000..0430c0c4
--- /dev/null
+++ b/communications/insights/TD-Audit-Fixes.md
@@ -0,0 +1,47 @@
+# TD Audit Fixes & Architectural Insights
+
+**Mission Key:** TD-Audit-Fixes
+**Date:** 2026-02-05
+
+## 1. Resolved Technical Debt
+
+### TD-231: CommerceSystem Sales Tax Planning Leak
+- **Issue**: Consumption planning ignored sales tax, leading to execution failures.
+- **Fix**: Updated `CommerceSystem.plan_consumption_and_leisure` to include `SALES_TAX_RATE` (default 5%) in affordability calculations.
+
+### TD-232: InheritanceManager Encapsulation Violation
+- **Issue**: `InheritanceManager` was bypassing `TransactionProcessor` and manually mutating agent state (`portfolio`, `owned_properties`) while creating "fake" executed transactions.
+- **Fix**: Refactored `InheritanceManager` to:
+    - Stop manual mutation.
+    - Create `asset_liquidation` and `asset_transfer` transactions.
+    - Execute them synchronously via `simulation.transaction_processor.execute(..., [tx])`.
+    - Rely on `MonetaryTransactionHandler` (and `AssetTransferHandler`) to perform the state mutations.
+
+### TD-233: FinanceDepartment Law of Demeter Violation
+- **Issue**: `FinanceDepartment` directly accessed `Household._econ_state` internals.
+- **Fix**:
+    - Added `portfolio` property to `Household` (via `HouseholdFinancialsMixin`).
+    - Updated `FinanceDepartment` to use `household.portfolio`.
+    - Refactored `MonetaryTransactionHandler` and `StockTransactionHandler` to prefer `agent.portfolio` interface, removing broken legacy access to `shares_owned`.
+
+### TD-234: WelfareService Abstraction Leak
+- **Issue**: `WelfareService` used fragile `hasattr` checks and directly mutated `Government.gdp_history`.
+- **Fix**:
+    - Defined `IWelfareRecipient` protocol (runtime checkable).
+    - Encapsulated `gdp_history` mutation in `Government.record_gdp()`.
+    - Updated `WelfareService` to use these abstractions.
+
+## 2. Architectural Insights
+
+### TransactionProcessor Synchronous Execution Pattern
+- **Pattern**: When a System (like `InheritanceManager`) needs to perform a complex sequence of transactions where subsequent steps depend on the result (e.g. cash raised) of previous ones, it should use `transaction_processor.execute(state, [tx])` synchronously.
+- **Benefit**: Maintains "Sacred Sequence" and centralization of transaction logic (in Handlers) while allowing dynamic workflows.
+- **Observation**: `AgentLifecycleManager` captures the return values of these transactions for logging/reporting, ensuring visibility.
+
+### Legacy Test Brittleness
+- **Observation**: Several unit tests (`test_commerce_system.py`, `test_finance_department_bankruptcy.py`) were broken or outdated, checking for non-existent methods or incorrectly assuming data types (float vs Dict).
+- **Action**: Patched strictly necessary tests to verify TD fixes, but a broader "Test Debt" cleanup is recommended.
+
+## 3. Remaining Issues
+- `FinanceDepartment.check_bankruptcy` logic seems to miss the "Brand Resilience" feature tested in `test_finance_department_bankruptcy.py`. This feature might have been lost in a previous refactor.
+- `CommerceSystem` tests refer to `execute_consumption_and_leisure` which no longer exists.
diff --git a/modules/government/welfare/api.py b/modules/government/welfare/api.py
index 2e8f5ee5..a8e6a803 100644
--- a/modules/government/welfare/api.py
+++ b/modules/government/welfare/api.py
@@ -1,7 +1,18 @@
 # modules/government/welfare/api.py
-from typing import Protocol, List, Dict, Any
+from typing import Protocol, List, Dict, Any, runtime_checkable
 from simulation.models import Transaction
 
+@runtime_checkable
+class IWelfareRecipient(Protocol):
+    """
+    Protocol for agents that can receive welfare.
+    """
+    id: int
+    is_active: bool
+    is_employed: bool
+    assets: Any # Can be float or dict
+    needs: Dict[str, float]
+
 class IWelfareService(Protocol):
     """
     Interface for the welfare service.
diff --git a/modules/government/welfare/service.py b/modules/government/welfare/service.py
index 56a8949b..ca245af1 100644
--- a/modules/government/welfare/service.py
+++ b/modules/government/welfare/service.py
@@ -1,7 +1,7 @@
 from typing import List, Any, Dict, TYPE_CHECKING, Optional
 import logging
 from simulation.models import Transaction
-from modules.government.welfare.api import IWelfareService
+from modules.government.welfare.api import IWelfareService, IWelfareRecipient
 from modules.government.constants import (
     DEFAULT_UNEMPLOYMENT_BENEFIT_RATIO,
     DEFAULT_STIMULUS_TRIGGER_GDP_DROP, DEFAULT_HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK,
@@ -95,23 +95,23 @@ class WelfareService(IWelfareService):
         total_welfare_paid = 0.0
 
         for agent in households:
-            if not getattr(agent, "is_active", False):
+            if not isinstance(agent, IWelfareRecipient):
                 continue
 
-            if hasattr(agent, "needs") and hasattr(agent, "is_employed"):
-                # Unemployment Benefit
-                if not agent.is_employed:
-                    txs = self.provide_household_support(agent, benefit_amount, current_tick)
-                    transactions.extend(txs)
-                    total_welfare_paid += benefit_amount
+            if not agent.is_active:
+                continue
+
+            # Unemployment Benefit
+            if not agent.is_employed:
+                txs = self.provide_household_support(agent, benefit_amount, current_tick)
+                transactions.extend(txs)
+                total_welfare_paid += benefit_amount
 
         # 3. Stimulus Check
         current_gdp = market_data.get("total_production", 0.0)
 
-        # NOTE: We access and modify government.gdp_history as it is the source of truth
-        self.government.gdp_history.append(current_gdp)
-        if len(self.government.gdp_history) > self.government.gdp_history_window:
-            self.government.gdp_history.pop(0)
+        # TD-234: Use record_gdp encapsulation
+        self.government.record_gdp(current_gdp)
 
         trigger_drop = getattr(self.config, "STIMULUS_TRIGGER_GDP_DROP", DEFAULT_STIMULUS_TRIGGER_GDP_DROP)
 
@@ -125,7 +125,7 @@ class WelfareService(IWelfareService):
 
         if should_stimulus:
              stimulus_amount = survival_cost * 5.0
-             active_households = [a for a in households if hasattr(a, "is_employed") and getattr(a, "is_active", False)]
+             active_households = [a for a in households if isinstance(a, IWelfareRecipient) and a.is_active]
 
              total_stimulus = 0.0
              for h in active_households:
diff --git a/modules/household/mixins/_financials.py b/modules/household/mixins/_financials.py
index 76cd5291..c0ec8684 100644
--- a/modules/household/mixins/_financials.py
+++ b/modules/household/mixins/_financials.py
@@ -146,6 +146,14 @@ class HouseholdFinancialsMixin:
 
     # --- IPortfolioHandler Implementation ---
 
+    @property
+    def portfolio(self) -> Portfolio:
+        """
+        Direct access to the internal portfolio object.
+        Resolves TD-233 (FinanceDept LoD) and TD-232 (Inheritance).
+        """
+        return self._econ_state.portfolio
+
     def get_portfolio(self) -> PortfolioDTO:
         assets = []
         for firm_id, share in self._econ_state.portfolio.holdings.items():
diff --git a/simulation/agents/government.py b/simulation/agents/government.py
index 7b38f8db..8e344a3c 100644
--- a/simulation/agents/government.py
+++ b/simulation/agents/government.py
@@ -227,6 +227,15 @@ class Government(ICurrencyHolder):
 
         self.expenditure_this_tick = {DEFAULT_CURRENCY: 0.0}
 
+    def record_gdp(self, gdp: float) -> None:
+        """
+        Records the GDP for the current tick.
+        Encapsulates gdp_history mutation (TD-234).
+        """
+        self.gdp_history.append(gdp)
+        if len(self.gdp_history) > self.gdp_history_window:
+            self.gdp_history.pop(0)
+
     def process_monetary_transactions(self, transactions: List[Transaction]):
         """
         Delegates monetary transaction processing to the MonetaryLedger.
diff --git a/simulation/components/finance_department.py b/simulation/components/finance_department.py
index fd42eee7..6be33088 100644
--- a/simulation/components/finance_department.py
+++ b/simulation/components/finance_department.py
@@ -183,7 +183,8 @@ class FinanceDepartment:
             total_shares = self.firm.total_shares
             if total_shares > 0:
                 for household in households:
-                    shares = household._econ_state.portfolio.to_legacy_dict().get(self.firm.id, 0.0)
+                    # TD-233: Use portfolio property (LoD fix)
+                    shares = household.portfolio.to_legacy_dict().get(self.firm.id, 0.0)
                     if shares > 0:
                         dividend_amount = distributable_profit * (shares / total_shares)
                         transactions.append(
diff --git a/simulation/systems/commerce_system.py b/simulation/systems/commerce_system.py
index 3a891970..432e31c1 100644
--- a/simulation/systems/commerce_system.py
+++ b/simulation/systems/commerce_system.py
@@ -80,9 +80,14 @@ class CommerceSystem(ICommerceSystem):
                     # Stock Out. Could we afford it?
                     default_price = getattr(self.config, 'DEFAULT_FALLBACK_PRICE', 5.0)
                     price = batch_decisions.get('price', default_price)
-                    if household._econ_state.assets < price:
+
+                    # TD-231: Account for Sales Tax in affordability check
+                    tax_rate = getattr(self.config, 'SALES_TAX_RATE', 0.05)
+                    price_with_tax = price * (1 + tax_rate)
+
+                    if household._econ_state.assets < price_with_tax:
                         reason = "INSOLVENT"
-                        context_data = {"cash": household._econ_state.assets, "price": price, "need": survival_need}
+                        context_data = {"cash": household._econ_state.assets, "price": price, "price_with_tax": price_with_tax, "need": survival_need}
                     else:
                         reason = "STOCK_OUT"
                         context_data = {"inventory": household._econ_state.inventory.copy(), "cash": household._econ_state.assets}
@@ -130,7 +135,9 @@ class CommerceSystem(ICommerceSystem):
 
                     else:
                         # Legacy Emergency Buy
-                        cost = b_amt * food_price
+                        tax_rate = getattr(self.config, 'SALES_TAX_RATE', 0.05)
+                        cost = b_amt * food_price * (1 + tax_rate) # TD-231: Include tax
+
                         if household._econ_state.assets >= cost:
                             planned_consumptions[household.id]["buy_amount"] = b_amt
                             government = context.get("government")
diff --git a/simulation/systems/handlers/monetary_handler.py b/simulation/systems/handlers/monetary_handler.py
index f4a03a6e..b071cc92 100644
--- a/simulation/systems/handlers/monetary_handler.py
+++ b/simulation/systems/handlers/monetary_handler.py
@@ -99,24 +99,23 @@ class MonetaryTransactionHandler(ITransactionHandler):
             return
 
         # 1. Seller Holdings
-        if isinstance(seller, Household):
+        if hasattr(seller, "portfolio"):
+            seller.portfolio.remove(firm_id, tx.quantity)
+        elif isinstance(seller, Household) and hasattr(seller, "shares_owned"):
+             # Legacy Fallback
             current_shares = seller.shares_owned.get(firm_id, 0)
             seller.shares_owned[firm_id] = max(0, current_shares - tx.quantity)
             if seller.shares_owned[firm_id] <= 0 and firm_id in seller.shares_owned:
                 del seller.shares_owned[firm_id]
-            if hasattr(seller, "portfolio"):
-                seller.portfolio.remove(firm_id, tx.quantity)
         elif isinstance(seller, Firm) and seller.id == firm_id:
             seller.treasury_shares = max(0, seller.treasury_shares - tx.quantity)
-        elif hasattr(seller, "portfolio"):
-            seller.portfolio.remove(firm_id, tx.quantity)
 
         # 2. Buyer Holdings
-        if isinstance(buyer, Household):
+        if hasattr(buyer, "portfolio"):
+            buyer.portfolio.add(firm_id, tx.quantity, tx.price)
+        elif isinstance(buyer, Household) and hasattr(buyer, "shares_owned"):
+            # Legacy Fallback
             buyer.shares_owned[firm_id] = buyer.shares_owned.get(firm_id, 0) + tx.quantity
-            if hasattr(buyer, "portfolio"):
-                buyer.portfolio.add(firm_id, tx.quantity, tx.price)
-                buyer.shares_owned[firm_id] = buyer.portfolio.holdings[firm_id].quantity
         elif isinstance(buyer, Firm) and buyer.id == firm_id:
             buyer.treasury_shares += tx.quantity
             buyer.total_shares -= tx.quantity
diff --git a/simulation/systems/handlers/stock_handler.py b/simulation/systems/handlers/stock_handler.py
index 044b4d00..afc5f2a9 100644
--- a/simulation/systems/handlers/stock_handler.py
+++ b/simulation/systems/handlers/stock_handler.py
@@ -38,27 +38,24 @@ class StockTransactionHandler(ITransactionHandler):
             return
 
         # 1. Seller Holdings
-        if isinstance(seller, Household):
+        if hasattr(seller, "portfolio"):
+            seller.portfolio.remove(firm_id, tx.quantity)
+        elif isinstance(seller, Household) and hasattr(seller, "shares_owned"):
+             # Legacy Fallback
             current_shares = seller.shares_owned.get(firm_id, 0)
             seller.shares_owned[firm_id] = max(0, current_shares - tx.quantity)
             if seller.shares_owned[firm_id] <= 0 and firm_id in seller.shares_owned:
                 del seller.shares_owned[firm_id]
-            if hasattr(seller, "portfolio"):
-                seller.portfolio.remove(firm_id, tx.quantity)
         elif isinstance(seller, Firm) and seller.id == firm_id:
             # Firm selling its own treasury shares
             seller.treasury_shares = max(0, seller.treasury_shares - tx.quantity)
-        elif hasattr(seller, "portfolio"):
-            # Secondary market trade for Firms/Institutions
-            seller.portfolio.remove(firm_id, tx.quantity)
 
         # 2. Buyer Holdings
-        if isinstance(buyer, Household):
+        if hasattr(buyer, "portfolio"):
+            buyer.portfolio.add(firm_id, tx.quantity, tx.price)
+        elif isinstance(buyer, Household) and hasattr(buyer, "shares_owned"):
+            # Legacy Fallback
             buyer.shares_owned[firm_id] = buyer.shares_owned.get(firm_id, 0) + tx.quantity
-            if hasattr(buyer, "portfolio"):
-                buyer.portfolio.add(firm_id, tx.quantity, tx.price)
-                # Sync legacy dict
-                buyer.shares_owned[firm_id] = buyer.portfolio.holdings[firm_id].quantity
         elif isinstance(buyer, Firm) and buyer.id == firm_id:
             # Firm buying back shares (Treasury)
             buyer.treasury_shares += tx.quantity
diff --git a/simulation/systems/inheritance_manager.py b/simulation/systems/inheritance_manager.py
index ec99155e..1f8572a0 100644
--- a/simulation/systems/inheritance_manager.py
+++ b/simulation/systems/inheritance_manager.py
@@ -85,34 +85,28 @@ class InheritanceManager:
                     price = current_prices.get(firm_id, 0.0)
                     proceeds = round(share.quantity * price, 2)
 
-                    # Execute Atomic Transfer: Gov Cash -> Deceased Cash (Simulated)
-                    # We use settlement_system.transfer to maintain zero-sum
-                    if settlement_system.transfer(government, deceased, proceeds, "liquidation_stock", tick=current_tick):
-                        # Update Asset Ownership
-                        # Deceased -> Government (or Market/System)
-                        # Remove from Deceased Portfolio
-                        del deceased._econ_state.portfolio.holdings[firm_id]
+                    # TD-232: Use TransactionProcessor for atomic execution + side effects
+                    tx = Transaction(
+                        buyer_id=government.id,
+                        seller_id=deceased.id,
+                        item_id=f"stock_{firm_id}",
+                        quantity=share.quantity,
+                        price=price,
+                        market_id="stock_market",
+                        transaction_type="asset_liquidation",
+                        time=current_tick,
+                        metadata={"executed": False}
+                    )
+
+                    results = simulation.transaction_processor.execute(simulation.world_state, [tx])
+
+                    if results and results[0].success:
+                        # Success - proceeds have been transferred and assets moved by Handler
                         if firm_id in portfolio_holdings:
                              del portfolio_holdings[firm_id] # Keep local copy in sync
 
-                        # Add to Government Portfolio (if Government holds stocks)
-                        # Or assume destroyed/market absorption.
-                        # For zero-sum asset integrity, someone must hold it.
-                        # Let's assign to Government for now (Escheatment logic).
-                        pass # Gov portfolio update skipped for brevity or handled by caller if Gov is agent
-
-                        # Record TX
-                        tx = Transaction(
-                            buyer_id=government.id,
-                            seller_id=deceased.id,
-                            item_id=f"stock_{firm_id}",
-                            quantity=share.quantity,
-                            price=price,
-                            market_id="stock_market",
-                            transaction_type="asset_liquidation",
-                            time=current_tick,
-                            metadata={"executed": True}
-                        )
+                        # Mark as executed for reporting
+                        tx.metadata["executed"] = True
                         transactions.append(tx)
 
                         cash += proceeds
@@ -126,30 +120,24 @@ class InheritanceManager:
                 for unit in list(deceased_units):
                     sale_price = round(unit.estimated_value * fire_sale_ratio, 2)
 
-                    if settlement_system.transfer(government, deceased, sale_price, "liquidation_re", tick=current_tick):
-                        # Update Ownership (Manual update required for immediate cash flow logic)
-                        unit.owner_id = government.id
+                    # TD-232: Use TransactionProcessor
+                    tx = Transaction(
+                        buyer_id=government.id,
+                        seller_id=deceased.id,
+                        item_id=f"real_estate_{unit.id}",
+                        quantity=1.0,
+                        price=sale_price,
+                        market_id="real_estate_market",
+                        transaction_type="asset_liquidation",
+                        time=current_tick,
+                        metadata={"executed": False}
+                    )
 
-                        # Fix Leak: Update owned_properties lists
-                        if hasattr(deceased, "owned_properties") and unit.id in deceased.owned_properties:
-                            deceased.owned_properties.remove(unit.id)
-                        if hasattr(government, "owned_properties"):
-                             if unit.id not in government.owned_properties:
-                                government.owned_properties.append(unit.id)
+                    results = simulation.transaction_processor.execute(simulation.world_state, [tx])
 
+                    if results and results[0].success:
                         deceased_units.remove(unit)
-
-                        tx = Transaction(
-                            buyer_id=government.id,
-                            seller_id=deceased.id,
-                            item_id=f"real_estate_{unit.id}",
-                            quantity=1.0,
-                            price=sale_price,
-                            market_id="real_estate_market",
-                            transaction_type="asset_liquidation",
-                            time=current_tick,
-                            metadata={"executed": True}
-                        )
+                        tx.metadata["executed"] = True
                         transactions.append(tx)
 
                         cash += sale_price
@@ -200,7 +188,7 @@ class InheritanceManager:
             # Escheat remaining Assets
             # Portfolio Transfer is handled by SettlementSystem (Atomic).
 
-            # Real Estate Transfer (Deferred via AssetTransferHandler)
+            # Real Estate Transfer (Execute Synchronously)
             for unit in deceased_units:
                  tx = Transaction(
                         buyer_id=government.id,
@@ -213,7 +201,11 @@ class InheritanceManager:
                         time=current_tick,
                         metadata={"executed": False}
                      )
-                 transactions.append(tx)
+
+                 results = simulation.transaction_processor.execute(simulation.world_state, [tx])
+                 if results and results[0].success:
+                     tx.metadata["executed"] = True
+                     transactions.append(tx)
 
         else:
             # Distribute to Heirs
@@ -228,11 +220,10 @@ class InheritanceManager:
             # Portfolio Transfer is handled by SettlementSystem (Atomic) to the designated heir (Primary).
             # Note: This changes from equal split to single heir for portfolio assets to ensure atomicity.
 
-            # Distribute Real Estate (Round Robin)
+            # Distribute Real Estate (Round Robin - Synchronous)
             for i, unit in enumerate(deceased_units):
                 recipient = heirs[i % count]
-                # We do NOT set unit.owner_id here manually.
-                # AssetTransferHandler will handle it when processing the transaction.
+
                 tx = Transaction(
                         buyer_id=recipient.id,
                         seller_id=deceased.id,
@@ -244,7 +235,11 @@ class InheritanceManager:
                         time=current_tick,
                         metadata={"executed": False}
                      )
-                transactions.append(tx)
+
+                results = simulation.transaction_processor.execute(simulation.world_state, [tx])
+                if results and results[0].success:
+                    tx.metadata["executed"] = True
+                    transactions.append(tx)
 
         # 5. Execute Settlement (Cash)
         # ------------------------------------------------------------------
diff --git a/tests/unit/components/test_finance_department_bankruptcy.py b/tests/unit/components/test_finance_department_bankruptcy.py
index ab26cc92..61a839d3 100644
--- a/tests/unit/components/test_finance_department_bankruptcy.py
+++ b/tests/unit/components/test_finance_department_bankruptcy.py
@@ -2,6 +2,7 @@ import pytest
 from unittest.mock import MagicMock
 from simulation.components.finance_department import FinanceDepartment
 from simulation.firms import Firm
+from modules.system.api import DEFAULT_CURRENCY
 
 class TestFinanceDepartmentBankruptcy:
     @pytest.fixture
@@ -32,12 +33,12 @@ class TestFinanceDepartmentBankruptcy:
         # Threshold is 5.
         # Simulate 4 losses
         for _ in range(4):
-            finance.current_profit = -100.0
+            finance.current_profit[DEFAULT_CURRENCY] = -100.0
             finance.check_bankruptcy()
             assert not firm.is_bankrupt
 
         # 5th loss
-        finance.current_profit = -100.0
+        finance.current_profit[DEFAULT_CURRENCY] = -100.0
         finance.check_bankruptcy()
         assert firm.is_bankrupt
 
@@ -55,12 +56,12 @@ class TestFinanceDepartmentBankruptcy:
 
         # So firm should survive 6 losses.
         for _ in range(6):
-            finance.current_profit = -100.0
+            finance.current_profit[DEFAULT_CURRENCY] = -100.0
             finance.check_bankruptcy()
             assert not firm.is_bankrupt
 
         # 7th loss
-        finance.current_profit = -100.0
+        finance.current_profit[DEFAULT_CURRENCY] = -100.0
         finance.check_bankruptcy()
         assert firm.is_bankrupt
 
@@ -69,16 +70,16 @@ class TestFinanceDepartmentBankruptcy:
 
         # 3 losses
         for _ in range(3):
-            finance.current_profit = -100.0
+            finance.current_profit[DEFAULT_CURRENCY] = -100.0
             finance.check_bankruptcy()
 
         # 1 profit
-        finance.current_profit = 100.0
+        finance.current_profit[DEFAULT_CURRENCY] = 100.0
         finance.check_bankruptcy()
         assert finance.consecutive_loss_turns == 0
 
         # 3 losses again
         for _ in range(3):
-            finance.current_profit = -100.0
+            finance.current_profit[DEFAULT_CURRENCY] = -100.0
             finance.check_bankruptcy()
             assert not firm.is_bankrupt
diff --git a/tests/unit/systems/test_inheritance_manager.py b/tests/unit/systems/test_inheritance_manager.py
index a92f567a..c8ba0f20 100644
--- a/tests/unit/systems/test_inheritance_manager.py
+++ b/tests/unit/systems/test_inheritance_manager.py
@@ -22,6 +22,13 @@ class TestInheritanceManager:
         simulation.stock_market.get_daily_avg_price.return_value = 10.0
         simulation.government = MagicMock()
         simulation.real_estate_units = []
+
+        # TD-232: Mock TransactionProcessor
+        simulation.transaction_processor = MagicMock()
+        success_result = MagicMock()
+        success_result.success = True
+        simulation.transaction_processor.execute.return_value = [success_result]
+
         return simulation
 
     def create_household(self, id, assets=0.0):
@@ -47,6 +54,20 @@ class TestInheritanceManager:
 
         mocks.agents = {2: heir1, 3: heir2}
 
+        # Mock Settlement System Receipts
+        mocks.settlement_system.execute_settlement.return_value = [
+            {
+                "buyer_id": 1, "seller_id": 2, "item_id": "inheritance_distribution",
+                "quantity": 1.0, "price": 5000.0, "market_id": "system",
+                "transaction_type": "inheritance_distribution", "time": 0, "metadata": {"heir_ids": [2, 3]}
+            },
+            {
+                "buyer_id": 1, "seller_id": 3, "item_id": "inheritance_distribution",
+                "quantity": 1.0, "price": 5000.0, "market_id": "system",
+                "transaction_type": "inheritance_distribution", "time": 0, "metadata": {"heir_ids": [2, 3]}
+            }
+        ]
+
         txs = setup_manager.process_death(deceased, mocks.government, mocks)
 
         # Check for distribution tx
@@ -66,6 +87,15 @@ class TestInheritanceManager:
         deceased._bio_state.children_ids = [2, 3, 4]
         mocks.agents = {2: heir1, 3: heir2, 4: heir3}
 
+        # Mock Settlement System Receipts
+        mocks.settlement_system.execute_settlement.return_value = [
+            {
+                "buyer_id": 1, "seller_id": 2, "item_id": "inheritance_distribution",
+                "quantity": 1.0, "price": 33.33, "market_id": "system",
+                "transaction_type": "inheritance_distribution", "time": 0, "metadata": {"heir_ids": [2, 3, 4]}
+            }
+        ]
+
         txs = setup_manager.process_death(deceased, mocks.government, mocks)
 
         dist_tx = next((t for t in txs if t.transaction_type == "inheritance_distribution"), None)
@@ -77,6 +107,15 @@ class TestInheritanceManager:
         deceased = self.create_household(1, assets=1000.0)
         deceased._bio_state.children_ids = [] # No children
 
+        # Mock Settlement System Receipts
+        mocks.settlement_system.execute_settlement.return_value = [
+            {
+                "buyer_id": 1, "seller_id": mocks.government.id, "item_id": "escheatment_cash",
+                "quantity": 1.0, "price": 1000.0, "market_id": "system",
+                "transaction_type": "escheatment", "time": 0, "metadata": {}
+            }
+        ]
+
         txs = setup_manager.process_death(deceased, mocks.government, mocks)
 
         # Expect Escheatment transactions
@@ -92,6 +131,15 @@ class TestInheritanceManager:
         deceased._bio_state.children_ids = [2]
         mocks.agents = {2: heir1}
 
+        # Mock Settlement System Receipts
+        mocks.settlement_system.execute_settlement.return_value = [
+            {
+                "buyer_id": 1, "seller_id": 2, "item_id": "inheritance_distribution",
+                "quantity": 1.0, "price": 0.0, "market_id": "system",
+                "transaction_type": "inheritance_distribution", "time": 0, "metadata": {"heir_ids": [2]}
+            }
+        ]
+
         txs = setup_manager.process_death(deceased, mocks.government, mocks)
 
         # Still expects distribution tx to handle potential cleanup or signaling
@@ -110,6 +158,15 @@ class TestInheritanceManager:
         deceased._bio_state.children_ids = [2]
         mocks.agents = {2: heir1}
 
+        # Mock Settlement System Receipts
+        mocks.settlement_system.execute_settlement.return_value = [
+            {
+                "buyer_id": 1, "seller_id": mocks.government.id, "item_id": "inheritance_tax",
+                "quantity": 1.0, "price": 500.0, "market_id": "system",
+                "transaction_type": "tax", "time": 0, "metadata": {}
+            }
+        ]
+
         txs = setup_manager.process_death(deceased, mocks.government, mocks)
 
         tax_tx = next((t for t in txs if t.transaction_type == "tax"), None)
