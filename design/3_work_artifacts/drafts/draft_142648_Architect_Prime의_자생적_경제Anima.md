```python
# modules/system/api.py
from __future__ import annotations
from typing import TypedDict, List, Dict, Optional, Protocol, Any
from enum import Enum

# --- DTOs for Market Stability Signals ---

class MarketSignalDTO(TypedDict):
    """
    Provides agents with essential, pre-calculated signals about a specific market's state.
    This is passed within the MarketSnapshotDTO to maintain data purity.
    """
    market_id: str
    item_id: str
    best_bid: Optional[float]
    best_ask: Optional[float]
    last_traded_price: Optional[float]
    price_history_7d: List[float] # Rolling 7-tick price history
    volatility_7d: float # Standard deviation of price_history_7d
    order_book_depth_buy: int # Number of buy orders
    order_book_depth_sell: int # Number of sell orders
    is_frozen: bool # True if circuit breaker is active or no trades are occurring

# --- DTOs and Interfaces for Public Manager (Asset Recovery) ---

class AssetRecoveryType(Enum):
    """The type of asset being recovered from a bankrupt agent."""
    INVENTORY = "INVENTORY"
    DURABLE = "DURABLE"
    PROPERTY = "PROPERTY"
    SHARES = "SHARES"

class RecoveredAssetDTO(TypedDict):
    """Represents a single asset recovered from a bankrupt agent."""
    asset_type: AssetRecoveryType
    item_id: str
    quantity: float
    quality: float
    original_owner_id: int

class AgentBankruptcyEventDTO(TypedDict):
    """
    An event payload broadcast when an agent goes bankrupt.
    The PublicManager listens for this event.
    """
    tick: int
    agent_id: int
    assets_at_bankruptcy: float
    liabilities_at_bankruptcy: float
    inventory: Dict[str, float] # item_id -> quantity
    durable_assets: List[Dict[str, Any]]
    # Potentially add portfolio, properties etc.

class PublicManagerReportDTO(TypedDict):
    """A report generated by the Public Manager each tick."""
    tick: int
    newly_recovered_assets: int
    assets_liquidated_count: int
    liquidation_revenue: float
    current_managed_inventory: Dict[str, float]


class IAssetRecoverySystem(Protocol):
    """
    Interface for the system responsible for managing assets of bankrupt agents.
    This system is NOT an agent and operates at the system level.
    """

    def process_bankruptcy_event(self, event: AgentBankruptcyEventDTO) -> None:
        """
        Receives a bankruptcy event and takes ownership of the defunct agent's assets.
        This method should transfer assets into the manager's custody.
        """
        ...

    def generate_liquidation_orders(self, market_signals: Dict[str, MarketSignalDTO]) -> List["Order"]:
        """
        Analyzes the current market state and its own inventory to generate sell orders.
        This is called by the simulation engine during a specific phase to avoid circular dependencies.
        Returns a list of Orders to be placed in the next tick's matching phase.
        """
        ...

    def get_status_report(self) -> PublicManagerReportDTO:
        """Returns a DTO summarizing the manager's activities for the current tick."""
        ...

# --- Modifications to Existing DTOs ---

class MarketSnapshotDTO(TypedDict):
    """
    [MODIFIED] A snapshot of all relevant market data for a given tick.
    Now includes the new MarketSignalDTO.
    """
    tick: int
    market_data: Dict[str, Any] # Legacy market data
    market_signals: Dict[str, MarketSignalDTO] # item_id -> signal_dto

class DecisionContext(TypedDict):
    """
    [MODIFIED] The complete context provided to a decision engine.
    The market_snapshot field is updated to the new structure.
    """
    state: "HouseholdStateDTO" # or FirmStateDTO
    config: "HouseholdConfigDTO" # or FirmConfigDTO
    goods_data: List[Dict[str, Any]]
    market_snapshot: MarketSnapshotDTO
    current_time: int
    # ... other existing fields
```

```markdown
# SPECIFICATION: Animal Spirits (SPEC_ANIMAL_SPIRITS)

**Objective**: This specification retires the artificial 'Price Arbitrator' and introduces more organic, agent-driven economic behaviors to create a self-stabilizing market. It focuses on implementing survival instincts in households, robust pricing logic in firms, and systemic resilience through asset preservation.

---

## 1. Household Survival Override

This logic allows households to prioritize survival needs above all else, preventing death by starvation when they have the means to purchase food.

- **Location**: `modules.household.decisions.AIDrivenHouseholdDecisionEngine`
- **Trigger**: Before standard decision-making, check if `state.needs['survival'] > config.survival_need_emergency_threshold`.

### 1.1. Logic (Pseudo-code)

```python
# In AIDrivenHouseholdDecisionEngine.make_decisions

survival_need = context.state.needs.get('survival', 0)
emergency_threshold = context.config.survival_need_emergency_threshold
food_id = "food" # Assuming a primary survival good

if survival_need > emergency_threshold:
    # --- SURVIVAL OVERRIDE ACTIVATED ---
    
    # 1. Find the cheapest available food
    market_signal = context.market_snapshot.market_signals.get(food_id)
    
    if market_signal and market_signal.best_ask is not None:
        # We have a price signal.
        ask_price = market_signal.best_ask
        
        # 2. Can we afford it?
        if context.state.assets >= ask_price:
            
            # 3. Create an aggressive BUY order to ensure fulfillment
            # Bid slightly above the ask price to jump the queue.
            bid_price = ask_price * (1 + context.config.survival_bid_premium)
            
            # Buy enough to satisfy the immediate need.
            quantity_to_buy = 1.0 
            
            survival_order = Order(
                agent_id=context.state.id,
                item_id=food_id,
                order_type="BUY",
                quantity=quantity_to_buy,
                price=bid_price
            )
            
            # Log this override action
            self.logger.warning(f"SURVIVAL_OVERRIDE: Agent {context.state.id} bidding {bid_price} for food.")
            
            # Return ONLY the survival order, skipping all other decisions.
            return [survival_order], ("SURVIVAL", "MAX")
            
# If override not triggered or cannot be executed, proceed to normal decision logic...
return self.run_normal_decision_flow(context)
```

## 2. Firm Pricing Logic: Cost-Plus & Fire-Sale

This provides firms with robust pricing strategies for situations with high uncertainty or financial distress.

- **Location**: `modules.firm.decisions.AIDrivenFirmDecisionEngine`

### 2.1. Cost-Plus Fallback (Pseudo-code)

This logic is used when placing SELL orders if market price signals are unreliable.

```python
# In Firm decision logic for setting sell price

item_id = "product_a"
market_signal = context.market_snapshot.market_signals.get(item_id)
production_cost = self.calculate_unit_cost(item_id, context.state) # Includes labor, materials

# Check if market signal is unreliable
is_unreliable = (
    market_signal is None or 
    market_signal.last_traded_price is None or
    (context.current_time - market_signal.last_trade_tick) > config.max_price_staleness_ticks
)

if is_unreliable:
    # --- COST-PLUS FALLBACK ---
    target_margin = context.config.default_target_margin
    sell_price = production_cost * (1 + target_margin)
    self.logger.info(f"COST_PLUS: Firm {context.state.id} using cost-plus pricing for {item_id}: {sell_price}")
else:
    # Use normal market-following logic
    sell_price = market_signal.last_traded_price * (1 + dynamic_margin)

# create_sell_order(item_id, sell_price, ...)
```

### 2.2. Fire-Sale Logic (Pseudo-code)

This logic generates additional, discounted SELL orders when the firm is in financial distress.

```python
# In Firm decision logic, after primary orders are decided

is_distressed = (
    context.state.assets < context.config.fire_sale_asset_threshold and
    context.state.inventory[item_id] > context.config.fire_sale_inventory_threshold
)

if is_distressed:
    # --- FIRE-SALE ACTIVATED ---
    market_signal = context.market_snapshot.market_signals.get(item_id)
    
    # Determine a discount price
    if market_signal and market_signal.best_bid is not None:
        # Undercut the highest buyer
        fire_sale_price = market_signal.best_bid * (1 - context.config.fire_sale_discount)
    else:
        # No buyers, fall back to a discount on our own cost
        fire_sale_price = production_cost * (1 - context.config.fire_sale_cost_discount)
        
    # Sell off excess inventory
    quantity_to_sell = context.state.inventory[item_id] - context.config.fire_sale_inventory_target
    
    fire_sale_order = Order(
        agent_id=context.state.id,
        item_id=item_id,
        order_type="SELL",
        quantity=quantity_to_sell,
        price=max(0.01, fire_sale_price) # Don't sell for free
    )
    
    self.logger.warning(f"FIRE_SALE: Firm {context.state.id} selling {quantity_to_sell} of {item_id} at {fire_sale_price}")
    
    # Add this order to the list of orders for this tick
    orders.append(fire_sale_order)
```

## 3. Market: Circuit Breaker Relaxation

To prevent market seizure at the start of the simulation, the circuit breaker's bounds will be widened when price history is sparse.

- **Location**: `simulation.markets.order_book_market.OrderBookMarket.get_dynamic_price_bounds`
- **Logic**: Modify the existing method to check the length of the price history.

### 3.1. Logic (Pseudo-code)

```python
# In OrderBookMarket.get_dynamic_price_bounds

min_history_len = self.config_module.CIRCUIT_BREAKER_MIN_HISTORY
if item_id not in self.price_history or len(self.price_history[item_id]) < min_history_len:
    # --- WIDENED BOUNDS ---
    # Return very wide or infinite bounds to allow initial price discovery
    return 0.0, float('inf')

# ... existing logic for calculating bounds based on volatility ...
history = list(self.price_history[item_id])
mean_price = sum(history) / len(history)

# [Slight Modification]: The volatility adjustment itself can be dampened if desired
# volatility_adj = 1.0 + ( (std_dev / mean_price) * self.config_module.VOLATILITY_DAMPENING_FACTOR )

# ... existing logic continues ...
```

## 4. System: Public Manager for Asset Preservation

This system-level entity prevents value destruction from bankruptcy by recovering and liquidating assets in an orderly manner.

- **Entity**: `PublicManager`, a new class implementing `IAssetRecoverySystem`. It will be managed by the main `Simulation` object.
- **Trigger**: `Simulation` detects an agent's bankruptcy (`agent.assets < 0`) and emits an `AgentBankruptcyEventDTO`.
- **Execution Phase**: The `PublicManager`'s actions are executed in a new, dedicated phase of the simulation tick to avoid circular dependencies.
    1. `process_bankruptcy_event`: Called immediately when an agent is marked for removal.
    2. `generate_liquidation_orders`: Called *after* agent decisions but *before* market matching.

### 4.1. Process Flow (Pseudo-code)

```python
# --- In Simulation Loop ---

# Phase 4: Lifecycle (where bankruptcy is determined)
for agent in all_agents:
    if agent.assets < 0 and agent.is_active:
        agent.is_active = False
        # Create and broadcast event
        event = create_bankruptcy_event_dto(agent)
        public_manager.process_bankruptcy_event(event)
        # Mark agent for removal from simulation

# NEW Phase 4.5: Asset Liquidation
market_signals = system_monitor.get_market_signals()
liquidation_orders = public_manager.generate_liquidation_orders(market_signals)
for order in liquidation_orders:
    market.place_order(order, current_time)

# Phase 5: Market Matching (was Phase 2)
# The liquidation orders are now in the order book to be matched.

# --- In PublicManager class ---

class PublicManager(IAssetRecoverySystem):
    def __init__(self):
        self.managed_inventory: Dict[str, float] = defaultdict(float)
        # ... other asset stores

    def process_bankruptcy_event(self, event: AgentBankruptcyEventDTO):
        # Transfer inventory
        for item_id, quantity in event.inventory.items():
            self.managed_inventory[item_id] += quantity
        
        self.logger.info(f"PUBLIC_MANAGER: Recovered assets from bankrupt agent {event.agent_id}")

    def generate_liquidation_orders(self, market_signals: Dict[str, MarketSignalDTO]) -> List[Order]:
        orders = []
        for item_id, quantity in self.managed_inventory.items():
            if quantity <= 0: continue

            market_signal = market_signals.get(item_id)
            if market_signal and market_signal.best_ask is not None:
                # Create a sell order slightly below the current best ask to ensure it sells,
                # but don't crash the market.
                sell_price = market_signal.best_ask * (1 - self.config.liquidation_ask_undercut)
                
                # Sell only a portion of the inventory per tick to avoid flooding.
                sell_quantity = quantity * self.config.liquidation_sell_rate
                
                order = Order(
                    agent_id="PUBLIC_MANAGER", # Special ID
                    item_id=item_id,
                    order_type="SELL",
                    quantity=sell_quantity,
                    price=max(0.01, sell_price)
                )
                orders.append(order)
                
                # Decrement tracked inventory (it will be fully removed once transaction is confirmed)
                self.managed_inventory[item_id] -= sell_quantity
        return orders
```

## 5. DTO & Interface Summary

The following APIs will be created in `modules/system/api.py`:

- **`MarketSignalDTO`**: A DTO passed within `MarketSnapshotDTO` containing pre-calculated market health indicators (`best_bid`, `best_ask`, `volatility_7d`, etc.) to ensure agent decision logic remains pure.
- **`AgentBankruptcyEventDTO`**: A data object broadcast by the system upon agent bankruptcy, containing the agent's final asset state.
- **`PublicManagerReportDTO`**: A DTO for reporting the Public Manager's activities.
- **`IAssetRecoverySystem`**: A protocol defining the `PublicManager`'s responsibilities, including `process_bankruptcy_event` and `generate_liquidation_orders`.
- **`MarketSnapshotDTO` (Modified)**: Will be updated to include a dictionary of `MarketSignalDTO`s.

## 6. Verification Plan

1.  **Unit Tests**:
    - `TestHouseholdSurvivalOverride`: Simulate a household with high survival need and assets. Verify it generates an aggressive BUY order for food, ignoring other options.
    - `TestFirmPricingLogic`:
        - Test `Cost-Plus`: Create a firm in a market with no price history. Verify its sell order price is `cost * (1 + margin)`.
        - Test `Fire-Sale`: Simulate a firm with low cash and high inventory. Verify it generates an additional, discounted SELL order.
    - `TestPublicManager`:
        - Trigger a bankruptcy event. Verify the `PublicManager` correctly inventories the defunct agent's assets.
        - In a subsequent step, provide market signals and verify it generates appropriate, non-market-crashing SELL orders.
2.  **Integration Tests**:
    - A full simulation run with the new logic. The primary success metric is the **absence of `CIRCUIT_BREAKER` seizures and a non-zero GDP** after the initial ticks.
    - The `scripts/trace_leak.py` script **MUST** be run to ensure the `PublicManager` does not introduce money supply leaks.
3.  **Golden Fixture Regeneration**: The introduction of these fundamental behaviors will invalidate nearly all existing economic outcome tests. A full regeneration of golden fixtures using `scripts/fixture_harvester.py` is mandatory after implementation. The spec must budget time for this activity.

## 7. Risk & Impact Audit (Response to Pre-flight Check)

This design explicitly addresses the risks identified in the `AUTO-AUDIT FINDINGS`.

- **1. Architectural Purity**: The design strictly adheres to the purity mandate. All agent logic (Survival, Cost-Plus, Fire-Sale) relies on the new **`MarketSignalDTO`** passed within the `DecisionContext`. Agents **do not** call `market.get_best_bid()` or any other live market methods. The responsibility of calculating these signals is shifted to a system-level observer that prepares the `MarketSnapshotDTO`.

- **2. God Class Refactoring (`Household`)**: The "Survival Override" logic is placed within the **`AIDrivenHouseholdDecisionEngine`**, not the `Household` facade. This correctly separates the "brain" (decision logic) from the "body" (state representation). It preempts the normal decision flow rather than getting entangled in the problematic `update_needs` method.

- **3. Systemic Integrity (`PublicManager`)**: The `PublicManager` is designed as a **system-level service**, not an agent. Its logic is executed in a distinct phase (`Phase 4.5: Asset Liquidation`) after agent decisions and before market matching. This breaks the potential for circular dependencies. Its asset handling is a pure transfer, and proceeds from liquidation can be tracked by a system-level treasury to ensure **Zero-Sum Integrity is maintained** and verifiable by `trace_leak.py`.

- **4. Market Stability & Test Invalidation**: The specification acknowledges that these changes will fundamentally alter market dynamics.
    - The "Circuit Breaker Relaxation" is implemented as proposed in `OrderBookMarket.get_dynamic_price_bounds`.
    - The **Verification Plan (Section 6)** explicitly states that existing tests will be invalidated and mandates a **full review and regeneration of GoldenLoader fixtures** as a required work item.
```
