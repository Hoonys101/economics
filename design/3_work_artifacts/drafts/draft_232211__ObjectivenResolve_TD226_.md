# Spec: Government Agent Decoupling & WelfareManager Extraction
- **Mission**: `TD-226`, `TD-227`, `TD-228`, `TD-300`
- **Author**: Scribe (Gemini)
- **Approver**: Antigravity (Team Leader Review Required)

## 1. Overview & Goals
This document outlines the refactoring of the `Government` agent to resolve critical technical debt related to high coupling, SRP violations, and unstable data contracts.

The primary goals are:
1.  **Decouple Components**: Extract `Welfare` and `Tax` logic into independent, stateless services, eliminating circular dependencies as mandated by **TD-226** and **TD-227**.
2.  **Enforce SRP**: Create a new `WelfareManager` responsible *only* for welfare and subsidies. The `TaxService` will be the single authority for all tax-related logic, resolving **TD-228**.
3.  **Stabilize Contracts**: Introduce strict DTOs for all communication between the agent and its services, preventing runtime errors and defensive coding as noted in **TD-300**.

## 2. Architectural Vision: Before & After

### Before: "God Agent" with Circular Dependencies
The `Government` agent directly instantiated components, passing its own instance (`self`) to them, creating a tangled, untestable web of dependencies.

- `Government` -> `WelfareService(self)` // Circular dependency
- `Government.run_welfare_check()` // Handles both Tax and Welfare (SRP Violation)
- Data passed as `Dict[str, Any]` // Unstable contract

### After: Decoupled Orchestrator
The `Government` agent acts as a pure orchestrator. It calls independent services which return data requests (DTOs). The agent is solely responsible for executing state changes (e.g., wallet transfers).

- `Government` -> `IWelfareManager` (Unidirectional)
- `Government` -> `ITaxService` (Unidirectional)
- `IWelfareManager` returns `WelfareResultDTO` (a request for payment)
- `ITaxService` returns `TaxCollectionResultDTO` (a request for payment)
- The agent's `Phase_SocialPolicy` loop processes these requests.

## 3. DTO & API Design
The following changes will be made to `dtos.py` and `api.py` to establish the new, stable contracts.

### Proposed: `modules/government/dtos.py`
```python
from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any, Union
from simulation.ai.enums import PolicyActionTag
from modules.system.api import CurrencyCode, IAgent, FirmID, HouseholdID

# region: Existing DTOs (for context, no changes)
@dataclass
class TaxHistoryItemDTO:
    tick: int
    total: float
    tax_revenue: Dict[str, float]

@dataclass
class TaxBracketDTO:
    """Defines a single progressive tax bracket."""
    floor: float
    rate: float
    ceiling: Optional[float] # None for the highest bracket

@dataclass
class FiscalPolicyDTO:
    """State of the current fiscal policy."""
    progressive_tax_brackets: List[TaxBracketDTO]

@dataclass
class MonetaryPolicyDTO:
    """State of the current monetary policy."""
    target_interest_rate: float
    inflation_target: float
    unemployment_target: float

@dataclass
class GovernmentStateDTO:
    """The complete state of the Government agent."""
    id: int
    assets: float
    fiscal_policy: FiscalPolicyDTO
    monetary_policy: MonetaryPolicyDTO

@dataclass
class MacroEconomicSnapshotDTO:
    """Snapshot of macro-economic indicators for Monetary Policy."""
    inflation_rate: float
    nominal_gdp: float
    potential_gdp: float
    unemployment_rate: float

@dataclass
class PolicyActionDTO:
    """Represents a proposed government policy action."""
    name: str
    utility: float
    tag: PolicyActionTag
    action_type: str
    params: Dict[str, Any] = field(default_factory=dict)
# endregion

# region: NEW & REVISED DTOs for Decoupling (TD-300)

@dataclass
class PaymentRequestDTO:
    """
    A stateless request for a financial transfer.
    Generated by a service, executed by the agent holding the wallet.
    """
    payer: Union[IAgent, FirmID, HouseholdID]
    payee: Union[IAgent, FirmID, HouseholdID]
    amount: float
    currency: CurrencyCode
    memo: str

@dataclass
class TaxCollectionResultDTO:
    """Result from a tax collection operation, containing payment requests."""
    payment_requests: List[PaymentRequestDTO] = field(default_factory=list)
    total_collected: float = 0.0
    tax_type: str = ""

@dataclass
class WelfareResultDTO:
    """Result from a welfare check operation, containing payment requests."""
    payment_requests: List[PaymentRequestDTO] = field(default_factory=list)
    total_paid: float = 0.0

@dataclass
class BailoutResultDTO:
    """
    Result from a bailout evaluation, requesting the creation of a loan
    and the initial fund transfer.
    """
    loan_request: "BailoutLoanDTO" # The DTO defining the loan terms
    payment_request: PaymentRequestDTO # The initial transfer of funds

# endregion
```

### Proposed: `modules/government/api.py`
```python
from __future__ import annotations
from typing import Protocol, List, Any, Optional
from modules.government.dtos import (
    FiscalPolicyDTO,
    MonetaryPolicyDTO,
    GovernmentStateDTO,
    MacroEconomicSnapshotDTO,
    WelfareResultDTO,
    BailoutResultDTO,
    TaxCollectionResultDTO,
)
from simulation.dtos.api import MarketSnapshotDTO
from modules.system.api import IAgent

class IFiscalPolicyManager(Protocol):
    """Interface for managing the government's fiscal policy."""

    def determine_fiscal_stance(self, market_snapshot: "MarketSnapshotDTO") -> FiscalPolicyDTO:
        """Adjusts tax brackets based on economic conditions."""
        ...

    def calculate_tax_liability(self, policy: FiscalPolicyDTO, income: float) -> float:
        """Calculates the tax owed based on a progressive bracket system."""
        ...

class IMonetaryPolicyManager(Protocol):
    """Interface for managing the government's monetary policy (Central Bank)."""

    def determine_monetary_stance(self, market_snapshot: "MacroEconomicSnapshotDTO") -> MonetaryPolicyDTO:
        """Adjusts the target interest rate based on a Taylor-like rule."""
        ...

# region: NEW & REVISED Service Interfaces

class ITaxService(Protocol):
    """
    A stateless service responsible for all tax calculations and for generating
    tax collection requests.
    """
    def collect_wealth_tax(self, agents: List[IAgent]) -> TaxCollectionResultDTO:
        """
        Calculates wealth tax for all eligible agents and returns a DTO
        containing payment requests for the government to execute.
        """
        ...
    
    # ... other existing tax calculation methods ...

class IWelfareManager(Protocol):
    """
    A stateless service responsible for all welfare and subsidy logic.
    It does not hold state or have access to agent wallets.
    """
    def run_welfare_check(self, agents: List[IAgent], market_data: MarketSnapshotDTO, current_tick: int) -> WelfareResultDTO:
        """
        Identifies agents needing support and returns a DTO containing
        welfare payment requests for the government to execute.
        """
        ...

    def provide_firm_bailout(self, firm: IAgent, amount: float, current_tick: int, is_solvent: bool) -> Optional[BailoutResultDTO]:
        """
        Evaluates bailout eligibility and returns a DTO containing a loan request
        and a payment request. Returns None if not eligible.
        """
        ...
    
    def get_survival_cost(self, market_data: MarketSnapshotDTO) -> float:
        """Calculates current survival cost based on market prices."""
        ...

# endregion


class IGovernment(Protocol):
    """Facade for the government agent."""
    state: GovernmentStateDTO

    def make_policy_decision(self, market_snapshot: "MarketSnapshotDTO") -> None:
        ...
```

## 4. Agent Orchestration Logic
The `Government` agent's `run_welfare_check` method will be removed. A new orchestration method, likely called during a `Phase_SocialPolicy` tick phase, will replace it.

### Pseudo-code: `Government.execute_social_policy()`
```python
# In Government agent class
def execute_social_policy(self, agents: List[IAgent], market_data: MarketSnapshotDTO, current_tick: int):
    
    all_transactions = []
    
    # 1. Collect Wealth Tax (Responsibility of TaxService)
    # The service returns *requests*, not transactions.
    wealth_tax_result: TaxCollectionResultDTO = self.tax_service.collect_wealth_tax(agents)
    for request in wealth_tax_result.payment_requests:
        # The agent executes the transfer using its own wallet/settlement system
        success = self.settlement_system.transfer(
            payer=request.payer, 
            payee=request.payee, 
            amount=request.amount, 
            memo=request.memo
        )
        if success:
            self.record_revenue(...) # Update internal ledgers

    # 2. Run Welfare Checks (Responsibility of WelfareManager)
    # The service is stateless and cannot access the government's wallet.
    welfare_result: WelfareResultDTO = self.welfare_manager.run_welfare_check(agents, market_data, current_tick)
    for request in welfare_result.payment_requests:
        # The agent executes the transfer
        success = self.settlement_system.transfer(
            payer=self, # Government pays
            payee=request.payee,
            amount=request.amount,
            memo=request.memo
        )
        if success:
            self.record_expenditure(...)

    # ... Other social policies like bailouts would follow a similar pattern ...
```

## 5. Verification Plan (Addressing TD-229)
Due to low test coverage, a Test-Driven approach is mandatory.

1.  **Unit Tests for `WelfareManager`**:
    - Create `tests/modules/government/test_welfare_manager.py`.
    - Write tests for `run_welfare_check` and `provide_firm_bailout` in isolation.
    - **Mocking Strategy**: Use the existing `golden_households` and `golden_firms` pytest fixtures. **DO NOT** use `MagicMock` to create agents, as this hides schema mismatches.
    - **Assertions**: Verify that the methods return the correct `WelfareResultDTO` or `BailoutResultDTO` based on the golden fixture data.

2.  **Unit Tests for `TaxService`**:
    - Create `tests/modules/government/test_tax_service.py`.
    - Add tests for the new `collect_wealth_tax` method.
    - **Assertions**: Verify that the method returns the correct `TaxCollectionResultDTO`.

3.  **Integration Tests for `Government` Agent**:
    - Modify existing government tests or create `tests/agents/test_government_integration.py`.
    - **Goal**: Prove that the refactored `Government` agent, by orchestrating calls to the new mock services, produces the same net financial outcome (tax revenue, welfare spending) as the old, monolithic version.
    - A full simulation run with the new components should be compared against a baseline run to check for macroeconomic divergences.

## 6. Risk & Impact Audit
This section formally addresses the risks identified in the pre-flight audit.

-   **[TD-227] Circular Dependency**: **MITIGATED**. The new design is strictly unidirectional (`Agent -> Service`). Services are stateless and cannot call back to the agent. They return data (DTOs) instead of executing actions.

-   **[TD-228] SRP Violation**: **MITIGATED**. `run_welfare_check` is removed from the `Government` agent. `TaxService` now exclusively handles wealth tax, and the new `WelfareManager` exclusively handles welfare distribution, adhering to the Single Responsibility Principle.

-   **[TD-300] Unstable DTOs**: **MITIGATED**. The introduction of `PaymentRequestDTO`, `WelfareResultDTO`, and `TaxCollectionResultDTO` establishes a clear, typed, and stable contract for all interactions, eliminating the need for fragile `hasattr` or dictionary key checks.

-   **[TD-229] Low Test Coverage**: **RISK**. This remains the highest implementation risk. **MITIGATION** is the strict adherence to the TDD strategy outlined in the Verification Plan. Any PR for this change *must* include comprehensive unit and integration tests.

-   **[TD-226] Government God Class**: **MITIGATED**. The agent's role is reduced to orchestration. Core business logic is now delegated to independent, testable components.

## 7. [Routine] Insight Logging Mandate
During implementation, the assigned developer (Jules) **must** record any unforeseen challenges, architectural discoveries, or new technical debt in a dedicated markdown file: `communications/insights/TD-226_Gov_Decoupling.md`. This ensures that all learnings are captured for the post-mission review and `TECH_DEBT_LEDGER.md` update, preventing knowledge loss and cross-team conflicts.
