# Spec: TD-109 Sacred Sequence Normalization

**Version:** 1.0
**Date:** 2026-01-25
**Author:** Gemini (Administrative Assistant)

## 1. Introduction

### 1.1. Goal
This document outlines the architectural refactoring required to enforce the "Sacred Sequence" principle. All direct, out-of-phase financial state modifications will be converted into auditable `Transaction` objects processed within the designated transaction phase. This addresses the violations identified in `TD-109_SEQUENCE_PROFILE.md`.

### 1.2. Scope
This refactoring impacts the following systems and their interactions with financial state:
- `TickScheduler`: The orchestrator of the simulation tick.
- `Government`: Specifically `invest_infrastructure`.
- `Bank`: Specifically `check_solvency`.
- `InheritanceManager`: The entire `process_death` workflow.

This design explicitly addresses the risks and constraints identified in the `TD-109 Pre-flight Audit`.

---

## 2. Core Architectural Changes

To manage the transition from synchronous to asynchronous operations, two new architectural components will be introduced.

### 2.1. New Component: `WorldState.inter_tick_queue`
A new queue will be added to the `WorldState` to handle transactions that are generated in one tick but must be executed in the *next*.

- **Type**: `List[Transaction]`
- **Location**: `simulation.world_state.WorldState`
- **Responsibility**: To hold transactions generated by the `InheritanceManager` and `Bank` solvency checks, ensuring their settlement is deferred.
- **Interaction**:
    - The `TickScheduler` will populate this queue during the current tick (`_phase_lifecycle`).
    - At the start of the *next* tick, the `TickScheduler` will drain this queue and prepend its contents to the `system_transactions` list for processing.

### 2.2. New `TickScheduler` Phase: `_phase_pre_sequence_stabilization`
To mitigate the risk of a temporarily insolvent bank causing cascading failures, a new, very early phase is introduced.

- **Placement**: Executed at the absolute start of `run_tick`, before any other system or agent logic.
- **Responsibility**: To process critical, system-stabilizing transactions generated in the *previous* tick. Its primary use case is executing the "Lender of Last Resort" transaction for the bank.
- **Logic**: This phase will have its own dedicated `TransactionProcessor.execute()` call for a very limited set of transactions tagged for stabilization.

---

## 3. Module Refactoring Plan

### 3.1. `simulation.tick_scheduler.py`

The `TickScheduler` will be modified to orchestrate the new asynchronous flow.

#### 3.1.1. `run_tick` Method Modification:
- **At the start of `run_tick`**:
    1.  **Add `_phase_pre_sequence_stabilization`**:
        -   Create a `stabilization_txs` list.
        -   Call a new `bank.generate_solvency_transactions()` method, which checks solvency from the *end of the previous tick* and returns a `lender_of_last_resort` transaction if needed.
        -   Execute these transactions immediately using the `TransactionProcessor`. This ensures the `bank` is solvent before any agent decisions.
    2.  **Integrate `inter_tick_queue`**:
        -   Drain `world_state.inter_tick_queue` into the `system_transactions` list *before* other system transactions (like interest and wages) are generated. This ensures inheritance settlements from the previous tick are processed early.

- **In `_phase_lifecycle`**:
    1.  The call to `lifecycle_manager.execute()` will now return a list of transactions generated by the `InheritanceManager`.
    2.  Instead of processing these immediately, append them to the `world_state.inter_tick_queue`.

#### Pseudo-code for `run_tick` changes:
```python
# In TickScheduler.run_tick
def run_tick(self, ...):
    state = self.world_state

    # [NEW] Phase 0A: Pre-Sequence Stabilization
    self._phase_pre_sequence_stabilization(state)

    state.time += 1
    ...

    # [MODIFIED] Transaction Generation Phase
    system_transactions: List[Transaction] = []

    # [NEW] Drain inter-tick queue from previous tick's lifecycle events
    system_transactions.extend(state.inter_tick_queue)
    state.inter_tick_queue.clear()

    # ... existing system transaction generation (bank interest, firm wages, etc.)
    bank_txs = state.bank.run_tick(...)
    system_transactions.extend(bank_txs)
    ...
    infra_txs = state.government.invest_infrastructure(...) # Now returns List[Transaction]
    system_transactions.extend(infra_txs)
    ...

    # [MODIFIED] Lifecycle Phase
    self._phase_lifecycle(sim_state) # No longer returns transactions directly

# In TickScheduler._phase_lifecycle
def _phase_lifecycle(self, state: SimulationState) -> None:
    if self.world_state.lifecycle_manager:
        # [NEW] LifecycleManager now returns transactions from inheritance
        inheritance_txs = self.world_state.lifecycle_manager.execute(state)
        # [NEW] Queue transactions for the *next* tick
        state.inter_tick_queue.extend(inheritance_txs)
    ...

# [NEW] _phase_pre_sequence_stabilization
def _phase_pre_sequence_stabilization(self, state: WorldState) -> None:
    # Called at the very end of the *previous* tick, this check generates a tx for *this* tick
    stabilization_txs = state.bank.generate_solvency_transactions(state.government)
    if stabilization_txs:
        # Create a temporary SimulationState DTO for the processor
        temp_sim_state = SimulationState(..., transactions=stabilization_txs)
        self.world_state.transaction_processor.execute(temp_sim_state)
        state.logger.warning("Executed pre-sequence stabilization for Bank.")

```

### 3.2. `simulation.agents.government.py`

#### 3.2.1. `invest_infrastructure` Method Refactoring:
- **Signature Change**: `invest_infrastructure(...) -> Tuple[bool, List[Transaction]]` becomes `invest_infrastructure(...) -> List[Transaction]`.
- **Logic**:
    1.  The function will no longer perform direct transfers via `settlement_system.transfer`.
    2.  It will continue to handle its own financing by calling `finance_system.issue_treasury_bonds_synchronous` if its own assets are insufficient. This financing step itself might generate transactions, which should be returned.
    3.  If financing is successful (or not needed), it will create and return a single `Transaction` object.
    4.  The side-effect (global TFP boost) will be removed from this function. It will be triggered by an event after the transaction is processed (see Verification Plan).

#### Pseudo-code for `invest_infrastructure`:
```python
# In Government
def invest_infrastructure(self, current_tick: int, reflux_system: Any) -> List[Transaction]:
    transactions = []
    effective_cost = ...

    # 1. Synchronous Financing (remains, but now may return bond transactions)
    if self.assets < effective_cost:
        # This synchronous call internally modifies self.assets
        success = self.finance_system.issue_treasury_bonds_synchronous(...)
        if not success:
            return [] # Return empty list if financing fails

    # 2. Generate the Investment Transaction
    investment_tx = Transaction(
        buyer_id=self.id,
        seller_id=reflux_system.id, # Target is the system sink
        item_id="infrastructure_investment",
        quantity=1,
        price=effective_cost,
        market_id="system",
        transaction_type="infrastructure_spending",
        time=current_tick,
        # [NEW] Metadata for side-effect
        metadata={"triggers_effect": "GLOBAL_TFP_BOOST"}
    )
    transactions.append(investment_tx)

    # DO NOT apply TFP boost here.
    # DO NOT call settlement_system.transfer here.

    return transactions
```

### 3.3. `simulation.bank.py`

#### 3.3.1. `check_solvency` Method Replacement:
- **Remove**: The `check_solvency` method will be removed.
- **New Method**: `generate_solvency_transactions(self, government: Government) -> List[Transaction]`. This method is called at the end of a tick to prepare for the *next* tick's stabilization phase.
- **Logic**:
    1.  If `self.assets < 0`, calculate the required `borrow_amount`.
    2.  Create a single `Transaction` of type `lender_of_last_resort`.
        -   This transaction represents the creation of new money. The `buyer` will be the `government` and the `seller` will be the `bank`, but the `TransactionProcessor` will treat this special type as a money injection for the `seller` without debiting the `buyer`.
    3.  Return a list containing this transaction. It will be executed in the next tick's `_phase_pre_sequence_stabilization`.

#### Pseudo-code for `generate_solvency_transactions`:
```python
# In Bank
def generate_solvency_transactions(self, government: Government) -> List[Transaction]:
    if self.assets < 0:
        borrow_amount = abs(self.assets) + 1000.0 # Buffer

        tx = Transaction(
            buyer_id=government.id, # Symbolic buyer (source of minting)
            seller_id=self.id,      # Recipient of funds
            item_id="lender_of_last_resort",
            quantity=1,
            price=borrow_amount,
            market_id="system_stabilization",
            transaction_type="money_creation",
            time=0 # Tick will be updated by scheduler
        )
        logger.warning(f"INSOLVENT: Generating Lender of Last Resort tx for {borrow_amount:.2f}")
        return [tx]

    return []
```

### 3.4. `simulation.systems.inheritance_manager.py`

#### 3.4.1. `process_death` Method Refactoring:
- **Signature Change**: `process_death(...) -> None` becomes `process_death(...) -> List[Transaction]`.
- **Logic**: The entire method will be rewritten to be non-state-modifying. It will perform valuation and then generate an ordered list of `Transaction` objects to be queued for the next tick.
- **State Management**: The deceased agent's assets are conceptually "frozen". The transactions will source from the deceased's ID, and the `TransactionProcessor` must be able to handle transfers from an inactive agent.

#### Transaction Choreography:
The method will return a list of transactions in a precise order to ensure correct settlement:
1.  **Liquidation Transactions**:
    -   For each stock holding: create a `Transaction` to sell the stock. The buyer is the `government` (acting as market maker of last resort).
    -   For each real estate unit: create a `Transaction` to sell the property. Buyer is `government`.
2.  **Tax Transaction**:
    -   Create one `Transaction` to transfer the calculated `tax_amount` from the deceased to the `government`.
3.  **Distribution Transactions**:
    -   For each heir: create `Transaction` objects to transfer their share of the remaining cash, stocks, and real estate. These will be `asset_transfer` types.
    -   If no heirs, create `escheatment` transactions to transfer all remaining assets to the government.

#### Pseudo-code for `process_death`:
```python
# In InheritanceManager
def process_death(self, deceased: Household, ...) -> List[Transaction]:
    transactions = []
    current_tick = simulation.time

    # 1. Valuation (No changes, read-only)
    total_wealth, cash, stock_value, re_value = self.valuate_estate(...)
    tax_amount = self.calculate_tax(...)

    # 2. Generate Liquidation Transactions (if needed)
    # These transactions represent the government buying the assets for cash
    cash_shortfall = tax_amount - cash
    if cash_shortfall > 0 and stock_value > 0:
        for firm_id, share in deceased.portfolio.holdings.items():
            proceeds = share.quantity * current_prices[firm_id]
            tx = Transaction(buyer_id=government.id, seller_id=deceased.id, item_id=f"stock_{firm_id}", ..., transaction_type="asset_liquidation")
            transactions.append(tx)

    # ... similar logic for real estate liquidation ...

    # 3. Generate Tax Transaction
    tax_tx = Transaction(buyer_id=deceased.id, seller_id=government.id, item_id="inheritance_tax", price=tax_amount, ...)
    transactions.append(tax_tx)

    # 4. Generate Distribution/Escheatment Transactions
    heirs = self.find_heirs(...)
    if heirs:
        # Generate transactions to transfer remaining cash, stocks, and properties to heirs
        # These are of type 'asset_transfer' and might require the TransactionProcessor
        # to handle non-cash item transfers.
        ...
    else:
        # Generate transactions to transfer all remaining assets to the government.
        ...

    # All transactions must have their 'time' field set to current_tick
    for tx in transactions:
        tx.time = current_tick

    return transactions
```

---

## 4. Verification Plan

1.  **Unit Tests**:
    -   Each refactored method (`invest_infrastructure`, `generate_solvency_transactions`, `process_death`) will be unit-tested to ensure it returns the correct `Transaction` objects based on input state, without modifying the state itself.
2.  **Integration Test: `TransactionProcessor`**:
    -   The `TransactionProcessor` must be updated to handle the new transaction types: `lender_of_last_resort`, `asset_liquidation`, `asset_transfer`.
    -   It must also be tested for ordered execution based on transaction priority/sub-phase to handle the inheritance choreography.
3.  **Integration Test: `TickScheduler`**:
    -   A multi-tick integration test is required to verify the new workflow:
        -   **Tick 1**: Trigger an agent's death. Verify that `inter_tick_queue` is populated with inheritance transactions. Verify bank ends tick insolvent, and `generate_solvency_transactions` creates a tx.
        -   **Tick 2**: Verify that `_phase_pre_sequence_stabilization` makes the bank solvent. Verify that the inheritance transactions from Tick 1 are processed correctly, and assets are properly transferred to heirs and government.
4.  **Side-Effect Verification**:
    -   A test will be created to verify the "consequence" mechanism.
    -   **Mechanism**: The `TransactionProcessor`, upon successfully processing a transaction with `metadata={"triggers_effect": "..."}`, will add the effect and its context to a `world_state.effects_queue`. A new `SystemEffectsManager`, run after `_phase_transactions`, will process this queue and apply state changes (e.g., the TFP boost).
    -   **Test**: In Tick 1, government invests in infrastructure. In Tick 2, verify that firm productivity has increased.

## 5. Risk & Impact Audit (Post-mortem)
This design directly addresses the five critical constraints from the pre-flight audit:
- **1. Synchronous Side-Effects**: Resolved by the new event-based `SystemEffectsManager` triggered by transaction metadata.
- **2. System Stability**: Resolved by the new `_phase_pre_sequence_stabilization`, which ensures critical solvency issues are handled before agent decisions.
- **3. Complex State Management**: Resolved by defining a clear, ordered transaction choreography for inheritance and deferring execution to the robust `TransactionProcessor` in the next tick. The "ghost assets" are managed implicitly by sourcing transactions from the inactive agent's ID.
- **4. Inter-Tick Transaction Queue**: Resolved by adding `world_state.inter_tick_queue`.
- **5. SRP Violation**: Resolved by splitting `invest_infrastructure` into financing and spending, with the spending part now generating a standard, auditable transaction. The underlying zero-sum drift is acknowledged as an issue for the `TransactionProcessor` to solve, not to be worked around.
