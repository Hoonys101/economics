diff --git a/design/TECH_DEBT_LEDGER.md b/design/TECH_DEBT_LEDGER.md
index 8c09250..35d4d24 100644
--- a/design/TECH_DEBT_LEDGER.md
+++ b/design/TECH_DEBT_LEDGER.md
@@ -18,7 +18,6 @@
 | TD-050 | 2026-01-17 | Observer Scanner Path Inclusion | Exclude `scripts/observer` from scan loop | False positives in complexity reports | **DEFERRED** |
 | TD-051 | 2026-01-17 | Documentation Placeholders | Replace `WO-XXX` with actual IDs in manuals | Confusion in developer onboarding | **DEFERRED** |
 | TD-058 | 2026-01-19 | `FinanceSystem` - `Firm` Tight Coupling | Introduce `FinancialStatementDTO` in `Firm` | Architecture Rigidity / Brittle Tests | **RESOLVED** (Phase 29) |
-| TD-059 | 2026-01-19 | Legacy Logic in `FinanceDepartment` | Refactor component to use `AltmanZScoreCalculator` | Logic Duplication / SSOT Violation | **DEFERRED** |
 | TD-060 | 2026-01-19 | Hardcoded Scenario Path in `Initializer` | Implement dynamic lookup in `ConfigManager` | Low Configurability / Brittle Tests | **RESOLVED** (Phase 29) |
 | TD-061 | 2026-01-19 | Mock Fragility in Stress Testing | Collect 'Golden Data' and implement typed mocks | Brittle Tests / High Dev Friction | **RESOLVED** (WO-083C) |
 | TD-063 | 2026-01-19 | `sys.path` Manipulation in Scripts | Use `pathlib` for stable project root detection | Unpredictable Import Behavior | **DEFERRED** |
@@ -64,6 +63,7 @@
 | TD-049 | 2026-01-18 | 2026-01-18 | Test Flakiness (ConfigManager Mocking) | Fixed via `side_effect` for default values |
 | TD-070 | 2026-01-20 | 2026-01-20 | `test_rd_logic` coverage gap | Restored assertions in `test_corporate_manager.py` |
 | TD-068 | 2026-01-20 | 2026-01-20 | Observer scans `design/` | Added `design` to `IGNORE_DIRS` in `scan_codebase.py` |
+| TD-059 | 2026-01-19 | 2026-01-20 | Legacy Logic in `FinanceDepartment` | Refactored component to use `AltmanZScoreCalculator` |
 
 
 ---
diff --git a/simulation/ai/altman_z_score.py b/simulation/ai/altman_z_score.py
new file mode 100644
index 0000000..70a30d1
--- /dev/null
+++ b/simulation/ai/altman_z_score.py
@@ -0,0 +1,35 @@
+from simulation.dtos.financial_dtos import FinancialStatementDTO
+
+class AltmanZScoreCalculator:
+    """
+    Calculates the Altman Z-Score based on a standardized financial snapshot.
+    This component is pure and stateless, relying solely on the provided DTO.
+    """
+
+    def calculate(self, statement: FinancialStatementDTO) -> float:
+        """
+        Calculates the Z-Score using a modified formula for service companies.
+        Z = 1.2*X1 + 1.4*X2 + 3.3*X3
+
+        Where:
+            X1 = Working Capital / Total Assets
+            X2 = Retained Earnings / Total Assets
+            X3 = Average Profit / Total Assets
+        """
+        if statement["total_assets"] == 0:
+            return 0.0
+
+        # X1: Working Capital / Total Assets
+        # Measures liquid assets in relation to the size of the company.
+        x1 = statement["working_capital"] / statement["total_assets"]
+
+        # X2: Retained Earnings / Total Assets
+        # Measures cumulative profitability.
+        x2 = statement["retained_earnings"] / statement["total_assets"]
+
+        # X3: Average Profit / Total Assets
+        # Measures recent operational efficiency.
+        x3 = statement["average_profit"] / statement["total_assets"]
+
+        z_score = 1.2 * x1 + 1.4 * x2 + 3.3 * x3
+        return z_score
diff --git a/simulation/components/finance_department.py b/simulation/components/finance_department.py
index 347fb5c..1ab6294 100644
--- a/simulation/components/finance_department.py
+++ b/simulation/components/finance_department.py
@@ -3,6 +3,8 @@ from typing import List, Dict, Any, Optional, TYPE_CHECKING
 import logging
 from collections import deque
 from simulation.models import Transaction
+from simulation.dtos.financial_dtos import FinancialStatementDTO
+from simulation.ai.altman_z_score import AltmanZScoreCalculator
 
 if TYPE_CHECKING:
     from simulation.firms import Firm
@@ -42,6 +44,9 @@ class FinanceDepartment:
         self.last_sales_volume: float = 1.0
         self.sales_volume_this_tick: float = 0.0
 
+        # Specialized Calculators
+        self.solvency_calculator = AltmanZScoreCalculator()
+
     def record_revenue(self, amount: float):
         self.revenue_this_turn += amount
         self.revenue_this_tick += amount
@@ -207,48 +212,25 @@ class FinanceDepartment:
             self.firm.total_debt = 0.0
         self.firm.total_debt += amount
 
-    def calculate_altman_z_score(self) -> float:
-        """Calculates the Altman Z-Score for solvency, simplified for this model.
-
-        The formula used is a modified version for non-manufacturing or service companies:
-        Z = 1.2*X1 + 1.4*X2 + 3.3*X3
-
-        Where:
-            X1 (Working Capital / Total Assets): Measures liquid assets in relation
-               to the size of the company. A firm with significant working capital
-               is less likely to face immediate financial distress.
-               - Working Capital = Firm's cash reserves - total debt.
-               - Total Assets = Cash + Capital Stock + Inventory Value.
-            X2 (Retained Earnings / Total Assets): Measures cumulative profitability.
-               A higher value indicates a history of reinvesting profits,
-               strengthening the company's financial foundation.
-            X3 (Average Profit / Total Assets): Measures recent operational efficiency.
-               Uses a moving average of profit to gauge how effectively the firm
-               is generating earnings from its assets.
-
-        Returns:
-            The calculated Z-Score. A score below 1.81 typically indicates a firm
-            is heading for bankruptcy, while a score above 3.0 suggests a healthy
-            financial position.
+    def get_altman_z_score(self) -> float:
         """
-        total_assets = self.firm.assets + self.firm.capital_stock + self.get_inventory_value()
-        if total_assets == 0:
-            return 0.0
-
-        # X1: Working Capital / Total Assets
-        # Working Capital = Current Assets - Current Liabilities. Assume liabilities are total_debt for now.
-        working_capital = self.firm.assets - getattr(self.firm, 'total_debt', 0.0)
-        x1 = working_capital / total_assets
-
-        # X2: Retained Earnings / Total Assets
-        x2 = self.retained_earnings / total_assets
-
-        # X3: Average Profit / Total Assets
-        avg_profit = sum(self.profit_history) / len(self.profit_history) if self.profit_history else 0.0
-        x3 = avg_profit / total_assets
+        Calculates the firm's solvency by assembling a financial snapshot
+        and delegating the calculation to the dedicated solvency calculator.
+        """
+        # 1. Get the raw financial data.
+        snapshot_data = self.get_financial_snapshot()
+
+        # 2. Assemble the DTO.
+        financial_statement = FinancialStatementDTO(
+            total_assets=snapshot_data["total_assets"],
+            working_capital=snapshot_data["working_capital"],
+            retained_earnings=snapshot_data["retained_earnings"],
+            average_profit=snapshot_data["average_profit"],
+            total_debt=snapshot_data["total_debt"]
+        )
 
-        z_score = 1.2 * x1 + 1.4 * x2 + 3.3 * x3
-        return z_score
+        # 3. Delegate calculation and return the result.
+        return self.solvency_calculator.calculate(financial_statement)
 
     def check_bankruptcy(self):
         if self.current_profit < 0:
@@ -293,13 +275,15 @@ class FinanceDepartment:
         Returns a standardized dictionary of financial metrics for monitoring and analysis.
         This provides a stable interface for CrisisMonitor and FinanceSystem.
         """
-        total_assets = self.firm.assets + self.get_inventory_value()
+        # Update Total Assets to include Capital Stock (Fixed Assets)
+        inventory_value = self.get_inventory_value()
+        total_assets = self.firm.assets + inventory_value + self.firm.capital_stock
 
         # Working Capital = Current Assets - Current Liabilities
-        # Since we don't have long-term assets/liabilities clearly split yet,
-        # we treat total assets as current and total debt as current liabilities.
+        # Current Assets = Cash + Inventory
+        current_assets = self.firm.assets + inventory_value
         current_liabilities = getattr(self.firm, "total_debt", 0.0)
-        working_capital = total_assets - current_liabilities
+        working_capital = current_assets - current_liabilities
 
         # Retained Earnings
         retained_earnings = self.retained_earnings
diff --git a/simulation/dtos/financial_dtos.py b/simulation/dtos/financial_dtos.py
new file mode 100644
index 0000000..2e0e67e
--- /dev/null
+++ b/simulation/dtos/financial_dtos.py
@@ -0,0 +1,12 @@
+from typing import TypedDict
+
+class FinancialStatementDTO(TypedDict):
+    """
+    Standardized data contract for financial analytics.
+    Serves as the Single Source of Truth (SSOT) for solvency and valuation logic.
+    """
+    total_assets: float
+    working_capital: float
+    retained_earnings: float
+    average_profit: float
+    total_debt: float
diff --git a/tests/ai/test_altman_z_score.py b/tests/ai/test_altman_z_score.py
new file mode 100644
index 0000000..2b2b2c3
--- /dev/null
+++ b/tests/ai/test_altman_z_score.py
@@ -0,0 +1,53 @@
+import pytest
+from simulation.ai.altman_z_score import AltmanZScoreCalculator
+from simulation.dtos.financial_dtos import FinancialStatementDTO
+
+class TestAltmanZScoreCalculator:
+
+    @pytest.fixture
+    def calculator(self):
+        return AltmanZScoreCalculator()
+
+    def test_calculate_healthy_firm(self, calculator):
+        # High assets, low debt, good profit
+        dto = FinancialStatementDTO(
+            total_assets=1000.0,
+            working_capital=500.0,   # 0.5 * 1.2 = 0.6
+            retained_earnings=300.0, # 0.3 * 1.4 = 0.42
+            average_profit=200.0,    # 0.2 * 3.3 = 0.66
+            total_debt=100.0
+        )
+        # Expected: 0.6 + 0.42 + 0.66 = 1.68
+        # Wait, let's calculate exactly
+        # X1 = 500/1000 = 0.5; * 1.2 = 0.6
+        # X2 = 300/1000 = 0.3; * 1.4 = 0.42
+        # X3 = 200/1000 = 0.2; * 3.3 = 0.66
+        # Total = 1.68
+
+        score = calculator.calculate(dto)
+        assert score == pytest.approx(1.68)
+
+    def test_calculate_distressed_firm(self, calculator):
+        # Low working capital, losses
+        dto = FinancialStatementDTO(
+            total_assets=1000.0,
+            working_capital=50.0,    # 0.05 * 1.2 = 0.06
+            retained_earnings=-100.0,# -0.1 * 1.4 = -0.14
+            average_profit=-50.0,    # -0.05 * 3.3 = -0.165
+            total_debt=800.0
+        )
+        # Expected: 0.06 - 0.14 - 0.165 = -0.245
+
+        score = calculator.calculate(dto)
+        assert score == pytest.approx(-0.245)
+
+    def test_calculate_zero_assets(self, calculator):
+        dto = FinancialStatementDTO(
+            total_assets=0.0,
+            working_capital=0.0,
+            retained_earnings=0.0,
+            average_profit=0.0,
+            total_debt=0.0
+        )
+        score = calculator.calculate(dto)
+        assert score == 0.0
diff --git a/tests/components/test_finance_department_solvency.py b/tests/components/test_finance_department_solvency.py
new file mode 100644
index 0000000..77a176b
--- /dev/null
+++ b/tests/components/test_finance_department_solvency.py
@@ -0,0 +1,76 @@
+import pytest
+from unittest.mock import MagicMock, patch
+from simulation.components.finance_department import FinanceDepartment
+from simulation.dtos.financial_dtos import FinancialStatementDTO
+
+class TestFinanceDepartmentSolvency:
+
+    @pytest.fixture
+    def mock_firm(self):
+        firm = MagicMock()
+        firm.assets = 1000.0
+        firm.capital_stock = 500.0
+        firm.inventory = {}
+        firm.total_debt = 200.0
+        firm.last_prices = {}
+        return firm
+
+    @pytest.fixture
+    def mock_config(self):
+        config = MagicMock()
+        config.PROFIT_HISTORY_TICKS = 10
+        config.GOODS = {}
+        return config
+
+    @pytest.fixture
+    def finance_dept(self, mock_firm, mock_config):
+        dept = FinanceDepartment(mock_firm, mock_config)
+        return dept
+
+    def test_get_financial_snapshot_structure(self, finance_dept, mock_firm):
+        # Setup
+        mock_firm.assets = 1000.0
+        mock_firm.capital_stock = 500.0
+        mock_firm.inventory = {"apple": 10}
+        mock_firm.last_prices = {"apple": 5.0}
+        # Inventory Value = 10 * 5 = 50.0
+        # Total Assets = 1000 + 50 + 500 = 1550.0
+        # Current Assets = 1000 + 50 = 1050.0
+        # Total Debt = 200.0
+        # Working Capital = 1050 - 200 = 850.0
+
+        finance_dept.retained_earnings = 300.0
+        finance_dept.current_profit = 100.0
+
+        snapshot = finance_dept.get_financial_snapshot()
+
+        assert snapshot["total_assets"] == 1550.0
+        assert snapshot["working_capital"] == 850.0
+        assert snapshot["retained_earnings"] == 300.0
+        assert snapshot["average_profit"] == 100.0
+        assert snapshot["total_debt"] == 200.0
+
+    def test_get_altman_z_score_delegation(self, finance_dept, mock_firm):
+        # Setup specific values
+        mock_firm.assets = 1000.0
+        mock_firm.capital_stock = 0.0
+        mock_firm.inventory = {}
+        mock_firm.total_debt = 0.0
+
+        # Mock the calculator
+        mock_calculator = MagicMock()
+        mock_calculator.calculate.return_value = 99.9
+        finance_dept.solvency_calculator = mock_calculator
+
+        # Execute
+        result = finance_dept.get_altman_z_score()
+
+        # Verify
+        assert result == 99.9
+        mock_calculator.calculate.assert_called_once()
+
+        # Check arguments passed to calculate
+        call_args = mock_calculator.calculate.call_args[0][0]
+        assert isinstance(call_args, dict) # TypedDict is a dict at runtime
+        assert "total_assets" in call_args
+        assert "working_capital" in call_args
