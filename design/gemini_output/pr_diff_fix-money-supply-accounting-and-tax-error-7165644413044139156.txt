diff --git a/design/audits/ROOT_CAUSE_PROFILE.md b/design/audits/ROOT_CAUSE_PROFILE.md
new file mode 100644
index 0000000..5cdffb1
--- /dev/null
+++ b/design/audits/ROOT_CAUSE_PROFILE.md
@@ -0,0 +1,37 @@
+# Deep Root Cause Profile
+
+## Executive Summary
+This audit identifies three critical systemic failures causing the reported financial discrepancies. The primary "Tick 1 Deletion" (-185k) is a false positive leak caused by an accounting definition error where Government assets were excluded from the Money Supply (M2) calculation. The "Lifecycle Errors" are caused by a type error in the `TransactionProcessor`, preventing tax collection and leading to statistical drift. The "+293.3120 Anomaly" is a result of consistent money creation flow that appears as a leak due to the same accounting definition error or minor floating-point accumulation in interest payments.
+
+## 1. Tick 1 Deletion (-185,430.00)
+- **Status**: Identified
+- **Root Cause**: **Accounting Definition Error**.
+    - The `WorldState.calculate_total_money()` method explicitly excludes `Government.assets` from the M2 calculation.
+    - At Tick 1, the `MinistryOfEducation` executes the "Public Education" logic.
+    - Households pay "Student Share" of education costs to the Government.
+    - **Mechanism**: Money moves from `Households` (Inside M2) to `Government` (Outside M2).
+    - **Result**: M2 decreases by the total student share amount (~185k), which the system flags as a "Leak" because it is not recorded as "Money Destruction".
+- **Fix**: Update `WorldState.calculate_total_money()` to include `state.government.assets`. This recognizes the Government as an economic actor holding liquidity, ensuring transfers to/from the government satisfy zero-sum conservation.
+
+## 2. Systemic Money Destruction (Lifecycle/Tax Errors)
+- **Status**: Identified
+- **Root Cause**: **Type Error in TransactionProcessor**.
+    - The `TransactionProcessor` calls `government.collect_tax(..., payer_id, ...)` passing the agent's **ID** (int/str) instead of the **Agent Object**.
+    - `TaxAgency.collect_tax` expects an object to verify `hasattr(payer, 'id')`.
+    - **Mechanism**: `collect_tax` logs "Payer X is not an object" and returns 0.0, failing to record tax statistics or execute `FinanceSystem` logic (if connected).
+    - **Result**: While the `SettlementSystem` successfully transfers the funds (via `TransactionProcessor`'s direct call), the statistical tracking of tax revenue fails, leading to discrepancies between "Collected Tax" and actual asset movements.
+- **Fix**: Update `TransactionProcessor` to pass the `buyer` or `seller` object itself to `government.collect_tax`, not just the ID.
+
+## 3. The +293.3120 Anomaly
+- **Status**: Identified
+- **Root Cause**: **M2 Exclusion of Government & Infrastructure**.
+    - Similar to the Tick 1 error, the Government invests in Infrastructure (~5000/tick) by paying the `EconomicRefluxSystem`.
+    - **Mechanism**: `Government` (Outside M2) pays `RefluxSystem` (Inside M2).
+    - **Result**: M2 **increases** by the investment amount. This should appear as a positive leak.
+    - The specific value `293.3120` suggests a net effect of multiple flows (e.g., Infrastructure + Interest - Tax). If Tax leaks (negative) and Infrastructure adds (positive), the net result is the anomaly.
+    - Once Government is added to M2, all these flows become internal transfers, eliminating the "Leak" noise.
+
+## 4. De-registration Bug
+- **Status**: Clarified
+- **Root Cause**: The reported "De-registration" issue is largely the symptom of the `TaxAgency` Type Error described above. When `TransactionProcessor` fails to handle the object/ID distinction, it manifests as "Payer not found" errors that worsen when agents die (as IDs might be reused or lookups fail, though the primary error is the Type mismatch).
+- **Fix**: The fix for #2 addresses the root cause. No complex de-registration logic is needed beyond what `LifecycleManager` already does (rebuilding `state.agents`), provided the `TransactionProcessor` uses valid object references from the current state.
diff --git a/simulation/systems/transaction_processor.py b/simulation/systems/transaction_processor.py
index 8c9610c..a13a915 100644
--- a/simulation/systems/transaction_processor.py
+++ b/simulation/systems/transaction_processor.py
@@ -70,7 +70,8 @@ class TransactionProcessor(SystemInterface):
                     seller.deposit(trade_value)
                     government.deposit(tax_amount)
 
-                government.collect_tax(tax_amount, f"sales_tax_{tx.transaction_type}", buyer.id, current_time)
+                # Fix: Pass buyer object, not ID, to collect_tax
+                government.collect_tax(tax_amount, f"sales_tax_{tx.transaction_type}", buyer, current_time)
 
             elif tx.transaction_type == "stock":
                 # Stock: NO Sales Tax
@@ -104,7 +105,8 @@ class TransactionProcessor(SystemInterface):
                         seller.deposit(trade_value)
                         government.deposit(tax_amount)
 
-                    government.collect_tax(tax_amount, "income_tax_firm", buyer.id, current_time)
+                    # Fix: Pass buyer object (Firm) to collect_tax
+                    government.collect_tax(tax_amount, "income_tax_firm", buyer, current_time)
                 else:
                     # Household pays tax (Withholding model)
                     net_wage = trade_value - tax_amount
@@ -117,7 +119,8 @@ class TransactionProcessor(SystemInterface):
                         seller.deposit(net_wage)
                         government.deposit(tax_amount)
 
-                    government.collect_tax(tax_amount, "income_tax_household", seller.id, current_time)
+                    # Fix: Pass seller object (Household) to collect_tax
+                    government.collect_tax(tax_amount, "income_tax_household", seller, current_time)
             
             elif tx.item_id == "interest_payment":
                 if settlement:
diff --git a/simulation/world_state.py b/simulation/world_state.py
index 4b04116..f331cbe 100644
--- a/simulation/world_state.py
+++ b/simulation/world_state.py
@@ -127,8 +127,8 @@ class WorldState:
     def calculate_total_money(self) -> float:
         """
         Calculates the total money supply in the system.
-        Money_Total = Household_Assets + Firm_Assets + Bank_Reserves + Reflux_Balance
-        (Government assets are excluded as it is the issuer)
+        Money_Total = Household_Assets + Firm_Assets + Bank_Reserves + Reflux_Balance + Government_Assets
+        (Government assets are INCLUDED to ensure zero-sum integrity during transfers)
         """
         total = 0.0
 
@@ -150,6 +150,10 @@ class WorldState:
         if self.reflux_system:
             total += self.reflux_system.balance
 
+        # 5. Government Assets (WO-Fix: Include Government in M2 to prevent leaks)
+        if self.government:
+            total += self.government.assets
+
         return total
 
     def get_all_agents(self) -> List[Any]:
diff --git a/tests/verify_m2_fix.py b/tests/verify_m2_fix.py
new file mode 100644
index 0000000..a3f2530
--- /dev/null
+++ b/tests/verify_m2_fix.py
@@ -0,0 +1,54 @@
+from simulation.world_state import WorldState
+from simulation.agents.government import Government
+from simulation.core_agents import Household
+from unittest.mock import MagicMock
+import logging
+
+def test_m2_fix():
+    logger = logging.getLogger("test")
+    config = MagicMock()
+    repo = MagicMock()
+
+    state = WorldState(config, config, logger, repo)
+
+    # Init Gov
+    # Government now has assets included in M2.
+    gov = Government(id=0, initial_assets=1000, config_module=config)
+    state.government = gov
+
+    # Init Household
+    # Use a minimal Household setup
+    hh = MagicMock(spec=Household)
+    hh.id = 1
+    hh.assets = 1000.0
+    hh.is_active = True
+
+    state.households.append(hh)
+
+    # Check Initial M2
+    # Should be Gov(1000) + HH(1000) = 2000
+    m2_initial = state.calculate_total_money()
+    print(f"Initial M2: {m2_initial}")
+
+    # Verify my fix: Gov assets are included
+    if m2_initial != 2000:
+        print(f"FAILURE: Initial M2 is {m2_initial}, expected 2000. Did Government get included?")
+    assert m2_initial == 2000
+
+    # Simulate Transfer (e.g. Tax)
+    amount = 500
+    hh.assets -= amount
+    gov._add_assets(amount)
+
+    # Check Final M2
+    m2_final = state.calculate_total_money()
+    print(f"Final M2: {m2_final}")
+
+    if m2_final != 2000:
+        print(f"FAILURE: M2 changed to {m2_final} after transfer!")
+    assert m2_final == 2000
+
+    print("M2 Conservation Verified!")
+
+if __name__ == "__main__":
+    test_m2_fix()
diff --git a/tests/verify_transaction_processor.py b/tests/verify_transaction_processor.py
new file mode 100644
index 0000000..73a5398
--- /dev/null
+++ b/tests/verify_transaction_processor.py
@@ -0,0 +1,75 @@
+from simulation.systems.transaction_processor import TransactionProcessor
+from simulation.models import Transaction
+from unittest.mock import MagicMock
+import logging
+
+def test_tax_collection_args():
+    config = MagicMock()
+    config.SALES_TAX_RATE = 0.1
+    config.GOODS = {"apple": {}}
+
+    tp = TransactionProcessor(config)
+
+    state = MagicMock()
+    gov = MagicMock()
+    state.government = gov
+    # Mock calculate_income_tax for other paths, though we test 'goods' here
+    gov.calculate_income_tax.return_value = 0.0
+
+    state.settlement_system = None # Force fallback or direct call logic
+    state.market_data = {}
+    state.time = 0
+
+    # Buyer Object
+    buyer = MagicMock()
+    buyer.id = 1
+    buyer.assets = 100.0
+    # Add check_solvency mock
+    buyer.check_solvency = MagicMock()
+
+    # Seller Object
+    seller = MagicMock()
+    seller.id = 2
+    seller.inventory = {}
+    seller.deposit = MagicMock()
+
+    state.agents = {1: buyer, 2: seller}
+
+    # Transaction
+    tx = Transaction(
+        buyer_id=1,
+        seller_id=2,
+        item_id="apple",
+        price=10.0,
+        quantity=1.0,
+        market_id="goods",
+        transaction_type="goods",
+        time=0
+    )
+    state.transactions = [tx]
+
+    # Execute
+    tp.execute(state)
+
+    # Verify collect_tax call
+    # gov.collect_tax(tax_amount, tax_type, payer, tick)
+    # Expected: payer is buyer (object), not buyer.id
+
+    if not gov.collect_tax.called:
+        print("collect_tax not called!")
+        return
+
+    args = gov.collect_tax.call_args
+    print(f"Call args: {args}")
+    # args[0] is positional args tuple: (amount, type, payer, tick)
+    payer_arg = args[0][2] # 3rd arg
+
+    if payer_arg == buyer:
+        print("SUCCESS: Payer passed as object.")
+    elif payer_arg == buyer.id:
+        print("FAILURE: Payer passed as ID.")
+    else:
+        print(f"FAILURE: Unknown payer arg: {payer_arg}")
+
+if __name__ == "__main__":
+    test_tax_collection_args()
