diff --git a/scripts/audit_zero_sum.py b/scripts/audit_zero_sum.py
index 5c95191..8c71303 100644
--- a/scripts/audit_zero_sum.py
+++ b/scripts/audit_zero_sum.py
@@ -9,6 +9,7 @@ sys.path.append(str(Path(__file__).resolve().parent.parent))
 
 from main import create_simulation
 from simulation.firms import Firm
+from simulation.dtos.api import SimulationState
 
 def audit_integrity():
     logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')
@@ -35,10 +36,7 @@ def audit_integrity():
                        for f in sim.firms)
         gov_assets = sim.government.assets
 
-        # WO-106: Include Reflux Balance as it holds captured value before distribution
-        reflux_balance = sim.reflux_system.balance if hasattr(sim, 'reflux_system') else 0.0
-
-        return h_assets + f_assets + gov_assets + reflux_balance
+        return h_assets + f_assets + gov_assets
 
     # Snapshot T0 state for detailed accounting
     # Use config default price if dynamic price is missing
@@ -88,30 +86,11 @@ def audit_integrity():
         gross_production_value += f.current_production * price
 
     # 2. Consumption (Value Destroyed)
-    # Households don't expose 'consumed value' directly easily, but we know Consumption = Wealth Loss.
-    # Firms consume Inputs.
-    # We can infer Consumption + Input Usage by checking Inventory changes vs Production.
-    # But simpler: We assume Unexplained Diff is Consumption + Depreciation.
+    household_consumption_value = sum(h.current_consumption for h in sim.households)
 
     # 3. Depreciation (Capital Stock Loss)
     depreciation_loss = cap_stock_t0 - cap_stock_t1
 
-    # 4. Input Consumption (Firm)
-    # Hard to track exact input usage without snapshotting input_inventory.
-    # Let's assume input_inventory change is mostly consumption.
-    # But firms might buy inputs? (Trade). Trade is wealth transfer, not loss.
-    # So Input Consumption = (Input_Inv_T0 - Input_Inv_T1) + Inputs_Bought.
-    # If no trade (Tick 1 usually no trade?), then Delta Input Inv is Consumption.
-
-    # 5. Household Consumption
-    # sim.households[i].current_consumption (Value)
-    household_consumption_value = sum(h.current_consumption for h in sim.households)
-
-    # Predict Delta
-    # Delta Wealth = Gross Production - HH Consumption - Depreciation - Input Consumption
-    # If Input Consumption is not tracked, we might fail.
-    # Let's see if Gross Production - HH Consumption - Depreciation aligns.
-
     predicted_diff = gross_production_value - household_consumption_value - depreciation_loss
     unexplained_diff = diff - predicted_diff
 
@@ -123,30 +102,8 @@ def audit_integrity():
     # PR Review: Tolerance tightened to 0.1%
     tolerance = 0.001 # 0.1%
 
-    # We accept Variance if it likely Input Consumption (Negative Unexplained).
-    # If Unexplained is Negative, it means we predicted MORE wealth than actual -> Something consumed it.
-    # Input Consumption is the missing sink.
-    # If Unexplained is Positive, we have Created Money from nowhere. That is BAD.
-
-    # We enforce STRICT no-creation (Positive Unexplained <= tolerance).
-    # We allow Sinks (Negative Unexplained) to be larger IF we attribute it to inputs.
-    # But the user asked for "Tolerance 0.1%".
-    # I should assume "Net Change" should be explained.
-
-    if abs(unexplained_diff) > wealth_t0 * tolerance:
-         # If variance is negative, check if it fits Input Consumption profile?
-         # For now, log error but provide context.
-         logger.error(f"FAILED: Initial Sink detected! (>0.1% unexplained variance). Unexplained: {unexplained_diff:.2f}")
-    else:
-         logger.info("PASSED: Initial Sink check (Unexplained variance < 0.1%).")
-
-    # PR Review: Tolerance tightened to 0.1%
-    tolerance = 0.001 # 0.1%
-
-    # We check if unexplained variance is within tolerance
     if abs(unexplained_diff) > wealth_t0 * tolerance:
          logger.error(f"FAILED: Initial Sink detected! (>0.1% unexplained variance). Unexplained: {unexplained_diff:.2f}")
-         # Also fail if the raw diff is huge and we can't explain it, but here we try to explain it.
     else:
          logger.info("PASSED: Initial Sink check (Unexplained variance < 0.1%).")
 
@@ -184,39 +141,63 @@ def audit_integrity():
     else:
         logger.warning("No immigrants created (unexpected)")
 
-    # 4. Check Reflux Capture (Liquidation)
+    # 4. Check Liquidation Escheatment (Government Capture)
     # ------------------------------------------------------------------
-    logger.info("Checking Reflux System Capture...")
-    # Create a dummy firm to kill or use existing
+    logger.info("Checking Liquidation Escheatment (to Government)...")
+    # Create victim firm (orphan, no shareholders)
     victim = sim.firms[0]
     victim.inventory['basic_food'] = 10.0
     victim.capital_stock = 500.0
-    diff = 100.0 - victim.assets
+    victim.total_shares = 1000.0
+    victim.treasury_shares = 1000.0 # 100% Treasury -> No external shareholders -> Escheat to Gov
+
+    # Ensure it has cash
+    victim_cash = 1000.0
     if hasattr(victim, '_add_assets'):
-        victim._add_assets(diff)
+         victim._add_assets(victim_cash - victim.assets)
     else:
-        victim.assets = 100.0
-
-    # Ensure market exists for basic_food for pricing
-    if 'basic_food' not in sim.markets:
-         sim.markets['basic_food'] = type('MockMarket', (), {'avg_price': 10.0, 'current_price': 10.0})()
+         victim.assets = victim_cash
 
     victim.is_active = False # Mark for death
 
-    initial_reflux = sim.reflux_system.balance
-    logger.info(f"Reflux Balance Before: {initial_reflux}")
+    initial_gov = sim.government.assets
+
+    # Create SimulationState DTO for lifecycle manager
+    sim_state = SimulationState(
+        time=sim.time,
+        households=sim.households,
+        firms=sim.firms,
+        agents=sim.agents,
+        markets=sim.markets,
+        government=sim.government,
+        bank=sim.bank,
+        central_bank=sim.central_bank,
+        stock_market=sim.stock_market,
+        stock_tracker=sim.stock_tracker if hasattr(sim, 'stock_tracker') else None,
+        goods_data=sim.goods_data,
+        market_data={},
+        config_module=sim.config_module,
+        tracker=sim.tracker,
+        logger=sim.logger,
+        ai_training_manager=sim.ai_training_manager,
+        ai_trainer=sim.ai_trainer,
+        next_agent_id=sim.next_agent_id,
+        real_estate_units=sim.real_estate_units,
+        settlement_system=sim.world_state.settlement_system
+    )
 
     # Run lifecycle manager
-    sim.lifecycle_manager._handle_agent_liquidation(sim)
+    sim.lifecycle_manager._handle_agent_liquidation(sim_state)
 
-    final_reflux = sim.reflux_system.balance
-    captured = final_reflux - initial_reflux
-    logger.info(f"Reflux Balance After: {final_reflux} (Captured: {captured})")
+    final_gov = sim.government.assets
+    captured = final_gov - initial_gov
+    logger.info(f"Gov Assets Before: {initial_gov:.2f} | After: {final_gov:.2f} | Captured: {captured:.2f}")
 
-    if captured > 0:
-        logger.info(f"PASSED: Reflux System captured liquidation value.")
+    # We expect Government to capture the Cash (1000.0). Real assets (inventory/capital) are destroyed.
+    if abs(captured - victim_cash) < 1.0:
+        logger.info(f"PASSED: Government captured liquidation cash.")
     else:
-        logger.error("FAILED: Reflux System captured nothing.")
+        logger.error(f"FAILED: Government capture mismatch. Expected ~{victim_cash}, got {captured}")
 
 if __name__ == "__main__":
     audit_integrity()
diff --git a/scripts/diagnose_money_leak.py b/scripts/diagnose_money_leak.py
index 795cc93..0764553 100644
--- a/scripts/diagnose_money_leak.py
+++ b/scripts/diagnose_money_leak.py
@@ -47,10 +47,9 @@ def diagnose():
         
         gov = sim.government.assets
         bank = sim.bank.assets
-        reflux = sim.reflux_system.balance if hasattr(sim, 'reflux_system') else 0.0
         
         # M2 통계
-        total = h_sum + f_sum + gov + bank + reflux + h_inactive + f_inactive
+        total = h_sum + f_sum + gov + bank + h_inactive + f_inactive
         return {
             "total": total,
             "h_active": h_sum,
@@ -59,7 +58,6 @@ def diagnose():
             "f_ghost": f_inactive,
             "gov": gov,
             "bank": bank,
-            "reflux": reflux,
             "issued": getattr(sim.government, "total_money_issued", 0.0),
             "destroyed": getattr(sim.government, "total_money_destroyed", 0.0)
         }
diff --git a/scripts/hunt_leak.py b/scripts/hunt_leak.py
index 8532cbd..851c6af 100644
--- a/scripts/hunt_leak.py
+++ b/scripts/hunt_leak.py
@@ -22,8 +22,6 @@ def hunt_leak():
             snapshot["BANK"] = state.bank.assets
         if state.government:
             snapshot["GOVT"] = state.government.assets
-        if state.reflux_system:
-            snapshot["REFLUX"] = state.reflux_system.balance
         return snapshot
 
     print("--- LEAK HUNT START ---")
diff --git a/scripts/trace_tick.py b/scripts/trace_tick.py
index 977b7ee..8c38719 100644
--- a/scripts/trace_tick.py
+++ b/scripts/trace_tick.py
@@ -32,7 +32,7 @@ def trace_tick():
     
     # Bank
     if hasattr(state.bank, "run_tick"):
-         bank_txs = state.bank.run_tick(state.agents, state.time, reflux_system=state.reflux_system)
+         bank_txs = state.bank.run_tick(state.agents, state.time)
          system_transactions.extend(bank_txs)
     report("Post-Bank-Tick")
     
@@ -52,12 +52,12 @@ def trace_tick():
     report("Post-Welfare-Gen")
     
     # Infrastructure
-    infra = state.government.invest_infrastructure(state.time, state.reflux_system)
+    infra = state.government.invest_infrastructure(state.time, state.households)
     if infra: system_transactions.extend(infra)
     report("Post-Infra-Gen")
     
     # Education
-    edu = state.government.run_public_education(state.households, state.config_module, state.time, state.reflux_system)
+    edu = state.government.run_public_education(state.households, state.config_module, state.time)
     if edu: system_transactions.extend(edu)
     report("Post-Edu-Gen")
     
@@ -68,11 +68,16 @@ def trace_tick():
         sim_state = SimulationState(
             time=state.time, households=state.households, firms=state.firms,
             agents=state.agents, markets=state.markets, government=state.government,
-            bank=state.bank, central_bank=state.central_bank, reflux_system=state.reflux_system,
+            bank=state.bank, central_bank=state.central_bank,
             transactions=system_transactions, config_module=state.config_module,
             tracker=state.tracker, logger=state.logger, goods_data=state.goods_data,
             next_agent_id=state.next_agent_id, real_estate_units=state.real_estate_units,
-            settlement_system=state.settlement_system, inactive_agents=state.inactive_agents
+            settlement_system=state.settlement_system, inactive_agents=state.inactive_agents,
+            ai_training_manager=state.ai_training_manager,
+            ai_trainer=state.ai_trainer,
+            stock_market=state.stock_market,
+            stock_tracker=state.stock_tracker,
+            market_data={}
         )
         state.transaction_processor.execute(sim_state)
     report("Post-Execution")
@@ -88,18 +93,20 @@ def trace_tick():
         sim_state = SimulationState(
             time=state.time, households=state.households, firms=state.firms,
             agents=state.agents, markets=state.markets, government=state.government,
-            bank=state.bank, central_bank=state.central_bank, reflux_system=state.reflux_system,
+            bank=state.bank, central_bank=state.central_bank,
             transactions=[], config_module=state.config_module,
             tracker=state.tracker, logger=state.logger, goods_data=state.goods_data,
             next_agent_id=state.next_agent_id, real_estate_units=state.real_estate_units,
-            settlement_system=state.settlement_system, inactive_agents=state.inactive_agents
+            settlement_system=state.settlement_system, inactive_agents=state.inactive_agents,
+            ai_training_manager=state.ai_training_manager,
+            ai_trainer=state.ai_trainer,
+            stock_market=state.stock_market,
+            stock_tracker=state.stock_tracker,
+            market_data={}
         )
         state.lifecycle_manager.execute(sim_state)
     report("Post-Lifecycle")
     
-    # Reflux Distribute
-    state.reflux_system.distribute(state.households)
-    report("Post-Distribute")
 
 if __name__ == "__main__":
     trace_tick()
diff --git a/scripts/verify_great_reset_stability.py b/scripts/verify_great_reset_stability.py
index 5b8f139..c9b2630 100644
--- a/scripts/verify_great_reset_stability.py
+++ b/scripts/verify_great_reset_stability.py
@@ -50,10 +50,8 @@ def verify_great_reset_stability():
         f_assets = sum(f.assets for f in sim.firms if f.is_active)
         gov_assets = sim.government.assets
         bank_assets = sim.bank.assets
-        # Reflux balance (Sunk costs)
-        reflux_bal = sim.reflux_system.balance if hasattr(sim, 'reflux_system') else 0.0
         
-        return h_assets + f_assets + gov_assets + bank_assets + reflux_bal
+        return h_assets + f_assets + gov_assets + bank_assets
 
     m2_start = get_total_m2()
     logger.info(f"Initial M2: {m2_start:,.2f}")
diff --git a/scripts/verify_reflux.py b/scripts/verify_reflux.py
deleted file mode 100644
index a5415d9..0000000
--- a/scripts/verify_reflux.py
+++ /dev/null
@@ -1,113 +0,0 @@
-
-import logging
-import sys
-from pathlib import Path
-import os
-import matplotlib.pyplot as plt
-
-# Ensure module path
-sys.path.append(str(Path(__file__).resolve().parent.parent))
-
-from main import run_simulation
-from simulation.db.repository import SimulationRepository
-from modules.analytics.loader import DataLoader
-import config
-
-# Setup Logging to capture DIVIDEND events
-from utils.logging_manager import setup_logging
-setup_logging()
-logger = logging.getLogger("VERIFY_REFLUX")
-
-def run_test_plan_a():
-    """
-    Test Plan A: 'The Reflux'
-    - Income Tax = 0
-    - Productivity = 20.0
-    - Check for Dividend Logs
-    - Check for Asset Golden Cross (Capital Income vs Labor Income)
-    - Check Survival > 200 ticks
-    """
-    logger.info("Starting Test Plan A: Operation Reflux Verification")
-
-    # 1. Configure
-    # Override config for Laissez-Faire + Reflux
-    overrides = {
-        "INCOME_TAX_RATE": 0.0,
-        "CORPORATE_TAX_RATE": 0.0, # Let them keep profit to distribute
-        "SALES_TAX_RATE": 0.0,
-        "FIRM_PRODUCTIVITY_FACTOR": 20.0,
-        "FIRM_MAINTENANCE_FEE": 50.0,
-        "SIMULATION_TICKS": 400, # Goal is > 200
-        "INITIAL_FIRM_CAPITAL_MEAN": 10000.0, # Same as Laissez-Faire
-    }
-    
-    # Apply overrides (Hack: modify config directly as main.run_simulation doesn't support all overrides easily via args)
-    # But main.create_simulation does.
-    # main.run_simulation accepts specific args, but we might need to modify config module.
-    for k, v in overrides.items():
-        setattr(config, k, v)
-    
-    # 2. Run Simulation
-    output_file = "reflux_test_results.csv"
-    try:
-        run_simulation(output_filename=output_file)
-    except Exception as e:
-        logger.error(f"Simulation crashed: {e}")
-        return
-
-    # 3. Analyze Results
-    repo = SimulationRepository()
-    run_id = repo._get_latest_run_id()
-    loader = DataLoader("simulation_data.db")
-    eco_df = loader.load_economic_indicators(run_id=run_id)
-    
-    if eco_df.empty:
-        logger.error("No economic data found.")
-        return
-
-    # 3.1 Check Log/Event Evidence (Dividends)
-    # We can't grep logs easily from here unless we read the log file.
-    # But we can check 'total_capital_income' from eco_df.
-    
-    total_labor = eco_df["total_labor_income"].sum()
-    total_capital = eco_df["total_capital_income"].sum()
-    
-    logger.info(f"Total Labor Income: {total_labor:,.2f}")
-    logger.info(f"Total Capital Income: {total_capital:,.2f}")
-    
-    if total_capital > 0:
-        logger.info("SUCCESS: Capital Income detected (Dividends flowing).")
-    else:
-        logger.error("FAILURE: No Capital Income detected.")
-        
-    # 3.2 Check Golden Cross
-    # Plot Income Composition
-    plt.figure(figsize=(10, 6))
-    plt.plot(eco_df.index, eco_df["total_labor_income"], label="Labor Income", color="blue")
-    plt.plot(eco_df.index, eco_df["total_capital_income"], label="Capital Income", color="red")
-    plt.title("Income Composition: Labor vs Capital")
-    plt.xlabel("Tick")
-    plt.ylabel("Income")
-    plt.legend()
-    plt.grid(True)
-    plt.savefig("reports/figures/income_composition_reflux.png")
-    logger.info("Generated 'reports/figures/income_composition_reflux.png'")
-    
-    # 3.3 Check Survival
-    # Deaths?
-    # Get attrition
-    attrition = repo.get_attrition_counts(start_tick=0, end_tick=400, run_id=run_id)
-    logger.info(f"Attrition: {attrition}")
-    
-    final_tick = eco_df.index.max()
-    logger.info(f"Simulation reached tick: {final_tick}")
-    
-    if final_tick >= 200:
-        logger.info("SUCCESS: Survived beyond 200 ticks.")
-    else:
-        logger.warning(f"WARNING: Colllapsed at {final_tick} ticks.")
-
-    repo.close()
-
-if __name__ == "__main__":
-    run_test_plan_a()
diff --git a/scripts/verify_td_111.py b/scripts/verify_td_111.py
index 04c1e68..53151ac 100644
--- a/scripts/verify_td_111.py
+++ b/scripts/verify_td_111.py
@@ -12,10 +12,9 @@ def verify_td_111():
     print("--- VERIFY TD-111 START ---")
     sim = create_simulation()
 
-    # Run a few ticks to generate some economic activity and potential reflux
+    # Run a few ticks to generate some economic activity
     print("Running simulation for 10 ticks...")
     for i in range(10):
-        sim.orchestrate_production_and_tech(i)
         sim.run_tick()
 
     world_state = sim.world_state
@@ -25,16 +24,14 @@ def verify_td_111():
     ws_total = world_state.calculate_total_money()
     m2_total = tracker.get_m2_money_supply(world_state)
 
-    reflux_balance = world_state.reflux_system.balance if world_state.reflux_system else 0.0
     cb_balance = world_state.central_bank.assets.get('cash', 0.0) if world_state.central_bank else 0.0
 
     print(f"WorldState Total Money (Integrity): {ws_total:,.6f}")
     print(f"M2 Money Supply (Reporting): {m2_total:,.6f}")
-    print(f"Reflux Balance: {reflux_balance:,.6f}")
     print(f"Central Bank Cash: {cb_balance:,.6f}")
 
     # Calculate sum
-    calculated_total = m2_total + reflux_balance + cb_balance
+    calculated_total = m2_total + cb_balance
 
     diff = abs(ws_total - calculated_total)
     print(f"Difference: {diff:,.10f}")
@@ -44,30 +41,16 @@ def verify_td_111():
 
     print("✅ TD-111 Integrity Check Passed.")
 
-    # Also verify that if Reflux > 0, M2 < Total (Strict subset)
-    # Reflux might be 0 if everything distributed perfectly or nothing happened.
-    if reflux_balance > 0:
-        assert m2_total < ws_total, "M2 should be less than Total when Reflux > 0"
-        print("✅ M2 is strictly less than Total (Reflux excluded confirmed).")
-    else:
-        print("⚠️ Reflux balance is 0.0, cannot confirm strict exclusion. (This is okay if no reflux happened yet)")
-
     # Verify that M2 from tracker (via run_tick) matches get_m2_money_supply
     # We need to access the latest tracked value.
     latest_metrics = tracker.get_latest_indicators()
     tracked_m2 = latest_metrics.get("money_supply", -1.0)
     print(f"Tracked M2 (from metrics): {tracked_m2:,.6f}")
 
-    # NOTE: tracked_m2 comes from the START of the tick (or end, depending on when track is called).
-    # In tick_scheduler.py: track is called in the middle/end.
-    # The value `m2_total` we calculated above is NOW (end of tick 10).
-    # `tracked_m2` should be from tick 10 (latest).
-
     if abs(tracked_m2 - m2_total) < 1e-6:
-         print("✅ Tracked M2 matches calculated M2. (Code is likely modified to use M2)")
+         print("✅ Tracked M2 matches calculated M2.")
     elif abs(tracked_m2 - ws_total) < 1e-6:
          print("❌ Tracked M2 matches Total Money. (Code is likely NOT YET modified)")
-         # This will be useful to confirm the change.
     else:
          print(f"⚠️ Tracked M2 ({tracked_m2}) matches neither M2 ({m2_total}) nor Total ({ws_total}).")
 
diff --git a/simulation/action_processor.py b/simulation/action_processor.py
index 1b09ad1..1214407 100644
--- a/simulation/action_processor.py
+++ b/simulation/action_processor.py
@@ -49,6 +49,7 @@ class ActionProcessor:
                 bank=self.world_state.bank,
                 central_bank=self.world_state.central_bank,
                 stock_market=self.world_state.stock_market,
+                stock_tracker=self.world_state.stock_tracker,
                 goods_data=self.world_state.goods_data,
                 market_data=market_data,
                 config_module=self.world_state.config_module,
diff --git a/simulation/agents/government.py b/simulation/agents/government.py
index add36a4..da530d7 100644
--- a/simulation/agents/government.py
+++ b/simulation/agents/government.py
@@ -659,13 +659,6 @@ class Government:
         """
         Delegates public education logic to the Ministry of Education.
         Returns transactions.
-        REMOVED RefluxSystem arg.
         """
         households = [a for a in agents if hasattr(a, 'education_level')]
-        # Removed reflux_system and settlement_system args (MinistryOfEducation shouldn't need settlement_system to CREATE transaction DTOs)
-        # But my previous read showed MinistryOfEducation taking settlement_system?
-        # Let's check.
-        # `def run_public_education(self, households: List[Any], government: Any, current_tick: int, reflux_system: Any = None, settlement_system: Any = None) -> List[Transaction]:`
-        # It was taking them.
-        # I'll update call to remove them.
         return self.ministry_of_education.run_public_education(households, self, current_tick)
diff --git a/simulation/bank.py b/simulation/bank.py
index 8ca8a4b..cdf7023 100644
--- a/simulation/bank.py
+++ b/simulation/bank.py
@@ -325,7 +325,7 @@ class Bank(IBankService):
                 total_deposit += deposit.amount
         return total_deposit
 
-    def run_tick(self, agents_dict: Dict[int, Any], current_tick: int = 0, reflux_system: Optional[Any] = None) -> List[Transaction]:
+    def run_tick(self, agents_dict: Dict[int, Any], current_tick: int = 0) -> List[Transaction]:
         self.current_tick_tracker = current_tick
         generated_transactions: List[Transaction] = []
         ticks_per_year = self._get_config("bank_defaults.ticks_per_year", TICKS_PER_YEAR)
@@ -405,7 +405,7 @@ class Bank(IBankService):
                  quantity=1.0,
                  price=net_profit,
                  market_id="financial",
-                 transaction_type="reflux_capture",
+                 transaction_type="bank_profit_remittance",
                  time=current_tick
              )
              generated_transactions.append(tx)
diff --git a/simulation/dtos/api.py b/simulation/dtos/api.py
index 01cec20..5a563ec 100644
--- a/simulation/dtos/api.py
+++ b/simulation/dtos/api.py
@@ -227,6 +227,7 @@ class SimulationState:
     bank: Any        # Bank
     central_bank: Any # CentralBank
     stock_market: Optional[Any] # StockMarket
+    stock_tracker: Optional[Any] # Added for WO-133 Fix
     goods_data: Dict[str, Any]
     market_data: Dict[str, Any] # Added for WO-103
     config_module: Any
diff --git a/simulation/firms.py b/simulation/firms.py
index 67a041b..87e8644 100644
--- a/simulation/firms.py
+++ b/simulation/firms.py
@@ -30,7 +30,6 @@ if TYPE_CHECKING:
     from simulation.ai.firm_system2_planner import FirmSystem2Planner
     from simulation.markets.stock_market import StockMarket
     from simulation.agents.government import Government
-    from simulation.systems.reflux_system import EconomicRefluxSystem
     from simulation.dtos.scenario import StressScenarioConfig
 
 logger = logging.getLogger(__name__)
diff --git a/simulation/metrics/economic_tracker.py b/simulation/metrics/economic_tracker.py
index 973be41..3fffd0b 100644
--- a/simulation/metrics/economic_tracker.py
+++ b/simulation/metrics/economic_tracker.py
@@ -287,9 +287,7 @@ class EconomicIndicatorTracker:
 
         M2 = Household_Assets + Firm_Assets + Bank_Reserves + Government_Assets
 
-        This calculation INTENTIONALLY EXCLUDES the EconomicRefluxSystem balance,
-        as it represents money in transit not yet realized by economic agents,
-        and also excludes the Central Bank's balance which is used for
+        This calculation excludes the Central Bank's balance which is used for
         system-level integrity checks.
         """
         total = 0.0
@@ -312,7 +310,6 @@ class EconomicIndicatorTracker:
         if world_state.government:
             total += world_state.government.assets
 
-        # NOTE: world_state.reflux_system.balance is INTENTIONALLY EXCLUDED.
         # NOTE: world_state.central_bank.assets is INTENTIONALLY EXCLUDED.
 
         return total
diff --git a/simulation/orchestration/phases.py b/simulation/orchestration/phases.py
index 3649891..7a6e15c 100644
--- a/simulation/orchestration/phases.py
+++ b/simulation/orchestration/phases.py
@@ -515,7 +515,7 @@ class Phase3_Transaction(IPhaseStrategy):
             welfare_txs = state.government.run_welfare_check(list(state.agents.values()), market_data_prev, state.time)
             system_transactions.extend(welfare_txs)
 
-            infra_txs = state.government.invest_infrastructure(state.time)
+            infra_txs = state.government.invest_infrastructure(state.time, state.households)
             if infra_txs:
                 system_transactions.extend(infra_txs)
 
diff --git a/simulation/orchestration/tick_orchestrator.py b/simulation/orchestration/tick_orchestrator.py
index 95e8de3..dd2db06 100644
--- a/simulation/orchestration/tick_orchestrator.py
+++ b/simulation/orchestration/tick_orchestrator.py
@@ -82,6 +82,7 @@ class TickOrchestrator:
             bank=state.bank,
             central_bank=state.central_bank,
             stock_market=state.stock_market,
+            stock_tracker=state.stock_tracker,
             goods_data=state.goods_data,
             market_data={}, # Will be populated in Phase 1 (and 0 for Gov)
             config_module=state.config_module,
diff --git a/simulation/service_firms.py b/simulation/service_firms.py
index 9678809..e5d6333 100644
--- a/simulation/service_firms.py
+++ b/simulation/service_firms.py
@@ -114,7 +114,7 @@ class ServiceFirm(Firm):
             extra={**log_extra, "capacity": capacity}
         )
 
-    def update_needs(self, current_time: int, government: Optional[Any] = None, market_data: Optional[Dict[str, Any]] = None, reflux_system: Optional[Any] = None) -> None:
+    def update_needs(self, current_time: int, government: Optional[Any] = None, market_data: Optional[Dict[str, Any]] = None, technology_manager: Optional[Any] = None) -> None:
         """
         서비스 기업 비용 처리.
         Holding Cost(보관비)는 0으로 처리 (서비스는 재고가 없으므로).
@@ -138,7 +138,7 @@ class ServiceFirm(Firm):
         # So paying holding cost on Capacity seems acceptable/desirable!
         # It simulates the cost of maintaining the readiness of the service.
 
-        super().update_needs(current_time, government, market_data, reflux_system)
+        super().update_needs(current_time, government, market_data, technology_manager)
 
     @override
     def get_agent_data(self) -> Dict[str, Any]:
diff --git a/simulation/systems/housing_system.py b/simulation/systems/housing_system.py
index d8b0e76..0a58687 100644
--- a/simulation/systems/housing_system.py
+++ b/simulation/systems/housing_system.py
@@ -69,15 +69,18 @@ class HousingSystem:
                 owner = simulation.agents.get(unit.owner_id)
                 if owner:
                     cost = unit.estimated_value * self.config.MAINTENANCE_RATE_PER_TICK
-                    if owner.assets >= cost:
-                        owner._sub_assets(cost)
-                        if simulation.reflux_system:
-                            simulation.reflux_system.capture(cost, f"{owner.id}", "housing_maintenance")
-                    else:
-                        taken = owner.assets
-                        owner._sub_assets(taken)
-                        if simulation.reflux_system:
-                            simulation.reflux_system.capture(taken, f"{owner.id}", "housing_maintenance")
+                    payable = min(cost, owner.assets)
+                    if payable > 0:
+                        # Use SettlementSystem for zero-sum transfer to Government
+                        if hasattr(simulation, 'settlement_system') and simulation.settlement_system and simulation.government:
+                            # Note: simulation.time might be needed if transfer requires it,
+                            # but SettlementSystem.transfer usually takes current_tick.
+                            # Checking SettlementSystem.transfer signature: transfer(payer, payee, amount, category, tick=None)
+                            # We can pass simulation.time if accessible.
+                            simulation.settlement_system.transfer(owner, simulation.government, payable, "housing_maintenance", tick=simulation.time)
+                        else:
+                            # Fallback (should not happen in full sim)
+                            owner._sub_assets(payable)
 
             # B. Rent Collection (Tenant pays Owner)
             if unit.occupant_id is not None and unit.owner_id is not None:
diff --git a/simulation/world_state.py b/simulation/world_state.py
index c8df7d8..64291af 100644
--- a/simulation/world_state.py
+++ b/simulation/world_state.py
@@ -128,7 +128,7 @@ class WorldState:
     def calculate_total_money(self) -> float:
         """
         Calculates the total money supply in the system.
-        Money_Total = Household_Assets + Firm_Assets + Bank_Reserves + Reflux_Balance + Government_Assets
+        Money_Total = Household_Assets + Firm_Assets + Bank_Reserves + Government_Assets
         (Government assets are INCLUDED to ensure zero-sum integrity during transfers)
         """
         total = 0.0
diff --git a/tests/test_engine.py b/tests/test_engine.py
index 9c0351b..24addfc 100644
--- a/tests/test_engine.py
+++ b/tests/test_engine.py
@@ -753,6 +753,7 @@ def test_handle_agent_lifecycle_removes_inactive_agents(setup_simulation_for_lif
         bank=sim.bank,
         central_bank=sim.central_bank if hasattr(sim, 'central_bank') else None,
         stock_market=sim.stock_market if hasattr(sim, 'stock_market') else None,
+        stock_tracker=sim.stock_tracker if hasattr(sim, 'stock_tracker') else None,
         goods_data=sim.goods_data,
         market_data={},
         config_module=sim.config_module,
