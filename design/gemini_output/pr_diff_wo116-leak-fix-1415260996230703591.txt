diff --git a/scripts/diagnose_money_leak.py b/scripts/diagnose_money_leak.py
index caf418c..cdd9602 100644
--- a/scripts/diagnose_money_leak.py
+++ b/scripts/diagnose_money_leak.py
@@ -48,7 +48,7 @@ def diagnose():
     last_b = get_balances()
     logger.info(f"START | Total: {last_b['total']:,.2f} | H: {last_b['h_active']:,.2f} | Bank: {last_b['bank']:,.2f}")
 
-    for tick in range(1, 11): # 초기 10틱만 집중 관찰
+    for tick in range(1, 101): # Run for 100 ticks
         sim.run_tick()
         curr_b = get_balances()
         diff = curr_b['total'] - last_b['total']
diff --git a/simulation/bank.py b/simulation/bank.py
index c9c606b..c24da75 100644
--- a/simulation/bank.py
+++ b/simulation/bank.py
@@ -318,6 +318,13 @@ class Bank(IFinancialEntity):
         generated_transactions: List[Transaction] = []
         ticks_per_year = self._get_config("bank_defaults.ticks_per_year", TICKS_PER_YEAR)
 
+        # Find Government for default processing & profit transfer
+        gov_agent = None
+        for a in agents_dict.values():
+             if a.__class__.__name__ == 'Government':
+                 gov_agent = a
+                 break
+
         # 1. Collect Interest from Loans
         total_loan_interest = 0.0
 
@@ -353,7 +360,7 @@ class Bank(IFinancialEntity):
                 total_loan_interest += payment
 
             else:
-                self.process_default(agent, loan, current_tick)
+                self.process_default(agent, loan, current_tick, government=gov_agent)
                 partial = agent.assets
                 if partial > 0:
                     tx = Transaction(
@@ -403,13 +410,6 @@ class Bank(IFinancialEntity):
         # 3. Bank Profit Capture (Reflux)
         net_profit = total_loan_interest - total_deposit_interest
 
-        # Find Government for profit transfer
-        gov_agent = None
-        for a in agents_dict.values():
-             if a.__class__.__name__ == 'Government':
-                 gov_agent = a
-                 break
-
         if net_profit > 0 and gov_agent:
              tx = Transaction(
                  buyer_id=self.id, # Bank pays
@@ -482,7 +482,7 @@ class Bank(IFinancialEntity):
 
             logger.warning(f"LENDER_OF_LAST_RESORT | Bank {self.id} insolvent! Borrowed {borrow_amount:.2f} from Government (Money Creation).")
 
-    def process_default(self, agent: Any, loan: Loan, current_tick: int):
+    def process_default(self, agent: Any, loan: Loan, current_tick: int, government: Optional[Any] = None):
         """
         Phase 4: Handles loan default.
         1. Liquidation: Sell assets (stocks, inventory) to repay.
@@ -500,6 +500,10 @@ class Bank(IFinancialEntity):
             logger.info(f"LIQUIDATION | Agent {agent.id} shares confiscated.")
 
         # 2. Forgiveness (Write-off)
+        if government and loan.remaining_balance > 0:
+            government.total_money_destroyed += loan.remaining_balance
+            logger.info(f"MONEY_DESTRUCTION | Loan Write-off {loan.remaining_balance:.2f} recorded as destroyed money.")
+
         loan.remaining_balance = 0.0 # Effectively forgiven
 
         # 3. Penalty
diff --git a/simulation/systems/lifecycle_manager.py b/simulation/systems/lifecycle_manager.py
index 2007946..2cadac8 100644
--- a/simulation/systems/lifecycle_manager.py
+++ b/simulation/systems/lifecycle_manager.py
@@ -116,10 +116,16 @@ class AgentLifecycleManager(AgentLifecycleManagerInterface):
                 inv_value = self._calculate_inventory_value(firm.inventory, state.markets)
                 if inv_value > 0:
                     state.reflux_system.capture(inv_value, str(firm.id), "liquidation_inventory")
+                    # FIX: Track Reflux Alchemy as Issuance
+                    if hasattr(state.government, "total_money_issued"):
+                        state.government.total_money_issued += inv_value
 
                 # 2. Capital Stock (Scrap Value)
                 if firm.capital_stock > 0:
                     state.reflux_system.capture(firm.capital_stock, str(firm.id), "liquidation_capital")
+                    # FIX: Track Reflux Alchemy as Issuance
+                    if hasattr(state.government, "total_money_issued"):
+                        state.government.total_money_issued += firm.capital_stock
 
             # SoC Refactor: use hr.employees
             for employee in firm.hr.employees:
@@ -133,15 +139,25 @@ class AgentLifecycleManager(AgentLifecycleManagerInterface):
             if total_cash > 0:
                 outstanding_shares = firm.total_shares - firm.treasury_shares
                 if outstanding_shares > 0:
-                    for household in state.households:
-                        if household.is_active and firm.id in household.shares_owned:
-                            share_ratio = household.shares_owned[firm.id] / outstanding_shares
+                    # Fix: Include Inactive Households (pre-inheritance) and Government
+                    shareholders = list(state.households)
+                    if hasattr(state, 'government') and state.government:
+                        shareholders.append(state.government)
+
+                    for agent in shareholders:
+                        # Check shares safely (Government might not have shares_owned init)
+                        shares = 0
+                        if hasattr(agent, "shares_owned"):
+                            shares = agent.shares_owned.get(firm.id, 0)
+
+                        if shares > 0:
+                            share_ratio = shares / outstanding_shares
                             distribution = total_cash * share_ratio
-                            household._add_assets(distribution)
+                            agent._add_assets(distribution)
                             self.logger.info(
-                                f"LIQUIDATION_DISTRIBUTION | Household {household.id} received "
+                                f"LIQUIDATION_DISTRIBUTION | Agent {agent.id} received "
                                 f"{distribution:.2f} from Firm {firm.id} liquidation",
-                                extra={"agent_id": household.id, "tags": ["liquidation"]}
+                                extra={"agent_id": agent.id, "tags": ["liquidation"]}
                             )
                 else:
                     from simulation.agents.government import Government
@@ -170,6 +186,9 @@ class AgentLifecycleManager(AgentLifecycleManagerInterface):
                 inv_value = self._calculate_inventory_value(household.inventory, state.markets)
                 if inv_value > 0:
                     state.reflux_system.capture(inv_value, str(household.id), "liquidation_inventory")
+                    # FIX: Track Reflux Alchemy as Issuance
+                    if hasattr(state.government, "total_money_issued"):
+                        state.government.total_money_issued += inv_value
 
             household.inventory.clear()
             household.shares_owned.clear()
diff --git a/simulation/systems/tax_agency.py b/simulation/systems/tax_agency.py
index 03a3bd1..2767b42 100644
--- a/simulation/systems/tax_agency.py
+++ b/simulation/systems/tax_agency.py
@@ -62,7 +62,7 @@ class TaxAgency:
 
         government.total_collected_tax += amount
         government.revenue_this_tick += amount
-        government.total_money_destroyed += amount
+        # government.total_money_destroyed += amount  <-- REMOVED: Tax is Transfer, not Destruction
         government.tax_revenue[tax_type] = (
             government.tax_revenue.get(tax_type, 0.0) + amount
         )
@@ -109,7 +109,7 @@ class TaxAgency:
 
         government.total_collected_tax += amount
         government.revenue_this_tick += amount
-        government.total_money_destroyed += amount
+        # government.total_money_destroyed += amount  <-- REMOVED: Tax is Transfer, not Destruction
         government.tax_revenue[tax_type] = government.tax_revenue.get(tax_type, 0.0) + amount
         government.current_tick_stats["tax_revenue"][tax_type] = government.current_tick_stats["tax_revenue"].get(tax_type, 0.0) + amount
         government.current_tick_stats["total_collected"] += amount
