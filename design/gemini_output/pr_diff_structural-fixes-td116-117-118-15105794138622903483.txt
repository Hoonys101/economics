diff --git a/modules/household/dtos.py b/modules/household/dtos.py
index 5cbb990..f47050e 100644
--- a/modules/household/dtos.py
+++ b/modules/household/dtos.py
@@ -7,6 +7,7 @@ from simulation.models import Share
 
 if TYPE_CHECKING:
     from simulation.core_markets import Market
+    from simulation.dtos.api import MarketSnapshotDTO
 
 @dataclass
 class HouseholdStateDTO:
@@ -56,7 +57,7 @@ class CloningRequestDTO:
 @dataclass
 class EconContextDTO:
     """Context for economic operations."""
-    markets: Dict[str, "Market"]
+    market_snapshot: "MarketSnapshotDTO"
     market_data: Dict[str, Any]
     current_time: int
 
diff --git a/modules/household/econ_component.py b/modules/household/econ_component.py
index 41b9282..b92320f 100644
--- a/modules/household/econ_component.py
+++ b/modules/household/econ_component.py
@@ -244,7 +244,7 @@ class EconComponent(IEconComponent):
         """
         market_data = context.market_data
         current_time = context.current_time
-        markets = context.markets
+        market_snapshot = context.market_snapshot
 
         # 1. System 2 Housing Decision (Run Logic)
         self._decide_housing(market_data, current_time)
@@ -254,21 +254,18 @@ class EconComponent(IEconComponent):
 
         # 3. Execute System 2 Housing Decision (Generate Orders)
         if self.housing_target_mode == "BUY" and self.is_homeless:
-            housing_market = markets.get("housing")
-            if housing_market:
-                target_unit_id = None
-                best_price = float('inf')
-
-                # Check for available units
-                if hasattr(housing_market, "sell_orders"):
-                    for item_id, sell_orders in housing_market.sell_orders.items():
-                        if item_id.startswith("unit_") and sell_orders:
-                            ask_price = sell_orders[0].price
-                            if ask_price < best_price:
-                                best_price = ask_price
-                                target_unit_id = item_id
-
-                if target_unit_id:
+            target_unit_id = None
+            best_price = float('inf')
+
+            # Check for available units via DTO
+            for item_id, asks in market_snapshot.asks.items():
+                if item_id.startswith("unit_") and asks:
+                    ask_price = asks[0].price
+                    if ask_price < best_price:
+                        best_price = ask_price
+                        target_unit_id = item_id
+
+            if target_unit_id:
                      # Check affordability (20% down payment)
                      down_payment = best_price * 0.2
                      if self.assets >= down_payment:
@@ -324,7 +321,7 @@ class EconComponent(IEconComponent):
 
             if order.order_type == "BUY" and order.target_agent_id is None:
                 # Select best seller
-                best_seller_id, best_price = self.market_component.choose_best_seller(order.item_id, {"markets": markets})
+                best_seller_id, best_price = self.market_component.choose_best_seller(order.item_id, {"market_snapshot": market_snapshot})
                 if best_seller_id:
                     order.target_agent_id = best_seller_id
             refined_orders.append(order)
diff --git a/simulation/components/market_component.py b/simulation/components/market_component.py
index bc3de41..9743a3c 100644
--- a/simulation/components/market_component.py
+++ b/simulation/components/market_component.py
@@ -17,16 +17,8 @@ class MarketComponent(IMarketComponent):
         """
         Selects the best seller based on Utility = (Quality^alpha * (1+Awareness)^beta * Loyalty) / Price.
         """
-        markets = context["markets"]
-        market = markets.get(item_id)
-        if not market:
-            return None, 0.0
-
-        # Assumes market has get_all_asks method returning list of orders
-        if not hasattr(market, 'get_all_asks'):
-            return None, 0.0
-
-        asks = market.get_all_asks(item_id)
+        market_snapshot = context["market_snapshot"]
+        asks = market_snapshot.asks.get(item_id, [])
         if not asks:
             return None, 0.0
 
diff --git a/simulation/core_agents.py b/simulation/core_agents.py
index 34d0aa5..8d6d5a5 100644
--- a/simulation/core_agents.py
+++ b/simulation/core_agents.py
@@ -14,7 +14,7 @@ from simulation.ai.api import (
     Aggressiveness,
 )
 from simulation.core_markets import Market
-from simulation.dtos import DecisionContext, LeisureEffectDTO, LeisureType, MacroFinancialContext, HouseholdConfigDTO
+from simulation.dtos import DecisionContext, LeisureEffectDTO, LeisureType, MacroFinancialContext, HouseholdConfigDTO, MarketSnapshotDTO, GovernmentPolicyDTO
 from simulation.portfolio import Portfolio
 
 from simulation.ai.household_ai import HouseholdAI
@@ -661,11 +661,11 @@ class Household(BaseAgent, ILearningAgent):
     @override
     def make_decision(
         self,
-        markets: Dict[str, "Market"],
+        market_snapshot: MarketSnapshotDTO,
+        government_policy: GovernmentPolicyDTO,
         goods_data: List[Dict[str, Any]],
         market_data: Dict[str, Any],
         current_time: int,
-        government: Optional[Any] = None,
         macro_context: Optional[MacroFinancialContext] = None,
         stress_scenario_config: Optional["StressScenarioConfig"] = None,
     ) -> Tuple[List["Order"], Tuple["Tactic", "Aggressiveness"]]:
@@ -737,11 +737,11 @@ class Household(BaseAgent, ILearningAgent):
         context = DecisionContext(
             state=state_dto,
             config=config_dto,
-            markets=markets,
+            market_snapshot=market_snapshot,
+            government_policy=government_policy,
             goods_data=goods_data,
             market_data=market_data,
             current_time=current_time,
-            government=government,
             stress_scenario_config=stress_scenario_config
         )
 
@@ -749,7 +749,7 @@ class Household(BaseAgent, ILearningAgent):
         orders, chosen_tactic_tuple = self.decision_engine.make_decisions(context, macro_context)
 
         # 3. Orchestrate/Refine Orders via EconComponent
-        econ_context = EconContextDTO(markets, market_data, current_time)
+        econ_context = EconContextDTO(market_snapshot, market_data, current_time)
         refined_orders = self.econ_component.orchestrate_economic_decisions(econ_context, orders, stress_scenario_config)
 
         return refined_orders, chosen_tactic_tuple
diff --git a/simulation/decisions/ai_driven_household_engine.py b/simulation/decisions/ai_driven_household_engine.py
index 491ed30..db985cc 100644
--- a/simulation/decisions/ai_driven_household_engine.py
+++ b/simulation/decisions/ai_driven_household_engine.py
@@ -51,9 +51,10 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
             from simulation.schemas import HouseholdActionVector
             return [], HouseholdActionVector()
 
-        markets = context.markets
+        # markets = context.markets # Removed in TD-117
         market_data = context.market_data
         current_time = context.current_time
+        market_snapshot = context.market_snapshot
 
         agent_data = household.agent_data
 
@@ -283,12 +284,10 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
 
         # 4. Stock Investment Logic
         stock_orders = self._make_stock_investment_decisions(
-            household, markets, market_data, action_vector, current_time, macro_context
+            household, market_data, action_vector, current_time, macro_context
         )
-        stock_market = markets.get("stock_market")
-        if stock_market is not None:
-            for stock_order in stock_orders:
-                stock_market.place_order(stock_order, current_time)
+        # TD-117: Do not place orders directly. Return them.
+        orders.extend(stock_orders)
 
         # 5. Liquidity Management
         stress_config = context.stress_scenario_config
@@ -330,8 +329,11 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
             orders.extend(emergency_orders)
 
         # 6. Real Estate Logic
-        if "housing" in markets:
-             housing_market = markets["housing"]
+        # TD-117: Use market_snapshot instead of markets["housing"]
+        # Check if housing items exist in asks
+        has_housing = any(k.startswith("unit_") for k in market_snapshot.asks.keys())
+
+        if has_housing:
              from simulation.decisions.housing_manager import HousingManager
 
              housing_manager = HousingManager(household, self.config_module) # Now passes DTO
@@ -456,7 +458,6 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
     def _make_stock_investment_decisions(
         self,
         household: "HouseholdStateDTO",
-        markets: Dict[str, Any],
         market_data: Dict[str, Any],
         action_vector: Any,
         current_time: int,
@@ -467,8 +468,8 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
         if not getattr(self.config_module, "STOCK_MARKET_ENABLED", False):
             return stock_orders
         
-        stock_market = markets.get("stock_market")
-        if stock_market is None:
+        stock_market_data = market_data.get("stock_market")
+        if not stock_market_data:
             return stock_orders
 
         if household.assets < self.config_module.HOUSEHOLD_MIN_ASSETS_FOR_INVESTMENT:
@@ -496,7 +497,12 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
             macro_context=macro_context
         )
 
-        current_prices = {firm_id: stock_market.get_stock_price(firm_id) for firm_id in household.portfolio_holdings.keys()}
+        current_prices = {}
+        stock_market_data = market_data.get("stock_market", {})
+        for firm_id in household.portfolio_holdings.keys():
+            item_key = f"stock_{firm_id}"
+            price_info = stock_market_data.get(item_key, {})
+            current_prices[firm_id] = price_info.get("avg_price", 0.0)
 
         # Calculate valuation manually for DTO
         current_equity_value = 0.0
@@ -507,9 +513,9 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
         equity_delta = target_equity - current_equity_value
 
         if equity_delta > self.config_module.STOCK_INVESTMENT_EQUITY_DELTA_THRESHOLD:
-            stock_orders.extend(self._place_buy_orders(household, equity_delta, stock_market, current_time))
+            stock_orders.extend(self._place_buy_orders(household, equity_delta, stock_market_data, current_time))
         elif equity_delta < -self.config_module.STOCK_INVESTMENT_EQUITY_DELTA_THRESHOLD:
-            stock_orders.extend(self._place_sell_orders(household, -equity_delta, stock_market, current_time))
+            stock_orders.extend(self._place_sell_orders(household, -equity_delta, stock_market_data, current_time))
         
         return stock_orders
 
@@ -520,9 +526,17 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
             return 5.0
         return 2.0
 
-    def _place_buy_orders(self, household: "HouseholdStateDTO", amount_to_invest: float, stock_market: Any, tick: int) -> List[StockOrder]:
+    def _place_buy_orders(self, household: "HouseholdStateDTO", amount_to_invest: float, stock_market_data: Dict[str, Any], tick: int) -> List[StockOrder]:
         orders = []
-        available_stocks = [fid for fid in stock_market.reference_prices.keys() if stock_market.get_stock_price(fid) > 0]
+        available_stocks = []
+        for key, info in stock_market_data.items():
+            if key.startswith("stock_") and info.get("avg_price", 0) > 0:
+                try:
+                    fid = int(key.replace("stock_", ""))
+                    available_stocks.append(fid)
+                except ValueError:
+                    pass
+
         if not available_stocks:
             return orders
 
@@ -530,7 +544,7 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
         investment_per_stock = amount_to_invest / diversification_count
         for _ in range(diversification_count):
             firm_id = random.choice(available_stocks)
-            price = stock_market.get_stock_price(firm_id)
+            price = stock_market_data.get(f"stock_{firm_id}", {}).get("avg_price", 0.0)
             if price > 0:
                 quantity = investment_per_stock / price
                 if quantity >= 1.0:
@@ -538,11 +552,15 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
                     orders.append(order)
         return orders
 
-    def _place_sell_orders(self, household: "HouseholdStateDTO", amount_to_sell: float, stock_market: Any, tick: int) -> List[StockOrder]:
+    def _place_sell_orders(self, household: "HouseholdStateDTO", amount_to_sell: float, stock_market_data: Dict[str, Any], tick: int) -> List[StockOrder]:
         orders = []
+
+        def get_price(fid):
+            return stock_market_data.get(f"stock_{fid}", {}).get("avg_price", 0.0)
+
         sorted_holdings = sorted(
             household.portfolio_holdings.items(),
-            key=lambda item: item[1].quantity * stock_market.get_stock_price(item[0]), # Access .quantity
+            key=lambda item: item[1].quantity * get_price(item[0]),
             reverse=True
         )
 
@@ -550,7 +568,7 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
             quantity = share.quantity
             if amount_to_sell <= 0:
                 break
-            price = stock_market.get_stock_price(firm_id)
+            price = get_price(firm_id)
             if price > 0:
                 value_of_holding = quantity * price
                 sell_value = min(amount_to_sell, value_of_holding)
diff --git a/simulation/dtos/api.py b/simulation/dtos/api.py
index 74eb39e..dd4ec84 100644
--- a/simulation/dtos/api.py
+++ b/simulation/dtos/api.py
@@ -2,6 +2,7 @@ from __future__ import annotations
 from dataclasses import dataclass, field
 from typing import Dict, Any, Optional, List, TYPE_CHECKING, Union
 from simulation.dtos.firm_state_dto import FirmStateDTO
+from simulation.models import Order
 
 if TYPE_CHECKING:
     from simulation.core_agents import Household
@@ -9,6 +10,28 @@ if TYPE_CHECKING:
     from simulation.dtos.scenario import StressScenarioConfig
     from modules.household.dtos import HouseholdStateDTO
 
+# ==============================================================================
+# TD-117: Structural Purity DTOs
+# ==============================================================================
+
+@dataclass
+class MarketSnapshotDTO:
+    """A pure-data snapshot of the state of all markets at a point in time."""
+    prices: Dict[str, float]
+    volumes: Dict[str, float]
+    asks: Dict[str, List[Order]] # For seller selection logic
+    bids: Dict[str, List[Order]] # For demand analysis (Shadow Mode)
+    # Add other aggregated market data as needed by decision engines
+
+@dataclass
+class GovernmentPolicyDTO:
+    """A pure-data snapshot of current government policies affecting agent decisions."""
+    income_tax_rate: float
+    sales_tax_rate: float
+    corporate_tax_rate: float
+    base_interest_rate: float
+    # Add other policy data as needed, e.g., welfare amounts, subsidies
+
 @dataclass
 class TransactionData:
     run_id: int
@@ -151,8 +174,8 @@ class DecisionContext:
     """
     A pure data container for decision-making.
     Direct agent instance access is strictly forbidden (Enforced by Purity Gate).
+    TD-117 CHANGE: Replaced live objects with DTOs.
     """
-    markets: Dict[str, Any]
     goods_data: List[Dict[str, Any]]
     market_data: Dict[str, Any]
     current_time: int
@@ -163,9 +186,13 @@ class DecisionContext:
     # Static configuration values relevant to the agent type
     config: Union[HouseholdConfigDTO, FirmConfigDTO]
 
-    government: Optional[Any] = None
-    reflux_system: Optional[Any] = None # Phase 8-B: Reflux System
-    stress_scenario_config: Optional[StressScenarioConfig] = None # Phase 28
+    # DTO-based context
+    market_snapshot: MarketSnapshotDTO
+    government_policy: GovernmentPolicyDTO
+
+    # Legacy systems passed through - to be phased out
+    reflux_system: Optional[Any] = None
+    stress_scenario_config: Optional[StressScenarioConfig] = None
 
 
 @dataclass
@@ -198,6 +225,8 @@ class SimulationState:
     transactions: List[Any] = None # List[Transaction]
     effects_queue: List[Dict[str, Any]] = None # WO-109: Queue for side-effects
     inactive_agents: Dict[int, Any] = None # WO-109: Store inactive agents
+    # TD-118: Planned consumption from Phase 1
+    planned_consumption: Optional[Dict[int, Dict[str, Any]]] = None
 
     def __post_init__(self):
         if self.transactions is None:
@@ -206,6 +235,8 @@ class SimulationState:
             self.effects_queue = []
         if self.inactive_agents is None:
             self.inactive_agents = {}
+        if self.planned_consumption is None:
+            self.planned_consumption = {}
 
 
 # ------------------------------------------------------------------------------
diff --git a/simulation/firms.py b/simulation/firms.py
index ca263c7..73cd630 100644
--- a/simulation/firms.py
+++ b/simulation/firms.py
@@ -11,7 +11,7 @@ from simulation.core_agents import Household
 from simulation.markets.order_book_market import OrderBookMarket
 from simulation.base_agent import BaseAgent
 from simulation.decisions.base_decision_engine import BaseDecisionEngine
-from simulation.dtos import DecisionContext, FirmConfigDTO
+from simulation.dtos import DecisionContext, FirmConfigDTO, MarketSnapshotDTO, GovernmentPolicyDTO
 from simulation.dtos.firm_state_dto import FirmStateDTO
 from simulation.ai.enums import Personality
 
@@ -314,7 +314,7 @@ class Firm(BaseAgent, ILearningAgent):
 
     @override
     def make_decision(
-        self, markets: Dict[str, Any], goods_data: list[Dict[str, Any]], market_data: Dict[str, Any], current_time: int, government: Optional[Any] = None, reflux_system: Optional[Any] = None, stress_scenario_config: Optional["StressScenarioConfig"] = None
+        self, market_snapshot: MarketSnapshotDTO, government_policy: GovernmentPolicyDTO, goods_data: list[Dict[str, Any]], market_data: Dict[str, Any], current_time: int, reflux_system: Optional[Any] = None, stress_scenario_config: Optional["StressScenarioConfig"] = None
     ) -> tuple[list[Order], Any]:
         log_extra = {"tick": current_time, "agent_id": self.id, "tags": ["firm_action"]}
         # SoC Refactor
@@ -335,11 +335,11 @@ class Firm(BaseAgent, ILearningAgent):
         context = DecisionContext(
             state=state_dto,
             config=config_dto,
-            markets=markets,
+            market_snapshot=market_snapshot,
+            government_policy=government_policy,
             goods_data=goods_data,
             market_data=market_data,
             current_time=current_time,
-            government=government,
             reflux_system=reflux_system,
             stress_scenario_config=stress_scenario_config,
         )
@@ -349,12 +349,13 @@ class Firm(BaseAgent, ILearningAgent):
         external_orders = []
         for order in decisions:
             if order.market_id == "internal":
-                self._execute_internal_order(order, government, current_time, reflux_system)
+                # Note: government access removed from make_decision, passing None.
+                self._execute_internal_order(order, None, current_time, reflux_system)
             else:
                 external_orders.append(order)
 
         # WO-056: Shadow Mode Calculation
-        self._calculate_invisible_hand_price(markets, current_time)
+        self._calculate_invisible_hand_price(market_snapshot, current_time)
 
         # SoC Refactor
         self.logger.debug(
@@ -444,19 +445,14 @@ class Firm(BaseAgent, ILearningAgent):
             self.productivity_factor *= 1.05
             self.logger.info(f"INTERNAL_EXEC | Firm {self.id} R&D SUCCESS (Budget: {budget:.1f})")
 
-    def _calculate_invisible_hand_price(self, markets: Dict[str, Any], current_tick: int) -> None:
+    def _calculate_invisible_hand_price(self, market_snapshot: MarketSnapshotDTO, current_tick: int) -> None:
         """
         WO-056: Stage 1 Shadow Mode (Price Discovery 2.0).
         Calculates and logs the shadow price based on Excess Demand.
         """
-        market = markets.get(self.specialization)
-        # Check if market supports order book inspection
-        if not market or not hasattr(market, 'get_all_bids'):
-            return
-
-        # 1. Get Demand and Supply (Market-wide for this good)
-        bids = market.get_all_bids(self.specialization)
-        asks = market.get_all_asks(self.specialization)
+        # 1. Get Demand and Supply (Market-wide for this good) from DTO
+        bids = market_snapshot.bids.get(self.specialization, [])
+        asks = market_snapshot.asks.get(self.specialization, [])
 
         demand = sum(o.quantity for o in bids)
         supply = sum(o.quantity for o in asks)
diff --git a/simulation/systems/api.py b/simulation/systems/api.py
index b8398ee..0fad337 100644
--- a/simulation/systems/api.py
+++ b/simulation/systems/api.py
@@ -21,7 +21,7 @@ if TYPE_CHECKING:
     from simulation.dtos import GovernmentStateDTO, LeisureEffectDTO
     from simulation.markets.market import Market
     from simulation.dtos.scenario import StressScenarioConfig
-    from simulation.dtos.api import SimulationState
+    from simulation.dtos.api import SimulationState, MarketSnapshotDTO
 
 
 # ===================================================================
@@ -67,7 +67,7 @@ class LifecycleContext(TypedDict):
 
 class MarketInteractionContext(TypedDict):
     """시장 상호작용 컴포넌트에 필요한 데이터입니다."""
-    markets: Dict[str, 'Market']
+    market_snapshot: 'MarketSnapshotDTO'
 
 class LearningUpdateContext(TypedDict):
     """에이전트의 AI 학습 업데이트에 필요한 데이터입니다."""
@@ -133,11 +133,17 @@ class ICommerceSystem(Protocol):
     """틱의 소비 및 여가 부분을 관리하는 시스템의 인터페이스입니다."""
     def __init__(self, config: Any, reflux_system: 'EconomicRefluxSystem'): ...
 
-    def execute_consumption_and_leisure(self, context: CommerceContext, scenario_config: Optional[StressScenarioConfig] = None) -> Dict[int, float]:
+    def plan_consumption_and_leisure(self, context: CommerceContext, scenario_config: Optional[StressScenarioConfig] = None) -> Tuple[Dict[int, Dict[str, Any]], List[Any]]:
         """
-        가계 소비, 긴급 구매(fast-track purchases), 여가 효과를 조율합니다.
+        Phase 1 (Decisions): 소비 및 여가 계획 수립.
         Returns:
-            Dict[int, float]: 가계 ID별 여가 효용(Leisure Utility) 맵.
+            Tuple[Dict, List[Order]]: (Consumption Plans, Generated Orders)
+        """
+        ...
+
+    def finalize_consumption_and_leisure(self, context: CommerceContext, planned_consumption: Dict[int, Dict[str, Any]]) -> Dict[int, float]:
+        """
+        Phase 4 (Lifecycle): 소비 실행 및 여가 효과 적용.
         """
         ...
 
diff --git a/simulation/systems/commerce_system.py b/simulation/systems/commerce_system.py
index c87fcf3..975d52b 100644
--- a/simulation/systems/commerce_system.py
+++ b/simulation/systems/commerce_system.py
@@ -1,7 +1,7 @@
 """
 Implements the CommerceSystem which orchestrates consumption, purchases, and leisure.
 """
-from typing import Any, Dict, List, Optional
+from typing import Any, Dict, List, Optional, Tuple
 import logging
 from simulation.systems.api import ICommerceSystem, CommerceContext
 from simulation.systems.reflux_system import EconomicRefluxSystem
@@ -17,21 +17,22 @@ class CommerceSystem(ICommerceSystem):
         self.config = config
         self.reflux_system = reflux_system
 
-    def execute_consumption_and_leisure(self, context: CommerceContext, scenario_config: Optional["StressScenarioConfig"] = None) -> Dict[int, float]:
+    def plan_consumption_and_leisure(self, context: CommerceContext, scenario_config: Optional["StressScenarioConfig"] = None) -> Tuple[Dict[int, Dict[str, Any]], List[Any]]:
         """
-        Executes vectorized consumption, applies fast-track purchases,
-        and calculates leisure effects. Incorporates stress scenario behavioral changes.
-
+        Phase 1 (Decisions): Determines desired consumption and leisure type.
         Returns:
-            Dict[int, float]: Map of Household ID to Utility Gained.
+            Tuple[Dict, List[Order]]: (Consumption Plans, Generated Orders)
         """
+        from simulation.models import Order
+
         households = context["households"]
         breeding_planner = context["breeding_planner"]
         time_allocation = context["household_time_allocation"]
         market_data = context["market_data"]
         current_time = context["time"]
 
-        household_leisure_effects: Dict[int, float] = {}
+        planned_consumption = {}
+        generated_orders = []
 
         # 1. Vectorized Decision Making
         batch_decisions = breeding_planner.decide_consumption_batch(households, market_data)
@@ -44,77 +45,81 @@ class CommerceSystem(ICommerceSystem):
             if not household.is_active:
                 continue
 
-            consumed_items = {}
+            plan = {
+                "consume_amt": 0.0,
+                "buy_amt": 0.0,
+                "leisure_hours": time_allocation.get(household.id, 0.0)
+            }
 
-            # 2a. Fast Consumption
+            # 2a. Plan Consumption
             if i < len(consume_list):
                 c_amt = consume_list[i]
 
-                # Phase 28: Deflationary Spiral - Consumption Collapse
+                # Phase 28: Deflationary Spiral
                 if scenario_config and scenario_config.is_active and scenario_config.scenario_name == 'deflation':
                     if not household.is_employed and scenario_config.consumption_pessimism_factor > 0:
-                        original_amt = c_amt
                         c_amt *= (1 - scenario_config.consumption_pessimism_factor)
-                        logger.debug(f"PESSIMISM_IMPACT | Household {household.id} consumption reduced from {original_amt:.2f} to {c_amt:.2f}")
 
                 if c_amt > 0:
-                    household.consume("basic_food", c_amt, current_time)
-                    consumed_items["basic_food"] = c_amt
+                    plan["consume_amt"] = c_amt
 
-            # 2b. Fast Purchase (Emergency Buy)
+            # 2b. Plan Purchase (Generate Order)
             if i < len(buy_list):
                 b_amt = buy_list[i]
                 if b_amt > 0:
-                    cost = b_amt * food_price
-                    if household.assets >= cost:
-                        household.withdraw(cost)
-                        household.inventory["basic_food"] = household.inventory.get("basic_food", 0) + b_amt
-
-                        # Capture money sink
-                        self.reflux_system.capture(cost, source=f"Household_{household.id}", category="emergency_food")
-
-                        logger.debug(
-                            f"VECTOR_BUY | Household {household.id} bought {b_amt:.1f} food (Fast Track)",
-                            extra={"agent_id": household.id, "tags": ["consumption", "vector_buy"]}
-                        )
-
-                        # Immediate consumption if needed
-                        if c_amt == 0:
-                            consume_now = min(b_amt, getattr(self.config, "FOOD_CONSUMPTION_QUANTITY", 1.0))
-                            household.consume("basic_food", consume_now, current_time)
-                            consumed_items["basic_food"] = consume_now
-
-            # 3. Leisure Effect
-            leisure_hours = time_allocation.get(household.id, 0.0)
-            effect_dto = household.apply_leisure_effect(leisure_hours, consumed_items)
+                    # Create Order instead of direct execution
+                    order = Order(
+                        agent_id=household.id,
+                        order_type="BUY",
+                        item_id="basic_food",
+                        quantity=b_amt,
+                        price=food_price * 1.5, # Willing to pay premium
+                        market_id="basic_food"
+                    )
+                    generated_orders.append(order)
+                    plan["buy_amt"] = b_amt
+
+            planned_consumption[household.id] = plan
+
+        return planned_consumption, generated_orders
+
+    def finalize_consumption_and_leisure(self, context: CommerceContext, planned_consumption: Dict[int, Dict[str, Any]]) -> Dict[int, float]:
+        """
+        Phase 4 (Lifecycle): Executes consumption from inventory and applies leisure effects.
+        """
+        households = context["households"]
+        current_time = context["time"]
+
+        household_leisure_effects: Dict[int, float] = {}
+
+        for household in households:
+            if not household.is_active:
+                continue
+
+            plan = planned_consumption.get(household.id, {})
+            consume_amt = plan.get("consume_amt", 0.0)
+            leisure_hours = plan.get("leisure_hours", 0.0)
 
+            consumed_items = {}
+
+            # Execute Consumption (Eat from Inventory)
+            if consume_amt > 0:
+                household.consume("basic_food", consume_amt, current_time)
+                consumed_items["basic_food"] = consume_amt
+
+            # Apply Leisure Effect
+            effect_dto = household.apply_leisure_effect(leisure_hours, consumed_items)
             household_leisure_effects[household.id] = effect_dto.utility_gained
 
-            # 4. Lifecycle Update (Needs, Tax, Psychology)
-            # This is now delegated to AgentLifecycleComponent inside household.update_needs
-            # But wait, household.update_needs calls labor_manager.work()!
-            # work() shouldn't be called here if it was already done or calculated.
-            # In the old `Simulation.run_tick`:
-            # - Transactions happened.
-            # - Then this loop happened.
-            # - household.update_needs() was called here.
-            # - household.update_needs() calls labor_manager.work(8.0)
-
-            # So we must call household.update_needs() here to maintain logic.
-            # BUT, we are refactoring update_needs to AgentLifecycleComponent.
-            # So we should call household.lifecycle.run_tick() ideally.
-            # Since household still has update_needs wrapping the new component (in the intermediate step),
-            # we call household.update_needs().
-
-            household.update_needs(current_time, market_data)
-
-            # 5. Parenting XP Transfer
+            # Parenting XP Transfer
             if effect_dto.leisure_type == "PARENTING" and effect_dto.xp_gained > 0:
                 agents = context.get("agents", {})
                 for child_id in household.children_ids:
-                    # Use O(1) lookup from agents dict
                     child = agents.get(child_id)
                     if child and getattr(child, "is_active", False):
                         child.education_xp += effect_dto.xp_gained
 
+            # CRITICAL: household.update_needs() is NOT called here.
+            # It is assumed to be called by AgentLifecycleManager in Phase 4.
+
         return household_leisure_effects
diff --git a/simulation/systems/transaction_processor.py b/simulation/systems/transaction_processor.py
index 496e397..35d0e41 100644
--- a/simulation/systems/transaction_processor.py
+++ b/simulation/systems/transaction_processor.py
@@ -110,17 +110,42 @@ class TransactionProcessor(SystemInterface):
                 heir_ids = tx.metadata.get("heir_ids", []) if tx.metadata else []
                 total_cash = buyer.assets
                 if total_cash > 0 and heir_ids:
-                    amount_per_heir = total_cash / len(heir_ids)
+                    import math
+                    count = len(heir_ids)
+                    # Calculate amount per heir, avoiding float precision issues
+                    base_amount = math.floor((total_cash / count) * 100) / 100.0
+
+                    distributed_sum = 0.0
                     all_success = True
-                    for h_id in heir_ids:
+
+                    # Distribute to all but the last heir
+                    for i in range(count - 1):
+                        h_id = heir_ids[i]
                         heir = agents.get(h_id)
                         if heir:
                             if settlement:
-                                if not settlement.transfer(buyer, heir, amount_per_heir, "inheritance_distribution"):
+                                if settlement.transfer(buyer, heir, base_amount, "inheritance_part"):
+                                    distributed_sum += base_amount
+                                else:
+                                    all_success = False
+                            else:
+                                buyer.withdraw(base_amount)
+                                heir.deposit(base_amount)
+                                distributed_sum += base_amount
+
+                    # Last heir gets the remainder to ensure zero-sum
+                    last_heir = agents.get(heir_ids[-1])
+                    if last_heir:
+                        remaining_amount = total_cash - distributed_sum
+                        # Ensure we don't transfer negative if something went wrong, though logic prevents it
+                        if remaining_amount > 0:
+                            if settlement:
+                                if not settlement.transfer(buyer, last_heir, remaining_amount, "inheritance_final"):
                                     all_success = False
                             else:
-                                buyer.withdraw(amount_per_heir)
-                                heir.deposit(amount_per_heir)
+                                buyer.withdraw(remaining_amount)
+                                last_heir.deposit(remaining_amount)
+
                     success = all_success
 
             elif tx.transaction_type == "goods":
diff --git a/simulation/tick_scheduler.py b/simulation/tick_scheduler.py
index 0bd0004..f8ce5a4 100644
--- a/simulation/tick_scheduler.py
+++ b/simulation/tick_scheduler.py
@@ -11,7 +11,9 @@ from simulation.agents.government import Government
 from simulation.dtos import (
     AIDecisionData,
     GovernmentStateDTO,
-    MacroFinancialContext
+    MacroFinancialContext,
+    MarketSnapshotDTO,
+    GovernmentPolicyDTO
 )
 from simulation.systems.api import (
     EventContext,
@@ -277,6 +279,39 @@ class TickScheduler:
         )
         state.household_time_allocation = household_time_allocation # Update state
 
+        # TD-118: Commerce Planning (Phase 1 Extension)
+        current_vacancies = 0
+        labor_market = state.markets.get("labor")
+        if labor_market and isinstance(labor_market, OrderBookMarket):
+             for item_orders in labor_market.buy_orders.values():
+                 for order in item_orders:
+                     current_vacancies += order.quantity
+
+        consumption_market_data = market_data.copy()
+        consumption_market_data["job_vacancies"] = current_vacancies
+
+        commerce_context: CommerceContext = {
+            "households": state.households,
+            "agents": state.agents,
+            "breeding_planner": state.breeding_planner,
+            "household_time_allocation": household_time_allocation,
+            "reflux_system": state.reflux_system,
+            "market_data": consumption_market_data,
+            "config": state.config_module,
+            "time": state.time
+        }
+
+        if state.commerce_system:
+            plans, commerce_orders = state.commerce_system.plan_consumption_and_leisure(commerce_context, state.stress_scenario_config)
+            sim_state.planned_consumption = plans
+            # Inject orders into markets
+            for order in commerce_orders:
+                target_market = state.markets.get(order.market_id)
+                if target_market:
+                    target_market.place_order(order, state.time)
+        else:
+            sim_state.planned_consumption = {}
+
         # 2. Matching
         self._phase_matching(sim_state)
 
@@ -300,29 +335,9 @@ class TickScheduler:
         # ---------------------------------------------------------
         # Activate Consumption Logic & Leisure Effects (via CommerceSystem)
         # ---------------------------------------------------------
-        current_vacancies = 0
-        labor_market = state.markets.get("labor")
-        if labor_market and isinstance(labor_market, OrderBookMarket):
-             for item_orders in labor_market.buy_orders.values():
-                 for order in item_orders:
-                     current_vacancies += order.quantity
-
-        consumption_market_data = market_data.copy()
-        consumption_market_data["job_vacancies"] = current_vacancies
-
-        commerce_context: CommerceContext = {
-            "households": state.households,
-            "agents": state.agents,
-            "breeding_planner": state.breeding_planner,
-            "household_time_allocation": household_time_allocation,
-            "reflux_system": state.reflux_system,
-            "market_data": consumption_market_data,
-            "config": state.config_module,
-            "time": state.time
-        }
-
+        # TD-118: Finalize Consumption (Phase 4 Extension)
         if state.commerce_system:
-            household_leisure_effects = state.commerce_system.execute_consumption_and_leisure(commerce_context, state.stress_scenario_config)
+            household_leisure_effects = state.commerce_system.finalize_consumption_and_leisure(commerce_context, sim_state.planned_consumption)
         else:
             state.logger.error("CommerceSystem not initialized! Skipping consumption cycle.")
             household_leisure_effects = {}
@@ -518,6 +533,10 @@ class TickScheduler:
         household_pre_states = {}
         household_time_allocation = {}
 
+        # TD-117: Create DTOs
+        market_snapshot = self._create_market_snapshot(state, market_data)
+        government_policy = self._create_government_policy(state)
+
         # 1. Firms
         for firm in state.firms:
             if firm.is_active:
@@ -541,15 +560,21 @@ class TickScheduler:
 
                 stress_config = self.world_state.stress_scenario_config
 
+                # TD-117: Pass DTOs
                 firm_orders, action_vector = firm.make_decision(
-                    state.markets, state.goods_data, market_data, state.time,
-                    state.government, state.reflux_system, stress_config
+                    market_snapshot, government_policy, state.goods_data, market_data, state.time,
+                    state.reflux_system, stress_config
                 )
 
                 for order in firm_orders:
-                    target_market = state.markets.get(order.market_id)
-                    if target_market:
-                        target_market.place_order(order, state.time)
+                    # TD-117: Handle StockOrder (returned, not placed directly)
+                    if hasattr(order, 'firm_id') or order.market_id == 'stock_market':
+                         if state.stock_market:
+                             state.stock_market.place_order(order, state.time)
+                    else:
+                        target_market = state.markets.get(order.market_id)
+                        if target_market:
+                            target_market.place_order(order, state.time)
 
                 state.logger.debug(f"TRACE_ENGINE | Firm {firm.id} submitted {len(firm_orders)} orders to markets.")
 
@@ -567,8 +592,10 @@ class TickScheduler:
                     }
 
                 stress_config = self.world_state.stress_scenario_config
+                # TD-117: Pass DTOs
                 household_orders, action_vector = household.make_decision(
-                    state.markets, state.goods_data, market_data, state.time, state.government, macro_context, stress_config
+                    market_snapshot, government_policy, state.goods_data, market_data, state.time,
+                    macro_context, stress_config
                 )
 
                 if hasattr(action_vector, 'work_aggressiveness'):
@@ -597,6 +624,12 @@ class TickScheduler:
                     elif order.item_id in ["deposit", "currency"]:
                         target_market_id = "loan_market"
 
+                    # TD-117: Handle StockOrder
+                    if hasattr(order, 'firm_id') or target_market_id == 'stock_market':
+                         if state.stock_market:
+                             state.stock_market.place_order(order, state.time)
+                         continue
+
                     household_target_market = state.markets.get(target_market_id)
 
                     if household_target_market:
@@ -611,6 +644,45 @@ class TickScheduler:
 
         return firm_pre_states, household_pre_states, household_time_allocation
 
+    def _create_market_snapshot(self, state: SimulationState, market_data: Dict[str, Any]) -> MarketSnapshotDTO:
+        prices = {}
+        volumes = {}
+        asks = {}
+        bids = {}
+
+        # Populate from market_data (which aggregates prices)
+        if "goods_market" in market_data:
+            for k, v in market_data["goods_market"].items():
+                if k.endswith("_current_sell_price"):
+                    item_id = k.replace("_current_sell_price", "")
+                    prices[item_id] = v
+
+        # Populate asks, bids and volumes from live markets
+        for market_id, market in state.markets.items():
+            if isinstance(market, OrderBookMarket):
+                # Asks for seller selection:
+                for item_id in market.sell_orders.keys():
+                    if item_id not in asks:
+                        asks[item_id] = []
+                    asks[item_id].extend(market.get_all_asks(item_id))
+
+                # Bids for demand analysis:
+                for item_id in market.buy_orders.keys():
+                    if item_id not in bids:
+                        bids[item_id] = []
+                    bids[item_id].extend(market.get_all_bids(item_id))
+
+        return MarketSnapshotDTO(prices=prices, volumes=volumes, asks=asks, bids=bids)
+
+    def _create_government_policy(self, state: SimulationState) -> GovernmentPolicyDTO:
+        # Default rates if not available
+        return GovernmentPolicyDTO(
+            income_tax_rate=getattr(state.government, 'income_tax_rate', 0.2),
+            sales_tax_rate=getattr(state.government, 'sales_tax_rate', 0.1),
+            corporate_tax_rate=getattr(state.government, 'corporate_tax_rate', 0.25),
+            base_interest_rate=state.central_bank.get_base_rate() if state.central_bank else 0.05
+        )
+
     def _phase_matching(self, state: SimulationState) -> None:
         """Phase 2: Match orders in all markets."""
         all_transactions = []
