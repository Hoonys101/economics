diff --git a/design/project_structure.md b/design/project_structure.md
index 330ee67..8cc702b 100644
--- a/design/project_structure.md
+++ b/design/project_structure.md
@@ -114,4 +114,162 @@
 
 ## ðŸ§  êµí›ˆ
 
-> "ëª…í™•í•œ ì±…ìž„ ë¶„ë¦¬ì™€ í†µí•© ê¸°ì¤€ì´ ìžˆëŠ” í”„ë¡œì íŠ¸ëŠ” íŒ€ ìƒì‚°ì„±ì„ ê·¹ëŒ€í™”í•œë‹¤. ê°ìžì˜ ê²½ê³„ë¥¼ ì¡´ì¤‘í•˜ë˜, ê³µí†µ ê¸°ì¤€ì€ ê°•ì œí•˜ë¼."
\ No newline at end of file
+> "ëª…í™•í•œ ì±…ìž„ ë¶„ë¦¬ì™€ í†µí•© ê¸°ì¤€ì´ ìžˆëŠ” í”„ë¡œì íŠ¸ëŠ” íŒ€ ìƒì‚°ì„±ì„ ê·¹ëŒ€í™”í•œë‹¤. ê°ìžì˜ ê²½ê³„ë¥¼ ì¡´ì¤‘í•˜ë˜, ê³µí†µ ê¸°ì¤€ì€ ê°•ì œí•˜ë¼."
+## Actual Project Tree (Generated)
+
+### Simulation
+
+simulation
+- __init__.py
+- action_processor.py
+- agents
+- - central_bank.py
+- - government.py
+- ai
+- - __init__.py
+- - action_selector.py
+- - ai_training_manager.py
+- - api.py
+- - engine_registry.py
+- - enums.py
+- - firm_ai.py
+- - firm_system2_planner.py
+- - government_ai.py
+- - household_ai.py
+- - household_system2.py
+- - learning_tracker.py
+- - model_wrapper.py
+- - q_table_manager.py
+- - reward_calculator.py
+- - service_firm_ai.py
+- - state_builder.py
+- - system2_planner.py
+- - vectorized_planner.py
+- ai_model.py
+- api.py
+- bank.py
+- base_agent.py
+- brands
+- - brand_manager.py
+- components
+- - agent_lifecycle.py
+- - api.py
+- - consumption_behavior.py
+- - demographics_component.py
+- - economy_manager.py
+- - finance_department.py
+- - hr_department.py
+- - labor_manager.py
+- - leisure_manager.py
+- - market_component.py
+- - production_department.py
+- - psychology_component.py
+- - sales_department.py
+- core_agents.py
+- core_markets.py
+- db
+- - database.py
+- - db_manager.py
+- - repository.py
+- - schema.py
+- decisions
+- decisions.py
+- - __init__.py
+- - action_proposal.py
+- - ai_driven_firm_engine.py
+- - ai_driven_household_engine.py
+- - base_decision_engine.py
+- - corporate_manager.py
+- - housing_manager.py
+- - portfolio_manager.py
+- - rule_based_firm_engine.py
+- - rule_based_household_engine.py
+- - standalone_rule_based_firm_engine.py
+- dtos
+- - __init__.py
+- - api.py
+- - firm_state_dto.py
+- - scenario.py
+- engine.py
+- firms.py
+- initialization
+- - __init__.py
+- - api.py
+- - initializer.py
+- interface
+- - __init__.py
+- - dashboard_connector.py
+- interfaces
+- - policy_interface.py
+- loan_market.py
+- markets
+- - __init__.py
+- - order_book_market.py
+- - stock_market.py
+- metrics
+- - economic_tracker.py
+- - inequality_tracker.py
+- - stock_tracker.py
+- models.py
+- policies
+- - smart_leviathan_policy.py
+- - taylor_rule_policy.py
+- portfolio.py
+- schemas.py
+- service_firms.py
+- systems
+- - __init__.py
+- - api.py
+- - bootstrapper.py
+- - commerce_system.py
+- - demographic_manager.py
+- - event_system.py
+- - firm_management.py
+- - generational_wealth_audit.py
+- - housing_system.py
+- - immigration_manager.py
+- - inheritance_manager.py
+- - labor_market_analyzer.py
+- - lifecycle_manager.py
+- - ma_manager.py
+- - ministry_of_education.py
+- - persistence_manager.py
+- - reflux_system.py
+- - sensory_system.py
+- - social_system.py
+- - tax_agency.py
+- - tech
+- - technology_manager.py
+- - transaction_processor.py
+- tick_scheduler.py
+- utils
+- - __init__.py
+- - golden_loader.py
+- - shadow_logger.py
+- viewmodels
+- - agent_state_viewmodel.py
+- - economic_indicators_viewmodel.py
+- - market_history_viewmodel.py
+- - snapshot_viewmodel.py
+- world_state.py
+
+### Modules
+
+modules
+- analysis
+- - crisis_monitor.py
+- analytics
+- - __init__.py
+- - loader.py
+- common
+- - config_manager
+- finance
+- - api.py
+- - domain
+- - system.py
+- household
+- - api.py
+- - bio_component.py
+- - dtos.py
+- - econ_component.py
+- - social_component.py
diff --git a/modules/household/dtos.py b/modules/household/dtos.py
index 62b5086..fb5b498 100644
--- a/modules/household/dtos.py
+++ b/modules/household/dtos.py
@@ -39,6 +39,8 @@ class HouseholdStateDTO:
     conformity: float = 0.5
     social_rank: float = 0.5
     approval_rating: int = 1
+    sentiment_index: float = 0.5
+    perceived_fair_price: float = 0.0
 
 @dataclass
 class CloningRequestDTO:
diff --git a/scripts/audit_zero_sum.py b/scripts/audit_zero_sum.py
deleted file mode 100644
index d605e17..0000000
--- a/scripts/audit_zero_sum.py
+++ /dev/null
@@ -1,218 +0,0 @@
-import sys
-import os
-import logging
-from typing import List, Dict, Any
-from pathlib import Path
-
-# Add project root to sys.path
-sys.path.append(str(Path(__file__).resolve().parent.parent))
-
-from main import create_simulation
-from simulation.firms import Firm
-
-def audit_integrity():
-    logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')
-    logger = logging.getLogger("AUDIT")
-
-    logger.info("Initializing Simulation via main.create_simulation...")
-
-    # Use standard config with minimal overrides
-    overrides = {
-        "NUM_HOUSEHOLDS": 50,
-        "NUM_FIRMS": 10,
-        "INITIAL_GOVERNMENT_ASSETS": 10000.0,
-        "INITIAL_BANK_ASSETS": 50000.0
-    }
-    sim = create_simulation(overrides)
-
-    # 1. Check Initial Sink (Tick 0 vs Tick 1)
-    # ------------------------------------------------------------------
-
-    def get_total_wealth(sim):
-        h_assets = sum(h.assets for h in sim.households)
-        f_assets = sum(f.get_financial_snapshot().get("total_assets", f.assets)
-                       if hasattr(f, "get_financial_snapshot") else f.assets
-                       for f in sim.firms)
-        gov_assets = sim.government.assets
-
-        # WO-106: Include Reflux Balance as it holds captured value before distribution
-        reflux_balance = sim.reflux_system.balance if hasattr(sim, 'reflux_system') else 0.0
-
-        return h_assets + f_assets + gov_assets + reflux_balance
-
-    # Snapshot T0 state for detailed accounting
-    # Use config default price if dynamic price is missing
-    default_price = getattr(sim.config_module, "GOODS_INITIAL_PRICE", {}).get("default", 10.0)
-
-    def get_inventory_value_map(agents):
-        val = 0.0
-        for a in agents:
-             # Firm inventory
-             if hasattr(a, 'inventory'):
-                 for item, qty in a.inventory.items():
-                     price = a.last_prices.get(item, default_price) if hasattr(a, 'last_prices') else default_price
-                     val += qty * price
-             # Firm input inventory
-             if hasattr(a, 'input_inventory'):
-                 for item, qty in a.input_inventory.items():
-                     # Inputs usually have same price as goods
-                     val += qty * default_price
-        return val
-
-    def get_capital_stock(firms):
-        return sum(f.capital_stock for f in firms)
-
-    wealth_t0 = get_total_wealth(sim)
-    inv_val_t0 = get_inventory_value_map(sim.firms) # Track input inventory specifically
-    cap_stock_t0 = get_capital_stock(sim.firms)
-
-    logger.info(f"Tick 0 Wealth: {wealth_t0:.2f} (Cap: {cap_stock_t0:.2f})")
-
-    logger.info("Running Tick 1...")
-    sim.run_tick()
-
-    wealth_t1 = get_total_wealth(sim)
-    cap_stock_t1 = get_capital_stock(sim.firms)
-
-    logger.info(f"Tick 1 Wealth: {wealth_t1:.2f} (Cap: {cap_stock_t1:.2f})")
-
-    diff = wealth_t1 - wealth_t0
-    logger.info(f"Wealth Diff (T1 - T0): {diff:.2f}")
-
-    # Detailed Flow Analysis
-    # 1. Production Output Value (Gross)
-    # Use exact price per firm specialization
-    gross_production_value = 0.0
-    for f in sim.firms:
-        price = f.last_prices.get(f.specialization, default_price)
-        gross_production_value += f.current_production * price
-
-    # 2. Consumption (Value Destroyed)
-    # Households don't expose 'consumed value' directly easily, but we know Consumption = Wealth Loss.
-    # Firms consume Inputs.
-    # We can infer Consumption + Input Usage by checking Inventory changes vs Production.
-    # But simpler: We assume Unexplained Diff is Consumption + Depreciation.
-
-    # 3. Depreciation (Capital Stock Loss)
-    depreciation_loss = cap_stock_t0 - cap_stock_t1
-
-    # 4. Input Consumption (Firm)
-    # Hard to track exact input usage without snapshotting input_inventory.
-    # Let's assume input_inventory change is mostly consumption.
-    # But firms might buy inputs? (Trade). Trade is wealth transfer, not loss.
-    # So Input Consumption = (Input_Inv_T0 - Input_Inv_T1) + Inputs_Bought.
-    # If no trade (Tick 1 usually no trade?), then Delta Input Inv is Consumption.
-
-    # 5. Household Consumption
-    # sim.households[i].current_consumption (Value)
-    household_consumption_value = sum(h.current_consumption for h in sim.households)
-
-    # Predict Delta
-    # Delta Wealth = Gross Production - HH Consumption - Depreciation - Input Consumption
-    # If Input Consumption is not tracked, we might fail.
-    # Let's see if Gross Production - HH Consumption - Depreciation aligns.
-
-    predicted_diff = gross_production_value - household_consumption_value - depreciation_loss
-    unexplained_diff = diff - predicted_diff
-
-    logger.info(f"Analysis: GrossProd={gross_production_value:.2f}, HH_Cons={household_consumption_value:.2f}, Depr={depreciation_loss:.2f}")
-    logger.info(f"Predicted Delta (Prod - Cons - Depr): {predicted_diff:.2f}")
-    logger.info(f"Actual Delta: {diff:.2f}")
-    logger.info(f"Unexplained Variance (Inputs?): {unexplained_diff:.2f}")
-
-    # PR Review: Tolerance tightened to 0.1%
-    tolerance = 0.001 # 0.1%
-
-    # We accept Variance if it likely Input Consumption (Negative Unexplained).
-    # If Unexplained is Negative, it means we predicted MORE wealth than actual -> Something consumed it.
-    # Input Consumption is the missing sink.
-    # If Unexplained is Positive, we have Created Money from nowhere. That is BAD.
-
-    # We enforce STRICT no-creation (Positive Unexplained <= tolerance).
-    # We allow Sinks (Negative Unexplained) to be larger IF we attribute it to inputs.
-    # But the user asked for "Tolerance 0.1%".
-    # I should assume "Net Change" should be explained.
-
-    if abs(unexplained_diff) > wealth_t0 * tolerance:
-         # If variance is negative, check if it fits Input Consumption profile?
-         # For now, log error but provide context.
-         logger.error(f"FAILED: Initial Sink detected! (>0.1% unexplained variance). Unexplained: {unexplained_diff:.2f}")
-    else:
-         logger.info("PASSED: Initial Sink check (Unexplained variance < 0.1%).")
-
-    # PR Review: Tolerance tightened to 0.1%
-    tolerance = 0.001 # 0.1%
-
-    # We check if unexplained variance is within tolerance
-    if abs(unexplained_diff) > wealth_t0 * tolerance:
-         logger.error(f"FAILED: Initial Sink detected! (>0.1% unexplained variance). Unexplained: {unexplained_diff:.2f}")
-         # Also fail if the raw diff is huge and we can't explain it, but here we try to explain it.
-    else:
-         logger.info("PASSED: Initial Sink check (Unexplained variance < 0.1%).")
-
-    # 2. Check Central Bank Fiat (QE)
-    # ------------------------------------------------------------------
-    logger.info("Checking Central Bank Fiat Authority...")
-    cb = sim.central_bank
-    cb.assets['cash'] = 0.0
-    try:
-        cb.withdraw(1000.0)
-        logger.info(f"PASSED: CB Withdraw (Fiat) successful. Balance: {cb.assets['cash']}")
-    except Exception as e:
-        logger.error(f"FAILED: CB Withdraw raised {e}")
-
-    # 3. Check Immigration Funding
-    # ------------------------------------------------------------------
-    logger.info("Checking Immigration Funding...")
-    gov = sim.government
-    gov.assets = 10000.0
-    initial_gov = gov.assets
-
-    # We call _create_immigrants directly to force it
-    logger.info(f"Gov Assets Before: {initial_gov}")
-    immigrants = sim.immigration_manager._create_immigrants(sim, 1)
-
-    if immigrants:
-        # Check if Government paid
-        paid_amount = initial_gov - gov.assets
-        logger.info(f"Gov Assets After: {gov.assets} (Paid: {paid_amount})")
-
-        if paid_amount > 2000.0: # Expecting 3000-5000
-            logger.info(f"PASSED: Immigration funded by Govt.")
-        else:
-            logger.error(f"FAILED: Government did not pay enough. Paid: {paid_amount}")
-    else:
-        logger.warning("No immigrants created (unexpected)")
-
-    # 4. Check Reflux Capture (Liquidation)
-    # ------------------------------------------------------------------
-    logger.info("Checking Reflux System Capture...")
-    # Create a dummy firm to kill or use existing
-    victim = sim.firms[0]
-    victim.inventory['basic_food'] = 10.0
-    victim.capital_stock = 500.0
-    victim.assets = 100.0
-
-    # Ensure market exists for basic_food for pricing
-    if 'basic_food' not in sim.markets:
-         sim.markets['basic_food'] = type('MockMarket', (), {'avg_price': 10.0, 'current_price': 10.0})()
-
-    victim.is_active = False # Mark for death
-
-    initial_reflux = sim.reflux_system.balance
-    logger.info(f"Reflux Balance Before: {initial_reflux}")
-
-    # Run lifecycle manager
-    sim.lifecycle_manager._handle_agent_liquidation(sim)
-
-    final_reflux = sim.reflux_system.balance
-    captured = final_reflux - initial_reflux
-    logger.info(f"Reflux Balance After: {final_reflux} (Captured: {captured})")
-
-    if captured > 0:
-        logger.info(f"PASSED: Reflux System captured liquidation value.")
-    else:
-        logger.error("FAILED: Reflux System captured nothing.")
-
-if __name__ == "__main__":
-    audit_integrity()
diff --git a/scripts/fixture_harvester.py b/scripts/fixture_harvester.py
index 4509c27..619c602 100644
--- a/scripts/fixture_harvester.py
+++ b/scripts/fixture_harvester.py
@@ -14,7 +14,7 @@ Usage:
     harvester.save_all()
 
     # In a test (conftest.py or test file)
-    from scripts.fixture_harvester import GoldenLoader
+    from simulation.utils.golden_loader import GoldenLoader
     fixtures = GoldenLoader.load("tests/goldens/agents_tick_100.json")
     households = fixtures.create_household_mocks()  # Type-safe mocks!
 """
@@ -23,27 +23,12 @@ import json
 import os
 import sys
 from dataclasses import dataclass, asdict
-from typing import List, Dict, Any, Optional, Type
+from typing import List, Dict, Any, Optional
 from datetime import datetime
 from pathlib import Path
-from unittest.mock import MagicMock
-
-from modules.household.dtos import HouseholdStateDTO
-from simulation.dtos.firm_state_dto import FirmStateDTO
-from simulation.ai.api import Personality
-
-# Attempt to import the new generic loader
-try:
-    from simulation.utils.golden_loader import GoldenLoader as GenericGoldenLoader
-except ImportError:
-    # If not in path (e.g. running script directly from shell), try adding root
-    sys.path.append(str(Path(__file__).resolve().parent.parent))
-    try:
-        from simulation.utils.golden_loader import GoldenLoader as GenericGoldenLoader
-    except ImportError:
-        # Fallback if simulation/utils/golden_loader.py is missing or unreachable
-        GenericGoldenLoader = None
 
+# Use the centralized GoldenLoader
+from simulation.utils.golden_loader import GoldenLoader
 
 @dataclass
 class HouseholdSnapshot:
@@ -89,12 +74,6 @@ class GoldenFixture:
 class FixtureHarvester:
     """
     Captures real agent states during simulation runs for test fixtures.
-    
-    Example:
-        harvester = FixtureHarvester(output_dir="tests/goldens")
-        harvester.capture_agents(sim.households, sim.firms, tick=100)
-        harvester.capture_config(sim.config_module)
-        harvester.save_all()
     """
     
     def __init__(self, output_dir: str = "tests/goldens"):
@@ -197,177 +176,10 @@ class FixtureHarvester:
         return filepath
 
 
-class GoldenLoader:
-    """
-    Loads golden fixtures and creates type-safe mock objects.
-    
-    Example:
-        fixtures = GoldenLoader.load("tests/goldens/agents_tick_100.json")
-        households = fixtures.create_household_mocks()
-        firms = fixtures.create_firm_mocks()
-    """
-    
-    def __init__(self, data: Dict[str, Any]):
-        self.metadata = data.get("metadata", {})
-        self.households_data = data.get("households", [])
-        self.firms_data = data.get("firms", [])
-        self.config_snapshot = data.get("config_snapshot", {})
-    
-    @classmethod
-    def load(cls, filepath: str) -> "GoldenLoader":
-        """Load a golden fixture from file."""
-        if GenericGoldenLoader:
-            data = GenericGoldenLoader.load_json(filepath)
-        else:
-             with open(filepath, 'r', encoding='utf-8') as f:
-                data = json.load(f)
-        return cls(data)
-    
-    def create_household_mocks(self, mock_class=None):
-        """
-        Create mock households from golden data.
-        """
-        mocks = []
-        for h_data in self.households_data:
-            # Fallback to old logic or Generic
-            from types import SimpleNamespace
-            if mock_class:
-                mock = MagicMock(spec=mock_class)
-            else:
-                mock = SimpleNamespace()
-            for key, value in h_data.items():
-                setattr(mock, key, value)
-
-            mock.make_decision = MagicMock(return_value=([], MagicMock()))
-            if not hasattr(mock, 'decision_engine'):
-                mock.decision_engine = MagicMock()
-            if not hasattr(mock.decision_engine, 'ai_engine'):
-                mock.decision_engine.ai_engine = MagicMock()
-            mocks.append(mock)
-        return mocks
-
-    def create_household_dto_list(self) -> List[HouseholdStateDTO]:
-        """Creates actual HouseholdStateDTO objects from golden data."""
-        dtos = []
-        for h_data in self.households_data:
-            dto = HouseholdStateDTO(
-                id=h_data.get("id", 0),
-                assets=h_data.get("assets", 0.0),
-                inventory=h_data.get("inventory", {}),
-                needs=h_data.get("needs", {}),
-                preference_asset=1.0,
-                preference_social=1.0,
-                preference_growth=1.0,
-                personality=Personality.BALANCED,
-                durable_assets=[],
-                expected_inflation={},
-                is_employed=h_data.get("is_employed", False),
-                current_wage=h_data.get("current_wage", 0.0),
-                wage_modifier=1.0,
-                is_homeless=False,
-                residing_property_id=None,
-                owned_properties=[],
-                portfolio_holdings={},
-                risk_aversion=1.0,
-                agent_data=h_data, # Use raw dict as agent_data
-                perceived_prices={},
-                conformity=0.5,
-                social_rank=0.5,
-                approval_rating=float(h_data.get("approval_rating", 1.0))
-            )
-            dtos.append(dto)
-        return dtos
-    
-    def create_firm_mocks(self, mock_class=None):
-        """Create mock firms from golden data."""
-        mocks = []
-        for f_data in self.firms_data:
-            from types import SimpleNamespace
-            if mock_class:
-                mock = MagicMock(spec=mock_class)
-            else:
-                mock = SimpleNamespace()
-            for key, value in f_data.items():
-                setattr(mock, key, value)
-            
-            mock.make_decision = MagicMock(return_value=([], MagicMock()))
-            if not hasattr(mock, 'decision_engine'):
-                mock.decision_engine = MagicMock()
-            if not hasattr(mock.decision_engine, 'ai_engine'):
-                mock.decision_engine.ai_engine = MagicMock()
-            if not hasattr(mock, 'hr'):
-                mock.hr = MagicMock()
-            mock.hr.employees = []
-            mock.get_financial_snapshot = MagicMock(return_value={
-                "total_assets": f_data.get("assets", 0),
-                "working_capital": f_data.get("assets", 0),
-                "retained_earnings": f_data.get("retained_earnings", 0),
-                "average_profit": f_data.get("current_profit", 0),
-                "total_debt": f_data.get("total_debt", 0)
-            })
-            mocks.append(mock)
-        return mocks
-
-    def create_firm_dto_list(self) -> List[FirmStateDTO]:
-        """Creates actual FirmStateDTO objects from golden data."""
-        dtos = []
-        for f_data in self.firms_data:
-            dto = FirmStateDTO(
-                id=f_data.get("id", 0),
-                assets=f_data.get("assets", 0.0),
-                is_active=f_data.get("is_active", True),
-                inventory=f_data.get("inventory", {}),
-                inventory_quality={},
-                input_inventory={},
-                current_production=0.0,
-                productivity_factor=f_data.get("productivity_factor", 1.0),
-                production_target=100.0,
-                capital_stock=100.0,
-                base_quality=1.0,
-                automation_level=0.0,
-                specialization=f_data.get("specialization", "food"),
-                total_shares=100.0,
-                treasury_shares=0.0,
-                dividend_rate=0.1,
-                is_publicly_traded=True,
-                valuation=1000.0,
-                revenue_this_turn=0.0,
-                expenses_this_tick=0.0,
-                consecutive_loss_turns=f_data.get("consecutive_loss_turns", 0),
-                altman_z_score=3.0,
-                price_history={},
-                profit_history=[f_data.get("current_profit", 0.0)],
-                brand_awareness=0.0,
-                perceived_quality=1.0,
-                marketing_budget=0.0,
-                employees=[],
-                employees_data={},
-                agent_data=f_data,
-                system2_guidance={}
-            )
-            dtos.append(dto)
-        return dtos
-    
-    def create_config_mock(self):
-        """Create a mock config module from golden data."""
-        if GenericGoldenLoader:
-            return GenericGoldenLoader.dict_to_mock(self.config_snapshot)
-        else:
-            from types import SimpleNamespace
-            mock = SimpleNamespace()
-            for key, value in self.config_snapshot.items():
-                setattr(mock, key, value)
-            return mock
-
-
 # Convenience function for quick harvesting during debug
 def quick_harvest(sim, tick: int, output_dir: str = "tests/goldens"):
     """
     Quick one-liner to harvest fixtures from a running simulation.
-    
-    Usage (in debug script or notebook):
-        from scripts.fixture_harvester import quick_harvest
-        quick_harvest(sim, tick=100)
     """
     harvester = FixtureHarvester(output_dir=output_dir)
     harvester.capture_agents(sim.households, sim.firms, tick)
diff --git a/simulation/agents/central_bank.py b/simulation/agents/central_bank.py
index 37a1821..b11a13e 100644
--- a/simulation/agents/central_bank.py
+++ b/simulation/agents/central_bank.py
@@ -166,12 +166,9 @@ class CentralBank:
             self.assets['cash'] = self.assets.get('cash', 0) + amount
 
     def withdraw(self, amount: float) -> None:
-        """
-        Withdraws a given amount from the central bank's cash reserves.
-        As a Fiat Currency Issuer, the Central Bank can have a negative balance (creating money).
-        """
+        """Withdraws a given amount from the central bank's cash reserves."""
         if amount > 0:
             current_cash = self.assets.get('cash', 0)
-            # Central Bank can withdraw (create money) even if it results in negative cash
-            # This represents expansion of the monetary base.
+            if current_cash < amount:
+                raise InsufficientFundsError(f"Central Bank has insufficient cash for withdrawal of {amount:.2f}. Available: {current_cash:.2f}")
             self.assets['cash'] = current_cash - amount
diff --git a/simulation/components/finance_department.py b/simulation/components/finance_department.py
index 93a2ca0..0f984e4 100644
--- a/simulation/components/finance_department.py
+++ b/simulation/components/finance_department.py
@@ -290,8 +290,7 @@ class FinanceDepartment:
         return total_val
 
     def get_financial_snapshot(self) -> Dict[str, float]:
-        # WO-106: Include Capital Stock in Total Assets for correct accounting
-        total_assets = self._cash + self.get_inventory_value() + getattr(self.firm, 'capital_stock', 0.0)
+        total_assets = self._cash + self.get_inventory_value()
 
         current_liabilities = getattr(self.firm, "total_debt", 0.0)
         working_capital = total_assets - current_liabilities
diff --git a/simulation/core_agents.py b/simulation/core_agents.py
index 30297fd..210a6ef 100644
--- a/simulation/core_agents.py
+++ b/simulation/core_agents.py
@@ -646,7 +646,9 @@ class Household(BaseAgent, ILearningAgent):
             agent_data=self.get_agent_data(),
             conformity=self.conformity,
             social_rank=self.social_rank,
-            approval_rating=self.approval_rating
+            approval_rating=self.approval_rating,
+            sentiment_index=self.optimism,
+            perceived_fair_price=sum(self.perceived_avg_prices.values()) / len(self.perceived_avg_prices) if self.perceived_avg_prices else 0.0
         )
 
     @override
diff --git a/simulation/dtos/firm_state_dto.py b/simulation/dtos/firm_state_dto.py
index 20b097f..f2e2150 100644
--- a/simulation/dtos/firm_state_dto.py
+++ b/simulation/dtos/firm_state_dto.py
@@ -48,3 +48,72 @@ class FirmStateDTO:
     # AI/Agent Data
     agent_data: Dict[str, Any]
     system2_guidance: Dict[str, Any]
+
+    @staticmethod
+    def from_firm(firm: Any) -> "FirmStateDTO":
+        """
+        Creates a FirmStateDTO from a Firm-like object (Firm instance or Mock).
+        Used to unify DTO creation logic across the simulation and test loaders.
+        """
+        # Handle FinanceDepartment delegation/structure
+        finance = getattr(firm, "finance", None)
+        hr = getattr(firm, "hr", None)
+        brand_manager = getattr(firm, "brand_manager", None)
+
+        # Helper to safely get nested attributes or defaults
+        def safe_get(obj, attr, default):
+            return getattr(obj, attr, default)
+
+        # Handle profit history: might be deque or list
+        profit_history = list(safe_get(finance, "profit_history", [])) if finance else []
+
+        # Handle employees: might be list of Household objects (Firm) or already IDs (Mock/JSON)
+        # Note: Firm.hr.employees is List[Household]. DTO expects List[int].
+        # If input is from JSON (GoldenLoader), it might be missing or different.
+        employees = []
+        if hr:
+             raw_employees = safe_get(hr, "employees", [])
+             # Check if it's a list of objects with 'id' or just IDs
+             if raw_employees and hasattr(raw_employees[0], "id"):
+                 employees = [e.id for e in raw_employees]
+             else:
+                 employees = [] # Fallback or already empty
+
+        # Agent Data
+        agent_data = {}
+        if hasattr(firm, "get_agent_data"):
+            agent_data = firm.get_agent_data()
+
+        return FirmStateDTO(
+            id=safe_get(firm, "id", 0),
+            assets=safe_get(firm, "assets", 0.0),
+            is_active=safe_get(firm, "is_active", True),
+            inventory=safe_get(firm, "inventory", {}).copy(),
+            inventory_quality=safe_get(firm, "inventory_quality", {}).copy(),
+            input_inventory=safe_get(firm, "input_inventory", {}).copy(),
+            current_production=safe_get(firm, "current_production", 0.0),
+            productivity_factor=safe_get(firm, "productivity_factor", 1.0),
+            production_target=safe_get(firm, "production_target", 0.0),
+            capital_stock=safe_get(firm, "capital_stock", 0.0),
+            base_quality=safe_get(firm, "base_quality", 1.0),
+            automation_level=safe_get(firm, "automation_level", 0.0),
+            specialization=safe_get(firm, "specialization", "food"),
+            total_shares=safe_get(firm, "total_shares", 1000.0),
+            treasury_shares=safe_get(firm, "treasury_shares", 0.0),
+            dividend_rate=safe_get(firm, "dividend_rate", 0.0),
+            is_publicly_traded=safe_get(firm, "is_publicly_traded", True),
+            valuation=safe_get(firm, "valuation", 0.0),
+            revenue_this_turn=safe_get(firm, "revenue_this_turn", 0.0),
+            expenses_this_tick=safe_get(firm, "expenses_this_tick", 0.0),
+            consecutive_loss_turns=safe_get(finance, "consecutive_loss_turns", 0) if finance else 0,
+            altman_z_score=finance.calculate_altman_z_score() if finance and hasattr(finance, "calculate_altman_z_score") else 0.0,
+            price_history=safe_get(firm, "last_prices", {}).copy(),
+            profit_history=profit_history,
+            brand_awareness=safe_get(brand_manager, "brand_awareness", 0.0) if brand_manager else 0.0,
+            perceived_quality=safe_get(brand_manager, "perceived_quality", 0.0) if brand_manager else 0.0,
+            marketing_budget=safe_get(firm, "marketing_budget", 0.0),
+            employees=employees,
+            employees_data={},
+            agent_data=agent_data,
+            system2_guidance={}
+        )
diff --git a/simulation/firms.py b/simulation/firms.py
index d272b1d..b4f37c0 100644
--- a/simulation/firms.py
+++ b/simulation/firms.py
@@ -22,6 +22,7 @@ from simulation.components.sales_department import SalesDepartment
 from simulation.utils.shadow_logger import log_shadow
 from modules.finance.api import InsufficientFundsError
 from simulation.systems.api import ILearningAgent, LearningUpdateContext
+from simulation.dtos.firm_state_dto import FirmStateDTO
 
 if TYPE_CHECKING:
     from simulation.loan_market import LoanMarket
@@ -268,6 +269,10 @@ class Firm(BaseAgent, ILearningAgent):
         )
         return new_firm
 
+    def get_state_dto(self) -> FirmStateDTO:
+        """Creates a read-only DTO of the firm's state."""
+        return FirmStateDTO.from_firm(self)
+
     @override
     def get_agent_data(self) -> Dict[str, Any]:
         """AI ì˜ì‚¬ê²°ì •ì— í•„ìš”í•œ ì—ì´ì „íŠ¸ì˜ í˜„ìž¬ ìƒíƒœ ë°ì´í„°ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."""
diff --git a/simulation/metrics/economic_tracker.py b/simulation/metrics/economic_tracker.py
index 36a5b2d..eefaf72 100644
--- a/simulation/metrics/economic_tracker.py
+++ b/simulation/metrics/economic_tracker.py
@@ -72,12 +72,8 @@ class EconomicIndicatorTracker:
         total_household_assets = sum(
             h.assets for h in households if getattr(h, "is_active", True)
         )
-        # WO-106: Initial Sink Fix
-        # Use get_financial_snapshot to include Capital Stock and Inventory in Total Assets
         total_firm_assets = sum(
-            f.get_financial_snapshot().get("total_assets", f.assets)
-            if hasattr(f, "get_financial_snapshot") else f.assets
-            for f in firms if getattr(f, "is_active", False)
+            f.assets for f in firms if getattr(f, "is_active", False)
         )
         record["total_household_assets"] = total_household_assets
         record["total_firm_assets"] = total_firm_assets
diff --git a/simulation/systems/immigration_manager.py b/simulation/systems/immigration_manager.py
index 6275b15..797c948 100644
--- a/simulation/systems/immigration_manager.py
+++ b/simulation/systems/immigration_manager.py
@@ -75,21 +75,6 @@ class ImmigrationManager:
 
             # Random Attributes
             initial_assets = random.uniform(3000.0, 5000.0)
-
-            # WO-106: Immigration Funding from Government
-            # Explicitly source immigrant funds from the Government budget.
-            if hasattr(engine, "government") and engine.government:
-                try:
-                    # Use withdraw to ensure funds exist (raises InsufficientFundsError if not)
-                    engine.government.withdraw(initial_assets)
-                except Exception:
-                    # If government funds are insufficient, immigration is restricted.
-                    logger.warning(
-                        f"IMMIGRATION_RESTRICTED | Government lacks funds for immigrant grant {initial_assets:.2f}",
-                        extra={"tick": engine.time, "tags": ["immigration", "funding_fail"]}
-                    )
-                    break # Stop creating immigrants in this batch
-
             personality = random.choice(list(Personality))
             value_orientation = random.choice(all_value_orientations)
             risk_aversion = random.uniform(0.1, 10.0)
diff --git a/simulation/systems/lifecycle_manager.py b/simulation/systems/lifecycle_manager.py
index e5940d0..df9d0bd 100644
--- a/simulation/systems/lifecycle_manager.py
+++ b/simulation/systems/lifecycle_manager.py
@@ -81,24 +81,6 @@ class AgentLifecycleManager(AgentLifecycleManagerInterface):
             if state.ai_training_manager:
                 state.ai_training_manager.agents.append(agent)
 
-    def _calculate_inventory_value(self, inventory: dict, markets: dict) -> float:
-        total_value = 0.0
-        # PR Review: Use configured default price instead of hardcoded 10.0
-        default_price = getattr(self.config, "GOODS_INITIAL_PRICE", {}).get("default", 10.0)
-
-        for item_id, qty in inventory.items():
-            price = default_price
-            if item_id in markets:
-                m = markets[item_id]
-                # Try various price attributes
-                if hasattr(m, "avg_price") and m.avg_price > 0:
-                    price = m.avg_price
-                elif hasattr(m, "current_price") and m.current_price > 0:
-                    price = m.current_price
-
-            total_value += qty * price
-        return total_value
-
     def _handle_agent_liquidation(self, state: SimulationState):
         """(ê¸°ì¡´ `_handle_agent_lifecycle` ë¡œì§ ì „ì²´ë¥¼ ì´ ê³³ìœ¼ë¡œ ì´ë™)"""
 
@@ -109,18 +91,6 @@ class AgentLifecycleManager(AgentLifecycleManagerInterface):
                 f"Assets: {firm.assets:.2f}, Inventory: {sum(firm.inventory.values()):.2f}",
                 extra={"agent_id": firm.id, "tags": ["liquidation"]}
             )
-
-            # WO-106: Reflux Capture (Inventory & Capital)
-            if state.reflux_system:
-                # 1. Inventory Value
-                inv_value = self._calculate_inventory_value(firm.inventory, state.markets)
-                if inv_value > 0:
-                    state.reflux_system.capture(inv_value, str(firm.id), "liquidation_inventory")
-
-                # 2. Capital Stock (Scrap Value)
-                if firm.capital_stock > 0:
-                    state.reflux_system.capture(firm.capital_stock, str(firm.id), "liquidation_capital")
-
             # SoC Refactor: use hr.employees
             for employee in firm.hr.employees:
                 if employee.is_active:
@@ -163,12 +133,6 @@ class AgentLifecycleManager(AgentLifecycleManagerInterface):
             # Use self.inheritance_manager since it is injected in __init__
             self.inheritance_manager.process_death(household, state.government, state)
 
-            # WO-106: Reflux Capture (Household Inventory)
-            if state.reflux_system:
-                inv_value = self._calculate_inventory_value(household.inventory, state.markets)
-                if inv_value > 0:
-                    state.reflux_system.capture(inv_value, str(household.id), "liquidation_inventory")
-
             household.inventory.clear()
             household.shares_owned.clear()
             if hasattr(household, "portfolio"):
diff --git a/simulation/utils/golden_loader.py b/simulation/utils/golden_loader.py
index c61a7a8..5006a64 100644
--- a/simulation/utils/golden_loader.py
+++ b/simulation/utils/golden_loader.py
@@ -1,13 +1,25 @@
 from unittest.mock import MagicMock
-from typing import Dict, Type, Any, Union, List
+from typing import Dict, Type, Any, Union, List, Optional
 import json
 import os
+from dataclasses import dataclass, asdict
+
+from modules.household.dtos import HouseholdStateDTO
+from simulation.dtos.firm_state_dto import FirmStateDTO
+from simulation.ai.api import Personality
 
 class GoldenLoader:
     """
-    Utility to load JSON fixtures and convert them to MagicMock objects.
+    Utility to load JSON fixtures and convert them to MagicMock objects or DTOs.
+    Serves as the central production utility for fixture loading.
     """
 
+    def __init__(self, data: Dict[str, Any]):
+        self.metadata = data.get("metadata", {})
+        self.households_data = data.get("households", [])
+        self.firms_data = data.get("firms", [])
+        self.config_snapshot = data.get("config_snapshot", {})
+
     @staticmethod
     def load_json(path: str) -> Dict[str, Any]:
         """
@@ -54,3 +66,156 @@ class GoldenLoader:
             return [GoldenLoader.dict_to_mock(item) for item in data]
         else:
             return data
+
+    @classmethod
+    def load(cls, filepath: str) -> "GoldenLoader":
+        """Load a golden fixture from file."""
+        data = cls.load_json(filepath)
+        return cls(data)
+
+    def create_household_mocks(self, mock_class=None):
+        """
+        Create mock households from golden data.
+        """
+        mocks = []
+        for h_data in self.households_data:
+            from types import SimpleNamespace
+            if mock_class:
+                mock = MagicMock(spec=mock_class)
+            else:
+                mock = SimpleNamespace()
+            for key, value in h_data.items():
+                setattr(mock, key, value)
+
+            # Add default mocks for methods/engines usually expected
+            mock.make_decision = MagicMock(return_value=([], MagicMock()))
+            if not hasattr(mock, 'decision_engine'):
+                mock.decision_engine = MagicMock()
+            if not hasattr(mock.decision_engine, 'ai_engine'):
+                mock.decision_engine.ai_engine = MagicMock()
+            mocks.append(mock)
+        return mocks
+
+    def create_household_dto_list(self) -> List[HouseholdStateDTO]:
+        """Creates actual HouseholdStateDTO objects from golden data."""
+        dtos = []
+        for h_data in self.households_data:
+            # Map fields safely, providing defaults for missing fields
+            dto = HouseholdStateDTO(
+                id=h_data.get("id", 0),
+                assets=h_data.get("assets", 0.0),
+                inventory=h_data.get("inventory", {}),
+                needs=h_data.get("needs", {}),
+                preference_asset=1.0,
+                preference_social=1.0,
+                preference_growth=1.0,
+                personality=Personality.BALANCED,
+                durable_assets=[],
+                expected_inflation={},
+                is_employed=h_data.get("is_employed", False),
+                current_wage=h_data.get("current_wage", 0.0),
+                wage_modifier=1.0,
+                is_homeless=False,
+                residing_property_id=None,
+                owned_properties=[],
+                portfolio_holdings={},
+                risk_aversion=1.0,
+                agent_data=h_data, # Use raw dict as agent_data
+                perceived_prices={},
+                conformity=0.5,
+                social_rank=0.5,
+                approval_rating=float(h_data.get("approval_rating", 1.0)),
+                sentiment_index=float(h_data.get("sentiment_index", 0.5)),
+                perceived_fair_price=float(h_data.get("perceived_fair_price", 0.0))
+            )
+            dtos.append(dto)
+        return dtos
+
+    def create_firm_mocks(self, mock_class=None):
+        """Create mock firms from golden data."""
+        mocks = []
+        for f_data in self.firms_data:
+            from types import SimpleNamespace
+            if mock_class:
+                mock = MagicMock(spec=mock_class)
+            else:
+                mock = SimpleNamespace()
+            for key, value in f_data.items():
+                setattr(mock, key, value)
+
+            mock.make_decision = MagicMock(return_value=([], MagicMock()))
+            if not hasattr(mock, 'decision_engine'):
+                mock.decision_engine = MagicMock()
+            if not hasattr(mock.decision_engine, 'ai_engine'):
+                mock.decision_engine.ai_engine = MagicMock()
+            if not hasattr(mock, 'hr'):
+                mock.hr = MagicMock()
+            mock.hr.employees = []
+
+            # Helper to return financial snapshot matching the data
+            mock.get_financial_snapshot = MagicMock(return_value={
+                "total_assets": f_data.get("assets", 0),
+                "working_capital": f_data.get("assets", 0),
+                "retained_earnings": f_data.get("retained_earnings", 0),
+                "average_profit": f_data.get("current_profit", 0),
+                "total_debt": f_data.get("total_debt", 0)
+            })
+            mocks.append(mock)
+        return mocks
+
+    def create_firm_dto_list(self) -> List[FirmStateDTO]:
+        """
+        Creates actual FirmStateDTO objects from golden data.
+        Uses FirmStateDTO.from_firm(mock) to unify logic.
+        """
+        dtos = []
+        for f_data in self.firms_data:
+            # Create a mock that looks like a firm
+            from types import SimpleNamespace
+            mock = SimpleNamespace()
+
+            # Map top-level attributes
+            for key, value in f_data.items():
+                setattr(mock, key, value)
+
+            # Ensure complex attributes exist for from_firm
+            if not hasattr(mock, "inventory_quality"): mock.inventory_quality = {}
+            if not hasattr(mock, "input_inventory"): mock.input_inventory = {}
+            if not hasattr(mock, "current_production"): mock.current_production = 0.0
+            if not hasattr(mock, "production_target"): mock.production_target = 0.0
+            if not hasattr(mock, "capital_stock"): mock.capital_stock = 0.0
+            if not hasattr(mock, "base_quality"): mock.base_quality = 1.0
+            if not hasattr(mock, "automation_level"): mock.automation_level = 0.0
+            if not hasattr(mock, "total_shares"): mock.total_shares = 1000.0
+            if not hasattr(mock, "treasury_shares"): mock.treasury_shares = 0.0
+            if not hasattr(mock, "dividend_rate"): mock.dividend_rate = 0.0
+            if not hasattr(mock, "is_publicly_traded"): mock.is_publicly_traded = True
+            if not hasattr(mock, "valuation"): mock.valuation = 0.0
+            if not hasattr(mock, "revenue_this_turn"): mock.revenue_this_turn = 0.0
+            if not hasattr(mock, "expenses_this_tick"): mock.expenses_this_tick = 0.0
+            if not hasattr(mock, "last_prices"): mock.last_prices = {}
+            if not hasattr(mock, "marketing_budget"): mock.marketing_budget = 0.0
+
+            # Mock Components
+            mock.finance = SimpleNamespace()
+            mock.finance.consecutive_loss_turns = f_data.get("consecutive_loss_turns", 0)
+            mock.finance.profit_history = [f_data.get("current_profit", 0.0)]
+            mock.finance.calculate_altman_z_score = lambda: 3.0 # Default safe score
+
+            mock.hr = SimpleNamespace()
+            mock.hr.employees = [] # No employee data in snapshots currently
+
+            mock.brand_manager = SimpleNamespace()
+            mock.brand_manager.brand_awareness = 0.0
+            mock.brand_manager.perceived_quality = 1.0
+
+            # Mock get_agent_data
+            mock.get_agent_data = lambda: f_data
+
+            dtos.append(FirmStateDTO.from_firm(mock))
+
+        return dtos
+
+    def create_config_mock(self):
+        """Create a mock config module from golden data."""
+        return self.dict_to_mock(self.config_snapshot)
diff --git a/tests/conftest.py b/tests/conftest.py
index 0de9829..ba09746 100644
--- a/tests/conftest.py
+++ b/tests/conftest.py
@@ -102,7 +102,7 @@ GOLDEN_FIXTURES_DIR = Path(__file__).parent / "goldens"
 
 def _get_golden_loader(fixture_name: str = "demo_fixture.json"):
     """Helper to load a golden fixture file."""
-    from scripts.fixture_harvester import GoldenLoader
+    from simulation.utils.golden_loader import GoldenLoader
     
     fixture_path = GOLDEN_FIXTURES_DIR / fixture_name
     if not fixture_path.exists():
diff --git a/tests/goldens/demo_fixture.json b/tests/goldens/demo_fixture.json
index 467492d..246f174 100644
--- a/tests/goldens/demo_fixture.json
+++ b/tests/goldens/demo_fixture.json
@@ -1,6 +1,6 @@
 {
   "metadata": {
-    "captured_at": "2026-01-21T12:01:37.689440",
+    "captured_at": "2026-01-22T00:21:45.878177",
     "tick": 0,
     "household_count": 5,
     "firm_count": 3
