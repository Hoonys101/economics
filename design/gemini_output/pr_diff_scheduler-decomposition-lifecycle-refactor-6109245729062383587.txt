diff --git a/simulation/dtos/api.py b/simulation/dtos/api.py
index 4004327..e9220ad 100644
--- a/simulation/dtos/api.py
+++ b/simulation/dtos/api.py
@@ -241,19 +241,44 @@ class SimulationState:
     real_estate_units: List[Any] = field(default_factory=list) # Added for WO-103
     # Mutable state for the tick
     transactions: List[Any] = None # List[Transaction]
+    inter_tick_queue: List[Any] = None # List[Transaction]
     effects_queue: List[Dict[str, Any]] = None # WO-109: Queue for side-effects
     inactive_agents: Dict[int, Any] = None # WO-109: Store inactive agents
+
+    # --- NEW TRANSIENT FIELDS ---
+    # From Phase 1 (Decisions)
+    firm_pre_states: Dict[int, Any] = None
+    household_pre_states: Dict[int, Any] = None
+    household_time_allocation: Dict[int, float] = None
+
+    # From Commerce System (planned in Phase 1, used in PostSequence)
     planned_consumption: Optional[Dict[int, Dict[str, Any]]] = None # TD-118
 
+    # From Lifecycle (used in PostSequence for Learning)
+    household_leisure_effects: Dict[int, float] = None
+
+    # Injection
+    injectable_sensory_dto: Optional[Any] = None # GovernmentStateDTO
+
     def __post_init__(self):
         if self.transactions is None:
             self.transactions = []
+        if self.inter_tick_queue is None:
+            self.inter_tick_queue = []
         if self.effects_queue is None:
             self.effects_queue = []
         if self.inactive_agents is None:
             self.inactive_agents = {}
+        if self.firm_pre_states is None:
+            self.firm_pre_states = {}
+        if self.household_pre_states is None:
+            self.household_pre_states = {}
+        if self.household_time_allocation is None:
+            self.household_time_allocation = {}
         if self.planned_consumption is None:
             self.planned_consumption = {}
+        if self.household_leisure_effects is None:
+            self.household_leisure_effects = {}
 
 
 # ------------------------------------------------------------------------------
diff --git a/simulation/engine.py b/simulation/engine.py
index e21d243..38dff80 100644
--- a/simulation/engine.py
+++ b/simulation/engine.py
@@ -9,7 +9,7 @@ from simulation.metrics.economic_tracker import EconomicIndicatorTracker
 from simulation.systems.tech.api import FirmTechInfoDTO, HouseholdEducationDTO
 
 from simulation.world_state import WorldState
-from simulation.tick_scheduler import TickScheduler
+from simulation.orchestration.tick_orchestrator import TickOrchestrator
 from simulation.action_processor import ActionProcessor
 from simulation.models import Transaction
 
@@ -37,14 +37,14 @@ class Simulation:
             repository=repository
         )
         self.action_processor = ActionProcessor(self.world_state)
-        self.tick_scheduler = TickScheduler(self.world_state, self.action_processor)
+        self.tick_orchestrator = TickOrchestrator(self.world_state, self.action_processor)
 
     def __getattr__(self, name: str) -> Any:
         return getattr(self.world_state, name)
 
     def __setattr__(self, name: str, value: Any) -> None:
         # Avoid infinite recursion for internal components
-        if name in ["world_state", "tick_scheduler", "action_processor"]:
+        if name in ["world_state", "tick_orchestrator", "action_processor"]:
             super().__setattr__(name, value)
             return
 
@@ -64,7 +64,7 @@ class Simulation:
         self.world_state.logger.info("Simulation finalized and Repository connection closed.")
 
     def run_tick(self, injectable_sensory_dto: Optional[GovernmentStateDTO] = None) -> None:
-        self.tick_scheduler.run_tick(injectable_sensory_dto)
+        self.tick_orchestrator.run_tick(injectable_sensory_dto)
 
     def orchestrate_production_and_tech(self, tick: int) -> None:
         """
@@ -108,8 +108,9 @@ class Simulation:
     # --- Backward Compatibility Methods ---
 
     def _prepare_market_data(self, tracker: EconomicIndicatorTracker) -> Dict[str, Any]:
-        """Legacy wrapper for TickScheduler.prepare_market_data"""
-        return self.tick_scheduler.prepare_market_data(tracker)
+        """Legacy wrapper for TickOrchestrator.prepare_market_data"""
+        # Note: Tracker argument is ignored as orchestrator uses internal state
+        return self.tick_orchestrator.prepare_market_data()
 
     def _calculate_total_money(self) -> float:
         """Legacy wrapper for WorldState.calculate_total_money"""
diff --git a/simulation/firms.py b/simulation/firms.py
index b31ed94..05f7004 100644
--- a/simulation/firms.py
+++ b/simulation/firms.py
@@ -567,29 +567,10 @@ class Firm(BaseAgent, ILearningAgent):
     @override
     def update_needs(self, current_time: int, government: Optional[Any] = None, market_data: Optional[Dict[str, Any]] = None, reflux_system: Optional[Any] = None, technology_manager: Optional[Any] = None) -> None:
         """
-        Lifecycle updates (Age, Bankruptcy Check).
-        Financial transactions are now in generate_transactions.
-        Production is in produce.
+        [DEPRECATED] This logic has been moved to AgentLifecycleManager._process_firm_lifecycle.
+        Kept for BaseAgent interface compliance.
         """
-        self.age += 1
-
-        # --- Final State Updates & Checks ---
-        self.needs["liquidity_need"] = min(100.0, self.needs["liquidity_need"] + self.config_module.LIQUIDITY_NEED_INCREASE_RATE)
-        self.finance.check_bankruptcy()
-
-        # SoC Refactor
-        if self.assets <= self.config_module.ASSETS_CLOSURE_THRESHOLD or self.finance.consecutive_loss_turns >= self.config_module.FIRM_CLOSURE_TURNS_THRESHOLD:
-            self.is_active = False
-            self.logger.warning(
-                f"FIRM_INACTIVE | Firm {self.id} closed down. Assets: {self.assets:.2f}, Consecutive Loss Turns: {self.finance.consecutive_loss_turns}",
-                extra={
-                    "tick": current_time,
-                    "agent_id": self.id,
-                    "assets": self.assets,
-                    "consecutive_loss_turns": self.finance.consecutive_loss_turns,
-                    "tags": ["firm_closure"],
-                },
-            )
+        pass
 
     # Legacy: _pay_maintenance and _pay_taxes removed as they are now in FinanceDepartment
 
diff --git a/simulation/orchestration/api.py b/simulation/orchestration/api.py
new file mode 100644
index 0000000..4384d49
--- /dev/null
+++ b/simulation/orchestration/api.py
@@ -0,0 +1,20 @@
+from __future__ import annotations
+from typing import Protocol, TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from simulation.dtos.api import SimulationState
+
+class IPhaseStrategy(Protocol):
+    """Interface for a single phase of the simulation tick."""
+
+    def execute(self, state: SimulationState) -> SimulationState:
+        """
+        Executes the logic for this phase.
+
+        Args:
+            state: The current simulation state DTO for the tick.
+
+        Returns:
+            The potentially modified simulation state DTO.
+        """
+        ...
diff --git a/simulation/orchestration/phases.py b/simulation/orchestration/phases.py
new file mode 100644
index 0000000..b68d2e2
--- /dev/null
+++ b/simulation/orchestration/phases.py
@@ -0,0 +1,656 @@
+from __future__ import annotations
+from typing import List, Dict, Any, Optional, Tuple, TYPE_CHECKING
+import logging
+
+from simulation.orchestration.api import IPhaseStrategy
+from simulation.dtos.api import (
+    SimulationState, MarketSnapshotDTO, GovernmentPolicyDTO,
+    DecisionContext, MacroFinancialContext, AIDecisionData
+)
+from simulation.dtos import (
+    GovernmentStateDTO
+)
+from simulation.core_agents import Household
+from simulation.firms import Firm
+from simulation.markets.order_book_market import OrderBookMarket
+from simulation.systems.api import (
+    EventContext, SocialMobilityContext, SensoryContext,
+    CommerceContext, LearningUpdateContext
+)
+from simulation.models import Transaction
+
+if TYPE_CHECKING:
+    from simulation.world_state import WorldState
+    from simulation.action_processor import ActionProcessor
+    from simulation.metrics.economic_tracker import EconomicIndicatorTracker
+    from simulation.dtos.scenario import StressScenarioConfig
+
+logger = logging.getLogger(__name__)
+
+def prepare_market_data(state: SimulationState) -> Dict[str, Any]:
+    """Prepares market data for agent decisions."""
+    tracker = state.tracker
+    goods_market_data: Dict[str, Any] = {}
+
+    debt_data_map = {}
+    deposit_data_map = {}
+
+    # 1. Debt & Deposit Data
+    if state.bank:
+        for agent_id, agent in state.agents.items():
+            if isinstance(agent, (Household, Firm)):
+                debt_status = state.bank.get_debt_status(str(agent_id))
+
+                total_burden = 0.0
+                ticks_per_year = 100
+                if hasattr(state.bank, "_get_config"):
+                     ticks_per_year = state.bank._get_config("bank_defaults.ticks_per_year", 100)
+
+                for loan in debt_status.get("loans", []):
+                    total_burden += (loan["outstanding_balance"] * loan["interest_rate"]) / ticks_per_year
+
+                debt_data_entry = dict(debt_status)
+                debt_data_entry["daily_interest_burden"] = total_burden
+                debt_data_entry["total_principal"] = debt_status["total_outstanding_debt"]
+
+                debt_data_map[agent_id] = debt_data_entry
+                deposit_data_map[agent_id] = state.bank.get_balance(str(agent_id))
+
+    # 2. Goods Market Data
+    for good_name in state.config_module.GOODS:
+        market = state.markets.get(good_name)
+        if market and isinstance(market, OrderBookMarket):
+            avg_price = market.get_daily_avg_price()
+            if avg_price <= 0:
+                avg_price = market.get_best_ask(good_name) or 0
+            if avg_price <= 0:
+                latest = tracker.get_latest_indicators()
+                avg_price = latest.get(f"{good_name}_avg_price", 0)
+            if avg_price <= 0:
+                avg_price = state.config_module.GOODS[good_name].get("initial_price", 10.0)
+
+            goods_market_data[f"{good_name}_current_sell_price"] = avg_price
+
+    latest_indicators = tracker.get_latest_indicators()
+    avg_wage = latest_indicators.get("labor_avg_price", state.config_module.LABOR_MARKET_MIN_WAGE)
+
+    labor_market = state.markets.get("labor")
+    best_wage_offer = 0.0
+    job_vacancies = 0
+
+    if labor_market and isinstance(labor_market, OrderBookMarket):
+        best_wage_offer = labor_market.get_best_bid("labor") or 0.0
+        if best_wage_offer <= 0:
+            best_wage_offer = avg_wage
+
+        for item_orders in labor_market.buy_orders.values():
+             for order in item_orders:
+                 job_vacancies += order.quantity
+
+    goods_market_data["labor"] = {
+        "avg_wage": avg_wage,
+        "best_wage_offer": best_wage_offer
+    }
+    goods_market_data["job_vacancies"] = job_vacancies
+
+    total_price = 0.0
+    count = 0.0
+    for good_name in state.config_module.GOODS:
+        price = goods_market_data.get(f"{good_name}_current_sell_price")
+        if price is not None:
+            total_price += price
+            count += 1
+
+    avg_goods_price_for_market_data = total_price / count if count > 0 else 10.0
+
+    stock_market_data = {}
+    if state.stock_market:
+        for firm in state.firms:
+            firm_item_id = f"stock_{firm.id}"
+            price = state.stock_market.get_daily_avg_price(firm.id)
+            if price <= 0:
+                price = state.stock_market.get_best_ask(firm.id) or 0
+            if price <= 0:
+                price = firm.assets / firm.total_shares if firm.total_shares > 0 else 10.0
+            stock_market_data[firm_item_id] = {"avg_price": price}
+
+    rent_prices = [u.rent_price for u in state.real_estate_units if u.owner_id is not None]
+    avg_rent = sum(rent_prices) / len(rent_prices) if rent_prices else state.config_module.INITIAL_RENT_PRICE
+
+    housing_market_data = {
+        "avg_rent_price": avg_rent
+    }
+
+    interest_rate = 0.05
+    if state.bank:
+        interest_rate = state.bank.base_rate
+
+    return {
+        "time": state.time,
+        "goods_market": goods_market_data,
+        "housing_market": housing_market_data,
+        "loan_market": {"interest_rate": interest_rate},
+        "stock_market": stock_market_data,
+        "all_households": state.households,
+        "avg_goods_price": avg_goods_price_for_market_data,
+        "debt_data": debt_data_map,
+        "deposit_data": deposit_data_map,
+        "inflation": latest_indicators.get("inflation_rate", state.config_module.DEFAULT_INFLATION_RATE)
+    }
+
+
+class Phase0_PreSequence(IPhaseStrategy):
+    def __init__(self, world_state: WorldState):
+        self.world_state = world_state
+
+    def execute(self, state: SimulationState) -> SimulationState:
+        # WO-109: Pre-Sequence Stabilization
+        if state.bank and hasattr(state.bank, "generate_solvency_transactions"):
+            stabilization_txs = state.bank.generate_solvency_transactions(state.government)
+            if stabilization_txs:
+                state.transactions.extend(stabilization_txs)
+                state.logger.warning("STABILIZATION | Queued pre-sequence stabilization transactions.")
+
+        # Events
+        if self.world_state.event_system:
+             context: EventContext = {
+                 "households": state.households,
+                 "firms": state.firms,
+                 "markets": state.markets,
+                 "government": state.government,
+                 "central_bank": state.central_bank,
+                 "bank": state.bank
+             }
+             self.world_state.event_system.execute_scheduled_events(state.time, context, self.world_state.stress_scenario_config)
+
+        # AI Training
+        if state.ai_training_manager:
+            if state.time > 0 and state.time % state.config_module.IMITATION_LEARNING_INTERVAL == 0:
+                state.ai_training_manager.run_imitation_learning_cycle(state.time)
+
+        # --- WO-060 / Phase 17 Logic (Social & Gov) ---
+
+        # Update Stock Market Reference Prices
+        if state.stock_market:
+            active_firms = {f.id: f for f in state.firms if f.is_active}
+            state.stock_market.update_reference_prices(active_firms)
+
+        # Prepare Market Data (for Gov/Social)
+        market_data = prepare_market_data(state)
+
+        # Social Ranks
+        if getattr(state.config_module, "ENABLE_VANITY_SYSTEM", False) and self.world_state.social_system:
+            context: SocialMobilityContext = {
+                "households": state.households
+            }
+            self.world_state.social_system.update_social_ranks(context)
+            ref_std = self.world_state.social_system.calculate_reference_standard(context)
+            market_data["reference_standard"] = ref_std
+
+        # Government Public Opinion
+        if state.government:
+            state.government.update_public_opinion(state.households)
+
+        # Sensory System
+        sensory_context: SensoryContext = {
+            "tracker": state.tracker,
+            "government": state.government,
+            "time": state.time
+        }
+
+        sensory_dto = GovernmentStateDTO(state.time, 0, 0, 0, 0, 0, 0)
+        if self.world_state.sensory_system:
+            sensory_dto = self.world_state.sensory_system.generate_government_sensory_dto(sensory_context)
+        else:
+             state.logger.error("SensorySystem not initialized!")
+
+        if state.government:
+            if state.injectable_sensory_dto and state.injectable_sensory_dto.tick == state.time:
+                state.government.update_sensory_data(state.injectable_sensory_dto)
+                state.logger.warning(
+                    f"INJECTED_SENSORY_DATA | Overrode sensory data for tick {state.time} with custom DTO.",
+                    extra={"tick": state.time, "tags": ["test_injection"]}
+                )
+            else:
+                state.government.update_sensory_data(sensory_dto)
+
+            # Government Policy Decision
+            latest_gdp = state.tracker.get_latest_indicators().get("total_production", 0.0)
+            market_data["total_production"] = latest_gdp
+            state.government.make_policy_decision(market_data, state.time, state.central_bank)
+
+            state.government.check_election(state.time)
+
+        # Central Bank
+        if state.central_bank and state.bank:
+             state.central_bank.step(state.time)
+             new_base_rate = state.central_bank.get_base_rate()
+             state.bank.update_base_rate(new_base_rate)
+
+        return state
+
+
+class Phase1_Decision(IPhaseStrategy):
+    def __init__(self, world_state: WorldState):
+        self.world_state = world_state
+
+    def execute(self, state: SimulationState) -> SimulationState:
+        # Snapshot agents for learning (Pre-state)
+        for f in state.firms:
+            if f.is_active: f.pre_state_snapshot = f.get_agent_data()
+        for h in state.households:
+            if h.is_active: h.pre_state_snapshot = h.get_agent_data()
+
+        # Prepare Market Data
+        market_data = prepare_market_data(state)
+        state.market_data = market_data
+
+        firm_pre_states = {}
+        household_pre_states = {}
+        household_time_allocation = {}
+
+        # Construct DTOs
+        prices = {}
+        volumes = {}
+        asks = {}
+        best_asks = {}
+
+        for m_id, market in state.markets.items():
+            if hasattr(market, "get_daily_avg_price"):
+                 prices[m_id] = market.get_daily_avg_price()
+            if hasattr(market, "get_daily_volume"):
+                 volumes[m_id] = market.get_daily_volume()
+
+            if hasattr(market, "sell_orders"):
+                for item_id, orders in market.sell_orders.items():
+                    asks[item_id] = orders
+                    if orders:
+                        if hasattr(market, "get_best_ask"):
+                            best_asks[item_id] = market.get_best_ask(item_id)
+                        else:
+                            best_asks[item_id] = orders[0].price if orders else 0.0
+
+        if state.stock_market:
+            for firm in state.firms:
+                if firm.is_active:
+                    price = state.stock_market.get_stock_price(firm.id)
+                    prices[f"stock_{firm.id}"] = price
+
+        market_snapshot = MarketSnapshotDTO(
+            prices=prices, volumes=volumes, asks=asks, best_asks=best_asks
+        )
+
+        gov = state.government
+        bank = state.bank
+        gov_policy = GovernmentPolicyDTO(
+             income_tax_rate=getattr(gov, "income_tax_rate", 0.1),
+             sales_tax_rate=getattr(state.config_module, "SALES_TAX_RATE", 0.05),
+             corporate_tax_rate=getattr(gov, "corporate_tax_rate", 0.2),
+             base_interest_rate=getattr(bank, "base_rate", 0.05) if bank else 0.05
+        )
+
+        macro_financial_context = None
+        if getattr(state.config_module, "MACRO_PORTFOLIO_ADJUSTMENT_ENABLED", False):
+            interest_rate_trend = 0.0
+            if bank:
+                interest_rate_trend = bank.base_rate - self.world_state.last_interest_rate
+                self.world_state.last_interest_rate = bank.base_rate
+
+            market_volatility = self.world_state.stock_tracker.get_market_volatility() if self.world_state.stock_tracker else 0.0
+
+            # Gov sensory data needed for macro context.
+            # Assuming government has it updated.
+            # Or retrieve from sensory system.
+            # We'll use dummy for now or previous tick data.
+            macro_financial_context = MacroFinancialContext(
+                inflation_rate=0.0,
+                gdp_growth_rate=0.0,
+                market_volatility=market_volatility,
+                interest_rate_trend=interest_rate_trend
+            )
+
+        # 1. Firms
+        for firm in state.firms:
+            if firm.is_active:
+                if hasattr(firm.decision_engine, 'ai_engine') and firm.decision_engine.ai_engine:
+                    pre_strategic_state = (
+                        firm.decision_engine.ai_engine._get_strategic_state(
+                            firm.get_agent_data(), market_data
+                        )
+                    )
+                    pre_tactical_state = firm.decision_engine.ai_engine._get_tactical_state(
+                        firm.decision_engine.ai_engine.chosen_intention,
+                        firm.get_agent_data(),
+                        market_data,
+                    )
+                    firm_pre_states[firm.id] = {
+                        "pre_strategic_state": pre_strategic_state,
+                        "pre_tactical_state": pre_tactical_state,
+                        "chosen_intention": firm.decision_engine.ai_engine.chosen_intention,
+                        "chosen_tactic": firm.decision_engine.ai_engine.last_chosen_tactic,
+                    }
+
+                stress_config = self.world_state.stress_scenario_config
+
+                firm_orders, action_vector = firm.make_decision(
+                    state.markets, state.goods_data, market_data, state.time,
+                    state.government, state.reflux_system, stress_config,
+                    market_snapshot=market_snapshot, government_policy=gov_policy
+                )
+
+                for order in firm_orders:
+                    target_market = state.markets.get(order.market_id)
+                    if target_market:
+                        target_market.place_order(order, state.time)
+
+        # 2. Households
+        for household in state.households:
+            if household.is_active:
+                if hasattr(household.decision_engine, 'ai_engine') and household.decision_engine.ai_engine:
+                    pre_strategic_state = (
+                        household.decision_engine.ai_engine._get_strategic_state(
+                            household.get_agent_data(), market_data
+                        )
+                    )
+                    household_pre_states[household.id] = {
+                        "pre_strategic_state": pre_strategic_state,
+                    }
+
+                stress_config = self.world_state.stress_scenario_config
+                household_orders, action_vector = household.make_decision(
+                    state.markets, state.goods_data, market_data, state.time, state.government, macro_financial_context, stress_config,
+                    market_snapshot=market_snapshot, government_policy=gov_policy
+                )
+
+                if hasattr(action_vector, 'work_aggressiveness'):
+                    work_aggressiveness = action_vector.work_aggressiveness
+                else:
+                    work_aggressiveness = 0.5
+                max_work_hours = state.config_module.MAX_WORK_HOURS
+                shopping_hours = getattr(state.config_module, "SHOPPING_HOURS", 2.0)
+                hours_per_tick = getattr(state.config_module, "HOURS_PER_TICK", 24.0)
+
+                work_hours = work_aggressiveness * max_work_hours
+                leisure_hours = max(0.0, hours_per_tick - work_hours - shopping_hours)
+                household_time_allocation[household.id] = leisure_hours
+
+                for order in household_orders:
+                    if order.order_type == "INVEST" and order.market_id == "admin":
+                        if self.world_state.firm_system:
+                            self.world_state.firm_system.spawn_firm(state, household)
+                        else:
+                            state.logger.warning(f"SKIPPED_INVESTMENT | Agent {household.id} tried startup but firm_system missing.")
+                        continue
+
+                    target_market_id = order.market_id
+                    if order.order_type in ["DEPOSIT", "WITHDRAW", "LOAN_REQUEST", "REPAYMENT"]:
+                        target_market_id = "loan_market"
+                    elif order.item_id in ["deposit", "currency"]:
+                        target_market_id = "loan_market"
+
+                    household_target_market = state.markets.get(target_market_id)
+
+                    if household_target_market:
+                        household_target_market.place_order(order, state.time)
+
+        state.firm_pre_states = firm_pre_states
+        state.household_pre_states = household_pre_states
+        state.household_time_allocation = household_time_allocation
+
+        # Commerce Planning
+        current_vacancies = 0
+        labor_market = state.markets.get("labor")
+        if labor_market and isinstance(labor_market, OrderBookMarket):
+             for item_orders in labor_market.buy_orders.values():
+                 for order in item_orders:
+                     current_vacancies += order.quantity
+
+        consumption_market_data = market_data.copy()
+        consumption_market_data["job_vacancies"] = current_vacancies
+
+        commerce_context: CommerceContext = {
+            "households": state.households,
+            "agents": state.agents,
+            "breeding_planner": self.world_state.breeding_planner,
+            "household_time_allocation": household_time_allocation,
+            "reflux_system": state.reflux_system,
+            "market_data": consumption_market_data,
+            "config": state.config_module,
+            "time": state.time
+        }
+
+        if self.world_state.commerce_system:
+            planned_cons, commerce_txs = self.world_state.commerce_system.plan_consumption_and_leisure(
+                commerce_context, self.world_state.stress_scenario_config
+            )
+            state.planned_consumption = planned_cons
+            state.transactions.extend(commerce_txs)
+
+        return state
+
+
+class Phase2_Matching(IPhaseStrategy):
+    def __init__(self, world_state: WorldState):
+        self.world_state = world_state
+
+    def execute(self, state: SimulationState) -> SimulationState:
+        matched_txs = []
+        for market in state.markets.values():
+            if isinstance(market, OrderBookMarket):
+                matched_txs.extend(market.match_orders(state.time))
+
+        if state.stock_market:
+            stock_txs = state.stock_market.match_orders(state.time)
+            matched_txs.extend(stock_txs)
+            state.stock_market.clear_expired_orders(state.time)
+
+        if "housing" in state.markets:
+             housing_txs = state.markets["housing"].match_orders(state.time)
+             matched_txs.extend(housing_txs)
+
+        state.transactions.extend(matched_txs)
+        return state
+
+
+class Phase3_Transaction(IPhaseStrategy):
+    def __init__(self, world_state: WorldState, action_processor: ActionProcessor):
+        self.world_state = world_state
+        self.action_processor = action_processor
+
+    def execute(self, state: SimulationState) -> SimulationState:
+        system_transactions = []
+        system_transactions.extend(state.inter_tick_queue)
+        state.inter_tick_queue.clear()
+
+        if state.bank and hasattr(state.bank, "run_tick"):
+            bank_txs = state.bank.run_tick(state.agents, state.time, reflux_system=state.reflux_system)
+            system_transactions.extend(bank_txs)
+
+        market_data_prev = state.market_data
+        for firm in state.firms:
+             if firm.is_active:
+                 firm_txs = firm.generate_transactions(
+                     government=state.government,
+                     market_data=market_data_prev,
+                     all_households=state.households,
+                     current_time=state.time
+                 )
+                 system_transactions.extend(firm_txs)
+
+        if self.world_state.finance_system:
+             debt_txs = self.world_state.finance_system.service_debt(state.time)
+             system_transactions.extend(debt_txs)
+
+        if state.government:
+            welfare_txs = state.government.run_welfare_check(list(state.agents.values()), market_data_prev, state.time)
+            system_transactions.extend(welfare_txs)
+
+            infra_txs = state.government.invest_infrastructure(state.time, state.reflux_system)
+            if infra_txs:
+                system_transactions.extend(infra_txs)
+
+            edu_txs = state.government.run_public_education(state.households, state.config_module, state.time, state.reflux_system)
+            if edu_txs:
+                system_transactions.extend(edu_txs)
+
+        state.transactions.extend(system_transactions)
+
+        if self.world_state.transaction_processor:
+            self.world_state.transaction_processor.execute(state)
+        else:
+            state.logger.error("TransactionProcessor not initialized.")
+
+        return state
+
+
+class Phase4_Lifecycle(IPhaseStrategy):
+    def __init__(self, world_state: WorldState):
+        self.world_state = world_state
+
+    def execute(self, state: SimulationState) -> SimulationState:
+        if self.world_state.lifecycle_manager:
+            lifecycle_txs = self.world_state.lifecycle_manager.execute(state)
+            if lifecycle_txs:
+                state.inter_tick_queue.extend(lifecycle_txs)
+
+        consumption_market_data = state.market_data
+
+        commerce_context: CommerceContext = {
+            "households": state.households,
+            "agents": state.agents,
+            "breeding_planner": self.world_state.breeding_planner,
+            "household_time_allocation": state.household_time_allocation,
+            "reflux_system": state.reflux_system,
+            "market_data": consumption_market_data,
+            "config": state.config_module,
+            "time": state.time
+        }
+
+        if self.world_state.commerce_system:
+            leisure_effects = self.world_state.commerce_system.finalize_consumption_and_leisure(
+                commerce_context, state.planned_consumption
+            )
+            state.household_leisure_effects = leisure_effects
+
+        return state
+
+
+class Phase5_PostSequence(IPhaseStrategy):
+    def __init__(self, world_state: WorldState):
+        self.world_state = world_state
+
+    def execute(self, state: SimulationState) -> SimulationState:
+        # Housing
+        if self.world_state.housing_system:
+             self.world_state.housing_system.process_housing(state)
+             self.world_state.housing_system.apply_homeless_penalty(state)
+
+        # Learning Update
+        market_data_for_learning = prepare_market_data(state)
+
+        # Firms
+        for firm in state.firms:
+            if firm.is_active and firm.id in state.firm_pre_states:
+                agent_data = firm.get_agent_data()
+
+                if hasattr(firm.decision_engine, 'ai_engine'):
+                     reward = firm.decision_engine.ai_engine.calculate_reward(
+                        firm, firm.get_pre_state_data(), agent_data
+                     )
+
+                     context: LearningUpdateContext = {
+                        "reward": reward,
+                        "next_agent_data": agent_data,
+                        "next_market_data": market_data_for_learning
+                     }
+                     firm.update_learning(context)
+
+                     decision_data = AIDecisionData(
+                        run_id=state.agents.get(firm.id).run_id if hasattr(state.agents.get(firm.id), 'run_id') else 0,
+                        tick=state.time,
+                        agent_id=firm.id,
+                        decision_type="VECTOR_V2",
+                        decision_details={"reward": reward},
+                        predicted_reward=None,
+                        actual_reward=reward,
+                     )
+                     self.world_state.repository.save_ai_decision(decision_data)
+
+        # Households
+        for household in state.households:
+             if household.is_active and household.id in state.household_pre_states:
+                 if hasattr(household.decision_engine, 'ai_engine') and household.decision_engine.ai_engine:
+                     agent_data = household.get_agent_data()
+                     leisure_utility = state.household_leisure_effects.get(household.id, 0.0)
+                     agent_data["leisure_utility"] = leisure_utility
+
+                     reward = household.decision_engine.ai_engine._calculate_reward(
+                         household.get_pre_state_data(),
+                         agent_data, # post_state is current
+                         agent_data,
+                         market_data_for_learning
+                     )
+
+                     context: LearningUpdateContext = {
+                        "reward": reward,
+                        "next_agent_data": agent_data,
+                        "next_market_data": market_data_for_learning
+                     }
+                     household.update_learning(context)
+
+                     decision_data = AIDecisionData(
+                        run_id=state.agents.get(household.id).run_id if hasattr(state.agents.get(household.id), 'run_id') else 0,
+                        tick=state.time,
+                        agent_id=household.id,
+                        decision_type="VECTOR_V2",
+                        decision_details={"reward": reward},
+                        predicted_reward=None,
+                        actual_reward=reward,
+                     )
+                     self.world_state.repository.save_ai_decision(decision_data)
+
+        if self.world_state.ma_manager:
+            self.world_state.ma_manager.process_market_exits_and_entries(state.time)
+
+        # Cleanup firms
+        active_firms_before = len(state.firms)
+        state.firms[:] = [f for f in state.firms if f.is_active]
+        if len(state.firms) < active_firms_before:
+             state.logger.info(f"CLEANUP | Removed {active_firms_before - len(state.firms)} inactive firms.")
+
+        if state.government:
+             state.government.finalize_tick(state.time)
+
+        if state.reflux_system:
+             state.reflux_system.distribute(state.households)
+
+        if self.world_state.persistence_manager:
+             self.world_state.persistence_manager.buffer_tick_state(self.world_state, state.transactions)
+             if state.time % self.world_state.batch_save_interval == 0:
+                 self.world_state.persistence_manager.flush_buffers(state.time)
+
+        # Reset counters
+        for h in state.households:
+             if hasattr(h, "reset_consumption_counters"):
+                 h.reset_consumption_counters()
+
+        for f in state.firms:
+            f.last_daily_expenses = f.expenses_this_tick
+            f.last_sales_volume = f.sales_volume_this_tick
+            f.sales_volume_this_tick = 0.0
+            f.expenses_this_tick = 0.0
+            f.revenue_this_tick = 0.0
+
+        if self.world_state.generational_wealth_audit and state.time % 100 == 0:
+             self.world_state.generational_wealth_audit.run_audit(state.households, state.time)
+
+        if self.world_state.crisis_monitor:
+             self.world_state.crisis_monitor.monitor(state.time, state.firms)
+
+        for market in state.markets.values():
+             market.clear_orders()
+
+        if state.stock_market:
+             state.stock_tracker.track_all_firms(state.firms, state.stock_market)
+
+        return state
diff --git a/simulation/orchestration/tick_orchestrator.py b/simulation/orchestration/tick_orchestrator.py
new file mode 100644
index 0000000..20f88a9
--- /dev/null
+++ b/simulation/orchestration/tick_orchestrator.py
@@ -0,0 +1,142 @@
+from __future__ import annotations
+from typing import List, Optional, TYPE_CHECKING, Any, Dict
+import logging
+
+from simulation.dtos.api import SimulationState, GovernmentStateDTO
+from simulation.orchestration.phases import (
+    Phase0_PreSequence, Phase1_Decision, Phase2_Matching,
+    Phase3_Transaction, Phase4_Lifecycle, Phase5_PostSequence,
+    prepare_market_data
+)
+
+if TYPE_CHECKING:
+    from simulation.world_state import WorldState
+    from simulation.action_processor import ActionProcessor
+    from simulation.orchestration.api import IPhaseStrategy
+
+logger = logging.getLogger(__name__)
+
+class TickOrchestrator:
+    def __init__(self, world_state: WorldState, action_processor: ActionProcessor):
+        self.world_state = world_state
+        self.action_processor = action_processor
+
+        # Initialize phases with dependencies
+        self.phases: List[IPhaseStrategy] = [
+            Phase0_PreSequence(world_state),
+            Phase1_Decision(world_state),
+            Phase2_Matching(world_state),
+            Phase3_Transaction(world_state, action_processor),
+            Phase4_Lifecycle(world_state),
+            Phase5_PostSequence(world_state)
+        ]
+
+    def run_tick(self, injectable_sensory_dto: Optional[GovernmentStateDTO] = None) -> None:
+        state = self.world_state
+
+        # Money Supply Verification (Tick 0)
+        # This check is usually done before any activity starts
+        if state.time == 0:
+            state.baseline_money_supply = state.calculate_total_money()
+            state.logger.info(
+                f"MONEY_SUPPLY_BASELINE | Baseline Money Supply set to: {state.baseline_money_supply:.2f}",
+                extra={"tick": state.time, "money_supply": state.baseline_money_supply}
+            )
+
+        # Increment time
+        state.time += 1
+        state.logger.info(
+            f"--- Starting Tick {state.time} ---",
+            extra={"tick": state.time, "tags": ["tick_start"]},
+        )
+
+        # 1. Create the comprehensive state DTO for this tick
+        sim_state = self._create_simulation_state_dto(injectable_sensory_dto)
+
+        # 2. Execute all phases in sequence
+        for phase in self.phases:
+            sim_state = phase.execute(sim_state)
+
+        # 3. Post-execution state synchronization
+        self._synchronize_world_state(sim_state)
+
+        # 4. Final persistence and cleanup
+        self._finalize_tick(sim_state)
+
+        state.logger.info(
+            f"--- Ending Tick {state.time} ---",
+            extra={"tick": state.time, "tags": ["tick_end"]},
+        )
+
+    def _create_simulation_state_dto(self, injectable_sensory_dto: Optional[GovernmentStateDTO]) -> SimulationState:
+        state = self.world_state
+
+        return SimulationState(
+            time=state.time,
+            households=state.households,
+            firms=state.firms,
+            agents=state.agents,
+            markets=state.markets,
+            government=state.government,
+            bank=state.bank,
+            central_bank=state.central_bank,
+            stock_market=state.stock_market,
+            goods_data=state.goods_data,
+            market_data={}, # Will be populated in Phase 1 (and 0 for Gov)
+            config_module=state.config_module,
+            tracker=state.tracker,
+            logger=state.logger,
+            reflux_system=state.reflux_system,
+            ai_training_manager=state.ai_training_manager,
+            ai_trainer=state.ai_trainer,
+            settlement_system=state.settlement_system,
+            next_agent_id=state.next_agent_id,
+            real_estate_units=state.real_estate_units,
+            injectable_sensory_dto=injectable_sensory_dto,
+            inactive_agents=state.inactive_agents
+        )
+
+    def _synchronize_world_state(self, sim_state: SimulationState):
+        # Sync back scalar values that might have changed
+        self.world_state.next_agent_id = sim_state.next_agent_id
+
+        # Note: Collections (households, firms, etc.) are passed by reference in DTO,
+        # so modifications to objects inside them are already reflected.
+        # But if the list itself was replaced (e.g. filtered), we need to sync.
+        # Phase 5 filtered state.firms in place: state.firms[:] = [...]
+        # So WorldState.firms should be updated because it shares the same list object?
+        # Yes, `state.firms[:] = ...` modifies the list in place.
+        # `sim_state.firms` refers to `self.world_state.firms`.
+        pass
+
+    def _finalize_tick(self, sim_state: SimulationState):
+        state = self.world_state
+
+        # Money Supply Verification (Post-Tick)
+        if state.time >= 1:
+            current_money = state.calculate_total_money()
+            expected_money = state.baseline_money_supply
+            if hasattr(state.government, "get_monetary_delta"):
+                expected_money += state.government.get_monetary_delta()
+
+            delta = current_money - expected_money
+
+            msg = f"MONEY_SUPPLY_CHECK | Current: {current_money:.2f}, Expected: {expected_money:.2f}, Delta: {delta:.4f}"
+            extra_data = {"tick": state.time, "current": current_money, "expected": expected_money, "delta": delta, "tags": ["money_supply"]}
+
+            if abs(delta) > 1.0:
+                 state.logger.warning(msg, extra=extra_data)
+            else:
+                 state.logger.info(msg, extra=extra_data)
+
+    def prepare_market_data(self) -> Dict[str, Any]:
+        """
+        Legacy/External access to market data preparation.
+        Delegates to the logic used in Phase 1.
+
+        Used by: Simulation._prepare_market_data
+        """
+        # Create a proper SimulationState DTO to satisfy type requirements
+        # passing None for injectable_sensory_dto as it's not needed for this legacy call
+        sim_state = self._create_simulation_state_dto(None)
+        return prepare_market_data(sim_state)
diff --git a/simulation/systems/lifecycle_manager.py b/simulation/systems/lifecycle_manager.py
index 16cde82..2d3e951 100644
--- a/simulation/systems/lifecycle_manager.py
+++ b/simulation/systems/lifecycle_manager.py
@@ -41,20 +41,58 @@ class AgentLifecycleManager(AgentLifecycleManagerInterface):
         # 1. Aging (and internal lifecycle update)
         self.demographic_manager.process_aging(state.households, state.time, state.market_data)
 
-        # 2. Births
+        # 2. NEW: Firm Lifecycle (Aging & Bankruptcy Checks)
+        self._process_firm_lifecycle(state)
+
+        # 3. Births
         new_children = self._process_births(state)
         self._register_new_agents(state, new_children)
 
-        # 3. Immigration
+        # 4. Immigration
         new_immigrants = self.immigration_manager.process_immigration(state)
         self._register_new_agents(state, new_immigrants)
 
-        # 4. Entrepreneurship
+        # 5. Entrepreneurship
         self.firm_system.check_entrepreneurship(state)
 
-        # 5. Death & Liquidation
+        # 6. Death & Liquidation
         return self._handle_agent_liquidation(state)
 
+    def _process_firm_lifecycle(self, state: SimulationState) -> None:
+        """
+        Handles lifecycle updates for all active firms, formerly in Firm.update_needs.
+        """
+        assets_threshold = getattr(self.config, "ASSETS_CLOSURE_THRESHOLD", 0.0)
+        closure_turns_threshold = getattr(self.config, "FIRM_CLOSURE_TURNS_THRESHOLD", 5)
+        liquidity_inc_rate = getattr(self.config, "LIQUIDITY_NEED_INCREASE_RATE", 1.0)
+
+        for firm in state.firms:
+            if not firm.is_active:
+                continue
+
+            firm.age += 1
+
+            # Liquidity Need Increase
+            firm.needs["liquidity_need"] = min(100.0, firm.needs["liquidity_need"] + liquidity_inc_rate)
+
+            # Check bankruptcy status (logic from FinanceDepartment)
+            firm.finance.check_bankruptcy()
+
+            # Check for closure based on assets or consecutive losses
+            if (firm.assets <= assets_threshold or
+                    firm.finance.consecutive_loss_turns >= closure_turns_threshold):
+                firm.is_active = False
+                self.logger.warning(
+                    f"FIRM_INACTIVE | Firm {firm.id} closed down. Assets: {firm.assets:.2f}, Consecutive Loss Turns: {firm.finance.consecutive_loss_turns}",
+                    extra={
+                        "tick": state.time,
+                        "agent_id": firm.id,
+                        "assets": firm.assets,
+                        "consecutive_loss_turns": firm.finance.consecutive_loss_turns,
+                        "tags": ["firm_closure"],
+                    }
+                )
+
     def _process_births(self, state: SimulationState) -> List[Household]:
         birth_requests = []
         active_households = [h for h in state.households if h.is_active]
diff --git a/simulation/tick_scheduler.py b/simulation/tick_scheduler.py
deleted file mode 100644
index baf03a3..0000000
--- a/simulation/tick_scheduler.py
+++ /dev/null
@@ -1,943 +0,0 @@
-from __future__ import annotations
-from typing import List, Dict, Any, Optional, TYPE_CHECKING, Tuple
-import logging
-
-from simulation.models import Transaction, Order, StockOrder, RealEstateUnit
-from simulation.core_agents import Household
-from simulation.systems.tech.api import FirmTechInfoDTO, HouseholdEducationDTO
-from simulation.firms import Firm
-from simulation.markets.order_book_market import OrderBookMarket
-from simulation.agents.government import Government
-from simulation.dtos import (
-    AIDecisionData,
-    GovernmentStateDTO,
-    MacroFinancialContext
-)
-from simulation.systems.api import (
-    EventContext,
-    SocialMobilityContext,
-    SensoryContext,
-    CommerceContext,
-    LearningUpdateContext
-)
-from simulation.dtos.api import SimulationState
-
-if TYPE_CHECKING:
-    from simulation.world_state import WorldState
-    from simulation.action_processor import ActionProcessor
-    from simulation.metrics.economic_tracker import EconomicIndicatorTracker
-
-logger = logging.getLogger(__name__)
-
-
-class TickScheduler:
-    """
-    Manages the schedule and execution of a single simulation tick.
-    Decomposed from Simulation engine.
-    WO-103: Refactored to enforce the Sacred Sequence.
-    """
-
-    def __init__(self, world_state: WorldState, action_processor: ActionProcessor):
-        self.world_state = world_state
-        self.action_processor = action_processor
-        from simulation.systems.system_effects_manager import SystemEffectsManager
-        self.system_effects_manager = SystemEffectsManager(world_state.config_module)
-
-    def run_tick(self, injectable_sensory_dto: Optional[GovernmentStateDTO] = None) -> None:
-        state = self.world_state
-
-        # WO-109: Phase 0A: Pre-Sequence Stabilization
-        self._phase_pre_sequence_stabilization(state)
-
-        # --- Gold Standard / Money Supply Verification (WO-016) ---
-        if state.time == 0:
-            state.baseline_money_supply = state.calculate_total_money()
-            state.logger.info(
-                f"MONEY_SUPPLY_BASELINE | Baseline Money Supply set to: {state.baseline_money_supply:.2f}",
-                extra={"tick": state.time, "money_supply": state.baseline_money_supply}
-            )
-
-        state.time += 1
-        state.logger.info(
-            f"--- Starting Tick {state.time} ---",
-            extra={"tick": state.time, "tags": ["tick_start"]},
-        )
-
-        # ===== Chaos Injection Events (via EventSystem) =====
-        if state.event_system:
-             context: EventContext = {
-                 "households": state.households,
-                 "firms": state.firms,
-                 "markets": state.markets,
-                 "government": state.government,
-                 "central_bank": state.central_bank,
-                 "bank": state.bank
-             }
-             state.event_system.execute_scheduled_events(state.time, context, state.stress_scenario_config)
-
-        if (
-            state.time > 0
-            and state.time % state.config_module.IMITATION_LEARNING_INTERVAL == 0
-        ):
-            state.ai_training_manager.run_imitation_learning_cycle(state.time)
-
-        # ==================================================================================
-        # WO-116 Phase B: Transaction Generation Phase (System Transactions)
-        # ==================================================================================
-        system_transactions: List[Transaction] = []
-
-        # WO-109: Drain inter-tick queue from previous tick's lifecycle events
-        system_transactions.extend(state.inter_tick_queue)
-        state.inter_tick_queue.clear()
-
-        # 0. Firm Production (State Update: Inventory) - MOVED TO ORCHESTRATOR
-        # for firm in state.firms:
-        #      if firm.is_active:
-        #          firm.produce(state.time, technology_manager=state.technology_manager)
-
-        # 1. Bank Tick (Interest)
-        if hasattr(state.bank, "run_tick"):
-             bank_txs = state.bank.run_tick(state.agents, state.time, reflux_system=state.reflux_system)
-             system_transactions.extend(bank_txs)
-
-        # 2. Firm Financials (Wages, Taxes, Dividends) - Requires Market Data (T-1)
-        market_data_prev = self.prepare_market_data(state.tracker)
-        for firm in state.firms:
-             if firm.is_active:
-                 firm_txs = firm.generate_transactions(
-                     government=state.government,
-                     market_data=market_data_prev,
-                     all_households=state.households,
-                     current_time=state.time
-                 )
-                 system_transactions.extend(firm_txs)
-
-        # 3. Debt Service
-        debt_txs = state.finance_system.service_debt(state.time)
-        system_transactions.extend(debt_txs)
-
-        # 4. Welfare & Taxes (Wealth)
-        welfare_txs = state.government.run_welfare_check(list(state.agents.values()), market_data_prev, state.time)
-        system_transactions.extend(welfare_txs)
-
-        # 5. Infrastructure
-        infra_txs = state.government.invest_infrastructure(state.time, state.reflux_system)
-        if infra_txs:
-            system_transactions.extend(infra_txs)
-
-        # 6. Education (WO-054 Refactor)
-        edu_txs = state.government.run_public_education(state.households, state.config_module, state.time, state.reflux_system)
-        if edu_txs:
-            system_transactions.extend(edu_txs)
-
-        # [DEBUG LEAK]
-        current = state.calculate_total_money()
-        state.logger.info(f"DEBUG_MONEY | Steps 0-6 Complete. Money: {current:,.2f}")
-
-        # ----------------------------------------------------------------------------------
-
-        # Cleanup Orders (Reset for new tick)
-        for firm in state.firms:
-            firm.hires_last_tick = 0
-
-        for market in state.markets.values():
-            if isinstance(market, OrderBookMarket):
-                market.clear_orders()
-
-        # WO-057-Fix: Update tracker with the latest data before government decisions
-        money_supply = state.tracker.get_m2_money_supply(state)
-        state.tracker.track(state.time, state.households, state.firms, state.markets, money_supply=money_supply)
-
-        # [WO-060] Update stock market reference prices at the start of the tick
-        if state.stock_market is not None:
-            active_firms = {f.id: f for f in state.firms if f.is_active}
-            state.stock_market.update_reference_prices(active_firms)
-
-        # Phase 17-4: Update Social Ranks & Calculate Reference Standard (via SocialSystem)
-        market_data = self.prepare_market_data(state.tracker)
-
-        if getattr(state.config_module, "ENABLE_VANITY_SYSTEM", False) and state.social_system:
-            context: SocialMobilityContext = {
-                "households": state.households
-            }
-            state.social_system.update_social_ranks(context)
-            ref_std = state.social_system.calculate_reference_standard(context)
-            market_data["reference_standard"] = ref_std
-
-        # Phase 17-5: Leviathan Logic Integration
-        # 1. Update Household Political Opinions (Handled in Lifecycle/update_needs)
-
-        # 2. Government Gathers Opinion
-        state.government.update_public_opinion(state.households)
-
-        # --- WO-057-B: Sensory Module Pipeline (via SensorySystem) ---
-        sensory_context: SensoryContext = {
-            "tracker": state.tracker,
-            "government": state.government,
-            "time": state.time
-        }
-
-        if state.sensory_system:
-            sensory_dto = state.sensory_system.generate_government_sensory_dto(sensory_context)
-        else:
-            state.logger.error("SensorySystem not initialized! Check SimulationInitializer.")
-            sensory_dto = GovernmentStateDTO(state.time, 0, 0, 0, 0, 0, 0)
-
-        # Supply to Government
-        if injectable_sensory_dto and injectable_sensory_dto.tick == state.time:
-            state.government.update_sensory_data(injectable_sensory_dto)
-            state.logger.warning(
-                f"INJECTED_SENSORY_DATA | Overrode sensory data for tick {state.time} with custom DTO.",
-                extra={"tick": state.time, "tags": ["test_injection"]}
-            )
-        else:
-            state.government.update_sensory_data(sensory_dto)
-
-        # --- WO-062: Macro-Financial Context for Households ---
-        macro_financial_context = None
-        if getattr(state.config_module, "MACRO_PORTFOLIO_ADJUSTMENT_ENABLED", False):
-            interest_rate_trend = state.bank.base_rate - state.last_interest_rate
-            state.last_interest_rate = state.bank.base_rate
-
-            market_volatility = state.stock_tracker.get_market_volatility() if state.stock_tracker else 0.0
-
-            macro_financial_context = MacroFinancialContext(
-                inflation_rate=sensory_dto.inflation_sma,
-                gdp_growth_rate=sensory_dto.gdp_growth_sma,
-                market_volatility=market_volatility,
-                interest_rate_trend=interest_rate_trend
-            )
-
-        # [DEBUG WO-057]
-        latest_indicators = state.tracker.get_latest_indicators()
-
-        # 3. Government Makes Policy Decision (Act)
-        latest_gdp = state.tracker.get_latest_indicators().get("total_production", 0.0)
-        market_data["total_production"] = latest_gdp
-
-        state.government.make_policy_decision(market_data, state.time, state.central_bank)
-
-        # Monetary policy is updated AFTER the government's fiscal/AI decision
-        state.central_bank.step(state.time)
-        new_base_rate = state.central_bank.get_base_rate()
-        state.bank.update_base_rate(new_base_rate)
-
-        # 4. Election Check
-        state.government.check_election(state.time)
-
-        # Age firms (moved to Lifecycle/UpdateNeeds but kept partly here?)
-        # We handle 'age += 1' in firm.update_needs called in Lifecycle.
-        # So we can remove this loop.
-        # for firm in state.firms:
-        #    firm.age += 1
-
-        # Service national debt -> Moved to Transaction Gen
-        # state.finance_system.service_debt(state.time)
-
-        # Phase 4: Welfare Check -> Moved to Transaction Gen
-        # state.government.run_welfare_check(list(state.agents.values()), market_data, state.time)
-
-        # Snapshot agents for learning (Pre-state)
-        for f in state.firms:
-            if f.is_active: f.pre_state_snapshot = f.get_agent_data()
-        for h in state.households:
-            if h.is_active: h.pre_state_snapshot = h.get_agent_data()
-
-        # ==================================================================================
-        # THE SACRED SEQUENCE (WO-103)
-        # ==================================================================================
-
-        # 0. Construct Simulation State DTO
-        sim_state = SimulationState(
-            time=state.time,
-            households=state.households,
-            firms=state.firms,
-            agents=state.agents,
-            markets=state.markets,
-            government=state.government,
-            bank=state.bank,
-            central_bank=state.central_bank,
-            stock_market=state.stock_market,
-            goods_data=state.goods_data,
-            market_data=market_data,
-            config_module=state.config_module,
-            tracker=state.tracker,
-            logger=state.logger,
-            reflux_system=state.reflux_system,
-            ai_training_manager=getattr(state, "ai_training_manager", None),
-            ai_trainer=getattr(state, "ai_trainer", None),
-            next_agent_id=state.next_agent_id,
-            real_estate_units=state.real_estate_units,
-            settlement_system=getattr(state, "settlement_system", None),
-            inactive_agents=state.inactive_agents
-        )
-
-        # 1. Decisions
-        firm_pre_states, household_pre_states, household_time_allocation = self._phase_decisions(
-            sim_state, market_data, macro_financial_context
-        )
-        state.household_time_allocation = household_time_allocation # Update state
-
-        # TD-118: Commerce Planning (Phase 1 Extension)
-        # Prepare context for CommerceSystem
-        current_vacancies = 0
-        labor_market = state.markets.get("labor")
-        if labor_market and isinstance(labor_market, OrderBookMarket):
-             for item_orders in labor_market.buy_orders.values():
-                 for order in item_orders:
-                     current_vacancies += order.quantity
-
-        consumption_market_data = market_data.copy()
-        consumption_market_data["job_vacancies"] = current_vacancies
-
-        commerce_context: CommerceContext = {
-            "households": state.households,
-            "agents": state.agents,
-            "breeding_planner": state.breeding_planner,
-            "household_time_allocation": household_time_allocation,
-            "reflux_system": state.reflux_system,
-            "market_data": consumption_market_data,
-            "config": state.config_module,
-            "time": state.time
-        }
-
-        if state.commerce_system:
-            planned_cons, commerce_txs = state.commerce_system.plan_consumption_and_leisure(
-                commerce_context, state.stress_scenario_config
-            )
-            sim_state.planned_consumption = planned_cons
-            system_transactions.extend(commerce_txs)
-
-        # 2. Matching
-        self._phase_matching(sim_state)
-
-        # 3. Transactions
-        self._phase_transactions(sim_state, system_transactions)
-        state.transactions = sim_state.transactions  # Sync back for observability
-
-        # 4. Lifecycle
-        self._phase_lifecycle(sim_state)
-
-        # Sync back scalars
-        state.next_agent_id = sim_state.next_agent_id
-
-        # WO-109: Process Effects
-        self.system_effects_manager.process_effects(sim_state)
-
-        # ==================================================================================
-        # Post-Tick Logic
-        # ==================================================================================
-
-        # ---------------------------------------------------------
-        # Activate Consumption Logic & Leisure Effects (via CommerceSystem)
-        # ---------------------------------------------------------
-        current_vacancies = 0
-        labor_market = state.markets.get("labor")
-        if labor_market and isinstance(labor_market, OrderBookMarket):
-             for item_orders in labor_market.buy_orders.values():
-                 for order in item_orders:
-                     current_vacancies += order.quantity
-
-        consumption_market_data = market_data.copy()
-        consumption_market_data["job_vacancies"] = current_vacancies
-
-        commerce_context: CommerceContext = {
-            "households": state.households,
-            "agents": state.agents,
-            "breeding_planner": state.breeding_planner,
-            "household_time_allocation": household_time_allocation,
-            "reflux_system": state.reflux_system,
-            "market_data": consumption_market_data,
-            "config": state.config_module,
-            "time": state.time
-        }
-
-        if state.commerce_system:
-            household_leisure_effects = state.commerce_system.finalize_consumption_and_leisure(commerce_context, state.planned_consumption if hasattr(state, "planned_consumption") else {})
-        else:
-            state.logger.error("CommerceSystem not initialized! Skipping consumption cycle.")
-            household_leisure_effects = {}
-
-        # Phase 17-3B: Process Housing (Logic that didn't fit in matching/lifecycle)
-        # Housing matching happened in _phase_matching.
-        # But apply_homeless_penalty needs to run.
-        current_pre_housing = state.calculate_total_money()
-        print(f"DEBUG_MONEY | Pre-Housing Process. Money: {current_pre_housing:,.2f}")
-
-        state.housing_system.process_housing(state) # Update rent/maintenance
-        state.housing_system.apply_homeless_penalty(state)
-
-        current_post_housing = state.calculate_total_money()
-        print(f"DEBUG_MONEY | Post-Housing Process. Money: {current_post_housing:,.2f}")
-
-        # ---------------------------------------------------------
-        # Activate Farm Logic (Production & Needs/Wages)
-        # ---------------------------------------------------------
-        for firm in state.firms:
-             if firm.is_active:
-                 # firm.produce -> Moved to Pre-Decision
-                 # firm.update_needs -> Refactored to only do Lifecycle state updates (not financial)
-                 firm.update_needs(state.time, state.government, market_data, state.reflux_system)
-
-                 # Corporate Tax -> Removed (Handled in Transaction Generation)
-
-                 # Gov Infra -> Removed (Handled in Pre-Decision)
-
-        # --- AI Learning Update (Unified) ---
-        market_data_for_learning = self.prepare_market_data(state.tracker)
-
-        # Firms
-        for firm in state.firms:
-            if firm.is_active and firm.id in firm_pre_states:
-                agent_data = firm.get_agent_data()
-
-                reward = firm.decision_engine.ai_engine.calculate_reward(
-                    firm, firm.get_pre_state_data(), agent_data
-                )
-
-                context: LearningUpdateContext = {
-                    "reward": reward,
-                    "next_agent_data": agent_data,
-                    "next_market_data": market_data_for_learning
-                }
-                firm.update_learning(context)
-
-                decision_data = AIDecisionData(
-                    run_id=state.run_id,
-                    tick=state.time,
-                    agent_id=firm.id,
-                    decision_type="VECTOR_V2",
-                    decision_details={"reward": reward},
-                    predicted_reward=None,
-                    actual_reward=reward,
-                )
-                state.repository.save_ai_decision(decision_data)
-
-        # Households
-        for household in state.households:
-            if household.is_active and household.id in household_pre_states:
-                # Hybrid check: Only update learning if agent has AI engine
-                if hasattr(household.decision_engine, 'ai_engine') and household.decision_engine.ai_engine:
-                    post_state_data = household.get_agent_data()
-                    agent_data = household.get_agent_data()
-
-                    leisure_utility = household_leisure_effects.get(household.id, 0.0)
-                    agent_data["leisure_utility"] = leisure_utility
-
-                    reward = household.decision_engine.ai_engine._calculate_reward(
-                        household.get_pre_state_data(),
-                        post_state_data,
-                        agent_data,
-                        market_data_for_learning,
-                    )
-
-                    context: LearningUpdateContext = {
-                        "reward": reward,
-                        "next_agent_data": agent_data,
-                        "next_market_data": market_data_for_learning
-                    }
-                    household.update_learning(context)
-
-                    decision_data = AIDecisionData(
-                        run_id=state.run_id,
-                        tick=state.time,
-                        agent_id=household.id,
-                        decision_type="VECTOR_V2",
-                        decision_details={"reward": reward},
-                        predicted_reward=None,
-                        actual_reward=reward,
-                    )
-                    state.repository.save_ai_decision(decision_data)
-
-        # 8. M&A
-        state.ma_manager.process_market_exits_and_entries(state.time)
-
-        # 9. Cleanup Inactive Firms
-        active_firms_count_before = len(state.firms)
-        state.firms = [f for f in state.firms if f.is_active]
-
-        if len(state.firms) < active_firms_count_before:
-            state.logger.info(f"CLEANUP | Removed {active_firms_count_before - len(state.firms)} inactive firms from execution list.")
-
-        # Phase 5: Finalize Government Stats
-        state.government.finalize_tick(state.time)
-
-        # Phase 8-B: Distribute Reflux
-        state.reflux_system.distribute(state.households)
-
-        # Save all state
-        # Persistence manager needs ALL transactions?
-        # state.persistence_manager.buffer_tick_state(state, all_transactions)
-        # sim_state.transactions contains all processed transactions.
-        state.persistence_manager.buffer_tick_state(state, sim_state.transactions)
-
-        if state.time % state.batch_save_interval == 0:
-            state.persistence_manager.flush_buffers(state.time)
-
-        # Reset counters
-        for h in state.households:
-            if hasattr(h, "reset_consumption_counters"):
-                h.reset_consumption_counters()
-            else:
-                # Fallback if reset method is missing (e.g. mock objects)
-                if hasattr(h, "current_consumption"):
-                    try:
-                        h.current_consumption = 0.0
-                    except AttributeError:
-                        pass
-
-        for f in state.firms:
-            f.last_daily_expenses = f.expenses_this_tick
-            f.last_sales_volume = f.sales_volume_this_tick
-            f.sales_volume_this_tick = 0.0
-            f.expenses_this_tick = 0.0
-            f.revenue_this_tick = 0.0
-
-        # --- Gold Standard / Money Supply Verification ---
-        if state.time >= 1:
-            # Solvency check moved to start of tick (Phase 0A)
-
-            current_money = state.calculate_total_money()
-            expected_money = getattr(state, "baseline_money_supply", 0.0)
-            if hasattr(state.government, "get_monetary_delta"):
-                expected_money += state.government.get_monetary_delta()
-
-            delta = current_money - expected_money
-
-            msg = f"MONEY_SUPPLY_CHECK | Current: {current_money:.2f}, Expected: {expected_money:.2f}, Delta: {delta:.4f}"
-            extra_data = {"tick": state.time, "current": current_money, "expected": expected_money, "delta": delta, "tags": ["money_supply"]}
-
-            if abs(delta) > 1.0:
-                 state.logger.warning(msg, extra=extra_data)
-            else:
-                 state.logger.info(msg, extra=extra_data)
-
-        # WO-058: Generational Wealth Audit
-        if state.time % 100 == 0:
-             state.generational_wealth_audit.run_audit(state.households, state.time)
-
-        # Phase 29: Crisis Monitor
-        if state.crisis_monitor:
-            state.crisis_monitor.monitor(state.time, [f for f in state.firms if f.is_active])
-
-        state.logger.info(
-            f"--- Ending Tick {state.time} ---",
-            extra={"tick": state.time, "tags": ["tick_end"]},
-        )
-
-        for market in state.markets.values():
-            market.clear_orders()
-
-        if state.stock_market is not None:
-            state.stock_tracker.track_all_firms([f for f in state.firms if f.is_active], state.stock_market)
-
-    def _phase_decisions(self, state: SimulationState, market_data: Dict[str, Any], macro_context: Optional[MacroFinancialContext]) -> Tuple[Dict, Dict, Dict]:
-        """Phase 1: Agents make decisions and place orders."""
-        firm_pre_states = {}
-        household_pre_states = {}
-        household_time_allocation = {}
-
-        # --- TD-117: Create DTOs ---
-        from simulation.dtos.api import MarketSnapshotDTO, GovernmentPolicyDTO
-
-        # Create MarketSnapshotDTO
-        prices = {}
-        volumes = {}
-        asks = {}
-        best_asks = {}
-
-        for m_id, market in state.markets.items():
-            if hasattr(market, "get_daily_avg_price"):
-                 prices[m_id] = market.get_daily_avg_price()
-            if hasattr(market, "get_daily_volume"):
-                 volumes[m_id] = market.get_daily_volume()
-
-            # Extract Asks
-            if hasattr(market, "sell_orders"):
-                for item_id, orders in market.sell_orders.items():
-                    asks[item_id] = orders
-
-                    # Best Ask
-                    if orders:
-                        if hasattr(market, "get_best_ask"):
-                            best_asks[item_id] = market.get_best_ask(item_id)
-                        else:
-                            best_asks[item_id] = orders[0].price if orders else 0.0
-            elif hasattr(market, "get_best_ask"):
-                # Fallback for markets without exposed sell_orders but with get_best_ask (e.g. StockMarket?)
-                # We iterate known items or catch on demand?
-                # Stock market uses firm_id as item_id.
-                # For now we rely on explicit loops if needed, or assume OrderBookMarket structure.
-                pass
-
-        # Stock Market Prices
-        if state.stock_market:
-            for firm in state.firms:
-                if firm.is_active:
-                    price = state.stock_market.get_stock_price(firm.id)
-                    prices[f"stock_{firm.id}"] = price
-
-        market_snapshot = MarketSnapshotDTO(
-            prices=prices,
-            volumes=volumes,
-            asks=asks,
-            best_asks=best_asks
-        )
-
-        # Create GovernmentPolicyDTO
-        gov = state.government
-        bank = state.bank
-
-        income_tax = 0.1
-        if hasattr(gov, "income_tax_rate"):
-            income_tax = gov.income_tax_rate
-        else:
-            state.logger.warning("DTO_FALLBACK | Government missing income_tax_rate, using 0.1")
-
-        corporate_tax = 0.2
-        if hasattr(gov, "corporate_tax_rate"):
-            corporate_tax = gov.corporate_tax_rate
-        else:
-            state.logger.warning("DTO_FALLBACK | Government missing corporate_tax_rate, using 0.2")
-
-        base_rate = 0.05
-        if hasattr(bank, "base_rate"):
-            base_rate = bank.base_rate
-        else:
-            state.logger.warning("DTO_FALLBACK | Bank missing base_rate, using 0.05")
-
-        gov_policy = GovernmentPolicyDTO(
-             income_tax_rate=income_tax,
-             sales_tax_rate=getattr(state.config_module, "SALES_TAX_RATE", 0.05),
-             corporate_tax_rate=corporate_tax,
-             base_interest_rate=base_rate
-        )
-
-        # 1. Firms
-        for firm in state.firms:
-            if firm.is_active:
-                if hasattr(firm.decision_engine, 'ai_engine') and firm.decision_engine.ai_engine:
-                    pre_strategic_state = (
-                        firm.decision_engine.ai_engine._get_strategic_state(
-                            firm.get_agent_data(), market_data
-                        )
-                    )
-                    pre_tactical_state = firm.decision_engine.ai_engine._get_tactical_state(
-                        firm.decision_engine.ai_engine.chosen_intention,
-                        firm.get_agent_data(),
-                        market_data,
-                    )
-                    firm_pre_states[firm.id] = {
-                        "pre_strategic_state": pre_strategic_state,
-                        "pre_tactical_state": pre_tactical_state,
-                        "chosen_intention": firm.decision_engine.ai_engine.chosen_intention,
-                        "chosen_tactic": firm.decision_engine.ai_engine.last_chosen_tactic,
-                    }
-
-                stress_config = self.world_state.stress_scenario_config
-
-                firm_orders, action_vector = firm.make_decision(
-                    state.markets, state.goods_data, market_data, state.time,
-                    state.government, state.reflux_system, stress_config,
-                    market_snapshot=market_snapshot, government_policy=gov_policy
-                )
-
-                for order in firm_orders:
-                    target_market = state.markets.get(order.market_id)
-                    if target_market:
-                        target_market.place_order(order, state.time)
-
-                state.logger.debug(f"TRACE_ENGINE | Firm {firm.id} submitted {len(firm_orders)} orders to markets.")
-
-        # 2. Households
-        for household in state.households:
-            if household.is_active:
-                if hasattr(household.decision_engine, 'ai_engine') and household.decision_engine.ai_engine:
-                    pre_strategic_state = (
-                        household.decision_engine.ai_engine._get_strategic_state(
-                            household.get_agent_data(), market_data
-                        )
-                    )
-                    household_pre_states[household.id] = {
-                        "pre_strategic_state": pre_strategic_state,
-                    }
-
-                stress_config = self.world_state.stress_scenario_config
-                household_orders, action_vector = household.make_decision(
-                    state.markets, state.goods_data, market_data, state.time, state.government, macro_context, stress_config,
-                    market_snapshot=market_snapshot, government_policy=gov_policy
-                )
-
-                if hasattr(action_vector, 'work_aggressiveness'):
-                    work_aggressiveness = action_vector.work_aggressiveness
-                else:
-                    work_aggressiveness = 0.5
-                max_work_hours = state.config_module.MAX_WORK_HOURS
-                shopping_hours = getattr(state.config_module, "SHOPPING_HOURS", 2.0)
-                hours_per_tick = getattr(state.config_module, "HOURS_PER_TICK", 24.0)
-
-                work_hours = work_aggressiveness * max_work_hours
-                leisure_hours = max(0.0, hours_per_tick - work_hours - shopping_hours)
-
-                household_time_allocation[household.id] = leisure_hours
-
-                for order in household_orders:
-                    if order.order_type == "INVEST" and order.market_id == "admin":
-                        state.logger.info(f"FOUND_INVEST_ORDER | Agent {household.id} attempting startup via admin market.")
-                        self.world_state.firm_system.spawn_firm(state, household)
-                        continue
-
-                    target_market_id = order.market_id
-
-                    if order.order_type in ["DEPOSIT", "WITHDRAW", "LOAN_REQUEST", "REPAYMENT"]:
-                        target_market_id = "loan_market"
-                    elif order.item_id in ["deposit", "currency"]:
-                        target_market_id = "loan_market"
-
-                    household_target_market = state.markets.get(target_market_id)
-
-                    if household_target_market:
-                        household_target_market.place_order(order, state.time)
-                    else:
-                        state.logger.warning(
-                            f"Market '{order.market_id}' not found for order from agent {household.id}",
-                            extra={"tick": state.time},
-                        )
-
-                state.logger.debug(f"TRACE_ENGINE | Household {household.id} submitted {len(household_orders)} orders back to engine.")
-
-        return firm_pre_states, household_pre_states, household_time_allocation
-
-    def _phase_matching(self, state: SimulationState) -> None:
-        """Phase 2: Match orders in all markets."""
-        all_transactions = []
-
-        # 1. Goods & Labor Markets
-        for market in state.markets.values():
-            if isinstance(market, OrderBookMarket):
-                all_transactions.extend(market.match_orders(state.time))
-
-        # 2. Stock Market
-        if state.stock_market is not None:
-            stock_transactions = state.stock_market.match_orders(state.time)
-            # Legacy Note: action_processor.process_stock_transactions was here.
-            # Now handled in TransactionProcessor.execute.
-            all_transactions.extend(stock_transactions)
-            state.stock_market.clear_expired_orders(state.time)
-
-        # 3. Housing Market
-        if "housing" in state.markets:
-             housing_transactions = state.markets["housing"].match_orders(state.time)
-             all_transactions.extend(housing_transactions)
-
-        state.transactions = all_transactions
-
-    def _phase_transactions(self, state: SimulationState, system_transactions: List[Transaction] = []) -> None:
-        """Phase 3: Execute transactions."""
-        # Merge system transactions
-        if system_transactions:
-            state.transactions.extend(system_transactions)
-
-        # Use the system service directly via WorldState (or passed if added to DTO)
-        if self.world_state.transaction_processor:
-            self.world_state.transaction_processor.execute(state)
-        else:
-            state.logger.error("TransactionProcessor not initialized.")
-
-    def _phase_lifecycle(self, state: SimulationState) -> None:
-        """Phase 4: Agent Lifecycle."""
-        # 1. Agent Lifecycle (Aging, Birth, Death)
-        if self.world_state.lifecycle_manager:
-            lifecycle_txs = self.world_state.lifecycle_manager.execute(state)
-            if lifecycle_txs:
-                self.world_state.inter_tick_queue.extend(lifecycle_txs)
-        else:
-            state.logger.error("LifecycleManager not initialized.")
-
-        # 2. Commerce Finalization (Consumption & Leisure Effects) - TD-118
-        # Re-construct context or pass relevant data?
-        # Ideally we reuse context but it's local to run_tick.
-        # We'll reconstruct minimal context here or rely on state.
-        # Actually, finalized consumption needs time_allocation which is in state (updated in run_tick).
-
-        # We need to reconstruct CommerceContext.
-        # Since _phase_lifecycle is a method, we can't easily pass the local commerce_context from run_tick
-        # without changing signature.
-        # We'll reconstruct it. It's cheap.
-
-        consumption_market_data = state.market_data # Use existing
-
-        # Household time allocation is needed.
-        # state.households is available.
-        # We need to know who is active.
-        # We need 'household_time_allocation' which IS NOT in SimulationState DTO explicitly?
-        # Check SimulationState definition in api.py.
-        # I didn't add it.
-        # But 'household_time_allocation' is returned by _phase_decisions and stored in WorldState (self.world_state.household_time_allocation).
-        # We can access it via self.world_state if needed, but 'state' arg here is SimulationState DTO.
-        # SimulationState doesn't have it.
-        # But we updated WorldState in run_tick: `state.household_time_allocation = household_time_allocation`.
-        # So we can access self.world_state.household_time_allocation.
-
-        commerce_context: CommerceContext = {
-            "households": state.households,
-            "agents": state.agents,
-            "breeding_planner": self.world_state.breeding_planner,
-            "household_time_allocation": getattr(self.world_state, "household_time_allocation", {}),
-            "reflux_system": state.reflux_system,
-            "market_data": state.market_data,
-            "config": state.config_module,
-            "time": state.time
-        }
-
-        if self.world_state.commerce_system:
-            leisure_effects = self.world_state.commerce_system.finalize_consumption_and_leisure(
-                commerce_context, state.planned_consumption
-            )
-            # Store effects for learning?
-            # Learning update happens in Post-Tick.
-            # We should probably store this somewhere.
-            # The original code returned it from execute_consumption_and_leisure and used it in Learning Update.
-            # In run_tick, we need `household_leisure_effects` variable.
-            # We should store it in SimulationState or WorldState?
-            # WorldState seems appropriate for transient tick data.
-            self.world_state.household_leisure_effects = leisure_effects
-
-    def prepare_market_data(self, tracker: EconomicIndicatorTracker) -> Dict[str, Any]:
-        """       ."""
-        state = self.world_state
-        goods_market_data: Dict[str, Any] = {}
-
-        debt_data_map = {}
-        deposit_data_map = {}
-        for agent_id in state.agents:
-            if isinstance(state.agents[agent_id], Household) or isinstance(state.agents[agent_id], Firm):
-                if state.bank:
-                    # Use IBankService methods with compatibility injection
-                    debt_status = state.bank.get_debt_status(str(agent_id))
-
-                    # Calculate daily_interest_burden for consumers
-                    total_burden = 0.0
-                    # Robustly get ticks_per_year
-                    ticks_per_year = 100
-                    if hasattr(state.bank, "_get_config"):
-                         ticks_per_year = state.bank._get_config("bank_defaults.ticks_per_year", 100)
-
-                    for loan in debt_status.get("loans", []):
-                        total_burden += (loan["outstanding_balance"] * loan["interest_rate"]) / ticks_per_year
-
-                    # Construct extended dict for consumers
-                    debt_data_entry = dict(debt_status)
-                    debt_data_entry["daily_interest_burden"] = total_burden
-                    debt_data_entry["total_principal"] = debt_status["total_outstanding_debt"]
-
-                    debt_data_map[agent_id] = debt_data_entry
-                    deposit_data_map[agent_id] = state.bank.get_balance(str(agent_id))
-
-        for good_name in state.config_module.GOODS:
-            market = state.markets.get(good_name)
-            if market and isinstance(market, OrderBookMarket):
-                avg_price = market.get_daily_avg_price()
-                if avg_price <= 0:
-                    avg_price = market.get_best_ask(good_name) or 0
-                if avg_price <= 0:
-                    latest = tracker.get_latest_indicators()
-                    avg_price = latest.get(f"{good_name}_avg_price", 0)
-                if avg_price <= 0:
-                    avg_price = state.config_module.GOODS[good_name].get("initial_price", 10.0)
-
-                goods_market_data[f"{good_name}_current_sell_price"] = avg_price
-
-        latest_indicators = tracker.get_latest_indicators()
-        avg_wage = latest_indicators.get("labor_avg_price", state.config_module.LABOR_MARKET_MIN_WAGE)
-
-        labor_market = state.markets.get("labor")
-        best_wage_offer = 0.0
-        if labor_market and isinstance(labor_market, OrderBookMarket):
-            best_wage_offer = labor_market.get_best_bid("labor") or 0.0
-            if best_wage_offer <= 0:
-                best_wage_offer = avg_wage
-
-        job_vacancies = 0
-        if labor_market and isinstance(labor_market, OrderBookMarket):
-             for item_orders in labor_market.buy_orders.values():
-                 for order in item_orders:
-                     job_vacancies += order.quantity
-
-        goods_market_data["labor"] = {
-            "avg_wage": avg_wage,
-            "best_wage_offer": best_wage_offer
-        }
-        goods_market_data["job_vacancies"] = job_vacancies
-
-        total_price = 0.0
-        count = 0.0
-        for good_name in state.config_module.GOODS:
-            price = goods_market_data.get(f"{good_name}_current_sell_price")
-            if price is not None:
-                total_price += price
-                count += 1
-
-        avg_goods_price_for_market_data = total_price / count if count > 0 else 10.0
-
-        stock_market_data = {}
-        if state.stock_market:
-            for firm in state.firms:
-                firm_item_id = f"stock_{firm.id}"
-                price = state.stock_market.get_daily_avg_price(firm.id)
-                if price <= 0:
-                    price = state.stock_market.get_best_ask(firm.id) or 0
-                if price <= 0:
-                    price = firm.assets / firm.total_shares if firm.total_shares > 0 else 10.0
-                stock_market_data[firm_item_id] = {"avg_price": price}
-
-        rent_prices = [u.rent_price for u in state.real_estate_units if u.owner_id is not None]
-        avg_rent = sum(rent_prices) / len(rent_prices) if rent_prices else state.config_module.INITIAL_RENT_PRICE
-
-        housing_market_data = {
-            "avg_rent_price": avg_rent
-        }
-
-        return {
-            "time": state.time,
-            "goods_market": goods_market_data,
-            "housing_market": housing_market_data,
-            "loan_market": {"interest_rate": state.bank.base_rate},
-            "stock_market": stock_market_data,
-            "all_households": state.households,
-            "avg_goods_price": avg_goods_price_for_market_data,
-            "debt_data": debt_data_map,
-            "deposit_data": deposit_data_map,
-            "inflation": latest_indicators.get("inflation_rate", state.config_module.DEFAULT_INFLATION_RATE)
-        }
-
-    def _phase_pre_sequence_stabilization(self, state: WorldState) -> None:
-        """Phase 0A: Pre-Sequence Stabilization (WO-109)."""
-        if hasattr(state.bank, "generate_solvency_transactions"):
-            stabilization_txs = state.bank.generate_solvency_transactions(state.government)
-            if stabilization_txs:
-                temp_sim_state = SimulationState(
-                    time=state.time,
-                    households=state.households,
-                    firms=state.firms,
-                    agents=state.agents,
-                    markets=state.markets,
-                    government=state.government,
-                    bank=state.bank,
-                    central_bank=state.central_bank,
-                    stock_market=state.stock_market,
-                    goods_data=state.goods_data,
-                    market_data={},
-                    config_module=state.config_module,
-                    tracker=state.tracker,
-                    logger=state.logger,
-                    reflux_system=state.reflux_system,
-                    ai_training_manager=state.ai_training_manager,
-                    ai_trainer=state.ai_trainer,
-                    settlement_system=state.settlement_system,
-                    transactions=stabilization_txs,
-                    inactive_agents=state.inactive_agents
-                )
-                if state.transaction_processor:
-                    state.transaction_processor.execute(temp_sim_state)
-                    state.logger.warning("STABILIZATION | Executed pre-sequence stabilization for Bank.")
diff --git a/tests/test_engine.py b/tests/test_engine.py
index fd84cf4..1839570 100644
--- a/tests/test_engine.py
+++ b/tests/test_engine.py
@@ -166,6 +166,19 @@ def mock_households(mock_config_module):
     hh1.talent.base_learning_rate = 0.1
     hh1.inventory_quality = {}
 
+    # Configure side effects for asset updates
+    def withdraw_side_effect(amount):
+        hh1.assets -= amount
+    def deposit_side_effect(amount):
+        hh1.assets += amount
+    def record_consumption_side_effect(quantity, is_food=False):
+        hh1.current_consumption += quantity
+        if is_food:
+            hh1.current_food_consumption += quantity
+    hh1.withdraw.side_effect = withdraw_side_effect
+    hh1.deposit.side_effect = deposit_side_effect
+    hh1.record_consumption.side_effect = record_consumption_side_effect
+
     hh2 = Mock(spec=Household)
     hh2.id = 2
     hh2._assets = 150.0
@@ -186,6 +199,11 @@ def mock_households(mock_config_module):
     hh2.talent = Mock(spec=Talent)
     hh2.talent.base_learning_rate = 0.1
     hh2.inventory_quality = {}
+
+    # Reuse side effects
+    hh2.withdraw.side_effect = withdraw_side_effect
+    hh2.deposit.side_effect = deposit_side_effect
+
     return [hh1, hh2]
 
 
@@ -726,6 +744,10 @@ def test_handle_agent_lifecycle_removes_inactive_agents(setup_simulation_for_lif
         real_estate_units=getattr(sim, 'real_estate_units', [])
     )
 
+    # Force inactive state as SimulationInitializer.build_simulation -> update_needs resets it
+    household_inactive.is_active = False
+    firm_inactive.is_active = False
+
     sim.lifecycle_manager._handle_agent_liquidation(state)
 
     assert len(sim.households) == 2
