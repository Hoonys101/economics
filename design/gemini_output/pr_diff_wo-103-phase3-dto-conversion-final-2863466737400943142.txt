diff --git a/modules/household/dtos.py b/modules/household/dtos.py
index be146f4..62b5086 100644
--- a/modules/household/dtos.py
+++ b/modules/household/dtos.py
@@ -33,6 +33,7 @@ class HouseholdStateDTO:
     portfolio_holdings: Dict[int, Share]
     risk_aversion: float
     agent_data: Dict[str, Any]
+    perceived_prices: Dict[str, float] = field(default_factory=dict)
 
     # Additional fields needed by DecisionEngine
     conformity: float = 0.5
diff --git a/scripts/fixture_harvester.py b/scripts/fixture_harvester.py
index 2031e85..71e56bf 100644
--- a/scripts/fixture_harvester.py
+++ b/scripts/fixture_harvester.py
@@ -28,12 +28,16 @@ from datetime import datetime
 from pathlib import Path
 from unittest.mock import MagicMock
 
+from modules.household.dtos import HouseholdStateDTO
+from simulation.dtos.firm_state_dto import FirmStateDTO
+from simulation.ai.api import Personality
+
 # Attempt to import the new generic loader
 try:
     from tests.utils.golden_loader import GoldenLoader as GenericGoldenLoader
 except ImportError:
     # If not in path (e.g. running script directly from shell), try adding root
-sys.path.append(str(Path(__file__).resolve().parent.parent))
+    sys.path.append(str(Path(__file__).resolve().parent.parent))
     try:
         from tests.utils.golden_loader import GoldenLoader as GenericGoldenLoader
     except ImportError:
@@ -222,91 +226,127 @@ class GoldenLoader:
     def create_household_mocks(self, mock_class=None):
         """
         Create mock households from golden data.
-        
-        Args:
-            mock_class: Optional - The actual Household class to use.
-                       If None, creates SimpleNamespace objects (legacy behavior) or MagicMock if generic loader used.
         """
         mocks = []
         for h_data in self.households_data:
-            if GenericGoldenLoader:
-                # Use GenericGoldenLoader to do the basic conversion
-                mock = GenericGoldenLoader.dict_to_mock(h_data, spec=mock_class)
+            # Fallback to old logic or Generic
+            from types import SimpleNamespace
+            if mock_class:
+                mock = MagicMock(spec=mock_class)
             else:
-                # Fallback to old logic
-                from types import SimpleNamespace
-                if mock_class:
-                    mock = MagicMock(spec=mock_class)
-                else:
-                    mock = SimpleNamespace()
-                for key, value in h_data.items():
-                    setattr(mock, key, value)
+                mock = SimpleNamespace()
+            for key, value in h_data.items():
+                setattr(mock, key, value)
 
-            # Add standard mock methods
-            # logic methods are never in data, so we can safely set them
             mock.make_decision = MagicMock(return_value=([], MagicMock()))
-
-            # Ensure complex nested mocks exist
-            # (Explicitly setting them ensures they exist even if we use SimpleNamespace in fallback)
             if not hasattr(mock, 'decision_engine'):
                 mock.decision_engine = MagicMock()
             if not hasattr(mock.decision_engine, 'ai_engine'):
                 mock.decision_engine.ai_engine = MagicMock()
-            
             mocks.append(mock)
-        
         return mocks
+
+    def create_household_dto_list(self) -> List[HouseholdStateDTO]:
+        """Creates actual HouseholdStateDTO objects from golden data."""
+        dtos = []
+        for h_data in self.households_data:
+            dto = HouseholdStateDTO(
+                id=h_data.get("id", 0),
+                assets=h_data.get("assets", 0.0),
+                inventory=h_data.get("inventory", {}),
+                needs=h_data.get("needs", {}),
+                preference_asset=1.0,
+                preference_social=1.0,
+                preference_growth=1.0,
+                personality=Personality.BALANCED,
+                durable_assets=[],
+                expected_inflation={},
+                is_employed=h_data.get("is_employed", False),
+                current_wage=h_data.get("current_wage", 0.0),
+                wage_modifier=1.0,
+                is_homeless=False,
+                residing_property_id=None,
+                owned_properties=[],
+                portfolio_holdings={},
+                risk_aversion=1.0,
+                agent_data=h_data, # Use raw dict as agent_data
+                perceived_prices={},
+                conformity=0.5,
+                social_rank=0.5,
+                approval_rating=float(h_data.get("approval_rating", 1.0))
+            )
+            dtos.append(dto)
+        return dtos
     
     def create_firm_mocks(self, mock_class=None):
-        """
-        Create mock firms from golden data.
-        
-        Args:
-            mock_class: Optional - The actual Firm class to use.
-                       If None, creates SimpleNamespace objects (legacy behavior) or MagicMock if generic loader used.
-        """
+        """Create mock firms from golden data."""
         mocks = []
         for f_data in self.firms_data:
-            if GenericGoldenLoader:
-                mock = GenericGoldenLoader.dict_to_mock(f_data, spec=mock_class)
+            from types import SimpleNamespace
+            if mock_class:
+                mock = MagicMock(spec=mock_class)
             else:
-                from types import SimpleNamespace
-                if mock_class:
-                    mock = MagicMock(spec=mock_class)
-                else:
-                    mock = SimpleNamespace()
-                for key, value in f_data.items():
-                    setattr(mock, key, value)
+                mock = SimpleNamespace()
+            for key, value in f_data.items():
+                setattr(mock, key, value)
             
-            # Add required mock methods
             mock.make_decision = MagicMock(return_value=([], MagicMock()))
-
             if not hasattr(mock, 'decision_engine'):
                 mock.decision_engine = MagicMock()
             if not hasattr(mock.decision_engine, 'ai_engine'):
                 mock.decision_engine.ai_engine = MagicMock()
-
-            # HR logic
             if not hasattr(mock, 'hr'):
                 mock.hr = MagicMock()
-
-            # If employees wasn't in data (it's not in snapshot, only count is), ensure it's empty list
-            # We must force this because MagicMock would return a Mock object for 'employees' otherwise
             mock.hr.employees = []
-            
-            # Add get_financial_snapshot based on captured data
-            # Logic method, always mock it
             mock.get_financial_snapshot = MagicMock(return_value={
-                "total_assets": f_data.get("assets", 0) + sum(f_data.get("inventory", {}).values()) * 10,
+                "total_assets": f_data.get("assets", 0),
                 "working_capital": f_data.get("assets", 0),
                 "retained_earnings": f_data.get("retained_earnings", 0),
                 "average_profit": f_data.get("current_profit", 0),
                 "total_debt": f_data.get("total_debt", 0)
             })
-            
             mocks.append(mock)
-        
         return mocks
+
+    def create_firm_dto_list(self) -> List[FirmStateDTO]:
+        """Creates actual FirmStateDTO objects from golden data."""
+        dtos = []
+        for f_data in self.firms_data:
+            dto = FirmStateDTO(
+                id=f_data.get("id", 0),
+                assets=f_data.get("assets", 0.0),
+                is_active=f_data.get("is_active", True),
+                inventory=f_data.get("inventory", {}),
+                inventory_quality={},
+                input_inventory={},
+                current_production=0.0,
+                productivity_factor=f_data.get("productivity_factor", 1.0),
+                production_target=100.0,
+                capital_stock=100.0,
+                base_quality=1.0,
+                automation_level=0.0,
+                specialization=f_data.get("specialization", "food"),
+                total_shares=100.0,
+                treasury_shares=0.0,
+                dividend_rate=0.1,
+                is_publicly_traded=True,
+                valuation=1000.0,
+                revenue_this_turn=0.0,
+                expenses_this_tick=0.0,
+                consecutive_loss_turns=f_data.get("consecutive_loss_turns", 0),
+                altman_z_score=3.0,
+                price_history={},
+                profit_history=[f_data.get("current_profit", 0.0)],
+                brand_awareness=0.0,
+                perceived_quality=1.0,
+                marketing_budget=0.0,
+                employees=[],
+                employees_data={},
+                agent_data=f_data,
+                system2_guidance={}
+            )
+            dtos.append(dto)
+        return dtos
     
     def create_config_mock(self):
         """Create a mock config module from golden data."""
diff --git a/simulation/decisions/ai_driven_household_engine.py b/simulation/decisions/ai_driven_household_engine.py
index a0f1d3d..e902679 100644
--- a/simulation/decisions/ai_driven_household_engine.py
+++ b/simulation/decisions/ai_driven_household_engine.py
@@ -48,7 +48,12 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
 
         # Legacy fallback if state is not provided but household object is
         if household is None and context.household:
-             household = context.household.create_state_dto()
+             # Check if context.household is actually a DTO already
+             if hasattr(context.household, "create_state_dto"):
+                 household = context.household.create_state_dto()
+             else:
+                 # It's already a DTO, use it directly
+                 household = context.household
 
         if household is None:
             # Fallback action vector for returning if agent is None
diff --git a/simulation/dtos/firm_state_dto.py b/simulation/dtos/firm_state_dto.py
new file mode 100644
index 0000000..20b097f
--- /dev/null
+++ b/simulation/dtos/firm_state_dto.py
@@ -0,0 +1,50 @@
+from dataclasses import dataclass, field
+from typing import Dict, List, Optional, Any
+
+@dataclass
+class FirmStateDTO:
+    """
+    A read-only DTO containing the state of a Firm agent.
+    Used by DecisionEngines to make decisions without direct dependency on the Firm class.
+    """
+    id: int
+    assets: float
+    is_active: bool
+    inventory: Dict[str, float]
+    inventory_quality: Dict[str, float]
+    input_inventory: Dict[str, float]
+
+    # Production & Tech
+    current_production: float
+    productivity_factor: float
+    production_target: float
+    capital_stock: float
+    base_quality: float
+    automation_level: float
+    specialization: str
+
+    # Finance & Market
+    total_shares: float
+    treasury_shares: float
+    dividend_rate: float
+    is_publicly_traded: bool
+    valuation: float
+    revenue_this_turn: float
+    expenses_this_tick: float
+    consecutive_loss_turns: int
+    altman_z_score: float
+    price_history: Dict[str, float] # last_prices
+    profit_history: List[float]
+
+    # Brand & Sales
+    brand_awareness: float
+    perceived_quality: float
+    marketing_budget: float
+
+    # HR
+    employees: List[int] # List of employee IDs
+    employees_data: Dict[int, Dict[str, Any]] # Detailed employee info
+
+    # AI/Agent Data
+    agent_data: Dict[str, Any]
+    system2_guidance: Dict[str, Any]
diff --git a/tests/factories.py b/tests/factories.py
new file mode 100644
index 0000000..42b48ac
--- /dev/null
+++ b/tests/factories.py
@@ -0,0 +1,94 @@
+
+from typing import Dict, Any, Optional
+from simulation.ai.enums import Personality
+from modules.household.dtos import HouseholdStateDTO
+from simulation.dtos.firm_state_dto import FirmStateDTO
+
+def create_household_dto(
+    id: int = 1,
+    assets: float = 1000.0,
+    inventory: Optional[Dict[str, float]] = None,
+    needs: Optional[Dict[str, float]] = None,
+    is_employed: bool = False,
+    current_wage: float = 0.0,
+    wage_modifier: float = 1.0,
+    durable_assets: Optional[list] = None,
+    perceived_prices: Optional[Dict[str, float]] = None,
+    agent_data: Optional[Dict[str, Any]] = None,
+    personality: Personality = Personality.BALANCED,
+    **kwargs
+) -> HouseholdStateDTO:
+    """Factory for HouseholdStateDTO with sensible defaults."""
+    return HouseholdStateDTO(
+        id=id,
+        assets=assets,
+        inventory=inventory or {},
+        needs=needs or {"survival": 0.5, "leisure": 0.5},
+        preference_asset=kwargs.get("preference_asset", 1.0),
+        preference_social=kwargs.get("preference_social", 1.0),
+        preference_growth=kwargs.get("preference_growth", 1.0),
+        personality=personality,
+        durable_assets=durable_assets or [],
+        expected_inflation=kwargs.get("expected_inflation", {}),
+        is_employed=is_employed,
+        current_wage=current_wage,
+        wage_modifier=wage_modifier,
+        is_homeless=kwargs.get("is_homeless", False),
+        residing_property_id=kwargs.get("residing_property_id"),
+        owned_properties=kwargs.get("owned_properties", []),
+        portfolio_holdings=kwargs.get("portfolio_holdings", {}),
+        risk_aversion=kwargs.get("risk_aversion", 1.0),
+        agent_data=agent_data or {},
+        perceived_prices=perceived_prices or {},
+        conformity=kwargs.get("conformity", 0.5),
+        social_rank=kwargs.get("social_rank", 0.5),
+        approval_rating=kwargs.get("approval_rating", 1)
+    )
+
+def create_firm_dto(
+    id: int = 100,
+    assets: float = 10000.0,
+    is_active: bool = True,
+    inventory: Optional[Dict[str, float]] = None,
+    current_production: float = 0.0,
+    productivity_factor: float = 1.0,
+    production_target: float = 100.0,
+    capital_stock: float = 100.0,
+    employees: Optional[list] = None,
+    price_history: Optional[Dict[str, float]] = None,
+    **kwargs
+) -> FirmStateDTO:
+    """Factory for FirmStateDTO with sensible defaults."""
+    return FirmStateDTO(
+        id=id,
+        assets=assets,
+        is_active=is_active,
+        inventory=inventory or {},
+        inventory_quality=kwargs.get("inventory_quality", {}),
+        input_inventory=kwargs.get("input_inventory", {}),
+        current_production=current_production,
+        productivity_factor=productivity_factor,
+        production_target=production_target,
+        capital_stock=capital_stock,
+        base_quality=kwargs.get("base_quality", 1.0),
+        automation_level=kwargs.get("automation_level", 0.0),
+        specialization=kwargs.get("specialization", "food"),
+        total_shares=kwargs.get("total_shares", 100.0),
+        treasury_shares=kwargs.get("treasury_shares", 0.0),
+        dividend_rate=kwargs.get("dividend_rate", 0.1),
+        is_publicly_traded=kwargs.get("is_publicly_traded", True),
+        valuation=kwargs.get("valuation", 1000.0),
+        revenue_this_turn=kwargs.get("revenue_this_turn", 0.0),
+        expenses_this_tick=kwargs.get("expenses_this_tick", 0.0),
+        consecutive_loss_turns=kwargs.get("consecutive_loss_turns", 0),
+        altman_z_score=kwargs.get("altman_z_score", 3.0),
+        price_history=price_history or {},
+        profit_history=kwargs.get("profit_history", []),
+        brand_awareness=kwargs.get("brand_awareness", 0.0),
+        perceived_quality=kwargs.get("perceived_quality", 1.0),
+        marketing_budget=kwargs.get("marketing_budget", 0.0),
+        employees=employees or [],
+        employees_data=kwargs.get("employees_data", {}),
+        agent_data=kwargs.get("agent_data", {}),
+        system2_guidance=kwargs.get("system2_guidance", {})
+    )
diff --git a/tests/goldens/demo_fixture.json b/tests/goldens/demo_fixture.json
index be7c931..467492d 100644
--- a/tests/goldens/demo_fixture.json
+++ b/tests/goldens/demo_fixture.json
@@ -1,6 +1,6 @@
 {
   "metadata": {
-    "captured_at": "2026-01-19T14:17:23.705220",
+    "captured_at": "2026-01-21T12:01:37.689440",
     "tick": 0,
     "household_count": 5,
     "firm_count": 3
diff --git a/tests/test_corporate_manager.py b/tests/test_corporate_manager.py
index 3fb5018..26ab3ef 100644
--- a/tests/test_corporate_manager.py
+++ b/tests/test_corporate_manager.py
@@ -62,6 +62,8 @@ def firm_mock(golden_firms):
     firm.finance.pay_ad_hoc_tax.side_effect = pay_tax_side_effect
     firm.finance.set_dividend_rate.side_effect = set_dividend_rate_side_effect
     firm.finance.get_book_value_per_share.return_value = 10.0 # Default BPS
+    firm.finance.calculate_altman_z_score.return_value = 3.0 # Default safe Z-score
+    firm.finance.consecutive_loss_turns = 0
 
     firm.hr = MagicMock()
     firm.hr.employees = []
diff --git a/tests/test_household_decision_engine_new.py b/tests/test_household_decision_engine_new.py
index 3ff096a..3bb4f03 100644
--- a/tests/test_household_decision_engine_new.py
+++ b/tests/test_household_decision_engine_new.py
@@ -4,15 +4,13 @@ from unittest.mock import Mock, patch
 from simulation.decisions.ai_driven_household_engine import (
     AIDrivenHouseholdDecisionEngine,
 )
-from simulation.core_agents import Household
 from simulation.ai.household_ai import HouseholdAI
-from simulation.ai.enums import Tactic, Aggressiveness
 from simulation.dtos import DecisionContext
 from simulation.models import Order
 from simulation.markets.order_book_market import OrderBookMarket
 from simulation.schemas import HouseholdActionVector
 from simulation.ai.api import Personality
-
+from tests.factories import create_household_dto
 
 # Mock Logger
 @pytest.fixture(autouse=True)
@@ -84,52 +82,17 @@ def mock_config():
 
 
 @pytest.fixture
-def mock_household():
-    hh = Mock(spec=Household)
-    hh.id = 1
-    hh.assets = 100.0
-    hh.economy_manager = Mock()
-    hh.labor_manager = Mock()
-    hh.needs = {"survival": 0.8, "leisure": 0.5}
-    hh.get_agent_data.return_value = {}
-    hh.get_pre_state_data.return_value = {}
-    hh.get_desired_wage.return_value = 50.0
-    hh.perceived_avg_prices = {}
-    hh.inventory = {}
-    hh.is_employed = False
-    hh.expected_inflation = {}
-    hh.value_orientation = "wealth_and_needs"
-    hh.current_wage = 0.0
-    hh.personality = Personality.BALANCED
-    hh.wage_modifier = 1.0
-    hh.preference_asset = 1.0
-    hh.preference_social = 1.0
-    hh.preference_growth = 1.0
-
-    # DTO Config
-    state_dto = Mock()
-    state_dto.id = 1
-    state_dto.assets = 100.0
-    state_dto.inventory = {}
-    state_dto.needs = {"survival": 0.8, "leisure": 0.5}
-    state_dto.expected_inflation = {}
-    state_dto.preference_asset = 1.0
-    state_dto.preference_social = 1.0
-    state_dto.preference_growth = 1.0
-    state_dto.personality = Personality.BALANCED
-    state_dto.is_employed = False
-    state_dto.current_wage = 0.0
-    state_dto.wage_modifier = 1.0
-    state_dto.risk_aversion = 1.0
-    state_dto.portfolio_holdings = {}
-    state_dto.agent_data = {}
-    state_dto.durable_assets = []
-    state_dto.residing_property_id = None
-    state_dto.owned_properties = []
-
-    hh.create_state_dto.return_value = state_dto
-
-    return hh
+def mock_household_dto():
+    """Returns a HouseholdStateDTO with typical test values."""
+    return create_household_dto(
+        id=1,
+        assets=100.0,
+        needs={"survival": 0.8, "leisure": 0.5},
+        is_employed=False,
+        current_wage=0.0,
+        wage_modifier=1.0,
+        personality=Personality.BALANCED
+    )
 
 
 @pytest.fixture
@@ -156,10 +119,10 @@ def decision_engine(mock_ai_engine, mock_config):
 
 class TestAIDrivenHouseholdDecisionEngine:
     def test_make_decisions_calls_ai(
-        self, decision_engine, mock_household, mock_ai_engine
+        self, decision_engine, mock_household_dto, mock_ai_engine
     ):
         context = DecisionContext(
-            household=mock_household,
+            household=mock_household_dto,
             markets={},
             goods_data=[],
             market_data={},
@@ -169,7 +132,7 @@ class TestAIDrivenHouseholdDecisionEngine:
         mock_ai_engine.decide_action_vector.assert_called_once()
 
     def test_consumption_do_nothing(
-        self, decision_engine, mock_household, mock_ai_engine
+        self, decision_engine, mock_household_dto, mock_ai_engine
     ):
         # Action Vector with 0 aggressiveness implies "Do Nothing" or buy minimum
         mock_ai_engine.decide_action_vector.return_value = HouseholdActionVector(
@@ -177,7 +140,7 @@ class TestAIDrivenHouseholdDecisionEngine:
         )
 
         context = DecisionContext(
-            household=mock_household,
+            household=mock_household_dto,
             markets={},
             goods_data=[],
             market_data={},
@@ -188,7 +151,7 @@ class TestAIDrivenHouseholdDecisionEngine:
         pass
 
     def test_consumption_buy_basic_food_sufficient_assets(
-        self, decision_engine, mock_household, mock_ai_engine, mock_config
+        self, decision_engine, mock_household_dto, mock_ai_engine, mock_config
     ):
         mock_goods_market = Mock(spec=OrderBookMarket, id="goods_market")
         mock_goods_market.get_best_ask.return_value = 10.0
@@ -200,7 +163,7 @@ class TestAIDrivenHouseholdDecisionEngine:
         )
 
         context = DecisionContext(
-            household=mock_household,
+            household=mock_household_dto,
             markets=mock_markets,
             goods_data=[],
             market_data={},
@@ -212,13 +175,13 @@ class TestAIDrivenHouseholdDecisionEngine:
         assert bf_order is not None
 
     def test_consumption_buy_luxury_food_insufficient_assets(
-        self, decision_engine, mock_household, mock_ai_engine, mock_config
+        self, decision_engine, mock_household_dto, mock_ai_engine, mock_config
     ):
         mock_goods_market = Mock(spec=OrderBookMarket, id="goods_market")
         mock_goods_market.get_best_ask.return_value = 1000.0
         mock_markets = {"goods_market": mock_goods_market}
         
-        mock_household.create_state_dto.return_value.assets = 100.0 # DTO assets
+        mock_household_dto.assets = 100.0 # DTO assets
 
         mock_ai_engine.decide_action_vector.return_value = HouseholdActionVector(
              consumption_aggressiveness={"luxury_food": 0.9}
@@ -233,7 +196,7 @@ class TestAIDrivenHouseholdDecisionEngine:
         }
 
         context = DecisionContext(
-            household=mock_household,
+            household=mock_household_dto,
             markets=mock_markets,
             goods_data=[],
             market_data=market_data,
@@ -246,7 +209,7 @@ class TestAIDrivenHouseholdDecisionEngine:
         assert lf_order is None or lf_order.quantity < 1.0
 
     def test_consumption_evaluate_options_chooses_best_utility(
-        self, decision_engine, mock_household, mock_ai_engine, mock_config
+        self, decision_engine, mock_household_dto, mock_ai_engine, mock_config
     ):
         mock_goods_market = Mock(spec=OrderBookMarket, id="goods_market")
         mock_goods_market.get_best_ask.side_effect = lambda item_id: 10.0 if item_id == "basic_food" else (20.0 if item_id == "luxury_food" else None)
@@ -259,7 +222,7 @@ class TestAIDrivenHouseholdDecisionEngine:
         )
 
         context = DecisionContext(
-            household=mock_household,
+            household=mock_household_dto,
             markets=mock_markets,
             goods_data=[],
             market_data={},
@@ -270,7 +233,7 @@ class TestAIDrivenHouseholdDecisionEngine:
         assert len(orders) >= 1
 
     def test_labor_market_participation_aggressive(
-        self, decision_engine, mock_household, mock_ai_engine
+        self, decision_engine, mock_household_dto, mock_ai_engine
     ):
         mock_labor_market = Mock(spec=OrderBookMarket, id="labor_market")
         mock_labor_market.get_all_bids = Mock(
@@ -283,8 +246,8 @@ class TestAIDrivenHouseholdDecisionEngine:
         )
 
         # Set DTO wage
-        mock_household.create_state_dto.return_value.current_wage = 0.0
-        mock_household.create_state_dto.return_value.wage_modifier = 1.0
+        mock_household_dto.current_wage = 0.0
+        mock_household_dto.wage_modifier = 0.9 # Lower than 1.0 to trigger participation
 
         # Inject market data for avg wage
         market_data = {
@@ -297,7 +260,7 @@ class TestAIDrivenHouseholdDecisionEngine:
         }
 
         context = DecisionContext(
-            household=mock_household,
+            household=mock_household_dto,
             markets=mock_markets,
             goods_data=[],
             market_data=market_data,
@@ -307,71 +270,14 @@ class TestAIDrivenHouseholdDecisionEngine:
 
         # Filter Labor Order
         labor_order = next((o for o in orders if o.item_id == "labor"), None)
-        # Note: In Facade Refactoring, AIDrivenHouseholdDecisionEngine no longer has direct side-effect access
-        # to household.wage_modifier unless it modifies the DTO or household is passed.
-        # But 'make_decisions' calculates reservation_wage based on passed DTO.
-        # However, the logic for updating wage_modifier (decay/recovery) was REMOVED from Engine
-        # and assumed to be in EconComponent or handled BEFORE decision.
-        # Wait, the code in Engine:
-        # reservation_wage = market_avg_wage * household.wage_modifier
-        # It uses the modifier from the DTO.
-        # The test sets modifier=1.0.
-        # So reservation_wage = 50.0 * 1.0 = 50.0.
-        # Market offer is 49.5.
-        # 49.5 < 50.0.
-        # So it should REFUSE (return None).
-        # Previously, the Engine *updated* the modifier in-place (decay/recovery).
-        # In the new code, does it update the modifier?
-        # The new code:
-        #   # 1. Update Wage Modifier (Adaptive) ... logic removed?
-        # Let's check the applied diff for 'ai_driven_household_engine.py'.
-        # I removed the update block in the previous failed patch? No, I tried to debug print it.
-        # Let's check if the update block exists.
-
-        # If the Engine DOES NOT update modifier, then it remains 1.0.
-        # Then Reservation Wage is 50.0.
-        # Offer is 49.5.
-        # 49.5 < 50.0 -> Refusal.
-        # So 'labor_order' is None.
-        # The assertion expects 'labor_order is not None'.
-        # So the test expects the agent to SELL.
-        # Why did it SELL before?
-        # Because previously, the Engine *did* update the modifier (decay/recovery).
-        # Or maybe the test setup implies it should sell? "aggressive".
-        # If aggressive, why sell?
-        # Aggressiveness used to lower price. In V2, it affects quit prob.
-        # Here we are UNEMPLOYED.
-        # If unemployed, we check if offer >= reservation.
-        # If we want it to sell, we need reservation < offer.
-        # So we need modifier < 0.99.
-        # We must manually set modifier in DTO to simulate "desperation" or ensure the engine updates it.
-        # The Architecture Plan says: "Move aging/lifecycle... to BioComponent".
-        # Wage updates are Econ/Labor logic.
-        # If the Engine is "Pure Logic", it shouldn't mutate state.
-        # But it needs to calculate the price for the order.
-        # If the Engine doesn't update, who does?
-        # EconComponent.orchestrate_economic_decisions?
-        # No, that runs AFTER orders.
-        # So the input DTO must ALREADY have the updated modifier.
-        # The test should simulate that time passed or modifier dropped.
-        # I will update the test to set a lower modifier to ensure participation.
-
-        # Manually lower modifier to simulate desperation
-        mock_household.create_state_dto.return_value.wage_modifier = 0.9
-
-        # Res Wage = 50 * 0.9 = 45.0
-        # Offer 49.5 >= 45.0. Should Accept.
-
-        # Re-run make_decisions with updated DTO
-        orders, _ = decision_engine.make_decisions(context)
-        labor_order = next((o for o in orders if o.item_id == "labor"), None)
 
         assert labor_order is not None
         assert labor_order.order_type == "SELL"
+        # 50.0 * 0.9 = 45.0
         assert labor_order.price == 45.0
 
     def test_labor_market_participation_passive_no_offer(
-        self, decision_engine, mock_household, mock_ai_engine
+        self, decision_engine, mock_household_dto, mock_ai_engine
     ):
         mock_labor_market = Mock(spec=OrderBookMarket, id="labor_market")
         mock_labor_market.get_all_bids = Mock(
@@ -384,8 +290,8 @@ class TestAIDrivenHouseholdDecisionEngine:
              work_aggressiveness=0.1
         )
 
-        mock_household.create_state_dto.return_value.current_wage = 0.0
-        mock_household.create_state_dto.return_value.wage_modifier = 1.0
+        mock_household_dto.current_wage = 0.0
+        mock_household_dto.wage_modifier = 1.0
 
         # Inject high avg wage so reservation wage calc results in high value
         market_data = {
@@ -398,7 +304,7 @@ class TestAIDrivenHouseholdDecisionEngine:
         }
 
         context = DecisionContext(
-            household=mock_household,
+            household=mock_household_dto,
             markets=mock_markets,
             goods_data=[],
             market_data=market_data,
@@ -408,11 +314,6 @@ class TestAIDrivenHouseholdDecisionEngine:
 
         # Filter Labor Order
         labor_order = next((o for o in orders if o.item_id == "labor"), None)
-        # If modifier is 1.0 (no decay in engine), Res Wage = 50.0.
-        # Offer 55.0 > 50.0.
-        # So it SHOULD sell.
+        # Res Wage = 50.0. Offer 55.0. 55 > 50 -> Sell.
         assert labor_order is not None
-        # Price should be Reservation Wage = 50.0 * 1.0 = 50.0 (if no decay)
-        # The test asserted 49.0 (assuming decay).
-        # Since we removed side-effects from Engine, we asserting 50.0.
         assert labor_order.price == 50.0
diff --git a/tests/test_wo058_production.py b/tests/test_wo058_production.py
index b54bd88..d554d40 100644
--- a/tests/test_wo058_production.py
+++ b/tests/test_wo058_production.py
@@ -7,6 +7,7 @@ from simulation.firms import Firm
 from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
 from simulation.decisions.ai_driven_firm_engine import AIDrivenFirmDecisionEngine
 from simulation.ai.api import Personality
+from simulation.metrics.economic_tracker import EconomicIndicatorTracker
 
 @pytest.fixture
 def mock_config():
@@ -90,7 +91,15 @@ def test_bootstrapper_injection(mock_config, mock_repo, mock_ai_trainer):
     ]
 
     # The bootstrapper is called during the Simulation initialization
-    sim = Simulation(households=households, firms=firms, ai_trainer=mock_ai_trainer, repository=mock_repo, config_module=mock_config, goods_data=[])
+    sim = Simulation(config_manager=Mock(), config_module=mock_config, logger=Mock(), repository=mock_repo)
+    sim.world_state.households = households
+    sim.world_state.firms = firms
+    sim.world_state.ai_trainer = mock_ai_trainer
+    sim.world_state.goods_data = []
+    sim.world_state.tracker = EconomicIndicatorTracker(config_module=mock_config)
+
+    Bootstrapper.inject_initial_liquidity(sim.firms, mock_config)
+    Bootstrapper.force_assign_workers(sim.firms, sim.households)
 
     # Assert Assets >= 2000
     for firm in sim.firms:
@@ -111,7 +120,15 @@ def test_production_kickstart(mock_config, mock_repo, mock_ai_trainer):
     ]
 
     # This is a simplified simulation setup; a real test would need more comprehensive mocks
-    sim = Simulation(households=households, firms=firms, ai_trainer=mock_ai_trainer, repository=mock_repo, config_module=mock_config, goods_data=[])
+    sim = Simulation(config_manager=Mock(), config_module=mock_config, logger=Mock(), repository=mock_repo)
+    sim.world_state.households = households
+    sim.world_state.firms = firms
+    sim.world_state.ai_trainer = mock_ai_trainer
+    sim.world_state.goods_data = []
+    sim.world_state.tracker = EconomicIndicatorTracker(config_module=mock_config)
+
+    Bootstrapper.inject_initial_liquidity(sim.firms, mock_config)
+    Bootstrapper.force_assign_workers(sim.firms, sim.households)
 
     # We will manually trigger production to verify the bootstrapper's effect.
     firm = sim.firms[0]
