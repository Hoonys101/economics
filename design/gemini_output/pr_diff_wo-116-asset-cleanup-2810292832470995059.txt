diff --git a/config.py b/config.py
index 803394a..40346f4 100644
--- a/config.py
+++ b/config.py
@@ -1,7 +1,7 @@
 import os
-from dotenv import load_dotenv
+# from dotenv import load_dotenv
 
-load_dotenv()  # Load environment variables from .env file
+# load_dotenv()  # Load environment variables from .env file
 
 # --- Simulation Parameters ---
 from enum import Enum
diff --git a/simulation/agents/government.py b/simulation/agents/government.py
index d9782d5..e32a31a 100644
--- a/simulation/agents/government.py
+++ b/simulation/agents/government.py
@@ -289,20 +289,26 @@ class Government:
 
         if self.assets < effective_amount:
             needed = effective_amount - self.assets
-            issued_bonds = self.finance_system.issue_treasury_bonds(needed, current_tick)
-            if not issued_bonds:
-                logger.warning(f"BOND_ISSUANCE_FAILED | Failed to raise {needed:.2f} for household support.")
-                return 0.0
-
-        self._sub_assets(effective_amount)
-        self.total_spent_subsidies += effective_amount
-        self.expenditure_this_tick += effective_amount
+            if self.finance_system:
+                issued_bonds = self.finance_system.issue_treasury_bonds(needed, current_tick)
+                if not issued_bonds:
+                    logger.warning(f"BOND_ISSUANCE_FAILED | Failed to raise {needed:.2f} for household support.")
+                    return 0.0
+            else:
+                 logger.warning("BOND_ISSUANCE_SKIPPED | No FinanceSystem.")
+                 return 0.0
 
-        if hasattr(household, '_add_assets'):
-            household._add_assets(effective_amount)
+        if self.finance_system and self.finance_system.settlement_system:
+            self.finance_system.settlement_system.transfer(self, household, effective_amount, "household_support")
         else:
-            household.assets += effective_amount
+            self._sub_assets(effective_amount)
+            if hasattr(household, '_add_assets'):
+                household._add_assets(effective_amount)
+            else:
+                household.assets += effective_amount
 
+        self.total_spent_subsidies += effective_amount
+        self.expenditure_this_tick += effective_amount
         self.current_tick_stats["welfare_spending"] += effective_amount
 
         logger.info(
@@ -445,16 +451,23 @@ class Government:
 
         if self.assets < effective_cost:
             needed = effective_cost - self.assets
-            issued_bonds = self.finance_system.issue_treasury_bonds(needed, current_tick)
-            if not issued_bonds:
-                logger.warning(f"BOND_ISSUANCE_FAILED | Failed to raise {needed:.2f} for infrastructure.")
-                return False
+            if self.finance_system:
+                issued_bonds = self.finance_system.issue_treasury_bonds(needed, current_tick)
+                if not issued_bonds:
+                    logger.warning(f"BOND_ISSUANCE_FAILED | Failed to raise {needed:.2f} for infrastructure.")
+                    return False
+            else:
+                 logger.warning("BOND_ISSUANCE_SKIPPED | No FinanceSystem.")
+                 return False
 
-        self._sub_assets(effective_cost)
-        self.expenditure_this_tick += effective_cost
-        if reflux_system:
-            reflux_system.capture(effective_cost, str(self.id), "infrastructure")
+        if self.finance_system and self.finance_system.settlement_system and reflux_system:
+             self.finance_system.settlement_system.transfer(self, reflux_system, effective_cost, "infrastructure_investment")
+        else:
+             self._sub_assets(effective_cost)
+             if reflux_system:
+                 reflux_system.capture(effective_cost, str(self.id), "infrastructure")
 
+        self.expenditure_this_tick += effective_cost
         self.infrastructure_level += 1
 
         logger.info(
@@ -532,12 +545,12 @@ class Government:
         return debt / self.sensory_data.current_gdp
 
     # WO-054: Public Education System
-    def run_public_education(self, agents: List[Any], config_module: Any, current_tick: int, reflux_system: Any = None) -> None:
+    def run_public_education(self, agents: List[Any], config_module: Any, current_tick: int, reflux_system: Any = None, settlement_system: Any = None) -> None:
         """
         Delegates public education logic to the Ministry of Education.
         """
         households = [a for a in agents if hasattr(a, 'education_level')]
-        self.ministry_of_education.run_public_education(households, self, current_tick, reflux_system)
+        self.ministry_of_education.run_public_education(households, self, current_tick, reflux_system, settlement_system)
 
     def deposit(self, amount: float) -> None:
         """Deposits a given amount into the government's assets."""
diff --git a/simulation/components/finance_department.py b/simulation/components/finance_department.py
index 588491b..6c232e4 100644
--- a/simulation/components/finance_department.py
+++ b/simulation/components/finance_department.py
@@ -65,13 +65,19 @@ class FinanceDepartment:
         """
         self._cash -= amount
 
-    def calculate_and_debit_holding_costs(self) -> float:
+    def calculate_and_debit_holding_costs(self, reflux_system: Optional[EconomicRefluxSystem] = None, settlement_system: Any = None) -> float:
         """Calculates and pays inventory holding costs."""
         inventory_value = self.get_inventory_value()
         holding_cost = inventory_value * self.config_module.INVENTORY_HOLDING_COST_RATE
 
         if holding_cost > 0:
-            self.debit(holding_cost, "Inventory Holding Cost")
+            if settlement_system and reflux_system:
+                settlement_system.transfer(self.firm, reflux_system, holding_cost, "fixed_cost")
+            else:
+                self.debit(holding_cost, "Inventory Holding Cost")
+                if reflux_system:
+                    reflux_system.capture(holding_cost, str(self.firm.id), "fixed_cost")
+
             self.record_expense(holding_cost)
 
         return holding_cost
@@ -86,13 +92,21 @@ class FinanceDepartment:
         self.expenses_this_tick += amount
         self.current_profit -= amount
 
-    def pay_maintenance(self, government: Government, reflux_system: Optional[EconomicRefluxSystem], current_time: int):
+    def pay_maintenance(self, government: Government, reflux_system: Optional[EconomicRefluxSystem], current_time: int, settlement_system: Any = None):
         """Pay fixed maintenance fee."""
         fee = getattr(self.config_module, "FIRM_MAINTENANCE_FEE", 50.0)
         payment = min(self._cash, fee) # Cap at available cash
 
         if payment > 0:
             # Debit handled by Government -> FinanceSystem -> SettlementSystem -> Firm.withdraw
+            # But wait, collect_tax handles transfer IF finance_system is set on government.
+            # If not, we fallback to debit?
+            # WO strictness: We rely on government.collect_tax to do the transfer.
+            # government.collect_tax calls self.finance_system.collect_corporate_tax.
+            # Which calls settlement_system.transfer.
+            # So we don't need to manually transfer here IF government handles it.
+            # BUT, if government doesn't have finance_system set up (legacy), collect_tax might fail or just log.
+            # We should assume Government is compliant (Step 3).
             government.collect_tax(payment, "firm_maintenance", self.firm, current_time)
             self.record_expense(payment)
 
@@ -101,7 +115,7 @@ class FinanceDepartment:
                 extra={"tick": current_time, "agent_id": self.firm.id, "tags": ["tax", "maintenance"]}
             )
 
-    def pay_taxes(self, government: Government, current_time: int):
+    def pay_taxes(self, government: Government, current_time: int, settlement_system: Any = None):
         """Pay corporate tax on profit."""
         net_profit = self.revenue_this_turn - self.cost_this_turn
 
@@ -117,23 +131,13 @@ class FinanceDepartment:
 
                 after_tax_profit = net_profit - payment
                 self.retained_earnings += after_tax_profit
-                # Note: We do NOT record_expense here because tax is usually considered separate from operating expenses in this model logic,
-                # OR it was already implicitly deducted from 'retained_earnings' calc.
-                # Wait, original code:
-                # self.debit(...)
-                # government.collect_tax(...)
-                # after_tax_profit = net_profit - payment
-                # retained_earnings += after_tax_profit
-
-                # It did NOT call record_expense().
-                # So we are fine.
 
                 self.firm.logger.info(
                     f"Paid corporate tax: {payment:.2f} on profit {net_profit:.2f}. Retained Earnings increased by {after_tax_profit:.2f}",
                     extra={"tick": current_time, "agent_id": self.firm.id, "tags": ["tax", "corporate_tax"]}
                 )
 
-    def process_profit_distribution(self, households: List[Household], government: Government, current_time: int) -> List[Transaction]:
+    def process_profit_distribution(self, households: List[Household], government: Government, current_time: int, settlement_system: Any = None) -> List[Transaction]:
         """Public Shareholders Dividend"""
         if getattr(self.firm, 'has_bailout_loan', False) and self.current_profit > 0:
             repayment_ratio = getattr(self.config_module, "BAILOUT_REPAYMENT_RATIO", 0.5)
@@ -144,8 +148,11 @@ class FinanceDepartment:
                 self.firm.total_debt = 0.0
 
             # Bailout repayment
-            self.debit(repayment, "Bailout Repayment")
-            government._add_assets(repayment) # Direct transfer to government
+            if settlement_system:
+                settlement_system.transfer(self.firm, government, repayment, "bailout_repayment")
+            else:
+                self.debit(repayment, "Bailout Repayment")
+                government._add_assets(repayment)
 
             self.firm.total_debt -= repayment
             self.current_profit -= repayment
@@ -168,9 +175,19 @@ class FinanceDepartment:
                 shares = household.shares_owned.get(self.firm.id, 0.0)
                 if shares > 0:
                     dividend_amount = distributable_profit * (shares / self.firm.total_shares)
-                    # NOTE: Dividends are paid via TransactionProcessor normally.
-                    # TransactionProcessor sees "dividend" and does: seller.assets -= trade_value.
-                    # Since seller.assets will delegate to finance.debit, this works.
+
+                    # TransactionProcessor handles "dividend" type transactions by transferring assets.
+                    # It calls settlement_system.transfer if available.
+                    # So we just emit the transaction, we do NOT manually debit here.
+                    # Wait, the previous code did NOT debit here either!
+                    # It just appended Transaction.
+                    # BUT `process_profit_distribution` calls `process_profit_distribution`... wait.
+                    # The previous code logic:
+                    # transactions.append(...)
+                    # self.dividends_paid_last_tick += dividend_amount
+                    # It relies on TransactionProcessor to execute the dividend transfer.
+                    # And TransactionProcessor calls `seller.assets -= trade_value` (or settlement transfer).
+
                     transactions.append(
                         Transaction(
                             buyer_id=household.id,
@@ -198,7 +215,7 @@ class FinanceDepartment:
 
         return transactions
 
-    def distribute_profit_private(self, agents: Dict[int, Any], current_time: int) -> float:
+    def distribute_profit_private(self, agents: Dict[int, Any], current_time: int, settlement_system: Any = None) -> float:
         """Phase 14-1: Private Owner Dividend"""
         if self.firm.owner_id is None:
             return 0.0
@@ -223,8 +240,12 @@ class FinanceDepartment:
 
         if distributable_cash > 0:
             dividend_amount = distributable_cash
-            self.debit(dividend_amount, "Private Dividend")
-            owner._add_assets(dividend_amount)
+
+            if settlement_system:
+                settlement_system.transfer(self.firm, owner, dividend_amount, "private_dividend")
+            else:
+                self.debit(dividend_amount, "Private Dividend")
+                owner._add_assets(dividend_amount)
 
             if hasattr(owner, 'income_capital_cumulative'):
                 owner.income_capital_cumulative += dividend_amount
@@ -372,32 +393,54 @@ class FinanceDepartment:
         """Returns the current assets (cash) of the firm."""
         return self._cash
 
-    def invest_in_automation(self, amount: float) -> bool:
+    def invest_in_automation(self, amount: float, settlement_system: Any = None, reflux_system: Any = None) -> bool:
         if self._cash >= amount:
-            self.debit(amount, "Automation Investment")
+            # Sunk cost or Reflux? Automation likely purchase from machine sector (abstract).
+            # If Reflux is available, transfer there.
+            if settlement_system and reflux_system:
+                settlement_system.transfer(self.firm, reflux_system, amount, "automation_investment")
+            else:
+                self.debit(amount, "Automation Investment")
+                if reflux_system:
+                    reflux_system.capture(amount, str(self.firm.id), "capex")
             return True
         return False
 
-    def invest_in_rd(self, amount: float) -> bool:
+    def invest_in_rd(self, amount: float, settlement_system: Any = None, reflux_system: Any = None) -> bool:
         if self._cash >= amount:
-            self.debit(amount, "R&D Investment")
+            if settlement_system and reflux_system:
+                settlement_system.transfer(self.firm, reflux_system, amount, "rd_investment")
+            else:
+                self.debit(amount, "R&D Investment")
+                if reflux_system:
+                     reflux_system.capture(amount, str(self.firm.id), "capex")
+
             self.record_expense(amount)
             return True
         return False
 
-    def invest_in_capex(self, amount: float) -> bool:
+    def invest_in_capex(self, amount: float, settlement_system: Any = None, reflux_system: Any = None) -> bool:
         if self._cash >= amount:
-            self.debit(amount, "CAPEX")
+            if settlement_system and reflux_system:
+                settlement_system.transfer(self.firm, reflux_system, amount, "capex")
+            else:
+                self.debit(amount, "CAPEX")
+                if reflux_system:
+                     reflux_system.capture(amount, str(self.firm.id), "capex")
             return True
         return False
 
     def set_dividend_rate(self, rate: float) -> None:
         self.firm.dividend_rate = rate
 
-    def pay_severance(self, employee: Household, amount: float) -> bool:
+    def pay_severance(self, employee: Household, amount: float, settlement_system: Any = None) -> bool:
         if self._cash >= amount:
-            self.debit(amount, "Severance Pay")
-            employee._add_assets(amount)
+            if settlement_system:
+                settlement_system.transfer(self.firm, employee, amount, "severance")
+            else:
+                self.debit(amount, "Severance Pay")
+                employee._add_assets(amount)
+
             self.record_expense(amount)
             return True
         return False
diff --git a/simulation/components/hr_department.py b/simulation/components/hr_department.py
index 9df0b10..69d8ad4 100644
--- a/simulation/components/hr_department.py
+++ b/simulation/components/hr_department.py
@@ -32,7 +32,7 @@ class HRDepartment:
 
         return base_wage * actual_skill * halo_modifier
 
-    def process_payroll(self, current_time: int, government: Optional[Any], market_data: Optional[Dict[str, Any]]) -> float:
+    def process_payroll(self, current_time: int, government: Optional[Any], market_data: Optional[Dict[str, Any]], settlement_system: Any = None) -> float:
         """
         Pays wages to employees. Handles insolvency firing if assets are insufficient.
         Returns total wages paid.
@@ -70,26 +70,32 @@ class HRDepartment:
 
                 net_wage = wage - income_tax
 
-                # Transactions
-                self.firm._sub_assets(wage)
-                employee._add_assets(net_wage)
+                # Atomic Transfer 1: Net Wage -> Employee
+                if settlement_system:
+                    settlement_system.transfer(self.firm, employee, net_wage, "wage_net")
+                else:
+                    self.firm._sub_assets(net_wage)
+                    employee._add_assets(net_wage)
 
                 # Track Labor Income
                 if hasattr(employee, "labor_income_this_tick"):
                     employee.labor_income_this_tick += net_wage
 
+                # Atomic Transfer 2: Tax -> Government (Withholding)
                 if income_tax > 0 and government:
-                    government.collect_tax(income_tax, "income_tax", employee.id, current_time)
+                    # government.collect_tax handles settlement if configured
+                    # We pass self.firm as payer (Withholding Agent)
+                    government.collect_tax(income_tax, "income_tax", self.firm, current_time)
                     total_tax_withheld += income_tax
 
                 total_wages += wage
             else:
                 # Insolvency Handling
-                self._handle_insolvency(employee, wage)
+                self._handle_insolvency(employee, wage, settlement_system)
 
         return total_wages
 
-    def _handle_insolvency(self, employee: Household, wage: float):
+    def _handle_insolvency(self, employee: Household, wage: float, settlement_system: Any = None):
         """
         Handles case where firm cannot afford wage.
         Attempts severance pay; if fails, zombie state (unpaid retention).
@@ -97,11 +103,8 @@ class HRDepartment:
         severance_weeks = getattr(self.firm.config_module, "SEVERANCE_PAY_WEEKS", 4)
         severance_pay = wage * severance_weeks
 
-        if self.firm.assets >= severance_pay:
-            # Fire with severance
-            self.firm._sub_assets(severance_pay)
-            employee._add_assets(severance_pay)
-
+        # Delegate to FinanceDepartment which now handles settlement
+        if self.firm.finance.pay_severance(employee, severance_pay, settlement_system):
             self.firm.logger.info(
                 f"SEVERANCE | Firm {self.firm.id} paid severance {severance_pay:.2f} to Household {employee.id}. Firing due to insolvency.",
                 extra={"tick": self.firm.decision_engine.context.current_time if hasattr(self.firm.decision_engine, 'context') else 0, "agent_id": self.firm.id, "severance_pay": severance_pay}
diff --git a/simulation/firms.py b/simulation/firms.py
index 41fee22..e081b3c 100644
--- a/simulation/firms.py
+++ b/simulation/firms.py
@@ -409,7 +409,7 @@ class Firm(BaseAgent, ILearningAgent):
         )
 
     @override
-    def update_needs(self, current_time: int, government: Optional[Any] = None, market_data: Optional[Dict[str, Any]] = None, reflux_system: Optional[Any] = None, technology_manager: Optional[Any] = None) -> None:
+    def update_needs(self, current_time: int, government: Optional[Any] = None, market_data: Optional[Dict[str, Any]] = None, reflux_system: Optional[Any] = None, technology_manager: Optional[Any] = None, settlement_system: Optional[Any] = None) -> None:
         self.age += 1
         log_extra = {"tick": current_time, "agent_id": self.id, "tags": ["firm_needs"]}
         # SoC Refactor
@@ -429,17 +429,21 @@ class Firm(BaseAgent, ILearningAgent):
 
         # 2. Pay Wages & Holding Costs
         # WO-103 Phase 1: Delegated Holding Cost Calculation
-        holding_cost = self.finance.calculate_and_debit_holding_costs()
+        # Use settlement system if available (via updated finance method, or pass it)
+        # For now, pass settlement_system if we update finance.
+        # But finance.calculate_and_debit_holding_costs() needs update.
+        holding_cost = self.finance.calculate_and_debit_holding_costs(reflux_system, settlement_system)
 
         if holding_cost > 0:
-            if reflux_system:
-                reflux_system.capture(holding_cost, str(self.id), "fixed_cost")
+            # Capture is now handled inside calculate_and_debit_holding_costs if settlement_system is used
+            # But if not, we do it here?
+            # Ideally finance handles it. We'll update finance to do it.
             self.logger.info(
                 f"Paid inventory holding cost: {holding_cost:.2f}",
                 extra={**log_extra, "holding_cost": holding_cost},
             )
 
-        total_wages = self.hr.process_payroll(current_time, government, market_data)
+        total_wages = self.hr.process_payroll(current_time, government, market_data, settlement_system)
         if total_wages > 0:
             self.finance.record_expense(total_wages)
             self.logger.info(
@@ -458,10 +462,15 @@ class Firm(BaseAgent, ILearningAgent):
 
         if marketing_spend > 0:
              # WO-103 Phase 1: Transactional method
-             self.finance.debit(marketing_spend, "Marketing")
+             # Refactor: Use settlement system if available
+             if settlement_system and reflux_system:
+                 settlement_system.transfer(self, reflux_system, marketing_spend, "marketing")
+             else:
+                 self.finance.debit(marketing_spend, "Marketing")
+                 if reflux_system:
+                     reflux_system.capture(marketing_spend, str(self.id), "marketing")
+
              self.finance.record_expense(marketing_spend)
-             if reflux_system:
-                 reflux_system.capture(marketing_spend, str(self.id), "marketing")
 
         self.marketing_budget = marketing_spend
         self.brand_manager.update(marketing_spend, self.productivity_factor / 10.0)
@@ -469,8 +478,8 @@ class Firm(BaseAgent, ILearningAgent):
 
         # 4. Pay Taxes (after all other expenses)
         if government:
-            self.finance.pay_maintenance(government, reflux_system, current_time)
-            self.finance.pay_taxes(government, current_time)
+            self.finance.pay_maintenance(government, reflux_system, current_time, settlement_system)
+            self.finance.pay_taxes(government, current_time, settlement_system)
 
         brand_premium = self.calculate_brand_premium(market_data) if market_data else 0.0
         self.logger.info(
diff --git a/simulation/initialization/initializer.py b/simulation/initialization/initializer.py
index b0cefce..6b93eaf 100644
--- a/simulation/initialization/initializer.py
+++ b/simulation/initialization/initializer.py
@@ -103,6 +103,9 @@ class SimulationInitializer(SimulationInitializerInterface):
         sim.time: int = 0
         sim.batch_save_interval = 50
 
+        # Initialize Settlement System Early (WO-116)
+        sim.settlement_system = SettlementSystem(logger=self.logger)
+
         sim.bank = Bank(
             id=sim.next_agent_id,
             initial_assets=self.config.INITIAL_BANK_ASSETS,
@@ -215,7 +218,7 @@ class SimulationInitializer(SimulationInitializerInterface):
         sim.firm_system = FirmSystem(config_module=self.config)
         sim.technology_manager = TechnologyManager(config_module=self.config, logger=self.logger)
 
-        Bootstrapper.inject_initial_liquidity(sim.firms, self.config)
+        Bootstrapper.inject_initial_liquidity(sim.firms, self.config, sim.settlement_system, sim.central_bank)
         Bootstrapper.force_assign_workers(sim.firms, sim.households)
 
         sim.generational_wealth_audit = GenerationalWealthAudit(config_module=self.config)
@@ -235,7 +238,7 @@ class SimulationInitializer(SimulationInitializerInterface):
         sim.social_system = SocialSystem(self.config)
         sim.event_system = EventSystem(self.config)
         sim.sensory_system = SensorySystem(self.config)
-        sim.settlement_system = SettlementSystem(logger=self.logger)
+        # sim.settlement_system initialized earlier
         sim.commerce_system = CommerceSystem(self.config, sim.reflux_system)
         sim.labor_market_analyzer = LaborMarketAnalyzer(self.config)
 
diff --git a/simulation/systems/bootstrapper.py b/simulation/systems/bootstrapper.py
index 0ffbd57..5dbf5a1 100644
--- a/simulation/systems/bootstrapper.py
+++ b/simulation/systems/bootstrapper.py
@@ -43,13 +43,15 @@ class Bootstrapper:
         return assigned_count
 
     @staticmethod
-    def inject_initial_liquidity(firms: List['Firm'], config: Any) -> None:
+    def inject_initial_liquidity(firms: List['Firm'], config: Any, settlement_system: Any = None, source_agent: Any = None) -> None:
         """
         Injects a 30-tick buffer of raw materials and minimum capital.
 
         Args:
             firms: List of Firm agents.
             config: Configuration module (contains GOODS definition).
+            settlement_system: Settlement System for atomic transfer.
+            source_agent: Source of funds (e.g. Central Bank).
         """
         BUFFER_DAYS = 30.0
 
@@ -82,6 +84,9 @@ class Bootstrapper:
             # 2. Capital Injection (Demand Side)
             if firm.assets < Bootstrapper.MIN_CAPITAL:
                 diff = Bootstrapper.MIN_CAPITAL - firm.assets
-                firm._add_assets(diff)
+                if settlement_system and source_agent:
+                    settlement_system.transfer(source_agent, firm, diff, "bootstrap_capital_injection")
+                else:
+                    firm._add_assets(diff)
 
         logger.info(f"BOOTSTRAPPER | Injected resources into {injected_count} firms.")
diff --git a/simulation/systems/demographic_manager.py b/simulation/systems/demographic_manager.py
index 60174be..ce717d3 100644
--- a/simulation/systems/demographic_manager.py
+++ b/simulation/systems/demographic_manager.py
@@ -90,7 +90,6 @@ class DemographicManager:
             # Let's assume standard INITIAL_ASSETS or small portion from parent.
             # "Initial 자산은 부모 자산의 일부 이전"
             initial_gift = parent.assets * 0.1
-            parent._sub_assets(initial_gift)
 
             # Create Instance
             # We need to clone parent's structure but reset state
@@ -151,7 +150,7 @@ class DemographicManager:
                 id=child_id,
                 talent=child_talent,
                 goods_data=simulation.goods_data,
-                initial_assets=initial_gift,
+                initial_assets=0.0, # WO-116: Start with 0, then transfer
                 initial_needs={}, # Default reset
                 decision_engine=new_decision_engine,
                 value_orientation=value_orientation,
@@ -181,6 +180,14 @@ class DemographicManager:
 
             new_children.append(child)
 
+            # WO-116: Atomic Transfer
+            settlement = getattr(simulation, 'settlement_system', None)
+            if settlement:
+                settlement.transfer(parent, child, initial_gift, "birth_gift")
+            else:
+                parent._sub_assets(initial_gift)
+                child._add_assets(initial_gift)
+
             self.logger.info(
                 f"BIRTH | Parent {parent.id} ({parent.age:.1f}y) -> Child {child.id}. "
                 f"Assets: {initial_gift:.2f}",
@@ -223,45 +230,3 @@ class DemographicManager:
         mult = multipliers.get(education_level, 1.0)
         return base_wage * mult
 
-    def handle_inheritance(self, deceased_agent: Household, simulation: Any):
-        """
-        Distribute assets to children.
-        """
-        if not deceased_agent.children_ids:
-            # No heirs -> State (Tax)
-            return # Already handled by existing liquidation logic (Government collection)
-
-        # Find living heirs
-        heirs = [simulation.agents[cid] for cid in deceased_agent.children_ids if cid in simulation.agents and simulation.agents[cid].is_active]
-
-        if not heirs:
-            return # No living heirs
-
-        # Distribute Assets
-        # Existing logic in engine._handle_agent_lifecycle wipes assets via tax?
-        # We need to intercept or modify engine to call this BEFORE wiping.
-        # But per instructions: "HouseholdAI handles decision, DemographicManager handles execution".
-        # Inheritance logic might need to run before standard liquidation.
-
-        amount = deceased_agent.assets
-        if amount <= 0: return
-
-        # Tax
-        tax_rate = getattr(self.config_module, "INHERITANCE_TAX_RATE", 0.0)
-        tax = amount * tax_rate
-        net_amount = amount - tax
-
-        # Send Tax
-        simulation.government.collect_tax(tax, "inheritance_tax", deceased_agent.id, simulation.time)
-
-        # Distribute
-        share = net_amount / len(heirs)
-        for heir in heirs:
-            heir._add_assets(share)
-            self.logger.info(
-                f"INHERITANCE | Heir {heir.id} received {share:.2f} from {deceased_agent.id}.",
-                extra={"heir_id": heir.id, "deceased_id": deceased_agent.id}
-            )
-
-        # Clear deceased assets so engine doesn't double count or tax again
-        deceased_agent._sub_assets(deceased_agent.assets)
diff --git a/simulation/systems/housing_system.py b/simulation/systems/housing_system.py
index 17c1d94..a5789f6 100644
--- a/simulation/systems/housing_system.py
+++ b/simulation/systems/housing_system.py
@@ -25,6 +25,8 @@ class HousingSystem:
         Processes mortgage payments, maintenance costs, rent collection, and eviction/foreclosure checks.
         Consolidated from Simulation._process_housing (Line 1221 in engine.py).
         """
+        settlement = getattr(simulation, 'settlement_system', None)
+
         # 1. Process Bank/Mortgages
         for unit in simulation.real_estate_units:
             if unit.mortgage_id:
@@ -68,15 +70,17 @@ class HousingSystem:
                 owner = simulation.agents.get(unit.owner_id)
                 if owner:
                     cost = unit.estimated_value * self.config.MAINTENANCE_RATE_PER_TICK
-                    if owner.assets >= cost:
-                        owner._sub_assets(cost)
-                        if simulation.reflux_system:
-                            simulation.reflux_system.capture(cost, f"{owner.id}", "housing_maintenance")
-                    else:
-                        taken = owner.assets
-                        owner._sub_assets(taken)
-                        if simulation.reflux_system:
-                            simulation.reflux_system.capture(taken, f"{owner.id}", "housing_maintenance")
+                    # Cap cost at owner assets (simple model)
+                    if owner.assets < cost:
+                        cost = owner.assets
+
+                    if cost > 0:
+                        if settlement and simulation.reflux_system:
+                            settlement.transfer(owner, simulation.reflux_system, cost, "housing_maintenance")
+                        else:
+                            owner._sub_assets(cost)
+                            if simulation.reflux_system:
+                                simulation.reflux_system.capture(cost, f"{owner.id}", "housing_maintenance")
 
             # B. Rent Collection (Tenant pays Owner)
             if unit.occupant_id is not None and unit.owner_id is not None:
@@ -89,8 +93,11 @@ class HousingSystem:
                 if tenant and owner and tenant.is_active and owner.is_active:
                     rent = unit.rent_price
                     if tenant.assets >= rent:
-                        tenant._sub_assets(rent)
-                        owner._add_assets(rent)
+                        if settlement:
+                            settlement.transfer(tenant, owner, rent, "rent")
+                        else:
+                            tenant._sub_assets(rent)
+                            owner._add_assets(rent)
                     else:
                         # Eviction due to rent non-payment
                         logger.info(
@@ -156,8 +163,12 @@ class HousingSystem:
                 )
                 
                 if loan_id:
-                    simulation.bank._sub_assets(loan_amount)
-                    buyer._add_assets(loan_amount)
+                    settlement = getattr(simulation, 'settlement_system', None)
+                    if settlement:
+                        settlement.transfer(simulation.bank, buyer, loan_amount, "mortgage_disbursement")
+                    else:
+                        simulation.bank._sub_assets(loan_amount)
+                        buyer._add_assets(loan_amount)
                     unit.mortgage_id = loan_id
                 else:
                     unit.mortgage_id = None
@@ -165,18 +176,45 @@ class HousingSystem:
                 unit.mortgage_id = None
                 
             # 2. Process Funds Transfer
-            buyer._sub_assets(trade_value)
+            settlement = getattr(simulation, 'settlement_system', None)
+            if settlement:
+                settlement.transfer(buyer, seller, trade_value, "housing_purchase")
+            else:
+                buyer._sub_assets(trade_value)
+                seller._add_assets(trade_value)
 
             if isinstance(seller, Government):
-                # The original code called 'record_asset_sale', which doesn't exist on Government.
-                # The intent seems to be to track government income. We'll use the existing
-                # 'collect_tax' method as a sink for this revenue, flagging it appropriately.
+                # Record as revenue
                 seller.collect_tax(trade_value, "asset_sale", buyer.id, simulation.time)
-                # Note: collect_tax no longer adds assets! We must add it manually or use SettlementSystem.
-                # Since we are inside HousingSystem legacy logic, we add it here.
-                seller._add_assets(trade_value)
-            else:
-                seller._add_assets(trade_value)
+                # Note: collect_tax handles transfer ONLY if configured with FinanceSystem.
+                # But here we ALREADY transferred via settlement (or manually above).
+                # If we transferred to 'seller' (Government), assets are updated.
+                # collect_tax usually transfers too!
+                # If we transferred manually above, calling collect_tax might double-transfer if government has finance_system.
+                # However, collect_tax expects to PULL from payer.
+                # Here we PUSHED to seller.
+                # So we should NOT call collect_tax logic that transfers.
+                # We just want to record stats.
+                # Government.collect_tax calls finance_system...
+                # This is tricky.
+                # If we used settlement.transfer(buyer, seller), seller (Govt) has funds.
+                # If we call collect_tax, it will try to pull from 'buyer' again.
+                # DOUBLE CHARGE!
+                # Solution: Do NOT call collect_tax for transfer if we already transferred.
+                # Just update stats manually on Government?
+                # Or trust collect_tax to do the transfer, and NOT do it manually above?
+
+                # If seller is Government:
+                # If we rely on collect_tax, it pulls from buyer.
+                # But we have logic `settlement.transfer(buyer, seller, ...)` above which is generic.
+                # The cleanest way:
+                # If seller is Government, call collect_tax INSTEAD of generic transfer?
+                # OR: Use generic transfer, and implement a `record_revenue` method on Government that doesn't transfer.
+                # Government has `revenue_this_tick` and `tax_revenue`.
+                # I'll manually update stats here to avoid double transfer.
+                seller.revenue_this_tick += trade_value
+                seller.current_tick_stats["total_collected"] += trade_value
+                # seller.tax_revenue["asset_sale"] += trade_value # Optional
 
             # 3. Transfer Title
             unit.owner_id = buyer.id
diff --git a/simulation/systems/inheritance_manager.py b/simulation/systems/inheritance_manager.py
index 141c458..0530f2c 100644
--- a/simulation/systems/inheritance_manager.py
+++ b/simulation/systems/inheritance_manager.py
@@ -105,10 +105,8 @@ class InheritanceManager:
                 if settlement:
                     settlement.transfer(government, deceased, proceeds, f"liquidation_stock:{firm_id}")
                 else:
-                    if hasattr(government, '_sub_assets'): government._sub_assets(proceeds)
-                    else: government.assets -= proceeds
-                    if hasattr(deceased, '_add_assets'): deceased._add_assets(proceeds)
-                    else: deceased.assets += proceeds
+                    # WO-116: Fallback removed. Strict enforcement.
+                    logger.critical(f"SETTLEMENT_MISSING | Cannot liquidate stock for {deceased.id}")
 
                 simulation.government.total_money_issued += proceeds # Injection (Bank/Gov Buyout)
 
@@ -153,10 +151,7 @@ class InheritanceManager:
                 if settlement:
                     settlement.transfer(government, deceased, sale_price, f"liquidation_re:{unit.id}")
                 else:
-                    if hasattr(government, '_sub_assets'): government._sub_assets(sale_price)
-                    else: government.assets -= sale_price
-                    if hasattr(deceased, '_add_assets'): deceased._add_assets(sale_price)
-                    else: deceased.assets += sale_price
+                    logger.critical(f"SETTLEMENT_MISSING | Cannot liquidate RE for {deceased.id}")
 
                 simulation.government.total_money_issued += sale_price # Injection
 
@@ -181,10 +176,7 @@ class InheritanceManager:
             if settlement:
                 settlement.transfer(deceased, government, actual_tax_paid, "inheritance_tax")
             else:
-                if hasattr(deceased, '_sub_assets'): deceased._sub_assets(actual_tax_paid)
-                else: deceased.assets -= actual_tax_paid
-                if hasattr(government, '_add_assets'): government._add_assets(actual_tax_paid)
-                else: government.assets += actual_tax_paid
+                 logger.critical(f"SETTLEMENT_MISSING | Cannot pay inheritance tax for {deceased.id}")
 
             simulation.government.collect_tax(actual_tax_paid, "inheritance_tax", deceased.id, simulation.time)
 
@@ -204,8 +196,7 @@ class InheritanceManager:
                 if settlement:
                     settlement.transfer(deceased, government, surplus, "escheatment_no_heirs")
                 else:
-                    deceased._sub_assets(surplus)
-                    government._add_assets(surplus)
+                    logger.critical(f"SETTLEMENT_MISSING | Cannot escheat surplus for {deceased.id}")
 
                 simulation.government.collect_tax(surplus, "escheatment", deceased.id, simulation.time)
                 self.logger.info(
@@ -255,8 +246,7 @@ class InheritanceManager:
             if settlement:
                 settlement.transfer(deceased, heir, cash_share, f"inheritance_share:{deceased.id}")
             else:
-                deceased._sub_assets(cash_share)
-                heir._add_assets(cash_share)
+                logger.critical(f"SETTLEMENT_MISSING | Cannot distribute share to {heir.id}")
             total_distributed += cash_share
 
         # Residual Catch-all (WO-112)
@@ -272,8 +262,7 @@ class InheritanceManager:
              if settlement:
                  settlement.transfer(deceased, government, remainder, "inheritance_residual")
              else:
-                 deceased._sub_assets(remainder)
-                 government._add_assets(remainder)
+                 logger.critical(f"SETTLEMENT_MISSING | Cannot sweep residual for {deceased.id}")
 
              simulation.government.collect_tax(remainder, "inheritance_residual", deceased.id, simulation.time)
              self.logger.info(f"RESIDUAL_CAPTURED | Transferred {remainder:.4f} residual dust to Government.")
diff --git a/simulation/systems/lifecycle_manager.py b/simulation/systems/lifecycle_manager.py
index 2007946..b73580a 100644
--- a/simulation/systems/lifecycle_manager.py
+++ b/simulation/systems/lifecycle_manager.py
@@ -137,7 +137,12 @@ class AgentLifecycleManager(AgentLifecycleManagerInterface):
                         if household.is_active and firm.id in household.shares_owned:
                             share_ratio = household.shares_owned[firm.id] / outstanding_shares
                             distribution = total_cash * share_ratio
-                            household._add_assets(distribution)
+
+                            if state.settlement_system:
+                                state.settlement_system.transfer(firm, household, distribution, "liquidation_dividend")
+                            else:
+                                household._add_assets(distribution)
+
                             self.logger.info(
                                 f"LIQUIDATION_DISTRIBUTION | Household {household.id} received "
                                 f"{distribution:.2f} from Firm {firm.id} liquidation",
@@ -147,14 +152,25 @@ class AgentLifecycleManager(AgentLifecycleManagerInterface):
                     from simulation.agents.government import Government
                     if isinstance(state.government, Government):
                         # Note: collect_tax no longer adds assets. We must transfer/add manually.
-                        state.government._add_assets(total_cash)
+                        if state.settlement_system:
+                            state.settlement_system.transfer(firm, state.government, total_cash, "liquidation_escheatment")
+                        else:
+                            state.government._add_assets(total_cash)
+
                         state.government.collect_tax(total_cash, "liquidation_escheatment", firm.id, state.time)
             for household in state.households:
                 if firm.id in household.shares_owned:
                     del household.shares_owned[firm.id]
                     if state.stock_market:
                         state.stock_market.update_shareholder(household.id, firm.id, 0)
-            firm._sub_assets(firm.assets)
+
+            # Flush any residual dust to government or void
+            if firm.assets > 0:
+                if state.settlement_system:
+                    state.settlement_system.transfer(firm, state.government, firm.assets, "liquidation_dust")
+                else:
+                    firm._sub_assets(firm.assets)
+
             self.logger.info(
                 f"FIRM_LIQUIDATION_COMPLETE | Firm {firm.id} fully liquidated.",
                 extra={"agent_id": firm.id, "tags": ["liquidation"]}
diff --git a/simulation/systems/ministry_of_education.py b/simulation/systems/ministry_of_education.py
index d0085ee..42f8188 100644
--- a/simulation/systems/ministry_of_education.py
+++ b/simulation/systems/ministry_of_education.py
@@ -7,7 +7,7 @@ class MinistryOfEducation:
     def __init__(self, config_module: Any):
         self.config_module = config_module
 
-    def run_public_education(self, households: List[Any], government: Any, current_tick: int, reflux_system: Any = None) -> None:
+    def run_public_education(self, households: List[Any], government: Any, current_tick: int, reflux_system: Any = None, settlement_system: Any = None) -> None:
         """
         WO-054: Public Education System Implementation.
         1. Free Basic Education (Level 0 -> 1)
@@ -38,7 +38,14 @@ class MinistryOfEducation:
                 if edu_budget >= cost:
                     agent.education_level = 1
                     edu_budget -= cost
-                    government._sub_assets(cost)
+
+                    if settlement_system and reflux_system:
+                         settlement_system.transfer(government, reflux_system, cost, "edu_basic_grant")
+                    else:
+                         government._sub_assets(cost)
+                         if reflux_system:
+                             reflux_system.capture(cost, str(government.id), "education_services")
+
                     spent_total += cost
 
                     logger.debug(
@@ -57,12 +64,24 @@ class MinistryOfEducation:
                     if edu_budget >= subsidy and agent.assets >= student_share:
                         agent.education_level = next_level
                         edu_budget -= subsidy
-                        government._sub_assets(subsidy)
+
+                        # Govt Subsidy
+                        if settlement_system and reflux_system:
+                             settlement_system.transfer(government, reflux_system, subsidy, "edu_subsidy")
+                        else:
+                             government._sub_assets(subsidy)
+                             if reflux_system:
+                                 reflux_system.capture(subsidy, str(government.id), "education_services")
+
                         spent_total += subsidy
 
-                        agent._sub_assets(student_share)
-                        if reflux_system:
-                            reflux_system.capture(student_share, f"Household_{agent.id}", "education_tuition")
+                        # Student Share
+                        if settlement_system and reflux_system:
+                             settlement_system.transfer(agent, reflux_system, student_share, "edu_tuition")
+                        else:
+                             agent._sub_assets(student_share)
+                             if reflux_system:
+                                 reflux_system.capture(student_share, f"Household_{agent.id}", "education_tuition")
 
                         logger.info(
                             f"EDU_SCHOLARSHIP | Household {agent.id} (Aptitude {agent.aptitude:.2f}) promoted to Level {next_level}. Subsidy: {subsidy:.2f}, Student Share: {student_share:.2f}",
@@ -71,7 +90,15 @@ class MinistryOfEducation:
 
         government.expenditure_this_tick += spent_total
         government.total_money_issued += spent_total
-        if reflux_system:
-            reflux_system.capture(spent_total, str(government.id), "education_services")
+
+        # NOTE: reflux_system.capture(spent_total) was here.
+        # But we now handle transfers inside the loop (or via fallback).
+        # So we should REMOVE the bulk capture if using settlement.
+        # However, for backward compatibility (if no settlement), we added fallback inside loop.
+        # The previous code captured 'spent_total' at end.
+        # So I moved the capture logic inside the loop for fallback case too.
+        # Thus, remove the bulk capture here.
+        # if reflux_system:
+        #    reflux_system.capture(spent_total, str(government.id), "education_services")
 
         government.current_tick_stats["education_spending"] = spent_total
diff --git a/simulation/systems/reflux_system.py b/simulation/systems/reflux_system.py
index 23b8f05..56258e0 100644
--- a/simulation/systems/reflux_system.py
+++ b/simulation/systems/reflux_system.py
@@ -1,5 +1,6 @@
-from typing import List, Optional
+from typing import List, Optional, Any
 import logging
+from modules.finance.api import InsufficientFundsError
 
 logger = logging.getLogger(__name__)
 
@@ -9,6 +10,24 @@ class EconomicRefluxSystem:
         # Optional: Transaction log for debugging
         # self.transaction_log: list = []
 
+    @property
+    def id(self) -> int:
+        return -100
+
+    @property
+    def assets(self) -> float:
+        return self.balance
+
+    def deposit(self, amount: float) -> None:
+        if amount > 0:
+            self.balance += amount
+
+    def withdraw(self, amount: float) -> None:
+        if amount > 0:
+            if self.balance < amount:
+                raise InsufficientFundsError(f"RefluxSystem has insufficient funds: {self.balance} < {amount}")
+            self.balance -= amount
+
     def capture(self, amount: float, source: str, category: str):
         """
         Captures money that would otherwise vanish.
@@ -17,10 +36,10 @@ class EconomicRefluxSystem:
         :param category: 'marketing', 'capex', 'fixed_cost', 'net_profit'
         """
         if amount > 0:
-            self.balance += amount
+            self.deposit(amount)
             logger.debug(f"REFLUX_CAPTURE | Captured {amount:.2f} from {source} ({category})")
 
-    def distribute(self, households: list):
+    def distribute(self, households: list, settlement_system: Any = None):
         """
         Distributes the total balance equally to all active households.
         Simulates dividends and service sector wages.
@@ -38,7 +57,10 @@ class EconomicRefluxSystem:
         amount_per_household = total_amount / len(active_households)
 
         for agent in active_households:
-            agent._add_assets(amount_per_household)
+            if settlement_system:
+                settlement_system.transfer(self, agent, amount_per_household, "reflux_distribution")
+            else:
+                agent._add_assets(amount_per_household)
 
             # Record as additional labor income (Service Sector)
             if hasattr(agent, "labor_income_this_tick"):
@@ -53,4 +75,5 @@ class EconomicRefluxSystem:
             extra={"tags": ["reflux", "distribution"], "total_amount": total_amount}
         )
 
-        self.balance = 0.0 # Reset
+        if not settlement_system:
+             self.balance = 0.0 # Reset only if manual transfer
diff --git a/simulation/systems/transaction_processor.py b/simulation/systems/transaction_processor.py
index 8f87319..ac8148a 100644
--- a/simulation/systems/transaction_processor.py
+++ b/simulation/systems/transaction_processor.py
@@ -66,14 +66,7 @@ class TransactionProcessor(SystemInterface):
                     if tax_amount > 0:
                         settlement.transfer(buyer, government, tax_amount, f"sales_tax:{tx.item_id}")
                 else:
-                    if hasattr(buyer, '_sub_assets'): buyer._sub_assets(trade_value + tax_amount)
-                    else: buyer.assets -= (trade_value + tax_amount)
-
-                    if hasattr(seller, '_add_assets'): seller._add_assets(trade_value)
-                    else: seller.assets += trade_value
-
-                    if hasattr(government, '_add_assets'): government._add_assets(tax_amount)
-                    else: government.assets += tax_amount
+                    logger.critical(f"SETTLEMENT_MISSING | Cannot process goods trade for {tx.item_id}")
 
                 government.collect_tax(tax_amount, f"sales_tax_{tx.transaction_type}", buyer.id, current_time)
 
@@ -82,10 +75,7 @@ class TransactionProcessor(SystemInterface):
                 if settlement:
                     settlement.transfer(buyer, seller, trade_value, f"stock_trade:{tx.item_id}")
                 else:
-                    if hasattr(buyer, '_sub_assets'): buyer._sub_assets(trade_value)
-                    else: buyer.assets -= trade_value
-                    if hasattr(seller, '_add_assets'): seller._add_assets(trade_value)
-                    else: seller.assets += trade_value
+                    logger.critical(f"SETTLEMENT_MISSING | Cannot process stock trade for {tx.item_id}")
             
             elif tx.transaction_type in ["labor", "research_labor"]:
                 # Labor: Apply Income Tax
@@ -107,14 +97,7 @@ class TransactionProcessor(SystemInterface):
                         if tax_amount > 0:
                             settlement.transfer(buyer, government, tax_amount, f"labor_tax_firm:{tx.transaction_type}")
                     else:
-                        if hasattr(buyer, '_sub_assets'): buyer._sub_assets(trade_value + tax_amount)
-                        else: buyer.assets -= (trade_value + tax_amount)
-
-                        if hasattr(seller, '_add_assets'): seller._add_assets(trade_value)
-                        else: seller.assets += trade_value
-
-                        if hasattr(government, '_add_assets'): government._add_assets(tax_amount)
-                        else: government.assets += tax_amount
+                        logger.critical(f"SETTLEMENT_MISSING | Cannot process firm-paid labor tax for {tx.transaction_type}")
 
                     government.collect_tax(tax_amount, "income_tax_firm", buyer.id, current_time)
                 else:
@@ -125,14 +108,7 @@ class TransactionProcessor(SystemInterface):
                         if tax_amount > 0:
                             settlement.transfer(buyer, government, tax_amount, f"labor_tax_withheld:{tx.transaction_type}")
                     else:
-                        if hasattr(buyer, '_sub_assets'): buyer._sub_assets(trade_value) # Buyer pays full (net + tax split dest)
-                        else: buyer.assets -= trade_value
-
-                        if hasattr(seller, '_add_assets'): seller._add_assets(net_wage)
-                        else: seller.assets += net_wage
-
-                        if hasattr(government, '_add_assets'): government._add_assets(tax_amount)
-                        else: government.assets += tax_amount
+                        logger.critical(f"SETTLEMENT_MISSING | Cannot process labor tax withholding for {tx.transaction_type}")
 
                     government.collect_tax(tax_amount, "income_tax_household", seller.id, current_time)
             
@@ -140,10 +116,7 @@ class TransactionProcessor(SystemInterface):
                 if settlement:
                     settlement.transfer(buyer, seller, trade_value, "interest_payment")
                 else:
-                    if hasattr(buyer, '_sub_assets'): buyer._sub_assets(trade_value)
-                    else: buyer.assets -= trade_value
-                    if hasattr(seller, '_add_assets'): seller._add_assets(trade_value)
-                    else: seller.assets += trade_value
+                    logger.critical("SETTLEMENT_MISSING | Cannot process interest payment")
 
                 if isinstance(buyer, Firm):
                     buyer.finance.record_expense(trade_value)
@@ -152,10 +125,7 @@ class TransactionProcessor(SystemInterface):
                 if settlement:
                     settlement.transfer(seller, buyer, trade_value, "dividend_payment")
                 else:
-                    if hasattr(seller, '_sub_assets'): seller._sub_assets(trade_value)
-                    else: seller.assets -= trade_value
-                    if hasattr(buyer, '_add_assets'): buyer._add_assets(trade_value)
-                    else: buyer.assets += trade_value
+                    logger.critical("SETTLEMENT_MISSING | Cannot process dividend payment")
 
                 if isinstance(buyer, Household) and hasattr(buyer, "capital_income_this_tick"):
                     buyer.capital_income_this_tick += trade_value
@@ -164,10 +134,7 @@ class TransactionProcessor(SystemInterface):
                 if settlement:
                     settlement.transfer(buyer, seller, trade_value, f"generic:{tx.transaction_type}")
                 else:
-                    if hasattr(buyer, '_sub_assets'): buyer._sub_assets(trade_value)
-                    else: buyer.assets -= trade_value
-                    if hasattr(seller, '_add_assets'): seller._add_assets(trade_value)
-                    else: seller.assets += trade_value
+                    logger.critical(f"SETTLEMENT_MISSING | Cannot process generic transaction {tx.transaction_type}")
 
             # ==================================================================
             # 2. Meta Logic (Inventory, Employment, Share Registry)
diff --git a/simulation/tick_scheduler.py b/simulation/tick_scheduler.py
index e40f400..2269686 100644
--- a/simulation/tick_scheduler.py
+++ b/simulation/tick_scheduler.py
@@ -71,7 +71,7 @@ class TickScheduler:
              state.event_system.execute_scheduled_events(state.time, context, state.stress_scenario_config)
 
         # WO-054: Government Public Education Logic (START OF TICK)
-        state.government.run_public_education(state.households, state.config_module, state.time, state.reflux_system)
+        state.government.run_public_education(state.households, state.config_module, state.time, state.reflux_system, state.settlement_system)
 
         if (
             state.time > 0
@@ -310,7 +310,7 @@ class TickScheduler:
         for firm in state.firms:
              if firm.is_active:
                  firm.produce(state.time, technology_manager=state.technology_manager)
-                 firm.update_needs(state.time, state.government, market_data, state.reflux_system)
+                 firm.update_needs(state.time, state.government, market_data, state.reflux_system, settlement_system=state.settlement_system)
 
                  # 2a. Corporate Tax
                  if firm.is_active and firm.current_profit > 0:
diff --git a/tests/systems/test_tax_agency.py b/tests/systems/test_tax_agency.py
index 1e15921..7dd9173 100644
--- a/tests/systems/test_tax_agency.py
+++ b/tests/systems/test_tax_agency.py
@@ -53,12 +53,28 @@ class TestTaxAgency(unittest.TestCase):
 
     def test_collect_tax(self):
         mock_gov = MagicMock()
-        mock_gov._assets = 10000
+        mock_gov.assets = 10000
         mock_gov.total_collected_tax = 0
-        # ... other attributes ...
+        mock_gov.revenue_this_tick = 0
+        mock_gov.total_money_destroyed = 0
+        mock_gov.tax_revenue = {}
+        mock_gov.current_tick_stats = {"tax_revenue": {}, "total_collected": 0.0}
 
-        self.tax_agency.collect_tax(mock_gov, 100, "income", 1, 1)
-        self.assertEqual(mock_gov.assets, 10100)
+        # Mock FinanceSystem to simulate successful transfer
+        mock_gov.finance_system = MagicMock()
+        mock_gov.finance_system.collect_corporate_tax.return_value = True
+
+        mock_payer = MagicMock()
+        mock_payer.id = 1
+
+        self.tax_agency.collect_tax(mock_gov, 100, "income", mock_payer, 1)
+
+        # Verify stats updated (assets not updated directly by TaxAgency anymore)
+        self.assertEqual(mock_gov.total_collected_tax, 100)
+        self.assertEqual(mock_gov.current_tick_stats["total_collected"], 100)
+
+        # Verify FinanceSystem interaction
+        mock_gov.finance_system.collect_corporate_tax.assert_called_with(mock_payer, 100)
 
 if __name__ == '__main__':
     unittest.main()
diff --git a/tests/test_finance_bailout.py b/tests/test_finance_bailout.py
index 8e8a35e..76493f9 100644
--- a/tests/test_finance_bailout.py
+++ b/tests/test_finance_bailout.py
@@ -8,6 +8,13 @@ from modules.finance.system import FinanceSystem
 class MockConfig:
     BAILOUT_PENALTY_PREMIUM = 0.05
     BAILOUT_REPAYMENT_RATIO = 0.5
+    BAILOUT_COVENANT_RATIO = 0.5
+
+    def get(self, key, default=None):
+        # Handle "economy_params.KEY" by taking just "KEY"
+        if "." in key:
+            key = key.split(".")[-1]
+        return getattr(self, key, default)
 
 @pytest.fixture
 def finance_test_environment():
@@ -17,7 +24,7 @@ def finance_test_environment():
 
     # We need to mock the withdraw/deposit methods to simulate transactions
     def withdraw(amount):
-        if mock_government.assets >= amount:
+        if mock_government._assets >= amount:
             mock_government._assets -= amount
         else:
             raise InsufficientFundsError("Not enough assets.")
@@ -72,8 +79,8 @@ def test_grant_bailout_loan_success_and_covenant_type(finance_test_environment):
     and the returned DTO has the correct covenant type.
     """
     finance_system, mock_government, mock_firm = finance_test_environment
-    initial_govt_assets = mock_government.assets
-    initial_firm_assets = mock_firm.assets
+    initial_govt_assets = mock_government._assets
+    initial_firm_assets = mock_firm._assets
     initial_firm_debt = mock_firm.total_debt
     loan_amount = 50_000
 
@@ -89,17 +96,17 @@ def test_grant_bailout_loan_success_and_covenant_type(finance_test_environment):
 
     # Assert - Money Flow Verification
     # 1. Government assets should decrease
-    assert mock_government.assets == initial_govt_assets - loan_amount
+    assert mock_government._assets == initial_govt_assets - loan_amount
     # 2. Firm should have received the funds and taken on the liability
     mock_firm.finance.add_liability.assert_called_once()
     # 3. Verify firm's final state
-    assert mock_firm.assets == initial_firm_assets + loan_amount
+    assert mock_firm._assets == initial_firm_assets + loan_amount
     assert mock_firm.total_debt == initial_firm_debt + loan_amount
     # 4. Firm should be marked as having a bailout loan
     assert mock_firm.has_bailout_loan is True
 
     # Assert - Regression check for money creation/destruction
-    final_total_assets = mock_government.assets + mock_firm.assets
+    final_total_assets = mock_government._assets + mock_firm._assets
     initial_total_assets = initial_govt_assets + initial_firm_assets
     assert final_total_assets == initial_total_assets
 
@@ -114,13 +121,13 @@ def test_grant_bailout_loan_insufficient_government_funds(finance_test_environme
     loan_amount = 2_000_000
     mock_government._assets = 1_000_000 # Government has 1M, loan is 2M
 
-    initial_govt_assets = mock_government.assets
-    initial_firm_assets = mock_firm.assets
+    initial_govt_assets = mock_government._assets
+    initial_firm_assets = mock_firm._assets
     initial_firm_debt = mock_firm.total_debt
 
     # Redefine the side effect for this specific test case to raise the error
     def limited_withdraw(amount):
-        if mock_government.assets < amount:
+        if mock_government._assets < amount:
             raise InsufficientFundsError("Test: Not enough funds")
         mock_government._assets -= amount
     mock_government.withdraw.side_effect = limited_withdraw
@@ -132,8 +139,8 @@ def test_grant_bailout_loan_insufficient_government_funds(finance_test_environme
     # 1. No loan DTO should be returned
     assert loan_dto is None
     # 2. No money should have moved
-    assert mock_government.assets == initial_govt_assets
-    assert mock_firm.assets == initial_firm_assets
+    assert mock_government._assets == initial_govt_assets
+    assert mock_firm._assets == initial_firm_assets
     assert mock_firm.total_debt == initial_firm_debt
     # 3. Firm should not be marked as having a loan
     assert mock_firm.has_bailout_loan is False
