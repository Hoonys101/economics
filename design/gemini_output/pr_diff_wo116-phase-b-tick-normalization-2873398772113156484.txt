diff --git a/modules/finance/system.py b/modules/finance/system.py
index 482b51a..98c4180 100644
--- a/modules/finance/system.py
+++ b/modules/finance/system.py
@@ -1,10 +1,11 @@
-from typing import List, Dict, Optional, Any
+from typing import List, Dict, Optional, Any, Tuple
 import logging
 from modules.finance.api import IFinanceSystem, BondDTO, BailoutLoanDTO, BailoutCovenant, IFinancialEntity, InsufficientFundsError
 from modules.finance.domain import AltmanZScoreCalculator
 from modules.analysis.fiscal_monitor import FiscalMonitor
 # Forward reference for type hinting
 from simulation.firms import Firm
+from simulation.models import Transaction
 
 logger = logging.getLogger(__name__)
 
@@ -48,12 +49,13 @@ class FinanceSystem(IFinanceSystem):
             )
             return z_score > z_score_threshold
 
-    def issue_treasury_bonds(self, amount: float, current_tick: int) -> List[BondDTO]:
+    def issue_treasury_bonds(self, amount: float, current_tick: int) -> Tuple[List[BondDTO], List[Transaction]]:
         """
         Issues new treasury bonds to the market, allowing for crowding out.
-        The Central Bank only intervenes if yields exceed a critical threshold.
+        Returns newly issued bonds AND transactions for bond purchase.
         """
         base_rate = self.central_bank.get_base_rate()
+        generated_transactions = []
 
         # Use FiscalMonitor for risk assessment
         world_dto = getattr(self.government, 'sensory_data', None)
@@ -67,7 +69,6 @@ class FinanceSystem(IFinanceSystem):
         })
 
         risk_premium = 0.0
-        # Convert keys to floats just in case they are strings in the dictionary
         sorted_tiers = sorted(
             [(float(k), v) for k, v in risk_premium_tiers.items()],
             key=lambda x: x[0],
@@ -96,53 +97,53 @@ class FinanceSystem(IFinanceSystem):
         if yield_rate > qe_threshold:
             # Central Bank intervenes as buyer of last resort (QE)
             buyer = self.central_bank
-            # Note: Central Bank purchasing logic (add to portfolio) should be handled
         else:
             # Commercial bank buys it
+            # Optimistic check for Phase B
             if self.bank.assets >= amount:
                 buyer = self.bank
             else:
-                # Bond issuance fails if no one can buy it
                 logger.warning("BOND_ISSUANCE_FAILED | No buyer found (Bank insufficient funds).")
-                return []
-
-        # Execute Transfer via SettlementSystem
-        memo = f"Govt Bond Sale {new_bond.id}, Yield: {yield_rate:.2%}"
-        if self._transfer(debtor=buyer, creditor=self.government, amount=amount, memo=memo):
-            self.outstanding_bonds.append(new_bond)
-
-            # Update Buyer Portfolio
-            if hasattr(buyer, 'add_bond_to_portfolio'):
-                buyer.add_bond_to_portfolio(new_bond)
-            elif buyer == self.central_bank:
-                # Central Bank logic (if add_bond_to_portfolio missing)
-                if not hasattr(buyer.assets, 'get'): # If assets is not dict
-                     # Assuming CentralBank implementation, but for now specific hack
-                     pass
-                if isinstance(buyer.assets, dict):
-                     if "bonds" not in buyer.assets:
-                         buyer.assets["bonds"] = []
-                     buyer.assets["bonds"].append(new_bond)
-
-            return [new_bond]
-        else:
-             logger.error("BOND_ISSUANCE_FAILED | Settlement failed.")
-             return []
+                return [], []
+
+        # Generate Transaction: Buyer -> Government
+        tx = Transaction(
+            buyer_id=buyer.id,
+            seller_id=self.government.id,
+            item_id=new_bond.id,
+            quantity=1.0,
+            price=amount,
+            market_id="financial",
+            transaction_type="bond_purchase",
+            time=current_tick
+        )
+        generated_transactions.append(tx)
+
+        # Optimistic State Update
+        self.outstanding_bonds.append(new_bond)
+        if hasattr(buyer, 'add_bond_to_portfolio'):
+            buyer.add_bond_to_portfolio(new_bond)
+        elif buyer == self.central_bank:
+            if isinstance(buyer.assets, dict):
+                 if "bonds" not in buyer.assets:
+                     buyer.assets["bonds"] = []
+                 buyer.assets["bonds"].append(new_bond)
+
+        return [new_bond], generated_transactions
 
     def collect_corporate_tax(self, firm: IFinancialEntity, tax_amount: float) -> bool:
-        """Collects corporate tax using atomic settlement."""
-        memo = f"Corporate Tax, Firm ID: {firm.id}"
-        return self._transfer(
-            debtor=firm,
-            creditor=self.government,
-            amount=tax_amount,
-            memo=memo
-        )
+        """
+        Legacy method.
+        Tax collection should now be handled via Transaction Generation.
+        Kept for interface compatibility but warns usage.
+        """
+        logger.warning("FinanceSystem.collect_corporate_tax called. Should be using Transaction Generation.")
+        return False
 
-    def grant_bailout_loan(self, firm: 'Firm', amount: float) -> Optional[BailoutLoanDTO]:
+    def grant_bailout_loan(self, firm: 'Firm', amount: float, current_tick: int) -> Tuple[Optional[BailoutLoanDTO], List[Transaction]]:
         """
         Converts a bailout from a grant to an interest-bearing senior loan.
-        Returns the loan DTO on success, or None if the transfer fails.
+        Returns the loan DTO and Transaction.
         """
         base_rate = self.central_bank.get_base_rate()
         penalty_premium = self.config_module.get("economy_params.BAILOUT_PENALTY_PREMIUM", 0.05)
@@ -159,41 +160,43 @@ class FinanceSystem(IFinanceSystem):
             covenants=covenants
         )
 
-        # Transfer funds from Government to the firm
-        if self._transfer(debtor=self.government, creditor=firm, amount=amount, memo=f"Bailout Loan {firm.id}"):
-            # The government provides the funds, which become a liability for the firm
-            firm.finance.add_liability(amount, loan.interest_rate)
-            firm.has_bailout_loan = True
-            return loan
-        else:
-            logger.error(f"BAILOUT_FAILED | Could not transfer {amount:.2f} to Firm {firm.id} for bailout.")
-            return None
+        # Generate Transaction: Government -> Firm
+        tx = Transaction(
+            buyer_id=self.government.id,
+            seller_id=firm.id,
+            item_id=f"bailout_loan_{firm.id}",
+            quantity=1.0,
+            price=amount,
+            market_id="financial",
+            transaction_type="bailout_loan",
+            time=current_tick
+        )
+
+        # Optimistic State Update
+        firm.finance.add_liability(amount, loan.interest_rate)
+        firm.has_bailout_loan = True
 
+        return loan, [tx]
 
     def _transfer(self, debtor: IFinancialEntity, creditor: IFinancialEntity, amount: float, memo: str = "FinanceSystem Transfer") -> bool:
         """
-        Atomically handles the movement of funds using SettlementSystem.
+        Legacy method.
+        Should not be used in Phase 3 Normalized Sequence.
         """
         if amount <= 0:
             return True
 
         if self.settlement_system:
             return self.settlement_system.transfer(debtor, creditor, amount, memo)
-        else:
-            # Fallback legacy logic
-            try:
-                debtor.withdraw(amount)
-                creditor.deposit(amount)
-                return True
-            except InsufficientFundsError as e:
-                logger.warning(f"TRANSFER_FAILED | Atomic transfer of {amount:.2f} failed: {e}")
-                return False
-
-    def service_debt(self, current_tick: int) -> None:
+        return False
+
+    def service_debt(self, current_tick: int) -> List[Transaction]:
         """
         Manages the servicing of outstanding government debt.
         When bonds mature, both principal and accrued simple interest are paid.
+        Returns List of Transactions.
         """
+        transactions = []
         matured_bonds = [b for b in self.outstanding_bonds if b.maturity_date <= current_tick]
 
         bond_maturity_ticks = self.config_module.get("economy_params.BOND_MATURITY_TICKS", 400)
@@ -212,16 +215,23 @@ class FinanceSystem(IFinanceSystem):
                  if bond in self.central_bank.assets.get("bonds", []):
                       bond_holder = self.central_bank
 
-            # Execute Repayment via SettlementSystem
-            memo = f"Bond Repayment {bond.id}"
-            if self._transfer(debtor=self.government, creditor=bond_holder, amount=total_repayment, memo=memo):
-                 # Post-settlement cleanup
-                 if bond_holder == self.central_bank:
-                      self.central_bank.assets["bonds"].remove(bond)
-                 # Note: If Commercial Bank, we assume it just takes cash.
-                 # If it had a specific list of bonds, we should remove it there too.
+            # Generate Transaction: Government -> Holder
+            tx = Transaction(
+                buyer_id=self.government.id,
+                seller_id=bond_holder.id,
+                item_id=bond.id,
+                quantity=1.0,
+                price=total_repayment,
+                market_id="financial",
+                transaction_type="bond_repayment",
+                time=current_tick
+            )
+            transactions.append(tx)
 
-                 self.outstanding_bonds.remove(bond)
-            else:
-                 logger.critical(f"SOVEREIGN_DEFAULT | Government failed to repay bond {bond.id} (Amt: {total_repayment:.2f})")
-                 # Future: Trigger Default Protocol
+            # Optimistic Cleanup
+            if bond_holder == self.central_bank:
+                 self.central_bank.assets["bonds"].remove(bond)
+
+            self.outstanding_bonds.remove(bond)
+
+        return transactions
diff --git a/simulation/agents/government.py b/simulation/agents/government.py
index 35fa6de..bfb7a16 100644
--- a/simulation/agents/government.py
+++ b/simulation/agents/government.py
@@ -1,5 +1,5 @@
 import logging
-from typing import Dict, List, Any, Deque
+from typing import Dict, List, Any, Deque, Tuple
 from collections import deque
 from simulation.ai.enums import PoliticalParty
 from simulation.interfaces.policy_interface import IGovernmentPolicy
@@ -8,9 +8,11 @@ from simulation.policies.smart_leviathan_policy import SmartLeviathanPolicy
 from simulation.dtos import GovernmentStateDTO
 from typing import Optional, TYPE_CHECKING
 from simulation.utils.shadow_logger import log_shadow
+from simulation.models import Transaction
 
 if TYPE_CHECKING:
     from simulation.finance.api import ISettlementSystem
+    from modules.finance.api import BailoutLoanDTO
 from simulation.systems.tax_agency import TaxAgency
 from simulation.systems.ministry_of_education import MinistryOfEducation
 from modules.finance.api import InsufficientFundsError
@@ -164,6 +166,7 @@ class Government:
 
     def collect_tax(self, amount: float, tax_type: str, payer: Any, current_tick: int):
         """세금을 징수합니다."""
+        # Legacy method support if any direct calls remain, though TickScheduler uses transactions now.
         return self.tax_agency.collect_tax(self, amount, tax_type, payer, current_tick)
 
     def update_public_opinion(self, households: List[Any]):
@@ -182,13 +185,10 @@ class Government:
         avg_approval = total_approval / count if count > 0 else 0.5
         self.public_opinion_queue.append(avg_approval)
 
-        # Update Perceived Opinion (Lagged)
-        # We take the oldest value in the queue (FIFO)
-        # If queue is full (len 4), index 0 is 4 ticks ago.
         if len(self.public_opinion_queue) > 0:
             self.perceived_public_opinion = self.public_opinion_queue[0]
 
-        self.approval_rating = avg_approval # Real-time value (for omniscient logging)
+        self.approval_rating = avg_approval
 
     def check_election(self, current_tick: int):
         """
@@ -198,8 +198,6 @@ class Government:
         if current_tick > 0 and current_tick % election_cycle == 0:
             self.last_election_tick = current_tick
 
-            # Retrospective Voting
-            # If Perceived Opinion < 0.5 (Tolerance), Incumbent loses.
             if self.perceived_public_opinion < 0.5:
                 # Flip Party
                 old_party = self.ruling_party
@@ -221,23 +219,19 @@ class Government:
         (전략 패턴 적용: Taylor Rule 또는 AI Adaptive)
         """
         # 1. 정책 엔진 실행 (Actuator 및 Shadow Mode 로직 포함)
-        # WO-057-B FIX: Pass the smoothed sensory data, not the raw market_data
         decision = self.policy_engine.decide(self, self.sensory_data, current_tick, central_bank)
         
-        # 2. 결과 로깅 (엔진 내부에서 상세 로깅 수행)
         if decision.get("status") == "EXECUTED":
              logger.debug(
                 f"POLICY_EXECUTED | Tick: {current_tick} | Action: {decision.get('action_taken')}",
                 extra={"tick": current_tick, "agent_id": self.id}
             )
 
-
         gdp_gap = 0.0
         if self.potential_gdp > 0:
             current_gdp = market_data.get("total_production", 0.0)
             gdp_gap = (current_gdp - self.potential_gdp) / self.potential_gdp
 
-            # Simple EMA update for Potential GDP
             alpha = 0.01
             self.potential_gdp = (alpha * current_gdp) + ((1-alpha) * self.potential_gdp)
 
@@ -257,17 +251,10 @@ class Government:
             if past_gdp > 0:
                 real_gdp_growth = (current_gdp - past_gdp) / past_gdp
 
-        # 5. Taylor Rule 2.0
-        # Target_Rate = Real_GDP_Growth + Inflation + 0.5*(Inf - Target_Inf) + 0.5*(GDP_Gap)
         target_inflation = getattr(self.config_module, "CB_INFLATION_TARGET", 0.02)
-
-        # Neutral Rate assumption: Real Growth
-        neutral_rate = max(0.01, real_gdp_growth) # Floor at 1%?
-
+        neutral_rate = max(0.01, real_gdp_growth)
         target_rate = neutral_rate + inflation + 0.5 * (inflation - target_inflation) + 0.5 * gdp_gap
 
-        # 6. Log
-        # Get current base rate from market_data["loan_market"] or similar
         current_base_rate = 0.05
         if "loan_market" in market_data:
             current_base_rate = market_data["loan_market"].get("interest_rate", 0.05)
@@ -284,49 +271,60 @@ class Government:
             details=f"Inf={inflation:.2%}, Growth={real_gdp_growth:.2%}, Gap={gdp_gap:.2%}, RateGap={gap:.4f}"
         )
 
-    def provide_household_support(self, household: Any, amount: float, current_tick: int):
-        """Provides subsidies to households (e.g., unemployment, stimulus)."""
+    def provide_household_support(self, household: Any, amount: float, current_tick: int) -> List[Transaction]:
+        """Provides subsidies to households (e.g., unemployment, stimulus). Returns transactions."""
+        transactions = []
         effective_amount = amount * self.welfare_budget_multiplier
 
         if effective_amount <= 0:
-            return 0.0
+            return []
+
+        # Check budget, issue bonds if needed (Optimistic check)
 
         if self.assets < effective_amount:
             needed = effective_amount - self.assets
-            issued_bonds = self.finance_system.issue_treasury_bonds(needed, current_tick)
-            if not issued_bonds:
+            # FinanceSystem now returns (bonds, transactions)
+            bonds, txs = self.finance_system.issue_treasury_bonds(needed, current_tick)
+            if not bonds:
                 logger.warning(f"BOND_ISSUANCE_FAILED | Failed to raise {needed:.2f} for household support.")
-                return 0.0
-
-        success = False
-        if self.settlement_system:
-            success = self.settlement_system.transfer(self, household, effective_amount, "Household Support")
-        else:
-            self.withdraw(effective_amount)
-            household.deposit(effective_amount)
-            success = True
+                return []
+            transactions.extend(txs)
+
+        # Generate Welfare Transaction
+        tx = Transaction(
+            buyer_id=self.id,
+            seller_id=household.id,
+            item_id="welfare_support",
+            quantity=1.0,
+            price=effective_amount,
+            market_id="system",
+            transaction_type="welfare",
+            time=current_tick
+        )
+        transactions.append(tx)
 
-        if success:
-            self.total_spent_subsidies += effective_amount
-            self.expenditure_this_tick += effective_amount
-            self.current_tick_stats["welfare_spending"] += effective_amount
+        self.total_spent_subsidies += effective_amount
+        self.expenditure_this_tick += effective_amount
+        self.current_tick_stats["welfare_spending"] += effective_amount
 
         logger.info(
-            f"HOUSEHOLD_SUPPORT | Paid {effective_amount:.2f} to {household.id}",
+            f"HOUSEHOLD_SUPPORT | Generated support tx of {effective_amount:.2f} to {household.id}",
             extra={"tick": current_tick, "agent_id": self.id, "amount": effective_amount, "target_id": household.id}
         )
-        return effective_amount
+        return transactions
 
-    def provide_firm_bailout(self, firm: Any, amount: float, current_tick: int):
-        """Provides a bailout loan to a firm if it's eligible."""
+    def provide_firm_bailout(self, firm: Any, amount: float, current_tick: int) -> Tuple[Optional["BailoutLoanDTO"], List[Transaction]]:
+        """Provides a bailout loan to a firm if it's eligible. Returns (LoanDTO, Transactions)."""
         if self.finance_system.evaluate_solvency(firm, current_tick):
             logger.info(f"BAILOUT_APPROVED | Firm {firm.id} is eligible for a bailout.")
-            loan = self.finance_system.grant_bailout_loan(firm, amount)
-            self.expenditure_this_tick += amount
-            return loan
+            # FinanceSystem now returns (loan, transactions)
+            loan, txs = self.finance_system.grant_bailout_loan(firm, amount, current_tick)
+            if loan:
+                self.expenditure_this_tick += amount
+            return loan, txs
         else:
             logger.warning(f"BAILOUT_DENIED | Firm {firm.id} is insolvent and not eligible for a bailout.")
-            return None
+            return None, []
 
     def get_survival_cost(self, market_data: Dict[str, Any]) -> float:
         """ Calculates current survival cost based on food prices. """
@@ -340,34 +338,14 @@ class Government:
         daily_food_need = getattr(self.config_module, "HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK", 1.0)
         return max(avg_food_price * daily_food_need, 10.0)
 
-    def run_welfare_check(self, agents: List[Any], market_data: Dict[str, Any], current_tick: int):
+    def run_welfare_check(self, agents: List[Any], market_data: Dict[str, Any], current_tick: int) -> List[Transaction]:
         """
         Government Main Loop Step.
-        1. Reset Tick Flow.
-        2. Make AI Policy Decisions (Act).
-        3. Check Election (Judge).
-        4. Execute Welfare/Stimulus (using updated policy).
+        Returns List of Transactions.
         """
-        # Ensure tick flow is reset at the start of government processing
+        transactions = []
         self.reset_tick_flow()
 
-        # --- Phase 17-5: Leviathan Logic ---
-        # 1. Update Opinion & Make Decision
-        # Note: Opinion is updated by Engine calling update_public_opinion BEFORE this method?
-        # Yes, Plan says engine.py loop will call update_public_opinion -> make_decision -> check_election.
-        # But here in run_welfare_check, we can group them if engine calls this.
-        # Current engine.py calls run_welfare_check.
-        # So I will move the AI calls HERE or keep them in Engine.
-        # The prompt plan says "Update Simulation Engine... Call household.update_political_opinion... government.update_public_opinion... make_policy_decision".
-        # If I put them in Engine, run_welfare_check becomes just "Execute Welfare".
-        # Let's keep run_welfare_check focused on Welfare execution, and let Engine handle the high level "Government Thinking".
-
-        # However, run_welfare_check also did "adjust_fiscal_policy".
-        # I should REMOVE the old `adjust_fiscal_policy` call here as AI replaces it.
-        # I removed it below.
-
-        # ---------------------------------------
-
         # 1. Calculate Survival Cost (Dynamic)
         survival_cost = self.get_survival_cost(market_data)
 
@@ -390,23 +368,32 @@ class Government:
             if hasattr(agent, "needs") and hasattr(agent, "is_employed"):
                 # A. Wealth Tax
                 net_worth = agent.assets
-                # Stock Value logic skipped for brevity/speed as per original
-
                 if net_worth > wealth_threshold:
                     tax_amount = (net_worth - wealth_threshold) * wealth_tax_rate_tick
-                    # Check available assets
                     tax_amount = min(tax_amount, agent.assets)
 
                     if tax_amount > 0:
-                        self.collect_tax(tax_amount, "wealth_tax", agent, current_tick)
+                        # Generate Tax Transaction
+                        tx = Transaction(
+                            buyer_id=agent.id,
+                            seller_id=self.id,
+                            item_id="wealth_tax",
+                            quantity=1.0,
+                            price=tax_amount,
+                            market_id="system",
+                            transaction_type="tax",
+                            time=current_tick
+                        )
+                        transactions.append(tx)
                         total_wealth_tax += tax_amount
 
                 # B. Unemployment Benefit
                 if not agent.is_employed:
-                    self.provide_household_support(agent, benefit_amount, current_tick)
+                    txs = self.provide_household_support(agent, benefit_amount, current_tick)
+                    transactions.extend(txs)
                     total_welfare_paid += benefit_amount
 
-        # 3. Stimulus Check (Legacy Logic, now influenced by AI multiplier)
+        # 3. Stimulus Check
         current_gdp = market_data.get("total_production", 0.0)
         self.gdp_history.append(current_gdp)
         if len(self.gdp_history) > self.gdp_history_window:
@@ -428,45 +415,75 @@ class Government:
 
              total_stimulus = 0.0
              for h in active_households:
-                 paid = self.provide_household_support(h, stimulus_amount, current_tick)
-                 total_stimulus += paid
+                 txs = self.provide_household_support(h, stimulus_amount, current_tick)
+                 transactions.extend(txs)
+
+                 # Calculate total from txs for logging?
+                 # Assuming 1 welfare tx per support call
+                 for tx in txs:
+                     if tx.transaction_type == 'welfare':
+                         total_stimulus += tx.price
 
              if total_stimulus > 0:
                  logger.warning(
-                     f"STIMULUS_TRIGGERED | GDP Drop Detected. Paid {total_stimulus:.2f}.",
+                     f"STIMULUS_TRIGGERED | GDP Drop Detected. Generated stimulus txs total {total_stimulus:.2f}.",
                      extra={"tick": current_tick, "agent_id": self.id, "gdp_current": current_gdp}
                  )
 
-    def invest_infrastructure(self, current_tick: int, reflux_system: Any = None) -> bool:
-        """인프라에 투자하여 전체 생산성을 향상시킵니다."""
+        return transactions
+
+    def invest_infrastructure(self, current_tick: int, reflux_system: Any = None) -> Tuple[bool, List[Transaction]]:
+        """인프라에 투자하여 전체 생산성을 향상시킵니다. Returns (Success, Transactions)."""
+        transactions = []
         cost = getattr(self.config_module, "INFRASTRUCTURE_INVESTMENT_COST", 5000.0)
         
-        # Apply AI Multiplier? Maybe firm subsidy multiplier applies here too?
-        # Let's say BLUE party loves infrastructure.
-        effective_cost = cost # Cost is fixed, but decision to buy depends on funds
+        effective_cost = cost
 
-        # If multiplier < 1.0 (Austerity), maybe we skip investment?
         if self.firm_subsidy_budget_multiplier < 0.8:
-            return False
+            return False, []
+
+        # Optimistic Check: Do we have enough + potential bond revenue?
+        # Note: Since bond transactions are returned and executed later, self.assets isn't updated yet.
+        # But we also delay infrastructure spending via Transaction.
+        # So we check: Current Assets + (Bond Revenue) >= Cost
 
+        potential_revenue = 0.0
         if self.assets < effective_cost:
             needed = effective_cost - self.assets
-            issued_bonds = self.finance_system.issue_treasury_bonds(needed, current_tick)
-            if not issued_bonds:
+            bonds, txs = self.finance_system.issue_treasury_bonds(needed, current_tick)
+            if not bonds:
                 logger.warning(f"BOND_ISSUANCE_FAILED | Failed to raise {needed:.2f} for infrastructure.")
-                return False
+                return False, []
+            transactions.extend(txs)
+            potential_revenue = needed # Assume success
+
+        # Generate Investment Transaction (Gov -> Reflux)
+        # Using RefluxSystem ID (999999) as Receiver
+        reflux_id = 999999
+        if reflux_system and hasattr(reflux_system, 'id'):
+            reflux_id = reflux_system.id
+
+        tx = Transaction(
+            buyer_id=reflux_id, # Reflux Receives
+            seller_id=self.id, # Government Pays
+            item_id="infrastructure_investment",
+            quantity=1.0,
+            price=effective_cost,
+            market_id="system",
+            transaction_type="infrastructure",
+            time=current_tick
+        )
+        transactions.append(tx)
 
-        # Note: Ideally this would be a transfer to a contractor/firm, but for now it's a sink or abstract investment.
-        # We use withdraw().
-        self.withdraw(effective_cost)
         self.expenditure_this_tick += effective_cost
-        if reflux_system:
-            reflux_system.capture(effective_cost, str(self.id), "infrastructure")
+
+        # We do NOT call reflux_system.capture here because the Transaction will deposit to Reflux.
+        # RefluxSystem.deposit calls capture.
 
         self.infrastructure_level += 1
 
         logger.info(
-            f"INFRASTRUCTURE_INVESTED | Level {self.infrastructure_level} reached. Cost: {effective_cost}",
+            f"INFRASTRUCTURE_INVESTED | Level {self.infrastructure_level} reached. Generated tx for {effective_cost}",
             extra={
                 "tick": current_tick,
                 "agent_id": self.id,
@@ -474,7 +491,7 @@ class Government:
                 "tags": ["investment", "infrastructure"]
             }
         )
-        return True
+        return True, transactions
 
     def finalize_tick(self, current_tick: int):
         """
@@ -558,15 +575,3 @@ class Government:
         """
         households = [a for a in agents if hasattr(a, 'education_level')]
         self.ministry_of_education.run_public_education(households, self, current_tick, reflux_system)
-
-    def deposit(self, amount: float) -> None:
-        """Deposits a given amount into the government's assets."""
-        if amount > 0:
-            self._assets += amount
-
-    def withdraw(self, amount: float) -> None:
-        """Withdraws a given amount from the government's assets."""
-        if amount > 0:
-            if self.assets < amount:
-                raise InsufficientFundsError(f"Government {self.id} has insufficient funds for withdrawal of {amount:.2f}. Available: {self.assets:.2f}")
-            self._assets -= amount
diff --git a/simulation/bank.py b/simulation/bank.py
index 4eafaea..d289045 100644
--- a/simulation/bank.py
+++ b/simulation/bank.py
@@ -4,6 +4,7 @@ from typing import Dict, Any, List, Optional, TYPE_CHECKING
 import math
 from modules.common.config_manager.api import ConfigManager
 from modules.finance.api import InsufficientFundsError, IFinancialEntity
+from simulation.models import Transaction
 
 if TYPE_CHECKING:
     from simulation.finance.api import ISettlementSystem
@@ -144,23 +145,6 @@ class Bank(IFinancialEntity):
         # 2. Liquidity Check
         # 1a. Credit Jail Check (Phase 4)
         if self._get_config("credit_recovery_ticks", None) is not None:
-            # We assume borrower_id maps to an agent object passed somewhere, but here we only have ID.
-            # We need to access the agent to check 'credit_frozen_until_tick'.
-            # Bank doesn't have direct access to agent list in grant_loan signature.
-            # But grant_loan is usually called by LoanMarket which has access or the Agent itself calls it via Market.
-            # Wait, LoanMarket.process_loan_request calls this.
-            # Ideally, LoanMarket should check this before calling grant_loan.
-            # BUT, to enforce it at the Bank level, we'd need the agent object or a way to look it up.
-            # Since we don't have it here easily without changing signature, let's assume LoanMarket checks it OR
-            # we rely on the fact that if an agent is in credit jail, their 'credit_rating' (conceptually) is 0.
-            # Let's enforce it in LoanMarket instead?
-            # The spec says "Modify Bank to handle defaults ... prevents Moral Hazard".
-            # It also says "Bankrupt agents remain active but are economically crippled (Credit Jail)."
-            # Let's add an optional 'borrower_agent' arg or rely on LoanMarket.
-            # I'll update LoanMarket in the next steps or if I can modify Bank signature.
-            # Actually, Bank.run_tick has access to 'agents_dict'.
-            # Let's trust LoanMarket for now, OR change signature.
-            # I will assume LoanMarket handles the denial based on the flag I added to Household.
             pass
 
         # 3. Gold Standard (Full Reserve) Check vs. Fractional Reserve (WO-064)
@@ -326,16 +310,16 @@ class Bank(IFinancialEntity):
                 total_deposit += deposit.amount
         return total_deposit
 
-    def run_tick(self, agents_dict: Dict[int, Any], current_tick: int = 0, reflux_system: Optional[Any] = None):
+    def run_tick(self, agents_dict: Dict[int, Any], current_tick: int = 0, reflux_system: Optional[Any] = None) -> List[Transaction]:
         """
         Process interest payments and distributions.
-        Must be called every tick.
+        Returns a list of transactions to be executed by TransactionProcessor.
         """
+        generated_transactions: List[Transaction] = []
         ticks_per_year = self._get_config("bank_defaults.ticks_per_year", TICKS_PER_YEAR)
 
         # 1. Collect Interest from Loans
         total_loan_interest = 0.0
-        loans_to_remove = []
 
         for loan_id, loan in self.loans.items():
             agent = agents_dict.get(loan.borrower_id)
@@ -345,52 +329,45 @@ class Bank(IFinancialEntity):
 
             # Calculate Interest Payment
             interest_payment = (loan.remaining_balance * loan.annual_interest_rate) / ticks_per_year
-
-            # Principal Repayment (Amortized or Bullet? Assuming Bullet for now or minimal amortization)
-            # Let's simple amortization: Principal / Remaining Term
-            # Wait, design spec says "Man-gi or Bun-hal". Let's do simple interest only + Principal at end?
-            # Or constant payment?
-            # Spec: "tick_payment = (balance * annual_rate) / TICKS_PER_YEAR" -> This is Interest Only.
-
             payment = interest_payment
 
-            # Try to collect
-            if agent.assets >= payment:
-                success = False
-                if self.settlement_system:
-                    success = self.settlement_system.transfer(agent, self, payment, f"Loan Interest {loan_id}")
-                else:
-                    agent.withdraw(payment)
-                    self.deposit(payment)
-                    success = True
+            # Optimistic check (actual verification happens in TransactionProcessor)
+            # However, if we want to trigger default logic, we MUST check here or defer default logic.
+            # If we generate a transaction and it fails later, how do we trigger Default?
+            # The TransactionProcessor doesn't trigger callbacks on failure yet.
+            # So, we must check 'assets' here to decide whether to issue 'Interest Payment' or 'Default Protocol'.
+            # This relies on 'agent.assets' being accurate at this point.
 
-                if success:
-                    total_loan_interest += payment
-
-                    # Record Expense for Firms (FinanceDepartment)
-                    if hasattr(agent, 'finance') and hasattr(agent.finance, 'record_expense'):
-                        agent.finance.record_expense(payment)
+            if agent.assets >= payment:
+                tx = Transaction(
+                    buyer_id=agent.id, # Payer
+                    seller_id=self.id, # Payee
+                    item_id=loan_id,
+                    quantity=1.0,
+                    price=payment,
+                    market_id="financial",
+                    transaction_type="loan_interest",
+                    time=current_tick
+                )
+                generated_transactions.append(tx)
+                total_loan_interest += payment
 
             else:
-                # Default / Penalty logic
-                # Phase 4: Call process_default
                 self.process_default(agent, loan, current_tick)
-
-                # Take whatever is left (process_default might have seized assets already)
                 partial = agent.assets
                 if partial > 0:
-                     success = False
-                     if self.settlement_system:
-                         success = self.settlement_system.transfer(agent, self, partial, f"Loan Default Recovery {loan_id}")
-                     else:
-                         # Force withdrawal of remaining balance
-                         # Assuming partial = agent.assets
-                         agent.withdraw(partial)
-                         self.deposit(partial)
-                         success = True
-
-                     if success:
-                        total_loan_interest += partial
+                    tx = Transaction(
+                        buyer_id=agent.id,
+                        seller_id=self.id,
+                        item_id=loan_id,
+                        quantity=1.0,
+                        price=partial,
+                        market_id="financial",
+                        transaction_type="loan_default_recovery",
+                        time=current_tick
+                    )
+                    generated_transactions.append(tx)
+                    total_loan_interest += partial
 
         # 2. Pay Interest to Depositors
         total_deposit_interest = 0.0
@@ -401,46 +378,59 @@ class Bank(IFinancialEntity):
 
             interest_payout = (deposit.amount * deposit.annual_interest_rate) / ticks_per_year
 
+            # Optimistic check
             if self.assets >= interest_payout:
-                success = False
-                if self.settlement_system:
-                    success = self.settlement_system.transfer(self, agent, interest_payout, f"Deposit Interest {dep_id}")
-                else:
-                    self.withdraw(interest_payout)
-                    agent.deposit(interest_payout)
-                    success = True
-
-                # Track Capital Income (Interest)
-                from simulation.core_agents import Household
-                if isinstance(agent, Household) and hasattr(agent, "capital_income_this_tick"):
+                 tx = Transaction(
+                    buyer_id=self.id, # Bank pays
+                    seller_id=agent.id, # Depositor receives
+                    item_id=dep_id,
+                    quantity=1.0,
+                    price=interest_payout,
+                    market_id="financial",
+                    transaction_type="deposit_interest",
+                    time=current_tick
+                 )
+                 generated_transactions.append(tx)
+                 total_deposit_interest += interest_payout
+
+                 # Side effect: Track capital income
+                 from simulation.core_agents import Household
+                 if isinstance(agent, Household) and hasattr(agent, "capital_income_this_tick"):
                     agent.capital_income_this_tick += interest_payout
-
-                total_deposit_interest += interest_payout
-                # Compounding? Usually deposits compound.
-                # If we pay to agent.assets, it's "Payout".
-                # If we add to deposit.amount, it's "Compound".
-                # Spec says: "bank.reserves 차감, agent.assets 증가 (유동성 공급)" -> Payout.
             else:
-                # Bank run scenario?
-                logger.error("BANK_LIQUIDITY_CRISIS | Cannot pay deposit interest!")
+                 logger.error("BANK_LIQUIDITY_CRISIS | Cannot pay deposit interest!")
 
-        # Phase 8-B: Capture Net Profit (Reflux)
-        # Net Profit = Interest Income - Interest Expense
+        # 3. Bank Profit Capture (Reflux)
         net_profit = total_loan_interest - total_deposit_interest
-        if net_profit > 0 and reflux_system:
-            # Transfer profit to reflux system (Distribution as dividend/service fee)
-            # This ensures Bank doesn't accumulate infinite money.
-            # Bank assets were already updated above (+loan_int, -dep_int).
-            # So we subtract net_profit from assets.
-            self._assets -= net_profit
-            reflux_system.capture(net_profit, "Bank", "net_profit")
-            logger.info(f"BANK_PROFIT_CAPTURE | Transferred {net_profit:.2f} to Reflux System.")
+
+        # Find Government for profit transfer
+        gov_agent = None
+        for a in agents_dict.values():
+             if a.__class__.__name__ == 'Government':
+                 gov_agent = a
+                 break
+
+        if net_profit > 0 and gov_agent:
+             tx = Transaction(
+                 buyer_id=gov_agent.id, # Government receives
+                 seller_id=self.id, # Bank pays
+                 item_id="bank_profit",
+                 quantity=1.0,
+                 price=net_profit,
+                 market_id="financial",
+                 transaction_type="reflux_capture",
+                 time=current_tick
+             )
+             generated_transactions.append(tx)
+             logger.info(f"BANK_PROFIT_CAPTURE | Generated transaction of {net_profit:.2f} to Government.")
 
         logger.info(
-            f"BANK_TICK_SUMMARY | Collected Loan Int: {total_loan_interest:.2f}, Paid Deposit Int: {total_deposit_interest:.2f}, Net Profit: {net_profit:.2f}, Reserves: {self.assets:.2f}",
+            f"BANK_TICK_SUMMARY | Collected Loan Int: {total_loan_interest:.2f}, Paid Deposit Int: {total_deposit_interest:.2f}, Net Profit: {net_profit:.2f}, Generated Txs: {len(generated_transactions)}",
             extra={"agent_id": self.id, "tags": ["bank", "tick"]}
         )
 
+        return generated_transactions
+
     # Legacy method support for compatibility if needed, but we are rewriting
     def get_outstanding_loans_for_agent(self, agent_id: int) -> List[Dict]:
         # Return dict representation for compatibility if other modules use it
@@ -475,10 +465,6 @@ class Bank(IFinancialEntity):
              # If we have a reference to government via simulation later, but here we take config
              pass
         
-        # We need a way to increment gov.total_money_issued. 
-        # Since Bank doesn't have gov reference directly, we'll return the amount
-        # or rely on the engine to track it if we flag it.
-        # Better: Pass government to Bank.run_tick or check_solvency.
         logger.warning(f"BANK_BORROWING | Central Bank injected {amount:.2f} into Bank {self.id} reserves.")
 
     def check_solvency(self, government: Any):
diff --git a/simulation/components/finance_department.py b/simulation/components/finance_department.py
index 35a6119..96f7738 100644
--- a/simulation/components/finance_department.py
+++ b/simulation/components/finance_department.py
@@ -53,29 +53,14 @@ class FinanceDepartment:
 
     def credit(self, amount: float, description: str = "") -> None:
         """Adds funds to the firm's cash reserves."""
-        # Unchecked credit. In some scenarios (correction) negative credit might be theoretically possible
-        # but generally discouraged. We accept it to handle external 'assets' property setters robustly.
         self._cash += amount
 
     def debit(self, amount: float, description: str = "") -> None:
         """
         Deducts funds from the firm's cash reserves.
-        Allows negative balance (insolvency) to be tracked rather than crashing,
-        but caller should generally check funds first.
         """
         self._cash -= amount
 
-    def calculate_and_debit_holding_costs(self) -> float:
-        """Calculates and pays inventory holding costs."""
-        inventory_value = self.get_inventory_value()
-        holding_cost = inventory_value * self.config_module.INVENTORY_HOLDING_COST_RATE
-
-        if holding_cost > 0:
-            self.debit(holding_cost, "Inventory Holding Cost")
-            self.record_expense(holding_cost)
-
-        return holding_cost
-
     def record_revenue(self, amount: float):
         self.revenue_this_turn += amount
         self.revenue_this_tick += amount
@@ -86,84 +71,143 @@ class FinanceDepartment:
         self.expenses_this_tick += amount
         self.current_profit -= amount
 
-    def pay_maintenance(self, government: Government, reflux_system: Optional[EconomicRefluxSystem], current_time: int):
-        """Pay fixed maintenance fee."""
+    def generate_holding_cost_transaction(self, government: Government, current_time: int) -> Optional[Transaction]:
+        """Generates inventory holding cost transaction."""
+        inventory_value = self.get_inventory_value()
+        holding_cost = inventory_value * self.config_module.INVENTORY_HOLDING_COST_RATE
+
+        if holding_cost > 0:
+            # We record expense so Profit calc later in tick is correct
+            self.record_expense(holding_cost)
+
+            return Transaction(
+                buyer_id=self.firm.id,
+                seller_id=government.id, # Capture to Gov/Reflux
+                item_id="holding_cost",
+                quantity=1.0,
+                price=holding_cost,
+                market_id="system",
+                transaction_type="holding_cost",
+                time=current_time
+            )
+        return None
+
+    def generate_maintenance_transaction(self, government: Government, current_time: int) -> Optional[Transaction]:
+        """Generates maintenance fee transaction."""
         fee = getattr(self.config_module, "FIRM_MAINTENANCE_FEE", 50.0)
-        payment = min(self._cash, fee) # Cap at available cash
+
+        # Optimistic check
+        payment = min(self._cash, fee)
 
         if payment > 0:
-            # Debit handled by Government -> FinanceSystem -> SettlementSystem -> Firm.withdraw
-            government.collect_tax(payment, "firm_maintenance", self.firm, current_time)
             self.record_expense(payment)
-
             self.firm.logger.info(
-                f"Paid maintenance fee: {payment:.2f}",
+                f"Generated maintenance fee tx: {payment:.2f}",
                 extra={"tick": current_time, "agent_id": self.firm.id, "tags": ["tax", "maintenance"]}
             )
+            return Transaction(
+                buyer_id=self.firm.id,
+                seller_id=government.id,
+                item_id="firm_maintenance",
+                quantity=1.0,
+                price=payment,
+                market_id="system",
+                transaction_type="tax",
+                time=current_time
+            )
+        return None
 
-    def pay_taxes(self, government: Government, current_time: int):
-        """Pay corporate tax on profit."""
+    def generate_tax_transaction(self, government: Government, current_time: int) -> Optional[Transaction]:
+        """Generates corporate tax transaction."""
         net_profit = self.revenue_this_turn - self.cost_this_turn
 
         if net_profit > 0:
             tax_rate = getattr(self.config_module, "CORPORATE_TAX_RATE", 0.2)
             tax_amount = net_profit * tax_rate
 
-            payment = min(self._cash, tax_amount) # Cap at available cash
+            # Optimistic check
+            payment = min(self._cash, tax_amount)
 
             if payment > 0:
-                # Debit handled by Government -> FinanceSystem -> SettlementSystem -> Firm.withdraw
-                government.collect_tax(payment, "corporate_tax", self.firm, current_time)
-
                 after_tax_profit = net_profit - payment
                 self.retained_earnings += after_tax_profit
-                # Note: We do NOT record_expense here because tax is usually considered separate from operating expenses in this model logic,
-                # OR it was already implicitly deducted from 'retained_earnings' calc.
-                # Wait, original code:
-                # self.debit(...)
-                # government.collect_tax(...)
-                # after_tax_profit = net_profit - payment
-                # retained_earnings += after_tax_profit
-
-                # It did NOT call record_expense().
-                # So we are fine.
 
                 self.firm.logger.info(
-                    f"Paid corporate tax: {payment:.2f} on profit {net_profit:.2f}. Retained Earnings increased by {after_tax_profit:.2f}",
+                    f"Generated corporate tax tx: {payment:.2f} on profit {net_profit:.2f}.",
                     extra={"tick": current_time, "agent_id": self.firm.id, "tags": ["tax", "corporate_tax"]}
                 )
 
+                return Transaction(
+                    buyer_id=self.firm.id,
+                    seller_id=government.id,
+                    item_id="corporate_tax",
+                    quantity=1.0,
+                    price=payment,
+                    market_id="system",
+                    transaction_type="tax",
+                    time=current_time
+                )
+        return None
+
+    def generate_marketing_transaction(self, government: Government, current_time: int, amount: float) -> Optional[Transaction]:
+        """Generates marketing spend transaction."""
+        if amount > 0:
+            self.record_expense(amount)
+            return Transaction(
+                buyer_id=self.firm.id,
+                seller_id=government.id, # Reflux/Gov capture
+                item_id="marketing",
+                quantity=1.0,
+                price=amount,
+                market_id="system",
+                transaction_type="marketing",
+                time=current_time
+            )
+        return None
+
     def process_profit_distribution(self, households: List[Household], government: Government, current_time: int) -> List[Transaction]:
-        """Public Shareholders Dividend"""
+        """
+        Public Shareholders Dividend & Bailout Repayment.
+        Returns List of Transactions.
+        """
+        transactions = []
+
+        # 1. Bailout Repayment
         if getattr(self.firm, 'has_bailout_loan', False) and self.current_profit > 0:
             repayment_ratio = getattr(self.config_module, "BAILOUT_REPAYMENT_RATIO", 0.5)
             repayment = self.current_profit * repayment_ratio
 
+            # Optimistic update of debt state (assuming tx succeeds)
+            # If it fails, we might drift. But TransactionProcessor should be reliable if funds exist.
+            # We assume funds exist if current_profit > 0 (implies we made money).
+
             # Ensure total_debt exists
             if not hasattr(self.firm, 'total_debt'):
                 self.firm.total_debt = 0.0
 
-            # Bailout repayment
-            if hasattr(self.firm, 'settlement_system') and self.firm.settlement_system:
-                self.firm.settlement_system.transfer(self.firm, government, repayment, "Bailout Repayment")
-            else:
-                self.debit(repayment, "Bailout Repayment")
-                government.deposit(repayment)
+            transactions.append(
+                Transaction(
+                    buyer_id=self.firm.id,
+                    seller_id=government.id,
+                    item_id="bailout_repayment",
+                    quantity=1.0,
+                    price=repayment,
+                    market_id="system",
+                    transaction_type="repayment",
+                    time=current_time
+                )
+            )
 
             self.firm.total_debt -= repayment
             self.current_profit -= repayment
-            self.firm.logger.info(f"BAILOUT_REPAYMENT | Firm {self.firm.id} repaid {repayment:.2f} of its bailout loan to the government.")
+            self.firm.logger.info(f"BAILOUT_REPAYMENT | Generated repayment tx {repayment:.2f}.")
 
-            # Check if the loan is fully repaid
             if self.firm.total_debt <= 0:
                 self.firm.total_debt = 0.0
                 self.firm.has_bailout_loan = False
-                self.firm.logger.info(f"BAILOUT_PAID_OFF | Firm {self.firm.id} has fully repaid its bailout loan.")
 
-        transactions = []
+        # 2. Dividends
         distributable_profit = max(0, self.current_profit * self.firm.dividend_rate)
-
-        # Reset tracker
         self.dividends_paid_last_tick = 0.0
 
         if distributable_profit > 0:
@@ -171,26 +215,19 @@ class FinanceDepartment:
                 shares = household.shares_owned.get(self.firm.id, 0.0)
                 if shares > 0:
                     dividend_amount = distributable_profit * (shares / self.firm.total_shares)
-                    # NOTE: Dividends are paid via TransactionProcessor normally.
-                    # TransactionProcessor sees "dividend" and does: seller.assets -= trade_value.
-                    # Since seller.assets will delegate to finance.debit, this works.
                     transactions.append(
                         Transaction(
-                            buyer_id=household.id,
                             seller_id=self.firm.id,
+                            buyer_id=household.id,
                             item_id="dividend",
-                            quantity=dividend_amount,
-                            price=1.0,
+                            quantity=1.0, # 1 unit of dividend event
+                            price=dividend_amount, # Cash amount
                             market_id="financial",
                             transaction_type="dividend",
                             time=current_time,
                         )
                     )
                     self.dividends_paid_last_tick += dividend_amount
-                    self.firm.logger.info(
-                        f"Firm {self.firm.id} distributed {dividend_amount:.2f} dividend to Household {household.id}.",
-                        extra={"tick": current_time, "agent_id": self.firm.id, "household_id": household.id, "amount": dividend_amount, "tags": ["dividend"]},
-                    )
 
         # Reset period counters
         self.current_profit = 0.0
@@ -201,14 +238,14 @@ class FinanceDepartment:
 
         return transactions
 
-    def distribute_profit_private(self, agents: Dict[int, Any], current_time: int) -> float:
-        """Phase 14-1: Private Owner Dividend"""
+    def distribute_profit_private(self, agents: Dict[int, Any], government: Government, current_time: int) -> List[Transaction]:
+        """Phase 14-1: Private Owner Dividend Transaction Generation"""
         if self.firm.owner_id is None:
-            return 0.0
+            return []
 
         owner = agents.get(self.firm.owner_id)
         if owner is None:
-            return 0.0
+            return []
 
         maintenance_fee = getattr(self.config_module, "FIRM_MAINTENANCE_FEE", 0.0)
 
@@ -224,33 +261,58 @@ class FinanceDepartment:
 
         distributable_cash = self._cash - required_reserves
 
+        transactions = []
         if distributable_cash > 0:
             dividend_amount = distributable_cash
-            success = False
-            if hasattr(self.firm, 'settlement_system') and self.firm.settlement_system:
-                success = self.firm.settlement_system.transfer(self.firm, owner, dividend_amount, "Private Dividend")
-            else:
-                self.debit(dividend_amount, "Private Dividend")
-                owner.deposit(dividend_amount)
-                success = True
-
-            if success:
-                if hasattr(owner, 'income_capital_cumulative'):
-                    owner.income_capital_cumulative += dividend_amount
-                if hasattr(owner, 'capital_income_this_tick'):
-                    owner.capital_income_this_tick += dividend_amount
-
-                self.retained_earnings -= dividend_amount
-                self.dividends_paid_last_tick += dividend_amount
-
-                if self.firm.logger:
-                    self.firm.logger.info(
-                        f"DIVIDEND | Firm {self.firm.id} -> Household {self.firm.owner_id} : ${dividend_amount:.2f}",
-                        extra={"tick": current_time, "event": "DIVIDEND", "amount": dividend_amount}
-                    )
-                return dividend_amount
 
-        return 0.0
+            transactions.append(
+                Transaction(
+                    buyer_id=self.firm.id,
+                    seller_id=owner.id,
+                    item_id="private_dividend",
+                    quantity=1.0,
+                    price=dividend_amount,
+                    market_id="financial",
+                    transaction_type="dividend",
+                    time=current_time
+                )
+            )
+
+            # Optimistic state update
+            if hasattr(owner, 'income_capital_cumulative'):
+                owner.income_capital_cumulative += dividend_amount
+            if hasattr(owner, 'capital_income_this_tick'):
+                owner.capital_income_this_tick += dividend_amount
+
+            self.retained_earnings -= dividend_amount
+            self.dividends_paid_last_tick += dividend_amount
+
+        return transactions
+
+    def generate_financial_transactions(self, government: Government, households: List[Household], current_time: int) -> List[Transaction]:
+        """Consolidates all financial outflow generation logic."""
+        transactions = []
+
+        # 1. Holding Costs
+        tx_holding = self.generate_holding_cost_transaction(government, current_time)
+        if tx_holding:
+            transactions.append(tx_holding)
+
+        # 2. Maintenance
+        tx_maint = self.generate_maintenance_transaction(government, current_time)
+        if tx_maint:
+            transactions.append(tx_maint)
+
+        # 3. Corporate Tax
+        tx_tax = self.generate_tax_transaction(government, current_time)
+        if tx_tax:
+            transactions.append(tx_tax)
+
+        # 4. Profit Distribution (Public)
+        txs_public = self.process_profit_distribution(households, government, current_time)
+        transactions.extend(txs_public)
+
+        return transactions
 
     def add_liability(self, amount: float, interest_rate: float):
         """Adds a liability (like a loan) to the firm's balance sheet."""
diff --git a/simulation/components/hr_department.py b/simulation/components/hr_department.py
index 9df0b10..5086c15 100644
--- a/simulation/components/hr_department.py
+++ b/simulation/components/hr_department.py
@@ -5,6 +5,7 @@ import logging
 if TYPE_CHECKING:
     from simulation.core_agents import Household
     from simulation.firms import Firm
+    from simulation.models import Transaction
 
 logger = logging.getLogger(__name__)
 
@@ -32,13 +33,14 @@ class HRDepartment:
 
         return base_wage * actual_skill * halo_modifier
 
-    def process_payroll(self, current_time: int, government: Optional[Any], market_data: Optional[Dict[str, Any]]) -> float:
+    def process_payroll(self, current_time: int, government: Optional[Any], market_data: Optional[Dict[str, Any]]) -> List[Transaction]:
         """
         Pays wages to employees. Handles insolvency firing if assets are insufficient.
-        Returns total wages paid.
+        Returns list of Transactions.
         """
-        total_wages = 0.0
-        total_tax_withheld = 0.0
+        from simulation.models import Transaction
+
+        generated_transactions: List[Transaction] = []
 
         # Calculate survival cost for tax logic
         survival_cost = 10.0 # Default fallback
@@ -61,7 +63,7 @@ class HRDepartment:
             base_wage = self.employee_wages.get(employee.id, self.firm.config_module.LABOR_MARKET_MIN_WAGE)
             wage = self.calculate_wage(employee, base_wage)
 
-            # Affordability Check
+            # Affordability Check (Optimistic)
             if self.firm.assets >= wage:
                 # Calculate Tax
                 income_tax = 0.0
@@ -70,41 +72,70 @@ class HRDepartment:
 
                 net_wage = wage - income_tax
 
-                # Transactions
-                self.firm._sub_assets(wage)
-                employee._add_assets(net_wage)
-
-                # Track Labor Income
+                # Transaction 1: Net Wage (Firm -> Employee)
+                tx_wage = Transaction(
+                    buyer_id=self.firm.id, # Payer
+                    seller_id=employee.id, # Payee
+                    item_id="labor_wage",
+                    quantity=1.0,
+                    price=net_wage,
+                    market_id="labor",
+                    transaction_type="wage",
+                    time=current_time
+                )
+                generated_transactions.append(tx_wage)
+
+                # Transaction 2: Income Tax (Firm -> Government) [Withholding]
+                if income_tax > 0 and government:
+                    tx_tax = Transaction(
+                        buyer_id=self.firm.id, # Payer
+                        seller_id=government.id, # Payee
+                        item_id="income_tax",
+                        quantity=1.0,
+                        price=income_tax,
+                        market_id="system",
+                        transaction_type="tax",
+                        time=current_time
+                    )
+                    generated_transactions.append(tx_tax)
+
+                # Track Labor Income (Side Effect)
                 if hasattr(employee, "labor_income_this_tick"):
                     employee.labor_income_this_tick += net_wage
 
-                if income_tax > 0 and government:
-                    government.collect_tax(income_tax, "income_tax", employee.id, current_time)
-                    total_tax_withheld += income_tax
-
-                total_wages += wage
             else:
                 # Insolvency Handling
-                self._handle_insolvency(employee, wage)
+                self._handle_insolvency_transactions(employee, wage, current_time, generated_transactions)
 
-        return total_wages
+        return generated_transactions
 
-    def _handle_insolvency(self, employee: Household, wage: float):
+    def _handle_insolvency_transactions(self, employee: Household, wage: float, current_time: int, tx_list: List[Transaction]):
         """
         Handles case where firm cannot afford wage.
         Attempts severance pay; if fails, zombie state (unpaid retention).
         """
+        from simulation.models import Transaction
+
         severance_weeks = getattr(self.firm.config_module, "SEVERANCE_PAY_WEEKS", 4)
         severance_pay = wage * severance_weeks
 
         if self.firm.assets >= severance_pay:
-            # Fire with severance
-            self.firm._sub_assets(severance_pay)
-            employee._add_assets(severance_pay)
+            # Fire with severance (Transaction)
+            tx = Transaction(
+                buyer_id=self.firm.id,
+                seller_id=employee.id,
+                item_id="severance_pay",
+                quantity=1.0,
+                price=severance_pay,
+                market_id="labor",
+                transaction_type="severance",
+                time=current_time
+            )
+            tx_list.append(tx)
 
             self.firm.logger.info(
                 f"SEVERANCE | Firm {self.firm.id} paid severance {severance_pay:.2f} to Household {employee.id}. Firing due to insolvency.",
-                extra={"tick": self.firm.decision_engine.context.current_time if hasattr(self.firm.decision_engine, 'context') else 0, "agent_id": self.firm.id, "severance_pay": severance_pay}
+                extra={"tick": current_time, "agent_id": self.firm.id, "severance_pay": severance_pay}
             )
 
             employee.quit()
diff --git a/simulation/firms.py b/simulation/firms.py
index 6691a86..805b5e3 100644
--- a/simulation/firms.py
+++ b/simulation/firms.py
@@ -30,6 +30,7 @@ if TYPE_CHECKING:
     from simulation.ai.firm_system2_planner import FirmSystem2Planner
     from simulation.markets.stock_market import StockMarket
     from simulation.agents.government import Government
+    from simulation.systems.reflux_system import EconomicRefluxSystem
     from simulation.dtos.scenario import StressScenarioConfig
 
 logger = logging.getLogger(__name__)
@@ -492,81 +493,51 @@ class Firm(BaseAgent, ILearningAgent):
             details=f"Item={self.specialization}, D={demand:.1f}, S={supply:.1f}, Ratio={excess_demand_ratio:.2f}"
         )
 
-    @override
-    def update_needs(self, current_time: int, government: Optional[Any] = None, market_data: Optional[Dict[str, Any]] = None, reflux_system: Optional[Any] = None, technology_manager: Optional[Any] = None) -> None:
-        self.age += 1
-        log_extra = {"tick": current_time, "agent_id": self.id, "tags": ["firm_needs"]}
-        # SoC Refactor
-        self.logger.debug(
-            f"FIRM_NEEDS_UPDATE_START | Firm {self.id} needs before update: Liquidity={self.needs['liquidity_need']:.1f}, Assets={self.assets:.2f}, Employees={len(self.hr.employees)}",
-            extra={
-                **log_extra,
-                "needs_before": self.needs,
-                "assets_before": self.assets,
-                "num_employees_before": len(self.hr.employees),
-            },
-        )
-
-        # --- Core Operations (SoC Refactor) ---
-        # 1. Produce
-        self.produce(current_time, technology_manager)
-
-        # 2. Pay Wages & Holding Costs
-        # WO-103 Phase 1: Delegated Holding Cost Calculation
-        holding_cost = self.finance.calculate_and_debit_holding_costs()
+    def generate_transactions(self, government: Optional[Government], market_data: Dict[str, Any], all_households: List[Household], current_time: int) -> List[Transaction]:
+        """
+        Generates all financial transactions for the tick (Wages, Taxes, Dividends, etc.).
+        Phase 3 Architecture.
+        """
+        transactions = []
 
-        if holding_cost > 0:
-            if reflux_system:
-                reflux_system.capture(holding_cost, str(self.id), "fixed_cost")
-            self.logger.info(
-                f"Paid inventory holding cost: {holding_cost:.2f}",
-                extra={**log_extra, "holding_cost": holding_cost},
-            )
+        # 1. Wages & Income Tax (HR)
+        tx_payroll = self.hr.process_payroll(current_time, government, market_data)
+        transactions.extend(tx_payroll)
 
-        total_wages = self.hr.process_payroll(current_time, government, market_data)
-        if total_wages > 0:
-            self.finance.record_expense(total_wages)
-            self.logger.info(
-                f"Paid total wages: {total_wages:.2f} to {len(self.hr.employees)} employees.",
-                extra={**log_extra, "total_wages": total_wages},
-            )
+        # 2. Finance Transactions (Holding, Maint, Corp Tax, Dividends, Bailout Repayment)
+        tx_finance = self.finance.generate_financial_transactions(government, all_households, current_time)
+        transactions.extend(tx_finance)
 
-        # 3. Marketing & Brand Update
-        marketing_spend = 0.0
-        # SoC Refactor
+        # 3. Marketing (Direct Calculation here as per old update_needs)
         if self.assets > 100.0:
             marketing_spend = max(10.0, self.finance.revenue_this_turn * self.marketing_budget_rate)
-        
+        else:
+            marketing_spend = 0.0
+
         if self.assets < marketing_spend:
              marketing_spend = 0.0
 
         if marketing_spend > 0:
-             # WO-103 Phase 1: Transactional method
-             self.finance.debit(marketing_spend, "Marketing")
-             self.finance.record_expense(marketing_spend)
-             if reflux_system:
-                 reflux_system.capture(marketing_spend, str(self.id), "marketing")
+            tx_marketing = self.finance.generate_marketing_transaction(government, current_time, marketing_spend)
+            if tx_marketing:
+                transactions.append(tx_marketing)
 
+        # State Update: Set budget for next decisions
         self.marketing_budget = marketing_spend
+        # Brand Update: Needs to happen (optimistic about spend success)
         self.brand_manager.update(marketing_spend, self.productivity_factor / 10.0)
-        self.sales.adjust_marketing_budget() # Note: Renamed from _adjust_marketing_budget
+        self.sales.adjust_marketing_budget()
 
-        # 4. Pay Taxes (after all other expenses)
-        if government:
-            self.finance.pay_maintenance(government, reflux_system, current_time)
-            self.finance.pay_taxes(government, current_time)
+        return transactions
 
-        brand_premium = self.calculate_brand_premium(market_data) if market_data else 0.0
-        self.logger.info(
-            f"FIRM_BRAND_METRICS | Firm {self.id}: Awareness={self.brand_manager.brand_awareness:.4f}, "
-            f"Quality={self.brand_manager.perceived_quality:.4f}, Premium={brand_premium:.2f}",
-            extra={
-                **log_extra,
-                "brand_awareness": self.brand_manager.brand_awareness,
-                "perceived_quality": self.brand_manager.perceived_quality,
-                "brand_premium": brand_premium
-            }
-        )
+    @override
+    def update_needs(self, current_time: int, government: Optional[Any] = None, market_data: Optional[Dict[str, Any]] = None, reflux_system: Optional[Any] = None, technology_manager: Optional[Any] = None) -> None:
+        """
+        Lifecycle updates (Age, Bankruptcy Check).
+        Financial transactions are now in generate_transactions.
+        Production is in produce.
+        """
+        self.age += 1
 
         # --- Final State Updates & Checks ---
         self.needs["liquidity_need"] = min(100.0, self.needs["liquidity_need"] + self.config_module.LIQUIDITY_NEED_INCREASE_RATE)
@@ -578,34 +549,26 @@ class Firm(BaseAgent, ILearningAgent):
             self.logger.warning(
                 f"FIRM_INACTIVE | Firm {self.id} closed down. Assets: {self.assets:.2f}, Consecutive Loss Turns: {self.finance.consecutive_loss_turns}",
                 extra={
-                    **log_extra,
+                    "tick": current_time,
+                    "agent_id": self.id,
                     "assets": self.assets,
                     "consecutive_loss_turns": self.finance.consecutive_loss_turns,
                     "tags": ["firm_closure"],
                 },
             )
 
-        self.logger.debug(
-            f"FIRM_NEEDS_UPDATE_END | Firm {self.id} needs after update: Liquidity={self.needs['liquidity_need']:.1f}, Assets={self.assets:.2f}, Employees={len(self.hr.employees)}, is_active={self.is_active}",
-            extra={
-                **log_extra,
-                "needs_after": self.needs,
-                "assets_after": self.assets,
-                "num_employees_after": len(self.hr.employees),
-                "is_active_after": self.is_active,
-                "brand_awareness": self.brand_manager.brand_awareness,
-                "perceived_quality": self.brand_manager.perceived_quality
-            },
-        )
-
     # Legacy: _pay_maintenance and _pay_taxes removed as they are now in FinanceDepartment
 
     def distribute_profit(self, agents: Dict[int, Any], current_time: int) -> float:
         """
-        Phase 14-1: Mandatory Dividend Rule.
-        Distribute surplus cash to owner if reserves are met.
+        Legacy method kept for compatibility but should use generate_transactions.
+        Calls distribute_profit_private which returns List[Transaction] now, but signature says float?
+        FinanceDepartment.distribute_profit_private returns List[Transaction].
+        So we cannot return float if we use it.
+        We will return 0.0 dummy or fix caller.
+        TickScheduler uses this method in old code. New code will use generate_transactions.
         """
-        return self.finance.distribute_profit_private(agents, current_time)
+        return 0.0
 
     def deposit(self, amount: float) -> None:
         """Deposits a given amount into the firm's cash reserves."""
diff --git a/simulation/systems/reflux_system.py b/simulation/systems/reflux_system.py
index 23b8f05..d468706 100644
--- a/simulation/systems/reflux_system.py
+++ b/simulation/systems/reflux_system.py
@@ -1,14 +1,35 @@
 from typing import List, Optional
 import logging
+from modules.finance.api import IFinancialEntity, InsufficientFundsError
 
 logger = logging.getLogger(__name__)
 
-class EconomicRefluxSystem:
+class EconomicRefluxSystem(IFinancialEntity):
     def __init__(self):
+        self._id = 999999 # Special ID for Reflux
         self.balance: float = 0.0
         # Optional: Transaction log for debugging
         # self.transaction_log: list = []
 
+    @property
+    def id(self) -> int:
+        return self._id
+
+    @property
+    def assets(self) -> float:
+        return self.balance
+
+    def deposit(self, amount: float) -> None:
+        """IFinancialEntity implementation."""
+        if amount > 0:
+            self.capture(amount, "System", "Deposit")
+
+    def withdraw(self, amount: float) -> None:
+        """IFinancialEntity implementation."""
+        if self.balance < amount:
+            raise InsufficientFundsError(f"RefluxSystem has insufficient funds.")
+        self.balance -= amount
+
     def capture(self, amount: float, source: str, category: str):
         """
         Captures money that would otherwise vanish.
@@ -38,6 +59,12 @@ class EconomicRefluxSystem:
         amount_per_household = total_amount / len(active_households)
 
         for agent in active_households:
+            # We use _add_assets for now as this is a distribution phase separate from transactions?
+            # Or should we generate transactions?
+            # Reflux distribute happens in Phase 4 (Lifecycle/Post-Processing) in TickScheduler.
+            # So direct modification is acceptable here as it's outside the Transaction Phase strictness?
+            # Ideally yes, or we move it to Transaction Phase.
+            # For now, leaving as direct modification (Legacy).
             agent._add_assets(amount_per_household)
 
             # Record as additional labor income (Service Sector)
diff --git a/simulation/tick_scheduler.py b/simulation/tick_scheduler.py
index e40f400..f7f01b0 100644
--- a/simulation/tick_scheduler.py
+++ b/simulation/tick_scheduler.py
@@ -79,18 +79,58 @@ class TickScheduler:
         ):
             state.ai_training_manager.run_imitation_learning_cycle(state.time)
 
-        # Update Bank Tick (Interest Processing)
-        if hasattr(state.bank, "run_tick") and "reflux_system" in state.bank.run_tick.__code__.co_varnames:
-             state.bank.run_tick(state.agents, state.time, reflux_system=state.reflux_system)
-        elif hasattr(state.bank, "run_tick") and "current_tick" in state.bank.run_tick.__code__.co_varnames:
-             state.bank.run_tick(state.agents, state.time)
-        else:
-             state.bank.run_tick(state.agents)
+        # ==================================================================================
+        # WO-116 Phase B: Transaction Generation Phase (System Transactions)
+        # ==================================================================================
+        system_transactions: List[Transaction] = []
+
+        # 0. Firm Production (State Update: Inventory)
+        for firm in state.firms:
+             if firm.is_active:
+                 firm.produce(state.time, technology_manager=state.technology_manager)
 
-        # Phase 14-1: Firm Profit Distribution (Operation Reflux)
+        # 1. Bank Tick (Interest)
+        if hasattr(state.bank, "run_tick"):
+             bank_txs = state.bank.run_tick(state.agents, state.time, reflux_system=state.reflux_system)
+             system_transactions.extend(bank_txs)
+
+        # 2. Firm Financials (Wages, Taxes, Dividends) - Requires Market Data (T-1)
+        market_data_prev = self.prepare_market_data(state.tracker)
         for firm in state.firms:
-             firm.distribute_profit(state.agents, state.time)
+             if firm.is_active:
+                 firm_txs = firm.generate_transactions(
+                     government=state.government,
+                     market_data=market_data_prev,
+                     all_households=state.households,
+                     current_time=state.time
+                 )
+                 system_transactions.extend(firm_txs)
+
+        # 3. Debt Service
+        debt_txs = state.finance_system.service_debt(state.time)
+        system_transactions.extend(debt_txs)
+
+        # 4. Welfare & Taxes (Wealth)
+        welfare_txs = state.government.run_welfare_check(list(state.agents.values()), market_data_prev, state.time)
+        system_transactions.extend(welfare_txs)
+
+        # 5. Infrastructure
+        infra_success, infra_txs = state.government.invest_infrastructure(state.time, state.reflux_system)
+        if infra_txs:
+            system_transactions.extend(infra_txs)
+
+        if infra_success:
+            tfp_boost = getattr(state.config_module, "INFRASTRUCTURE_TFP_BOOST", 0.05)
+            for firm in state.firms:
+                firm.productivity_factor *= (1.0 + tfp_boost)
+            state.logger.info(
+                f"GLOBAL_TFP_BOOST | All firms productivity increased by {tfp_boost*100:.1f}%",
+                extra={"tick": state.time, "tags": ["government", "infrastructure"]}
+            )
 
+        # ----------------------------------------------------------------------------------
+
+        # Cleanup Orders (Reset for new tick)
         for firm in state.firms:
             firm.hires_last_tick = 0
 
@@ -167,10 +207,8 @@ class TickScheduler:
 
         # [DEBUG WO-057]
         latest_indicators = state.tracker.get_latest_indicators()
-        avg_price = latest_indicators.get('avg_goods_price', 'MISSING')
-        inf_sma = sensory_dto.inflation_sma if isinstance(sensory_dto.inflation_sma, (int, float)) else 0.0
 
-        # 3. Government Makes Policy Decision
+        # 3. Government Makes Policy Decision (Act)
         latest_gdp = state.tracker.get_latest_indicators().get("total_production", 0.0)
         market_data["total_production"] = latest_gdp
 
@@ -184,15 +222,17 @@ class TickScheduler:
         # 4. Election Check
         state.government.check_election(state.time)
 
-        # Age firms
-        for firm in state.firms:
-            firm.age += 1
+        # Age firms (moved to Lifecycle/UpdateNeeds but kept partly here?)
+        # We handle 'age += 1' in firm.update_needs called in Lifecycle.
+        # So we can remove this loop.
+        # for firm in state.firms:
+        #    firm.age += 1
 
-        # Service national debt
-        state.finance_system.service_debt(state.time)
+        # Service national debt -> Moved to Transaction Gen
+        # state.finance_system.service_debt(state.time)
 
-        # Phase 4: Welfare Check
-        state.government.run_welfare_check(list(state.agents.values()), market_data, state.time)
+        # Phase 4: Welfare Check -> Moved to Transaction Gen
+        # state.government.run_welfare_check(list(state.agents.values()), market_data, state.time)
 
         # Snapshot agents for learning (Pre-state)
         for f in state.firms:
@@ -237,7 +277,7 @@ class TickScheduler:
         self._phase_matching(sim_state)
 
         # 3. Transactions
-        self._phase_transactions(sim_state)
+        self._phase_transactions(sim_state, system_transactions)
 
         # 4. Lifecycle
         self._phase_lifecycle(sim_state)
@@ -309,29 +349,13 @@ class TickScheduler:
         # ---------------------------------------------------------
         for firm in state.firms:
              if firm.is_active:
-                 firm.produce(state.time, technology_manager=state.technology_manager)
+                 # firm.produce -> Moved to Pre-Decision
+                 # firm.update_needs -> Refactored to only do Lifecycle state updates (not financial)
                  firm.update_needs(state.time, state.government, market_data, state.reflux_system)
 
-                 # 2a. Corporate Tax
-                 if firm.is_active and firm.current_profit > 0:
-                     tax_amount = state.government.calculate_corporate_tax(firm.current_profit)
-                     if state.settlement_system:
-                         state.settlement_system.transfer(firm, state.government, tax_amount, "corporate_tax")
-                     else:
-                         # Fallback
-                         firm._sub_assets(tax_amount)
-                         state.government._add_assets(tax_amount)
-                     state.government.collect_tax(tax_amount, "corporate_tax", firm.id, state.time)
-
-        # 2b. Government Infra Investment
-        if state.government.invest_infrastructure(state.time, state.reflux_system):
-            tfp_boost = getattr(state.config_module, "INFRASTRUCTURE_TFP_BOOST", 0.05)
-            for firm in state.firms:
-                firm.productivity_factor *= (1.0 + tfp_boost)
-            state.logger.info(
-                f"GLOBAL_TFP_BOOST | All firms productivity increased by {tfp_boost*100:.1f}%",
-                extra={"tick": state.time, "tags": ["government", "infrastructure"]}
-            )
+                 # Corporate Tax -> Removed (Handled in Transaction Generation)
+
+                 # Gov Infra -> Removed (Handled in Pre-Decision)
 
         # --- AI Learning Update (Unified) ---
         market_data_for_learning = self.prepare_market_data(state.tracker)
@@ -603,8 +627,12 @@ class TickScheduler:
 
         state.transactions = all_transactions
 
-    def _phase_transactions(self, state: SimulationState) -> None:
+    def _phase_transactions(self, state: SimulationState, system_transactions: List[Transaction] = []) -> None:
         """Phase 3: Execute transactions."""
+        # Merge system transactions
+        if system_transactions:
+            state.transactions.extend(system_transactions)
+
         # Use the system service directly via WorldState (or passed if added to DTO)
         if self.world_state.transaction_processor:
             self.world_state.transaction_processor.execute(state)
diff --git a/tests/integration/test_tick_normalization.py b/tests/integration/test_tick_normalization.py
new file mode 100644
index 0000000..edae4a4
--- /dev/null
+++ b/tests/integration/test_tick_normalization.py
@@ -0,0 +1,129 @@
+import pytest
+from unittest.mock import MagicMock, Mock
+from simulation.tick_scheduler import TickScheduler
+from simulation.models import Transaction
+from simulation.world_state import WorldState
+from simulation.dtos.api import SimulationState
+
+class TestTickNormalization:
+    @pytest.fixture
+    def mock_world_state(self):
+        # Remove spec=WorldState to avoid AttributeError on missing attributes like social_system
+        state = MagicMock()
+        state.time = 0
+        state.agents = {}
+        state.firms = []
+        state.households = []
+        state.markets = {}
+        state.transactions = []
+
+        # Components
+        state.bank = MagicMock()
+        # Mock run_tick to return a test transaction
+        state.bank.run_tick.return_value = [
+            Transaction(0, 1, "test_item", 1.0, 10.0, "financial", "test_type", 0)
+        ]
+
+        state.finance_system = MagicMock()
+        state.finance_system.service_debt.return_value = []
+
+        state.government = MagicMock()
+        state.government.run_welfare_check.return_value = []
+        # Return (success, txs)
+        state.government.invest_infrastructure.return_value = (True, [])
+        # Fix: Mock get_monetary_delta to return float
+        state.government.get_monetary_delta.return_value = 0.0
+
+        state.tracker = MagicMock()
+        state.tracker.get_latest_indicators.return_value = {}
+
+        state.transaction_processor = MagicMock()
+
+        # Mocks needed for sim_state construction
+        state.config_module = MagicMock()
+        state.config_module.INFRASTRUCTURE_TFP_BOOST = 0.05
+        state.config_module.IMITATION_LEARNING_INTERVAL = 100 # Avoid modulo error if any
+
+        state.logger = MagicMock()
+        state.reflux_system = MagicMock()
+        state.central_bank = MagicMock()
+        state.stock_market = None
+        state.goods_data = []
+        state.next_agent_id = 100
+        state.real_estate_units = []
+
+        # Tech manager
+        state.technology_manager = MagicMock()
+
+        # Systems
+        state.ma_manager = MagicMock()
+        state.event_system = None
+        state.commerce_system = None
+        state.housing_system = MagicMock()
+        state.crisis_monitor = None
+        state.generational_wealth_audit = None
+
+        # Fix format issue
+        state.calculate_total_money = MagicMock(return_value=1000.0)
+        state.baseline_money_supply = 1000.0
+
+        return state
+
+    @pytest.fixture
+    def scheduler(self, mock_world_state):
+        processor = MagicMock()
+        return TickScheduler(mock_world_state, processor)
+
+    def test_run_tick_collects_transactions(self, scheduler, mock_world_state):
+        # Setup Firm
+        mock_firm = MagicMock()
+        mock_firm.id = 50
+        mock_firm.is_active = True
+        # Mock generate_transactions to return a tax transaction
+        mock_firm.generate_transactions.return_value = [
+            Transaction(50, 0, "corporate_tax", 1.0, 50.0, "system", "tax", 0)
+        ]
+        # Mock produce
+        mock_firm.produce = MagicMock()
+        mock_firm.update_needs = MagicMock()
+
+        # Add firm to state
+        mock_world_state.firms = [mock_firm]
+        mock_world_state.agents = {50: mock_firm}
+
+        # Prepare mock for _phase_decisions to avoid errors
+        # (It returns tuple of dicts)
+        scheduler._phase_decisions = MagicMock(return_value=({}, {}, {}))
+        scheduler._phase_matching = MagicMock()
+        scheduler._phase_lifecycle = MagicMock()
+        scheduler.prepare_market_data = MagicMock(return_value={})
+
+        # Act
+        scheduler.run_tick()
+
+        # Assertions
+
+        # 1. Firm Produce called (Pre-Decision)
+        mock_firm.produce.assert_called_once()
+
+        # 2. Bank run_tick called
+        mock_world_state.bank.run_tick.assert_called_once()
+
+        # 3. Firm generate_transactions called
+        mock_firm.generate_transactions.assert_called_once()
+
+        # 4. Check TransactionProcessor call
+        assert mock_world_state.transaction_processor.execute.called
+
+        # Verify passed transactions
+        args, _ = mock_world_state.transaction_processor.execute.call_args
+        sim_state_dto = args[0]
+        assert isinstance(sim_state_dto, SimulationState)
+
+        transactions = sim_state_dto.transactions
+        # Should contain Bank Tx (1) + Firm Tx (1) = 2
+        assert len(transactions) >= 2
+
+        tx_types = [tx.transaction_type for tx in transactions]
+        assert "test_type" in tx_types
+        assert "tax" in tx_types
diff --git a/tests/modules/finance/test_double_entry.py b/tests/modules/finance/test_double_entry.py
index 9820039..84140da 100644
--- a/tests/modules/finance/test_double_entry.py
+++ b/tests/modules/finance/test_double_entry.py
@@ -1,30 +1,26 @@
 import unittest
 from unittest.mock import MagicMock
-
-# Mock necessary modules and classes that FinanceSystem depends on
 from modules.finance.system import FinanceSystem
 from modules.finance.api import InsufficientFundsError
+from simulation.models import Transaction
 
 # Mock objects that will be passed to FinanceSystem
 class MockGovernment:
     def __init__(self, initial_assets):
+        self.id = 0
         self._assets = initial_assets
+        self.sensory_data = None
     @property
     def assets(self): return self._assets
     def get_debt_to_gdp_ratio(self):
         return 0.5
+    # Deprecated methods for Phase 3 but kept for interface compliance
     def deposit(self, amount): self._assets += amount
-    def withdraw(self, amount):
-        if self._assets < amount:
-            raise InsufficientFundsError()
-        self._assets -= amount
-    # Interface compatibility
-    def _add_assets(self, amount): self._assets += amount
-    def _sub_assets(self, amount): self._assets -= amount
-
+    def withdraw(self, amount): self._assets -= amount
 
 class MockCentralBank:
     def __init__(self, initial_cash):
+        self.id = 999
         self._assets = {"cash": initial_cash, "bonds": []}
     @property
     def assets(self): return self._assets
@@ -32,25 +28,18 @@ class MockCentralBank:
         return 0.01
     def purchase_bonds(self, bond):
         self.assets["bonds"].append(bond)
+    # Mocking IFinancialEntity behavior loosely
     def deposit(self, amount): self.assets['cash'] += amount
-    def withdraw(self, amount):
-        if self.assets['cash'] < amount:
-            raise InsufficientFundsError()
-        self.assets['cash'] -= amount
-    # Central Bank mock uses dict for assets, complicated to verify against IFinancialEntity, ignoring for now
+    def withdraw(self, amount): self.assets['cash'] -= amount
 
 class MockBank:
     def __init__(self, initial_assets):
+        self.id = 1
         self._assets = initial_assets
     @property
     def assets(self): return self._assets
     def deposit(self, amount): self._assets += amount
-    def withdraw(self, amount):
-        if self._assets < amount:
-            raise InsufficientFundsError()
-        self._assets -= amount
-    def _add_assets(self, amount): self._assets += amount
-    def _sub_assets(self, amount): self._assets -= amount
+    def withdraw(self, amount): self._assets -= amount
 
 class MockFirm:
     def __init__(self, id, initial_cash_reserve):
@@ -59,11 +48,11 @@ class MockFirm:
         # Mock the finance component of the firm
         self.finance = MagicMock()
         self.has_bailout_loan = False
+        self.age = 100
+    @property
+    def assets(self): return self.cash_reserve
     def deposit(self, amount): self.cash_reserve += amount
-    def withdraw(self, amount):
-        if self.cash_reserve < amount:
-            raise InsufficientFundsError()
-        self.cash_reserve -= amount
+    def withdraw(self, amount): self.cash_reserve -= amount
 
 class MockConfig:
     QE_INTERVENTION_YIELD_THRESHOLD = 0.05
@@ -83,6 +72,12 @@ class MockConfig:
             return self.DEBT_RISK_PREMIUM_TIERS
         if key == "economy_params.QE_INTERVENTION_YIELD_THRESHOLD":
             return self.QE_INTERVENTION_YIELD_THRESHOLD
+        if key == "economy_params.STARTUP_GRACE_PERIOD_TICKS":
+            return 24
+        if key == "economy_params.ALTMAN_Z_SCORE_THRESHOLD":
+            return 1.81
+        if key == "economy_params.BOND_MATURITY_TICKS":
+            return 400
         return default
 
 
@@ -102,86 +97,84 @@ class TestDoubleEntry(unittest.TestCase):
             config_module=self.mock_config
         )
 
-    def test_bailout_loan_maintains_money_supply(self):
+        # Mock FiscalMonitor to redirect to Gov mock method
+        self.finance_system.fiscal_monitor = MagicMock()
+        self.finance_system.fiscal_monitor.get_debt_to_gdp_ratio.side_effect = lambda gov, dto: gov.get_debt_to_gdp_ratio()
+
+    def test_bailout_loan_generates_transaction(self):
         """
-        Verify that granting a bailout loan correctly transfers assets
-        without changing the total money supply.
+        Verify that granting a bailout loan generates a Transaction
+        and does NOT modify assets directly (Deferred).
         """
-        initial_total_assets = self.mock_gov.assets + self.mock_firm.cash_reserve
+        initial_gov_assets = self.mock_gov.assets
+        initial_firm_cash = self.mock_firm.cash_reserve
         bailout_amount = 500
 
-        self.finance_system.grant_bailout_loan(self.mock_firm, bailout_amount)
+        loan, txs = self.finance_system.grant_bailout_loan(self.mock_firm, bailout_amount, current_tick=1)
 
         # Assertions
-        self.assertEqual(self.mock_gov.assets, 10000 - bailout_amount)
-        self.assertEqual(self.mock_firm.cash_reserve, 100 + bailout_amount)
+        # Assets Unchanged
+        self.assertEqual(self.mock_gov.assets, initial_gov_assets)
+        self.assertEqual(self.mock_firm.cash_reserve, initial_firm_cash)
+
+        # Transaction Generated
+        self.assertEqual(len(txs), 1)
+        tx = txs[0]
+        self.assertEqual(tx.buyer_id, self.mock_gov.id)
+        self.assertEqual(tx.seller_id, self.mock_firm.id)
+        self.assertEqual(tx.price, bailout_amount)
 
-        final_total_assets = self.mock_gov.assets + self.mock_firm.cash_reserve
-        self.assertEqual(initial_total_assets, final_total_assets)
+        # State Update (Optimistic)
         self.assertTrue(self.mock_firm.has_bailout_loan)
         self.mock_firm.finance.add_liability.assert_called_once()
 
-    def test_qe_bond_issuance_maintains_money_supply(self):
+    def test_qe_bond_issuance_generates_transaction(self):
         """
-        Verify that issuing bonds under QE correctly transfers assets
-        from the Central Bank to the Government.
+        Verify that issuing bonds under QE generates correct transaction.
         """
         # Force high yield to trigger QE
         self.mock_gov.get_debt_to_gdp_ratio = lambda: 1.5
 
-        initial_total_assets = self.mock_gov.assets + self.mock_cb.assets['cash']
+        initial_gov_assets = self.mock_gov.assets
+        initial_cb_cash = self.mock_cb.assets['cash']
         bond_amount = 1000
 
-        self.finance_system.issue_treasury_bonds(bond_amount, current_tick=1)
+        bonds, txs = self.finance_system.issue_treasury_bonds(bond_amount, current_tick=1)
 
         # Assertions
-        self.assertEqual(self.mock_gov.assets, 10000 + bond_amount)
-        self.assertEqual(self.mock_cb.assets['cash'], 5000 - bond_amount)
+        # Assets Unchanged
+        self.assertEqual(self.mock_gov.assets, initial_gov_assets)
+        self.assertEqual(self.mock_cb.assets['cash'], initial_cb_cash)
 
-        final_total_assets = self.mock_gov.assets + self.mock_cb.assets['cash']
-        self.assertEqual(initial_total_assets, final_total_assets)
-        self.assertEqual(len(self.mock_cb.assets['bonds']), 1)
+        # Transaction Generated (Buyer -> Gov)
+        self.assertEqual(len(txs), 1)
+        tx = txs[0]
+        self.assertEqual(tx.buyer_id, self.mock_cb.id) # Central Bank buys
+        self.assertEqual(tx.seller_id, self.mock_gov.id)
+        self.assertEqual(tx.price, bond_amount)
 
-    def test_market_bond_issuance_maintains_money_supply(self):
+    def test_market_bond_issuance_generates_transaction(self):
         """
-        Verify that issuing bonds to the market correctly transfers assets
-        from the commercial bank to the Government.
+        Verify that issuing bonds to the market generates correct transaction.
         """
         # Ensure low yield to avoid QE
         self.mock_gov.get_debt_to_gdp_ratio = lambda: 0.5
 
-        initial_total_assets = self.mock_gov.assets + self.mock_bank.assets
-        bond_amount = 2000
-
-        self.finance_system.issue_treasury_bonds(bond_amount, current_tick=1)
-
-        # Assertions
-        self.assertEqual(self.mock_gov.assets, 10000 + bond_amount)
-        self.assertEqual(self.mock_bank.assets, 20000 - bond_amount)
-
-        final_total_assets = self.mock_gov.assets + self.mock_bank.assets
-        self.assertEqual(initial_total_assets, final_total_assets)
-
-
-    def test_transfer_fails_on_insufficient_funds(self):
-        """
-        Verify that a transfer does not occur if the debtor has insufficient funds.
-        """
-        # Government has 10000, Firm has 100
         initial_gov_assets = self.mock_gov.assets
-        initial_firm_cash = self.mock_firm.cash_reserve
-
-        # Try to grant a bailout that the government cannot afford
-        bailout_amount = 15000
+        initial_bank_assets = self.mock_bank.assets
+        bond_amount = 2000
 
-        # The grant_bailout_loan should fail because the _transfer will return False
-        loan = self.finance_system.grant_bailout_loan(self.mock_firm, bailout_amount)
+        bonds, txs = self.finance_system.issue_treasury_bonds(bond_amount, current_tick=1)
 
         # Assertions
-        self.assertIsNone(loan)
         self.assertEqual(self.mock_gov.assets, initial_gov_assets)
-        self.assertEqual(self.mock_firm.cash_reserve, initial_firm_cash)
-        self.assertFalse(self.mock_firm.has_bailout_loan)
+        self.assertEqual(self.mock_bank.assets, initial_bank_assets)
+
+        self.assertEqual(len(txs), 1)
+        tx = txs[0]
+        self.assertEqual(tx.buyer_id, self.mock_bank.id) # Bank buys
+        self.assertEqual(tx.seller_id, self.mock_gov.id)
+        self.assertEqual(tx.price, bond_amount)
 
 if __name__ == '__main__':
     unittest.main()
diff --git a/tests/test_bank.py b/tests/test_bank.py
index 4d37834..f8bdb2e 100644
--- a/tests/test_bank.py
+++ b/tests/test_bank.py
@@ -166,3 +166,38 @@ class TestBank:
     def test_financial_entity_withdraw_insufficient(self, bank_instance):
         with pytest.raises(InsufficientFundsError):
             bank_instance.withdraw(bank_instance.assets + 1000.0)
+
+    def test_run_tick_returns_transactions(self, bank_instance):
+        # Setup: Loan and Deposit
+        borrower_id = 101
+        depositor_id = 202
+
+        bank_instance.grant_loan(borrower_id, 1000.0)
+        bank_instance.deposit_from_customer(depositor_id, 500.0)
+
+        # Mock Agents
+        mock_borrower = MagicMock()
+        mock_borrower.id = borrower_id
+        mock_borrower.assets = 100.0 # Enough to pay interest
+        mock_borrower.is_active = True
+
+        mock_depositor = MagicMock()
+        mock_depositor.id = depositor_id
+        mock_depositor.is_active = True
+
+        agents = {borrower_id: mock_borrower, depositor_id: mock_depositor}
+
+        # Act
+        transactions = bank_instance.run_tick(agents, current_tick=1)
+
+        # Assert
+        assert len(transactions) >= 2 # Interest Payment (Loan) + Interest Payment (Deposit)
+
+        # Check types
+        tx_types = [tx.transaction_type for tx in transactions]
+        assert "loan_interest" in tx_types
+        assert "deposit_interest" in tx_types
+
+        # Check assets NOT modified
+        # (Assuming initial assets = 10000.0)
+        assert bank_instance.assets == 10000.0
diff --git a/tests/test_government_fiscal_policy.py b/tests/test_government_fiscal_policy.py
index 4a11fd0..817e5eb 100644
--- a/tests/test_government_fiscal_policy.py
+++ b/tests/test_government_fiscal_policy.py
@@ -1,5 +1,7 @@
 import pytest
 from unittest.mock import Mock
+from simulation.models import Transaction
+from simulation.agents.government import Government
 
 def test_tax_collection_and_bailouts(government):
     """
@@ -8,12 +10,10 @@ def test_tax_collection_and_bailouts(government):
     """
     initial_gov_assets = government.assets
 
-    # 1. Manual Tax Collection Test
+    # 1. Manual Tax Collection Test (Legacy direct call)
     government.collect_tax(100.0, "test_tax", 1, 1)
-    assert government.assets == initial_gov_assets + 100.0
-    assert government.total_collected_tax == 100.0
 
-    # 2. Bailout Test (now a loan, not a subsidy)
+    # 2. Bailout Test (now a loan, returns transactions)
     mock_firm = Mock()
     mock_firm.id = 101
     mock_firm._assets = 1000.0
@@ -22,41 +22,49 @@ def test_tax_collection_and_bailouts(government):
     # Mock the finance system to approve the bailout
     government.finance_system.evaluate_solvency.return_value = True
 
-    # This is the key fix: the grant_bailout_loan method *itself* should
-    # have the side effect of decreasing the government's assets.
-    def grant_loan_side_effect(firm, amount):
-        government._assets -= amount
-        return Mock()
+    # Mock grant_bailout_loan to return (loan, txs)
+    loan_dto = Mock()
+    tx_list = [Mock(spec=Transaction)]
+    government.finance_system.grant_bailout_loan.return_value = (loan_dto, tx_list)
 
-    government.finance_system.grant_bailout_loan = Mock(side_effect=grant_loan_side_effect)
+    result_loan, result_txs = government.provide_firm_bailout(mock_firm, 50.0, 1)
 
-    government.provide_firm_bailout(mock_firm, 50.0, 1)
-
-    # Now the assertion is correct, because the side effect has been applied.
-    assert government.assets == initial_gov_assets + 100.0 - 50.0
+    assert result_loan == loan_dto
+    assert result_txs == tx_list
     government.finance_system.grant_bailout_loan.assert_called_once()
 
 
-def test_infrastructure_investment(government):
+def test_infrastructure_investment():
     """
     Tests that infrastructure investment decreases government assets and
     increases the infrastructure level.
+    Uses explicit instantiation to avoid fixture ambiguity.
     """
-    # This test no longer checks for TFP boost directly, as that's an
-    # integration effect. It now unit-tests the government's action.
+    config_mock = Mock()
+    config_mock.INFRASTRUCTURE_INVESTMENT_COST = 5000.0
+    config_mock.TICKS_PER_YEAR = 100 # Required for TaylorRulePolicy init
+
+    gov = Government(id=1, initial_assets=6000.0, config_module=config_mock)
+
+    # Needs finance system mock
+    gov.finance_system = Mock()
+    gov.finance_system.issue_treasury_bonds.return_value = ([], [])
+
+    gov.firm_subsidy_budget_multiplier = 1.0
 
-    # Mock config for investment cost
-    government.config_module.INFRASTRUCTURE_INVESTMENT_COST = 5000.0
-    government._assets = 6000.0
-    initial_assets = government.assets
-    initial_level = government.infrastructure_level
+    initial_assets = gov.assets
+    initial_level = gov.infrastructure_level
 
-    # Mock successful bond issuance in case assets are not enough
-    # (though they are in this setup)
-    government.finance_system.issue_treasury_bonds.return_value = [Mock()]
+    invested_result = gov.invest_infrastructure(current_tick=1)
 
-    invested = government.invest_infrastructure(current_tick=1)
+    assert isinstance(invested_result, tuple)
+    success, txs = invested_result
+    assert success is True
+    assert isinstance(txs, list)
 
-    assert invested is True
-    assert government.assets == initial_assets - 5000.0
-    assert government.infrastructure_level == initial_level + 1
+    # In Normalized Tick Phase B, Invest Infrastructure returns Transactions.
+    # It NO LONGER executes self.withdraw() immediately (side effect removed).
+    # So gov.assets should REMAIN UNCHANGED at this step.
+    # The transaction will reduce assets when processed.
+    assert gov.assets == initial_assets
+    assert gov.infrastructure_level == initial_level + 1
