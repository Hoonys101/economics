diff --git a/design/audits/FINAL_DRIFT_FIX.md b/design/audits/FINAL_DRIFT_FIX.md
new file mode 100644
index 0000000..e6f7625
--- /dev/null
+++ b/design/audits/FINAL_DRIFT_FIX.md
@@ -0,0 +1,31 @@
+# Final Zero-Sum Drift Fix
+
+## Diagnosis
+A recurring positive money leak (Drift > 0) was observed in the simulation, specifically correlated with `Government.invest_infrastructure` calls. The reported drift was `+299.7760` (and `+289.2640` in some logs) for a `5000.0` investment.
+
+### Investigation
+1.  **Transaction Logic**: The existing code generated a `Transaction` of type `infrastructure` from Government to `EconomicRefluxSystem`.
+2.  **Transaction Processor**: The processor handles this type via a generic fallback, calling `settlement_system.transfer`.
+3.  **Reflux System**: Upon deposit, `RefluxSystem` captures the funds and later distributes them to households.
+4.  **Leak Analysis**:
+    *   The drift amount (`299.7760`) is remarkably specific. It does not match simple tax rates (5%, 10%) exactly on 5000.
+    *   The drift represents a *creation* of money (`M2` increases more than expected).
+    *   Since the `TransactionProcessor` logic involves complex conditional checks (tax, goods, labor), there is a risk that the `infrastructure` transaction is triggering a side effect (e.g., Phantom Tax, or misclassification) or that `RefluxSystem.capture` is being triggered twice in a race condition or accounting error.
+
+## Solution
+To guarantee zero-sum integrity for this critical internal transfer, we will **bypass the `TransactionProcessor`** for the infrastructure investment payment itself.
+
+Instead of generating a `Transaction` object that might be misinterpreted, `Government.invest_infrastructure` will explicitly call `self.settlement_system.transfer()`.
+
+### Benefits
+1.  **Atomicity**: `SettlementSystem.transfer` guarantees that `Government` assets are decremented exactly by the amount `RefluxSystem` assets are incremented.
+2.  **Isolation**: Prevents `TransactionProcessor` from applying sales tax or other logic to this internal transfer.
+3.  **Clarity**: Explicitly models the action as a direct fiscal transfer rather than a market "trade".
+
+## Implementation
+Modify `simulation/agents/government.py`:
+- In `invest_infrastructure`:
+    - Check for `self.settlement_system` and `reflux_system`.
+    - Execute direct transfer.
+    - Omit the `infrastructure` transaction from the returned list.
+    - Retain `bond` issuance transactions if needed.
diff --git a/simulation/agents/government.py b/simulation/agents/government.py
index 413a623..09c0286 100644
--- a/simulation/agents/government.py
+++ b/simulation/agents/government.py
@@ -472,33 +472,34 @@ class Government:
             transactions.extend(txs)
             potential_revenue = needed # Assume success
 
-        # Generate Investment Transaction (Gov -> Reflux)
-        # Using RefluxSystem ID (999999) as Receiver
-        reflux_id = 999999
-        if reflux_system and hasattr(reflux_system, 'id'):
-            reflux_id = reflux_system.id
-
-        tx = Transaction(
-            buyer_id=self.id, # Government Pays
-            seller_id=reflux_id, # Reflux Receives
-            item_id="infrastructure_investment",
-            quantity=1.0,
-            price=effective_cost,
-            market_id="system",
-            transaction_type="infrastructure",
-            time=current_tick
+        # WO-Fix: Bypass TransactionProcessor for internal transfers to prevent zero-sum drift (phantom tax/leaks)
+        # We execute the transfer directly using SettlementSystem.
+        # Fallback to Transaction logic is REMOVED to prevent recurring drift bugs.
+
+        if not self.settlement_system or not reflux_system:
+             logger.critical(
+                 "INFRASTRUCTURE_ABORTED | Missing SettlementSystem or RefluxSystem. "
+                 "Cannot execute zero-sum investment.",
+                 extra={"tick": current_tick, "agent_id": self.id}
+             )
+             return False, []
+
+        transfer_success = self.settlement_system.transfer(
+             self,
+             reflux_system,
+             effective_cost,
+             "Infrastructure Investment (Direct)"
         )
-        transactions.append(tx)
-
-        self.expenditure_this_tick += effective_cost
 
-        # We do NOT call reflux_system.capture here because the Transaction will deposit to Reflux.
-        # RefluxSystem.deposit calls capture.
+        if not transfer_success:
+             logger.error(f"INFRASTRUCTURE_FAIL | Settlement transfer failed.")
+             return False, []
 
+        self.expenditure_this_tick += effective_cost
         self.infrastructure_level += 1
 
         logger.info(
-            f"INFRASTRUCTURE_INVESTED | Level {self.infrastructure_level} reached. Generated tx for {effective_cost}",
+            f"INFRASTRUCTURE_INVESTED | Level {self.infrastructure_level} reached. Cost: {effective_cost}",
             extra={
                 "tick": current_tick,
                 "agent_id": self.id,
