diff --git a/communications/team_assignments.json b/communications/team_assignments.json
index 4585587..0112a32 100644
--- a/communications/team_assignments.json
+++ b/communications/team_assignments.json
@@ -21,18 +21,6 @@
       "5173331688343789029": {
         "title": "WO-113-Sovereign-Debt",
         "initial_mission": "Phase 26.5: Sovereign Debt & Corporate Finance 시스템을 구현하라. | 1. `design/specs/Phase26-Sovereign-Debt-Spec.md`와 `design/work_orders/WO-113-Sovereign-Debt.md`를 필독하라. | 2. `FiscalMonitor`를 구현하여 정부의 재정 건전성을 모니터링하라. | 3. `FinanceSystem`에 국채 발행(`issue_treasury_bonds`)과 법인세 징수(`collect_corporate_tax`) 로직을 구현하되, 반드시 `SettlementSystem`을 사용해 원자적으로 처리하라. | 4. `Government` 에이전트에서 직접적인 자산 수정을 모두 제거하고 `FinanceSystem`에 위임하라. | 5. '실무자 보고서'에 구현 중 발견한 특이사항을 기록하라."
-      },
-      "2513104936953701906": {
-        "title": "WO-114_DTO_Purity_Gate_Completion",
-        "initial_mission": "Work Order WO-114-DTO-Purity-Gate-Completion.md에 따라 DTO Purity Gate 리팩토링을 완료하라. | 1. 모든 의사결정 엔진이 context.state와 context.config만 사용하도록 전환. | 2. 에이전트 인스턴스 직접 참조 제거. | 3. 단위 테스트 수정 및 Purity Gate 검증 테스트 추가. | 작업 완료 후 실무자 보고서를 제출하라."
-      },
-      "16428660261459271791": {
-        "title": "WO-115_Great_Reset_Stability_Verification",
-        "initial_mission": "Work Order WO-115-Great-Reset-Stress-Test.md에 따라 시스템 안정성을 검증하라. | 1. 1,000틱 롱런 시뮬레이션 스크립트 작성 및 실행. | 2. M2 통화량 무결성(Zero-Sum) 및 부채 대 GDP 비율 모니터링. | 3. 발견된 '수치적 누출'이나 불안정성 보고."
-      },
-      "2810292832470995059": {
-        "title": "WO-116_Asset_Mutation_Cleanup",
-        "initial_mission": "Work Order WO-116-Asset-Mutation-Cleanup.md에 따라 자산 수정 로직을 전수 조사하고 청소하라. | 1. `_assets +=`, `_add_assets` 등 직접 수정 코드 검색 및 정산 시스템 호출로 교체. | 2. `InheritanceManager`, `LifecycleManager` 등 핵심 시스템의 원자성 보장 확인. | 3. 발견된 '그림자 로직' 보고."
       }
     },
     "completed_sessions": {
diff --git a/design/command_registry.json b/design/command_registry.json
index b3bede4..52707a3 100644
--- a/design/command_registry.json
+++ b/design/command_registry.json
@@ -12,9 +12,9 @@
   },
   "jules": {
     "command": "create",
-    "title": "WO-116_Asset_Mutation_Cleanup",
-    "instruction": "Work Order WO-116-Asset-Mutation-Cleanup.md에 따라 자산 수정 로직을 전수 조사하고 청소하라. | 1. `_assets +=`, `_add_assets` 등 직접 수정 코드 검색 및 정산 시스템 호출로 교체. | 2. `InheritanceManager`, `LifecycleManager` 등 핵심 시스템의 원자성 보장 확인. | 3. 발견된 '그림자 로직' 보고.",
-    "wait": false
+    "title": "WO-114_DTO_Purity_Gate_Completion",
+    "instruction": "Work Order WO-114-DTO-Purity-Gate-Completion.md에 따라 DTO Purity Gate 리팩토링을 완료하라. | 1. 모든 의사결정 엔진이 context.state와 context.config만 사용하도록 전환. | 2. 에이전트 인스턴스 직접 참조 제거. | 3. 단위 테스트 수정 및 Purity Gate 검증 테스트 추가. | 작업 완료 후 실무자 보고서를 제출하라.",
+    "wait": true
   },
   "git_review": {
     "branch": "main",
diff --git a/design/gemini_output/pr_diff_verify-great-reset-stability-16428660261459271791.txt b/design/gemini_output/pr_diff_verify-great-reset-stability-16428660261459271791.txt
deleted file mode 100644
index 35517c6..0000000
--- a/design/gemini_output/pr_diff_verify-great-reset-stability-16428660261459271791.txt
+++ /dev/null
@@ -1,371 +0,0 @@
-diff --git a/communications/team_assignments.json b/communications/team_assignments.json
-index a16f416..91015bd 100644
---- a/communications/team_assignments.json
-+++ b/communications/team_assignments.json
-@@ -25,10 +25,6 @@
-       "2513104936953701906": {
-         "title": "WO-114_DTO_Purity_Gate_Completion",
-         "initial_mission": "Work Order WO-114-DTO-Purity-Gate-Completion.md에 따라 DTO Purity Gate 리팩토링을 완료하라. | 1. 모든 의사결정 엔진이 context.state와 context.config만 사용하도록 전환. | 2. 에이전트 인스턴스 직접 참조 제거. | 3. 단위 테스트 수정 및 Purity Gate 검증 테스트 추가. | 작업 완료 후 실무자 보고서를 제출하라."
--      },
--      "16428660261459271791": {
--        "title": "WO-115_Great_Reset_Stability_Verification",
--        "initial_mission": "Work Order WO-115-Great-Reset-Stress-Test.md에 따라 시스템 안정성을 검증하라. | 1. 1,000틱 롱런 시뮬레이션 스크립트 작성 및 실행. | 2. M2 통화량 무결성(Zero-Sum) 및 부채 대 GDP 비율 모니터링. | 3. 발견된 '수치적 누출'이나 불안정성 보고."
-       }
-     },
-     "completed_sessions": {
-diff --git a/design/command_registry.json b/design/command_registry.json
-index b3bede4..05526ff 100644
---- a/design/command_registry.json
-+++ b/design/command_registry.json
-@@ -12,8 +12,8 @@
-   },
-   "jules": {
-     "command": "create",
--    "title": "WO-116_Asset_Mutation_Cleanup",
--    "instruction": "Work Order WO-116-Asset-Mutation-Cleanup.md에 따라 자산 수정 로직을 전수 조사하고 청소하라. | 1. `_assets +=`, `_add_assets` 등 직접 수정 코드 검색 및 정산 시스템 호출로 교체. | 2. `InheritanceManager`, `LifecycleManager` 등 핵심 시스템의 원자성 보장 확인. | 3. 발견된 '그림자 로직' 보고.",
-+    "title": "WO-115_Great_Reset_Stability_Verification",
-+    "instruction": "Work Order WO-115-Great-Reset-Stress-Test.md에 따라 시스템 안정성을 검증하라. | 1. 1,000틱 롱런 시뮬레이션 스크립트 작성 및 실행. | 2. M2 통화량 무결성(Zero-Sum) 및 부채 대 GDP 비율 모니터링. | 3. 발견된 '수치적 누출'이나 불안정성 보고.",
-     "wait": false
-   },
-   "git_review": {
-diff --git a/reports/GREAT_RESET_REPORT.md b/reports/GREAT_RESET_REPORT.md
-new file mode 100644
-index 0000000..baa5a2c
---- /dev/null
-+++ b/reports/GREAT_RESET_REPORT.md
-@@ -0,0 +1,15 @@
-+# Great Reset Stress Test Report (WO-115)
-+**Status**: PASSED
-+
-+## 1. System Stability (Atomicity)
-+**PASSED**: No Atomicity Failures (DEPOSIT_FAILURE / ROLLBACK_FAILED) detected.
-+
-+## 2. M2 Money Supply Integrity
-+- Start M2: 1,503,583.46
-+- End M2: 2,258,540.22
-+- Delta: 754,956.77 (+50.21%)
-+
-+## 3. Fiscal Stability (Debt-to-GDP)
-+- Max Debt/GDP: 60180.08%
-+- Final Debt/GDP: 0.00%
-+- Debt levels appear sustainable.
-\ No newline at end of file
-diff --git a/scripts/verify_great_reset_stability.py b/scripts/verify_great_reset_stability.py
-new file mode 100644
-index 0000000..4fc4bd4
---- /dev/null
-+++ b/scripts/verify_great_reset_stability.py
-@@ -0,0 +1,199 @@
-+import sys
-+import os
-+import logging
-+from typing import List, Dict, Any, Optional
-+from pathlib import Path
-+from collections import deque
-+
-+# Add project root to sys.path
-+sys.path.append(str(Path(__file__).resolve().parent.parent))
-+
-+from main import create_simulation
-+from utils.logging_manager import setup_logging
-+import config
-+
-+# --- Verification Log Handler ---
-+class VerificationLogHandler(logging.Handler):
-+    def __init__(self):
-+        super().__init__()
-+        self.atomicity_failures: List[str] = []
-+
-+    def emit(self, record):
-+        msg = self.format(record)
-+        if "DEPOSIT_FAILURE" in msg or "ROLLBACK_FAILED" in msg:
-+            self.atomicity_failures.append(msg)
-+
-+def verify_great_reset():
-+    # 1. Setup Logging
-+    setup_logging()
-+
-+    # Attach handler to capture failures
-+    verification_handler = VerificationLogHandler()
-+    logging.getLogger().addHandler(verification_handler)
-+    logging.getLogger("simulation").addHandler(verification_handler)
-+
-+    logger = logging.getLogger("VERIFY")
-+    logger.info("Starting Great Reset Stress Test (WO-115)...")
-+
-+    # 2. Initialize Simulation
-+    # Ensure standard config
-+    config.INITIAL_HOUSEHOLD_ASSETS_MEAN = 5000.0
-+    config.GOVERNMENT_STIMULUS_ENABLED = True
-+    config.TICKS_PER_YEAR = 100
-+
-+    sim = create_simulation()
-+
-+    # Metrics Storage
-+    m2_history: List[float] = []
-+    debt_ratio_history: List[float] = []
-+
-+    m2_baseline = 0.0
-+
-+    total_ticks = 1000
-+
-+    # 3. Main Loop
-+    for tick in range(1, total_ticks + 1):
-+        try:
-+            sim.run_tick()
-+        except Exception as e:
-+            logger.critical(f"Simulation Crashed at Tick {tick}: {e}", exc_info=True)
-+            break
-+
-+        # 4. Calculate Metrics
-+
-+        # M2 Calculation (Zero-Sum Check)
-+        # M2 = Households + Firms + Government + Reflux + Bank
-+        # Note: We access _assets directly or via property if available.
-+        # Assuming all agents implement IFinancialEntity which usually exposes assets property.
-+
-+        h_assets = sum(h.assets for h in sim.households if h.is_active)
-+        f_assets = sum(f.assets for f in sim.firms if f.is_active)
-+
-+        # Government
-+        gov_assets = sim.government.assets
-+
-+        # Reflux
-+        reflux_bal = sim.reflux_system.balance if sim.reflux_system else 0.0
-+
-+        # Bank
-+        bank_assets = sim.bank.assets if sim.bank else 0.0
-+
-+        current_m2 = h_assets + f_assets + gov_assets + reflux_bal + bank_assets
-+        m2_history.append(current_m2)
-+
-+        if tick == 1:
-+            m2_baseline = current_m2
-+
-+        # Debt-to-GDP Calculation
-+        # Debt = Government Total Debt
-+        # GDP = Current Nominal GDP (Production * Price)
-+
-+        debt = sim.government.total_debt
-+
-+        # Get GDP from tracker
-+        metrics = sim.tracker.get_latest_indicators()
-+        prod = metrics.get("total_production", 0.0)
-+        price = metrics.get("avg_goods_price", 0.0)
-+
-+        # If production/price is 0 (early ticks), use approximation or 0
-+        nominal_gdp = prod * price
-+
-+        # Use smoothed GDP if available to avoid volatility spikes
-+        # But tracker usually gives current tick data.
-+        # Let's use nominal_gdp directly.
-+
-+        debt_ratio = 0.0
-+        if nominal_gdp > 0:
-+            debt_ratio = debt / nominal_gdp
-+
-+        debt_ratio_history.append(debt_ratio)
-+
-+        # Log Progress
-+        if tick % 100 == 0:
-+            logger.info(f"Tick {tick}/{total_ticks} | M2: {current_m2:,.2f} | Debt/GDP: {debt_ratio:.2%}")
-+
-+    # 5. Analysis & Reporting
-+    logger.info("Simulation Complete. Generating Report...")
-+
-+    report_lines = []
-+    report_lines.append("# Great Reset Stress Test Report (WO-115)")
-+    report_lines.append(f"**Status**: {'FAILED' if verification_handler.atomicity_failures else 'PASSED'}")
-+    report_lines.append("")
-+
-+    # Atomicity Check
-+    report_lines.append("## 1. System Stability (Atomicity)")
-+    if verification_handler.atomicity_failures:
-+        report_lines.append(f"**FAILED**: {len(verification_handler.atomicity_failures)} Atomicity Failures detected.")
-+        for fail in verification_handler.atomicity_failures[:10]:
-+            report_lines.append(f"- {fail}")
-+        if len(verification_handler.atomicity_failures) > 10:
-+            report_lines.append(f"- ... and {len(verification_handler.atomicity_failures) - 10} more.")
-+    else:
-+        report_lines.append("**PASSED**: No Atomicity Failures (DEPOSIT_FAILURE / ROLLBACK_FAILED) detected.")
-+
-+    # M2 Integrity Check
-+    report_lines.append("")
-+    report_lines.append("## 2. M2 Money Supply Integrity")
-+    m2_start = m2_history[0]
-+    m2_end = m2_history[-1]
-+    m2_delta = m2_end - m2_start
-+    m2_pct_change = (m2_delta / m2_start) * 100 if m2_start != 0 else 0.0
-+
-+    report_lines.append(f"- Start M2: {m2_start:,.2f}")
-+    report_lines.append(f"- End M2: {m2_end:,.2f}")
-+    report_lines.append(f"- Delta: {m2_delta:,.2f} ({m2_pct_change:+.2f}%)")
-+
-+    # Zero-Sum Analysis
-+    # In a pure Zero-Sum system, Delta should be 0.
-+    # However, Bank Loans create money (Deposit) and Loan Repayment destroys it.
-+    # Government Bond Issuance: Buyers(Cash) -> Govt(Cash). M2 const.
-+    # Tax: HH(Cash) -> Govt(Cash). M2 const.
-+    # Spending: Govt(Cash) -> HH(Cash). M2 const.
-+    # So ONLY Bank Credit Creation/Destruction affects M2 in this definition.
-+    # If M2 grows, it implies Net Lending > 0.
-+    # We check if the change corresponds to Net Loan Growth?
-+    # Bank Assets = Cash + Loans (Receivable)?
-+    # Wait. Bank Assets in code usually means 'Cash/Reserves'.
-+    # If Bank lends 100: Bank Cash -100, Firm Cash +100. Sum M2 = 0.
-+    # IF Bank creates money from thin air (Fractional Reserve):
-+    # Bank Cash (Reserves) doesn't change? Firm Cash +100.
-+    # In this sim, does Bank have infinite cash or is it constrained?
-+    # Usually `bank.withdraw` reduces its assets.
-+    # If Bank Assets go negative (which is allowed for Central Bank but maybe not commercial Bank),
-+    # then M2 Sum would still be 0 if we count negative Bank Assets.
-+    # BUT, if Bank Assets floor at 0 and it still lends -> Creation.
-+    # Let's see what the report says.
-+
-+    report_lines.append("")
-+    report_lines.append("## 3. Fiscal Stability (Debt-to-GDP)")
-+    if debt_ratio_history:
-+        max_debt = max(debt_ratio_history)
-+        end_debt = debt_ratio_history[-1]
-+        report_lines.append(f"- Max Debt/GDP: {max_debt:.2%}")
-+        report_lines.append(f"- Final Debt/GDP: {end_debt:.2%}")
-+        if end_debt > 2.0: # Arbitrary threshold for "Spiral"
-+            report_lines.append("- **WARNING**: Debt-to-GDP ratio is very high (>200%).")
-+        else:
-+            report_lines.append("- Debt levels appear sustainable.")
-+    else:
-+        report_lines.append("- No Debt/GDP data available.")
-+
-+    # Write Report
-+    os.makedirs("reports", exist_ok=True)
-+    report_path = "reports/GREAT_RESET_REPORT.md"
-+    with open(report_path, "w") as f:
-+        f.write("\n".join(report_lines))
-+
-+    logger.info(f"Report saved to {report_path}")
-+    print(f"Report saved to {report_path}")
-+
-+    # Return Code
-+    if verification_handler.atomicity_failures:
-+        sys.exit(1)
-+
-+    # We don't fail on M2 drift yet as we are diagnosing, unless it's huge.
-+    # But WO says "Monitor".
-+    sys.exit(0)
-+
-+if __name__ == "__main__":
-+    verify_great_reset()
-diff --git a/simulation/bank.py b/simulation/bank.py
-index 20ebaac..96c7a6d 100644
---- a/simulation/bank.py
-+++ b/simulation/bank.py
-@@ -46,7 +46,7 @@ class Bank(IFinancialEntity):
-     """
- 
-     def __init__(self, id: int, initial_assets: float, config_manager: ConfigManager):
--        self.id = id
-+        self._id = id
-         self._assets = initial_assets # Reserves
-         self.config_manager = config_manager
- 
-@@ -70,6 +70,10 @@ class Bank(IFinancialEntity):
-             extra={"tick": 0, "agent_id": self.id, "tags": ["init", "bank"]},
-         )
- 
-+    @property
-+    def id(self) -> int:
-+        return self._id
-+
-     @property
-     def assets(self) -> float:
-         return self._assets
-@@ -132,23 +136,6 @@ class Bank(IFinancialEntity):
-         # 2. Liquidity Check
-         # 1a. Credit Jail Check (Phase 4)
-         if self._get_config("credit_recovery_ticks", None) is not None:
--            # We assume borrower_id maps to an agent object passed somewhere, but here we only have ID.
--            # We need to access the agent to check 'credit_frozen_until_tick'.
--            # Bank doesn't have direct access to agent list in grant_loan signature.
--            # But grant_loan is usually called by LoanMarket which has access or the Agent itself calls it via Market.
--            # Wait, LoanMarket.process_loan_request calls this.
--            # Ideally, LoanMarket should check this before calling grant_loan.
--            # BUT, to enforce it at the Bank level, we'd need the agent object or a way to look it up.
--            # Since we don't have it here easily without changing signature, let's assume LoanMarket checks it OR
--            # we rely on the fact that if an agent is in credit jail, their 'credit_rating' (conceptually) is 0.
--            # Let's enforce it in LoanMarket instead?
--            # The spec says "Modify Bank to handle defaults ... prevents Moral Hazard".
--            # It also says "Bankrupt agents remain active but are economically crippled (Credit Jail)."
--            # Let's add an optional 'borrower_agent' arg or rely on LoanMarket.
--            # I'll update LoanMarket in the next steps or if I can modify Bank signature.
--            # Actually, Bank.run_tick has access to 'agents_dict'.
--            # Let's trust LoanMarket for now, OR change signature.
--            # I will assume LoanMarket handles the denial based on the flag I added to Household.
-             pass
- 
-         # 3. Gold Standard (Full Reserve) Check vs. Fractional Reserve (WO-064)
-diff --git a/simulation/decisions/ai_driven_household_engine.py b/simulation/decisions/ai_driven_household_engine.py
-index 39000a8..571534a 100644
---- a/simulation/decisions/ai_driven_household_engine.py
-+++ b/simulation/decisions/ai_driven_household_engine.py
-@@ -59,7 +59,8 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
- 
-         agent_data = household.agent_data
- 
--        goods_list = list(config.GOODS.keys()) # Error here, DTO doesn't have GOODS.
-+        # Use self.config_module which contains the full GOODS definition
-+        goods_list = list(self.config_module.GOODS.keys())
-         
-         action_vector = self.ai_engine.decide_action_vector(
-             agent_data, market_data, goods_list
-diff --git a/simulation/systems/commerce_system.py b/simulation/systems/commerce_system.py
-index 624ac0e..c87fcf3 100644
---- a/simulation/systems/commerce_system.py
-+++ b/simulation/systems/commerce_system.py
-@@ -67,7 +67,7 @@ class CommerceSystem(ICommerceSystem):
-                 if b_amt > 0:
-                     cost = b_amt * food_price
-                     if household.assets >= cost:
--                        household.assets -= cost
-+                        household.withdraw(cost)
-                         household.inventory["basic_food"] = household.inventory.get("basic_food", 0) + b_amt
- 
-                         # Capture money sink
-diff --git a/simulation/systems/inheritance_manager.py b/simulation/systems/inheritance_manager.py
-index 141c458..bd033cf 100644
---- a/simulation/systems/inheritance_manager.py
-+++ b/simulation/systems/inheritance_manager.py
-@@ -26,7 +26,11 @@ class InheritanceManager:
-             government: The entity collecting tax.
-             simulation: Access to markets/registry for liquidation and transfer.
-         """
--        settlement = getattr(simulation.state, 'settlement_system', None)
-+        # If simulation is SimulationState DTO, it has settlement_system directly.
-+        # If it is Simulation Engine, it has it via __getattr__ or world_state.
-+        settlement = getattr(simulation, 'settlement_system', None)
-+        if settlement is None and hasattr(simulation, 'state'):
-+             settlement = getattr(simulation.state, 'settlement_system', None)
- 
-         self.logger.info(
-             f"INHERITANCE_START | Processing death for Household {deceased.id}. Assets: {deceased.assets:.2f}",
-diff --git a/simulation/systems/ma_manager.py b/simulation/systems/ma_manager.py
-index d4f59f1..a5ddf80 100644
---- a/simulation/systems/ma_manager.py
-+++ b/simulation/systems/ma_manager.py
-@@ -177,7 +177,7 @@ class MAManager:
-         self.logger.info(f"{tag}_EXECUTE | Predator {predator.id} acquires Prey {prey.id}. Price: {price:,.2f}.")
-         
-         # 1. Payment
--        predator.assets -= price
-+        predator.withdraw(price)
- 
-         # Pay Shareholders (Households)
-         # Assuming 100% buyout.
-@@ -185,7 +185,7 @@ class MAManager:
-         # For simplicity, pay founder or distribute generally?
-         # Let's stick to paying founder as proxy for 'Shareholders'
-         if prey.founder_id is not None and prey.founder_id in self.simulation.agents:
--             self.simulation.agents[prey.founder_id].assets += price
-+             self.simulation.agents[prey.founder_id].deposit(price)
-         
-         # 2. Asset Transfer
-         # SoC Refactor: use production.add_capital
diff --git a/design/gemini_output/pr_diff_wo-116-asset-cleanup-2810292832470995059.txt b/design/gemini_output/pr_diff_wo-116-asset-cleanup-2810292832470995059.txt
deleted file mode 100644
index f32ab84..0000000
--- a/design/gemini_output/pr_diff_wo-116-asset-cleanup-2810292832470995059.txt
+++ /dev/null
@@ -1,1224 +0,0 @@
-diff --git a/config.py b/config.py
-index 803394a..40346f4 100644
---- a/config.py
-+++ b/config.py
-@@ -1,7 +1,7 @@
- import os
--from dotenv import load_dotenv
-+# from dotenv import load_dotenv
- 
--load_dotenv()  # Load environment variables from .env file
-+# load_dotenv()  # Load environment variables from .env file
- 
- # --- Simulation Parameters ---
- from enum import Enum
-diff --git a/simulation/agents/government.py b/simulation/agents/government.py
-index d9782d5..e32a31a 100644
---- a/simulation/agents/government.py
-+++ b/simulation/agents/government.py
-@@ -289,20 +289,26 @@ class Government:
- 
-         if self.assets < effective_amount:
-             needed = effective_amount - self.assets
--            issued_bonds = self.finance_system.issue_treasury_bonds(needed, current_tick)
--            if not issued_bonds:
--                logger.warning(f"BOND_ISSUANCE_FAILED | Failed to raise {needed:.2f} for household support.")
--                return 0.0
--
--        self._sub_assets(effective_amount)
--        self.total_spent_subsidies += effective_amount
--        self.expenditure_this_tick += effective_amount
-+            if self.finance_system:
-+                issued_bonds = self.finance_system.issue_treasury_bonds(needed, current_tick)
-+                if not issued_bonds:
-+                    logger.warning(f"BOND_ISSUANCE_FAILED | Failed to raise {needed:.2f} for household support.")
-+                    return 0.0
-+            else:
-+                 logger.warning("BOND_ISSUANCE_SKIPPED | No FinanceSystem.")
-+                 return 0.0
- 
--        if hasattr(household, '_add_assets'):
--            household._add_assets(effective_amount)
-+        if self.finance_system and self.finance_system.settlement_system:
-+            self.finance_system.settlement_system.transfer(self, household, effective_amount, "household_support")
-         else:
--            household.assets += effective_amount
-+            self._sub_assets(effective_amount)
-+            if hasattr(household, '_add_assets'):
-+                household._add_assets(effective_amount)
-+            else:
-+                household.assets += effective_amount
- 
-+        self.total_spent_subsidies += effective_amount
-+        self.expenditure_this_tick += effective_amount
-         self.current_tick_stats["welfare_spending"] += effective_amount
- 
-         logger.info(
-@@ -445,16 +451,23 @@ class Government:
- 
-         if self.assets < effective_cost:
-             needed = effective_cost - self.assets
--            issued_bonds = self.finance_system.issue_treasury_bonds(needed, current_tick)
--            if not issued_bonds:
--                logger.warning(f"BOND_ISSUANCE_FAILED | Failed to raise {needed:.2f} for infrastructure.")
--                return False
-+            if self.finance_system:
-+                issued_bonds = self.finance_system.issue_treasury_bonds(needed, current_tick)
-+                if not issued_bonds:
-+                    logger.warning(f"BOND_ISSUANCE_FAILED | Failed to raise {needed:.2f} for infrastructure.")
-+                    return False
-+            else:
-+                 logger.warning("BOND_ISSUANCE_SKIPPED | No FinanceSystem.")
-+                 return False
- 
--        self._sub_assets(effective_cost)
--        self.expenditure_this_tick += effective_cost
--        if reflux_system:
--            reflux_system.capture(effective_cost, str(self.id), "infrastructure")
-+        if self.finance_system and self.finance_system.settlement_system and reflux_system:
-+             self.finance_system.settlement_system.transfer(self, reflux_system, effective_cost, "infrastructure_investment")
-+        else:
-+             self._sub_assets(effective_cost)
-+             if reflux_system:
-+                 reflux_system.capture(effective_cost, str(self.id), "infrastructure")
- 
-+        self.expenditure_this_tick += effective_cost
-         self.infrastructure_level += 1
- 
-         logger.info(
-@@ -532,12 +545,12 @@ class Government:
-         return debt / self.sensory_data.current_gdp
- 
-     # WO-054: Public Education System
--    def run_public_education(self, agents: List[Any], config_module: Any, current_tick: int, reflux_system: Any = None) -> None:
-+    def run_public_education(self, agents: List[Any], config_module: Any, current_tick: int, reflux_system: Any = None, settlement_system: Any = None) -> None:
-         """
-         Delegates public education logic to the Ministry of Education.
-         """
-         households = [a for a in agents if hasattr(a, 'education_level')]
--        self.ministry_of_education.run_public_education(households, self, current_tick, reflux_system)
-+        self.ministry_of_education.run_public_education(households, self, current_tick, reflux_system, settlement_system)
- 
-     def deposit(self, amount: float) -> None:
-         """Deposits a given amount into the government's assets."""
-diff --git a/simulation/components/finance_department.py b/simulation/components/finance_department.py
-index 588491b..6c232e4 100644
---- a/simulation/components/finance_department.py
-+++ b/simulation/components/finance_department.py
-@@ -65,13 +65,19 @@ class FinanceDepartment:
-         """
-         self._cash -= amount
- 
--    def calculate_and_debit_holding_costs(self) -> float:
-+    def calculate_and_debit_holding_costs(self, reflux_system: Optional[EconomicRefluxSystem] = None, settlement_system: Any = None) -> float:
-         """Calculates and pays inventory holding costs."""
-         inventory_value = self.get_inventory_value()
-         holding_cost = inventory_value * self.config_module.INVENTORY_HOLDING_COST_RATE
- 
-         if holding_cost > 0:
--            self.debit(holding_cost, "Inventory Holding Cost")
-+            if settlement_system and reflux_system:
-+                settlement_system.transfer(self.firm, reflux_system, holding_cost, "fixed_cost")
-+            else:
-+                self.debit(holding_cost, "Inventory Holding Cost")
-+                if reflux_system:
-+                    reflux_system.capture(holding_cost, str(self.firm.id), "fixed_cost")
-+
-             self.record_expense(holding_cost)
- 
-         return holding_cost
-@@ -86,13 +92,21 @@ class FinanceDepartment:
-         self.expenses_this_tick += amount
-         self.current_profit -= amount
- 
--    def pay_maintenance(self, government: Government, reflux_system: Optional[EconomicRefluxSystem], current_time: int):
-+    def pay_maintenance(self, government: Government, reflux_system: Optional[EconomicRefluxSystem], current_time: int, settlement_system: Any = None):
-         """Pay fixed maintenance fee."""
-         fee = getattr(self.config_module, "FIRM_MAINTENANCE_FEE", 50.0)
-         payment = min(self._cash, fee) # Cap at available cash
- 
-         if payment > 0:
-             # Debit handled by Government -> FinanceSystem -> SettlementSystem -> Firm.withdraw
-+            # But wait, collect_tax handles transfer IF finance_system is set on government.
-+            # If not, we fallback to debit?
-+            # WO strictness: We rely on government.collect_tax to do the transfer.
-+            # government.collect_tax calls self.finance_system.collect_corporate_tax.
-+            # Which calls settlement_system.transfer.
-+            # So we don't need to manually transfer here IF government handles it.
-+            # BUT, if government doesn't have finance_system set up (legacy), collect_tax might fail or just log.
-+            # We should assume Government is compliant (Step 3).
-             government.collect_tax(payment, "firm_maintenance", self.firm, current_time)
-             self.record_expense(payment)
- 
-@@ -101,7 +115,7 @@ class FinanceDepartment:
-                 extra={"tick": current_time, "agent_id": self.firm.id, "tags": ["tax", "maintenance"]}
-             )
- 
--    def pay_taxes(self, government: Government, current_time: int):
-+    def pay_taxes(self, government: Government, current_time: int, settlement_system: Any = None):
-         """Pay corporate tax on profit."""
-         net_profit = self.revenue_this_turn - self.cost_this_turn
- 
-@@ -117,23 +131,13 @@ class FinanceDepartment:
- 
-                 after_tax_profit = net_profit - payment
-                 self.retained_earnings += after_tax_profit
--                # Note: We do NOT record_expense here because tax is usually considered separate from operating expenses in this model logic,
--                # OR it was already implicitly deducted from 'retained_earnings' calc.
--                # Wait, original code:
--                # self.debit(...)
--                # government.collect_tax(...)
--                # after_tax_profit = net_profit - payment
--                # retained_earnings += after_tax_profit
--
--                # It did NOT call record_expense().
--                # So we are fine.
- 
-                 self.firm.logger.info(
-                     f"Paid corporate tax: {payment:.2f} on profit {net_profit:.2f}. Retained Earnings increased by {after_tax_profit:.2f}",
-                     extra={"tick": current_time, "agent_id": self.firm.id, "tags": ["tax", "corporate_tax"]}
-                 )
- 
--    def process_profit_distribution(self, households: List[Household], government: Government, current_time: int) -> List[Transaction]:
-+    def process_profit_distribution(self, households: List[Household], government: Government, current_time: int, settlement_system: Any = None) -> List[Transaction]:
-         """Public Shareholders Dividend"""
-         if getattr(self.firm, 'has_bailout_loan', False) and self.current_profit > 0:
-             repayment_ratio = getattr(self.config_module, "BAILOUT_REPAYMENT_RATIO", 0.5)
-@@ -144,8 +148,11 @@ class FinanceDepartment:
-                 self.firm.total_debt = 0.0
- 
-             # Bailout repayment
--            self.debit(repayment, "Bailout Repayment")
--            government._add_assets(repayment) # Direct transfer to government
-+            if settlement_system:
-+                settlement_system.transfer(self.firm, government, repayment, "bailout_repayment")
-+            else:
-+                self.debit(repayment, "Bailout Repayment")
-+                government._add_assets(repayment)
- 
-             self.firm.total_debt -= repayment
-             self.current_profit -= repayment
-@@ -168,9 +175,19 @@ class FinanceDepartment:
-                 shares = household.shares_owned.get(self.firm.id, 0.0)
-                 if shares > 0:
-                     dividend_amount = distributable_profit * (shares / self.firm.total_shares)
--                    # NOTE: Dividends are paid via TransactionProcessor normally.
--                    # TransactionProcessor sees "dividend" and does: seller.assets -= trade_value.
--                    # Since seller.assets will delegate to finance.debit, this works.
-+
-+                    # TransactionProcessor handles "dividend" type transactions by transferring assets.
-+                    # It calls settlement_system.transfer if available.
-+                    # So we just emit the transaction, we do NOT manually debit here.
-+                    # Wait, the previous code did NOT debit here either!
-+                    # It just appended Transaction.
-+                    # BUT `process_profit_distribution` calls `process_profit_distribution`... wait.
-+                    # The previous code logic:
-+                    # transactions.append(...)
-+                    # self.dividends_paid_last_tick += dividend_amount
-+                    # It relies on TransactionProcessor to execute the dividend transfer.
-+                    # And TransactionProcessor calls `seller.assets -= trade_value` (or settlement transfer).
-+
-                     transactions.append(
-                         Transaction(
-                             buyer_id=household.id,
-@@ -198,7 +215,7 @@ class FinanceDepartment:
- 
-         return transactions
- 
--    def distribute_profit_private(self, agents: Dict[int, Any], current_time: int) -> float:
-+    def distribute_profit_private(self, agents: Dict[int, Any], current_time: int, settlement_system: Any = None) -> float:
-         """Phase 14-1: Private Owner Dividend"""
-         if self.firm.owner_id is None:
-             return 0.0
-@@ -223,8 +240,12 @@ class FinanceDepartment:
- 
-         if distributable_cash > 0:
-             dividend_amount = distributable_cash
--            self.debit(dividend_amount, "Private Dividend")
--            owner._add_assets(dividend_amount)
-+
-+            if settlement_system:
-+                settlement_system.transfer(self.firm, owner, dividend_amount, "private_dividend")
-+            else:
-+                self.debit(dividend_amount, "Private Dividend")
-+                owner._add_assets(dividend_amount)
- 
-             if hasattr(owner, 'income_capital_cumulative'):
-                 owner.income_capital_cumulative += dividend_amount
-@@ -372,32 +393,54 @@ class FinanceDepartment:
-         """Returns the current assets (cash) of the firm."""
-         return self._cash
- 
--    def invest_in_automation(self, amount: float) -> bool:
-+    def invest_in_automation(self, amount: float, settlement_system: Any = None, reflux_system: Any = None) -> bool:
-         if self._cash >= amount:
--            self.debit(amount, "Automation Investment")
-+            # Sunk cost or Reflux? Automation likely purchase from machine sector (abstract).
-+            # If Reflux is available, transfer there.
-+            if settlement_system and reflux_system:
-+                settlement_system.transfer(self.firm, reflux_system, amount, "automation_investment")
-+            else:
-+                self.debit(amount, "Automation Investment")
-+                if reflux_system:
-+                    reflux_system.capture(amount, str(self.firm.id), "capex")
-             return True
-         return False
- 
--    def invest_in_rd(self, amount: float) -> bool:
-+    def invest_in_rd(self, amount: float, settlement_system: Any = None, reflux_system: Any = None) -> bool:
-         if self._cash >= amount:
--            self.debit(amount, "R&D Investment")
-+            if settlement_system and reflux_system:
-+                settlement_system.transfer(self.firm, reflux_system, amount, "rd_investment")
-+            else:
-+                self.debit(amount, "R&D Investment")
-+                if reflux_system:
-+                     reflux_system.capture(amount, str(self.firm.id), "capex")
-+
-             self.record_expense(amount)
-             return True
-         return False
- 
--    def invest_in_capex(self, amount: float) -> bool:
-+    def invest_in_capex(self, amount: float, settlement_system: Any = None, reflux_system: Any = None) -> bool:
-         if self._cash >= amount:
--            self.debit(amount, "CAPEX")
-+            if settlement_system and reflux_system:
-+                settlement_system.transfer(self.firm, reflux_system, amount, "capex")
-+            else:
-+                self.debit(amount, "CAPEX")
-+                if reflux_system:
-+                     reflux_system.capture(amount, str(self.firm.id), "capex")
-             return True
-         return False
- 
-     def set_dividend_rate(self, rate: float) -> None:
-         self.firm.dividend_rate = rate
- 
--    def pay_severance(self, employee: Household, amount: float) -> bool:
-+    def pay_severance(self, employee: Household, amount: float, settlement_system: Any = None) -> bool:
-         if self._cash >= amount:
--            self.debit(amount, "Severance Pay")
--            employee._add_assets(amount)
-+            if settlement_system:
-+                settlement_system.transfer(self.firm, employee, amount, "severance")
-+            else:
-+                self.debit(amount, "Severance Pay")
-+                employee._add_assets(amount)
-+
-             self.record_expense(amount)
-             return True
-         return False
-diff --git a/simulation/components/hr_department.py b/simulation/components/hr_department.py
-index 9df0b10..69d8ad4 100644
---- a/simulation/components/hr_department.py
-+++ b/simulation/components/hr_department.py
-@@ -32,7 +32,7 @@ class HRDepartment:
- 
-         return base_wage * actual_skill * halo_modifier
- 
--    def process_payroll(self, current_time: int, government: Optional[Any], market_data: Optional[Dict[str, Any]]) -> float:
-+    def process_payroll(self, current_time: int, government: Optional[Any], market_data: Optional[Dict[str, Any]], settlement_system: Any = None) -> float:
-         """
-         Pays wages to employees. Handles insolvency firing if assets are insufficient.
-         Returns total wages paid.
-@@ -70,26 +70,32 @@ class HRDepartment:
- 
-                 net_wage = wage - income_tax
- 
--                # Transactions
--                self.firm._sub_assets(wage)
--                employee._add_assets(net_wage)
-+                # Atomic Transfer 1: Net Wage -> Employee
-+                if settlement_system:
-+                    settlement_system.transfer(self.firm, employee, net_wage, "wage_net")
-+                else:
-+                    self.firm._sub_assets(net_wage)
-+                    employee._add_assets(net_wage)
- 
-                 # Track Labor Income
-                 if hasattr(employee, "labor_income_this_tick"):
-                     employee.labor_income_this_tick += net_wage
- 
-+                # Atomic Transfer 2: Tax -> Government (Withholding)
-                 if income_tax > 0 and government:
--                    government.collect_tax(income_tax, "income_tax", employee.id, current_time)
-+                    # government.collect_tax handles settlement if configured
-+                    # We pass self.firm as payer (Withholding Agent)
-+                    government.collect_tax(income_tax, "income_tax", self.firm, current_time)
-                     total_tax_withheld += income_tax
- 
-                 total_wages += wage
-             else:
-                 # Insolvency Handling
--                self._handle_insolvency(employee, wage)
-+                self._handle_insolvency(employee, wage, settlement_system)
- 
-         return total_wages
- 
--    def _handle_insolvency(self, employee: Household, wage: float):
-+    def _handle_insolvency(self, employee: Household, wage: float, settlement_system: Any = None):
-         """
-         Handles case where firm cannot afford wage.
-         Attempts severance pay; if fails, zombie state (unpaid retention).
-@@ -97,11 +103,8 @@ class HRDepartment:
-         severance_weeks = getattr(self.firm.config_module, "SEVERANCE_PAY_WEEKS", 4)
-         severance_pay = wage * severance_weeks
- 
--        if self.firm.assets >= severance_pay:
--            # Fire with severance
--            self.firm._sub_assets(severance_pay)
--            employee._add_assets(severance_pay)
--
-+        # Delegate to FinanceDepartment which now handles settlement
-+        if self.firm.finance.pay_severance(employee, severance_pay, settlement_system):
-             self.firm.logger.info(
-                 f"SEVERANCE | Firm {self.firm.id} paid severance {severance_pay:.2f} to Household {employee.id}. Firing due to insolvency.",
-                 extra={"tick": self.firm.decision_engine.context.current_time if hasattr(self.firm.decision_engine, 'context') else 0, "agent_id": self.firm.id, "severance_pay": severance_pay}
-diff --git a/simulation/firms.py b/simulation/firms.py
-index 41fee22..e081b3c 100644
---- a/simulation/firms.py
-+++ b/simulation/firms.py
-@@ -409,7 +409,7 @@ class Firm(BaseAgent, ILearningAgent):
-         )
- 
-     @override
--    def update_needs(self, current_time: int, government: Optional[Any] = None, market_data: Optional[Dict[str, Any]] = None, reflux_system: Optional[Any] = None, technology_manager: Optional[Any] = None) -> None:
-+    def update_needs(self, current_time: int, government: Optional[Any] = None, market_data: Optional[Dict[str, Any]] = None, reflux_system: Optional[Any] = None, technology_manager: Optional[Any] = None, settlement_system: Optional[Any] = None) -> None:
-         self.age += 1
-         log_extra = {"tick": current_time, "agent_id": self.id, "tags": ["firm_needs"]}
-         # SoC Refactor
-@@ -429,17 +429,21 @@ class Firm(BaseAgent, ILearningAgent):
- 
-         # 2. Pay Wages & Holding Costs
-         # WO-103 Phase 1: Delegated Holding Cost Calculation
--        holding_cost = self.finance.calculate_and_debit_holding_costs()
-+        # Use settlement system if available (via updated finance method, or pass it)
-+        # For now, pass settlement_system if we update finance.
-+        # But finance.calculate_and_debit_holding_costs() needs update.
-+        holding_cost = self.finance.calculate_and_debit_holding_costs(reflux_system, settlement_system)
- 
-         if holding_cost > 0:
--            if reflux_system:
--                reflux_system.capture(holding_cost, str(self.id), "fixed_cost")
-+            # Capture is now handled inside calculate_and_debit_holding_costs if settlement_system is used
-+            # But if not, we do it here?
-+            # Ideally finance handles it. We'll update finance to do it.
-             self.logger.info(
-                 f"Paid inventory holding cost: {holding_cost:.2f}",
-                 extra={**log_extra, "holding_cost": holding_cost},
-             )
- 
--        total_wages = self.hr.process_payroll(current_time, government, market_data)
-+        total_wages = self.hr.process_payroll(current_time, government, market_data, settlement_system)
-         if total_wages > 0:
-             self.finance.record_expense(total_wages)
-             self.logger.info(
-@@ -458,10 +462,15 @@ class Firm(BaseAgent, ILearningAgent):
- 
-         if marketing_spend > 0:
-              # WO-103 Phase 1: Transactional method
--             self.finance.debit(marketing_spend, "Marketing")
-+             # Refactor: Use settlement system if available
-+             if settlement_system and reflux_system:
-+                 settlement_system.transfer(self, reflux_system, marketing_spend, "marketing")
-+             else:
-+                 self.finance.debit(marketing_spend, "Marketing")
-+                 if reflux_system:
-+                     reflux_system.capture(marketing_spend, str(self.id), "marketing")
-+
-              self.finance.record_expense(marketing_spend)
--             if reflux_system:
--                 reflux_system.capture(marketing_spend, str(self.id), "marketing")
- 
-         self.marketing_budget = marketing_spend
-         self.brand_manager.update(marketing_spend, self.productivity_factor / 10.0)
-@@ -469,8 +478,8 @@ class Firm(BaseAgent, ILearningAgent):
- 
-         # 4. Pay Taxes (after all other expenses)
-         if government:
--            self.finance.pay_maintenance(government, reflux_system, current_time)
--            self.finance.pay_taxes(government, current_time)
-+            self.finance.pay_maintenance(government, reflux_system, current_time, settlement_system)
-+            self.finance.pay_taxes(government, current_time, settlement_system)
- 
-         brand_premium = self.calculate_brand_premium(market_data) if market_data else 0.0
-         self.logger.info(
-diff --git a/simulation/initialization/initializer.py b/simulation/initialization/initializer.py
-index b0cefce..6b93eaf 100644
---- a/simulation/initialization/initializer.py
-+++ b/simulation/initialization/initializer.py
-@@ -103,6 +103,9 @@ class SimulationInitializer(SimulationInitializerInterface):
-         sim.time: int = 0
-         sim.batch_save_interval = 50
- 
-+        # Initialize Settlement System Early (WO-116)
-+        sim.settlement_system = SettlementSystem(logger=self.logger)
-+
-         sim.bank = Bank(
-             id=sim.next_agent_id,
-             initial_assets=self.config.INITIAL_BANK_ASSETS,
-@@ -215,7 +218,7 @@ class SimulationInitializer(SimulationInitializerInterface):
-         sim.firm_system = FirmSystem(config_module=self.config)
-         sim.technology_manager = TechnologyManager(config_module=self.config, logger=self.logger)
- 
--        Bootstrapper.inject_initial_liquidity(sim.firms, self.config)
-+        Bootstrapper.inject_initial_liquidity(sim.firms, self.config, sim.settlement_system, sim.central_bank)
-         Bootstrapper.force_assign_workers(sim.firms, sim.households)
- 
-         sim.generational_wealth_audit = GenerationalWealthAudit(config_module=self.config)
-@@ -235,7 +238,7 @@ class SimulationInitializer(SimulationInitializerInterface):
-         sim.social_system = SocialSystem(self.config)
-         sim.event_system = EventSystem(self.config)
-         sim.sensory_system = SensorySystem(self.config)
--        sim.settlement_system = SettlementSystem(logger=self.logger)
-+        # sim.settlement_system initialized earlier
-         sim.commerce_system = CommerceSystem(self.config, sim.reflux_system)
-         sim.labor_market_analyzer = LaborMarketAnalyzer(self.config)
- 
-diff --git a/simulation/systems/bootstrapper.py b/simulation/systems/bootstrapper.py
-index 0ffbd57..5dbf5a1 100644
---- a/simulation/systems/bootstrapper.py
-+++ b/simulation/systems/bootstrapper.py
-@@ -43,13 +43,15 @@ class Bootstrapper:
-         return assigned_count
- 
-     @staticmethod
--    def inject_initial_liquidity(firms: List['Firm'], config: Any) -> None:
-+    def inject_initial_liquidity(firms: List['Firm'], config: Any, settlement_system: Any = None, source_agent: Any = None) -> None:
-         """
-         Injects a 30-tick buffer of raw materials and minimum capital.
- 
-         Args:
-             firms: List of Firm agents.
-             config: Configuration module (contains GOODS definition).
-+            settlement_system: Settlement System for atomic transfer.
-+            source_agent: Source of funds (e.g. Central Bank).
-         """
-         BUFFER_DAYS = 30.0
- 
-@@ -82,6 +84,9 @@ class Bootstrapper:
-             # 2. Capital Injection (Demand Side)
-             if firm.assets < Bootstrapper.MIN_CAPITAL:
-                 diff = Bootstrapper.MIN_CAPITAL - firm.assets
--                firm._add_assets(diff)
-+                if settlement_system and source_agent:
-+                    settlement_system.transfer(source_agent, firm, diff, "bootstrap_capital_injection")
-+                else:
-+                    firm._add_assets(diff)
- 
-         logger.info(f"BOOTSTRAPPER | Injected resources into {injected_count} firms.")
-diff --git a/simulation/systems/demographic_manager.py b/simulation/systems/demographic_manager.py
-index 60174be..ce717d3 100644
---- a/simulation/systems/demographic_manager.py
-+++ b/simulation/systems/demographic_manager.py
-@@ -90,7 +90,6 @@ class DemographicManager:
-             # Let's assume standard INITIAL_ASSETS or small portion from parent.
-             # "Initial 자산은 부모 자산의 일부 이전"
-             initial_gift = parent.assets * 0.1
--            parent._sub_assets(initial_gift)
- 
-             # Create Instance
-             # We need to clone parent's structure but reset state
-@@ -151,7 +150,7 @@ class DemographicManager:
-                 id=child_id,
-                 talent=child_talent,
-                 goods_data=simulation.goods_data,
--                initial_assets=initial_gift,
-+                initial_assets=0.0, # WO-116: Start with 0, then transfer
-                 initial_needs={}, # Default reset
-                 decision_engine=new_decision_engine,
-                 value_orientation=value_orientation,
-@@ -181,6 +180,14 @@ class DemographicManager:
- 
-             new_children.append(child)
- 
-+            # WO-116: Atomic Transfer
-+            settlement = getattr(simulation, 'settlement_system', None)
-+            if settlement:
-+                settlement.transfer(parent, child, initial_gift, "birth_gift")
-+            else:
-+                parent._sub_assets(initial_gift)
-+                child._add_assets(initial_gift)
-+
-             self.logger.info(
-                 f"BIRTH | Parent {parent.id} ({parent.age:.1f}y) -> Child {child.id}. "
-                 f"Assets: {initial_gift:.2f}",
-@@ -223,45 +230,3 @@ class DemographicManager:
-         mult = multipliers.get(education_level, 1.0)
-         return base_wage * mult
- 
--    def handle_inheritance(self, deceased_agent: Household, simulation: Any):
--        """
--        Distribute assets to children.
--        """
--        if not deceased_agent.children_ids:
--            # No heirs -> State (Tax)
--            return # Already handled by existing liquidation logic (Government collection)
--
--        # Find living heirs
--        heirs = [simulation.agents[cid] for cid in deceased_agent.children_ids if cid in simulation.agents and simulation.agents[cid].is_active]
--
--        if not heirs:
--            return # No living heirs
--
--        # Distribute Assets
--        # Existing logic in engine._handle_agent_lifecycle wipes assets via tax?
--        # We need to intercept or modify engine to call this BEFORE wiping.
--        # But per instructions: "HouseholdAI handles decision, DemographicManager handles execution".
--        # Inheritance logic might need to run before standard liquidation.
--
--        amount = deceased_agent.assets
--        if amount <= 0: return
--
--        # Tax
--        tax_rate = getattr(self.config_module, "INHERITANCE_TAX_RATE", 0.0)
--        tax = amount * tax_rate
--        net_amount = amount - tax
--
--        # Send Tax
--        simulation.government.collect_tax(tax, "inheritance_tax", deceased_agent.id, simulation.time)
--
--        # Distribute
--        share = net_amount / len(heirs)
--        for heir in heirs:
--            heir._add_assets(share)
--            self.logger.info(
--                f"INHERITANCE | Heir {heir.id} received {share:.2f} from {deceased_agent.id}.",
--                extra={"heir_id": heir.id, "deceased_id": deceased_agent.id}
--            )
--
--        # Clear deceased assets so engine doesn't double count or tax again
--        deceased_agent._sub_assets(deceased_agent.assets)
-diff --git a/simulation/systems/housing_system.py b/simulation/systems/housing_system.py
-index 17c1d94..a5789f6 100644
---- a/simulation/systems/housing_system.py
-+++ b/simulation/systems/housing_system.py
-@@ -25,6 +25,8 @@ class HousingSystem:
-         Processes mortgage payments, maintenance costs, rent collection, and eviction/foreclosure checks.
-         Consolidated from Simulation._process_housing (Line 1221 in engine.py).
-         """
-+        settlement = getattr(simulation, 'settlement_system', None)
-+
-         # 1. Process Bank/Mortgages
-         for unit in simulation.real_estate_units:
-             if unit.mortgage_id:
-@@ -68,15 +70,17 @@ class HousingSystem:
-                 owner = simulation.agents.get(unit.owner_id)
-                 if owner:
-                     cost = unit.estimated_value * self.config.MAINTENANCE_RATE_PER_TICK
--                    if owner.assets >= cost:
--                        owner._sub_assets(cost)
--                        if simulation.reflux_system:
--                            simulation.reflux_system.capture(cost, f"{owner.id}", "housing_maintenance")
--                    else:
--                        taken = owner.assets
--                        owner._sub_assets(taken)
--                        if simulation.reflux_system:
--                            simulation.reflux_system.capture(taken, f"{owner.id}", "housing_maintenance")
-+                    # Cap cost at owner assets (simple model)
-+                    if owner.assets < cost:
-+                        cost = owner.assets
-+
-+                    if cost > 0:
-+                        if settlement and simulation.reflux_system:
-+                            settlement.transfer(owner, simulation.reflux_system, cost, "housing_maintenance")
-+                        else:
-+                            owner._sub_assets(cost)
-+                            if simulation.reflux_system:
-+                                simulation.reflux_system.capture(cost, f"{owner.id}", "housing_maintenance")
- 
-             # B. Rent Collection (Tenant pays Owner)
-             if unit.occupant_id is not None and unit.owner_id is not None:
-@@ -89,8 +93,11 @@ class HousingSystem:
-                 if tenant and owner and tenant.is_active and owner.is_active:
-                     rent = unit.rent_price
-                     if tenant.assets >= rent:
--                        tenant._sub_assets(rent)
--                        owner._add_assets(rent)
-+                        if settlement:
-+                            settlement.transfer(tenant, owner, rent, "rent")
-+                        else:
-+                            tenant._sub_assets(rent)
-+                            owner._add_assets(rent)
-                     else:
-                         # Eviction due to rent non-payment
-                         logger.info(
-@@ -156,8 +163,12 @@ class HousingSystem:
-                 )
-                 
-                 if loan_id:
--                    simulation.bank._sub_assets(loan_amount)
--                    buyer._add_assets(loan_amount)
-+                    settlement = getattr(simulation, 'settlement_system', None)
-+                    if settlement:
-+                        settlement.transfer(simulation.bank, buyer, loan_amount, "mortgage_disbursement")
-+                    else:
-+                        simulation.bank._sub_assets(loan_amount)
-+                        buyer._add_assets(loan_amount)
-                     unit.mortgage_id = loan_id
-                 else:
-                     unit.mortgage_id = None
-@@ -165,18 +176,45 @@ class HousingSystem:
-                 unit.mortgage_id = None
-                 
-             # 2. Process Funds Transfer
--            buyer._sub_assets(trade_value)
-+            settlement = getattr(simulation, 'settlement_system', None)
-+            if settlement:
-+                settlement.transfer(buyer, seller, trade_value, "housing_purchase")
-+            else:
-+                buyer._sub_assets(trade_value)
-+                seller._add_assets(trade_value)
- 
-             if isinstance(seller, Government):
--                # The original code called 'record_asset_sale', which doesn't exist on Government.
--                # The intent seems to be to track government income. We'll use the existing
--                # 'collect_tax' method as a sink for this revenue, flagging it appropriately.
-+                # Record as revenue
-                 seller.collect_tax(trade_value, "asset_sale", buyer.id, simulation.time)
--                # Note: collect_tax no longer adds assets! We must add it manually or use SettlementSystem.
--                # Since we are inside HousingSystem legacy logic, we add it here.
--                seller._add_assets(trade_value)
--            else:
--                seller._add_assets(trade_value)
-+                # Note: collect_tax handles transfer ONLY if configured with FinanceSystem.
-+                # But here we ALREADY transferred via settlement (or manually above).
-+                # If we transferred to 'seller' (Government), assets are updated.
-+                # collect_tax usually transfers too!
-+                # If we transferred manually above, calling collect_tax might double-transfer if government has finance_system.
-+                # However, collect_tax expects to PULL from payer.
-+                # Here we PUSHED to seller.
-+                # So we should NOT call collect_tax logic that transfers.
-+                # We just want to record stats.
-+                # Government.collect_tax calls finance_system...
-+                # This is tricky.
-+                # If we used settlement.transfer(buyer, seller), seller (Govt) has funds.
-+                # If we call collect_tax, it will try to pull from 'buyer' again.
-+                # DOUBLE CHARGE!
-+                # Solution: Do NOT call collect_tax for transfer if we already transferred.
-+                # Just update stats manually on Government?
-+                # Or trust collect_tax to do the transfer, and NOT do it manually above?
-+
-+                # If seller is Government:
-+                # If we rely on collect_tax, it pulls from buyer.
-+                # But we have logic `settlement.transfer(buyer, seller, ...)` above which is generic.
-+                # The cleanest way:
-+                # If seller is Government, call collect_tax INSTEAD of generic transfer?
-+                # OR: Use generic transfer, and implement a `record_revenue` method on Government that doesn't transfer.
-+                # Government has `revenue_this_tick` and `tax_revenue`.
-+                # I'll manually update stats here to avoid double transfer.
-+                seller.revenue_this_tick += trade_value
-+                seller.current_tick_stats["total_collected"] += trade_value
-+                # seller.tax_revenue["asset_sale"] += trade_value # Optional
- 
-             # 3. Transfer Title
-             unit.owner_id = buyer.id
-diff --git a/simulation/systems/inheritance_manager.py b/simulation/systems/inheritance_manager.py
-index 141c458..0530f2c 100644
---- a/simulation/systems/inheritance_manager.py
-+++ b/simulation/systems/inheritance_manager.py
-@@ -105,10 +105,8 @@ class InheritanceManager:
-                 if settlement:
-                     settlement.transfer(government, deceased, proceeds, f"liquidation_stock:{firm_id}")
-                 else:
--                    if hasattr(government, '_sub_assets'): government._sub_assets(proceeds)
--                    else: government.assets -= proceeds
--                    if hasattr(deceased, '_add_assets'): deceased._add_assets(proceeds)
--                    else: deceased.assets += proceeds
-+                    # WO-116: Fallback removed. Strict enforcement.
-+                    logger.critical(f"SETTLEMENT_MISSING | Cannot liquidate stock for {deceased.id}")
- 
-                 simulation.government.total_money_issued += proceeds # Injection (Bank/Gov Buyout)
- 
-@@ -153,10 +151,7 @@ class InheritanceManager:
-                 if settlement:
-                     settlement.transfer(government, deceased, sale_price, f"liquidation_re:{unit.id}")
-                 else:
--                    if hasattr(government, '_sub_assets'): government._sub_assets(sale_price)
--                    else: government.assets -= sale_price
--                    if hasattr(deceased, '_add_assets'): deceased._add_assets(sale_price)
--                    else: deceased.assets += sale_price
-+                    logger.critical(f"SETTLEMENT_MISSING | Cannot liquidate RE for {deceased.id}")
- 
-                 simulation.government.total_money_issued += sale_price # Injection
- 
-@@ -181,10 +176,7 @@ class InheritanceManager:
-             if settlement:
-                 settlement.transfer(deceased, government, actual_tax_paid, "inheritance_tax")
-             else:
--                if hasattr(deceased, '_sub_assets'): deceased._sub_assets(actual_tax_paid)
--                else: deceased.assets -= actual_tax_paid
--                if hasattr(government, '_add_assets'): government._add_assets(actual_tax_paid)
--                else: government.assets += actual_tax_paid
-+                 logger.critical(f"SETTLEMENT_MISSING | Cannot pay inheritance tax for {deceased.id}")
- 
-             simulation.government.collect_tax(actual_tax_paid, "inheritance_tax", deceased.id, simulation.time)
- 
-@@ -204,8 +196,7 @@ class InheritanceManager:
-                 if settlement:
-                     settlement.transfer(deceased, government, surplus, "escheatment_no_heirs")
-                 else:
--                    deceased._sub_assets(surplus)
--                    government._add_assets(surplus)
-+                    logger.critical(f"SETTLEMENT_MISSING | Cannot escheat surplus for {deceased.id}")
- 
-                 simulation.government.collect_tax(surplus, "escheatment", deceased.id, simulation.time)
-                 self.logger.info(
-@@ -255,8 +246,7 @@ class InheritanceManager:
-             if settlement:
-                 settlement.transfer(deceased, heir, cash_share, f"inheritance_share:{deceased.id}")
-             else:
--                deceased._sub_assets(cash_share)
--                heir._add_assets(cash_share)
-+                logger.critical(f"SETTLEMENT_MISSING | Cannot distribute share to {heir.id}")
-             total_distributed += cash_share
- 
-         # Residual Catch-all (WO-112)
-@@ -272,8 +262,7 @@ class InheritanceManager:
-              if settlement:
-                  settlement.transfer(deceased, government, remainder, "inheritance_residual")
-              else:
--                 deceased._sub_assets(remainder)
--                 government._add_assets(remainder)
-+                 logger.critical(f"SETTLEMENT_MISSING | Cannot sweep residual for {deceased.id}")
- 
-              simulation.government.collect_tax(remainder, "inheritance_residual", deceased.id, simulation.time)
-              self.logger.info(f"RESIDUAL_CAPTURED | Transferred {remainder:.4f} residual dust to Government.")
-diff --git a/simulation/systems/lifecycle_manager.py b/simulation/systems/lifecycle_manager.py
-index 2007946..b73580a 100644
---- a/simulation/systems/lifecycle_manager.py
-+++ b/simulation/systems/lifecycle_manager.py
-@@ -137,7 +137,12 @@ class AgentLifecycleManager(AgentLifecycleManagerInterface):
-                         if household.is_active and firm.id in household.shares_owned:
-                             share_ratio = household.shares_owned[firm.id] / outstanding_shares
-                             distribution = total_cash * share_ratio
--                            household._add_assets(distribution)
-+
-+                            if state.settlement_system:
-+                                state.settlement_system.transfer(firm, household, distribution, "liquidation_dividend")
-+                            else:
-+                                household._add_assets(distribution)
-+
-                             self.logger.info(
-                                 f"LIQUIDATION_DISTRIBUTION | Household {household.id} received "
-                                 f"{distribution:.2f} from Firm {firm.id} liquidation",
-@@ -147,14 +152,25 @@ class AgentLifecycleManager(AgentLifecycleManagerInterface):
-                     from simulation.agents.government import Government
-                     if isinstance(state.government, Government):
-                         # Note: collect_tax no longer adds assets. We must transfer/add manually.
--                        state.government._add_assets(total_cash)
-+                        if state.settlement_system:
-+                            state.settlement_system.transfer(firm, state.government, total_cash, "liquidation_escheatment")
-+                        else:
-+                            state.government._add_assets(total_cash)
-+
-                         state.government.collect_tax(total_cash, "liquidation_escheatment", firm.id, state.time)
-             for household in state.households:
-                 if firm.id in household.shares_owned:
-                     del household.shares_owned[firm.id]
-                     if state.stock_market:
-                         state.stock_market.update_shareholder(household.id, firm.id, 0)
--            firm._sub_assets(firm.assets)
-+
-+            # Flush any residual dust to government or void
-+            if firm.assets > 0:
-+                if state.settlement_system:
-+                    state.settlement_system.transfer(firm, state.government, firm.assets, "liquidation_dust")
-+                else:
-+                    firm._sub_assets(firm.assets)
-+
-             self.logger.info(
-                 f"FIRM_LIQUIDATION_COMPLETE | Firm {firm.id} fully liquidated.",
-                 extra={"agent_id": firm.id, "tags": ["liquidation"]}
-diff --git a/simulation/systems/ministry_of_education.py b/simulation/systems/ministry_of_education.py
-index d0085ee..42f8188 100644
---- a/simulation/systems/ministry_of_education.py
-+++ b/simulation/systems/ministry_of_education.py
-@@ -7,7 +7,7 @@ class MinistryOfEducation:
-     def __init__(self, config_module: Any):
-         self.config_module = config_module
- 
--    def run_public_education(self, households: List[Any], government: Any, current_tick: int, reflux_system: Any = None) -> None:
-+    def run_public_education(self, households: List[Any], government: Any, current_tick: int, reflux_system: Any = None, settlement_system: Any = None) -> None:
-         """
-         WO-054: Public Education System Implementation.
-         1. Free Basic Education (Level 0 -> 1)
-@@ -38,7 +38,14 @@ class MinistryOfEducation:
-                 if edu_budget >= cost:
-                     agent.education_level = 1
-                     edu_budget -= cost
--                    government._sub_assets(cost)
-+
-+                    if settlement_system and reflux_system:
-+                         settlement_system.transfer(government, reflux_system, cost, "edu_basic_grant")
-+                    else:
-+                         government._sub_assets(cost)
-+                         if reflux_system:
-+                             reflux_system.capture(cost, str(government.id), "education_services")
-+
-                     spent_total += cost
- 
-                     logger.debug(
-@@ -57,12 +64,24 @@ class MinistryOfEducation:
-                     if edu_budget >= subsidy and agent.assets >= student_share:
-                         agent.education_level = next_level
-                         edu_budget -= subsidy
--                        government._sub_assets(subsidy)
-+
-+                        # Govt Subsidy
-+                        if settlement_system and reflux_system:
-+                             settlement_system.transfer(government, reflux_system, subsidy, "edu_subsidy")
-+                        else:
-+                             government._sub_assets(subsidy)
-+                             if reflux_system:
-+                                 reflux_system.capture(subsidy, str(government.id), "education_services")
-+
-                         spent_total += subsidy
- 
--                        agent._sub_assets(student_share)
--                        if reflux_system:
--                            reflux_system.capture(student_share, f"Household_{agent.id}", "education_tuition")
-+                        # Student Share
-+                        if settlement_system and reflux_system:
-+                             settlement_system.transfer(agent, reflux_system, student_share, "edu_tuition")
-+                        else:
-+                             agent._sub_assets(student_share)
-+                             if reflux_system:
-+                                 reflux_system.capture(student_share, f"Household_{agent.id}", "education_tuition")
- 
-                         logger.info(
-                             f"EDU_SCHOLARSHIP | Household {agent.id} (Aptitude {agent.aptitude:.2f}) promoted to Level {next_level}. Subsidy: {subsidy:.2f}, Student Share: {student_share:.2f}",
-@@ -71,7 +90,15 @@ class MinistryOfEducation:
- 
-         government.expenditure_this_tick += spent_total
-         government.total_money_issued += spent_total
--        if reflux_system:
--            reflux_system.capture(spent_total, str(government.id), "education_services")
-+
-+        # NOTE: reflux_system.capture(spent_total) was here.
-+        # But we now handle transfers inside the loop (or via fallback).
-+        # So we should REMOVE the bulk capture if using settlement.
-+        # However, for backward compatibility (if no settlement), we added fallback inside loop.
-+        # The previous code captured 'spent_total' at end.
-+        # So I moved the capture logic inside the loop for fallback case too.
-+        # Thus, remove the bulk capture here.
-+        # if reflux_system:
-+        #    reflux_system.capture(spent_total, str(government.id), "education_services")
- 
-         government.current_tick_stats["education_spending"] = spent_total
-diff --git a/simulation/systems/reflux_system.py b/simulation/systems/reflux_system.py
-index 23b8f05..56258e0 100644
---- a/simulation/systems/reflux_system.py
-+++ b/simulation/systems/reflux_system.py
-@@ -1,5 +1,6 @@
--from typing import List, Optional
-+from typing import List, Optional, Any
- import logging
-+from modules.finance.api import InsufficientFundsError
- 
- logger = logging.getLogger(__name__)
- 
-@@ -9,6 +10,24 @@ class EconomicRefluxSystem:
-         # Optional: Transaction log for debugging
-         # self.transaction_log: list = []
- 
-+    @property
-+    def id(self) -> int:
-+        return -100
-+
-+    @property
-+    def assets(self) -> float:
-+        return self.balance
-+
-+    def deposit(self, amount: float) -> None:
-+        if amount > 0:
-+            self.balance += amount
-+
-+    def withdraw(self, amount: float) -> None:
-+        if amount > 0:
-+            if self.balance < amount:
-+                raise InsufficientFundsError(f"RefluxSystem has insufficient funds: {self.balance} < {amount}")
-+            self.balance -= amount
-+
-     def capture(self, amount: float, source: str, category: str):
-         """
-         Captures money that would otherwise vanish.
-@@ -17,10 +36,10 @@ class EconomicRefluxSystem:
-         :param category: 'marketing', 'capex', 'fixed_cost', 'net_profit'
-         """
-         if amount > 0:
--            self.balance += amount
-+            self.deposit(amount)
-             logger.debug(f"REFLUX_CAPTURE | Captured {amount:.2f} from {source} ({category})")
- 
--    def distribute(self, households: list):
-+    def distribute(self, households: list, settlement_system: Any = None):
-         """
-         Distributes the total balance equally to all active households.
-         Simulates dividends and service sector wages.
-@@ -38,7 +57,10 @@ class EconomicRefluxSystem:
-         amount_per_household = total_amount / len(active_households)
- 
-         for agent in active_households:
--            agent._add_assets(amount_per_household)
-+            if settlement_system:
-+                settlement_system.transfer(self, agent, amount_per_household, "reflux_distribution")
-+            else:
-+                agent._add_assets(amount_per_household)
- 
-             # Record as additional labor income (Service Sector)
-             if hasattr(agent, "labor_income_this_tick"):
-@@ -53,4 +75,5 @@ class EconomicRefluxSystem:
-             extra={"tags": ["reflux", "distribution"], "total_amount": total_amount}
-         )
- 
--        self.balance = 0.0 # Reset
-+        if not settlement_system:
-+             self.balance = 0.0 # Reset only if manual transfer
-diff --git a/simulation/systems/transaction_processor.py b/simulation/systems/transaction_processor.py
-index 8f87319..ac8148a 100644
---- a/simulation/systems/transaction_processor.py
-+++ b/simulation/systems/transaction_processor.py
-@@ -66,14 +66,7 @@ class TransactionProcessor(SystemInterface):
-                     if tax_amount > 0:
-                         settlement.transfer(buyer, government, tax_amount, f"sales_tax:{tx.item_id}")
-                 else:
--                    if hasattr(buyer, '_sub_assets'): buyer._sub_assets(trade_value + tax_amount)
--                    else: buyer.assets -= (trade_value + tax_amount)
--
--                    if hasattr(seller, '_add_assets'): seller._add_assets(trade_value)
--                    else: seller.assets += trade_value
--
--                    if hasattr(government, '_add_assets'): government._add_assets(tax_amount)
--                    else: government.assets += tax_amount
-+                    logger.critical(f"SETTLEMENT_MISSING | Cannot process goods trade for {tx.item_id}")
- 
-                 government.collect_tax(tax_amount, f"sales_tax_{tx.transaction_type}", buyer.id, current_time)
- 
-@@ -82,10 +75,7 @@ class TransactionProcessor(SystemInterface):
-                 if settlement:
-                     settlement.transfer(buyer, seller, trade_value, f"stock_trade:{tx.item_id}")
-                 else:
--                    if hasattr(buyer, '_sub_assets'): buyer._sub_assets(trade_value)
--                    else: buyer.assets -= trade_value
--                    if hasattr(seller, '_add_assets'): seller._add_assets(trade_value)
--                    else: seller.assets += trade_value
-+                    logger.critical(f"SETTLEMENT_MISSING | Cannot process stock trade for {tx.item_id}")
-             
-             elif tx.transaction_type in ["labor", "research_labor"]:
-                 # Labor: Apply Income Tax
-@@ -107,14 +97,7 @@ class TransactionProcessor(SystemInterface):
-                         if tax_amount > 0:
-                             settlement.transfer(buyer, government, tax_amount, f"labor_tax_firm:{tx.transaction_type}")
-                     else:
--                        if hasattr(buyer, '_sub_assets'): buyer._sub_assets(trade_value + tax_amount)
--                        else: buyer.assets -= (trade_value + tax_amount)
--
--                        if hasattr(seller, '_add_assets'): seller._add_assets(trade_value)
--                        else: seller.assets += trade_value
--
--                        if hasattr(government, '_add_assets'): government._add_assets(tax_amount)
--                        else: government.assets += tax_amount
-+                        logger.critical(f"SETTLEMENT_MISSING | Cannot process firm-paid labor tax for {tx.transaction_type}")
- 
-                     government.collect_tax(tax_amount, "income_tax_firm", buyer.id, current_time)
-                 else:
-@@ -125,14 +108,7 @@ class TransactionProcessor(SystemInterface):
-                         if tax_amount > 0:
-                             settlement.transfer(buyer, government, tax_amount, f"labor_tax_withheld:{tx.transaction_type}")
-                     else:
--                        if hasattr(buyer, '_sub_assets'): buyer._sub_assets(trade_value) # Buyer pays full (net + tax split dest)
--                        else: buyer.assets -= trade_value
--
--                        if hasattr(seller, '_add_assets'): seller._add_assets(net_wage)
--                        else: seller.assets += net_wage
--
--                        if hasattr(government, '_add_assets'): government._add_assets(tax_amount)
--                        else: government.assets += tax_amount
-+                        logger.critical(f"SETTLEMENT_MISSING | Cannot process labor tax withholding for {tx.transaction_type}")
- 
-                     government.collect_tax(tax_amount, "income_tax_household", seller.id, current_time)
-             
-@@ -140,10 +116,7 @@ class TransactionProcessor(SystemInterface):
-                 if settlement:
-                     settlement.transfer(buyer, seller, trade_value, "interest_payment")
-                 else:
--                    if hasattr(buyer, '_sub_assets'): buyer._sub_assets(trade_value)
--                    else: buyer.assets -= trade_value
--                    if hasattr(seller, '_add_assets'): seller._add_assets(trade_value)
--                    else: seller.assets += trade_value
-+                    logger.critical("SETTLEMENT_MISSING | Cannot process interest payment")
- 
-                 if isinstance(buyer, Firm):
-                     buyer.finance.record_expense(trade_value)
-@@ -152,10 +125,7 @@ class TransactionProcessor(SystemInterface):
-                 if settlement:
-                     settlement.transfer(seller, buyer, trade_value, "dividend_payment")
-                 else:
--                    if hasattr(seller, '_sub_assets'): seller._sub_assets(trade_value)
--                    else: seller.assets -= trade_value
--                    if hasattr(buyer, '_add_assets'): buyer._add_assets(trade_value)
--                    else: buyer.assets += trade_value
-+                    logger.critical("SETTLEMENT_MISSING | Cannot process dividend payment")
- 
-                 if isinstance(buyer, Household) and hasattr(buyer, "capital_income_this_tick"):
-                     buyer.capital_income_this_tick += trade_value
-@@ -164,10 +134,7 @@ class TransactionProcessor(SystemInterface):
-                 if settlement:
-                     settlement.transfer(buyer, seller, trade_value, f"generic:{tx.transaction_type}")
-                 else:
--                    if hasattr(buyer, '_sub_assets'): buyer._sub_assets(trade_value)
--                    else: buyer.assets -= trade_value
--                    if hasattr(seller, '_add_assets'): seller._add_assets(trade_value)
--                    else: seller.assets += trade_value
-+                    logger.critical(f"SETTLEMENT_MISSING | Cannot process generic transaction {tx.transaction_type}")
- 
-             # ==================================================================
-             # 2. Meta Logic (Inventory, Employment, Share Registry)
-diff --git a/simulation/tick_scheduler.py b/simulation/tick_scheduler.py
-index e40f400..2269686 100644
---- a/simulation/tick_scheduler.py
-+++ b/simulation/tick_scheduler.py
-@@ -71,7 +71,7 @@ class TickScheduler:
-              state.event_system.execute_scheduled_events(state.time, context, state.stress_scenario_config)
- 
-         # WO-054: Government Public Education Logic (START OF TICK)
--        state.government.run_public_education(state.households, state.config_module, state.time, state.reflux_system)
-+        state.government.run_public_education(state.households, state.config_module, state.time, state.reflux_system, state.settlement_system)
- 
-         if (
-             state.time > 0
-@@ -310,7 +310,7 @@ class TickScheduler:
-         for firm in state.firms:
-              if firm.is_active:
-                  firm.produce(state.time, technology_manager=state.technology_manager)
--                 firm.update_needs(state.time, state.government, market_data, state.reflux_system)
-+                 firm.update_needs(state.time, state.government, market_data, state.reflux_system, settlement_system=state.settlement_system)
- 
-                  # 2a. Corporate Tax
-                  if firm.is_active and firm.current_profit > 0:
-diff --git a/tests/systems/test_tax_agency.py b/tests/systems/test_tax_agency.py
-index 1e15921..7dd9173 100644
---- a/tests/systems/test_tax_agency.py
-+++ b/tests/systems/test_tax_agency.py
-@@ -53,12 +53,28 @@ class TestTaxAgency(unittest.TestCase):
- 
-     def test_collect_tax(self):
-         mock_gov = MagicMock()
--        mock_gov._assets = 10000
-+        mock_gov.assets = 10000
-         mock_gov.total_collected_tax = 0
--        # ... other attributes ...
-+        mock_gov.revenue_this_tick = 0
-+        mock_gov.total_money_destroyed = 0
-+        mock_gov.tax_revenue = {}
-+        mock_gov.current_tick_stats = {"tax_revenue": {}, "total_collected": 0.0}
- 
--        self.tax_agency.collect_tax(mock_gov, 100, "income", 1, 1)
--        self.assertEqual(mock_gov.assets, 10100)
-+        # Mock FinanceSystem to simulate successful transfer
-+        mock_gov.finance_system = MagicMock()
-+        mock_gov.finance_system.collect_corporate_tax.return_value = True
-+
-+        mock_payer = MagicMock()
-+        mock_payer.id = 1
-+
-+        self.tax_agency.collect_tax(mock_gov, 100, "income", mock_payer, 1)
-+
-+        # Verify stats updated (assets not updated directly by TaxAgency anymore)
-+        self.assertEqual(mock_gov.total_collected_tax, 100)
-+        self.assertEqual(mock_gov.current_tick_stats["total_collected"], 100)
-+
-+        # Verify FinanceSystem interaction
-+        mock_gov.finance_system.collect_corporate_tax.assert_called_with(mock_payer, 100)
- 
- if __name__ == '__main__':
-     unittest.main()
-diff --git a/tests/test_finance_bailout.py b/tests/test_finance_bailout.py
-index 8e8a35e..76493f9 100644
---- a/tests/test_finance_bailout.py
-+++ b/tests/test_finance_bailout.py
-@@ -8,6 +8,13 @@ from modules.finance.system import FinanceSystem
- class MockConfig:
-     BAILOUT_PENALTY_PREMIUM = 0.05
-     BAILOUT_REPAYMENT_RATIO = 0.5
-+    BAILOUT_COVENANT_RATIO = 0.5
-+
-+    def get(self, key, default=None):
-+        # Handle "economy_params.KEY" by taking just "KEY"
-+        if "." in key:
-+            key = key.split(".")[-1]
-+        return getattr(self, key, default)
- 
- @pytest.fixture
- def finance_test_environment():
-@@ -17,7 +24,7 @@ def finance_test_environment():
- 
-     # We need to mock the withdraw/deposit methods to simulate transactions
-     def withdraw(amount):
--        if mock_government.assets >= amount:
-+        if mock_government._assets >= amount:
-             mock_government._assets -= amount
-         else:
-             raise InsufficientFundsError("Not enough assets.")
-@@ -72,8 +79,8 @@ def test_grant_bailout_loan_success_and_covenant_type(finance_test_environment):
-     and the returned DTO has the correct covenant type.
-     """
-     finance_system, mock_government, mock_firm = finance_test_environment
--    initial_govt_assets = mock_government.assets
--    initial_firm_assets = mock_firm.assets
-+    initial_govt_assets = mock_government._assets
-+    initial_firm_assets = mock_firm._assets
-     initial_firm_debt = mock_firm.total_debt
-     loan_amount = 50_000
- 
-@@ -89,17 +96,17 @@ def test_grant_bailout_loan_success_and_covenant_type(finance_test_environment):
- 
-     # Assert - Money Flow Verification
-     # 1. Government assets should decrease
--    assert mock_government.assets == initial_govt_assets - loan_amount
-+    assert mock_government._assets == initial_govt_assets - loan_amount
-     # 2. Firm should have received the funds and taken on the liability
-     mock_firm.finance.add_liability.assert_called_once()
-     # 3. Verify firm's final state
--    assert mock_firm.assets == initial_firm_assets + loan_amount
-+    assert mock_firm._assets == initial_firm_assets + loan_amount
-     assert mock_firm.total_debt == initial_firm_debt + loan_amount
-     # 4. Firm should be marked as having a bailout loan
-     assert mock_firm.has_bailout_loan is True
- 
-     # Assert - Regression check for money creation/destruction
--    final_total_assets = mock_government.assets + mock_firm.assets
-+    final_total_assets = mock_government._assets + mock_firm._assets
-     initial_total_assets = initial_govt_assets + initial_firm_assets
-     assert final_total_assets == initial_total_assets
- 
-@@ -114,13 +121,13 @@ def test_grant_bailout_loan_insufficient_government_funds(finance_test_environme
-     loan_amount = 2_000_000
-     mock_government._assets = 1_000_000 # Government has 1M, loan is 2M
- 
--    initial_govt_assets = mock_government.assets
--    initial_firm_assets = mock_firm.assets
-+    initial_govt_assets = mock_government._assets
-+    initial_firm_assets = mock_firm._assets
-     initial_firm_debt = mock_firm.total_debt
- 
-     # Redefine the side effect for this specific test case to raise the error
-     def limited_withdraw(amount):
--        if mock_government.assets < amount:
-+        if mock_government._assets < amount:
-             raise InsufficientFundsError("Test: Not enough funds")
-         mock_government._assets -= amount
-     mock_government.withdraw.side_effect = limited_withdraw
-@@ -132,8 +139,8 @@ def test_grant_bailout_loan_insufficient_government_funds(finance_test_environme
-     # 1. No loan DTO should be returned
-     assert loan_dto is None
-     # 2. No money should have moved
--    assert mock_government.assets == initial_govt_assets
--    assert mock_firm.assets == initial_firm_assets
-+    assert mock_government._assets == initial_govt_assets
-+    assert mock_firm._assets == initial_firm_assets
-     assert mock_firm.total_debt == initial_firm_debt
-     # 3. Firm should not be marked as having a loan
-     assert mock_firm.has_bailout_loan is False
diff --git a/design/gemini_output/pr_review_verify-great-reset-stability-16428660261459271791.md b/design/gemini_output/pr_review_verify-great-reset-stability-16428660261459271791.md
deleted file mode 100644
index 06952cd..0000000
--- a/design/gemini_output/pr_review_verify-great-reset-stability-16428660261459271791.md
+++ /dev/null
@@ -1,46 +0,0 @@
-🕵️  Reviewing Code with instruction: 'Analyze this PR.'...
-📖 Attached context: C:\coding\economics\design\gemini_output\pr_diff_verify-great-reset-stability-16428660261459271791.txt
-🚀 [GeminiWorker] Running task with manual: git_reviewer.md
-
-📝 [Review Report]
-============================================================
-# 🔍 Git Diff Review: WO-115 Great Reset Stability
-
----
-
-### 🔍 Summary
-이 PR은 'Great Reset' 시나리오의 안정성을 검증하기 위한 새로운 스트레스 테스트 스크립트(`verify_great_reset_stability.py`)와 관련 리포트를 추가합니다. 이와 함께 여러 시스템(`commerce`, `ma_manager` 등)에서 자산(asset)을 직접 수정하는 대신 `deposit`/`withdraw` 메서드를 사용하도록 리팩토링하여 트랜잭션의 정합성을 강화했습니다.
-
----
-
-### 🚨 Critical Issues
-- 발견되지 않았습니다. API 키, 시스템 절대 경로, 외부 레포지토리 URL과 같은 심각한 보안 문제는 포함되어 있지 않습니다.
-
----
-
-### ⚠️ Logic & Spec Gaps
-1.  **캡슐화 위반 (Encapsulation Breach) in Verification Script**:
-    - **파일**: `scripts/verify_great_reset_stability.py`
-    - **문제**: M2 통화량을 계산하는 로직(`lines 78-88`)에서 각 경제 주체(가계, 기업 등)의 자산을 `h.assets`, `f.assets`와 같이 직접 조회하고 있습니다. 이 PR의 다른 부분에서는 `assets -= ...`와 같은 직접적인 자산 수정을 `withdraw()` 메서드로 변경하며 캡슐화를 강화하고 있는데, 정작 검증 스크립트가 이 원칙을 위배하고 있습니다. 이는 향후 모델의 내부 구현이 변경될 경우 검증 코드가 깨지기 쉬운 구조입니다.
-
-2.  **불명확한 화폐 창출 메커니즘 분석**:
-    - **파일**: `scripts/verify_great_reset_stability.py`
-    - **문제**: 스크립트 내 주석(`lines 160-170`)을 보면 은행의 대출 과정에서 화폐가 어떻게 창출되는지에 대한 메커니즘이 불확실한 상태에서 M2 변화량을 분석하고 있습니다. (`// In this sim, does Bank have infinite cash or is it constrained?`). 검증 스크립트는 시스템의 동작을 '단언'해야 하는데, 핵심 로직에 대한 가정이 불분명하면 검증 결과의 신뢰도가 떨어질 수 있습니다.
-
----
-
-### 💡 Suggestions
-1.  **검증 스크립트 리팩토링**:
-    - `verify_great_reset_stability.py`에서 각 에이전트의 자산을 직접 접근하는 대신, `get_assets()`와 같은 공식적인 인터페이스나 public property를 사용하도록 수정하는 것을 권장합니다. 이는 이 PR의 다른 파일에서 진행된 리팩토링 방향과 일치하며 코드의 유지보수성을 높입니다.
-
-2.  **리팩토링의 일관성**:
-    - `simulation/systems/commerce_system.py`와 `simulation/systems/ma_manager.py`에서 자산 직접 수정을 `withdraw`/`deposit`으로 변경한 것은 매우 훌륭한 개선입니다. 이러한 원칙이 프로젝트 전반에 걸쳐 일관되게 적용될 필요가 있습니다.
-
----
-
-### ✅ Verdict
-**REQUEST CHANGES**
-
-**이유**: PR의 전반적인 방향성(안정성 테스트 추가, 트랜잭션 정합성 강화)은 매우 긍정적입니다. 그러나 새로 추가된 핵심 검증 스크립트가 다른 파일에서 개선하고 있는 아키텍처 원칙(캡슐화)을 위반하고 있어 일관성이 부족합니다. 제안된 내용을 반영하여 코드를 수정하면 더 견고하고 유지보수하기 좋은 구조가 될 것입니다.
-
-============================================================
diff --git a/design/gemini_output/pr_review_wo-116-asset-cleanup-2810292832470995059.md b/design/gemini_output/pr_review_wo-116-asset-cleanup-2810292832470995059.md
deleted file mode 100644
index 18f269e..0000000
--- a/design/gemini_output/pr_review_wo-116-asset-cleanup-2810292832470995059.md
+++ /dev/null
@@ -1,39 +0,0 @@
-🕵️  Reviewing Code with instruction: 'Analyze this PR.'...
-📖 Attached context: C:\coding\economics\design\gemini_output\pr_diff_wo-116-asset-cleanup-2810292832470995059.txt
-🚀 [GeminiWorker] Running task with manual: git_reviewer.md
-
-📝 [Review Report]
-============================================================
-# 🔍 PR Review: WO-116 Asset Cleanup & Settlement System Integration
-
-### 1. 🔍 Summary
-이 변경 사항은 시스템 전반에 걸쳐 자산 이동의 정합성을 보장하기 위해 `SettlementSystem`을 도입하는 대규모 리팩토링입니다. 기존의 `_add_assets` 및 `_sub_assets`를 사용한 수동적인 자산 증감 로직을 원자적(atomic)인 `settlement.transfer`로 대체하여, 돈 복사 및 자산 누수 버그의 근본적인 원인을 제거하는 것을 목표로 합니다. 이는 시스템의 재무 건전성을 크게 향상시키는 중요한 아키텍처 개선입니다.
-
-### 2. 🚨 Critical Issues
-- **(POTENTIAL) Logic Flaw**: `simulation/systems/housing_system.py`의 `process_sale` 함수에서 정부(seller)에게 주택 판매 대금을 지급하는 로직이 매우 복잡하고 위험해 보입니다.
-    - 개발자가 남긴 주석(`# DOUBLE CHARGE!`)에서 정확히 지적했듯이, `settlement.transfer(buyer, seller, ...)`를 호출하여 이미 대금을 정부에 이전한 후, `seller.collect_tax(...)`를 다시 호출하고 있습니다.
-    - 만약 `collect_tax` 내부에서도 자산 이전 로직이 실행된다면, 구매자에게 **대금이 이중으로 청구될 수 있는 심각한 버그**가 발생할 수 있습니다.
-    - 현재는 이중 청구를 피하기 위해 수동으로 정부의 통계(`revenue_this_tick`, `total_collected`)만 업데이트하고 있지만, 이는 `collect_tax` API의 책임이 모호하다는 증거이며 임시방편에 가깝습니다.
-
-### 3. ⚠️ Logic & Spec Gaps
-- **API Contract Ambiguity**: `government.collect_tax` 메소드의 역할이 불분명해졌습니다. 과거에는 세금 징수와 자산 증가를 모두 처리했을 수 있으나, 이제 `SettlementSystem`이 자산 이전을 전담합니다. `collect_tax`가 통계 기록용인지, 실제 자산 이전용인지 명확히 구분되지 않아 `housing_system.py`와 같은 혼란과 잠재적 버그를 유발하고 있습니다.
-- **Inconsistent Fallback Logic**: `inheritance_manager.py`와 `transaction_processor.py`에서는 `SettlementSystem`이 없을 경우 `logger.critical`을 호출하며 시스템을 사실상 중단시키는 'Strict Mode'를 채택했습니다. 이는 매우 좋은 결정입니다.
-    - 하지만 `government.py`, `finance_department.py` 등 다른 여러 파일에서는 `SettlementSystem`이 없으면 기존의 수동 `_sub/_add` 방식을 사용하는 폴백(fallback) 로직이 여전히 남아있습니다.
-    - 이러한 불일치는 시스템의 특정 부분에서는 자산 정합성을 강제하지만, 다른 부분에서는 여전히 잠재적인 오류에 노출되게 만듭니다.
-
-### 4. 💡 Suggestions
-- **Refactor `government.collect_tax`**: `collect_tax` 메소드의 책임을 명확히 분리해야 합니다.
-    1.  `government.record_revenue(amount, category, ...)`: 순수하게 통계만 기록하는 메소드.
-    2.  `finance_system.execute_tax_payment(payer, amount, ...)`: 실제 세금 이전만 담당하는 메소드.
-    - 이렇게 분리하면 `housing_system.py`의 복잡한 문제를 깨끗하게 해결할 수 있습니다. (`settlement.transfer` 호출 후 `government.record_revenue`를 호출)
-- **Deprecate Fallbacks**: 'Strict Mode'를 프로젝트 전반으로 확장할 계획을 세워야 합니다. 전환 기간 동안 레거시 폴백 로직이 필요할 수는 있으나, 빠른 시일 내에 모든 자산 이전이 `SettlementSystem`을 통하도록 강제하고, 폴백 로직을 제거하여 코드베이스의 일관성과 안정성을 높이는 것이 바람직합니다.
-- **Minor Style (`tests/test_finance_bailout.py`)**: 테스트 코드에서 `mock_government.assets` 대신 `mock_government._assets`와 같이 내부 속성에 직접 접근하고 있습니다. 이는 테스트의 불안정성을 높일 수 있으므로, 가능하다면 public 인터페이스를 통해 값을 확인하도록 수정하는 것을 권장합니다.
-
-### 5. ✅ Verdict
-**REQUEST CHANGES**
-
-이번 PR은 프로젝트의 재무 안정성을 위한 매우 긍정적이고 필수적인 단계입니다. 개발자는 `SettlementSystem`이라는 올바른 해결책을 도입했으며, 복잡한 로직의 잠재적 위험을 스스로 발견하는 등 훌륭한 작업을 수행했습니다.
-
-다만, `government.collect_tax` API의 모호성으로 인해 발생한 잠재적 이중 청구 버그는 반드시 수정되어야 합니다. 제안된 리팩토링을 통해 API의 책임을 명확히 하고 코드의 안정성을 확보한 후 `APPROVE`하는 것이 좋겠습니다.
-
-============================================================
diff --git a/design/gemini_output/review_backup_20260123_134405_Analyze_this_PR.md b/design/gemini_output/review_backup_20260123_134405_Analyze_this_PR.md
deleted file mode 100644
index 20d2670..0000000
--- a/design/gemini_output/review_backup_20260123_134405_Analyze_this_PR.md
+++ /dev/null
@@ -1,38 +0,0 @@
-# 🔍 Git Diff Review: WO-115 Great Reset Stability
-
----
-
-### 🔍 Summary
-이 PR은 'Great Reset' 시나리오의 안정성을 검증하기 위한 새로운 스트레스 테스트 스크립트(`verify_great_reset_stability.py`)와 관련 리포트를 추가합니다. 이와 함께 여러 시스템(`commerce`, `ma_manager` 등)에서 자산(asset)을 직접 수정하는 대신 `deposit`/`withdraw` 메서드를 사용하도록 리팩토링하여 트랜잭션의 정합성을 강화했습니다.
-
----
-
-### 🚨 Critical Issues
-- 발견되지 않았습니다. API 키, 시스템 절대 경로, 외부 레포지토리 URL과 같은 심각한 보안 문제는 포함되어 있지 않습니다.
-
----
-
-### ⚠️ Logic & Spec Gaps
-1.  **캡슐화 위반 (Encapsulation Breach) in Verification Script**:
-    - **파일**: `scripts/verify_great_reset_stability.py`
-    - **문제**: M2 통화량을 계산하는 로직(`lines 78-88`)에서 각 경제 주체(가계, 기업 등)의 자산을 `h.assets`, `f.assets`와 같이 직접 조회하고 있습니다. 이 PR의 다른 부분에서는 `assets -= ...`와 같은 직접적인 자산 수정을 `withdraw()` 메서드로 변경하며 캡슐화를 강화하고 있는데, 정작 검증 스크립트가 이 원칙을 위배하고 있습니다. 이는 향후 모델의 내부 구현이 변경될 경우 검증 코드가 깨지기 쉬운 구조입니다.
-
-2.  **불명확한 화폐 창출 메커니즘 분석**:
-    - **파일**: `scripts/verify_great_reset_stability.py`
-    - **문제**: 스크립트 내 주석(`lines 160-170`)을 보면 은행의 대출 과정에서 화폐가 어떻게 창출되는지에 대한 메커니즘이 불확실한 상태에서 M2 변화량을 분석하고 있습니다. (`// In this sim, does Bank have infinite cash or is it constrained?`). 검증 스크립트는 시스템의 동작을 '단언'해야 하는데, 핵심 로직에 대한 가정이 불분명하면 검증 결과의 신뢰도가 떨어질 수 있습니다.
-
----
-
-### 💡 Suggestions
-1.  **검증 스크립트 리팩토링**:
-    - `verify_great_reset_stability.py`에서 각 에이전트의 자산을 직접 접근하는 대신, `get_assets()`와 같은 공식적인 인터페이스나 public property를 사용하도록 수정하는 것을 권장합니다. 이는 이 PR의 다른 파일에서 진행된 리팩토링 방향과 일치하며 코드의 유지보수성을 높입니다.
-
-2.  **리팩토링의 일관성**:
-    - `simulation/systems/commerce_system.py`와 `simulation/systems/ma_manager.py`에서 자산 직접 수정을 `withdraw`/`deposit`으로 변경한 것은 매우 훌륭한 개선입니다. 이러한 원칙이 프로젝트 전반에 걸쳐 일관되게 적용될 필요가 있습니다.
-
----
-
-### ✅ Verdict
-**REQUEST CHANGES**
-
-**이유**: PR의 전반적인 방향성(안정성 테스트 추가, 트랜잭션 정합성 강화)은 매우 긍정적입니다. 그러나 새로 추가된 핵심 검증 스크립트가 다른 파일에서 개선하고 있는 아키텍처 원칙(캡슐화)을 위반하고 있어 일관성이 부족합니다. 제안된 내용을 반영하여 코드를 수정하면 더 견고하고 유지보수하기 좋은 구조가 될 것입니다.
diff --git a/design/gemini_output/review_backup_20260123_134431_Analyze_this_PR.md b/design/gemini_output/review_backup_20260123_134431_Analyze_this_PR.md
deleted file mode 100644
index 1579668..0000000
--- a/design/gemini_output/review_backup_20260123_134431_Analyze_this_PR.md
+++ /dev/null
@@ -1,31 +0,0 @@
-# 🔍 PR Review: WO-116 Asset Cleanup & Settlement System Integration
-
-### 1. 🔍 Summary
-이 변경 사항은 시스템 전반에 걸쳐 자산 이동의 정합성을 보장하기 위해 `SettlementSystem`을 도입하는 대규모 리팩토링입니다. 기존의 `_add_assets` 및 `_sub_assets`를 사용한 수동적인 자산 증감 로직을 원자적(atomic)인 `settlement.transfer`로 대체하여, 돈 복사 및 자산 누수 버그의 근본적인 원인을 제거하는 것을 목표로 합니다. 이는 시스템의 재무 건전성을 크게 향상시키는 중요한 아키텍처 개선입니다.
-
-### 2. 🚨 Critical Issues
-- **(POTENTIAL) Logic Flaw**: `simulation/systems/housing_system.py`의 `process_sale` 함수에서 정부(seller)에게 주택 판매 대금을 지급하는 로직이 매우 복잡하고 위험해 보입니다.
-    - 개발자가 남긴 주석(`# DOUBLE CHARGE!`)에서 정확히 지적했듯이, `settlement.transfer(buyer, seller, ...)`를 호출하여 이미 대금을 정부에 이전한 후, `seller.collect_tax(...)`를 다시 호출하고 있습니다.
-    - 만약 `collect_tax` 내부에서도 자산 이전 로직이 실행된다면, 구매자에게 **대금이 이중으로 청구될 수 있는 심각한 버그**가 발생할 수 있습니다.
-    - 현재는 이중 청구를 피하기 위해 수동으로 정부의 통계(`revenue_this_tick`, `total_collected`)만 업데이트하고 있지만, 이는 `collect_tax` API의 책임이 모호하다는 증거이며 임시방편에 가깝습니다.
-
-### 3. ⚠️ Logic & Spec Gaps
-- **API Contract Ambiguity**: `government.collect_tax` 메소드의 역할이 불분명해졌습니다. 과거에는 세금 징수와 자산 증가를 모두 처리했을 수 있으나, 이제 `SettlementSystem`이 자산 이전을 전담합니다. `collect_tax`가 통계 기록용인지, 실제 자산 이전용인지 명확히 구분되지 않아 `housing_system.py`와 같은 혼란과 잠재적 버그를 유발하고 있습니다.
-- **Inconsistent Fallback Logic**: `inheritance_manager.py`와 `transaction_processor.py`에서는 `SettlementSystem`이 없을 경우 `logger.critical`을 호출하며 시스템을 사실상 중단시키는 'Strict Mode'를 채택했습니다. 이는 매우 좋은 결정입니다.
-    - 하지만 `government.py`, `finance_department.py` 등 다른 여러 파일에서는 `SettlementSystem`이 없으면 기존의 수동 `_sub/_add` 방식을 사용하는 폴백(fallback) 로직이 여전히 남아있습니다.
-    - 이러한 불일치는 시스템의 특정 부분에서는 자산 정합성을 강제하지만, 다른 부분에서는 여전히 잠재적인 오류에 노출되게 만듭니다.
-
-### 4. 💡 Suggestions
-- **Refactor `government.collect_tax`**: `collect_tax` 메소드의 책임을 명확히 분리해야 합니다.
-    1.  `government.record_revenue(amount, category, ...)`: 순수하게 통계만 기록하는 메소드.
-    2.  `finance_system.execute_tax_payment(payer, amount, ...)`: 실제 세금 이전만 담당하는 메소드.
-    - 이렇게 분리하면 `housing_system.py`의 복잡한 문제를 깨끗하게 해결할 수 있습니다. (`settlement.transfer` 호출 후 `government.record_revenue`를 호출)
-- **Deprecate Fallbacks**: 'Strict Mode'를 프로젝트 전반으로 확장할 계획을 세워야 합니다. 전환 기간 동안 레거시 폴백 로직이 필요할 수는 있으나, 빠른 시일 내에 모든 자산 이전이 `SettlementSystem`을 통하도록 강제하고, 폴백 로직을 제거하여 코드베이스의 일관성과 안정성을 높이는 것이 바람직합니다.
-- **Minor Style (`tests/test_finance_bailout.py`)**: 테스트 코드에서 `mock_government.assets` 대신 `mock_government._assets`와 같이 내부 속성에 직접 접근하고 있습니다. 이는 테스트의 불안정성을 높일 수 있으므로, 가능하다면 public 인터페이스를 통해 값을 확인하도록 수정하는 것을 권장합니다.
-
-### 5. ✅ Verdict
-**REQUEST CHANGES**
-
-이번 PR은 프로젝트의 재무 안정성을 위한 매우 긍정적이고 필수적인 단계입니다. 개발자는 `SettlementSystem`이라는 올바른 해결책을 도입했으며, 복잡한 로직의 잠재적 위험을 스스로 발견하는 등 훌륭한 작업을 수행했습니다.
-
-다만, `government.collect_tax` API의 모호성으로 인해 발생한 잠재적 이중 청구 버그는 반드시 수정되어야 합니다. 제안된 리팩토링을 통해 API의 책임을 명확히 하고 코드의 안정성을 확보한 후 `APPROVE`하는 것이 좋겠습니다.
diff --git a/modules/household/dtos.py b/modules/household/dtos.py
index c86f5d6..5cbb990 100644
--- a/modules/household/dtos.py
+++ b/modules/household/dtos.py
@@ -39,6 +39,8 @@ class HouseholdStateDTO:
     conformity: float = 0.5
     social_rank: float = 0.5
     approval_rating: int = 1
+    optimism: float = 0.5
+    ambition: float = 0.5
 
     # WO-108: Parity Fields
     perceived_fair_price: Dict[str, float] = field(default_factory=dict)
diff --git a/simulation/ai/firm_system2_planner.py b/simulation/ai/firm_system2_planner.py
index 700697e..f17deb2 100644
--- a/simulation/ai/firm_system2_planner.py
+++ b/simulation/ai/firm_system2_planner.py
@@ -15,7 +15,7 @@ class FirmSystem2Planner:
     """
 
     def __init__(self, firm: Any, config_module: Any):
-        self.firm = firm
+        self.firm = firm # Deprecated, keep for compatibility if needed or pass None
         self.config = config_module
         self.logger = logging.getLogger(__name__)
 
@@ -28,22 +28,53 @@ class FirmSystem2Planner:
         self.last_calc_tick = -999
         self.cached_guidance: Dict[str, Any] = {}
 
-    def project_future(self, current_tick: int, market_data: Dict[str, Any]) -> Dict[str, Any]:
+    def project_future(self, current_tick: int, market_data: Dict[str, Any], firm_state: Optional[Any] = None) -> Dict[str, Any]:
         """
         Projects future cash flows to determine strategic direction.
         Returns guidance dictionary.
+        Uses firm_state (FirmStateDTO).
         """
         if current_tick - self.last_calc_tick < self.calc_interval and self.cached_guidance:
             return self.cached_guidance
 
         self.last_calc_tick = current_tick
 
+        if firm_state is None:
+            # Purity Gate: Strict requirement for DTO
+            raise ValueError("FirmSystem2Planner requires firm_state (FirmStateDTO).")
+
+        # Abstraction layer to access data from DTO
+        revenue = firm_state.revenue_this_turn
+        last_revenue = revenue # DTO might not have last_revenue, approximate
+
+        # Sum wages from employees_data
+        current_wages = 0.0
+        if firm_state.employees_data:
+            current_wages = sum(e['wage'] for e in firm_state.employees_data.values())
+
+        automation_level = firm_state.automation_level
+
+        # Map string to Enum
+        personality_data = firm_state.agent_data.get("personality", "BALANCED")
+        if isinstance(personality_data, Personality):
+            personality = personality_data
+        else:
+            try:
+                # Handle "Personality.BALANCED" string format if present
+                if "Personality." in str(personality_data):
+                    clean_name = str(personality_data).split(".")[-1]
+                    personality = Personality[clean_name]
+                else:
+                    personality = Personality[str(personality_data).upper()]
+            except (KeyError, AttributeError):
+                personality = Personality.BALANCED
+
+        assets = firm_state.assets
+
         # 1. Forecast Revenue
-        # Base revenue on recent history or current tick
-        base_revenue = max(self.firm.finance.revenue_this_turn, self.firm.finance.last_revenue, 10.0)
+        base_revenue = max(revenue, last_revenue, 10.0)
 
         # 2. Forecast Costs (Status Quo)
-        current_wages = sum(self.firm.hr.employee_wages.values())
         current_maintenance = getattr(self.config, "FIRM_MAINTENANCE_FEE", 50.0)
 
         # 3. Scenario Analysis: Automation Investment
@@ -53,19 +84,10 @@ class FirmSystem2Planner:
 
         # Scenario B: High Automation (Target 0.8)
         target_a = 0.8
-        current_a = self.firm.automation_level
+        current_a = automation_level
         gap = max(0.0, target_a - current_a)
 
         # Investment Cost Calculation (Aligned with CorporateManager logic?)
-        # CorporateManager uses: Cost = cost_per_pct * (gap * 100.0)
-        # Spec says: "Firm Size (Assets)".
-        # But for test consistency with `test_system2_planner_guidance`, let's check assumptions.
-        # My test assumes Cost = Assets * Gap (approx).
-        # Let's align code with a reasonable assumption.
-        # If Cost = 1000 * (Gap*100), then for Gap=0.8, Cost = 1000 * 80 = 80,000.
-        # If firm assets = 50,000, it can't afford it in one go.
-        # But NPV calculation should account for total cost.
-        # Let's assume cost is spread or total capital cost.
         cost_per_pct = getattr(self.config, "AUTOMATION_COST_PER_PCT", 1000.0)
         investment_cost = cost_per_pct * (gap * 100.0)
 
@@ -84,24 +106,23 @@ class FirmSystem2Planner:
 
         # Hurdle Rate Logic
         hurdle = 1.1
-        if self.firm.personality == Personality.CASH_COW:
+        if personality == Personality.CASH_COW:
              hurdle = 1.0 # No premium needed
 
         # Check if investment is logically sound (NPV > Status Quo)
         if npv_automated > npv_status_quo * hurdle:
             target_automation = max(target_automation, target_a)
             # If CASH_COW, push it further?
-            if self.firm.personality == Personality.CASH_COW:
+            if personality == Personality.CASH_COW:
                  target_automation = max(target_automation, 0.9)
 
         # 6. R&D Strategy
-        personality = self.firm.personality
         rd_intensity = 0.2 if personality == Personality.GROWTH_HACKER else 0.05
 
         # 7. M&A Strategy
         expansion_mode = "ORGANIC"
         if personality == Personality.GROWTH_HACKER or personality == Personality.BALANCED:
-            if self.firm.assets > self.firm.finance.revenue_this_turn * 50:
+            if assets > revenue * 50:
                 expansion_mode = "MA"
 
         guidance = {
diff --git a/simulation/core_agents.py b/simulation/core_agents.py
index 9c64b79..34d0aa5 100644
--- a/simulation/core_agents.py
+++ b/simulation/core_agents.py
@@ -651,6 +651,8 @@ class Household(BaseAgent, ILearningAgent):
             conformity=self.conformity,
             social_rank=self.social_rank,
             approval_rating=self.approval_rating,
+            optimism=self.optimism,
+            ambition=self.ambition,
             # WO-108: Parity Fields
             perceived_fair_price=self.perceived_avg_prices.copy(),
             sentiment_index=self.optimism
@@ -733,7 +735,6 @@ class Household(BaseAgent, ILearningAgent):
 
         # Context for Decision Engine (Pure Logic)
         context = DecisionContext(
-            household=self, # DEPRECATED: Required for pending legacy engines
             state=state_dto,
             config=config_dto,
             markets=markets,
diff --git a/simulation/decisions/README.md b/simulation/decisions/README.md
new file mode 100644
index 0000000..a7e761e
--- /dev/null
+++ b/simulation/decisions/README.md
@@ -0,0 +1,29 @@
+# Decisions Module
+
+This directory contains the decision-making engines for Agents (Households and Firms).
+
+## DTO Purity Gate & Internal Order Pattern
+
+As of **WO-114**, the simulation enforces a strict "Purity Gate" architecture to decouple decision logic (Pure Function) from state mutation (Side Effect).
+
+### 1. Purity Gate (DTOs)
+Decision Engines must **NEVER** access Agent instances (`Firm`, `Household`) directly. Instead, they receive read-only Data Transfer Objects (DTOs) via the `DecisionContext`:
+- `FirmStateDTO`
+- `HouseholdStateDTO`
+
+This ensures that the decision process is deterministic, testable, and free from unintended side effects during the decision phase.
+
+### 2. Internal Order Pattern
+Decision Engines express their intent by returning a list of `Order` objects. To modify an agent's internal state (e.g., setting production targets, firing employees, investing in R&D), engines use **Internal Orders**.
+
+**Mechanism:**
+1. **Intent:** The Engine returns an `Order` with `market_id="internal"`.
+2. **Type:** The `order_type` specifies the action (e.g., `SET_TARGET`, `INVEST_RD`, `FIRE`).
+3. **Execution:** The Agent class (e.g., `Firm.make_decision`) intercepts these orders before returning external market orders to the system. It executes the logic locally.
+
+**Examples of Internal Orders:**
+- `Order(type="SET_TARGET", quantity=150, market_id="internal")`: Sets production target.
+- `Order(type="INVEST_AUTOMATION", quantity=5000, market_id="internal")`: Deducts cash and increases automation level.
+- `Order(type="FIRE", target_agent_id=101, price=2000, market_id="internal")`: Fires employee 101 and pays 2000 severance.
+
+This pattern standardizes all agent outputs as "Orders," whether they target the external market or the agent's own configuration.
diff --git a/simulation/decisions/ai_driven_household_engine.py b/simulation/decisions/ai_driven_household_engine.py
index 39000a8..491ed30 100644
--- a/simulation/decisions/ai_driven_household_engine.py
+++ b/simulation/decisions/ai_driven_household_engine.py
@@ -10,7 +10,6 @@ from simulation.dtos import DecisionContext, MacroFinancialContext
 from simulation.decisions.portfolio_manager import PortfolioManager
 
 if TYPE_CHECKING:
-    from simulation.core_agents import Household
     from simulation.ai.household_ai import HouseholdAI
     from modules.household.dtos import HouseholdStateDTO
     from simulation.dtos import HouseholdConfigDTO
@@ -43,13 +42,12 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
         """
         AI 엔진을 사용하여 최적의 전술(Vector)을 결정하고, 그에 따른 주문을 생성한다.
         Architecture V2: Continuous Aggressiveness
+        Refactored for DTO Purity Gate.
         """
-        # [Refactoring] Use state DTO
         household: HouseholdStateDTO = context.state
         config: HouseholdConfigDTO = context.config
 
         if household is None:
-            # Fallback action vector for returning if agent is None
             from simulation.schemas import HouseholdActionVector
             return [], HouseholdActionVector()
 
@@ -59,7 +57,7 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
 
         agent_data = household.agent_data
 
-        goods_list = list(config.GOODS.keys()) # Error here, DTO doesn't have GOODS.
+        goods_list = list(self.config_module.GOODS.keys())
         
         action_vector = self.ai_engine.decide_action_vector(
             agent_data, market_data, goods_list
@@ -114,7 +112,7 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
             if not avg_price or avg_price <= 0:
                 avg_price = config.market_price_fallback
             
-            good_info = self.config_module.GOODS.get(item_id, {}) # GOODS not in config DTO yet
+            good_info = self.config_module.GOODS.get(item_id, {})
             is_luxury = good_info.get("is_luxury", False)
 
             # Need Value (UC)
@@ -153,7 +151,6 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
                     f"SavROI: {savings_roi:.4f} vs ConsROI: {consumption_roi:.4f} -> Agg: {agg_buy:.2f}"
                 )
             
-            good_info = self.config_module.GOODS.get(item_id, {})
             utility_effects = good_info.get("utility_effects", {})
             
             avg_price = market_data.get("goods_market", {}).get(f"{item_id}_current_sell_price", self.config_module.MARKET_PRICE_FALLBACK)
@@ -246,15 +243,6 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
 
         # Scenario B: Unemployed
         if not household.is_employed:
-            # Panic check logic duplicated from EconComponent?
-            # Ideally EconComponent should handle reservation wage calculation and panic check.
-            # But Engine decides TO SELL or NOT.
-            # We use 'wage_modifier' from state which is updated by EconComponent (via run_tick/lifecycle?).
-            # Actually, EconComponent._calculate_shadow_reservation_wage is called AFTER decisions in original code.
-            # So here we use current state.
-
-            # Survival Trigger (Panic Mode) - Logic moved here or duplicated?
-            # Original code had panic logic here.
             food_inventory = household.inventory.get("basic_food", 0.0)
             food_price = market_data.get("goods_market", {}).get("basic_food_avg_traded_price", 10.0)
             if food_price <= 0: food_price = 10.0
@@ -341,37 +329,12 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
             emergency_orders = self._check_emergency_liquidity(household, market_data, current_time)
             orders.extend(emergency_orders)
 
-        # 6. Real Estate Logic (Moved to EconComponent mostly, but Engine has Mimicry check)
-        # We keep Mimicry check here if it's AI driven?
-        # The logic was "Check Mimicry Trigger".
-        # If the housing logic is deterministic (based on mimicry factor), it belongs in EconComponent or here?
-        # Previous code had it here.
-        # But `Household.make_decision` called `decide_housing` (System 2) which sets `housing_target_mode`.
-        # Engine's logic below seems independent? "If housing in markets...".
-        # It generates BUY order if mimicry or rational.
-        # This seems to overlap with `EconComponent` logic?
-        # `EconComponent` checks `housing_target_mode == "BUY"`.
-        # Engine checks mimicry/rational and ADDS order.
-        # So we might have double orders if we are not careful?
-        # `EconComponent` adds order if `housing_target_mode` is BUY.
-        # `housing_target_mode` is set by `decide_housing` (System 2).
-        # Engine (here) uses `HousingManager` (System 2? No, `simulation.decisions.housing_manager`).
-        # This seems to be a conflict in original code or parallel systems.
-        # I will preserve this logic as is, assuming it's distinct.
-        # It modifies `orders` list.
-
+        # 6. Real Estate Logic
         if "housing" in markets:
              housing_market = markets["housing"]
              from simulation.decisions.housing_manager import HousingManager
-             # HousingManager needs Household object?
-             # HousingManager constructor: `__init__(self, household, config_module)`.
-             # Does it accept DTO?
-             # Probably not. It likely accesses `household.assets`, etc.
-             # If `HousingManager` is used, we need to check if it supports DTO.
-             # If not, we might need to update `HousingManager` or pass a compatible object.
-             # DTO has most fields. Duck typing might work.
 
-             housing_manager = HousingManager(household, self.config_module) # duck typing
+             housing_manager = HousingManager(household, self.config_module) # Now passes DTO
 
              reference_standard = market_data.get("reference_standard", {})
              mimicry_intent = housing_manager.decide_mimicry_purchase(reference_standard)
@@ -622,10 +585,7 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
         """
         Calls AI engine to decide reproduction.
         """
-        household = context.state # Use state
-        if household is None and context.household: # Fallback
-             household = context.household.create_state_dto()
-
+        household = context.state
         if not household: return False
 
         agent_data = household.agent_data
diff --git a/simulation/decisions/corporate_manager.py b/simulation/decisions/corporate_manager.py
index b2ba55c..6c2a6c6 100644
--- a/simulation/decisions/corporate_manager.py
+++ b/simulation/decisions/corporate_manager.py
@@ -1,18 +1,14 @@
 from __future__ import annotations
-from typing import TYPE_CHECKING, List, Optional, Any, Dict
+from typing import List, Optional, Any, Dict
 import logging
 import random
-import math
 
 from simulation.models import Order, StockOrder
 from simulation.schemas import FirmActionVector
-from simulation.dtos import DecisionContext
+from simulation.dtos import DecisionContext, FirmStateDTO
 from simulation.ai.firm_system2_planner import FirmSystem2Planner
 from simulation.markets.stock_market import StockMarket
 
-if TYPE_CHECKING:
-    from simulation.firms import Firm
-
 logger = logging.getLogger(__name__)
 
 class CorporateManager:
@@ -20,87 +16,74 @@ class CorporateManager:
     CEO Module (WO-027).
     Translates the 6-channel Aggressiveness Vector (Strategy) into concrete Actions (Tactics).
     Owned by AIDrivenFirmDecisionEngine.
+    Refactored for DTO Purity Gate (WO-114).
     """
 
     def __init__(self, config_module: Any, logger: Optional[logging.Logger] = None):
         self.config_module = config_module
         self.logger = logger if logger else logging.getLogger(__name__)
+        self.system2_planner: Optional[FirmSystem2Planner] = None
 
     def realize_ceo_actions(
         self,
-        firm: Firm,
+        firm: FirmStateDTO,
         context: DecisionContext,
         action_vector: FirmActionVector
     ) -> List[Order]:
         """
-        Main entry point. Orchestrates all channel executions.
+        Main entry point. Orchestrates all channel executions using pure DTOs.
+        Returns a list of Orders (External and Internal).
         """
         orders: List[Order] = []
 
         # Phase 21: System 2 Strategic Guidance
-        # Instantiate planner if not present (Lazy Init)
-        if firm.system2_planner is None:
-             firm.system2_planner = FirmSystem2Planner(firm, self.config_module)
+        if self.system2_planner is None:
+             self.system2_planner = FirmSystem2Planner(None, self.config_module)
 
-        guidance = firm.system2_planner.project_future(context.current_time, context.market_data)
+        guidance = self.system2_planner.project_future(context.current_time, context.market_data, firm)
 
         # 0. Production Target Adjustment (Restored Logic)
-        self._manage_production_target(firm)
+        target_order = self._manage_production_target(firm)
+        if target_order:
+            orders.append(target_order)
 
         # 0. Procurement Channel (Raw Materials) - WO-030
         procurement_orders = self._manage_procurement(firm, context.market_data, context.markets)
         orders.extend(procurement_orders)
 
-        # Phase 21: Automation Channel (New)
-        # Uses Capital Aggressiveness + System 2 Target
-        # But wait, Capital Channel is _manage_capex. Automation is different form of capital.
-        # Let's add specific method.
-        # We can use 'capital_aggressiveness' to split between CAPEX (Machines) and Automation.
-        self._manage_automation(firm, action_vector.capital_aggressiveness, guidance, context.current_time, context.government)
+        # Phase 21: Automation Channel
+        auto_orders = self._manage_automation(firm, action_vector.capital_aggressiveness, guidance, context.current_time)
+        orders.extend(auto_orders)
 
         # 1. R&D Channel (Innovation)
-        # System 2 guidance might override action vector?
-        # Or bias it.
-        # For now, let action vector drive execution intensity, but System 2 sets 'strategic priority' or modifies it?
-        # Spec: "Personalities dictate the 'Preferred Strategy' ... focus: innovation"
-        # The System 2 planner returns 'rd_intensity'.
-        # Let's blend them or use System 2 to modify action_vector.
-        # But realize_ceo_actions receives a 'fixed' vector from AI.
-        # The AI (RL Agent) learns to output the vector.
-        # System 2 is 'Cognitive Overhead' or 'Advisor'.
-        # If AI is System 1, System 2 should bias the AI? Or bias the execution?
-        # Let's bias the execution here.
-
         rd_agg = action_vector.rd_aggressiveness
         if guidance.get("rd_intensity", 0.0) > 0.1:
-             rd_agg = max(rd_agg, 0.5) # Minimum effort if strategic priority
+             rd_agg = max(rd_agg, 0.5)
 
-        self._manage_r_and_d(firm, rd_agg, context.current_time)
+        rd_order = self._manage_r_and_d(firm, rd_agg, context.current_time)
+        if rd_order:
+            orders.append(rd_order)
 
-        # 2. Capital Channel (CAPEX - Physical Machines)
-        # If Automation is prioritized, maybe reduce physical capex?
+        # 2. Capital Channel (CAPEX)
         capex_agg = action_vector.capital_aggressiveness
-        self._manage_capex(firm, capex_agg, context.reflux_system, context.current_time)
+        capex_order = self._manage_capex(firm, capex_agg, context.current_time)
+        if capex_order:
+            orders.append(capex_order)
 
         # 3. Dividend Channel
-        self._manage_dividends(firm, action_vector.dividend_aggressiveness)
+        div_order = self._manage_dividends(firm, action_vector.dividend_aggressiveness)
+        if div_order:
+            orders.append(div_order)
 
         # 4. Debt Channel (Leverage)
         debt_orders = self._manage_debt(firm, action_vector.debt_aggressiveness, context.market_data)
         orders.extend(debt_orders)
 
         # 5. Pricing Channel (Sales)
-        sales_order = self._manage_pricing(firm, action_vector.sales_aggressiveness, context.market_data, context.markets, context.current_time)
+        pricing_orders = self._manage_pricing(firm, action_vector.sales_aggressiveness, context.market_data, context.markets, context.current_time)
+        orders.extend(pricing_orders)
 
         # 6. Hiring Channel (Employment)
-        # If automation is high, maybe hire less?
-        # _manage_hiring logic calculates needed_labor based on productivity.
-        # productivity_factor is TFP.
-        # Automation changes Alpha.
-        # The 'needed_labor' calculation in _manage_hiring is simplistic: inventory_gap / productivity.
-        # It assumes L * TFP = Output.
-        # But Cobb-Douglas is Y = TFP * L^a * K^b.
-        # We need to update hiring logic to inverse the production function properly!
         hiring_orders = self._manage_hiring(firm, action_vector.hiring_aggressiveness, context.market_data)
         orders.extend(hiring_orders)
 
@@ -111,7 +94,7 @@ class CorporateManager:
 
         return orders
 
-    def _attempt_secondary_offering(self, firm: Firm, context: DecisionContext) -> Optional[StockOrder]:
+    def _attempt_secondary_offering(self, firm: FirmStateDTO, context: DecisionContext) -> Optional[StockOrder]:
         """Sell treasury shares to raise capital when cash is low."""
         startup_cost = getattr(self.config_module, "STARTUP_COST", 30000.0)
         trigger_ratio = getattr(self.config_module, "SEO_TRIGGER_RATIO", 0.5)
@@ -122,7 +105,8 @@ class CorporateManager:
             return None
 
         stock_market = context.markets.get("stock_market")
-        if not stock_market or not isinstance(stock_market, StockMarket):
+        # Check if market exists
+        if not stock_market:
             return None
 
         max_sell_ratio = getattr(self.config_module, "SEO_MAX_SELL_RATIO", 0.10)
@@ -131,10 +115,22 @@ class CorporateManager:
         if sell_qty < 1.0:
             return None
 
-        price = stock_market.get_stock_price(firm.id)
+        # Determine price (Market Price or Book Value)
+        price = 0.0
+        # Accessing market directly via context might violate purity if we modify it, but we are just reading price?
+        # Actually context.markets contains Market objects.
+        # Ideally we should use market_data.
+        # But stock_market logic below uses get_stock_price method.
+        # Assuming context.markets["stock_market"] is available.
+        if stock_market and hasattr(stock_market, "get_stock_price"):
+             price = stock_market.get_stock_price(firm.id)
+
         if price is None or price <= 0:
-            # SoC Refactor: Use FinanceDepartment
-            price = firm.finance.get_book_value_per_share()
+            # Fallback to Book Value
+            if firm.total_shares > 0:
+                price = firm.assets / firm.total_shares
+            else:
+                price = 0.0
 
         if price <= 0:
             return None
@@ -144,12 +140,13 @@ class CorporateManager:
             firm_id=firm.id,
             order_type="SELL",
             quantity=sell_qty,
-            price=price
+            price=price,
+            market_id="stock_market"
         )
         self.logger.info(f"SEO | Firm {firm.id} offering {sell_qty:.1f} shares at {price:.2f}")
         return order
 
-    def _manage_procurement(self, firm: Firm, market_data: Dict[str, Any], markets: Dict[str, Any]) -> List[Order]:
+    def _manage_procurement(self, firm: FirmStateDTO, market_data: Dict[str, Any], markets: Dict[str, Any]) -> List[Order]:
         """
         WO-030: Manage Raw Material Procurement.
         """
@@ -182,94 +179,53 @@ class CorporateManager:
 
         return orders
 
-    def _manage_automation(self, firm: Firm, aggressiveness: float, guidance: Dict[str, Any], current_time: int, government: Optional[Any] = None) -> None:
+    def _manage_automation(self, firm: FirmStateDTO, aggressiveness: float, guidance: Dict[str, Any], current_time: int) -> List[Order]:
         """
         Phase 21: Automation Investment.
         """
+        orders = []
         target_a = guidance.get("target_automation", firm.automation_level)
         current_a = firm.automation_level
 
         if current_a >= target_a:
-            return # No investment needed (except maintenance, which is handled implicitly? Or should be explicit?)
-            # Firm logic decays automation. So we need to top up.
+            return orders
 
         gap = target_a - current_a
-
-        # Cost Logic: Base Cost * Asset Scale * Gap
         cost_per_pct = getattr(self.config_module, "AUTOMATION_COST_PER_PCT", 1000.0)
-        # Let's treat 'Firm Size' as roughly constant 10000 or Assets.
-        # Spec: "Firm Size (Assets)".
-        # If Assets are huge, cost is huge.
-        # Let's clamp 'Firm Size' factor to avoid runaway costs for rich firms.
-        # Or use Log(Assets)?
-        # For simplicity and testability: Cost = 1000 * Gap.
-        # Wait, if Gap is 0.1 (10%), Cost = 100. Cheap.
-        # Spec says: AUTOMATION_COST_PER_PCT = 1000.0 (Base cost scaling).
-        # Maybe Cost = 1000 * (Gap * 100)?
-        # Let's say to increase 1% (0.01) costs 1000 * scale.
-        # Assuming scale = 1.0 for standard firm.
-        # Let's just use: Cost = AUTOMATION_COST_PER_PCT * (Gap * 100)
-        # So 10% increase = 1000 * 10 = 10,000.
-
         cost = cost_per_pct * (gap * 100.0)
 
-        # Budget Check (using aggressiveness)
-        # If aggressiveness is low, we invest slowly.
-
-        # [Fix] Solvency Check: Reserve buffer for wages (approx 2000.0)
         safety_margin = getattr(self.config_module, "FIRM_SAFETY_MARGIN", 2000.0)
         investable_cash = max(0.0, firm.assets - safety_margin)
 
         budget = investable_cash * (aggressiveness * 0.5)
-
         actual_spend = min(cost, budget)
 
         if actual_spend < 100.0:
-            return
+            return orders
 
-        # Execute: SoC Refactor
-        if not firm.finance.invest_in_automation(actual_spend):
-             return
+        # Generate Internal Order
+        orders.append(Order(firm.id, "INVEST_AUTOMATION", "internal", actual_spend, 0.0, "internal"))
 
         # WO-044-Track-B: Automation Tax
-        # Logic: actual_spend * AUTOMATION_TAX_RATE
         automation_tax_rate = getattr(self.config_module, "AUTOMATION_TAX_RATE", 0.05)
         tax_amount = actual_spend * automation_tax_rate
 
-        if tax_amount > 0 and government:
-            success = firm.finance.pay_ad_hoc_tax(tax_amount, "automation_tax", government, current_time)
-            if success:
-                self.logger.info(
-                    f"AUTOMATION_TAX | Firm {firm.id} paid {tax_amount:.2f} tax on {actual_spend:.2f} investment.",
-                    extra={"agent_id": firm.id, "tick": current_time, "tags": ["tax", "automation"]}
-                )
+        if tax_amount > 0:
+            orders.append(Order(firm.id, "PAY_TAX", "automation_tax", tax_amount, 0.0, "internal"))
 
-        # Calculate gained automation
-        # gained = (spend / cost_per_pct) / 100.0
-        gained_pct = actual_spend / cost_per_pct
-        gained_a = gained_pct / 100.0
-
-        # SoC Refactor
-        firm.production.set_automation_level(firm.automation_level + gained_a)
-
-        self.logger.info(
-            f"AUTOMATION | Firm {firm.id} invested {actual_spend:.1f}, level {current_a:.3f} -> {firm.automation_level:.3f}",
-            extra={"agent_id": firm.id, "tick": current_time, "tags": ["automation"]}
-        )
+        return orders
 
-    def _manage_r_and_d(self, firm: Firm, aggressiveness: float, current_time: int) -> None:
+    def _manage_r_and_d(self, firm: FirmStateDTO, aggressiveness: float, current_time: int) -> Optional[Order]:
         """
         Innovation Physics.
         """
         if aggressiveness <= 0.1:
-            return
+            return None
 
-        # SoC Refactor: use finance.revenue_this_turn
-        revenue_base = max(firm.finance.revenue_this_turn, firm.assets * 0.05)
+        revenue_base = max(firm.revenue_this_turn, firm.assets * 0.05)
         rd_budget_rate = aggressiveness * 0.20
         budget = revenue_base * rd_budget_rate
 
-        # [Fix] Solvency Check
         safety_margin = getattr(self.config_module, "FIRM_SAFETY_MARGIN", 2000.0)
         investable_cash = max(0.0, firm.assets - safety_margin)
 
@@ -277,102 +233,47 @@ class CorporateManager:
             budget = investable_cash * 0.5
 
         if budget < 10.0:
-            return
-
-        # SoC Refactor
-        if not firm.finance.invest_in_rd(budget):
-            return
-
-        firm.research_history["total_spent"] += budget
-
-        # SoC Refactor: use finance.revenue_this_turn
-        denominator = max(firm.finance.revenue_this_turn * 0.2, 100.0)
-        base_chance = min(1.0, budget / denominator)
-
-        avg_skill = 1.0
-        # SoC Refactor: use hr.employees
-        if firm.hr.employees:
-            avg_skill = sum(getattr(e, 'labor_skill', 1.0) for e in firm.hr.employees) / len(firm.hr.employees)
-
-        success_chance = base_chance * avg_skill
-
-        if random.random() < success_chance:
-            firm.research_history["success_count"] += 1
-            firm.research_history["last_success_tick"] = current_time
-            firm.base_quality += 0.05
-            firm.productivity_factor *= 1.05
+            return None
 
-            self.logger.info(
-                f"R&D SUCCESS | Firm {firm.id} spent {budget:.1f}. Quality {firm.base_quality:.2f}, Prod {firm.productivity_factor:.2f}",
-                extra={"agent_id": firm.id, "tick": current_time, "tags": ["innovation", "success"]}
-            )
-        else:
-             self.logger.info(
-                f"R&D FAIL | Firm {firm.id} spent {budget:.1f}. Chance {success_chance:.1%}",
-                extra={"agent_id": firm.id, "tick": current_time, "tags": ["innovation", "fail"]}
-            )
+        return Order(firm.id, "INVEST_RD", "internal", budget, 0.0, "internal")
 
-    def _manage_capex(self, firm: Firm, aggressiveness: float, reflux_system: Any, current_time: int) -> None:
+    def _manage_capex(self, firm: FirmStateDTO, aggressiveness: float, current_time: int) -> Optional[Order]:
         """
         Capacity Expansion.
         """
         if aggressiveness <= 0.2:
-            return
+            return None
 
-        # [Fix] Solvency Check
         safety_margin = getattr(self.config_module, "FIRM_SAFETY_MARGIN", 2000.0)
         investable_cash = max(0.0, firm.assets - safety_margin)
 
         budget = investable_cash * (aggressiveness * 0.5)
 
         if budget < 100.0:
-            return
-
-        # SoC Refactor
-        if not firm.finance.invest_in_capex(budget):
-            return
-
-        if reflux_system:
-             reflux_system.capture(budget, str(firm.id), "capex")
-
-        efficiency = 1.0 / getattr(self.config_module, "CAPITAL_TO_OUTPUT_RATIO", 2.0)
-        added_capital = budget * efficiency
-        # SoC Refactor
-        firm.production.add_capital(added_capital)
+            return None
 
-        self.logger.info(
-            f"CAPEX | Firm {firm.id} invested {budget:.1f}, added {added_capital:.1f} capital.",
-            extra={"agent_id": firm.id, "tick": current_time, "tags": ["capex"]}
-        )
+        return Order(firm.id, "INVEST_CAPEX", "internal", budget, 0.0, "internal")
 
-    def _manage_dividends(self, firm: Firm, aggressiveness: float) -> None:
+    def _manage_dividends(self, firm: FirmStateDTO, aggressiveness: float) -> Optional[Order]:
         """
         Set Dividend Rate.
         """
-        # Phase 29: Survival Mode Check
-        # Check Altman Z-Score
-        z_score = firm.finance.calculate_altman_z_score()
+        z_score = firm.altman_z_score
         z_score_threshold = getattr(self.config_module, "ALTMAN_Z_SCORE_THRESHOLD", 1.81)
-
-        # Check Consecutive Losses
         loss_limit = getattr(self.config_module, "DIVIDEND_SUSPENSION_LOSS_TICKS", 3)
 
-        is_distressed = (z_score < z_score_threshold) or (firm.finance.consecutive_loss_turns >= loss_limit)
+        is_distressed = (z_score < z_score_threshold) or (firm.consecutive_loss_turns >= loss_limit)
 
         if is_distressed:
-            firm.finance.set_dividend_rate(0.0)
-            self.logger.warning(
-                f"DIVIDEND SUSPENDED | Firm {firm.id} in distress (Z={z_score:.2f}, LossTicks={firm.finance.consecutive_loss_turns}).",
-                extra={"agent_id": firm.id, "tags": ["dividend", "crisis"]}
-            )
-            return
+            return Order(firm.id, "SET_DIVIDEND", "internal", 0.0, 0.0, "internal")
 
         base_rate = getattr(self.config_module, "DIVIDEND_RATE_MIN", 0.1)
         max_rate = getattr(self.config_module, "DIVIDEND_RATE_MAX", 0.5)
-        # SoC Refactor
-        firm.finance.set_dividend_rate(base_rate + (aggressiveness * (max_rate - base_rate)))
+        new_rate = base_rate + (aggressiveness * (max_rate - base_rate))
 
-    def _manage_debt(self, firm: Firm, aggressiveness: float, market_data: Dict) -> List[Order]:
+        return Order(firm.id, "SET_DIVIDEND", "internal", new_rate, 0.0, "internal")
+
+    def _manage_debt(self, firm: FirmStateDTO, aggressiveness: float, market_data: Dict) -> List[Order]:
         """
         Leverage Management.
         """
@@ -408,77 +309,71 @@ class CorporateManager:
 
         return orders
 
-    def _manage_pricing(self, firm: Firm, aggressiveness: float, market_data: Dict, markets: Dict, current_time: int) -> Optional[Order]:
+    def _manage_pricing(self, firm: FirmStateDTO, aggressiveness: float, market_data: Dict, markets: Dict, current_time: int) -> List[Order]:
         """
         Sales Channel.
         """
+        orders = []
         item_id = firm.specialization
         current_inventory = firm.inventory.get(item_id, 0)
 
         if current_inventory <= 0:
-            return None
+            return orders
 
         market_price = 0.0
         if item_id in market_data:
              market_price = market_data[item_id].get('avg_price', 0)
         if market_price <= 0:
-             market_price = firm.last_prices.get(item_id, 0)
+             market_price = firm.price_history.get(item_id, 0)
         if market_price <= 0:
              market_price = self.config_module.GOODS.get(item_id, {}).get("production_cost", 10.0)
 
         adjustment = (0.5 - aggressiveness) * 0.4
         target_price = market_price * (1.0 + adjustment)
 
-        # SoC Refactor: use finance.last_sales_volume
-        sales_vol = getattr(firm.finance, 'last_sales_volume', 1.0)
-        if sales_vol <= 0: sales_vol = 1.0
+        # Sales volume handling via DTO? DTO doesn't have last_sales_volume explicitly in root, but maybe we can infer?
+        # FirmStateDTO doesn't have sales volume.
+        # Fallback to 1.0 if not available.
+        sales_vol = 1.0
+
         days_on_hand = current_inventory / sales_vol
         decay = max(0.5, 1.0 - (days_on_hand * 0.005))
         target_price *= decay
 
         target_price = max(target_price, 0.1)
-        # SoC Refactor
-        firm.sales.set_price(item_id, target_price)
 
+        # 1. Internal Order to update price state
+        orders.append(Order(firm.id, "SET_PRICE", item_id, target_price, 0.0, "internal"))
+
+        # 2. Market Order to sell
         qty = min(current_inventory, self.config_module.MAX_SELL_QUANTITY)
 
+        # We generate a direct SELL order here.
+        # Note: Previous logic called `firm.sales.post_ask` which might do more (logging, etc).
+        # But we are in DTO mode. The Engine outputs Intent.
+
         target_market = markets.get(item_id)
         if target_market:
-            # firm.post_ask is a method on Firm, but it delegates to Sales.
-            # CorporateManager calls firm.post_ask. Spec says "Update Firm Internal Methods... make_decision... access sub-components".
-            # CorporateManager is calling firm.post_ask. Should it call firm.sales.post_ask?
-            # Spec says "External modules ... directly manipulate internal state".
-            # `post_ask` on `Firm` is a method, not a property.
-            # Spec mainly targets wrapper properties.
-            # However, for consistency, I can use `firm.sales.post_ask` IF `Firm`'s `post_ask` is just a wrapper.
-            # Let's check `Firm.post_ask` again.
-            # Yes: return self.sales.post_ask(item_id, price, quantity, market, current_tick)
-            # So I should use firm.sales.post_ask directly to be "Pure Orchestrator".
-            # But the orchestrator (Firm) might want to log or do things?
-            # Actually, `Firm.post_ask` IS the wrapper.
-            # So I will use `firm.sales.post_ask`.
-            firm.sales.post_ask(item_id, target_price, qty, target_market, current_time)
+             orders.append(Order(
+                 agent_id=firm.id,
+                 order_type="SELL",
+                 item_id=item_id,
+                 quantity=qty,
+                 price=target_price,
+                 market_id=item_id # Assumes market_id == item_id
+             ))
 
-        return None
+        return orders
 
-    def _manage_hiring(self, firm: Firm, aggressiveness: float, market_data: Dict) -> List[Order]:
+    def _manage_hiring(self, firm: FirmStateDTO, aggressiveness: float, market_data: Dict) -> List[Order]:
         """
         Hiring Channel.
-        Phase 21: Updated to account for Automation in labor demand.
         """
         orders = []
         target_inventory = firm.production_target
         current_inventory = firm.inventory.get(firm.specialization, 0)
         inventory_gap = target_inventory - current_inventory
 
-        # if inventory_gap <= 0:
-        #    return []
-
-        # Calculate needed labor with Cobb-Douglas inversion?
-        # Y = TFP * L^alpha * K^beta
-        # L^alpha = Y / (TFP * K^beta)
-        # L = (Y / (TFP * K^beta)) ^ (1/alpha)
-
         base_alpha = getattr(self.config_module, "LABOR_ALPHA", 0.7)
         automation_reduction = getattr(self.config_module, "AUTOMATION_LABOR_REDUCTION", 0.5)
         alpha_adjusted = base_alpha * (1.0 - (firm.automation_level * automation_reduction))
@@ -487,75 +382,53 @@ class CorporateManager:
         capital = max(firm.capital_stock, 1.0)
         tfp = firm.productivity_factor
 
-        # Avoid division by zero
         if tfp <= 0: tfp = 1.0
 
         needed_labor_calc = 0.0
         if inventory_gap > 0:
             try:
-                 # term = Y / (TFP * K^beta)
                  term = inventory_gap / (tfp * (capital ** beta_adjusted))
                  needed_labor_calc = term ** (1.0 / alpha_adjusted)
             except Exception:
-                 needed_labor_calc = 1.0 # Fallback
+                 needed_labor_calc = 1.0
         else:
             needed_labor_calc = 0.0
 
-        # Soft limit removed to allow full employment
         needed_labor = int(needed_labor_calc) + 1
-
-        # SoC Refactor: use hr.employees
-        current_employees = len(firm.hr.employees)
+        current_employees = len(firm.employees)
 
         # A. Firing Logic (Layoffs)
         if current_employees > needed_labor:
             excess = current_employees - needed_labor
-            # Don't fire everyone if inventory is just slightly full?
-            # Cobb-Douglas needs labor. If we fire all, prod=0.
-            # But needed_labor calculated above might be 0 if inventory gap <= 0.
-            # If inventory gap <= 0, we have enough stock. We don't need to produce.
-            # So firing is rational to save wages.
-            # However, firing everyone destroys organization capital.
-            # Let's keep at least 1 employee (skeleton crew) if possible, unless bankrupt.
-
-            # Allow firing down to 1
             fire_count = min(excess, max(0, current_employees - 1))
 
             if fire_count > 0:
-                # Fire the most expensive or random? Random for now.
-                # Actually we should iterate copy to modify list safely?
-                # No, we just call employee.quit().
-                # We need to pick employees.
-                candidates = firm.hr.employees[:fire_count] # FIFO firing
+                # Identify candidates (FIFO from ID list)
+                candidates = firm.employees[:fire_count]
 
-                # WO-044-Track-C: Strategic Firing Severance Check
                 severance_weeks = getattr(self.config_module, "SEVERANCE_PAY_WEEKS", 4)
 
-                for emp in candidates:
-                    # Estimate wage (Strategic firing happens before update_needs, so check current wage)
-                    # SoC Refactor: use hr.employee_wages
-                    wage = firm.hr.employee_wages.get(emp.id, self.config_module.LABOR_MARKET_MIN_WAGE)
-                    # Correct for skill
-                    skill = getattr(emp, 'labor_skill', 1.0)
-                    wage *= skill
-
-                    severance_pay = wage * severance_weeks
-
-                    # SoC Refactor: use finance.pay_severance
-                    if firm.finance.pay_severance(emp, severance_pay):
-                        emp.quit()
-                        self.logger.info(
-                            f"LAYOFF | Firm {firm.id} laid off Household {emp.id} with Severance {severance_pay:.2f}. Excess labor.",
-                            extra={"tick": 0, "tags": ["hiring", "layoff", "severance"]}
-                        )
-                    else:
-                        self.logger.warning(
-                            f"LAYOFF ABORTED | Firm {firm.id} cannot afford Severance {severance_pay:.2f} for Household {emp.id}. Firing cancelled.",
-                             extra={"tick": 0, "tags": ["hiring", "layoff_aborted"]}
-                        )
-
-                # Firing done. No hiring.
-                return []
+                for emp_id in candidates:
+                    # Get wage and skill from DTO
+                    emp_data = firm.employees_data.get(emp_id, {})
+                    wage = emp_data.get("wage", self.config_module.LABOR_MARKET_MIN_WAGE)
+                    skill = emp_data.get("skill", 1.0)
+
+                    adjusted_wage = wage * skill
+                    severance_pay = adjusted_wage * severance_weeks
+
+                    # Generate FIRE order
+                    orders.append(Order(
+                        firm.id,
+                        "FIRE",
+                        "internal",
+                        1,
+                        severance_pay,
+                        "internal",
+                        target_agent_id=emp_id
+                    ))
+
+                return orders
 
         # B. Hiring Logic
         market_wage = self.config_module.LABOR_MARKET_MIN_WAGE
@@ -566,10 +439,10 @@ class CorporateManager:
         offer_wage = market_wage * (1.0 + adjustment)
         offer_wage = max(self.config_module.LABOR_MARKET_MIN_WAGE, offer_wage)
 
-        # WO-047-B: Competitive Bidding Adjustment
-        offer_wage = self._adjust_wage_for_vacancies(firm, offer_wage, needed_labor)
+        # Competitive Bidding Logic (Simplified from original due to DTO access limits or replicate it?)
+        # We can replicate `_adjust_wage_for_vacancies` using DTO data.
+        offer_wage = self._adjust_wage_for_vacancies(firm, offer_wage, needed_labor, market_data)
 
-        # Calculate how many to hire
         to_hire = needed_labor - current_employees
         if to_hire > 0:
             for _ in range(to_hire):
@@ -579,84 +452,71 @@ class CorporateManager:
 
         return orders
 
-    def _get_total_liabilities(self, firm: Firm) -> float:
-        """Helper to get total liabilities from Bank logic (WO-047-B)."""
-        try:
-            loan_market = getattr(firm.decision_engine, 'loan_market', None)
-            if loan_market and hasattr(loan_market, 'bank') and loan_market.bank:
-                debt_summary = loan_market.bank.get_debt_summary(firm.id)
-                return debt_summary.get('total_principal', 0.0)
-        except Exception:
-            pass
-        return 0.0
-
-    def _adjust_wage_for_vacancies(self, firm: Firm, base_offer_wage: float, needed_labor: int) -> float:
+    def _adjust_wage_for_vacancies(self, firm: FirmStateDTO, base_offer_wage: float, needed_labor: int, market_data: Dict) -> float:
         """
-        WO-047-B: Competitive Bidding Logic.
-        If firm has vacancies and is solvent, bid up the wage.
+        WO-047-B: Competitive Bidding Logic (DTO version).
         """
-        # SoC Refactor
-        current_employees = len(firm.hr.employees)
+        current_employees = len(firm.employees)
         vacancies = max(0, needed_labor - current_employees)
         
         if vacancies <= 0:
             return base_offer_wage
 
-        # 1. 1.5x Solvency Check (Guardrail)
-        total_liabilities = self._get_total_liabilities(firm)
+        # 1. Solvency Check
+        # Need liabilities. DTO doesn't have it explicitly.
+        # But we can get it from market_data debt info.
+        total_liabilities = 0.0
+        debt_info = market_data.get("debt_data", {}).get(firm.id)
+        if debt_info:
+            total_liabilities = debt_info.get("total_principal", 0.0)
+
         if total_liabilities > 0:
             solvency_ratio = firm.assets / total_liabilities
             if solvency_ratio < 1.5:
-                # Insolvent or risky: Cannot afford bidding war
                 return base_offer_wage
         
-        # 2. Wage Bill Cap Check (Fallback for 0 liabilities)
-        # Check if we have enough cash runway (e.g., 2 ticks)
-        # Using current wage bill as proxy
-        # SoC Refactor: use hr.employee_wages
-        wage_bill = sum(firm.hr.employee_wages.values()) if firm.hr.employee_wages else 0.0
+        # 2. Wage Bill Cap
+        wage_bill = 0.0
+        if firm.employees_data:
+            wage_bill = sum(e['wage'] for e in firm.employees_data.values())
+
         if wage_bill > 0 and firm.assets < wage_bill * 2: 
              return base_offer_wage
 
         # 3. Calculate Increase
-        # Increase by 1% per vacancy, max 5%
         increase_rate = min(0.05, 0.01 * vacancies)
         new_wage = base_offer_wage * (1.0 + increase_rate)
 
-        # 4. Absolute Ceiling Check (Safety Net)
-        # Ensures firm doesn't commit to a wage causing immediate insolvency next tick
-        # Logic: Assets should cover (Current Employees + New Hires + 1) * New Wage
-        # This is a bit conservative but safe.
+        # 4. Absolute Ceiling
         max_affordable = firm.assets / (current_employees + vacancies + 1)
         if new_wage > max_affordable:
             new_wage = max(base_offer_wage, max_affordable)
 
-        # Ensure we don't accidentally lower it below base
         return max(base_offer_wage, new_wage)
 
-    def _manage_production_target(self, firm: Firm) -> None:
+    def _manage_production_target(self, firm: FirmStateDTO) -> Optional[Order]:
         """
         Adjust Production Target based on Inventory Levels.
-        Uses Rule-Based Logic (Legacy behavior restored).
         """
         item = firm.specialization
         current_inventory = firm.inventory.get(item, 0.0)
         target = firm.production_target
 
-        # Parameters
         overstock_threshold = getattr(self.config_module, "OVERSTOCK_THRESHOLD", 1.2)
         understock_threshold = getattr(self.config_module, "UNDERSTOCK_THRESHOLD", 0.8)
         adj_factor = getattr(self.config_module, "PRODUCTION_ADJUSTMENT_FACTOR", 0.1)
         min_target = getattr(self.config_module, "FIRM_MIN_PRODUCTION_TARGET", 10.0)
         max_target = getattr(self.config_module, "FIRM_MAX_PRODUCTION_TARGET", 500.0)
 
-        # Logic
+        new_target = target
         if current_inventory > target * overstock_threshold:
-            # Reduce Target
             new_target = target * (1.0 - adj_factor)
-            firm.production_target = max(min_target, new_target)
-
+            new_target = max(min_target, new_target)
         elif current_inventory < target * understock_threshold:
-            # Increase Target
             new_target = target * (1.0 + adj_factor)
-            firm.production_target = min(max_target, new_target)
+            new_target = min(max_target, new_target)
+
+        if new_target != target:
+            return Order(firm.id, "SET_TARGET", "internal", new_target, 0.0, "internal")
+
+        return None
diff --git a/simulation/decisions/housing_manager.py b/simulation/decisions/housing_manager.py
index e013d36..e0c2111 100644
--- a/simulation/decisions/housing_manager.py
+++ b/simulation/decisions/housing_manager.py
@@ -1,6 +1,10 @@
-from typing import Any, Dict, Optional
+from __future__ import annotations
+from typing import Any, Dict, Optional, TYPE_CHECKING
 import math
-from simulation.models import Order # Type hint purpose mostly
+from simulation.models import Order
+
+if TYPE_CHECKING:
+    from modules.household.dtos import HouseholdStateDTO
 
 class PurchaseIntent:
     """DTO for Mimicry Purchase decision"""
@@ -14,26 +18,17 @@ class HousingManager:
     Phase 17-3B: Housing Manager
     Acts as a 'Proxy Planner' (System 2 Proxy) for the Household.
     Calculates Buy vs Rent decisions using NPV and Personality Bias.
+    Refactored for DTO Purity Gate.
     """
 
-    def __init__(self, agent: Any, config: Any):
-        self.agent = agent  # Household instance
+    def __init__(self, agent: "HouseholdStateDTO", config: Any):
+        self.agent = agent  # HouseholdStateDTO
         self.config = config
 
-    def get_housing_tier(self, agent: Any) -> float:
+    def get_housing_tier(self, agent: "HouseholdStateDTO") -> float:
         """
         Estimates housing tier based on residence value.
-        Tier 1 ~ 10000 (Basic), Tier 3 ~ 30000 (High)
-        Returns a float score (e.g. 1.0, 3.0)
         """
-        # If agent owns/rents, we need the property value.
-        # Currently agent stores `residing_property_id`.
-        # Accessing `agent.decision_engine.market_data` or passing context is hard here.
-        # Ideally, we pass property_value.
-        # As a heuristic, if homeless, 0.0. If has home, assume standard (1.0) or check value if possible.
-        # Since we don't have easy access to RealEstateUnit here without passing it,
-        # we will assume standard Tier 1 (1.0) if not homeless, 0.0 if homeless.
-        # For verification, we might need to inject this.
         if agent.is_homeless or agent.residing_property_id is None:
             return 0.0
         return 1.0 # Default Tier 1
@@ -41,29 +36,26 @@ class HousingManager:
     def decide_mimicry_purchase(self, reference_standard: Dict[str, float]) -> Optional[PurchaseIntent]:
         """
         Phase 17-4: Mimicry Consumption Logic.
-        If Relative Deprivation > Threshold, trigger Panic Buy.
         """
         if not getattr(self.config, "ENABLE_VANITY_SYSTEM", False):
             return None
 
         # 1. Calculate Gap
-        # Note: referencing self.agent inside helper
         my_tier = self.get_housing_tier(self.agent)
         ref_tier = reference_standard.get("avg_housing_tier", 1.0)
 
         gap = ref_tier - my_tier
         if gap <= 0:
-            return None # Already at or above reference
+            return None
 
         # 2. Calculate Urgency
-        # urgency = Conformity * Gap * MimicryFactor
         conformity = getattr(self.agent, "conformity", 0.5)
         mimicry_factor = getattr(self.config, "MIMICRY_FACTOR", 0.5)
 
         urgency = conformity * gap * mimicry_factor
 
         # 3. Trigger Condition
-        if urgency > 0.5: # Threshold
+        if urgency > 0.5:
              return PurchaseIntent(
                  target="housing",
                  max_ltv=0.95, # Panic Buy: Max Leverage
@@ -74,50 +66,32 @@ class HousingManager:
     def should_buy(self, property_value: float, rent_price: float, interest_rate: float = 0.05) -> bool:
         """
         Determines whether to buy a property based on NPV calculation biased by personality.
-        
-        Args:
-            property_value: Asking price of the property.
-            rent_price: Current or expected monthly rent.
-            interest_rate: Annual mortgage interest rate (approximate).
-
-        Returns:
-            True if the agent should buy, False otherwise.
         """
         # 1. Base Economic Parameters
-        horizon = 120  # 10 years (120 ticks) horizon for calculation
-        discount_rate = 0.005 # 0.5% per tick discount rate
-        maintenance_rate = self.config.MAINTENANCE_RATE_PER_TICK # 0.1%
+        horizon = 120
+        discount_rate = 0.005
+        maintenance_rate = self.config.MAINTENANCE_RATE_PER_TICK
         
         # 2. Personality-Biased Parameters
         
-        # Optimism Bias: Optimists over-estimate future appreciation
-        # Base appreciation 0.2% per tick. Optimist (1.0) sees 0.4%, Pessimist (0.0) sees 0.0%
+        # Optimism Bias
         base_appreciation = 0.002
-        perceived_appreciation_rate = base_appreciation * (0.5 + self.agent.optimism)
+        perceived_appreciation_rate = base_appreciation * (0.5 + getattr(self.agent, 'optimism', 0.5))
         
-        # Ambition Bias: Ambitious agents perceive "Prestige Value" as tangible benefit
-        # Ambition 1.0 adds 10% of property value to total utility
+        # Ambition Bias
         prestige_bonus = 0.0
-        if hasattr(self.agent, 'ambition'):
-             prestige_bonus = property_value * 0.1 * self.agent.ambition
+        ambition = getattr(self.agent, 'ambition', 0.5)
+        prestige_bonus = property_value * 0.1 * ambition
 
         # 3. NPV Calculation
-        
-        # Cost of Renting (Outflow)
         rent_npv = 0.0
         for t in range(horizon):
             rent_npv += rent_price / ((1 + discount_rate) ** t)
             
-        # Cost of Buying (Outflow - Inflow)
-        # Outflows: Down Payment, Mortgage Pmt, Maintenance
-        # Inflow: Asset Value at horizon (Appreciated)
-        
         ltv = 0.8
         down_payment = property_value * (1 - ltv)
         loan_principal = property_value * ltv
         
-        # Mortgage Payment (Simplified Amortization for calc)
-        # Monthly Rate = Interest Rate / 12 (approx, since ticks are months)
         monthly_rate = interest_rate / 12
         if monthly_rate > 0:
             monthly_payment = loan_principal * (monthly_rate * (1 + monthly_rate) ** 360) / ((1 + monthly_rate) ** 360 - 1)
@@ -134,11 +108,6 @@ class HousingManager:
         future_value_npv = future_value / ((1 + discount_rate) ** horizon)
         
         # Net Cost of Buying (Cost - Asset Value - Prestige)
-        # Note: We compare Costs. Lower is better.
-        # So we treat Gain as Negative Cost.
-        
         net_buy_cost = buy_outflow_npv - future_value_npv - prestige_bonus
         
-        # 4. Decision
-        # If Buying is cheaper (or has more utility) than Renting
         return net_buy_cost < rent_npv
diff --git a/simulation/decisions/rule_based_firm_engine.py b/simulation/decisions/rule_based_firm_engine.py
index b1ca882..c0a6706 100644
--- a/simulation/decisions/rule_based_firm_engine.py
+++ b/simulation/decisions/rule_based_firm_engine.py
@@ -5,7 +5,7 @@ import logging
 from simulation.models import Order
 from simulation.decisions.base_decision_engine import BaseDecisionEngine
 from simulation.ai.enums import Tactic
-from simulation.dtos import DecisionContext
+from simulation.dtos import DecisionContext, FirmStateDTO
 
 if TYPE_CHECKING:
     from simulation.firms import Firm
@@ -36,7 +36,7 @@ class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
         )
 
     def _execute_tactic(
-        self, tactic: Tactic, firm: Firm, current_tick: int, market_data: Dict[str, Any]
+        self, tactic: Tactic, firm: FirmStateDTO, current_tick: int, market_data: Dict[str, Any]
     ) -> List[Order]:
         """
         선택된 전술에 따라 실제 행동(주문 생성)을 수행한다.
@@ -53,7 +53,7 @@ class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
 
         return []
 
-    def _adjust_production(self, firm: Firm, current_tick: int) -> List[Order]:
+    def _adjust_production(self, firm: FirmStateDTO, current_tick: int) -> List[Order]:
         """
         재고 수준에 따라 생산 목표를 조정한다.
         """
@@ -61,21 +61,24 @@ class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
         current_inventory = firm.inventory.get(item_id, 0)
         target_quantity = firm.production_target
 
-        is_overstocked = (
-            current_inventory > target_quantity * self.config_module.OVERSTOCK_THRESHOLD
-        )
-        is_understocked = (
-            current_inventory
-            < target_quantity * self.config_module.UNDERSTOCK_THRESHOLD
-        )
+        overstock_threshold = getattr(self.config_module, "OVERSTOCK_THRESHOLD", 1.2)
+        understock_threshold = getattr(self.config_module, "UNDERSTOCK_THRESHOLD", 0.8)
+        adj_factor = getattr(self.config_module, "PRODUCTION_ADJUSTMENT_FACTOR", 0.1)
+        min_target = getattr(self.config_module, "FIRM_MIN_PRODUCTION_TARGET", 10.0)
+        max_target = getattr(self.config_module, "FIRM_MAX_PRODUCTION_TARGET", 500.0)
+
+        new_target = target_quantity
+
+        is_overstocked = current_inventory > target_quantity * overstock_threshold
+        is_understocked = current_inventory < target_quantity * understock_threshold
 
         if is_overstocked:
-            firm.production_target = max(
-                self.config_module.FIRM_MIN_PRODUCTION_TARGET,
-                target_quantity * (1 - self.config_module.PRODUCTION_ADJUSTMENT_FACTOR),
+            new_target = max(
+                min_target,
+                target_quantity * (1 - adj_factor),
             )
             self.logger.info(
-                f"Overstock of {item_id}. Reducing production target to {firm.production_target:.1f}",
+                f"Overstock of {item_id}. Reducing production target to {new_target:.1f}",
                 extra={
                     "tick": current_tick,
                     "agent_id": firm.id,
@@ -83,12 +86,12 @@ class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
                 },
             )
         elif is_understocked:
-            firm.production_target = min(
-                self.config_module.FIRM_MAX_PRODUCTION_TARGET,
-                target_quantity * (1 + self.config_module.PRODUCTION_ADJUSTMENT_FACTOR),
+            new_target = min(
+                max_target,
+                target_quantity * (1 + adj_factor),
             )
             self.logger.info(
-                f"Understock of {item_id}. Increasing production target to {firm.production_target:.1f}",
+                f"Understock of {item_id}. Increasing production target to {new_target:.1f}",
                 extra={
                     "tick": current_tick,
                     "agent_id": firm.id,
@@ -96,10 +99,13 @@ class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
                 },
             )
 
-        return []  # 생산 목표 조정은 직접적인 주문을 생성하지 않음
+        if new_target != target_quantity:
+            return [Order(firm.id, "SET_TARGET", "internal", new_target, 0.0, "internal")]
+
+        return []
 
     def _adjust_wages(
-        self, firm: Firm, current_tick: int, market_data: Dict[str, Any]
+        self, firm: FirmStateDTO, current_tick: int, market_data: Dict[str, Any]
     ) -> List[Order]:
         """
         필요 노동력과 현재 고용 상태에 따라 임금을 조정하고 고용 주문을 생성한다.
@@ -109,9 +115,9 @@ class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
         needed_labor = self._calculate_needed_labor(firm)
         offered_wage = self._calculate_dynamic_wage_offer(firm)
 
-        # SoC Refactor: use hr.employees
-        if len(firm.hr.employees) < self.config_module.FIRM_MIN_EMPLOYEES:
-            # WO-098 Fix: Use correct market ID "labor"
+        current_employees = len(firm.employees)
+
+        if current_employees < self.config_module.FIRM_MIN_EMPLOYEES:
             order = Order(firm.id, "BUY", "labor", 1.0, offered_wage, "labor")
             orders.append(order)
             self.logger.info(
@@ -123,10 +129,9 @@ class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
                 },
             )
         elif (
-            needed_labor > len(firm.hr.employees)
-            and len(firm.hr.employees) < self.config_module.FIRM_MAX_EMPLOYEES
+            needed_labor > current_employees
+            and current_employees < self.config_module.FIRM_MAX_EMPLOYEES
         ):
-            # WO-098 Fix: Use correct market ID "labor"
             order = Order(firm.id, "BUY", "labor", 1.0, offered_wage, "labor")
             orders.append(order)
             self.logger.info(
@@ -140,7 +145,7 @@ class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
 
         return orders
 
-    def _calculate_needed_labor(self, firm: Firm) -> float:
+    def _calculate_needed_labor(self, firm: FirmStateDTO) -> float:
         """
         생산 목표 달성에 필요한 총 노동력을 계산한다.
         """
@@ -154,13 +159,12 @@ class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
         needed_labor = needed_production / firm.productivity_factor
         return needed_labor
 
-    def _calculate_dynamic_wage_offer(self, firm: Firm) -> float:
+    def _calculate_dynamic_wage_offer(self, firm: FirmStateDTO) -> float:
         """기업의 수익성 이력을 바탕으로 동적인 임금 제시액을 계산합니다."""
-        # SoC Refactor: use finance.profit_history
-        if not firm.finance.profit_history:
+        if not firm.profit_history:
             return self.config_module.BASE_WAGE
 
-        avg_profit = sum(firm.finance.profit_history) / len(firm.finance.profit_history)
+        avg_profit = sum(firm.profit_history) / len(firm.profit_history)
         profit_based_premium = avg_profit / (self.config_module.BASE_WAGE * 10.0)
         wage_premium = max(
             0,
@@ -172,64 +176,57 @@ class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
 
         return self.config_module.BASE_WAGE * (1 + wage_premium)
 
-    def _fire_excess_labor(self, firm: Firm, needed_labor: float) -> None:
+    def _fire_excess_labor(self, firm: FirmStateDTO, needed_labor: float) -> List[Order]:
         """
         WO-110: Firing logic for Rule-Based Firms.
         Fires excess employees if current workforce exceeds needed labor (with tolerance).
-        Returns None as actions are direct state modifications via Finance/HR.
+        Returns list of FIRE orders.
         """
-        current_employees = len(firm.hr.employees)
+        current_employees = len(firm.employees)
 
         # Guard: Check if we actually have employees
         if current_employees == 0:
-            return
+            return []
 
         # Allow slight overstaffing (buffer) to prevent hire/fire churn
         if current_employees <= needed_labor:
-            return
+            return []
 
         excess = current_employees - int(needed_labor)
-        # Keep at least 1 employee (skeleton crew) unless specified otherwise (e.g. bankruptcy handled elsewhere)
+        # Keep at least 1 employee (skeleton crew) unless specified otherwise
         excess = min(excess, max(0, current_employees - 1))
 
         if excess <= 0:
-            return
+            return []
 
-        # Fire from the list (FIFO: First in, First Fired - mimicking simplistic approach)
-        # Actually usually LIFO (Last In First Out) is better to keep experienced, but here experience is not tracked per se?
-        # HRDepartment stores list. employees[0] is oldest?
-        # Let's fire the most recently hired (end of list) or just pick.
-        # CorporateManager fires candidates = firm.hr.employees[:fire_count] (Oldest?).
-        # Let's mimic CorporateManager for consistency.
-        candidates = firm.hr.employees[:excess]
+        # Fire from the list (FIFO logic)
+        candidates = firm.employees[:excess]
+        orders = []
 
         severance_weeks = getattr(self.config_module, "SEVERANCE_PAY_WEEKS", 4)
-        min_wage = getattr(self.config_module, "LABOR_MARKET_MIN_WAGE", 5.0) # Fallback
-
-        for emp in list(candidates): # Copy list to iterate safely
-            # Calculate severance
-            # Need current wage.
-            wage = firm.hr.employee_wages.get(emp.id, min_wage)
-            # Correct for skill
-            skill = getattr(emp, 'labor_skill', 1.0)
-            wage *= skill
-
-            severance_pay = wage * severance_weeks
-
-            # Pay and Quit
-            if firm.finance.pay_severance(emp, severance_pay):
-                emp.quit()
-                firm.hr.remove_employee(emp)
-
-                self.logger.info(
-                    f"RuleBased Firing: Firm {firm.id} fired Agent {emp.id}. Severance: {severance_pay:.2f}",
-                    extra={"tick": 0, "agent_id": firm.id, "tags": ["firing"]}
-                )
-            else:
-                # Can't afford severance.
-                # In CorporateManager, we abort.
-                # Here, we also abort to avoid illegal firing.
-                self.logger.warning(
-                    f"RuleBased Firing Aborted: Firm {firm.id} cannot afford severance {severance_pay:.2f} for Agent {emp.id}.",
-                    extra={"tick": 0, "agent_id": firm.id, "tags": ["firing_aborted"]}
-                )
+        min_wage = getattr(self.config_module, "LABOR_MARKET_MIN_WAGE", 5.0)
+
+        for emp_id in candidates:
+            emp_data = firm.employees_data.get(emp_id, {})
+            wage = emp_data.get("wage", min_wage)
+            skill = emp_data.get("skill", 1.0)
+
+            severance_pay = wage * skill * severance_weeks
+
+            # Create FIRE Order
+            orders.append(Order(
+                firm.id,
+                "FIRE",
+                "internal",
+                1,
+                severance_pay,
+                "internal",
+                target_agent_id=emp_id
+            ))
+
+            self.logger.info(
+                f"RuleBased Firing: Firm {firm.id} planning to fire Agent {emp_id}. Severance: {severance_pay:.2f}",
+                extra={"tick": 0, "agent_id": firm.id, "tags": ["firing"]}
+            )
+
+        return orders
diff --git a/simulation/decisions/standalone_rule_based_firm_engine.py b/simulation/decisions/standalone_rule_based_firm_engine.py
index 3d1f935..f4ceb61 100644
--- a/simulation/decisions/standalone_rule_based_firm_engine.py
+++ b/simulation/decisions/standalone_rule_based_firm_engine.py
@@ -6,7 +6,7 @@ from simulation.models import Order
 from simulation.ai.enums import Tactic, Aggressiveness
 from .base_decision_engine import BaseDecisionEngine
 from .rule_based_firm_engine import RuleBasedFirmDecisionEngine
-from simulation.dtos import DecisionContext
+from simulation.dtos import DecisionContext, FirmStateDTO
 
 if TYPE_CHECKING:
     from simulation.firms import Firm
@@ -19,6 +19,7 @@ class StandaloneRuleBasedFirmDecisionEngine(BaseDecisionEngine):
     기업의 규칙 기반 의사결정을 담당하는 독립형 엔진.
     AI가 없는 환경에서 기업의 기본적인 경제 활동을 시뮬레이션한다.
     RuleBasedFirmDecisionEngine의 기능을 활용한다.
+    Refactored for DTO Purity Gate (WO-114).
     """
 
     def __init__(
@@ -42,7 +43,7 @@ class StandaloneRuleBasedFirmDecisionEngine(BaseDecisionEngine):
         규칙 기반 로직을 사용하여 기업의 의사결정을 수행한다.
         생산 조정, 임금 조정, 가격 조정에 집중한다.
         """
-        firm = context.firm
+        firm = context.state # FirmStateDTO
         markets = context.markets
         goods_data = context.goods_data
         market_data = context.market_data
@@ -50,6 +51,12 @@ class StandaloneRuleBasedFirmDecisionEngine(BaseDecisionEngine):
 
         if firm is None:
             return [], (Tactic.NO_ACTION, Aggressiveness.NEUTRAL)
+
+        # Guard: Check type
+        if not isinstance(firm, FirmStateDTO):
+            self.logger.error("StandaloneEngine received invalid state object.")
+            return [], (Tactic.NO_ACTION, Aggressiveness.NEUTRAL)
+
         orders: List[Order] = []
         chosen_tactic: Tactic = Tactic.NO_ACTION
         chosen_aggressiveness: Aggressiveness = Aggressiveness.NEUTRAL # 규칙 기반은 중립으로 설정
@@ -61,14 +68,16 @@ class StandaloneRuleBasedFirmDecisionEngine(BaseDecisionEngine):
         # 1. 생산 조정 결정 (Planning)
         if current_inventory > target_quantity * self.config_module.OVERSTOCK_THRESHOLD:
             chosen_tactic = Tactic.ADJUST_PRODUCTION
-            orders.extend(self.rule_based_executor._adjust_production(firm, current_time))
+            prod_orders = self.rule_based_executor._adjust_production(firm, current_time)
+            orders.extend(prod_orders)
             self.logger.info(
                 f"Firm {firm.id} RuleBased: Overstocked, adjusting production.",
                 extra={"tick": current_time, "agent_id": firm.id, "tactic": Tactic.ADJUST_PRODUCTION.name}
             )
         elif current_inventory < target_quantity * self.config_module.UNDERSTOCK_THRESHOLD:
             chosen_tactic = Tactic.ADJUST_PRODUCTION
-            orders.extend(self.rule_based_executor._adjust_production(firm, current_time))
+            prod_orders = self.rule_based_executor._adjust_production(firm, current_time)
+            orders.extend(prod_orders)
             self.logger.info(
                 f"Firm {firm.id} RuleBased: Understocked, adjusting production.",
                 extra={"tick": current_time, "agent_id": firm.id, "tactic": Tactic.ADJUST_PRODUCTION.name}
@@ -77,35 +86,27 @@ class StandaloneRuleBasedFirmDecisionEngine(BaseDecisionEngine):
         # 2. 임금 조정 및 고용 결정 (Operation)
         # WO-110: Sequential execution - Check labor needs even if production was adjusted
         needed_labor_for_production = self.rule_based_executor._calculate_needed_labor(firm)
-        current_employees = len(firm.hr.employees)
+        current_employees = len(firm.employees)
 
-        # SoC Refactor: use hr.employees
         # Hiring Logic
         if current_employees < needed_labor_for_production * self.config_module.FIRM_LABOR_REQUIREMENT_RATIO or \
            current_employees < self.config_module.FIRM_MIN_EMPLOYEES:
 
-            # Even if we adjusted production, we might still need to hire.
-            # If we were idling (NO_ACTION), we mark this as our main tactic.
-            # If we already adjusted production, we keep that as the primary tactic but still execute hiring.
             if chosen_tactic == Tactic.NO_ACTION:
                 chosen_tactic = Tactic.ADJUST_WAGES
 
-            # Fix mutual exclusivity bug: Always append orders regardless of chosen_tactic state
-            orders.extend(self.rule_based_executor._adjust_wages(firm, current_time, market_data))
+            hiring_orders = self.rule_based_executor._adjust_wages(firm, current_time, market_data)
+            orders.extend(hiring_orders)
             self.logger.info(
                 f"Firm {firm.id} RuleBased: Need more labor, adjusting wages/hiring.",
                 extra={"tick": current_time, "agent_id": firm.id, "tactic": Tactic.ADJUST_WAGES.name}
             )
 
         # Firing Logic (WO-110)
-        # If overstocked (production target reduced), we may have excess labor.
         firing_buffer_ratio = getattr(self.config_module, "LABOR_FIRING_BUFFER_RATIO", 1.05)
         if current_employees > needed_labor_for_production * firing_buffer_ratio:
-             # WO-110 Fix: Labor Hoarding to prevent Demand Collapse.
-             # Only fire if we are actually losing money for a sustained period or running low on cash.
-             # If we are profitable or have huge reserves, keep employees to sustain the economy (Demand side).
              loss_threshold = getattr(self.config_module, "LABOR_HOARDING_LOSS_THRESHOLD", 5)
-             is_bleeding = firm.finance.consecutive_loss_turns > loss_threshold
+             is_bleeding = firm.consecutive_loss_turns > loss_threshold
 
              startup_cost = getattr(self.config_module, "STARTUP_COST", 30000.0)
              asset_ratio_threshold = getattr(self.config_module, "LABOR_HOARDING_ASSET_RATIO", 0.5)
@@ -113,29 +114,28 @@ class StandaloneRuleBasedFirmDecisionEngine(BaseDecisionEngine):
 
              if is_bleeding or is_poor:
                  # Fire excess
-                 self.rule_based_executor._fire_excess_labor(firm, needed_labor_for_production)
-                 # _fire_excess_labor returns [] orders but performs action.
+                 firing_orders = self.rule_based_executor._fire_excess_labor(firm, needed_labor_for_production)
+                 orders.extend(firing_orders)
                  self.logger.info(
-                    f"Firm {firm.id} RuleBased: Excess labor ({current_employees} > {needed_labor_for_production:.1f}), firing due to financial pressure (LossTicks={firm.finance.consecutive_loss_turns}).",
+                    f"Firm {firm.id} RuleBased: Excess labor ({current_employees} > {needed_labor_for_production:.1f}), firing due to financial pressure.",
                     extra={"tick": current_time, "agent_id": firm.id, "tactic": "FIRING"}
                 )
              else:
                  self.logger.info(
-                    f"Firm {firm.id} RuleBased: Excess labor ({current_employees} > {needed_labor_for_production:.1f}), but hoarding labor (LossTicks={firm.finance.consecutive_loss_turns}).",
+                    f"Firm {firm.id} RuleBased: Excess labor ({current_employees} > {needed_labor_for_production:.1f}), but hoarding labor.",
                     extra={"tick": current_time, "agent_id": firm.id, "tactic": "HOARDING"}
                 )
 
         # 3. 가격 조정 및 판매 (Commerce)
         if current_inventory > 0:
-            # Decide on price tactic primarily if no other tactic was chosen, but execute selling regardless.
             if chosen_tactic == Tactic.NO_ACTION:
-                # 간단한 규칙: 재고가 많으면 가격을 낮추고, 적으면 가격 유지 또는 높임
                 if current_inventory > firm.production_target * self.config_module.OVERSTOCK_THRESHOLD:
-                    chosen_tactic = Tactic.PRICE_DECREASE_SMALL # 가격 인하
+                    chosen_tactic = Tactic.PRICE_DECREASE_SMALL
                 else:
-                    chosen_tactic = Tactic.PRICE_HOLD # 가격 유지 (또는 AI처럼 동적 조정)
+                    chosen_tactic = Tactic.PRICE_HOLD
 
-            orders.extend(self._adjust_price_based_on_inventory(firm, current_time))
+            pricing_orders = self._adjust_price_based_on_inventory(firm, current_time)
+            orders.extend(pricing_orders)
             self.logger.info(
                 f"Firm {firm.id} RuleBased: Adjusting price and selling.",
                 extra={"tick": current_time, "agent_id": firm.id, "tactic": Tactic.ADJUST_PRICE.name}
@@ -143,10 +143,9 @@ class StandaloneRuleBasedFirmDecisionEngine(BaseDecisionEngine):
 
         return orders, (chosen_tactic, chosen_aggressiveness)
     
-    def _adjust_price_based_on_inventory(self, firm: Firm, current_tick: int) -> List[Order]:
+    def _adjust_price_based_on_inventory(self, firm: FirmStateDTO, current_tick: int) -> List[Order]:
         """
         재고 수준에 따라 판매 가격을 조정하고 판매 주문을 생성한다.
-        AIDrivenFirmDecisionEngine의 _adjust_price 메서드와 유사하게 구현.
         """
         orders = []
         item_id = firm.specialization
@@ -159,7 +158,8 @@ class StandaloneRuleBasedFirmDecisionEngine(BaseDecisionEngine):
                 < target_inventory * self.config_module.UNDERSTOCK_THRESHOLD
             )
 
-            base_price = firm.last_prices.get(
+            # Get price from history or config
+            base_price = firm.price_history.get(
                 item_id, self.config_module.GOODS[item_id]["production_cost"]
             )
 
@@ -169,12 +169,9 @@ class StandaloneRuleBasedFirmDecisionEngine(BaseDecisionEngine):
                     current_inventory - target_inventory
                 ) / target_inventory
                 
-                # --- Genesis: Acceleration & Emergency Sale (WO-Diag-005) ---
                 price_multiplier = getattr(self.config_module, "GENESIS_PRICE_ADJUSTMENT_MULTIPLIER", 1.0)
                 
-                # Check for Emergency Overstock (2x threshold)
                 if current_inventory > 2 * target_inventory * self.config_module.OVERSTOCK_THRESHOLD:
-                    # Step-change drop: Force 50% discount to clear dead stock
                     adjusted_price = min(base_price * 0.5, self.config_module.GOODS[item_id]["production_cost"] * 0.5)
                     self.logger.warning(
                         f"EMERGENCY_FIRE_SALE | Firm {firm.id} is severely overstocked ({current_inventory:.1f}). Force-cutting price to {adjusted_price:.2f}",
@@ -184,22 +181,22 @@ class StandaloneRuleBasedFirmDecisionEngine(BaseDecisionEngine):
                     signed_power = (
                         abs(diff_ratio) ** self.config_module.PRICE_ADJUSTMENT_EXPONENT
                     )
-                    # Apply multiplier to speed up price discovery
                     adjustment = signed_power * self.config_module.PRICE_ADJUSTMENT_FACTOR * price_multiplier
                     
-                    if diff_ratio < 0: # Understocked, increase price
+                    if diff_ratio < 0:
                         adjusted_price = base_price * (1 + adjustment)
-                    else: # Overstocked, decrease price
+                    else:
                         adjusted_price = base_price * (1 - adjustment)
-                # ------------------------------------------------------------
 
             final_price = max(
-                getattr(self.config_module, "MIN_SELL_PRICE", 0.1), # Use config floor
+                getattr(self.config_module, "MIN_SELL_PRICE", 0.1),
                 min(self.config_module.MAX_SELL_PRICE, adjusted_price),
             )
-            # SoC Refactor: use sales.set_price
-            firm.sales.set_price(item_id, final_price)
 
+            # 1. Update Internal Price
+            orders.append(Order(firm.id, "SET_PRICE", item_id, final_price, 0.0, "internal"))
+
+            # 2. Sell Order
             quantity_to_sell = min(
                 current_inventory, self.config_module.MAX_SELL_QUANTITY
             )
@@ -210,7 +207,7 @@ class StandaloneRuleBasedFirmDecisionEngine(BaseDecisionEngine):
                     item_id,
                     quantity_to_sell,
                     final_price,
-                    item_id, # FIX: Use item_id as market_id (assumes market_id matches item_id)
+                    item_id,
                 )
                 orders.append(order)
                 self.logger.info(
diff --git a/simulation/dtos/api.py b/simulation/dtos/api.py
index 38ee2b3..3c36bfe 100644
--- a/simulation/dtos/api.py
+++ b/simulation/dtos/api.py
@@ -167,10 +167,6 @@ class DecisionContext:
     reflux_system: Optional[Any] = None # Phase 8-B: Reflux System
     stress_scenario_config: Optional[StressScenarioConfig] = None # Phase 28
 
-    # --- DEPRECATED FIELDS (To be removed after full migration) ---
-    household: Optional[Household] = None 
-    firm: Optional[Firm] = None
-
 
 @dataclass
 class SimulationState:
diff --git a/simulation/dtos/firm_state_dto.py b/simulation/dtos/firm_state_dto.py
index f68a637..dca6aec 100644
--- a/simulation/dtos/firm_state_dto.py
+++ b/simulation/dtos/firm_state_dto.py
@@ -62,12 +62,27 @@ class FirmStateDTO:
         employees_data = {}
         if hasattr(firm, 'hr') and hasattr(firm.hr, 'employees'):
             employee_ids = [e.id for e in firm.hr.employees]
-            # Ideally we would populate employees_data, but for now we keep it minimal if not exposed
+
+            # Populate employees_data for CorporateManager
+            wages_map = getattr(firm.hr, 'employee_wages', {})
+            for e in firm.hr.employees:
+                employees_data[e.id] = {
+                    "id": e.id,
+                    "wage": wages_map.get(e.id, 0.0),
+                    "skill": getattr(e, 'labor_skill', 1.0),
+                    "age": getattr(e, 'age', 0),
+                    "education_level": getattr(e, 'education_level', 0)
+                }
 
         # Extract financial data safely (using properties or direct access)
         finance = getattr(firm, 'finance', None)
         revenue = firm.revenue_this_turn if finance else 0.0
         expenses = firm.expenses_this_tick if finance else 0.0
+
+        profit_history = []
+        if finance and hasattr(finance, 'profit_history'):
+             profit_history = list(finance.profit_history)
+
         consecutive_loss_turns = firm.consecutive_loss_turns if hasattr(firm, 'consecutive_loss_turns') else 0
         if finance and hasattr(finance, 'consecutive_loss_turns'):
              consecutive_loss_turns = finance.consecutive_loss_turns
@@ -107,7 +122,7 @@ class FirmStateDTO:
             consecutive_loss_turns=consecutive_loss_turns,
             altman_z_score=altman_z,
             price_history=firm.last_prices.copy(),
-            profit_history=[], # firm doesn't store full history in attributes easily, leaving empty for now or need to fetch from tracker
+            profit_history=profit_history,
             brand_awareness=firm.brand_manager.brand_awareness,
             perceived_quality=firm.brand_manager.perceived_quality,
             marketing_budget=firm.marketing_budget,
diff --git a/simulation/firms.py b/simulation/firms.py
index 41fee22..bb1c983 100644
--- a/simulation/firms.py
+++ b/simulation/firms.py
@@ -330,7 +330,6 @@ class Firm(BaseAgent, ILearningAgent):
         state_dto = self.get_state_dto()
 
         context = DecisionContext(
-            firm=self, # DEPRECATED
             state=state_dto,
             config=config_dto,
             markets=markets,
@@ -343,21 +342,104 @@ class Firm(BaseAgent, ILearningAgent):
         )
         decisions, tactic = self.decision_engine.make_decisions(context)
 
+        # WO-114: Internal Order Interceptor (Purity Gate execution)
+        external_orders = []
+        for order in decisions:
+            if order.market_id == "internal":
+                self._execute_internal_order(order, government, current_time)
+            else:
+                external_orders.append(order)
+
         # WO-056: Shadow Mode Calculation
         self._calculate_invisible_hand_price(markets, current_time)
 
         # SoC Refactor
         self.logger.debug(
-            f"FIRM_DECISION_END | Firm {self.id} after decision: Assets={self.assets:.2f}, Employees={len(self.hr.employees)}, is_active={self.is_active}, Decisions={len(decisions)}",
+            f"FIRM_DECISION_END | Firm {self.id} after decision: Assets={self.assets:.2f}, Employees={len(self.hr.employees)}, is_active={self.is_active}, Decisions={len(external_orders)}",
             extra={
                 **log_extra,
                 "assets_after": self.assets,
                 "num_employees_after": len(self.hr.employees),
                 "is_active_after": self.is_active,
-                "num_decisions": len(decisions),
+                "num_decisions": len(external_orders),
             },
         )
-        return decisions, tactic
+        return external_orders, tactic
+
+    def _execute_internal_order(self, order: Order, government: Optional[Any], current_time: int) -> None:
+        """Executes internal orders (state modifications) received from the Decision Engine."""
+        if order.order_type == "SET_TARGET":
+            self.production_target = order.quantity
+            self.logger.info(f"INTERNAL_EXEC | Firm {self.id} set production target to {self.production_target:.1f}")
+
+        elif order.order_type == "INVEST_AUTOMATION":
+            spend = order.quantity
+            if self.finance.invest_in_automation(spend):
+                cost_per_pct = getattr(self.config_module, "AUTOMATION_COST_PER_PCT", 1000.0)
+                if cost_per_pct > 0:
+                    gained_a = (spend / cost_per_pct) / 100.0
+                    self.production.set_automation_level(self.automation_level + gained_a)
+                    self.logger.info(f"INTERNAL_EXEC | Firm {self.id} invested {spend:.1f} in automation.")
+
+        elif order.order_type == "PAY_TAX":
+            amount = order.quantity
+            reason = order.item_id
+            if government:
+                self.finance.pay_ad_hoc_tax(amount, reason, government, current_time)
+
+        elif order.order_type == "INVEST_RD":
+            budget = order.quantity
+            if self.finance.invest_in_rd(budget):
+                self._execute_rd_outcome(budget, current_time)
+
+        elif order.order_type == "INVEST_CAPEX":
+            budget = order.quantity
+            if self.finance.invest_in_capex(budget):
+                efficiency = 1.0 / getattr(self.config_module, "CAPITAL_TO_OUTPUT_RATIO", 2.0)
+                added_capital = budget * efficiency
+                self.production.add_capital(added_capital)
+                self.logger.info(f"INTERNAL_EXEC | Firm {self.id} invested {budget:.1f} in CAPEX.")
+
+        elif order.order_type == "SET_DIVIDEND":
+            self.finance.set_dividend_rate(order.quantity)
+
+        elif order.order_type == "SET_PRICE":
+            # Using quantity field for price as per CorporateManager implementation
+            self.sales.set_price(order.item_id, order.quantity)
+
+        elif order.order_type == "FIRE":
+            emp_id = order.target_agent_id
+            severance_pay = order.price
+
+            employee = next((e for e in self.hr.employees if e.id == emp_id), None)
+            if employee:
+                if self.finance.pay_severance(employee, severance_pay):
+                    employee.quit()
+                    self.hr.remove_employee(employee)
+                    self.logger.info(f"INTERNAL_EXEC | Firm {self.id} fired employee {emp_id}.")
+                else:
+                    self.logger.warning(f"INTERNAL_EXEC | Firm {self.id} failed to fire {emp_id} (insufficient funds).")
+
+    def _execute_rd_outcome(self, budget: float, current_time: int) -> None:
+        """Executes the probabilistic outcome of R&D investment."""
+        self.research_history["total_spent"] += budget
+
+        denominator = max(self.finance.revenue_this_turn * 0.2, 100.0)
+        base_chance = min(1.0, budget / denominator)
+
+        avg_skill = 1.0
+        if self.hr.employees:
+            avg_skill = sum(getattr(e, 'labor_skill', 1.0) for e in self.hr.employees) / len(self.hr.employees)
+
+        success_chance = base_chance * avg_skill
+
+        import random
+        if random.random() < success_chance:
+            self.research_history["success_count"] += 1
+            self.research_history["last_success_tick"] = current_time
+            self.base_quality += 0.05
+            self.productivity_factor *= 1.05
+            self.logger.info(f"INTERNAL_EXEC | Firm {self.id} R&D SUCCESS (Budget: {budget:.1f})")
 
     def _calculate_invisible_hand_price(self, markets: Dict[str, Any], current_tick: int) -> None:
         """
diff --git a/tests/test_corporate_manager.py b/tests/test_corporate_manager.py
index 625554f..c621220 100644
--- a/tests/test_corporate_manager.py
+++ b/tests/test_corporate_manager.py
@@ -1,9 +1,8 @@
 
 import pytest
 from unittest.mock import MagicMock
-from simulation.firms import Firm
 from simulation.decisions.corporate_manager import CorporateManager
-from simulation.dtos import DecisionContext
+from simulation.dtos import DecisionContext, FirmStateDTO
 from simulation.schemas import FirmActionVector
 from simulation.models import Order
 from simulation.ai.enums import Personality
@@ -14,120 +13,79 @@ class MockConfig:
     DIVIDEND_RATE_MAX = 0.5
     MAX_SELL_QUANTITY = 100
     LABOR_MARKET_MIN_WAGE = 10.0
-    GOODS = {"food": {"production_cost": 10.0}}
-    # Added for automation
+    GOODS = {"food": {"production_cost": 10.0, "inputs": {}}}
     AUTOMATION_COST_PER_PCT = 1000.0
     FIRM_SAFETY_MARGIN = 2000.0
     AUTOMATION_TAX_RATE = 0.05
     SEVERANCE_PAY_WEEKS = 4
+    FIRM_MIN_PRODUCTION_TARGET = 10.0
+    FIRM_MAX_PRODUCTION_TARGET = 500.0
+    OVERSTOCK_THRESHOLD = 1.2
+    UNDERSTOCK_THRESHOLD = 0.8
+    PRODUCTION_ADJUSTMENT_FACTOR = 0.1
+    SEO_TRIGGER_RATIO = 0.5
+    SEO_MAX_SELL_RATIO = 0.1
+    STARTUP_COST = 30000.0
 
 @pytest.fixture
-def firm_mock(golden_firms):
-    if not golden_firms:
-        pytest.skip("Golden firms fixture is empty or failed to load.")
-    firm = golden_firms[0]
-
-    # Initialize BaseAgent fields
-    firm._assets = 10000.0 # Default assets
-
-    # --- SoC Components Mocking ---
-    firm.finance = MagicMock()
-    firm.finance.revenue_this_turn = 200.0
-    firm.finance.last_sales_volume = 1.0
-    firm.finance.last_revenue = 200.0
-
-    # Side effects to simulate real behavior on mock firm assets
-    def invest_side_effect(amount):
-        firm._assets -= amount
-        return True
-
-    def pay_tax_side_effect(amount, *args, **kwargs):
-        firm._assets -= amount
-        return True
-
-    def pay_severance_side_effect(emp, amount):
-        firm._assets -= amount
-        # emp is a mock, so emp.assets update is mocked
-        if hasattr(emp, 'assets'):
-             emp._assets += amount
-        return True
-
-    def set_dividend_rate_side_effect(rate):
-        firm.dividend_rate = rate
-
-    firm.finance.invest_in_automation.side_effect = invest_side_effect
-    firm.finance.invest_in_rd.side_effect = invest_side_effect
-    firm.finance.invest_in_capex.side_effect = invest_side_effect
-    firm.finance.pay_severance.side_effect = pay_severance_side_effect
-    firm.finance.pay_ad_hoc_tax.side_effect = pay_tax_side_effect
-    firm.finance.set_dividend_rate.side_effect = set_dividend_rate_side_effect
-    firm.finance.get_book_value_per_share.return_value = 10.0 # Default BPS
-    firm.finance.calculate_altman_z_score.return_value = 3.0 # Default safe Z-score
-    firm.finance.consecutive_loss_turns = 0
-
-    firm.hr = MagicMock()
-    firm.hr.employees = []
-    firm.hr.employee_wages = {}
-
-    firm.production = MagicMock()
-    firm.production.set_automation_level.side_effect = lambda x: setattr(firm, 'automation_level', x)
-    firm.production.add_capital.side_effect = lambda x: setattr(firm, 'capital_stock', firm.capital_stock + x)
-
-    firm.sales = MagicMock()
-    firm.sales.set_price.side_effect = lambda item, price: firm.last_prices.update({item: price})
-
-    # --- Firm Attributes ---
-    firm.production_target = 100
-    firm.productivity_factor = 1.0
-    firm.specialization = "food"
-    if not isinstance(firm.inventory, dict):
-        firm.inventory = {"food": 50}
-    else:
-         firm.inventory["food"] = 50
-
-    firm.base_quality = 1.0
-    firm.research_history = {"total_spent": 0.0, "success_count": 0, "last_success_tick": -1}
-    firm.capital_stock = 100.0
-    firm.dividend_rate = 0.1
-    firm.total_shares = 100
-    firm.treasury_shares = 0
-    firm.last_prices = {"food": 10.0}
-    firm.personality = Personality.BALANCED
-
-    firm.system2_planner = None
-    firm.consecutive_loss_ticks_for_bankruptcy_threshold = 5
-    firm.automation_level = 0.0
-    firm.total_debt = 0.0
-    firm.bond_obligations = []
-
-    if not hasattr(firm, 'decision_engine'):
-        firm.decision_engine = MagicMock()
-
-    mock_bank = MagicMock()
-    mock_bank.get_debt_summary.return_value = {'total_principal': 0.0}
-
-    mock_loan_market = MagicMock()
-    mock_loan_market.bank = mock_bank
-
-    firm.decision_engine.loan_market = mock_loan_market
-
-    return firm
+def firm_dto():
+    return FirmStateDTO(
+        id=1,
+        assets=10000.0,
+        is_active=True,
+        inventory={"food": 50.0},
+        inventory_quality={"food": 1.0},
+        input_inventory={},
+        current_production=0.0,
+        productivity_factor=1.0,
+        production_target=100.0,
+        capital_stock=100.0,
+        base_quality=1.0,
+        automation_level=0.0,
+        specialization="food",
+        total_shares=100.0,
+        treasury_shares=0.0,
+        dividend_rate=0.1,
+        is_publicly_traded=True,
+        valuation=1000.0,
+        revenue_this_turn=200.0,
+        expenses_this_tick=100.0,
+        consecutive_loss_turns=0,
+        altman_z_score=3.0,
+        price_history={"food": 10.0},
+        profit_history=[],
+        brand_awareness=0.0,
+        perceived_quality=1.0,
+        marketing_budget=0.0,
+        employees=[],
+        employees_data={},
+        agent_data={"personality": "BALANCED"},
+        system2_guidance={},
+        sentiment_index=1.0
+    )
 
 @pytest.fixture
-def context_mock(firm_mock):
+def context_mock(firm_dto):
     context = MagicMock(spec=DecisionContext)
-    context.firm = firm_mock
+    context.state = firm_dto # Use state
     context.current_time = 1
-    context.market_data = {}
+    context.market_data = {
+        "goods_market": {
+            "food_avg_traded_price": 10.0,
+            "food_current_sell_price": 10.0
+        },
+        "debt_data": {1: {"total_principal": 0.0}}
+    }
     context.markets = {
         "food": MagicMock(),
-        "labor": MagicMock()
+        "labor": MagicMock(),
+        "stock_market": MagicMock()
     }
     context.reflux_system = MagicMock()
     context.government = MagicMock()
     return context
 
-def test_rd_logic(firm_mock, context_mock, monkeypatch):
+def test_rd_logic(firm_dto, context_mock):
     manager = CorporateManager(MockConfig())
     # Aggressiveness 1.0 -> 20% of Revenue
     vector = FirmActionVector(
@@ -139,55 +97,76 @@ def test_rd_logic(firm_mock, context_mock, monkeypatch):
         sales_aggressiveness=0.0
     )
 
-    # Need enough assets to pass safety margin (default 2000)
-    firm_mock._assets = 10000.0
-    firm_mock.finance.revenue_this_turn = 1000.0 # Set on finance
+    firm_dto.assets = 10000.0
+    firm_dto.revenue_this_turn = 1000.0
     expected_budget = 1000.0 * 0.2 # 200
 
-    # Force success
-    monkeypatch.setattr("random.random", lambda: 0.0)
-
-    initial_quality = firm_mock.base_quality
-    initial_prod = firm_mock.productivity_factor
+    orders = manager.realize_ceo_actions(firm_dto, context_mock, vector)
 
-    manager.realize_ceo_actions(firm_mock, context_mock, vector)
+    rd_orders = [o for o in orders if o.order_type == "INVEST_RD"]
+    assert len(rd_orders) == 1
+    assert rd_orders[0].quantity == expected_budget
+    assert rd_orders[0].market_id == "internal"
 
-    assert firm_mock.assets == 10000.0 - expected_budget
-    assert firm_mock.base_quality == pytest.approx(initial_quality + 0.05)
-    assert firm_mock.productivity_factor == pytest.approx(initial_prod * 1.05)
-
-def test_dividend_logic(firm_mock, context_mock):
+def test_dividend_logic(firm_dto, context_mock):
     manager = CorporateManager(MockConfig())
     vector = FirmActionVector(dividend_aggressiveness=1.0) # Max rate 0.5
 
-    manager.realize_ceo_actions(firm_mock, context_mock, vector)
+    orders = manager.realize_ceo_actions(firm_dto, context_mock, vector)
 
-    assert firm_mock.dividend_rate == 0.5
+    div_orders = [o for o in orders if o.order_type == "SET_DIVIDEND"]
+    assert len(div_orders) == 1
+    assert div_orders[0].quantity == 0.5
 
-def test_hiring_logic(firm_mock, context_mock):
+def test_hiring_logic(firm_dto, context_mock):
     manager = CorporateManager(MockConfig())
-    firm_mock.production_target = 100
-    # firm.inventory is a dict, so updating it works
-    firm_mock.inventory["food"] = 80 # Gap 20
-    firm_mock.productivity_factor = 10.0 # Need 2 workers
+    firm_dto.production_target = 100
+    firm_dto.inventory["food"] = 80 # Gap 20
+    firm_dto.productivity_factor = 10.0 # Need 2 workers (approx)
+
+    # Adjust mock to return empty list of employees so we hire
+    firm_dto.employees = []
 
-    vector = FirmActionVector(hiring_aggressiveness=0.5) # Market wage
+    vector = FirmActionVector(hiring_aggressiveness=0.5)
 
-    orders = manager.realize_ceo_actions(firm_mock, context_mock, vector)
+    orders = manager.realize_ceo_actions(firm_dto, context_mock, vector)
 
     hiring_orders = [o for o in orders if o.order_type == "BUY" and o.item_id == "labor"]
     assert len(hiring_orders) > 0
     assert hiring_orders[0].price >= 10.0
 
-def test_debt_logic_borrow(firm_mock, context_mock):
+def test_debt_logic_borrow(firm_dto, context_mock):
     manager = CorporateManager(MockConfig())
-    firm_mock._assets = 1000.0
-    firm_mock.total_debt = 0.0
+    firm_dto.assets = 1000.0
+
+    # Mock debt data
+    context_mock.market_data["debt_data"] = {firm_dto.id: {"total_principal": 0.0}}
 
     vector = FirmActionVector(debt_aggressiveness=0.5)
 
-    orders = manager.realize_ceo_actions(firm_mock, context_mock, vector)
+    orders = manager.realize_ceo_actions(firm_dto, context_mock, vector)
 
     loan_reqs = [o for o in orders if o.order_type == "LOAN_REQUEST"]
     assert len(loan_reqs) > 0
     assert loan_reqs[0].quantity > 0
+
+def test_automation_investment(firm_dto, context_mock):
+    config = MockConfig()
+    config.AUTOMATION_COST_PER_PCT = 10.0 # Make it cheap
+    manager = CorporateManager(config)
+    # Ensure automation is profitable so System 2 recommends it
+    # High wages so automation saves money
+    firm_dto.employees_data = {
+        1: {"wage": 2000.0, "skill": 1.0, "id": 1, "age": 20, "education_level": 1}
+    }
+    firm_dto.revenue_this_turn = 5000.0
+
+    firm_dto.assets = 50000.0 # Plenty of cash
+
+    vector = FirmActionVector(capital_aggressiveness=1.0)
+
+    orders = manager.realize_ceo_actions(firm_dto, context_mock, vector)
+
+    auto_orders = [o for o in orders if o.order_type == "INVEST_AUTOMATION"]
+    assert len(auto_orders) > 0
+    assert auto_orders[0].quantity > 0
diff --git a/tests/test_purity_gate.py b/tests/test_purity_gate.py
new file mode 100644
index 0000000..3d586a2
--- /dev/null
+++ b/tests/test_purity_gate.py
@@ -0,0 +1,156 @@
+
+import pytest
+from unittest.mock import MagicMock
+from simulation.dtos import DecisionContext, FirmStateDTO
+from modules.household.dtos import HouseholdStateDTO
+from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
+from simulation.decisions.standalone_rule_based_firm_engine import StandaloneRuleBasedFirmDecisionEngine
+from simulation.decisions.ai_driven_firm_engine import AIDrivenFirmDecisionEngine
+
+def test_decision_context_purity():
+    """Verify DecisionContext does not expose raw agents."""
+    assert not hasattr(DecisionContext, 'household')
+    assert not hasattr(DecisionContext, 'firm')
+
+    # Try to instantiate with deprecated fields (should fail type check or init if slots used,
+    # but since it's a dataclass, it might accept kwargs if we are not careful,
+    # but we removed fields so it should raise TypeError on init if passed)
+
+    try:
+        DecisionContext(
+            markets={}, goods_data=[], market_data={}, current_time=0,
+            state=MagicMock(), config=MagicMock(),
+            household=MagicMock() # Should fail
+        )
+        pytest.fail("DecisionContext accepted 'household' argument.")
+    except TypeError:
+        pass
+
+def test_standalone_firm_engine_uses_dto():
+    """Verify StandaloneRuleBasedFirmDecisionEngine accepts FirmStateDTO."""
+    config_mock = MagicMock()
+    config_mock.OVERSTOCK_THRESHOLD = 1.2
+    config_mock.UNDERSTOCK_THRESHOLD = 0.8
+    config_mock.FIRM_MIN_PRODUCTION_TARGET = 10.0
+    config_mock.FIRM_MAX_PRODUCTION_TARGET = 100.0
+    config_mock.PRODUCTION_ADJUSTMENT_FACTOR = 0.1
+    config_mock.FIRM_LABOR_REQUIREMENT_RATIO = 1.0
+    config_mock.FIRM_MIN_EMPLOYEES = 1
+    config_mock.LABOR_FIRING_BUFFER_RATIO = 1.1
+    config_mock.GOODS = {"wood": {"production_cost": 10.0}}
+    config_mock.MIN_SELL_PRICE = 1.0
+    config_mock.MAX_SELL_PRICE = 100.0
+    config_mock.MAX_SELL_QUANTITY = 100.0
+    config_mock.BASE_WAGE = 10.0 # Float, not Mock
+    # Fix getattr(mock) returning Mock instead of default
+    config_mock.GENESIS_PRICE_ADJUSTMENT_MULTIPLIER = 1.0
+    config_mock.PRICE_ADJUSTMENT_EXPONENT = 1.0
+    config_mock.PRICE_ADJUSTMENT_FACTOR = 0.1
+
+    engine = StandaloneRuleBasedFirmDecisionEngine(config_mock)
+
+    firm_dto = FirmStateDTO(
+        id=1, assets=1000.0, is_active=True, inventory={"wood": 50.0}, inventory_quality={}, input_inventory={},
+        current_production=0.0, productivity_factor=1.0, production_target=50.0, capital_stock=10.0, base_quality=1.0,
+        automation_level=0.0, specialization="wood", total_shares=100, treasury_shares=0, dividend_rate=0.0,
+        is_publicly_traded=False, valuation=0.0, revenue_this_turn=0.0, expenses_this_tick=0.0, consecutive_loss_turns=0,
+        altman_z_score=0.0, price_history={"wood": 10.0}, profit_history=[], brand_awareness=0.0, perceived_quality=0.0,
+        marketing_budget=0.0, employees=[], employees_data={}, agent_data={}, system2_guidance={}, sentiment_index=0.5
+    )
+
+    context = MagicMock(spec=DecisionContext)
+    context.state = firm_dto
+    context.markets = {}
+    context.goods_data = []
+    context.market_data = {}
+    context.current_time = 1
+
+    orders, (tactic, agg) = engine.make_decisions(context)
+
+    assert isinstance(orders, list)
+    # Check that it didn't crash
+
+def test_household_engine_uses_dto():
+    """Verify AIDrivenHouseholdDecisionEngine accepts HouseholdStateDTO."""
+    ai_engine_mock = MagicMock()
+    ai_engine_mock.decide_action_vector.return_value = MagicMock(
+        consumption_aggressiveness={},
+        job_mobility_aggressiveness=0.0
+    )
+
+    config_mock = MagicMock()
+    config_mock.GOODS = {"food": {}}
+    config_mock.HOUSEHOLD_MAX_PURCHASE_QUANTITY = 10
+    config_mock.DSR_CRITICAL_THRESHOLD = 0.5
+    config_mock.MARKET_PRICE_FALLBACK = 10.0 # Float
+    config_mock.BULK_BUY_NEED_THRESHOLD = 100.0
+    config_mock.BULK_BUY_AGG_THRESHOLD = 0.8
+    config_mock.PANIC_BUYING_THRESHOLD = 0.05
+    config_mock.DEFLATION_WAIT_THRESHOLD = -0.05
+    config_mock.DELAY_FACTOR = 0.5
+    config_mock.HOARDING_FACTOR = 0.5
+    config_mock.BUDGET_LIMIT_URGENT_NEED = 50.0
+    config_mock.BUDGET_LIMIT_URGENT_RATIO = 0.8
+    config_mock.BUDGET_LIMIT_NORMAL_RATIO = 0.5
+
+    engine = AIDrivenHouseholdDecisionEngine(ai_engine_mock, config_mock)
+
+    household_dto = MagicMock(spec=HouseholdStateDTO) # Using Mock of DTO for simplicity
+    household_dto.id = 1
+    household_dto.agent_data = {}
+    household_dto.inventory = {"basic_food": 10.0}
+    household_dto.needs = {"hunger": 0.0}
+    household_dto.assets = 1000.0
+    household_dto.current_wage = 10.0
+    household_dto.expected_inflation = {}
+    household_dto.personality = "BALANCED" # Enum mock
+    household_dto.preference_asset = 1.0
+    household_dto.preference_social = 1.0
+    household_dto.preference_growth = 1.0
+    household_dto.durable_assets = []
+    household_dto.is_employed = True
+
+    config_dto = MagicMock()
+    config_dto.market_price_fallback = 10.0
+    config_dto.min_purchase_quantity = 1.0
+    config_dto.household_max_purchase_quantity = 10.0
+    config_dto.bulk_buy_need_threshold = 100.0
+    config_dto.bulk_buy_agg_threshold = 0.8
+    config_dto.bulk_buy_moderate_ratio = 0.5
+    config_dto.panic_buying_threshold = 0.05
+    config_dto.hoarding_factor = 0.5
+    config_dto.deflation_wait_threshold = -0.05
+    config_dto.delay_factor = 0.5
+    config_dto.dsr_critical_threshold = 0.5
+    config_dto.budget_limit_normal_ratio = 0.5
+    config_dto.budget_limit_urgent_need = 50.0
+    config_dto.budget_limit_urgent_ratio = 0.8
+
+    # These are used via self.config_module (config_mock)
+    config_mock.BUDGET_LIMIT_NORMAL_RATIO = 0.5
+    config_mock.BUDGET_LIMIT_URGENT_NEED = 50.0
+    config_mock.BUDGET_LIMIT_URGENT_RATIO = 0.8
+    config_mock.NEED_FACTOR_BASE = 1.0
+    config_mock.NEED_FACTOR_SCALE = 100.0
+    config_mock.VALUATION_MODIFIER_BASE = 1.0
+    config_mock.VALUATION_MODIFIER_RANGE = 0.2
+    config_mock.BULK_BUY_NEED_THRESHOLD = 100.0
+    config_mock.BULK_BUY_AGG_THRESHOLD = 0.8
+    config_mock.BULK_BUY_MODERATE_RATIO = 0.5
+    config_mock.MIN_PURCHASE_QUANTITY = 1.0
+    config_mock.LABOR_MARKET_MIN_WAGE = 10.0
+    config_mock.JOB_QUIT_THRESHOLD_BASE = 0.5
+    config_mock.JOB_QUIT_PROB_BASE = 0.1
+    config_mock.JOB_QUIT_PROB_SCALE = 0.1
+
+    context = MagicMock(spec=DecisionContext)
+    context.state = household_dto
+    context.config = config_dto
+
+    context.markets = {}
+    context.market_data = {"loan_market": {"interest_rate": 0.05}}
+    context.current_time = 1
+
+    orders, vector = engine._make_decisions_internal(context)
+
+    assert isinstance(orders, list)
