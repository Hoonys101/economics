diff --git a/communications/insights/TD-008_Debt_Report.md b/communications/insights/TD-008_Debt_Report.md
new file mode 100644
index 0000000..71721bd
--- /dev/null
+++ b/communications/insights/TD-008_Debt_Report.md
@@ -0,0 +1,34 @@
+# Technical Debt Report - TD-008: Advanced Finance System Upgrade
+
+**Author:** Jules (Software Engineer)
+**Date:** 2024-05-24
+**Mission:** TD-008 Finance System Upgrade
+
+---
+
+## 1. 발견된 스파게티 코드 (Identified Spaghetti Code)
+- **FinanceDepartment Logic Leaks**:
+  기존의 `calculate_altman_z_score` 메서드가 `simulation/components/finance_department.py` (Agent Component) 내부에 구현되어 있었습니다.
+  그러나 이 로직은 시스템 수준의 감사(`FinanceSystem.evaluate_solvency`)에서 사용되므로, 시스템이 에이전트의 내부 컴포넌트 메서드에 직접 의존하는 구조였습니다. 이는 "시스템이 규칙을 정하고 에이전트는 따른다"는 원칙을 흐리게 만듭니다.
+
+## 2. 구현의 병목 (Implementation Bottlenecks)
+- **Data Access & Encapsulation**:
+  Z-Score 로직을 `modules/finance/domain`으로 분리했음에도 불구하고, 계산에 필요한 데이터(`retained_earnings`, `profit_history`)는 여전히 `FinanceDepartment`의 내부 상태로 관리됩니다.
+  따라서 `FinanceSystem`이 이 데이터를 얻기 위해 `firm.finance.retained_earnings`와 같이 깊숙이 접근해야 하며, 이는 `FinanceDepartment`의 구현 변경에 `FinanceSystem`이 취약하게 만듭니다.
+
+## 3. 신규 부채 (New Technical Debt)
+- **Manual Data Extraction in System**:
+  `FinanceSystem.evaluate_solvency` 메서드 내에서 `firm`과 `firm.finance`로부터 데이터를 수동으로 추출하여 `AltmanZScoreCalculator`에 주입하고 있습니다.
+  ```python
+  total_assets = firm.assets + firm.capital_stock + firm.get_inventory_value()
+  working_capital = firm.assets - getattr(firm, 'total_debt', 0.0)
+  retained_earnings = firm.finance.retained_earnings
+  ```
+  이러한 "Data Gathering" 코드는 중복될 가능성이 높고, `Firm`의 속성 이름이 바뀌면 `FinanceSystem`도 수정해야 하는 Coupling을 유지시킵니다.
+
+## 4. 상환 권고 (Repayment Recommendations)
+- **Standardized Financial Reporting**:
+  `Firm` (또는 `FinanceDepartment`)이 `FinancialStatementDTO`를 반환하도록 리팩토링해야 합니다.
+  `FinanceSystem`은 `firm.get_financial_statement()`를 호출하여 표준화된 데이터 객체를 받고, 이를 도메인 계산기에 넘기는 방식으로 변경하면 결합도를 낮출 수 있습니다.
+- **Domain Service Usage**:
+  `FinanceDepartment` 내부에서도 `AltmanZScoreCalculator`를 사용하도록 리팩토링하여 로직의 단일 진실 공급원(SSOT)을 유지해야 합니다. 현재는 `FinanceDepartment`에 구버전 로직이 남아있을 수 있습니다(이번 작업에서는 `system.py`만 수정함).
diff --git a/modules/finance/domain/__init__.py b/modules/finance/domain/__init__.py
new file mode 100644
index 0000000..2a04c2f
--- /dev/null
+++ b/modules/finance/domain/__init__.py
@@ -0,0 +1,3 @@
+from .corporate_finance import AltmanZScoreCalculator
+
+__all__ = ["AltmanZScoreCalculator"]
diff --git a/modules/finance/domain/corporate_finance.py b/modules/finance/domain/corporate_finance.py
new file mode 100644
index 0000000..a61fc13
--- /dev/null
+++ b/modules/finance/domain/corporate_finance.py
@@ -0,0 +1,51 @@
+from typing import Protocol, List
+from dataclasses import dataclass
+
+class AltmanZScoreCalculator:
+    """
+    Calculates the Altman Z-Score for a firm to assess its solvency and bankruptcy risk.
+
+    This implementation uses a modified Z-Score formula often used for non-manufacturing
+    or private companies, focusing on liquidity, cumulative profitability, and operational efficiency.
+    """
+
+    @staticmethod
+    def calculate(
+        total_assets: float,
+        working_capital: float,
+        retained_earnings: float,
+        average_profit: float
+    ) -> float:
+        """
+        Calculates the Altman Z-Score.
+
+        Formula:
+            Z = 1.2 * X1 + 1.4 * X2 + 3.3 * X3
+
+        Where:
+            X1 = Working Capital / Total Assets
+                 (Measures liquidity relative to size)
+            X2 = Retained Earnings / Total Assets
+                 (Measures cumulative profitability and leverage)
+            X3 = Average Profit (EBIT) / Total Assets
+                 (Measures operational efficiency)
+
+        Args:
+            total_assets (float): The sum of all assets (Cash + Capital + Inventory).
+            working_capital (float): Current Assets - Current Liabilities.
+            retained_earnings (float): The total earnings retained by the firm.
+            average_profit (float): The average profit (EBIT) over a recent period.
+
+        Returns:
+            float: The calculated Z-Score.
+                   Generally, Z > 3.0 is safe, 1.8 < Z < 3.0 is grey zone, Z < 1.8 is distress.
+        """
+        if total_assets <= 0:
+            return 0.0
+
+        x1 = working_capital / total_assets
+        x2 = retained_earnings / total_assets
+        x3 = average_profit / total_assets
+
+        z_score = 1.2 * x1 + 1.4 * x2 + 3.3 * x3
+        return z_score
diff --git a/modules/finance/system.py b/modules/finance/system.py
index eba2ad2..a929ae6 100644
--- a/modules/finance/system.py
+++ b/modules/finance/system.py
@@ -1,6 +1,7 @@
 from typing import List, Dict, Optional
 import logging
 from modules.finance.api import IFinanceSystem, BondDTO, BailoutLoanDTO, BailoutCovenant, IFinancialEntity, InsufficientFundsError
+from modules.finance.domain import AltmanZScoreCalculator
 # Forward reference for type hinting
 from simulation.firms import Firm
 
@@ -47,7 +48,21 @@ class FinanceSystem(IFinanceSystem):
             return firm.cash_reserve >= required_runway
         else:
             # Altman Z-Score for established firms
-            z_score = firm.finance.calculate_altman_z_score()
+            # Extracted data gathering to decouple from FinanceDepartment logic
+            total_assets = firm.assets + firm.capital_stock + firm.get_inventory_value()
+            working_capital = firm.assets - getattr(firm, 'total_debt', 0.0)
+            retained_earnings = firm.finance.retained_earnings
+
+            # Safe calculation of average profit
+            profit_history = firm.finance.profit_history
+            average_profit = sum(profit_history) / len(profit_history) if profit_history else 0.0
+
+            z_score = AltmanZScoreCalculator.calculate(
+                total_assets=total_assets,
+                working_capital=working_capital,
+                retained_earnings=retained_earnings,
+                average_profit=average_profit
+            )
             return z_score > z_score_threshold
 
     def issue_treasury_bonds(self, amount: float, current_tick: int) -> List[BondDTO]:
diff --git a/tests/modules/finance/test_corporate_finance.py b/tests/modules/finance/test_corporate_finance.py
new file mode 100644
index 0000000..aa80aaa
--- /dev/null
+++ b/tests/modules/finance/test_corporate_finance.py
@@ -0,0 +1,64 @@
+import pytest
+from modules.finance.domain.corporate_finance import AltmanZScoreCalculator
+
+class TestAltmanZScoreCalculator:
+
+    def test_calculate_safe_zone(self):
+        """Test a scenario where the firm is clearly safe (Z > 3.0)."""
+        # Example:
+        # Assets = 1000
+        # WC = 400 (40%) -> 1.2 * 0.4 = 0.48
+        # RE = 500 (50%) -> 1.4 * 0.5 = 0.70
+        # EBIT = 600 (60%) -> 3.3 * 0.6 = 1.98
+        # Total Z = 0.48 + 0.70 + 1.98 = 3.16
+
+        z = AltmanZScoreCalculator.calculate(
+            total_assets=1000.0,
+            working_capital=400.0,
+            retained_earnings=500.0,
+            average_profit=600.0
+        )
+        assert z == pytest.approx(3.16, abs=0.01)
+
+    def test_calculate_distress_zone(self):
+        """Test a scenario where the firm is in distress (Z < 1.8)."""
+        # Example:
+        # Assets = 1000
+        # WC = 100 (10%) -> 1.2 * 0.1 = 0.12
+        # RE = 0 (0%) -> 0
+        # EBIT = 100 (10%) -> 3.3 * 0.1 = 0.33
+        # Total Z = 0.12 + 0.33 = 0.45
+
+        z = AltmanZScoreCalculator.calculate(
+            total_assets=1000.0,
+            working_capital=100.0,
+            retained_earnings=0.0,
+            average_profit=100.0
+        )
+        assert z == pytest.approx(0.45, abs=0.01)
+
+    def test_calculate_zero_assets(self):
+        """Test calculation with zero assets (should handle division by zero)."""
+        z = AltmanZScoreCalculator.calculate(
+            total_assets=0.0,
+            working_capital=0.0,
+            retained_earnings=0.0,
+            average_profit=0.0
+        )
+        assert z == 0.0
+
+    def test_calculate_negative_values(self):
+        """Test calculation with negative working capital or profit."""
+        # Assets = 1000
+        # WC = -100 (-10%) -> 1.2 * -0.1 = -0.12
+        # RE = -200 (-20%) -> 1.4 * -0.2 = -0.28
+        # EBIT = -100 (-10%) -> 3.3 * -0.1 = -0.33
+        # Total Z = -0.73
+
+        z = AltmanZScoreCalculator.calculate(
+            total_assets=1000.0,
+            working_capital=-100.0,
+            retained_earnings=-200.0,
+            average_profit=-100.0
+        )
+        assert z == pytest.approx(-0.73, abs=0.01)
diff --git a/tests/modules/finance/test_system.py b/tests/modules/finance/test_system.py
index 9249e79..a688ccf 100644
--- a/tests/modules/finance/test_system.py
+++ b/tests/modules/finance/test_system.py
@@ -77,12 +77,25 @@ class StubFirm:
         self.id = 1
         self.age = 100
         self.assets = 10000.0
+        self.capital_stock = 0.0
+        self.total_debt = 0.0
         self.cash_reserve = 5000.0
         self.hr = Mock()
         self.hr.get_total_wage_bill.return_value = 1000.0
         self.finance = MagicMock()
-        self.finance.calculate_altman_z_score.return_value = 2.0
+        # Default healthy values:
+        # Total Assets = 10000
+        # WC = 10000 (X1 = 1.0) -> 1.2
+        # RE = 5000 (X2 = 0.5) -> 0.7
+        # Profit = 1000 (X3 = 0.1) -> 0.33
+        # Z = 1.2 + 0.7 + 0.33 = 2.23 > 1.81 (Threshold)
+        self.finance.retained_earnings = 5000.0
+        self.finance.profit_history = [1000.0, 1000.0]
         self.has_bailout_loan = False
+
+    def get_inventory_value(self):
+        return 0.0
+
     def deposit(self, amount): self.cash_reserve += amount
     def withdraw(self, amount):
         if self.cash_reserve < amount:
@@ -108,7 +121,13 @@ def test_evaluate_solvency_established_pass(finance_system, mock_firm):
     assert finance_system.evaluate_solvency(mock_firm, 100) is True
 
 def test_evaluate_solvency_established_fail(finance_system, mock_firm):
-    mock_firm.finance.calculate_altman_z_score.return_value = 1.5
+    # Set values to produce a low Z-Score
+    # WC = 10000 (X1=1.0) -> 1.2
+    # RE = 0 (X2=0) -> 0
+    # Profit = 0 (X3=0) -> 0
+    # Z = 1.2 < 1.81
+    mock_firm.finance.retained_earnings = 0.0
+    mock_firm.finance.profit_history = []
     assert finance_system.evaluate_solvency(mock_firm, 100) is False
 
 def test_issue_treasury_bonds_market(finance_system, mock_government, mock_bank):
