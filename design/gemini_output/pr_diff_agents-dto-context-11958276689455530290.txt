diff --git a/config.py b/config.py
index bc2dcc0..dee4ab5 100644
--- a/config.py
+++ b/config.py
@@ -801,3 +801,9 @@ ALTMAN_Z_SCORE_THRESHOLD = 1.81
 INVISIBLE_HAND_SENSITIVITY = 0.1
 CAPITAL_TO_OUTPUT_RATIO = 2.0
 FIRM_SAFETY_MARGIN = 2000.0
+
+# --- Added for DTO Parity (WO-135.2) ---
+CAPITAL_DEPRECIATION_RATE = 0.05
+INITIAL_FIRM_LIQUIDITY_NEED = 200.0
+BANKRUPTCY_CONSECUTIVE_LOSS_THRESHOLD = 20
+HOUSING_EXPECTATION_CAP = 0.05
diff --git a/main.py b/main.py
index eb75f1f..4d45731 100644
--- a/main.py
+++ b/main.py
@@ -9,6 +9,8 @@ from utils.logging_manager import (
 import config
 from pathlib import Path
 from modules.common.config_manager.impl import ConfigManagerImpl
+from simulation.utils.config_factory import create_config_dto
+from simulation.dtos.config_dtos import HouseholdConfigDTO, FirmConfigDTO
 from simulation.core_agents import Household, Talent
 from simulation.firms import Firm
 from simulation.ai.firm_ai import FirmAI
@@ -84,6 +86,10 @@ def create_simulation(overrides: Dict[str, Any] = None) -> Simulation:
         if "SIMULATION_ACTIVE_SCENARIO" in overrides:
             config_manager.set_value_for_test("simulation.active_scenario", overrides["SIMULATION_ACTIVE_SCENARIO"])
 
+    # Create Config DTOs
+    hh_config_dto = create_config_dto(config, HouseholdConfigDTO)
+    firm_config_dto = create_config_dto(config, FirmConfigDTO)
+
     state_builder = StateBuilder()
     action_proposal_engine = ActionProposalEngine(config_module=config_manager)
     ai_trainer = AIEngineRegistry(
@@ -204,7 +210,7 @@ def create_simulation(overrides: Dict[str, Any] = None) -> Simulation:
             decision_engine=household_decision_engine,
             value_orientation=value_orientation,
             personality=personality,
-            config_module=config_manager,
+            config_dto=hh_config_dto,
             risk_aversion=risk_aversion,
             logger=main_logger,
         )
@@ -271,7 +277,7 @@ def create_simulation(overrides: Dict[str, Any] = None) -> Simulation:
             productivity_factor=config.FIRM_PRODUCTIVITY_FACTOR,
             decision_engine=firm_decision_engine,
             value_orientation=firm_value_orientation,
-            config_module=config_manager,
+            config_dto=firm_config_dto,
             logger=main_logger,
         )
 
diff --git a/modules/household/api.py b/modules/household/api.py
index adba37a..f1279c5 100644
--- a/modules/household/api.py
+++ b/modules/household/api.py
@@ -1,9 +1,10 @@
 from __future__ import annotations
 from abc import ABC, abstractmethod
-from typing import Any, Dict, List, Optional, Tuple, TYPE_CHECKING
+from typing import Any, Dict, List, Optional, Tuple, TYPE_CHECKING, Union
 
 if TYPE_CHECKING:
     from simulation.dtos import LeisureEffectDTO, ConsumptionResult, LaborResult, StressScenarioConfig
+    from simulation.dtos.config_dtos import HouseholdConfigDTO
     from simulation.models import Order
     from modules.household.dtos import (
         BioStateDTO, EconStateDTO, SocialStateDTO,
@@ -14,12 +15,12 @@ class IBioComponent(ABC):
     """Interface for stateless Biological Component."""
 
     @abstractmethod
-    def age_one_tick(self, state: BioStateDTO, config: Any, current_tick: int) -> BioStateDTO:
+    def age_one_tick(self, state: BioStateDTO, config: HouseholdConfigDTO, current_tick: int) -> BioStateDTO:
         """Ages the agent and checks for natural death."""
         pass
 
     @abstractmethod
-    def create_offspring_demographics(self, state: BioStateDTO, new_id: int, current_tick: int, config: Any) -> Dict[str, Any]:
+    def create_offspring_demographics(self, state: BioStateDTO, new_id: int, current_tick: int, config: HouseholdConfigDTO) -> Dict[str, Any]:
         """Creates demographic data for a new agent (mitosis)."""
         pass
 
@@ -35,7 +36,7 @@ class IEconComponent(ABC):
         quantity: float,
         current_time: int,
         goods_info: Dict[str, Any],
-        config: Any
+        config: HouseholdConfigDTO
     ) -> Tuple[EconStateDTO, Dict[str, float], ConsumptionResult]:
         """
         Consumes an item.
@@ -50,7 +51,7 @@ class IEconComponent(ABC):
         needs: Dict[str, float],
         current_time: int,
         goods_info_map: Dict[str, Any],
-        config: Any
+        config: HouseholdConfigDTO
     ) -> Tuple[EconStateDTO, Dict[str, float], Dict[str, float]]:
         """
         Decides what to consume from inventory based on needs and executes consumption.
@@ -63,13 +64,13 @@ class IEconComponent(ABC):
         self,
         state: EconStateDTO,
         hours: float,
-        config: Any
+        config: HouseholdConfigDTO
     ) -> Tuple[EconStateDTO, LaborResult]:
         """Executes work logic (non-financial)."""
         pass
 
     @abstractmethod
-    def update_skills(self, state: EconStateDTO, config: Any) -> EconStateDTO:
+    def update_skills(self, state: EconStateDTO, config: HouseholdConfigDTO) -> EconStateDTO:
         """Updates labor skills based on experience."""
         pass
 
@@ -80,7 +81,7 @@ class IEconComponent(ABC):
         context: EconContextDTO,
         orders: List[Order],
         stress_scenario_config: Optional[StressScenarioConfig] = None,
-        config: Any = None
+        config: Optional[HouseholdConfigDTO] = None
     ) -> Tuple[EconStateDTO, List[Order]]:
         """Refines orders and updates internal economic state (e.g. shadow wages)."""
         pass
@@ -92,7 +93,7 @@ class IEconComponent(ABC):
         market_data: Dict[str, Any],
         goods_info_map: Dict[str, Any],
         stress_scenario_config: Optional[StressScenarioConfig],
-        config: Any
+        config: HouseholdConfigDTO
     ) -> EconStateDTO:
         """Updates inflation expectations and price memory."""
         pass
@@ -102,7 +103,7 @@ class IEconComponent(ABC):
         self,
         parent_state: EconStateDTO,
         parent_skills: Dict[str, Any],
-        config: Any
+        config: HouseholdConfigDTO
     ) -> Dict[str, Any]:
         """
         Prepares initial economic state for a clone (inheritance logic).
@@ -119,7 +120,7 @@ class ISocialComponent(ABC):
         state: SocialStateDTO,
         assets: float,
         luxury_inventory: Dict[str, float],
-        config: Any
+        config: HouseholdConfigDTO
     ) -> SocialStateDTO:
         """Calculates social status."""
         pass
@@ -141,7 +142,7 @@ class ISocialComponent(ABC):
         children_count: int,
         leisure_hours: float,
         consumed_items: Dict[str, float],
-        config: Any
+        config: HouseholdConfigDTO
     ) -> Tuple[SocialStateDTO, float, LeisureEffectDTO]:
         """
         Applies leisure effects.
@@ -157,7 +158,7 @@ class ISocialComponent(ABC):
         assets: float,
         durable_assets: List[Dict[str, Any]],
         goods_info_map: Dict[str, Any],
-        config: Any,
+        config: HouseholdConfigDTO,
         current_tick: int,
         market_data: Optional[Dict[str, Any]]
     ) -> Tuple[SocialStateDTO, Dict[str, float], List[Dict[str, Any]], bool]:
diff --git a/modules/household/bio_component.py b/modules/household/bio_component.py
index 63e1fbf..5666484 100644
--- a/modules/household/bio_component.py
+++ b/modules/household/bio_component.py
@@ -7,7 +7,7 @@ from modules.household.api import IBioComponent
 from modules.household.dtos import BioStateDTO
 
 if TYPE_CHECKING:
-    pass
+    from simulation.dtos.config_dtos import HouseholdConfigDTO
 
 logger = logging.getLogger(__name__)
 
@@ -17,15 +17,14 @@ class BioComponent(IBioComponent):
     Operates on BioStateDTO.
     """
 
-    def age_one_tick(self, state: BioStateDTO, config: Any, current_tick: int) -> BioStateDTO:
+    def age_one_tick(self, state: BioStateDTO, config: HouseholdConfigDTO, current_tick: int) -> BioStateDTO:
         """
         Ages the agent and checks for natural death.
         Returns a new (or modified copy) BioStateDTO.
         """
         new_state = state.copy()
 
-        ticks_per_year = getattr(config, "TICKS_PER_YEAR", 100)
-        # Assuming config might be an object or module
+        ticks_per_year = config.ticks_per_year
 
         new_state.age += 1.0 / ticks_per_year
 
@@ -51,7 +50,7 @@ class BioComponent(IBioComponent):
 
         return new_state
 
-    def create_offspring_demographics(self, state: BioStateDTO, new_id: int, current_tick: int, config: Any) -> Dict[str, Any]:
+    def create_offspring_demographics(self, state: BioStateDTO, new_id: int, current_tick: int, config: HouseholdConfigDTO) -> Dict[str, Any]:
         """
         Creates demographic data for a new agent (mitosis).
         Logic migrated from DemographicsComponent.
diff --git a/modules/household/econ_component.py b/modules/household/econ_component.py
index 1906209..65c9c26 100644
--- a/modules/household/econ_component.py
+++ b/modules/household/econ_component.py
@@ -13,7 +13,7 @@ from simulation.utils.shadow_logger import log_shadow
 from simulation.ai.household_system2 import HousingDecisionInputs
 
 if TYPE_CHECKING:
-    pass
+    from simulation.dtos.config_dtos import HouseholdConfigDTO
 
 logger = logging.getLogger(__name__)
 
@@ -23,15 +23,15 @@ class EconComponent(IEconComponent):
     Operates on EconStateDTO.
     """
 
-    def update_wage_dynamics(self, state: EconStateDTO, config: Any, is_employed: bool) -> EconStateDTO:
+    def update_wage_dynamics(self, state: EconStateDTO, config: HouseholdConfigDTO, is_employed: bool) -> EconStateDTO:
         new_state = state.copy()
 
         if is_employed:
-            recovery_rate = getattr(config, "WAGE_RECOVERY_RATE", 0.01)
+            recovery_rate = config.wage_recovery_rate
             new_state.wage_modifier = min(1.0, new_state.wage_modifier * (1.0 + recovery_rate))
         else:
-            decay_rate = getattr(config, "WAGE_DECAY_RATE", 0.02)
-            floor_mod = getattr(config, "RESERVATION_WAGE_FLOOR", 0.3)
+            decay_rate = config.wage_decay_rate
+            floor_mod = config.reservation_wage_floor
             new_state.wage_modifier = max(floor_mod, new_state.wage_modifier * (1.0 - decay_rate))
 
         return new_state
@@ -44,7 +44,7 @@ class EconComponent(IEconComponent):
         quantity: float,
         current_time: int,
         goods_info: Dict[str, Any],
-        config: Any
+        config: HouseholdConfigDTO
     ) -> Tuple[EconStateDTO, Dict[str, float], ConsumptionResult]:
         """
         Consumes an item, updating inventory, consumption tracking, and needs.
@@ -76,12 +76,12 @@ class EconComponent(IEconComponent):
 
             # Education XP logic
             if item_id == "education_service":
-                learning_efficiency = getattr(config, "LEARNING_EFFICIENCY", 0.1)
+                learning_efficiency = config.learning_efficiency
                 xp_gain = quantity * learning_efficiency
                 new_state.education_xp += xp_gain
 
             # Consumption Value
-            fallback_price = getattr(config, "DEFAULT_FALLBACK_PRICE", 5.0)
+            fallback_price = config.default_fallback_price
             price = new_state.perceived_avg_prices.get(item_id, fallback_price)
             consumption_value = quantity * price
 
@@ -111,7 +111,7 @@ class EconComponent(IEconComponent):
         needs: Dict[str, float],
         current_time: int,
         goods_info_map: Dict[str, Any],
-        config: Any
+        config: HouseholdConfigDTO
     ) -> Tuple[EconStateDTO, Dict[str, float], Dict[str, float]]:
         """
         Decides what to consume from inventory based on needs and executes consumption.
@@ -145,9 +145,9 @@ class EconComponent(IEconComponent):
                 current_need = final_needs.get(need_key, 0.0)
 
                 # Consumption Threshold
-                threshold = getattr(config, "NEED_MEDIUM_THRESHOLD", 50.0)
+                threshold = config.need_medium_threshold
                 if need_key == "survival":
-                    threshold = getattr(config, "SURVIVAL_NEED_CONSUMPTION_THRESHOLD", 20.0)
+                    threshold = config.survival_need_consumption_threshold
 
                 if current_need > threshold:
                     should_consume = True
@@ -179,7 +179,7 @@ class EconComponent(IEconComponent):
 
         return new_state, final_needs, consumed_items
 
-    def work(self, state: EconStateDTO, hours: float, config: Any) -> Tuple[EconStateDTO, LaborResult]:
+    def work(self, state: EconStateDTO, hours: float, config: HouseholdConfigDTO) -> Tuple[EconStateDTO, LaborResult]:
         """
         Executes work logic (non-financial).
         Logic migrated from LaborManager.work.
@@ -194,7 +194,7 @@ class EconComponent(IEconComponent):
 
         return new_state, LaborResult(hours_worked=hours, income_earned=income)
 
-    def update_skills(self, state: EconStateDTO, config: Any) -> EconStateDTO:
+    def update_skills(self, state: EconStateDTO, config: HouseholdConfigDTO) -> EconStateDTO:
         """
         Updates labor skills based on experience.
         Logic migrated from LaborManager.update_skills.
@@ -215,7 +215,7 @@ class EconComponent(IEconComponent):
         context: EconContextDTO,
         orders: List[Order],
         stress_scenario_config: Optional[StressScenarioConfig] = None,
-        config: Any = None
+        config: Optional[HouseholdConfigDTO] = None
     ) -> Tuple[EconStateDTO, List[Order]]:
         """
         Refines orders and updates internal economic state.
@@ -248,7 +248,7 @@ class EconComponent(IEconComponent):
                 if start_price > 0:
                     price_growth = (end_price - start_price) / start_price
 
-            ticks_per_year = getattr(config, "TICKS_PER_YEAR", 100)
+            ticks_per_year = config.ticks_per_year
 
             income = new_state.current_wage * ticks_per_year if new_state.is_employed else new_state.expected_wage * ticks_per_year
 
@@ -282,7 +282,7 @@ class EconComponent(IEconComponent):
                  U_shelter = inputs.market_rent_monthly
                  Cost_own = (P_initial * 0.01) / 12.0
 
-                 cap = getattr(config, "HOUSING_EXPECTATION_CAP", 0.05)
+                 cap = config.housing_expectation_cap
                  g_annual = min(inputs.price_growth_expectation, cap)
                  P_future = P_initial * ((1.0 + g_annual) ** T_years)
 
@@ -326,7 +326,7 @@ class EconComponent(IEconComponent):
             new_state.shadow_reservation_wage = (new_state.shadow_reservation_wage * 0.95) + (target * 0.05)
         else:
             new_state.shadow_reservation_wage *= (1.0 - 0.02)
-            min_wage = getattr(config, "HOUSEHOLD_MIN_WAGE_DEMAND", 6.0)
+            min_wage = config.household_min_wage_demand
             if new_state.shadow_reservation_wage < min_wage:
                 new_state.shadow_reservation_wage = min_wage
 
@@ -361,7 +361,7 @@ class EconComponent(IEconComponent):
 
         # 4. Panic Selling
         if stress_scenario_config and stress_scenario_config.is_active and stress_scenario_config.scenario_name == 'deflation':
-             threshold = getattr(config, "PANIC_SELLING_ASSET_THRESHOLD", 500.0)
+             threshold = config.panic_selling_asset_threshold
              if new_state.assets < threshold:
                  # Sell stocks
                  for firm_id, share in new_state.portfolio.holdings.items():
@@ -398,7 +398,7 @@ class EconComponent(IEconComponent):
         market_data: Dict[str, Any],
         goods_info_map: Dict[str, Any],
         stress_scenario_config: Optional[StressScenarioConfig],
-        config: Any
+        config: HouseholdConfigDTO
     ) -> EconStateDTO:
         """
         Updates inflation expectations and price memory.
@@ -433,7 +433,7 @@ class EconComponent(IEconComponent):
                 old_perceived_price = new_state.perceived_avg_prices.get(
                     item_id, actual_price
                 )
-                update_factor = getattr(config, "PERCEIVED_PRICE_UPDATE_FACTOR", 0.1)
+                update_factor = config.perceived_price_update_factor
                 new_perceived_price = (
                     update_factor * actual_price
                 ) + (
@@ -448,7 +448,7 @@ class EconComponent(IEconComponent):
         self,
         parent_state: EconStateDTO,
         parent_skills: Dict[str, Any],
-        config: Any
+        config: HouseholdConfigDTO
     ) -> Dict[str, Any]:
         """
         Prepares initial economic state for a clone (inheritance logic).
diff --git a/modules/household/social_component.py b/modules/household/social_component.py
index 03a46ae..95db394 100644
--- a/modules/household/social_component.py
+++ b/modules/household/social_component.py
@@ -8,7 +8,7 @@ from simulation.dtos import LeisureEffectDTO
 from simulation.ai.api import Personality
 
 if TYPE_CHECKING:
-    pass
+    from simulation.dtos.config_dtos import HouseholdConfigDTO
 
 logger = logging.getLogger(__name__)
 
@@ -23,7 +23,7 @@ class SocialComponent(ISocialComponent):
         state: SocialStateDTO,
         assets: float,
         luxury_inventory: Dict[str, float],
-        config: Any
+        config: HouseholdConfigDTO
     ) -> SocialStateDTO:
         """
         Calculates social status based on assets and luxury inventory.
@@ -33,8 +33,8 @@ class SocialComponent(ISocialComponent):
 
         luxury_goods_value = sum(luxury_inventory.values()) # Assuming values are quantities?
 
-        asset_weight = getattr(config, "SOCIAL_STATUS_ASSET_WEIGHT", 0.5)
-        luxury_weight = getattr(config, "SOCIAL_STATUS_LUXURY_WEIGHT", 0.5)
+        asset_weight = config.social_status_asset_weight
+        luxury_weight = config.social_status_luxury_weight
 
         new_state.social_status = (
             assets * asset_weight
@@ -69,7 +69,7 @@ class SocialComponent(ISocialComponent):
         children_count: int,
         leisure_hours: float,
         consumed_items: Dict[str, float],
-        config: Any
+        config: HouseholdConfigDTO
     ) -> Tuple[SocialStateDTO, float, LeisureEffectDTO]:
         """
         Applies leisure effects.
@@ -95,7 +95,7 @@ class SocialComponent(ISocialComponent):
         new_state.last_leisure_type = leisure_type
 
         # Get coefficients
-        leisure_coeffs = getattr(config, "LEISURE_COEFFS", {})
+        leisure_coeffs = config.leisure_coeffs
         coeffs = leisure_coeffs.get(leisure_type, {})
         utility_per_hour = coeffs.get("utility_per_hour", 0.0)
         xp_gain_per_hour = coeffs.get("xp_gain_per_hour", 0.0)
@@ -126,7 +126,7 @@ class SocialComponent(ISocialComponent):
         assets: float,
         durable_assets: List[Dict[str, Any]],
         goods_info_map: Dict[str, Any],
-        config: Any,
+        config: HouseholdConfigDTO,
         current_tick: int,
         market_data: Optional[Dict[str, Any]]
     ) -> Tuple[SocialStateDTO, Dict[str, float], List[Dict[str, Any]], bool]:
@@ -159,7 +159,7 @@ class SocialComponent(ISocialComponent):
                         new_needs[need_type] = max(0.0, new_needs[need_type] - effective_utility)
 
         # 2. Natural Growth based on Personality
-        base_growth = getattr(config, "BASE_DESIRE_GROWTH", 0.1)
+        base_growth = config.base_desire_growth
         new_needs["survival"] = new_needs.get("survival", 0.0) + base_growth
 
         for k in ["asset", "social", "improvement", "quality"]:
@@ -167,20 +167,20 @@ class SocialComponent(ISocialComponent):
             new_needs[k] = new_needs.get(k, 0.0) + (base_growth * weight)
 
         # Cap
-        max_val = getattr(config, "MAX_DESIRE_VALUE", 100.0)
+        max_val = config.max_desire_value
         for k in new_needs:
             new_needs[k] = min(max_val, new_needs[k])
 
         # 3. Check Death Conditions
-        death_threshold = getattr(config, "SURVIVAL_NEED_DEATH_THRESHOLD", 100.0)
+        death_threshold = config.survival_need_death_threshold
         if new_needs["survival"] >= death_threshold:
             new_state.survival_need_high_turns += 1
         else:
             new_state.survival_need_high_turns = 0
 
         # Assets Death Check
-        assets_death_threshold = getattr(config, "ASSETS_DEATH_THRESHOLD", -100.0)
-        turns_threshold = getattr(config, "HOUSEHOLD_DEATH_TURNS_THRESHOLD", 10)
+        assets_death_threshold = config.assets_death_threshold
+        turns_threshold = config.household_death_turns_threshold
 
         if (assets <= assets_death_threshold or
             new_state.survival_need_high_turns >= turns_threshold):
diff --git a/scripts/verify_purity.py b/scripts/verify_purity.py
new file mode 100644
index 0000000..fc0f0c5
--- /dev/null
+++ b/scripts/verify_purity.py
@@ -0,0 +1,79 @@
+import ast
+import os
+import sys
+
+def check_purity(filepath: str, allowed_imports: set = None) -> bool:
+    """
+    Checks if a file adheres to Purity rules:
+    1. No 'import config'
+    2. No 'from config import ...' (unless allowed)
+    """
+    with open(filepath, "r") as f:
+        tree = ast.parse(f.read(), filename=filepath)
+
+    has_error = False
+    for node in ast.walk(tree):
+        if isinstance(node, ast.Import):
+            for alias in node.names:
+                if alias.name == "config":
+                    print(f"ERROR: {filepath} imports 'config' directly.")
+                    has_error = True
+        elif isinstance(node, ast.ImportFrom):
+            if node.module == "config":
+                print(f"ERROR: {filepath} imports from 'config'.")
+                has_error = True
+
+    return not has_error
+
+def check_init_signature(filepath: str, expected_dto_type: str) -> bool:
+    """
+    Checks if __init__ accepts a config_dto of specific type.
+    """
+    with open(filepath, "r") as f:
+        tree = ast.parse(f.read(), filename=filepath)
+
+    for node in ast.walk(tree):
+        if isinstance(node, ast.FunctionDef) and node.name == "__init__":
+            for arg in node.args.args:
+                if arg.annotation:
+                    # Handle Name and Attribute annotation types
+                    type_name = ""
+                    if isinstance(arg.annotation, ast.Name):
+                        type_name = arg.annotation.id
+                    elif isinstance(arg.annotation, ast.Str):
+                        type_name = arg.annotation.s
+
+                    if type_name == expected_dto_type:
+                        return True
+            print(f"ERROR: {filepath} __init__ does not seem to accept {expected_dto_type}.")
+            return False
+    return True # If no __init__ found? Should fail? Assuming Agent has __init__.
+
+def main():
+    agent_files = {
+        "simulation/core_agents.py": "HouseholdConfigDTO",
+        "simulation/firms.py": "FirmConfigDTO"
+    }
+
+    all_passed = True
+    for filepath, dto in agent_files.items():
+        if not os.path.exists(filepath):
+            print(f"Skipping {filepath} (not found)")
+            continue
+
+        print(f"Checking {filepath}...")
+        if not check_purity(filepath):
+            all_passed = False
+
+        if not check_init_signature(filepath, dto):
+            all_passed = False
+
+    if all_passed:
+        print("Purity Check Passed!")
+        sys.exit(0)
+    else:
+        print("Purity Check Failed!")
+        sys.exit(1)
+
+if __name__ == "__main__":
+    main()
diff --git a/simulation/api.py b/simulation/api.py
index 54a45de..3b5b9de 100644
--- a/simulation/api.py
+++ b/simulation/api.py
@@ -27,87 +27,7 @@ from .ai.reward_calculator import RewardCalculator
 
 # --- Configuration DTOs ---
 
-@dataclass
-class HouseholdConfigDTO:
-    """Static configuration values relevant to household decisions."""
-    survival_need_consumption_threshold: float
-    target_food_buffer_quantity: float
-    food_purchase_max_per_tick: float
-    assets_threshold_for_other_actions: float
-    wage_decay_rate: float
-    reservation_wage_floor: float
-    survival_critical_turns: float
-    labor_market_min_wage: float
-    # New from Household.make_decision refactoring
-    household_low_asset_threshold: float
-    household_low_asset_wage: float
-    household_default_wage: float
-
-    # AI Engine requirements
-    market_price_fallback: float
-    need_factor_base: float
-    need_factor_scale: float
-    valuation_modifier_base: float
-    valuation_modifier_range: float
-    household_max_purchase_quantity: float
-    bulk_buy_need_threshold: float
-    bulk_buy_agg_threshold: float
-    bulk_buy_moderate_ratio: float
-    panic_buying_threshold: float
-    hoarding_factor: float
-    deflation_wait_threshold: float
-    delay_factor: float
-    dsr_critical_threshold: float
-    budget_limit_normal_ratio: float
-    budget_limit_urgent_need: float
-    budget_limit_urgent_ratio: float
-    min_purchase_quantity: float
-    job_quit_threshold_base: float
-    job_quit_prob_base: float
-    job_quit_prob_scale: float
-    stock_market_enabled: bool
-    household_min_assets_for_investment: float
-    stock_investment_equity_delta_threshold: float
-    stock_investment_diversification_count: int
-    expected_startup_roi: float
-    startup_cost: float
-    debt_repayment_ratio: float
-    debt_repayment_cap: float
-    debt_liquidity_ratio: float
-    # Added for parity
-    initial_rent_price: float
-    # Added for AI Engine Purity
-    default_mortgage_rate: float
-    # Housing Manager
-    enable_vanity_system: bool
-    mimicry_factor: float
-    maintenance_rate_per_tick: float
-
-@dataclass
-class FirmConfigDTO:
-    """Static configuration values relevant to firm decisions."""
-    firm_min_production_target: float
-    firm_max_production_target: float
-    startup_cost: float
-    seo_trigger_ratio: float
-    seo_max_sell_ratio: float
-    automation_cost_per_pct: float
-    firm_safety_margin: float
-    automation_tax_rate: float
-    altman_z_score_threshold: float
-    dividend_suspension_loss_ticks: int
-    dividend_rate_min: float
-    dividend_rate_max: float
-    labor_alpha: float
-    automation_labor_reduction: float
-    severance_pay_weeks: float
-    labor_market_min_wage: float
-    overstock_threshold: float
-    understock_threshold: float
-    production_adjustment_factor: float
-    max_sell_quantity: float
-    invisible_hand_sensitivity: float
-    capital_to_output_ratio: float
+from .dtos.config_dtos import HouseholdConfigDTO, FirmConfigDTO
 
 # --- Core Data DTOs ---
 
diff --git a/simulation/brands/brand_manager.py b/simulation/brands/brand_manager.py
index 7dd4438..06855ff 100644
--- a/simulation/brands/brand_manager.py
+++ b/simulation/brands/brand_manager.py
@@ -1,13 +1,17 @@
-from typing import Dict, Any, Optional
+from __future__ import annotations
+from typing import Dict, Any, Optional, TYPE_CHECKING
 import math
 import logging
 
+if TYPE_CHECKING:
+    from simulation.dtos.config_dtos import FirmConfigDTO
+
 class BrandManager:
     """
     Manages a firm's intangible assets: Adstock, Brand Awareness, and Perceived Quality.
     Based on Phase 6 Spec.
     """
-    def __init__(self, firm_id: int, config: Any, logger: Optional[logging.Logger] = None):
+    def __init__(self, firm_id: int, config: FirmConfigDTO, logger: Optional[logging.Logger] = None):
         self.firm_id = firm_id
         self.config = config
         self.logger = logger or logging.getLogger(__name__)
@@ -22,8 +26,8 @@ class BrandManager:
         """
         # 1. Adstock Update
         # Decay old adstock, add new spend (converted to adstock units)
-        decay_rate = getattr(self.config, "MARKETING_DECAY_RATE", 0.8)
-        efficiency = getattr(self.config, "MARKETING_EFFICIENCY", 0.01)
+        decay_rate = self.config.marketing_decay_rate
+        efficiency = self.config.marketing_efficiency
         
         # Adstock = (Previous * Decay) + (Spend * Efficiency)
         self.adstock = (self.adstock * decay_rate) + (marketing_spend * efficiency)
@@ -35,7 +39,7 @@ class BrandManager:
 
         # 3. Perceived Quality Update (EMA)
         # Q_perc_t = (Q_actual * alpha) + (Q_perc_t-1 * (1-alpha))
-        alpha = getattr(self.config, "PERCEIVED_QUALITY_ALPHA", 0.2)
+        alpha = self.config.perceived_quality_alpha
         
         # Ensure actual_quality is float
         if actual_quality is None:
diff --git a/simulation/components/finance_department.py b/simulation/components/finance_department.py
index d70c6aa..ed9fdbf 100644
--- a/simulation/components/finance_department.py
+++ b/simulation/components/finance_department.py
@@ -7,6 +7,7 @@ from modules.finance.api import InsufficientFundsError
 
 if TYPE_CHECKING:
     from simulation.firms import Firm
+    from simulation.dtos.config_dtos import FirmConfigDTO
     from simulation.core_agents import Household
     from simulation.agents.government import Government
 
@@ -17,9 +18,9 @@ class FinanceDepartment:
     Manages assets, maintenance fees, corporate taxes, dividend distribution, and tracks financial metrics.
     Centralized Asset Management (WO-103 Phase 1).
     """
-    def __init__(self, firm: Firm, config_module: Any, initial_capital: float = 0.0):
+    def __init__(self, firm: Firm, config: FirmConfigDTO, initial_capital: float = 0.0):
         self.firm = firm
-        self.config_module = config_module
+        self.config = config
 
         # Centralized Assets (WO-103 Phase 1)
         self._cash: float = initial_capital
@@ -37,7 +38,7 @@ class FinanceDepartment:
         self.expenses_this_tick: float = 0.0
 
         # History
-        self.profit_history: deque[float] = deque(maxlen=self.config_module.PROFIT_HISTORY_TICKS)
+        self.profit_history: deque[float] = deque(maxlen=self.config.profit_history_ticks)
         self.last_revenue: float = 0.0
         self.last_marketing_spend: float = 0.0
 
@@ -73,7 +74,7 @@ class FinanceDepartment:
     def generate_holding_cost_transaction(self, government: Government, current_time: int) -> Optional[Transaction]:
         """Generates inventory holding cost transaction."""
         inventory_value = self.get_inventory_value()
-        holding_cost = inventory_value * self.config_module.INVENTORY_HOLDING_COST_RATE
+        holding_cost = inventory_value * self.config.inventory_holding_cost_rate
 
         if holding_cost > 0:
             # We record expense so Profit calc later in tick is correct
@@ -93,7 +94,7 @@ class FinanceDepartment:
 
     def generate_maintenance_transaction(self, government: Government, current_time: int) -> Optional[Transaction]:
         """Generates maintenance fee transaction."""
-        fee = getattr(self.config_module, "FIRM_MAINTENANCE_FEE", 50.0)
+        fee = self.config.firm_maintenance_fee
 
         # Optimistic check
         payment = min(self._cash, fee)
@@ -121,7 +122,7 @@ class FinanceDepartment:
         net_profit = self.revenue_this_turn - self.cost_this_turn
 
         if net_profit > 0:
-            tax_rate = getattr(self.config_module, "CORPORATE_TAX_RATE", 0.2)
+            tax_rate = self.config.corporate_tax_rate
             tax_amount = net_profit * tax_rate
 
             # Optimistic check
@@ -173,7 +174,7 @@ class FinanceDepartment:
 
         # 1. Bailout Repayment
         if getattr(self.firm, 'has_bailout_loan', False) and self.current_profit > 0:
-            repayment_ratio = getattr(self.config_module, "BAILOUT_REPAYMENT_RATIO", 0.5)
+            repayment_ratio = self.config.bailout_repayment_ratio
             repayment = self.current_profit * repayment_ratio
 
             # Optimistic update of debt state (assuming tx succeeds)
@@ -246,7 +247,7 @@ class FinanceDepartment:
         if owner is None:
             return []
 
-        maintenance_fee = getattr(self.config_module, "FIRM_MAINTENANCE_FEE", 0.0)
+        maintenance_fee = self.config.firm_maintenance_fee
 
         # Query HR for wage data
         avg_wage = 0.0
@@ -351,7 +352,7 @@ class FinanceDepartment:
         if len(self.profit_history) > 0:
             avg_profit = sum(self.profit_history) / len(self.profit_history)
 
-        profit_premium = max(0.0, avg_profit) * getattr(self.config_module, "VALUATION_PER_MULTIPLIER", 10.0)
+        profit_premium = max(0.0, avg_profit) * self.config.valuation_per_multiplier
 
         self.firm.valuation = net_assets + profit_premium
         return self.firm.valuation
@@ -362,8 +363,8 @@ class FinanceDepartment:
         for good, qty in self.firm.inventory.items():
              price = self.firm.last_prices.get(good, 0.0)
              if price == 0.0:
-                 if self.config_module and hasattr(self.config_module, 'GOODS'):
-                     price = self.config_module.GOODS.get(good, {}).get('initial_price', 10.0)
+                 if self.config and self.config.goods:
+                     price = self.config.goods.get(good, {}).get('initial_price', 10.0)
                  else:
                      price = 10.0
              total_val += qty * price
diff --git a/simulation/components/hr_department.py b/simulation/components/hr_department.py
index 5086c15..2946a77 100644
--- a/simulation/components/hr_department.py
+++ b/simulation/components/hr_department.py
@@ -29,7 +29,7 @@ class HRDepartment:
 
         # WO-Sociologist: Halo Effect (Credential Premium)
         education_level = getattr(employee, 'education_level', 0)
-        halo_modifier = 1.0 + (education_level * getattr(self.firm.config_module, "HALO_EFFECT", 0.0))
+        halo_modifier = 1.0 + (education_level * self.firm.config.halo_effect)
 
         return base_wage * actual_skill * halo_modifier
 
@@ -60,7 +60,7 @@ class HRDepartment:
                     del self.employee_wages[employee.id]
                 continue
 
-            base_wage = self.employee_wages.get(employee.id, self.firm.config_module.LABOR_MARKET_MIN_WAGE)
+            base_wage = self.employee_wages.get(employee.id, self.firm.config.labor_market_min_wage)
             wage = self.calculate_wage(employee, base_wage)
 
             # Affordability Check (Optimistic)
@@ -116,7 +116,7 @@ class HRDepartment:
         """
         from simulation.models import Transaction
 
-        severance_weeks = getattr(self.firm.config_module, "SEVERANCE_PAY_WEEKS", 4)
+        severance_weeks = self.firm.config.severance_pay_weeks
         severance_pay = wage * severance_weeks
 
         if self.firm.assets >= severance_pay:
diff --git a/simulation/components/production_department.py b/simulation/components/production_department.py
index a3b49c5..11c6199 100644
--- a/simulation/components/production_department.py
+++ b/simulation/components/production_department.py
@@ -5,15 +5,16 @@ import math
 
 if TYPE_CHECKING:
     from simulation.firms import Firm
+    from simulation.dtos.config_dtos import FirmConfigDTO
 
 logger = logging.getLogger(__name__)
 
 class ProductionDepartment:
     """Handles the production logic for a firm."""
 
-    def __init__(self, firm: Firm, config_module: any):
+    def __init__(self, firm: Firm, config: FirmConfigDTO):
         self.firm = firm
-        self.config_module = config_module
+        self.config = config
 
     def produce(self, current_time: int, technology_manager: any = None) -> float:
         """
@@ -28,7 +29,7 @@ class ProductionDepartment:
             log_extra = {"tick": current_time, "agent_id": self.firm.id, "tags": ["production"]}
 
             # 1. 감가상각 처리
-            depreciation_rate = getattr(self.config_module, "CAPITAL_DEPRECIATION_RATE", 0.05)
+            depreciation_rate = self.config.capital_depreciation_rate
             self.firm.capital_stock *= (1.0 - depreciation_rate)
 
             # Phase 21: Automation Decay
@@ -40,14 +41,14 @@ class ProductionDepartment:
             total_labor_skill = self.firm.hr.get_total_labor_skill()
 
             # 3. Cobb-Douglas Parameters
-            base_alpha = getattr(self.config_module, "LABOR_ALPHA", 0.7)
-            automation_reduction = getattr(self.config_module, "AUTOMATION_LABOR_REDUCTION", 0.5)
+            base_alpha = self.config.labor_alpha
+            automation_reduction = self.config.automation_labor_reduction
 
             # Phase 21: Adjusted Alpha
             # alpha_adjusted = base_alpha * (1 - automation_level * 0.5)
             # If Automation = 1.0, Alpha = 0.7 * 0.5 = 0.35 (Capital dependent)
             alpha_raw = base_alpha * (1.0 - (self.firm.automation_level * automation_reduction))
-            alpha_adjusted = max(getattr(self.config_module, "LABOR_ELASTICITY_MIN", 0.3), alpha_raw)
+            alpha_adjusted = max(self.config.labor_elasticity_min, alpha_raw)
             beta_adjusted = 1.0 - alpha_adjusted
 
             # Effective Labor & Capital
@@ -62,7 +63,7 @@ class ProductionDepartment:
             # Phase 15: Quality Calculation
             avg_skill = self.firm.hr.get_avg_skill()
 
-            item_config = self.config_module.GOODS.get(self.firm.specialization, {})
+            item_config = self.config.goods.get(self.firm.specialization, {})
             quality_sensitivity = item_config.get("quality_sensitivity", 0.5)
             actual_quality = self.firm.base_quality + (math.log1p(avg_skill) * quality_sensitivity)
 
@@ -73,7 +74,7 @@ class ProductionDepartment:
             actual_produced = 0.0
             if produced_quantity > 0:
                 # WO-030: Input Constraints Logic
-                input_config = self.config_module.GOODS.get(self.firm.specialization, {}).get("inputs", {})
+                input_config = self.config.goods.get(self.firm.specialization, {}).get("inputs", {})
 
                 if input_config:
                     max_by_inputs = float('inf')
diff --git a/simulation/components/sales_department.py b/simulation/components/sales_department.py
index cf032d1..99c9d3c 100644
--- a/simulation/components/sales_department.py
+++ b/simulation/components/sales_department.py
@@ -3,6 +3,7 @@ from typing import TYPE_CHECKING, Dict, Any
 
 if TYPE_CHECKING:
     from simulation.firms import Firm
+    from simulation.dtos.config_dtos import FirmConfigDTO
     from simulation.markets.order_book_market import OrderBookMarket
 
 from simulation.models import Order
@@ -10,9 +11,9 @@ from simulation.models import Order
 class SalesDepartment:
     """Handles the sales and marketing logic for a firm."""
 
-    def __init__(self, firm: Firm, config_module: any):
+    def __init__(self, firm: Firm, config: FirmConfigDTO):
         self.firm = firm
-        self.config_module = config_module
+        self.config = config
 
     def post_ask(self, item_id: str, price: float, quantity: float, market: OrderBookMarket, current_tick: int) -> Order:
         """
@@ -63,11 +64,11 @@ class SalesDepartment:
         efficiency = delta_revenue / self.firm.finance.last_marketing_spend
 
         # Decision Rules
-        saturation_level = getattr(self.config_module, "BRAND_AWARENESS_SATURATION", 0.9)
-        high_eff_threshold = getattr(self.config_module, "MARKETING_EFFICIENCY_HIGH_THRESHOLD", 1.5)
-        low_eff_threshold = getattr(self.config_module, "MARKETING_EFFICIENCY_LOW_THRESHOLD", 0.8)
-        min_rate = getattr(self.config_module, "MARKETING_BUDGET_RATE_MIN", 0.01)
-        max_rate = getattr(self.config_module, "MARKETING_BUDGET_RATE_MAX", 0.20)
+        saturation_level = self.config.brand_awareness_saturation
+        high_eff_threshold = self.config.marketing_efficiency_high_threshold
+        low_eff_threshold = self.config.marketing_efficiency_low_threshold
+        min_rate = self.config.marketing_budget_rate_min
+        max_rate = self.config.marketing_budget_rate_max
 
         if self.firm.brand_manager.brand_awareness >= saturation_level:
             pass  # Maintain (Saturation)
diff --git a/simulation/core_agents.py b/simulation/core_agents.py
index dde1afb..2a5c687 100644
--- a/simulation/core_agents.py
+++ b/simulation/core_agents.py
@@ -15,7 +15,8 @@ from simulation.ai.api import (
     Aggressiveness,
 )
 from simulation.core_markets import Market
-from simulation.dtos import DecisionContext, LeisureEffectDTO, LeisureType, MacroFinancialContext, HouseholdConfigDTO, ConsumptionResult
+from simulation.dtos import DecisionContext, LeisureEffectDTO, LeisureType, MacroFinancialContext, ConsumptionResult
+from simulation.dtos.config_dtos import HouseholdConfigDTO
 from simulation.portfolio import Portfolio
 
 from simulation.ai.household_ai import HouseholdAI
@@ -54,7 +55,7 @@ class Household(BaseAgent, ILearningAgent):
         decision_engine: BaseDecisionEngine,
         value_orientation: str,
         personality: Personality,
-        config_module: Any,
+        config_dto: HouseholdConfigDTO,
         loan_market: Optional[LoanMarket] = None,
         risk_aversion: float = 1.0,
         logger: Optional[Logger] = None,
@@ -66,10 +67,10 @@ class Household(BaseAgent, ILearningAgent):
         initial_assets_record: Optional[float] = None,  # WO-124: Explicit record of intended assets
         **kwargs,
     ) -> None:
-        self.config_module = config_module
+        self.config = config_dto
 
         # --- Value Orientation (3 Pillars) ---
-        mapping = getattr(config_module, "VALUE_ORIENTATION_MAPPING", {})
+        mapping = self.config.value_orientation_mapping
         prefs = mapping.get(
             value_orientation,
             {"preference_asset": 1.0, "preference_social": 1.0, "preference_growth": 1.0}
@@ -100,13 +101,9 @@ class Household(BaseAgent, ILearningAgent):
         )
 
         # Econ State
-        # WO-095: Robust config access
-        raw_price_len = getattr(self.config_module, "PRICE_MEMORY_LENGTH", 10)
-        price_memory_len = int(raw_price_len) if isinstance(raw_price_len, (int, float)) else 10
-        raw_wage_len = getattr(self.config_module, "WAGE_MEMORY_LENGTH", 30)
-        wage_memory_len = int(raw_wage_len) if isinstance(raw_wage_len, (int, float)) else 30
-        raw_ticks = getattr(config_module, "TICKS_PER_YEAR", 100)
-        ticks_per_year = int(raw_ticks) if isinstance(raw_ticks, (int, float)) else 100
+        price_memory_len = int(self.config.price_memory_length)
+        wage_memory_len = int(self.config.wage_memory_length)
+        ticks_per_year = int(self.config.ticks_per_year)
 
         # Initial Perceived Prices
         perceived_prices = {}
@@ -114,11 +111,11 @@ class Household(BaseAgent, ILearningAgent):
              perceived_prices[g["id"]] = g.get("initial_price", 10.0)
 
         # Adaptation Rate
-        adaptation_rate = getattr(self.config_module, "ADAPTATION_RATE_NORMAL", 0.2)
+        adaptation_rate = self.config.adaptation_rate_normal
         if personality == Personality.IMPULSIVE:
-             adaptation_rate = getattr(self.config_module, "ADAPTATION_RATE_IMPULSIVE", 0.5)
+             adaptation_rate = self.config.adaptation_rate_impulsive
         elif personality == Personality.CONSERVATIVE:
-             adaptation_rate = getattr(self.config_module, "ADAPTATION_RATE_CONSERVATIVE", 0.1)
+             adaptation_rate = self.config.adaptation_rate_conservative
 
         # WO-054: Aptitude
         raw_aptitude = random.gauss(0.5, 0.15)
@@ -166,24 +163,24 @@ class Household(BaseAgent, ILearningAgent):
 
         # Social State
         # Conformity
-        conformity_ranges = getattr(config_module, "CONFORMITY_RANGES", {})
+        conformity_ranges = self.config.conformity_ranges
         c_min, c_max = conformity_ranges.get(personality.name, conformity_ranges.get(None, (0.3, 0.7)))
         conformity = random.uniform(c_min, c_max)
 
         # Quality Preference
-        mean_assets = getattr(config_module, "INITIAL_HOUSEHOLD_ASSETS_MEAN", 1000.0)
+        mean_assets = self.config.initial_household_assets_mean
         is_wealthy = initial_assets > mean_assets * 1.5
         is_poor = initial_assets < mean_assets * 0.5
 
         if personality == Personality.STATUS_SEEKER or is_wealthy:
-            min_pref = getattr(config_module, "QUALITY_PREF_SNOB_MIN", 0.7)
+            min_pref = self.config.quality_pref_snob_min
             q_pref = random.uniform(min_pref, 1.0)
         elif personality == Personality.MISER or is_poor:
-            max_pref = getattr(config_module, "QUALITY_PREF_MISER_MAX", 0.3)
+            max_pref = self.config.quality_pref_miser_max
             q_pref = random.uniform(0.0, max_pref)
         else:
-            min_snob = getattr(config_module, "QUALITY_PREF_SNOB_MIN", 0.7)
-            max_miser = getattr(config_module, "QUALITY_PREF_MISER_MAX", 0.3)
+            min_snob = self.config.quality_pref_snob_min
+            max_miser = self.config.quality_pref_miser_max
             q_pref = random.uniform(max_miser, min_snob)
 
         self._social_state = SocialStateDTO(
@@ -664,68 +661,20 @@ class Household(BaseAgent, ILearningAgent):
             self._social_state,
             self._econ_state.assets,
             self._econ_state.inventory,
-            self.config_module
+            self.config
         )
 
         # WO-103: Purity Guard - Update Wage Dynamics
         self._econ_state = self.econ_component.update_wage_dynamics(
-            self._econ_state, self.config_module, self._econ_state.is_employed
+            self._econ_state, self.config, self._econ_state.is_employed
         )
 
         # 1. Prepare DTOs
         state_dto = self.create_state_dto()
         
         # WO-103: Purity Guard - Prepare Config DTO
-        config_dto = HouseholdConfigDTO(
-            survival_need_consumption_threshold=self.config_module.SURVIVAL_NEED_CONSUMPTION_THRESHOLD,
-            target_food_buffer_quantity=getattr(self.config_module, "TARGET_FOOD_BUFFER_QUANTITY", 5.0),
-            food_purchase_max_per_tick=self.config_module.FOOD_PURCHASE_MAX_PER_TICK,
-            assets_threshold_for_other_actions=self.config_module.ASSETS_THRESHOLD_FOR_OTHER_ACTIONS,
-            wage_decay_rate=getattr(self.config_module, "WAGE_DECAY_RATE", 0.02),
-            reservation_wage_floor=getattr(self.config_module, "RESERVATION_WAGE_FLOOR", 0.3),
-            survival_critical_turns=getattr(self.config_module, "SURVIVAL_CRITICAL_TURNS", 5),
-            labor_market_min_wage=self.config_module.LABOR_MARKET_MIN_WAGE,
-            household_low_asset_threshold=self.config_module.HOUSEHOLD_LOW_ASSET_THRESHOLD,
-            household_low_asset_wage=self.config_module.HOUSEHOLD_LOW_ASSET_WAGE,
-            household_default_wage=self.config_module.HOUSEHOLD_DEFAULT_WAGE,
-            
-            # AI Engine requirements
-            market_price_fallback=self.config_module.MARKET_PRICE_FALLBACK,
-            need_factor_base=self.config_module.NEED_FACTOR_BASE,
-            need_factor_scale=self.config_module.NEED_FACTOR_SCALE,
-            valuation_modifier_base=self.config_module.VALUATION_MODIFIER_BASE,
-            valuation_modifier_range=self.config_module.VALUATION_MODIFIER_RANGE,
-            household_max_purchase_quantity=self.config_module.HOUSEHOLD_MAX_PURCHASE_QUANTITY,
-            bulk_buy_need_threshold=self.config_module.BULK_BUY_NEED_THRESHOLD,
-            bulk_buy_agg_threshold=self.config_module.BULK_BUY_AGG_THRESHOLD,
-            bulk_buy_moderate_ratio=self.config_module.BULK_BUY_MODERATE_RATIO,
-            panic_buying_threshold=getattr(self.config_module, "PANIC_BUYING_THRESHOLD", 0.05),
-            hoarding_factor=getattr(self.config_module, "HOARDING_FACTOR", 0.5),
-            deflation_wait_threshold=getattr(self.config_module, "DEFLATION_WAIT_THRESHOLD", -0.05),
-            delay_factor=getattr(self.config_module, "DELAY_FACTOR", 0.5),
-            dsr_critical_threshold=self.config_module.DSR_CRITICAL_THRESHOLD,
-            budget_limit_normal_ratio=self.config_module.BUDGET_LIMIT_NORMAL_RATIO,
-            budget_limit_urgent_need=self.config_module.BUDGET_LIMIT_URGENT_NEED,
-            budget_limit_urgent_ratio=self.config_module.BUDGET_LIMIT_URGENT_RATIO,
-            min_purchase_quantity=self.config_module.MIN_PURCHASE_QUANTITY,
-            job_quit_threshold_base=self.config_module.JOB_QUIT_THRESHOLD_BASE,
-            job_quit_prob_base=self.config_module.JOB_QUIT_PROB_BASE,
-            job_quit_prob_scale=self.config_module.JOB_QUIT_PROB_SCALE,
-            stock_market_enabled=getattr(self.config_module, "STOCK_MARKET_ENABLED", False),
-            household_min_assets_for_investment=self.config_module.HOUSEHOLD_MIN_ASSETS_FOR_INVESTMENT,
-            stock_investment_equity_delta_threshold=self.config_module.STOCK_INVESTMENT_EQUITY_DELTA_THRESHOLD,
-            stock_investment_diversification_count=self.config_module.STOCK_INVESTMENT_DIVERSIFICATION_COUNT,
-            expected_startup_roi=getattr(self.config_module, "EXPECTED_STARTUP_ROI", 0.15),
-            startup_cost=getattr(self.config_module, "STARTUP_COST", 30000.0),
-            debt_repayment_ratio=self.config_module.DEBT_REPAYMENT_RATIO,
-            debt_repayment_cap=self.config_module.DEBT_REPAYMENT_CAP,
-            debt_liquidity_ratio=self.config_module.DEBT_LIQUIDITY_RATIO,
-            initial_rent_price=self.config_module.INITIAL_RENT_PRICE,
-            default_mortgage_rate=getattr(self.config_module, "DEFAULT_MORTGAGE_RATE", 0.05),
-            enable_vanity_system=getattr(self.config_module, "ENABLE_VANITY_SYSTEM", False),
-            mimicry_factor=getattr(self.config_module, "MIMICRY_FACTOR", 0.5),
-            maintenance_rate_per_tick=self.config_module.MAINTENANCE_RATE_PER_TICK
-        )
+        # self.config is already the DTO.
+        config_dto = self.config
 
         context = DecisionContext(
             state=state_dto,
@@ -742,7 +691,7 @@ class Household(BaseAgent, ILearningAgent):
 
         econ_context = EconContextDTO(markets, market_data, current_time)
         self._econ_state, refined_orders = self.econ_component.orchestrate_economic_decisions(
-            self._econ_state, econ_context, orders, stress_scenario_config, self.config_module
+            self._econ_state, econ_context, orders, stress_scenario_config, self.config
         )
 
         return refined_orders, chosen_tactic_tuple
@@ -771,7 +720,7 @@ class Household(BaseAgent, ILearningAgent):
             self._bio_state.needs,
             current_time,
             self.goods_info_map,
-            self.config_module
+            self.config
         )
         self._bio_state.needs = new_needs
         self.update_needs(current_time, market_data)
@@ -786,7 +735,7 @@ class Household(BaseAgent, ILearningAgent):
             quantity,
             current_time,
             self.goods_info_map.get(item_id, {}),
-            self.config_module
+            self.config
         )
         self._bio_state.needs = new_needs
         return result
@@ -803,7 +752,7 @@ class Household(BaseAgent, ILearningAgent):
         # 1. Work (Econ)
         if self._econ_state.is_employed:
             self._econ_state, labor_res = self.econ_component.work(
-                self._econ_state, 8.0, self.config_module
+                self._econ_state, 8.0, self.config
             )
             # We could log labor_res if needed
 
@@ -814,7 +763,7 @@ class Household(BaseAgent, ILearningAgent):
             self._econ_state.assets,
             self._econ_state.durable_assets,
             self.goods_info_map,
-            self.config_module,
+            self.config,
             current_tick,
             market_data
         )
@@ -829,11 +778,11 @@ class Household(BaseAgent, ILearningAgent):
 
         # 4. Aging (Bio) - Also checks natural death
         self._bio_state = self.bio_component.age_one_tick(
-            self._bio_state, self.config_module, current_tick
+            self._bio_state, self.config, current_tick
         )
 
         # 5. Skill Updates
-        self._econ_state = self.econ_component.update_skills(self._econ_state, self.config_module)
+        self._econ_state = self.econ_component.update_skills(self._econ_state, self.config)
 
     def apply_leisure_effect(self, leisure_hours: float, consumed_items: Dict[str, float]) -> LeisureEffectDTO:
         self._social_state, self._econ_state.labor_skill, result = self.social_component.apply_leisure_effect(
@@ -842,14 +791,14 @@ class Household(BaseAgent, ILearningAgent):
             len(self._bio_state.children_ids),
             leisure_hours,
             consumed_items,
-            self.config_module
+            self.config
         )
         return result
 
     @override
     def update_perceived_prices(self, market_data: Dict[str, Any], stress_scenario_config: Optional["StressScenarioConfig"] = None) -> None:
         self._econ_state = self.econ_component.update_perceived_prices(
-            self._econ_state, market_data, self.goods_info_map, stress_scenario_config, self.config_module
+            self._econ_state, market_data, self.goods_info_map, stress_scenario_config, self.config
         )
 
     @override
@@ -859,13 +808,13 @@ class Household(BaseAgent, ILearningAgent):
         """
         # 1. Bio Cloning (Demographics)
         offspring_demo = self.bio_component.create_offspring_demographics(
-            self._bio_state, new_id, current_tick, self.config_module
+            self._bio_state, new_id, current_tick, self.config
         )
 
         # 2. Econ Cloning (Inheritance)
         # We need parent skills.
         econ_inheritance = self.econ_component.prepare_clone_state(
-            self._econ_state, self.skills, self.config_module
+            self._econ_state, self.skills, self.config
         )
 
         # 3. Create Decision Engine
@@ -885,7 +834,7 @@ class Household(BaseAgent, ILearningAgent):
             decision_engine=new_decision_engine,
             value_orientation=self.value_orientation,
             personality=self.personality, # Inherit personality
-            config_module=self.config_module,
+            config_dto=self.config,
             loan_market=self.decision_engine.loan_market,
             risk_aversion=self.risk_aversion,
             logger=None,
@@ -919,7 +868,7 @@ class Household(BaseAgent, ILearningAgent):
         )
         return AIDrivenHouseholdDecisionEngine(
             ai_engine=new_ai_engine,
-            config_module=self.config_module,
+            config_module=self.config,
             logger=self.logger
         )
 
@@ -950,9 +899,9 @@ class Household(BaseAgent, ILearningAgent):
         self._econ_state.labor_income_this_tick += income
 
     def get_desired_wage(self) -> float:
-        if self.assets < self.config_module.HOUSEHOLD_LOW_ASSET_THRESHOLD:
-            return self.config_module.HOUSEHOLD_LOW_ASSET_WAGE
-        return self.config_module.HOUSEHOLD_DEFAULT_WAGE
+        if self.assets < self.config.household_low_asset_threshold:
+            return self.config.household_low_asset_wage
+        return self.config.household_default_wage
 
     def initialize_demographics(
         self,
diff --git a/simulation/dtos/__init__.py b/simulation/dtos/__init__.py
index b6c0258..764bd5b 100644
--- a/simulation/dtos/__init__.py
+++ b/simulation/dtos/__init__.py
@@ -1,2 +1,3 @@
 from .api import *
 from .scenario import StressScenarioConfig
+from .config_dtos import HouseholdConfigDTO, FirmConfigDTO
diff --git a/simulation/dtos/api.py b/simulation/dtos/api.py
index e017978..2e877d5 100644
--- a/simulation/dtos/api.py
+++ b/simulation/dtos/api.py
@@ -9,6 +9,7 @@ if TYPE_CHECKING:
     from simulation.firms import Firm
     from simulation.dtos.scenario import StressScenarioConfig
     from modules.household.dtos import HouseholdStateDTO
+    from simulation.dtos.config_dtos import HouseholdConfigDTO, FirmConfigDTO
 
 @dataclass
 class TransactionData:
@@ -115,13 +116,15 @@ class MarketHistoryDTO(TypedDict, total=False):
     worst_ask: float
     worst_bid: float
 
-class OrderDTO(TypedDict):
+@dataclass
+class OrderDTO:
     agent_id: int
     item_id: str
     quantity: float
     price: float
 
-class MarketSnapshotDTO(TypedDict):
+@dataclass
+class MarketSnapshotDTO:
     """A pure-data snapshot of the state of all markets at a point in time."""
     prices: Dict[str, float]
     volumes: Dict[str, float]
@@ -136,88 +139,6 @@ class GovernmentPolicyDTO:
     corporate_tax_rate: float
     base_interest_rate: float
 
-@dataclass
-class HouseholdConfigDTO:
-    """Static configuration values relevant to household decisions."""
-    survival_need_consumption_threshold: float
-    target_food_buffer_quantity: float
-    food_purchase_max_per_tick: float
-    assets_threshold_for_other_actions: float
-    wage_decay_rate: float
-    reservation_wage_floor: float
-    survival_critical_turns: float
-    labor_market_min_wage: float
-    # New from Household.make_decision refactoring
-    household_low_asset_threshold: float
-    household_low_asset_wage: float
-    household_default_wage: float
-    
-    # AI Engine requirements
-    market_price_fallback: float
-    need_factor_base: float
-    need_factor_scale: float
-    valuation_modifier_base: float
-    valuation_modifier_range: float
-    household_max_purchase_quantity: float
-    bulk_buy_need_threshold: float
-    bulk_buy_agg_threshold: float
-    bulk_buy_moderate_ratio: float
-    panic_buying_threshold: float
-    hoarding_factor: float
-    deflation_wait_threshold: float
-    delay_factor: float
-    dsr_critical_threshold: float
-    budget_limit_normal_ratio: float
-    budget_limit_urgent_need: float
-    budget_limit_urgent_ratio: float
-    min_purchase_quantity: float
-    job_quit_threshold_base: float
-    job_quit_prob_base: float
-    job_quit_prob_scale: float
-    stock_market_enabled: bool
-    household_min_assets_for_investment: float
-    stock_investment_equity_delta_threshold: float
-    stock_investment_diversification_count: int
-    expected_startup_roi: float
-    startup_cost: float
-    debt_repayment_ratio: float
-    debt_repayment_cap: float
-    debt_liquidity_ratio: float
-    # Added for parity
-    initial_rent_price: float
-    # Added for AI Engine Purity
-    default_mortgage_rate: float
-    # Housing Manager
-    enable_vanity_system: bool
-    mimicry_factor: float
-    maintenance_rate_per_tick: float
-
-@dataclass
-class FirmConfigDTO:
-    """Static configuration values relevant to firm decisions."""
-    firm_min_production_target: float
-    firm_max_production_target: float
-    startup_cost: float
-    seo_trigger_ratio: float
-    seo_max_sell_ratio: float
-    automation_cost_per_pct: float
-    firm_safety_margin: float
-    automation_tax_rate: float
-    altman_z_score_threshold: float
-    dividend_suspension_loss_ticks: int
-    dividend_rate_min: float
-    dividend_rate_max: float
-    labor_alpha: float
-    automation_labor_reduction: float
-    severance_pay_weeks: float
-    labor_market_min_wage: float
-    overstock_threshold: float
-    understock_threshold: float
-    production_adjustment_factor: float
-    max_sell_quantity: float
-    invisible_hand_sensitivity: float
-    capital_to_output_ratio: float
-
 @dataclass
 class DecisionContext:
     """
diff --git a/simulation/dtos/config_dtos.py b/simulation/dtos/config_dtos.py
new file mode 100644
index 0000000..6413811
--- /dev/null
+++ b/simulation/dtos/config_dtos.py
@@ -0,0 +1,139 @@
+from dataclasses import dataclass
+from typing import Dict, Any
+
+@dataclass
+class HouseholdConfigDTO:
+    """Static configuration values relevant to household decisions."""
+    survival_need_consumption_threshold: float
+    target_food_buffer_quantity: float
+    food_purchase_max_per_tick: float
+    assets_threshold_for_other_actions: float
+    wage_decay_rate: float
+    reservation_wage_floor: float
+    survival_critical_turns: float
+    labor_market_min_wage: float
+    # New from Household.make_decision refactoring
+    household_low_asset_threshold: float
+    household_low_asset_wage: float
+    household_default_wage: float
+
+    # AI Engine requirements
+    market_price_fallback: float
+    need_factor_base: float
+    need_factor_scale: float
+    valuation_modifier_base: float
+    valuation_modifier_range: float
+    household_max_purchase_quantity: float
+    bulk_buy_need_threshold: float
+    bulk_buy_agg_threshold: float
+    bulk_buy_moderate_ratio: float
+    panic_buying_threshold: float
+    hoarding_factor: float
+    deflation_wait_threshold: float
+    delay_factor: float
+    dsr_critical_threshold: float
+    budget_limit_normal_ratio: float
+    budget_limit_urgent_need: float
+    budget_limit_urgent_ratio: float
+    min_purchase_quantity: float
+    job_quit_threshold_base: float
+    job_quit_prob_base: float
+    job_quit_prob_scale: float
+    stock_market_enabled: bool
+    household_min_assets_for_investment: float
+    stock_investment_equity_delta_threshold: float
+    stock_investment_diversification_count: int
+    expected_startup_roi: float
+    startup_cost: float
+    debt_repayment_ratio: float
+    debt_repayment_cap: float
+    debt_liquidity_ratio: float
+    # Added for parity
+    initial_rent_price: float
+    # Added for AI Engine Purity
+    default_mortgage_rate: float
+    # Housing Manager
+    enable_vanity_system: bool
+    mimicry_factor: float
+    maintenance_rate_per_tick: float
+
+    # Expanded Fields for DTO Parity
+    value_orientation_mapping: Dict[str, Any]
+    price_memory_length: int
+    wage_memory_length: int
+    ticks_per_year: int
+    adaptation_rate_normal: float
+    adaptation_rate_impulsive: float
+    adaptation_rate_conservative: float
+    conformity_ranges: Dict[str, Any]
+    initial_household_assets_mean: float
+    quality_pref_snob_min: float
+    quality_pref_miser_max: float
+    wage_recovery_rate: float
+    learning_efficiency: float
+    default_fallback_price: float
+    need_medium_threshold: float
+    housing_expectation_cap: float
+    household_min_wage_demand: float
+    panic_selling_asset_threshold: float
+    perceived_price_update_factor: float
+    social_status_asset_weight: float
+    social_status_luxury_weight: float
+    leisure_coeffs: Dict[str, Any]
+    base_desire_growth: float
+    max_desire_value: float
+    survival_need_death_threshold: float
+    assets_death_threshold: float
+    household_death_turns_threshold: float
+    initial_wage: float
+    education_cost_multipliers: Dict[int, float]
+
+@dataclass
+class FirmConfigDTO:
+    """Static configuration values relevant to firm decisions."""
+    firm_min_production_target: float
+    firm_max_production_target: float
+    startup_cost: float
+    seo_trigger_ratio: float
+    seo_max_sell_ratio: float
+    automation_cost_per_pct: float
+    firm_safety_margin: float
+    automation_tax_rate: float
+    altman_z_score_threshold: float
+    dividend_suspension_loss_ticks: int
+    dividend_rate: float
+    dividend_rate_min: float
+    dividend_rate_max: float
+    labor_alpha: float
+    automation_labor_reduction: float
+    severance_pay_weeks: float
+    labor_market_min_wage: float
+    overstock_threshold: float
+    understock_threshold: float
+    production_adjustment_factor: float
+    max_sell_quantity: float
+    invisible_hand_sensitivity: float
+    capital_to_output_ratio: float
+
+    # Expanded Fields for DTO Parity
+    initial_firm_liquidity_need: float
+    bankruptcy_consecutive_loss_threshold: int
+    profit_history_ticks: int
+    ipo_initial_shares: float
+    inventory_holding_cost_rate: float
+    firm_maintenance_fee: float
+    corporate_tax_rate: float
+    bailout_repayment_ratio: float
+    valuation_per_multiplier: float
+    capital_depreciation_rate: float
+    labor_elasticity_min: float
+    goods: Dict[str, Any]
+    halo_effect: float
+    marketing_decay_rate: float
+    marketing_efficiency: float
+    perceived_quality_alpha: float
+    brand_awareness_saturation: float
+    marketing_efficiency_high_threshold: float
+    marketing_efficiency_low_threshold: float
+    marketing_budget_rate_min: float
+    marketing_budget_rate_max: float
diff --git a/simulation/firms.py b/simulation/firms.py
index 87e8644..dd51e07 100644
--- a/simulation/firms.py
+++ b/simulation/firms.py
@@ -11,7 +11,8 @@ from simulation.core_agents import Household
 from simulation.markets.order_book_market import OrderBookMarket
 from simulation.base_agent import BaseAgent
 from simulation.decisions.base_decision_engine import BaseDecisionEngine
-from simulation.dtos import DecisionContext, FirmConfigDTO
+from simulation.dtos import DecisionContext
+from simulation.dtos.config_dtos import FirmConfigDTO
 from simulation.dtos.firm_state_dto import FirmStateDTO
 from simulation.ai.enums import Personality
 
@@ -46,7 +47,7 @@ class Firm(BaseAgent, ILearningAgent):
         productivity_factor: float,
         decision_engine: BaseDecisionEngine,
         value_orientation: str,
-        config_module: Any,
+        config_dto: FirmConfigDTO,
         initial_inventory: Optional[Dict[str, float]] = None,
         loan_market: Optional[LoanMarket] = None,
         logger: Optional[logging.Logger] = None,
@@ -69,7 +70,7 @@ class Firm(BaseAgent, ILearningAgent):
             logger=logger,
         )
         self.settlement_system: Optional["ISettlementSystem"] = None
-        self.config_module = config_module  # Store config_module
+        self.config = config_dto
         if initial_inventory is not None:
             self.inventory.update(initial_inventory)
         self.specialization = specialization
@@ -94,25 +95,25 @@ class Firm(BaseAgent, ILearningAgent):
         self.hr = HRDepartment(self)
         # WO-103 Phase 1: Initialize Finance with buffered assets
         # Fix: Use initial_capital passed to constructor, or self._assets from BaseAgent
-        self.finance = FinanceDepartment(self, config_module, initial_capital=initial_capital)
+        self.finance = FinanceDepartment(self, self.config, initial_capital=initial_capital)
 
-        self.production = ProductionDepartment(self, config_module)
-        self.sales = SalesDepartment(self, config_module)
+        self.production = ProductionDepartment(self, self.config)
+        self.sales = SalesDepartment(self, self.config)
 
         # Set bankruptcy threshold based on visionary status
-        base_threshold = getattr(config_module, "BANKRUPTCY_CONSECUTIVE_LOSS_THRESHOLD", 5)
+        base_threshold = self.config.bankruptcy_consecutive_loss_threshold
         if self.is_visionary:
             self.consecutive_loss_ticks_for_bankruptcy_threshold = base_threshold * 2
         else:
              self.consecutive_loss_ticks_for_bankruptcy_threshold = base_threshold
 
         self.production_target: float = (
-            config_module.FIRM_MIN_PRODUCTION_TARGET
+            self.config.firm_min_production_target
         )  # Initialize production target
 
         self.current_production: float = 0.0
         self.productivity_factor: float = productivity_factor
-        self.total_shares: float = getattr(config_module, "IPO_INITIAL_SHARES", 1000.0)
+        self.total_shares: float = self.config.ipo_initial_shares
         self.last_prices: Dict[str, float] = {}
         self.hires_last_tick: int = 0 # Handled in HR but maybe exposed here?
         
@@ -122,7 +123,7 @@ class Firm(BaseAgent, ILearningAgent):
         self.consecutive_loss_ticks_for_bankruptcy: int = 0 # Track separately strictly for rule
         
         # --- Phase 6: Brand Engine ---
-        self.brand_manager = BrandManager(self.id, config_module, logger)
+        self.brand_manager = BrandManager(self.id, self.config, logger)
         self.marketing_budget: float = 0.0 # Decision variable
         self.prev_awareness: float = 0.0  # For AI Reward Calculation
         # ROI Optimization
@@ -131,9 +132,7 @@ class Firm(BaseAgent, ILearningAgent):
         # --- 주식 시장 관련 속성 ---
         self.founder_id: Optional[int] = None  # 창업자 가계 ID
         self.is_publicly_traded: bool = True   # 상장 여부
-        self.dividend_rate: float = getattr(
-            config_module, "DIVIDEND_RATE", 0.3
-        )  # 기업별 배당률 (기본값: config)
+        self.dividend_rate: float = self.config.dividend_rate  # 기업별 배당률 (기본값: config)
         self.treasury_shares: float = self.total_shares  # 자사주 보유량
         self.capital_stock: float = 100.0   # 실물 자본재 (초기값: 100)
 
@@ -263,12 +262,12 @@ class Firm(BaseAgent, ILearningAgent):
         new_firm = Firm(
             id=new_id,
             initial_capital=initial_assets_from_parent,  # 현재 자산을 초기 자본으로 설정
-            initial_liquidity_need=self.config_module.INITIAL_FIRM_LIQUIDITY_NEED,  # 초기 유동성 필요는 설정값으로 리셋
+            initial_liquidity_need=self.config.initial_firm_liquidity_need,  # 초기 유동성 필요는 설정값으로 리셋
             specialization=self.specialization,
             productivity_factor=self.productivity_factor,
             decision_engine=cloned_decision_engine,
             value_orientation=self.value_orientation,
-            config_module=self.config_module,
+            config_dto=self.config,
             initial_inventory=copy.deepcopy(self.inventory),
             loan_market=self.decision_engine.loan_market,  # loan_market은 공유
             logger=self.logger,
@@ -339,30 +338,9 @@ class Firm(BaseAgent, ILearningAgent):
                 "is_active_before": self.is_active,
             },
         )
-        config_dto = FirmConfigDTO(
-            firm_min_production_target=self.config_module.FIRM_MIN_PRODUCTION_TARGET,
-            firm_max_production_target=getattr(self.config_module, "FIRM_MAX_PRODUCTION_TARGET", 500.0),
-            startup_cost=getattr(self.config_module, "STARTUP_COST", 30000.0),
-            seo_trigger_ratio=getattr(self.config_module, "SEO_TRIGGER_RATIO", 0.5),
-            seo_max_sell_ratio=getattr(self.config_module, "SEO_MAX_SELL_RATIO", 0.10),
-            automation_cost_per_pct=getattr(self.config_module, "AUTOMATION_COST_PER_PCT", 1000.0),
-            firm_safety_margin=getattr(self.config_module, "FIRM_SAFETY_MARGIN", 2000.0),
-            automation_tax_rate=getattr(self.config_module, "AUTOMATION_TAX_RATE", 0.05),
-            altman_z_score_threshold=getattr(self.config_module, "ALTMAN_Z_SCORE_THRESHOLD", 1.81),
-            dividend_suspension_loss_ticks=getattr(self.config_module, "DIVIDEND_SUSPENSION_LOSS_TICKS", 3),
-            dividend_rate_min=getattr(self.config_module, "DIVIDEND_RATE_MIN", 0.1),
-            dividend_rate_max=getattr(self.config_module, "DIVIDEND_RATE_MAX", 0.5),
-            labor_alpha=getattr(self.config_module, "LABOR_ALPHA", 0.7),
-            automation_labor_reduction=getattr(self.config_module, "AUTOMATION_LABOR_REDUCTION", 0.5),
-            severance_pay_weeks=getattr(self.config_module, "SEVERANCE_PAY_WEEKS", 4),
-            labor_market_min_wage=self.config_module.LABOR_MARKET_MIN_WAGE,
-            overstock_threshold=getattr(self.config_module, "OVERSTOCK_THRESHOLD", 1.2),
-            understock_threshold=getattr(self.config_module, "UNDERSTOCK_THRESHOLD", 0.8),
-            production_adjustment_factor=getattr(self.config_module, "PRODUCTION_ADJUSTMENT_FACTOR", 0.1),
-            max_sell_quantity=self.config_module.MAX_SELL_QUANTITY,
-            invisible_hand_sensitivity=getattr(self.config_module, "INVISIBLE_HAND_SENSITIVITY", 0.1),
-            capital_to_output_ratio=getattr(self.config_module, "CAPITAL_TO_OUTPUT_RATIO", 2.0)
-        )
+
+        # Config DTO is already available
+        config_dto = self.config
         state_dto = self.get_state_dto()
 
         context = DecisionContext(
@@ -410,7 +388,7 @@ class Firm(BaseAgent, ILearningAgent):
         elif order.order_type == "INVEST_AUTOMATION":
             spend = order.quantity
             if self.finance.invest_in_automation(spend, government):
-                cost_per_pct = getattr(self.config_module, "AUTOMATION_COST_PER_PCT", 1000.0)
+                cost_per_pct = self.config.automation_cost_per_pct
                 if cost_per_pct > 0:
                     gained_a = (spend / cost_per_pct) / 100.0
                     self.production.set_automation_level(self.automation_level + gained_a)
@@ -430,7 +408,7 @@ class Firm(BaseAgent, ILearningAgent):
         elif order.order_type == "INVEST_CAPEX":
             budget = order.quantity
             if self.finance.invest_in_capex(budget, government):
-                efficiency = 1.0 / getattr(self.config_module, "CAPITAL_TO_OUTPUT_RATIO", 2.0)
+                efficiency = 1.0 / self.config.capital_to_output_ratio
                 added_capital = budget * efficiency
                 self.production.add_capital(added_capital)
                 self.logger.info(f"INTERNAL_EXEC | Firm {self.id} invested {budget:.1f} in CAPEX.")
@@ -503,7 +481,7 @@ class Firm(BaseAgent, ILearningAgent):
 
         # 3. Calculate Candidate Price
         # Sensitivity: Default 0.1 if not configured
-        sensitivity = getattr(self.config_module, "INVISIBLE_HAND_SENSITIVITY", 0.1)
+        sensitivity = self.config.invisible_hand_sensitivity
 
         # Current Price: Use firm's last price or market avg fallback
         current_price = self.last_prices.get(self.specialization, 10.0)
diff --git a/simulation/initialization/initializer.py b/simulation/initialization/initializer.py
index 6c5984a..c6b8609 100644
--- a/simulation/initialization/initializer.py
+++ b/simulation/initialization/initializer.py
@@ -294,8 +294,6 @@ class SimulationInitializer(SimulationInitializerInterface):
             agent.update_needs(sim.time)
             agent.decision_engine.markets = sim.markets
             agent.decision_engine.goods_data = self.goods_data
-            if isinstance(agent, Firm):
-                agent.config_module = self.config
 
         sim.inequality_tracker = InequalityTracker(config_module=self.config)
         sim.personality_tracker = PersonalityStatisticsTracker(config_module=self.config)
diff --git a/simulation/systems/demographic_manager.py b/simulation/systems/demographic_manager.py
index 385ef24..45eeaeb 100644
--- a/simulation/systems/demographic_manager.py
+++ b/simulation/systems/demographic_manager.py
@@ -3,6 +3,8 @@ from typing import List, Dict, Any, Optional
 import logging
 import random
 from simulation.core_agents import Household
+from simulation.utils.config_factory import create_config_dto
+from simulation.dtos.config_dtos import HouseholdConfigDTO
 
 logger = logging.getLogger(__name__)
 
@@ -159,6 +161,8 @@ class DemographicManager:
                 if not initial_needs_for_newborn:
                     self.logger.warning("NEWBORN_INITIAL_NEEDS not found in config. Newborns may be inactive.")
 
+                hh_config_dto = create_config_dto(self.config_module, HouseholdConfigDTO)
+
                 # WO-124: Instantiate with 0 assets. Gift is transferred via SettlementSystem.
                 child = Household(
                     id=child_id,
@@ -169,7 +173,7 @@ class DemographicManager:
                     decision_engine=new_decision_engine,
                     value_orientation=value_orientation,
                     personality=child_personality,
-                    config_module=self.config_module,
+                    config_dto=hh_config_dto,
                     loan_market=simulation.markets.get("loan_market"),
                     risk_aversion=parent.risk_aversion, # Inherit risk aversion
                     logger=simulation.logger
diff --git a/simulation/systems/immigration_manager.py b/simulation/systems/immigration_manager.py
index de631c3..2d94693 100644
--- a/simulation/systems/immigration_manager.py
+++ b/simulation/systems/immigration_manager.py
@@ -8,6 +8,8 @@ from simulation.ai.household_ai import HouseholdAI
 from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
 from simulation.ai_model import AIEngineRegistry
 from simulation.finance.api import ISettlementSystem
+from simulation.utils.config_factory import create_config_dto
+from simulation.dtos.config_dtos import HouseholdConfigDTO
 
 logger = logging.getLogger(__name__)
 
@@ -63,6 +65,8 @@ class ImmigrationManager:
         """Generates a batch of new immigrant households."""
         new_households = []
 
+        hh_config_dto = create_config_dto(self.config, HouseholdConfigDTO)
+
         # Determine Value Orientations (same distribution as main.py)
         all_value_orientations = [
             "wealth_and_needs",
@@ -119,15 +123,19 @@ class ImmigrationManager:
                 decision_engine=household_decision_engine,
                 value_orientation=value_orientation,
                 personality=personality,
-                config_module=self.config,
+                config_dto=hh_config_dto,
                 risk_aversion=risk_aversion,
                 logger=logger
             )
 
             # Set specific immigrant traits
             household.education_level = education_level
-            household.gender = random.choice(["M", "F"])
-            household.age = random.randint(20, 35) # Young workforce
+            household.initialize_demographics(
+                age=float(random.randint(20, 35)),
+                gender=random.choice(["M", "F"]),
+                parent_id=None,
+                generation=0
+            )
 
             # Initial Inventory (Survival Kit)
             household.inventory["basic_food"] = 5.0
diff --git a/tests/test_base_agent.py b/tests/test_base_agent.py
index 9a92ca7..d4853f7 100644
--- a/tests/test_base_agent.py
+++ b/tests/test_base_agent.py
@@ -12,6 +12,8 @@ from simulation.decisions.ai_driven_household_engine import (
 )
 from simulation.decisions.ai_driven_firm_engine import AIDrivenFirmDecisionEngine
 import config
+from simulation.utils.config_factory import create_config_dto
+from simulation.dtos.config_dtos import HouseholdConfigDTO, FirmConfigDTO
 
 # 프로젝트 루트 디렉토리를 sys.path에 추가
 current_dir = os.path.dirname(os.path.abspath(__file__))
@@ -85,6 +87,7 @@ def test_household_clone():
     decision_engine = MockHouseholdDecisionEngine()
     mock_logger = Mock()
 
+    hh_config = create_config_dto(config, HouseholdConfigDTO)
     household = Household(
         id=1,
         talent=talent,
@@ -95,7 +98,7 @@ def test_household_clone():
         value_orientation=Mock(),
         logger=mock_logger,
         personality=Personality.MISER,
-        config_module=config,
+        config_dto=hh_config,
     )
 
     clone = household.clone(2, 50.0, 1)
@@ -118,9 +121,9 @@ def test_firm_inheritance_and_init():
     productivity_factor = 1.0
     decision_engine = MockFirmDecisionEngine()
     mock_logger = Mock()
-    mock_config = Mock(spec=config)
-    mock_config.PROFIT_HISTORY_TICKS = 10
-    mock_config.FIRM_MIN_PRODUCTION_TARGET = 10.0
+    firm_config = create_config_dto(config, FirmConfigDTO)
+    firm_config.profit_history_ticks = 10
+    firm_config.firm_min_production_target = 10.0
 
     firm = Firm(
         id=101,
@@ -131,7 +134,7 @@ def test_firm_inheritance_and_init():
         decision_engine=decision_engine,
         value_orientation=Mock(),
         logger=mock_logger,
-        config_module=mock_config,
+        config_dto=firm_config,
     )
 
     assert isinstance(firm, BaseAgent)
diff --git a/tests/test_firms.py b/tests/test_firms.py
index 54c6514..709d351 100644
--- a/tests/test_firms.py
+++ b/tests/test_firms.py
@@ -13,15 +13,19 @@ class TestFirmBookValue:
 
     @pytest.fixture
     def mock_config(self):
-        config = Mock()
-        config.FIRM_MIN_PRODUCTION_TARGET = 10.0
-        config.IPO_INITIAL_SHARES = 100.0
-        config.PROFIT_HISTORY_TICKS = 10
-        config.INITIAL_FIRM_LIQUIDITY_NEED = 100.0
-        config.LABOR_ALPHA = 0.7
-        config.CAPITAL_DEPRECIATION_RATE = 0.05
-        config.GOODS = {"test": {}}
-        return config
+        from simulation.dtos.config_dtos import FirmConfigDTO
+        import config
+        from simulation.utils.config_factory import create_config_dto
+
+        dto = create_config_dto(config, FirmConfigDTO)
+        dto.firm_min_production_target = 10.0
+        dto.ipo_initial_shares = 100.0
+        dto.profit_history_ticks = 10
+        dto.initial_firm_liquidity_need = 100.0
+        dto.labor_alpha = 0.7
+        dto.capital_depreciation_rate = 0.05
+        dto.goods = {"test": {"quality_sensitivity": 0.5}}
+        return dto
 
     @pytest.fixture
     def firm(self, mock_decision_engine, mock_config):
@@ -33,7 +37,7 @@ class TestFirmBookValue:
             productivity_factor=1.0,
             decision_engine=mock_decision_engine,
             value_orientation="PROFIT",
-            config_module=mock_config
+            config_dto=mock_config
         )
 
     def test_book_value_no_liabilities(self, firm):
@@ -86,13 +90,17 @@ class TestFirmBookValue:
 class TestProductionDepartment:
     @pytest.fixture
     def mock_config(self):
-        config = Mock()
-        config.LABOR_ALPHA = 0.7
-        config.AUTOMATION_LABOR_REDUCTION = 0.5
-        config.LABOR_ELASTICITY_MIN = 0.3
-        config.CAPITAL_DEPRECIATION_RATE = 0.05
-        config.GOODS = {"test": {"quality_sensitivity": 0.5}}
-        return config
+        from simulation.dtos.config_dtos import FirmConfigDTO
+        import config
+        from simulation.utils.config_factory import create_config_dto
+
+        dto = create_config_dto(config, FirmConfigDTO)
+        dto.labor_alpha = 0.7
+        dto.automation_labor_reduction = 0.5
+        dto.labor_elasticity_min = 0.3
+        dto.capital_depreciation_rate = 0.05
+        dto.goods = {"test": {"quality_sensitivity": 0.5}}
+        return dto
 
     @pytest.fixture
     def firm(self, mock_config):
@@ -121,7 +129,7 @@ class TestProductionDepartment:
 
         # Replicate the quality calculation to get the expected value
         avg_skill = firm.hr.get_avg_skill.return_value
-        quality_sensitivity = mock_config.GOODS["test"]["quality_sensitivity"]
+        quality_sensitivity = mock_config.goods["test"]["quality_sensitivity"]
         expected_quality = firm.base_quality + (math.log1p(avg_skill) * quality_sensitivity)
 
         firm.add_inventory.assert_called_once_with("test", produced_quantity, expected_quality)
@@ -129,13 +137,17 @@ class TestProductionDepartment:
 class TestSalesDepartment:
     @pytest.fixture
     def mock_config(self):
-        config = Mock()
-        config.BRAND_AWARENESS_SATURATION = 0.9
-        config.MARKETING_EFFICIENCY_HIGH_THRESHOLD = 1.5
-        config.MARKETING_EFFICIENCY_LOW_THRESHOLD = 0.8
-        config.MARKETING_BUDGET_RATE_MIN = 0.01
-        config.MARKETING_BUDGET_RATE_MAX = 0.20
-        return config
+        from simulation.dtos.config_dtos import FirmConfigDTO
+        import config
+        from simulation.utils.config_factory import create_config_dto
+
+        dto = create_config_dto(config, FirmConfigDTO)
+        dto.brand_awareness_saturation = 0.9
+        dto.marketing_efficiency_high_threshold = 1.5
+        dto.marketing_efficiency_low_threshold = 0.8
+        dto.marketing_budget_rate_min = 0.01
+        dto.marketing_budget_rate_max = 0.20
+        return dto
 
     @pytest.fixture
     def firm(self, mock_config):
diff --git a/tests/test_household_ai.py b/tests/test_household_ai.py
index 3a8f668..e2437d4 100644
--- a/tests/test_household_ai.py
+++ b/tests/test_household_ai.py
@@ -19,6 +19,8 @@ from simulation.decisions.action_proposal import ActionProposalEngine
 from simulation.ai.state_builder import StateBuilder
 from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
 from simulation.ai.household_ai import HouseholdAI
+from simulation.utils.config_factory import create_config_dto
+from simulation.dtos.config_dtos import HouseholdConfigDTO
 from simulation.ai.enums import Tactic
 
 @pytest.fixture
@@ -67,6 +69,7 @@ def test_ai_creates_purchase_order(setup_test_environment, ai_engine_setup):
         ai_engine=household_ai_instance, config_module=config
     )
 
+    hh_config = create_config_dto(config, HouseholdConfigDTO)
     talent = Talent(base_learning_rate=0.1, max_potential={"strength": 100})
     household = Household(
         id=2,
@@ -77,7 +80,7 @@ def test_ai_creates_purchase_order(setup_test_environment, ai_engine_setup):
         value_orientation=value_orientation,
         decision_engine=household_decision_engine,
         personality=Personality.MISER,
-        config_module=config,
+        config_dto=hh_config,
     )
 
     market_data = {
@@ -118,6 +121,7 @@ def test_ai_evaluates_consumption_options(setup_test_environment, ai_engine_setu
         ai_engine=household_ai_instance, config_module=config
     )
 
+    hh_config = create_config_dto(config, HouseholdConfigDTO)
     talent = Talent(base_learning_rate=0.1, max_potential={"strength": 100})
     household = Household(
         id=3,
@@ -128,7 +132,7 @@ def test_ai_evaluates_consumption_options(setup_test_environment, ai_engine_setu
         value_orientation=value_orientation,
         decision_engine=household_decision_engine,
         personality=Personality.STATUS_SEEKER,
-        config_module=config,
+        config_dto=hh_config,
     )
 
     market_data = {
