diff --git a/simulation/core_agents.py b/simulation/core_agents.py
index 34d0aa5..3c04ebf 100644
--- a/simulation/core_agents.py
+++ b/simulation/core_agents.py
@@ -668,6 +668,8 @@ class Household(BaseAgent, ILearningAgent):
         government: Optional[Any] = None,
         macro_context: Optional[MacroFinancialContext] = None,
         stress_scenario_config: Optional["StressScenarioConfig"] = None,
+        market_snapshot: Optional[Any] = None,
+        government_policy: Optional[Any] = None,
     ) -> Tuple[List["Order"], Tuple["Tactic", "Aggressiveness"]]:
 
         # 0. Update Social Status (Before Decision)
@@ -742,7 +744,9 @@ class Household(BaseAgent, ILearningAgent):
             market_data=market_data,
             current_time=current_time,
             government=government,
-            stress_scenario_config=stress_scenario_config
+            stress_scenario_config=stress_scenario_config,
+            market_snapshot=market_snapshot,
+            government_policy=government_policy
         )
 
         # 2. Call Decision Engine
diff --git a/simulation/decisions/ai_driven_household_engine.py b/simulation/decisions/ai_driven_household_engine.py
index 491ed30..8839d32 100644
--- a/simulation/decisions/ai_driven_household_engine.py
+++ b/simulation/decisions/ai_driven_household_engine.py
@@ -51,7 +51,8 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
             from simulation.schemas import HouseholdActionVector
             return [], HouseholdActionVector()
 
-        markets = context.markets
+        # TD-117: Use DTOs
+        market_snapshot = context.market_snapshot
         market_data = context.market_data
         current_time = context.current_time
 
@@ -283,12 +284,9 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
 
         # 4. Stock Investment Logic
         stock_orders = self._make_stock_investment_decisions(
-            household, markets, market_data, action_vector, current_time, macro_context
+            household, market_snapshot, market_data, action_vector, current_time, macro_context
         )
-        stock_market = markets.get("stock_market")
-        if stock_market is not None:
-            for stock_order in stock_orders:
-                stock_market.place_order(stock_order, current_time)
+        orders.extend(stock_orders)
 
         # 5. Liquidity Management
         stress_config = context.stress_scenario_config
@@ -456,7 +454,7 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
     def _make_stock_investment_decisions(
         self,
         household: "HouseholdStateDTO",
-        markets: Dict[str, Any],
+        market_snapshot: Any, # MarketSnapshotDTO
         market_data: Dict[str, Any],
         action_vector: Any,
         current_time: int,
@@ -467,8 +465,7 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
         if not getattr(self.config_module, "STOCK_MARKET_ENABLED", False):
             return stock_orders
         
-        stock_market = markets.get("stock_market")
-        if stock_market is None:
+        if market_snapshot is None:
             return stock_orders
 
         if household.assets < self.config_module.HOUSEHOLD_MIN_ASSETS_FOR_INVESTMENT:
@@ -496,7 +493,11 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
             macro_context=macro_context
         )
 
-        current_prices = {firm_id: stock_market.get_stock_price(firm_id) for firm_id in household.portfolio_holdings.keys()}
+        current_prices = {}
+        if market_snapshot:
+            for firm_id in household.portfolio_holdings.keys():
+                price = market_snapshot.prices.get(f"stock_{firm_id}", 0.0)
+                current_prices[firm_id] = price
 
         # Calculate valuation manually for DTO
         current_equity_value = 0.0
@@ -507,9 +508,9 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
         equity_delta = target_equity - current_equity_value
 
         if equity_delta > self.config_module.STOCK_INVESTMENT_EQUITY_DELTA_THRESHOLD:
-            stock_orders.extend(self._place_buy_orders(household, equity_delta, stock_market, current_time))
+            stock_orders.extend(self._place_buy_orders(household, equity_delta, market_snapshot, current_time))
         elif equity_delta < -self.config_module.STOCK_INVESTMENT_EQUITY_DELTA_THRESHOLD:
-            stock_orders.extend(self._place_sell_orders(household, -equity_delta, stock_market, current_time))
+            stock_orders.extend(self._place_sell_orders(household, -equity_delta, market_snapshot, current_time))
         
         return stock_orders
 
@@ -520,9 +521,18 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
             return 5.0
         return 2.0
 
-    def _place_buy_orders(self, household: "HouseholdStateDTO", amount_to_invest: float, stock_market: Any, tick: int) -> List[StockOrder]:
+    def _place_buy_orders(self, household: "HouseholdStateDTO", amount_to_invest: float, market_snapshot: Any, tick: int) -> List[StockOrder]:
         orders = []
-        available_stocks = [fid for fid in stock_market.reference_prices.keys() if stock_market.get_stock_price(fid) > 0]
+        # Filter stock prices from snapshot
+        available_stocks = []
+        for key, price in market_snapshot.prices.items():
+            if key.startswith("stock_") and price > 0:
+                try:
+                    fid = int(key.split("_")[1])
+                    available_stocks.append(fid)
+                except:
+                    pass
+
         if not available_stocks:
             return orders
 
@@ -530,7 +540,7 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
         investment_per_stock = amount_to_invest / diversification_count
         for _ in range(diversification_count):
             firm_id = random.choice(available_stocks)
-            price = stock_market.get_stock_price(firm_id)
+            price = market_snapshot.prices.get(f"stock_{firm_id}", 0.0)
             if price > 0:
                 quantity = investment_per_stock / price
                 if quantity >= 1.0:
@@ -538,11 +548,11 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
                     orders.append(order)
         return orders
 
-    def _place_sell_orders(self, household: "HouseholdStateDTO", amount_to_sell: float, stock_market: Any, tick: int) -> List[StockOrder]:
+    def _place_sell_orders(self, household: "HouseholdStateDTO", amount_to_sell: float, market_snapshot: Any, tick: int) -> List[StockOrder]:
         orders = []
         sorted_holdings = sorted(
             household.portfolio_holdings.items(),
-            key=lambda item: item[1].quantity * stock_market.get_stock_price(item[0]), # Access .quantity
+            key=lambda item: item[1].quantity * market_snapshot.prices.get(f"stock_{item[0]}", 0.0), # Access .quantity
             reverse=True
         )
 
@@ -550,7 +560,7 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
             quantity = share.quantity
             if amount_to_sell <= 0:
                 break
-            price = stock_market.get_stock_price(firm_id)
+            price = market_snapshot.prices.get(f"stock_{firm_id}", 0.0)
             if price > 0:
                 value_of_holding = quantity * price
                 sell_value = min(amount_to_sell, value_of_holding)
diff --git a/simulation/decisions/corporate_manager.py b/simulation/decisions/corporate_manager.py
index 6c2a6c6..f047591 100644
--- a/simulation/decisions/corporate_manager.py
+++ b/simulation/decisions/corporate_manager.py
@@ -48,7 +48,7 @@ class CorporateManager:
             orders.append(target_order)
 
         # 0. Procurement Channel (Raw Materials) - WO-030
-        procurement_orders = self._manage_procurement(firm, context.market_data, context.markets)
+        procurement_orders = self._manage_procurement(firm, context.market_data)
         orders.extend(procurement_orders)
 
         # Phase 21: Automation Channel
@@ -80,7 +80,7 @@ class CorporateManager:
         orders.extend(debt_orders)
 
         # 5. Pricing Channel (Sales)
-        pricing_orders = self._manage_pricing(firm, action_vector.sales_aggressiveness, context.market_data, context.markets, context.current_time)
+        pricing_orders = self._manage_pricing(firm, action_vector.sales_aggressiveness, context.market_data, context.current_time)
         orders.extend(pricing_orders)
 
         # 6. Hiring Channel (Employment)
@@ -104,9 +104,9 @@ class CorporateManager:
         if firm.treasury_shares <= 0:
             return None
 
-        stock_market = context.markets.get("stock_market")
-        # Check if market exists
-        if not stock_market:
+        # Use DTO
+        market_snapshot = context.market_snapshot
+        if not market_snapshot:
             return None
 
         max_sell_ratio = getattr(self.config_module, "SEO_MAX_SELL_RATIO", 0.10)
@@ -117,13 +117,8 @@ class CorporateManager:
 
         # Determine price (Market Price or Book Value)
         price = 0.0
-        # Accessing market directly via context might violate purity if we modify it, but we are just reading price?
-        # Actually context.markets contains Market objects.
-        # Ideally we should use market_data.
-        # But stock_market logic below uses get_stock_price method.
-        # Assuming context.markets["stock_market"] is available.
-        if stock_market and hasattr(stock_market, "get_stock_price"):
-             price = stock_market.get_stock_price(firm.id)
+        if market_snapshot:
+             price = market_snapshot.prices.get(f"stock_{firm.id}", 0.0)
 
         if price is None or price <= 0:
             # Fallback to Book Value
@@ -146,7 +141,7 @@ class CorporateManager:
         self.logger.info(f"SEO | Firm {firm.id} offering {sell_qty:.1f} shares at {price:.2f}")
         return order
 
-    def _manage_procurement(self, firm: FirmStateDTO, market_data: Dict[str, Any], markets: Dict[str, Any]) -> List[Order]:
+    def _manage_procurement(self, firm: FirmStateDTO, market_data: Dict[str, Any]) -> List[Order]:
         """
         WO-030: Manage Raw Material Procurement.
         """
@@ -309,7 +304,7 @@ class CorporateManager:
 
         return orders
 
-    def _manage_pricing(self, firm: FirmStateDTO, aggressiveness: float, market_data: Dict, markets: Dict, current_time: int) -> List[Order]:
+    def _manage_pricing(self, firm: FirmStateDTO, aggressiveness: float, market_data: Dict, current_time: int) -> List[Order]:
         """
         Sales Channel.
         """
@@ -352,16 +347,15 @@ class CorporateManager:
         # Note: Previous logic called `firm.sales.post_ask` which might do more (logging, etc).
         # But we are in DTO mode. The Engine outputs Intent.
 
-        target_market = markets.get(item_id)
-        if target_market:
-             orders.append(Order(
-                 agent_id=firm.id,
-                 order_type="SELL",
-                 item_id=item_id,
-                 quantity=qty,
-                 price=target_price,
-                 market_id=item_id # Assumes market_id == item_id
-             ))
+        # target_market check removed for DTO purity
+        orders.append(Order(
+             agent_id=firm.id,
+             order_type="SELL",
+             item_id=item_id,
+             quantity=qty,
+             price=target_price,
+             market_id=item_id # Assumes market_id == item_id
+        ))
 
         return orders
 
diff --git a/simulation/decisions/rule_based_household_engine.py b/simulation/decisions/rule_based_household_engine.py
index d7c987b..fd91144 100644
--- a/simulation/decisions/rule_based_household_engine.py
+++ b/simulation/decisions/rule_based_household_engine.py
@@ -43,7 +43,8 @@ class RuleBasedHouseholdDecisionEngine(BaseDecisionEngine):
         state: HouseholdStateDTO = context.state
         config: HouseholdConfigDTO = context.config
         
-        markets = context.markets
+        # TD-117: Use DTOs
+        market_snapshot = context.market_snapshot
         market_data = context.market_data
         current_time = context.current_time
 
@@ -68,9 +69,9 @@ class RuleBasedHouseholdDecisionEngine(BaseDecisionEngine):
 
                 needed_quantity = target_buffer - food_in_inventory
                 market_id = food_item_id 
-                market = markets.get(market_id)
 
-                best_ask = market.get_best_ask(item_id=food_item_id) if market else None
+                # TD-117: Use MarketSnapshotDTO
+                best_ask = market_snapshot.best_asks.get(food_item_id) if market_snapshot else None
 
                 if best_ask is None or best_ask == 0:
                     best_ask = getattr(self.config_module, "DEFAULT_FALLBACK_PRICE", 5.0)
diff --git a/simulation/decisions/standalone_rule_based_firm_engine.py b/simulation/decisions/standalone_rule_based_firm_engine.py
index f4ceb61..87b9d47 100644
--- a/simulation/decisions/standalone_rule_based_firm_engine.py
+++ b/simulation/decisions/standalone_rule_based_firm_engine.py
@@ -44,7 +44,7 @@ class StandaloneRuleBasedFirmDecisionEngine(BaseDecisionEngine):
         생산 조정, 임금 조정, 가격 조정에 집중한다.
         """
         firm = context.state # FirmStateDTO
-        markets = context.markets
+        # markets = context.markets # Removed for DTO purity
         goods_data = context.goods_data
         market_data = context.market_data
         current_time = context.current_time
diff --git a/simulation/dtos/api.py b/simulation/dtos/api.py
index 74eb39e..331aa26 100644
--- a/simulation/dtos/api.py
+++ b/simulation/dtos/api.py
@@ -2,6 +2,7 @@ from __future__ import annotations
 from dataclasses import dataclass, field
 from typing import Dict, Any, Optional, List, TYPE_CHECKING, Union
 from simulation.dtos.firm_state_dto import FirmStateDTO
+from simulation.models import Order
 
 if TYPE_CHECKING:
     from simulation.core_agents import Household
@@ -90,6 +91,22 @@ class AIDecisionData:
     predicted_reward: Optional[float] = None
     actual_reward: Optional[float] = None
 
+@dataclass
+class MarketSnapshotDTO:
+    """A pure-data snapshot of the state of all markets at a point in time."""
+    prices: Dict[str, float]
+    volumes: Dict[str, float]
+    asks: Dict[str, List[Order]]
+    best_asks: Dict[str, float]
+
+@dataclass
+class GovernmentPolicyDTO:
+    """A pure-data snapshot of current government policies affecting agent decisions."""
+    income_tax_rate: float
+    sales_tax_rate: float
+    corporate_tax_rate: float
+    base_interest_rate: float
+
 @dataclass
 class HouseholdConfigDTO:
     """Static configuration values relevant to household decisions."""
@@ -152,7 +169,6 @@ class DecisionContext:
     A pure data container for decision-making.
     Direct agent instance access is strictly forbidden (Enforced by Purity Gate).
     """
-    markets: Dict[str, Any]
     goods_data: List[Dict[str, Any]]
     market_data: Dict[str, Any]
     current_time: int
@@ -163,7 +179,14 @@ class DecisionContext:
     # Static configuration values relevant to the agent type
     config: Union[HouseholdConfigDTO, FirmConfigDTO]
 
+    # Deprecated: Will be removed after full migration to DTOs
+    markets: Optional[Dict[str, Any]] = None
     government: Optional[Any] = None
+
+    # New DTOs
+    market_snapshot: Optional[MarketSnapshotDTO] = None
+    government_policy: Optional[GovernmentPolicyDTO] = None
+
     reflux_system: Optional[Any] = None # Phase 8-B: Reflux System
     stress_scenario_config: Optional[StressScenarioConfig] = None # Phase 28
 
@@ -198,6 +221,7 @@ class SimulationState:
     transactions: List[Any] = None # List[Transaction]
     effects_queue: List[Dict[str, Any]] = None # WO-109: Queue for side-effects
     inactive_agents: Dict[int, Any] = None # WO-109: Store inactive agents
+    planned_consumption: Optional[Dict[int, Dict[str, Any]]] = None # TD-118
 
     def __post_init__(self):
         if self.transactions is None:
@@ -206,6 +230,8 @@ class SimulationState:
             self.effects_queue = []
         if self.inactive_agents is None:
             self.inactive_agents = {}
+        if self.planned_consumption is None:
+            self.planned_consumption = {}
 
 
 # ------------------------------------------------------------------------------
diff --git a/simulation/firms.py b/simulation/firms.py
index ca263c7..d57e263 100644
--- a/simulation/firms.py
+++ b/simulation/firms.py
@@ -314,7 +314,8 @@ class Firm(BaseAgent, ILearningAgent):
 
     @override
     def make_decision(
-        self, markets: Dict[str, Any], goods_data: list[Dict[str, Any]], market_data: Dict[str, Any], current_time: int, government: Optional[Any] = None, reflux_system: Optional[Any] = None, stress_scenario_config: Optional["StressScenarioConfig"] = None
+        self, markets: Dict[str, Any], goods_data: list[Dict[str, Any]], market_data: Dict[str, Any], current_time: int, government: Optional[Any] = None, reflux_system: Optional[Any] = None, stress_scenario_config: Optional["StressScenarioConfig"] = None,
+        market_snapshot: Optional[Any] = None, government_policy: Optional[Any] = None
     ) -> tuple[list[Order], Any]:
         log_extra = {"tick": current_time, "agent_id": self.id, "tags": ["firm_action"]}
         # SoC Refactor
@@ -342,6 +343,8 @@ class Firm(BaseAgent, ILearningAgent):
             government=government,
             reflux_system=reflux_system,
             stress_scenario_config=stress_scenario_config,
+            market_snapshot=market_snapshot,
+            government_policy=government_policy
         )
         decisions, tactic = self.decision_engine.make_decisions(context)
 
diff --git a/simulation/systems/api.py b/simulation/systems/api.py
index b8398ee..19ac36b 100644
--- a/simulation/systems/api.py
+++ b/simulation/systems/api.py
@@ -22,6 +22,7 @@ if TYPE_CHECKING:
     from simulation.markets.market import Market
     from simulation.dtos.scenario import StressScenarioConfig
     from simulation.dtos.api import SimulationState
+    from simulation.models import Transaction
 
 
 # ===================================================================
@@ -133,11 +134,15 @@ class ICommerceSystem(Protocol):
     """틱의 소비 및 여가 부분을 관리하는 시스템의 인터페이스입니다."""
     def __init__(self, config: Any, reflux_system: 'EconomicRefluxSystem'): ...
 
-    def execute_consumption_and_leisure(self, context: CommerceContext, scenario_config: Optional[StressScenarioConfig] = None) -> Dict[int, float]:
+    def plan_consumption_and_leisure(self, context: CommerceContext, scenario_config: Optional[StressScenarioConfig] = None) -> Tuple[Dict[int, Dict[str, Any]], List[Transaction]]:
         """
-        가계 소비, 긴급 구매(fast-track purchases), 여가 효과를 조율합니다.
-        Returns:
-            Dict[int, float]: 가계 ID별 여가 효용(Leisure Utility) 맵.
+        Phase 1: 소비 및 여가 계획. Fast Purchase를 위한 트랜잭션 생성.
+        """
+        ...
+
+    def finalize_consumption_and_leisure(self, context: CommerceContext, planned_consumptions: Dict[int, Dict[str, Any]]) -> Dict[int, float]:
+        """
+        Phase 4: 소비 실행(재고 차감) 및 여가 효과 적용.
         """
         ...
 
diff --git a/simulation/systems/commerce_system.py b/simulation/systems/commerce_system.py
index c87fcf3..80f6f26 100644
--- a/simulation/systems/commerce_system.py
+++ b/simulation/systems/commerce_system.py
@@ -1,10 +1,11 @@
 """
 Implements the CommerceSystem which orchestrates consumption, purchases, and leisure.
 """
-from typing import Any, Dict, List, Optional
+from typing import Any, Dict, List, Optional, Tuple
 import logging
 from simulation.systems.api import ICommerceSystem, CommerceContext
 from simulation.systems.reflux_system import EconomicRefluxSystem
+from simulation.models import Transaction
 
 logger = logging.getLogger(__name__)
 
@@ -17,21 +18,19 @@ class CommerceSystem(ICommerceSystem):
         self.config = config
         self.reflux_system = reflux_system
 
-    def execute_consumption_and_leisure(self, context: CommerceContext, scenario_config: Optional["StressScenarioConfig"] = None) -> Dict[int, float]:
+    def plan_consumption_and_leisure(self, context: CommerceContext, scenario_config: Optional["StressScenarioConfig"] = None) -> Tuple[Dict[int, Dict[str, Any]], List[Transaction]]:
         """
-        Executes vectorized consumption, applies fast-track purchases,
-        and calculates leisure effects. Incorporates stress scenario behavioral changes.
-
-        Returns:
-            Dict[int, float]: Map of Household ID to Utility Gained.
+        Phase 1: Decisions.
+        Determines desired consumption and generates transactions for Fast Purchase.
+        Returns (PlannedConsumptionMap, Transactions).
         """
         households = context["households"]
         breeding_planner = context["breeding_planner"]
-        time_allocation = context["household_time_allocation"]
         market_data = context["market_data"]
         current_time = context["time"]
 
-        household_leisure_effects: Dict[int, float] = {}
+        planned_consumptions = {}
+        transactions = []
 
         # 1. Vectorized Decision Making
         batch_decisions = breeding_planner.decide_consumption_batch(households, market_data)
@@ -44,12 +43,9 @@ class CommerceSystem(ICommerceSystem):
             if not household.is_active:
                 continue
 
-            consumed_items = {}
-
-            # 2a. Fast Consumption
+            c_amt = 0.0
             if i < len(consume_list):
                 c_amt = consume_list[i]
-
                 # Phase 28: Deflationary Spiral - Consumption Collapse
                 if scenario_config and scenario_config.is_active and scenario_config.scenario_name == 'deflation':
                     if not household.is_employed and scenario_config.consumption_pessimism_factor > 0:
@@ -57,32 +53,77 @@ class CommerceSystem(ICommerceSystem):
                         c_amt *= (1 - scenario_config.consumption_pessimism_factor)
                         logger.debug(f"PESSIMISM_IMPACT | Household {household.id} consumption reduced from {original_amt:.2f} to {c_amt:.2f}")
 
-                if c_amt > 0:
-                    household.consume("basic_food", c_amt, current_time)
-                    consumed_items["basic_food"] = c_amt
+            # Store plan
+            planned_consumptions[household.id] = {
+                "consume_amount": c_amt,
+                "buy_amount": 0.0,
+                "consumed_immediately_from_buy": 0.0
+            }
 
-            # 2b. Fast Purchase (Emergency Buy)
+            # 2b. Fast Purchase (Emergency Buy) -> Generate Transaction
             if i < len(buy_list):
                 b_amt = buy_list[i]
                 if b_amt > 0:
                     cost = b_amt * food_price
+                    # Optimistic check (actual balance check in TransactionProcessor)
                     if household.assets >= cost:
-                        household.withdraw(cost)
-                        household.inventory["basic_food"] = household.inventory.get("basic_food", 0) + b_amt
+                        planned_consumptions[household.id]["buy_amount"] = b_amt
+
+                        # Generate Emergency Buy Transaction
+                        tx = Transaction(
+                            buyer_id=household.id,
+                            seller_id=self.reflux_system.id if hasattr(self.reflux_system, 'id') else 0, # Assuming Reflux has ID or use 0/System
+                            item_id="basic_food",
+                            quantity=b_amt,
+                            price=cost, # Total price as trade_value? No, Transaction takes unit price usually?
+                            # Transaction: trade_value = quantity * price.
+                            # Here price should be unit price.
+                            # But cost = b_amt * food_price. So price = food_price.
+                            market_id="system",
+                            transaction_type="emergency_buy",
+                            time=current_time
+                        )
+                        # Fix: Transaction takes UNIT PRICE.
+                        tx.price = food_price
 
-                        # Capture money sink
-                        self.reflux_system.capture(cost, source=f"Household_{household.id}", category="emergency_food")
+                        transactions.append(tx)
 
                         logger.debug(
-                            f"VECTOR_BUY | Household {household.id} bought {b_amt:.1f} food (Fast Track)",
+                            f"VECTOR_BUY_PLAN | Household {household.id} planning to buy {b_amt:.1f} food (Fast Track)",
                             extra={"agent_id": household.id, "tags": ["consumption", "vector_buy"]}
                         )
 
-                        # Immediate consumption if needed
-                        if c_amt == 0:
-                            consume_now = min(b_amt, getattr(self.config, "FOOD_CONSUMPTION_QUANTITY", 1.0))
-                            household.consume("basic_food", consume_now, current_time)
-                            consumed_items["basic_food"] = consume_now
+                        # Immediate consumption if needed (Logic Logic: If planned consumption > inventory, assume some came from buy)
+                        # But we execute transactions later.
+                        # So inventory update happens in Phase 3.
+                        # Consumption happens in Phase 4 (Finalize).
+                        # So finalize will see updated inventory.
+                        pass
+
+        return planned_consumptions, transactions
+
+    def finalize_consumption_and_leisure(self, context: CommerceContext, planned_consumptions: Dict[int, Dict[str, Any]]) -> Dict[int, float]:
+        """
+        Phase 4: Lifecycle Effects.
+        Executes consumption from inventory and applies leisure effects.
+        """
+        households = context["households"]
+        time_allocation = context["household_time_allocation"]
+        current_time = context["time"]
+
+        household_leisure_effects: Dict[int, float] = {}
+
+        for household in households:
+            if not household.is_active:
+                continue
+
+            plan = planned_consumptions.get(household.id, {})
+            c_amt = plan.get("consume_amount", 0.0)
+
+            consumed_items = {}
+            if c_amt > 0:
+                household.consume("basic_food", c_amt, current_time)
+                consumed_items["basic_food"] = c_amt
 
             # 3. Leisure Effect
             leisure_hours = time_allocation.get(household.id, 0.0)
@@ -90,23 +131,8 @@ class CommerceSystem(ICommerceSystem):
 
             household_leisure_effects[household.id] = effect_dto.utility_gained
 
-            # 4. Lifecycle Update (Needs, Tax, Psychology)
-            # This is now delegated to AgentLifecycleComponent inside household.update_needs
-            # But wait, household.update_needs calls labor_manager.work()!
-            # work() shouldn't be called here if it was already done or calculated.
-            # In the old `Simulation.run_tick`:
-            # - Transactions happened.
-            # - Then this loop happened.
-            # - household.update_needs() was called here.
-            # - household.update_needs() calls labor_manager.work(8.0)
-
-            # So we must call household.update_needs() here to maintain logic.
-            # BUT, we are refactoring update_needs to AgentLifecycleComponent.
-            # So we should call household.lifecycle.run_tick() ideally.
-            # Since household still has update_needs wrapping the new component (in the intermediate step),
-            # we call household.update_needs().
-
-            household.update_needs(current_time, market_data)
+            # 4. Lifecycle Update (update_needs) REMOVED
+            # Moved to DemographicManager/LifecycleManager
 
             # 5. Parenting XP Transfer
             if effect_dto.leisure_type == "PARENTING" and effect_dto.xp_gained > 0:
diff --git a/simulation/systems/demographic_manager.py b/simulation/systems/demographic_manager.py
index 60174be..1e1ea37 100644
--- a/simulation/systems/demographic_manager.py
+++ b/simulation/systems/demographic_manager.py
@@ -28,9 +28,9 @@ class DemographicManager:
         self.initialized = True
         self.logger.info("DemographicManager initialized.")
 
-    def process_aging(self, agents: List[Household], current_tick: int) -> None:
+    def process_aging(self, agents: List[Household], current_tick: int, market_data: Optional[Dict[str, Any]] = None) -> None:
         """
-        Increments age for all households.
+        Increments age for all households and runs internal lifecycle updates.
         Handles natural death (old age).
         """
         # Ticks per Year is defined in config (e.g., 100 ticks = 1 year)
@@ -40,8 +40,12 @@ class DemographicManager:
             if not agent.is_active:
                 continue
 
-            # Increment Age for households
-            agent.age += (1.0 / ticks_per_year)
+            # Phase 4 Lifecycle Update (Replaced CommerceSystem call)
+            # Delegate internal lifecycle (aging, needs, taxes)
+            agent.update_needs(current_tick, market_data)
+
+            # Explicit aging removed as update_needs -> bio_component handles it.
+            # However, we check death here.
 
             # Check Natural Death (Gompertz-Makeham law simplified)
             if agent.age > 80:
diff --git a/simulation/systems/lifecycle_manager.py b/simulation/systems/lifecycle_manager.py
index 6436695..16cde82 100644
--- a/simulation/systems/lifecycle_manager.py
+++ b/simulation/systems/lifecycle_manager.py
@@ -38,8 +38,8 @@ class AgentLifecycleManager(AgentLifecycleManagerInterface):
             List[Transaction]: Transactions generated by lifecycle events (e.g., inheritance)
                                to be queued for the NEXT tick.
         """
-        # 1. Aging
-        self.demographic_manager.process_aging(state.households, state.time)
+        # 1. Aging (and internal lifecycle update)
+        self.demographic_manager.process_aging(state.households, state.time, state.market_data)
 
         # 2. Births
         new_children = self._process_births(state)
diff --git a/simulation/systems/transaction_processor.py b/simulation/systems/transaction_processor.py
index 496e397..6154c41 100644
--- a/simulation/systems/transaction_processor.py
+++ b/simulation/systems/transaction_processor.py
@@ -110,17 +110,43 @@ class TransactionProcessor(SystemInterface):
                 heir_ids = tx.metadata.get("heir_ids", []) if tx.metadata else []
                 total_cash = buyer.assets
                 if total_cash > 0 and heir_ids:
-                    amount_per_heir = total_cash / len(heir_ids)
+                    import math
+                    count = len(heir_ids)
+                    # Calculate amount per heir, avoiding float precision issues (floor to cent)
+                    base_amount = math.floor((total_cash / count) * 100) / 100.0
+
+                    distributed_sum = 0.0
                     all_success = True
-                    for h_id in heir_ids:
+
+                    # Distribute to all but the last heir
+                    for i in range(count - 1):
+                        h_id = heir_ids[i]
                         heir = agents.get(h_id)
                         if heir:
                             if settlement:
-                                if not settlement.transfer(buyer, heir, amount_per_heir, "inheritance_distribution"):
+                                if settlement.transfer(buyer, heir, base_amount, "inheritance_distribution"):
+                                    distributed_sum += base_amount
+                                else:
                                     all_success = False
                             else:
-                                buyer.withdraw(amount_per_heir)
-                                heir.deposit(amount_per_heir)
+                                buyer.withdraw(base_amount)
+                                heir.deposit(base_amount)
+                                distributed_sum += base_amount
+
+                    # Last heir gets the remainder to ensure zero-sum
+                    last_heir_id = heir_ids[-1]
+                    last_heir = agents.get(last_heir_id)
+                    if last_heir:
+                        remaining_amount = total_cash - distributed_sum
+                        # Ensure we don't transfer negative amounts or dust if something went wrong
+                        if remaining_amount > 0:
+                            if settlement:
+                                if not settlement.transfer(buyer, last_heir, remaining_amount, "inheritance_distribution_final"):
+                                    all_success = False
+                            else:
+                                buyer.withdraw(remaining_amount)
+                                last_heir.deposit(remaining_amount)
+
                     success = all_success
 
             elif tx.transaction_type == "goods":
@@ -230,6 +256,20 @@ class TransactionProcessor(SystemInterface):
                     buyer.withdraw(trade_value)
                     seller.deposit(trade_value)
                     success = True
+
+            elif tx.transaction_type == "emergency_buy":
+                # Fast Purchase (Buyer -> Reflux/System)
+                # No Sales Tax, Immediate Inventory Update
+                if settlement:
+                    success = settlement.transfer(buyer, seller, trade_value, "emergency_buy")
+                else:
+                    buyer.withdraw(trade_value)
+                    seller.deposit(trade_value)
+                    success = True
+
+                if success:
+                    buyer.inventory[tx.item_id] = buyer.inventory.get(tx.item_id, 0.0) + tx.quantity
+
             else:
                 # Default / Other
                 if settlement:
diff --git a/simulation/tick_scheduler.py b/simulation/tick_scheduler.py
index 0bd0004..8a75fb6 100644
--- a/simulation/tick_scheduler.py
+++ b/simulation/tick_scheduler.py
@@ -277,6 +277,36 @@ class TickScheduler:
         )
         state.household_time_allocation = household_time_allocation # Update state
 
+        # TD-118: Commerce Planning (Phase 1 Extension)
+        # Prepare context for CommerceSystem
+        current_vacancies = 0
+        labor_market = state.markets.get("labor")
+        if labor_market and isinstance(labor_market, OrderBookMarket):
+             for item_orders in labor_market.buy_orders.values():
+                 for order in item_orders:
+                     current_vacancies += order.quantity
+
+        consumption_market_data = market_data.copy()
+        consumption_market_data["job_vacancies"] = current_vacancies
+
+        commerce_context: CommerceContext = {
+            "households": state.households,
+            "agents": state.agents,
+            "breeding_planner": state.breeding_planner,
+            "household_time_allocation": household_time_allocation,
+            "reflux_system": state.reflux_system,
+            "market_data": consumption_market_data,
+            "config": state.config_module,
+            "time": state.time
+        }
+
+        if state.commerce_system:
+            planned_cons, commerce_txs = state.commerce_system.plan_consumption_and_leisure(
+                commerce_context, state.stress_scenario_config
+            )
+            sim_state.planned_consumption = planned_cons
+            system_transactions.extend(commerce_txs)
+
         # 2. Matching
         self._phase_matching(sim_state)
 
@@ -518,6 +548,63 @@ class TickScheduler:
         household_pre_states = {}
         household_time_allocation = {}
 
+        # --- TD-117: Create DTOs ---
+        from simulation.dtos.api import MarketSnapshotDTO, GovernmentPolicyDTO
+
+        # Create MarketSnapshotDTO
+        prices = {}
+        volumes = {}
+        asks = {}
+        best_asks = {}
+
+        for m_id, market in state.markets.items():
+            if hasattr(market, "get_daily_avg_price"):
+                 prices[m_id] = market.get_daily_avg_price()
+            if hasattr(market, "get_daily_volume"):
+                 volumes[m_id] = market.get_daily_volume()
+
+            # Extract Asks
+            if hasattr(market, "sell_orders"):
+                for item_id, orders in market.sell_orders.items():
+                    asks[item_id] = orders
+
+                    # Best Ask
+                    if orders:
+                        if hasattr(market, "get_best_ask"):
+                            best_asks[item_id] = market.get_best_ask(item_id)
+                        else:
+                            best_asks[item_id] = orders[0].price if orders else 0.0
+            elif hasattr(market, "get_best_ask"):
+                # Fallback for markets without exposed sell_orders but with get_best_ask (e.g. StockMarket?)
+                # We iterate known items or catch on demand?
+                # Stock market uses firm_id as item_id.
+                # For now we rely on explicit loops if needed, or assume OrderBookMarket structure.
+                pass
+
+        # Stock Market Prices
+        if state.stock_market:
+            for firm in state.firms:
+                if firm.is_active:
+                    price = state.stock_market.get_stock_price(firm.id)
+                    prices[f"stock_{firm.id}"] = price
+
+        market_snapshot = MarketSnapshotDTO(
+            prices=prices,
+            volumes=volumes,
+            asks=asks,
+            best_asks=best_asks
+        )
+
+        # Create GovernmentPolicyDTO
+        gov = state.government
+        bank = state.bank
+        gov_policy = GovernmentPolicyDTO(
+             income_tax_rate=gov.income_tax_rate if hasattr(gov, "income_tax_rate") else 0.1,
+             sales_tax_rate=getattr(state.config_module, "SALES_TAX_RATE", 0.05),
+             corporate_tax_rate=gov.corporate_tax_rate if hasattr(gov, "corporate_tax_rate") else 0.2,
+             base_interest_rate=bank.base_rate if hasattr(bank, "base_rate") else 0.05
+        )
+
         # 1. Firms
         for firm in state.firms:
             if firm.is_active:
@@ -543,7 +630,8 @@ class TickScheduler:
 
                 firm_orders, action_vector = firm.make_decision(
                     state.markets, state.goods_data, market_data, state.time,
-                    state.government, state.reflux_system, stress_config
+                    state.government, state.reflux_system, stress_config,
+                    market_snapshot=market_snapshot, government_policy=gov_policy
                 )
 
                 for order in firm_orders:
@@ -568,7 +656,8 @@ class TickScheduler:
 
                 stress_config = self.world_state.stress_scenario_config
                 household_orders, action_vector = household.make_decision(
-                    state.markets, state.goods_data, market_data, state.time, state.government, macro_context, stress_config
+                    state.markets, state.goods_data, market_data, state.time, state.government, macro_context, stress_config,
+                    market_snapshot=market_snapshot, government_policy=gov_policy
                 )
 
                 if hasattr(action_vector, 'work_aggressiveness'):
@@ -649,6 +738,7 @@ class TickScheduler:
 
     def _phase_lifecycle(self, state: SimulationState) -> None:
         """Phase 4: Agent Lifecycle."""
+        # 1. Agent Lifecycle (Aging, Birth, Death)
         if self.world_state.lifecycle_manager:
             lifecycle_txs = self.world_state.lifecycle_manager.execute(state)
             if lifecycle_txs:
@@ -656,6 +746,55 @@ class TickScheduler:
         else:
             state.logger.error("LifecycleManager not initialized.")
 
+        # 2. Commerce Finalization (Consumption & Leisure Effects) - TD-118
+        # Re-construct context or pass relevant data?
+        # Ideally we reuse context but it's local to run_tick.
+        # We'll reconstruct minimal context here or rely on state.
+        # Actually, finalized consumption needs time_allocation which is in state (updated in run_tick).
+
+        # We need to reconstruct CommerceContext.
+        # Since _phase_lifecycle is a method, we can't easily pass the local commerce_context from run_tick
+        # without changing signature.
+        # We'll reconstruct it. It's cheap.
+
+        consumption_market_data = state.market_data # Use existing
+
+        # Household time allocation is needed.
+        # state.households is available.
+        # We need to know who is active.
+        # We need 'household_time_allocation' which IS NOT in SimulationState DTO explicitly?
+        # Check SimulationState definition in api.py.
+        # I didn't add it.
+        # But 'household_time_allocation' is returned by _phase_decisions and stored in WorldState (self.world_state.household_time_allocation).
+        # We can access it via self.world_state if needed, but 'state' arg here is SimulationState DTO.
+        # SimulationState doesn't have it.
+        # But we updated WorldState in run_tick: `state.household_time_allocation = household_time_allocation`.
+        # So we can access self.world_state.household_time_allocation.
+
+        commerce_context: CommerceContext = {
+            "households": state.households,
+            "agents": state.agents,
+            "breeding_planner": self.world_state.breeding_planner,
+            "household_time_allocation": getattr(self.world_state, "household_time_allocation", {}),
+            "reflux_system": state.reflux_system,
+            "market_data": state.market_data,
+            "config": state.config_module,
+            "time": state.time
+        }
+
+        if self.world_state.commerce_system:
+            leisure_effects = self.world_state.commerce_system.finalize_consumption_and_leisure(
+                commerce_context, state.planned_consumption
+            )
+            # Store effects for learning?
+            # Learning update happens in Post-Tick.
+            # We should probably store this somewhere.
+            # The original code returned it from execute_consumption_and_leisure and used it in Learning Update.
+            # In run_tick, we need `household_leisure_effects` variable.
+            # We should store it in SimulationState or WorldState?
+            # WorldState seems appropriate for transient tick data.
+            self.world_state.household_leisure_effects = leisure_effects
+
     def prepare_market_data(self, tracker: EconomicIndicatorTracker) -> Dict[str, Any]:
         """현재 틱의 시장 데이터를 에이전트의 의사결정을 위해 준비합니다."""
         state = self.world_state
