diff --git a/config.py b/config.py
index 610e268..0de465d 100644
--- a/config.py
+++ b/config.py
@@ -775,3 +775,19 @@ RL_DISCOUNT_FACTOR = 0.95
 # ==============================================================================
 MACRO_PORTFOLIO_ADJUSTMENT_ENABLED = True
 BAILOUT_REPAYMENT_RATIO = 0.5
+
+# --- Newborn Configuration ---
+NEWBORN_INITIAL_NEEDS = {
+    "survival": 60.0,
+    "asset": 10.0,
+    "social": 20.0,
+    "improvement": 10.0,
+    "survival_need": 60.0,
+    "recognition_need": 20.0,
+    "growth_need": 10.0,
+    "wealth_need": 10.0,
+    "imitation_need": 15.0,
+    "labor_need": 0.0,
+    "child_rearing_need": 0.0,
+    "quality": 0.0,
+}
diff --git a/modules/household/dtos.py b/modules/household/dtos.py
index 5cbb990..e1ce5b1 100644
--- a/modules/household/dtos.py
+++ b/modules/household/dtos.py
@@ -65,3 +65,8 @@ class SocialContextDTO:
     """Context for social operations."""
     current_time: int
     market_data: Optional[Dict[str, Any]] = None
+
+@dataclass
+class LifecycleDTO:
+    """State data required for lifecycle updates."""
+    is_employed: bool
diff --git a/simulation/components/agent_lifecycle.py b/simulation/components/agent_lifecycle.py
index aca97c3..2aa2b62 100644
--- a/simulation/components/agent_lifecycle.py
+++ b/simulation/components/agent_lifecycle.py
@@ -17,14 +17,14 @@ class AgentLifecycleComponent(IAgentLifecycleComponent):
         """
         Orchestrates the household's tick-level updates.
         """
-        household = context["household"]
+        state = context["state"]
         market_data = context["market_data"]
         time = context["time"]
 
         # 1. Work (via LaborManager)
         # Assuming a fixed 8 hours of work per tick if employed
-        work_hours = 8.0 if household.is_employed else 0.0
-        household.labor_manager.work(work_hours)
+        work_hours = 8.0 if state.is_employed else 0.0
+        self.owner.labor_manager.work(work_hours)
 
         # 2. Consume (via EconomyManager/CommerceSystem)
         # Consumption is now handled by CommerceSystem before calling update_needs.
@@ -33,7 +33,7 @@ class AgentLifecycleComponent(IAgentLifecycleComponent):
         # The logic flow is: CommerceSystem -> execute consumption -> household.update_needs -> Lifecycle.run_tick
 
         # 3. Pay Taxes (via EconomyManager)
-        household.economy_manager.pay_taxes()
+        self.owner.economy_manager.pay_taxes()
 
         # 4. Update Psychological Needs (via PsychologyComponent)
-        household.psychology.update_needs(time, market_data)
+        self.owner.psychology.update_needs(time, market_data)
diff --git a/simulation/components/labor_manager.py b/simulation/components/labor_manager.py
index d6b817e..6333b6f 100644
--- a/simulation/components/labor_manager.py
+++ b/simulation/components/labor_manager.py
@@ -29,20 +29,26 @@ class LaborManager:
 
     def work(self, hours: float) -> LaborResult:
         """
-        Executes work for a given number of hours, earning income.
+        Executes work for a given number of hours.
+
+        CRITICAL ARCHITECTURE NOTE (Sacred Sequence):
+        - Financial transactions (Wages) are handled in Phase 3 (Transactions) by TransactionProcessor.
+        - This method runs in Phase 4 (Lifecycle).
+        - Therefore, this method MUST NOT modify assets or record income to prevent double-counting/leaks (TD-115).
+        - It is strictly for updating non-financial state (e.g. skill XP, fatigue).
 
         Args:
             hours: The number of hours to work.
 
         Returns:
-            A LaborResult DTO containing the hours worked and income earned.
+            A LaborResult DTO containing the hours worked and income earned (theoretical/informational).
         """
         if not self._household.is_employed or self._household.employer_id is None:
             return LaborResult(hours_worked=0, income_earned=0)
 
         income = self._household.current_wage * hours
-        self._household.adjust_assets(income)
-        self._household.add_labor_income(income)
+        # WO-124: Explicitly removed asset modification.
+
         return LaborResult(hours_worked=hours, income_earned=income)
 
     def search_job(self) -> None:
diff --git a/simulation/core_agents.py b/simulation/core_agents.py
index f6d365f..5a9ccb4 100644
--- a/simulation/core_agents.py
+++ b/simulation/core_agents.py
@@ -801,8 +801,12 @@ class Household(BaseAgent, ILearningAgent):
     @override
     def update_needs(self, current_tick: int, market_data: Optional[Dict[str, Any]] = None):
         """Delegates lifecycle updates to BioComponent."""
+        from modules.household.dtos import LifecycleDTO
+        lifecycle_state = LifecycleDTO(
+            is_employed=self.is_employed
+        )
         context: LifecycleContext = {
-            "household": self, # Some lifecycle logic might still need 'self' to access properties
+            "state": lifecycle_state,
             "market_data": market_data if market_data else {},
             "time": current_tick
         }
diff --git a/simulation/initialization/initializer.py b/simulation/initialization/initializer.py
index af88c18..c3ae1e8 100644
--- a/simulation/initialization/initializer.py
+++ b/simulation/initialization/initializer.py
@@ -227,6 +227,7 @@ class SimulationInitializer(SimulationInitializerInterface):
         sim.ma_manager = MAManager(sim, self.config)
         sim.reflux_system = EconomicRefluxSystem()
         sim.demographic_manager = DemographicManager(config_module=self.config)
+        sim.demographic_manager.settlement_system = sim.settlement_system # Inject SettlementSystem
         sim.immigration_manager = ImmigrationManager(config_module=self.config)
         sim.inheritance_manager = InheritanceManager(config_module=self.config)
         sim.housing_system = HousingSystem(config_module=self.config)
diff --git a/simulation/systems/api.py b/simulation/systems/api.py
index 19ac36b..48095f2 100644
--- a/simulation/systems/api.py
+++ b/simulation/systems/api.py
@@ -23,6 +23,7 @@ if TYPE_CHECKING:
     from simulation.dtos.scenario import StressScenarioConfig
     from simulation.dtos.api import SimulationState
     from simulation.models import Transaction
+    from modules.household.dtos import LifecycleDTO
 
 
 # ===================================================================
@@ -62,7 +63,7 @@ class CommerceContext(TypedDict):
 
 class LifecycleContext(TypedDict):
     """에이전트 생명주기 관리에 필요한 데이터입니다."""
-    household: 'Household' # 개별 가계를 대상으로 실행
+    state: 'LifecycleDTO' # WO-124: Replaces household instance
     market_data: Dict[str, Any]
     time: int
 
diff --git a/simulation/systems/demographic_manager.py b/simulation/systems/demographic_manager.py
index 0ce3e19..ef4d590 100644
--- a/simulation/systems/demographic_manager.py
+++ b/simulation/systems/demographic_manager.py
@@ -25,6 +25,7 @@ class DemographicManager:
 
         self.config_module = config_module
         self.logger = logging.getLogger("simulation.systems.demographic_manager")
+        self.settlement_system: Optional[Any] = None # Injected via Initializer
         self.initialized = True
         self.logger.info("DemographicManager initialized.")
 
@@ -95,8 +96,7 @@ class DemographicManager:
             # "Initial 자산은 부모 자산의 일부 이전"
             initial_gift = max(0.0, min(parent.assets * 0.1, parent.assets))
 
-            # Atomic Transaction: Subtract -> Create -> Add back on failure
-            parent._sub_assets(initial_gift)
+            # WO-124: Removed direct asset modification. Transfer happens via SettlementSystem after creation.
 
             try:
                 # Create Instance
@@ -159,11 +159,12 @@ class DemographicManager:
                 if not initial_needs_for_newborn:
                     self.logger.warning("NEWBORN_INITIAL_NEEDS not found in config. Newborns may be inactive.")
 
+                # WO-124: Instantiate with 0 assets. Gift is transferred via SettlementSystem.
                 child = Household(
                     id=child_id,
                     talent=child_talent,
                     goods_data=simulation.goods_data,
-                    initial_assets=initial_gift,
+                    initial_assets=0.0,
                     initial_needs=initial_needs_for_newborn.copy(),
                     decision_engine=new_decision_engine,
                     value_orientation=value_orientation,
@@ -192,16 +193,25 @@ class DemographicManager:
                 parent.children_ids.append(child_id)
                 new_children.append(child)
 
+                # WO-124: Transfer Birth Gift via SettlementSystem
+                if initial_gift > 0:
+                    # Prefer injected settlement_system, fallback to simulation object for compatibility
+                    settlement = self.settlement_system or getattr(simulation, "settlement_system", None)
+
+                    if settlement:
+                         settlement.transfer(parent, child, initial_gift, "BIRTH_GIFT")
+                    else:
+                         self.logger.error("BIRTH_ERROR | SettlementSystem not found. Cannot transfer birth gift.")
+
                 self.logger.info(
                     f"BIRTH | Parent {parent.id} ({parent.age:.1f}y) -> Child {child.id}. "
                     f"Assets: {initial_gift:.2f}",
                     extra={"parent_id": parent.id, "child_id": child.id, "tick": simulation.time}
                 )
             except Exception as e:
-                # Rollback transaction on failure to prevent asset leak
-                parent._add_assets(initial_gift)
+                # No asset rollback needed as transfer happens after success.
                 self.logger.error(
-                    f"BIRTH_FAILED | Failed to create child for parent {parent.id}. Rolled back {initial_gift:.2f}. Error: {e}",
+                    f"BIRTH_FAILED | Failed to create child for parent {parent.id}. Error: {e}",
                     extra={"parent_id": parent.id, "error": str(e)}
                 )
                 continue
diff --git a/tests/components/test_agent_lifecycle.py b/tests/components/test_agent_lifecycle.py
index c7bf726..5958b2a 100644
--- a/tests/components/test_agent_lifecycle.py
+++ b/tests/components/test_agent_lifecycle.py
@@ -2,6 +2,7 @@ import pytest
 from unittest.mock import MagicMock
 from simulation.components.agent_lifecycle import AgentLifecycleComponent
 from simulation.systems.api import LifecycleContext
+from modules.household.dtos import LifecycleDTO
 
 @pytest.fixture
 def lifecycle_component():
@@ -18,8 +19,9 @@ def test_run_tick_execution_order(lifecycle_component):
     household.economy_manager = MagicMock()
     household.psychology = MagicMock()
 
+    state = LifecycleDTO(is_employed=household.is_employed)
     context: LifecycleContext = {
-        "household": household,
+        "state": state,
         "market_data": {},
         "time": 1
     }
@@ -39,8 +41,9 @@ def test_run_tick_unemployed(lifecycle_component):
     household.economy_manager = MagicMock()
     household.psychology = MagicMock()
 
+    state = LifecycleDTO(is_employed=household.is_employed)
     context: LifecycleContext = {
-        "household": household,
+        "state": state,
         "market_data": {},
         "time": 1
     }
diff --git a/tests/systems/test_demographic_manager_newborn.py b/tests/systems/test_demographic_manager_newborn.py
index c22f2a1..86a055b 100644
--- a/tests/systems/test_demographic_manager_newborn.py
+++ b/tests/systems/test_demographic_manager_newborn.py
@@ -84,6 +84,7 @@ def mock_simulation():
     sim.ai_trainer.get_engine.return_value = MagicMock()
     sim.markets = {"loan_market": MagicMock()}
     sim.goods_data = [{"id": "food"}, {"id": "housing"}] # Assuming this is sufficient
+    sim.settlement_system = MagicMock()
 
     # Mock the AI Training Manager for brain inheritance
     type(sim).ai_training_manager = PropertyMock(return_value=MagicMock())
@@ -140,4 +141,10 @@ def test_newborn_receives_initial_needs_from_config(mock_config, mock_simulation
     assert child.age == 0.0
 
     # Verify asset transfer happened
-    parent_agent._sub_assets.assert_called_once_with(parent_agent.assets * 0.1)
+    expected_gift = parent_agent.assets * 0.1
+    # Check if transfer was called on the mock simulation's settlement system
+    # Since we didn't inject into manager.settlement_system in this test (it's None),
+    # the manager falls back to simulation.settlement_system (which is mock_simulation.settlement_system)
+    mock_simulation.settlement_system.transfer.assert_called_once_with(
+        parent_agent, child, expected_gift, "BIRTH_GIFT"
+    )
