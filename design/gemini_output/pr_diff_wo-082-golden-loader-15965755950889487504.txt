diff --git a/scripts/fixture_harvester.py b/scripts/fixture_harvester.py
index 3bd86fd..ba9001a 100644
--- a/scripts/fixture_harvester.py
+++ b/scripts/fixture_harvester.py
@@ -21,10 +21,24 @@ Usage:
 
 import json
 import os
+import sys
 from dataclasses import dataclass, asdict
 from typing import List, Dict, Any, Optional, Type
 from datetime import datetime
 from pathlib import Path
+from unittest.mock import MagicMock
+
+# Attempt to import the new generic loader
+try:
+    from tests.utils.golden_loader import GoldenLoader as GenericGoldenLoader
+except ImportError:
+    # If not in path (e.g. running script directly from shell), try adding root
+    sys.path.append(os.getcwd())
+    try:
+        from tests.utils.golden_loader import GoldenLoader as GenericGoldenLoader
+    except ImportError:
+        # Fallback if tests/utils/golden_loader.py is missing or unreachable
+        GenericGoldenLoader = None
 
 
 @dataclass
@@ -194,8 +208,11 @@ class GoldenLoader:
     @classmethod
     def load(cls, filepath: str) -> "GoldenLoader":
         """Load a golden fixture from file."""
-        with open(filepath, 'r', encoding='utf-8') as f:
-            data = json.load(f)
+        if GenericGoldenLoader:
+            data = GenericGoldenLoader.load_json(filepath)
+        else:
+             with open(filepath, 'r', encoding='utf-8') as f:
+                data = json.load(f)
         return cls(data)
     
     def create_household_mocks(self, mock_class=None):
@@ -204,27 +221,33 @@ class GoldenLoader:
         
         Args:
             mock_class: Optional - The actual Household class to use.
-                       If None, creates SimpleNamespace objects.
+                       If None, creates SimpleNamespace objects (legacy behavior) or MagicMock if generic loader used.
         """
-        from types import SimpleNamespace
-        from unittest.mock import MagicMock
-        
         mocks = []
         for h_data in self.households_data:
-            if mock_class:
-                # Create a MagicMock with spec but set real values
-                mock = MagicMock(spec=mock_class)
+            if GenericGoldenLoader:
+                # Use GenericGoldenLoader to do the basic conversion
+                mock = GenericGoldenLoader.dict_to_mock(h_data, spec=mock_class)
             else:
-                mock = SimpleNamespace()
-            
-            # Set all attributes from golden data
-            for key, value in h_data.items():
-                setattr(mock, key, value)
-            
+                # Fallback to old logic
+                from types import SimpleNamespace
+                if mock_class:
+                    mock = MagicMock(spec=mock_class)
+                else:
+                    mock = SimpleNamespace()
+                for key, value in h_data.items():
+                    setattr(mock, key, value)
+
             # Add standard mock methods
+            # logic methods are never in data, so we can safely set them
             mock.make_decision = MagicMock(return_value=([], MagicMock()))
-            mock.decision_engine = MagicMock()
-            mock.decision_engine.ai_engine = MagicMock()
+
+            # Ensure complex nested mocks exist
+            # (Explicitly setting them ensures they exist even if we use SimpleNamespace in fallback)
+            if not hasattr(mock, 'decision_engine'):
+                mock.decision_engine = MagicMock()
+            if not hasattr(mock.decision_engine, 'ai_engine'):
+                mock.decision_engine.ai_engine = MagicMock()
             
             mocks.append(mock)
         
@@ -236,30 +259,39 @@ class GoldenLoader:
         
         Args:
             mock_class: Optional - The actual Firm class to use.
-                       If None, creates SimpleNamespace objects.
+                       If None, creates SimpleNamespace objects (legacy behavior) or MagicMock if generic loader used.
         """
-        from types import SimpleNamespace
-        from unittest.mock import MagicMock
-        
         mocks = []
         for f_data in self.firms_data:
-            if mock_class:
-                mock = MagicMock(spec=mock_class)
+            if GenericGoldenLoader:
+                mock = GenericGoldenLoader.dict_to_mock(f_data, spec=mock_class)
             else:
-                mock = SimpleNamespace()
-            
-            # Set all attributes from golden data
-            for key, value in f_data.items():
-                setattr(mock, key, value)
+                from types import SimpleNamespace
+                if mock_class:
+                    mock = MagicMock(spec=mock_class)
+                else:
+                    mock = SimpleNamespace()
+                for key, value in f_data.items():
+                    setattr(mock, key, value)
             
             # Add required mock methods
             mock.make_decision = MagicMock(return_value=([], MagicMock()))
-            mock.decision_engine = MagicMock()
-            mock.decision_engine.ai_engine = MagicMock()
-            mock.hr = MagicMock()
-            mock.hr.employees = []  # Empty list since we only store count
+
+            if not hasattr(mock, 'decision_engine'):
+                mock.decision_engine = MagicMock()
+            if not hasattr(mock.decision_engine, 'ai_engine'):
+                mock.decision_engine.ai_engine = MagicMock()
+
+            # HR logic
+            if not hasattr(mock, 'hr'):
+                mock.hr = MagicMock()
+
+            # If employees wasn't in data (it's not in snapshot, only count is), ensure it's empty list
+            # We must force this because MagicMock would return a Mock object for 'employees' otherwise
+            mock.hr.employees = []
             
             # Add get_financial_snapshot based on captured data
+            # Logic method, always mock it
             mock.get_financial_snapshot = MagicMock(return_value={
                 "total_assets": f_data.get("assets", 0) + sum(f_data.get("inventory", {}).values()) * 10,
                 "working_capital": f_data.get("assets", 0),
@@ -274,11 +306,14 @@ class GoldenLoader:
     
     def create_config_mock(self):
         """Create a mock config module from golden data."""
-        from types import SimpleNamespace
-        mock = SimpleNamespace()
-        for key, value in self.config_snapshot.items():
-            setattr(mock, key, value)
-        return mock
+        if GenericGoldenLoader:
+            return GenericGoldenLoader.dict_to_mock(self.config_snapshot)
+        else:
+            from types import SimpleNamespace
+            mock = SimpleNamespace()
+            for key, value in self.config_snapshot.items():
+                setattr(mock, key, value)
+            return mock
 
 
 # Convenience function for quick harvesting during debug
diff --git a/tests/utils/__init__.py b/tests/utils/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/tests/utils/golden_loader.py b/tests/utils/golden_loader.py
new file mode 100644
index 0000000..c61a7a8
--- /dev/null
+++ b/tests/utils/golden_loader.py
@@ -0,0 +1,56 @@
+from unittest.mock import MagicMock
+from typing import Dict, Type, Any, Union, List
+import json
+import os
+
+class GoldenLoader:
+    """
+    Utility to load JSON fixtures and convert them to MagicMock objects.
+    """
+
+    @staticmethod
+    def load_json(path: str) -> Dict[str, Any]:
+        """
+        Safely loads JSON files from the filesystem.
+
+        Args:
+            path: Path to the JSON file.
+
+        Returns:
+            Dict containing the loaded JSON data.
+
+        Raises:
+            FileNotFoundError: If the file does not exist.
+        """
+        if not os.path.exists(path):
+            raise FileNotFoundError(f"Golden fixture not found at: {path}")
+
+        with open(path, 'r', encoding='utf-8') as f:
+            return json.load(f)
+
+    @staticmethod
+    def dict_to_mock(data: Any, spec: Type = None) -> Any:
+        """
+        Recursively converts nested dictionaries into nested MagicMock objects.
+
+        Args:
+            data: The dictionary or list to convert.
+            spec: Optional class to use as the spec for the created Mock (only for the top-level dict).
+                  Nested dictionaries will be converted to generic MagicMocks.
+
+        Returns:
+            MagicMock object if input is a dict.
+            List of objects/Mocks if input is a list.
+            Original value if input is a primitive.
+        """
+        if isinstance(data, dict):
+            mock = MagicMock(spec=spec)
+            for key, value in data.items():
+                # Recursively convert value
+                child = GoldenLoader.dict_to_mock(value)
+                setattr(mock, key, child)
+            return mock
+        elif isinstance(data, list):
+            return [GoldenLoader.dict_to_mock(item) for item in data]
+        else:
+            return data
diff --git a/tests/utils/test_golden_loader.py b/tests/utils/test_golden_loader.py
new file mode 100644
index 0000000..7d83351
--- /dev/null
+++ b/tests/utils/test_golden_loader.py
@@ -0,0 +1,67 @@
+import unittest
+import os
+import json
+from unittest.mock import MagicMock
+from tests.utils.golden_loader import GoldenLoader
+
+class TestGoldenLoader(unittest.TestCase):
+    def setUp(self):
+        self.test_file = "test_fixture.json"
+        self.data = {
+            "name": "Test Agent",
+            "attributes": {
+                "age": 30,
+                "skills": ["coding", "testing"]
+            },
+            "history": [
+                {"year": 2020, "event": "hired"},
+                {"year": 2021, "event": "promoted"}
+            ]
+        }
+        with open(self.test_file, 'w') as f:
+            json.dump(self.data, f)
+
+    def tearDown(self):
+        if os.path.exists(self.test_file):
+            os.remove(self.test_file)
+
+    def test_load_json(self):
+        loaded = GoldenLoader.load_json(self.test_file)
+        self.assertEqual(loaded, self.data)
+
+    def test_load_json_not_found(self):
+        with self.assertRaises(FileNotFoundError):
+            GoldenLoader.load_json("non_existent_file.json")
+
+    def test_dict_to_mock_basic(self):
+        mock = GoldenLoader.dict_to_mock(self.data)
+        self.assertIsInstance(mock, MagicMock)
+        self.assertEqual(mock.name, "Test Agent")
+        self.assertIsInstance(mock.attributes, MagicMock)
+        self.assertEqual(mock.attributes.age, 30)
+        self.assertEqual(mock.attributes.skills, ["coding", "testing"])
+
+    def test_dict_to_mock_nested_list(self):
+        mock = GoldenLoader.dict_to_mock(self.data)
+        self.assertIsInstance(mock.history, list)
+        self.assertEqual(len(mock.history), 2)
+        self.assertIsInstance(mock.history[0], MagicMock)
+        self.assertEqual(mock.history[0].year, 2020)
+        self.assertEqual(mock.history[1].event, "promoted")
+
+    def test_dict_to_mock_with_spec(self):
+        class Agent:
+            pass
+
+        mock = GoldenLoader.dict_to_mock(self.data, spec=Agent)
+        self.assertIsInstance(mock, MagicMock)
+        # Verify spec is set (isinstance checks against the spec class usually work for Mocks with spec)
+        self.assertIsInstance(mock, Agent)
+
+        # Check data is still there
+        self.assertEqual(mock.name, "Test Agent")
+
+    def test_primitives(self):
+        self.assertEqual(GoldenLoader.dict_to_mock(123), 123)
+        self.assertEqual(GoldenLoader.dict_to_mock("string"), "string")
+        self.assertEqual(GoldenLoader.dict_to_mock(None), None)
