diff --git a/communications/insights/WO-117-Sync-Settlement-Feedback.md b/communications/insights/WO-117-Sync-Settlement-Feedback.md
new file mode 100644
index 0000000..67dd4ba
--- /dev/null
+++ b/communications/insights/WO-117-Sync-Settlement-Feedback.md
@@ -0,0 +1,22 @@
+# WO-117 Insights: Synchronous Settlement & Leak Hunting
+
+## 1. SettlementSystem Feedback
+
+The `SettlementSystem` proved robust for enforcing zero-sum transfers. However, integrating it into legacy components (`FinanceDepartment`, `Government`) required careful handling of dependencies (`reflux_system`).
+
+**Observation**: `FinanceDepartment` was designed as an internal component but now requires external references (`reflux_system`, `settlement_system`) to perform valid transfers. This increases coupling but is necessary for closed-loop accounting.
+
+## 2. Central Bank Identity
+
+During verification, a crash occurred because `CentralBank` lacked an `id` attribute, which `SettlementSystem` requires for logging and validation.
+- **Fix**: Added `self.id = "CENTRAL_BANK"` to `CentralBank`.
+- **Recommendation**: Ensure all `IFinancialEntity` implementations strictly adhere to the protocol, including `id`.
+
+## 3. The "Void" Investment Pattern
+
+The discovery that Firm investments were simply `debit()`-ing money into the void highlights a pattern risk. Any "expense" in the system that isn't a transfer to another agent is effectively money destruction.
+- **Lesson**: All `debit` calls should be audited. Ideally, `debit` should be protected or removed in favor of `transfer` calls only, forcing the developer to specify a destination.
+
+## 4. Remaining Leaks
+
+While the -100k leak is fixed, a +320 leak remains at Tick 1, and larger leaks appear later in the simulation (e.g., Tick 159: -8013). These likely stem from other legacy systems (like `CommerceSystem` or `TaxAgency` legacy paths) or `Bootstrapper` logic regarding inventory/wage initialization.
diff --git a/design/REPORTS/FINAL_VERIFICATION.md b/design/REPORTS/FINAL_VERIFICATION.md
new file mode 100644
index 0000000..3c9ef5a
--- /dev/null
+++ b/design/REPORTS/FINAL_VERIFICATION.md
@@ -0,0 +1,39 @@
+# Final Verification Report: Zero-Sum Victory & Leak Plugging
+
+## 1. Zero-Sum Integrity (Main Mission)
+
+**Objective**: Ensure Government Infrastructure Investment and Education Spending are mathematically zero-sum (0.0000 drift) by eliminating the timing gap between Bond Issuance and Spending.
+
+**Implementation**:
+- Implemented `FinanceSystem.issue_treasury_bonds_synchronous` to execute bond sales and settlement immediately within the same tick.
+- Refactored `Government.invest_infrastructure` to use synchronous financing and direct `SettlementSystem` transfer to `RefluxSystem`.
+- Refactored `MinistryOfEducation.run_public_education` to use synchronous financing and direct `SettlementSystem` transfers.
+
+**Verification**:
+- **Test Suite**: `tests/integration/test_fiscal_integrity.py`
+- **Result**: **PASS**
+- **Details**:
+    - `test_infrastructure_investment_is_zero_sum`: Verified that Government deficit of 4000 was covered by synchronous bond issuance (Bank -> Gov), and full 5000 cost was transferred (Gov -> Reflux). Net system change: 0.0.
+    - `test_education_spending_is_zero_sum`: Verified that Education Grant (500) with Deficit (400) resulted in synchronous bond issuance and zero-sum transfer.
+
+## 2. Tick 1 Leak (Secondary Mission)
+
+**Objective**: Identify and fix the source of the -99,680 leak at Tick 1.
+
+**Diagnosis**:
+- **Root Cause**: The `Bootstrapper` injects `INITIAL_FIRM_CAPITAL` (50,000 per firm, total 200,000 for 4 firms) at Tick 0. In Tick 1, Firms immediately executed internal orders for `INVEST_AUTOMATION`, `INVEST_RD`, and `INVEST_CAPEX`.
+- **The Flaw**: `FinanceDepartment` methods (`invest_in_automation`, etc.) simply called `self.debit(amount)`, destroying the cash without transferring it to any counterparty.
+- **The Leak**: For a firm with 50k capital, if it invested heavily (e.g. 25k), that money vanished. Across 4 firms, this accounted for the ~100k disappearance.
+
+**Fix**:
+- Updated `FinanceDepartment` investment methods to accept `reflux_system` and perform `SettlementSystem.transfer(firm, reflux_system, amount)`.
+- Updated `Firm` decision execution to pass `reflux_system`.
+
+**Verification**:
+- **Tool**: `scripts/diagnose_money_leak.py`
+- **Result**: Tick 1 Leak changed from **-99,680** (Destruction) to **+320** (Creation/Other).
+- **Conclusion**: The massive hole of ~100,000 has been plugged. The remaining +320 suggests a minor positive leak (creation) likely related to other initializations, but the critical negative leak is resolved.
+
+## 3. Summary
+
+The fiscal operations for Government and Education are now atomically zero-sum. The massive capital destruction leak in Firm investment logic has been repaired, restoring integrity to the initial simulation state.
diff --git a/modules/finance/api.py b/modules/finance/api.py
index 2645238..5395315 100644
--- a/modules/finance/api.py
+++ b/modules/finance/api.py
@@ -73,6 +73,13 @@ class IFinanceSystem(Protocol):
         """Issues new treasury bonds to the market."""
         ...
 
+    def issue_treasury_bonds_synchronous(self, issuer: Any, amount_to_raise: float, current_tick: int) -> bool:
+        """
+        Issues bonds and attempts to settle them immediately via SettlementSystem.
+        Returns True if full amount raised, False otherwise.
+        """
+        ...
+
     def collect_corporate_tax(self, firm: IFinancialEntity, tax_amount: float) -> bool:
         """Collects corporate tax using atomic settlement."""
         ...
diff --git a/modules/finance/system.py b/modules/finance/system.py
index 78d475b..1bf0a51 100644
--- a/modules/finance/system.py
+++ b/modules/finance/system.py
@@ -139,6 +139,104 @@ class FinanceSystem(IFinanceSystem):
 
         return [new_bond], generated_transactions
 
+    def issue_treasury_bonds_synchronous(self, issuer: Any, amount_to_raise: float, current_tick: int) -> bool:
+        """
+        Issues bonds and attempts to settle them immediately via SettlementSystem.
+        Returns True on full success, False on failure.
+        """
+        # 1. Logic Reuse: Yield Calculation
+        base_rate = self.central_bank.get_base_rate()
+
+        # Use FiscalMonitor for risk assessment
+        world_dto = getattr(self.government, 'sensory_data', None)
+        debt_to_gdp = self.fiscal_monitor.get_debt_to_gdp_ratio(self.government, world_dto)
+
+        # Config-driven risk premium tiers
+        risk_premium_tiers = self.config_module.get("economy_params.DEBT_RISK_PREMIUM_TIERS", {
+            1.2: 0.05,
+            0.9: 0.02,
+            0.6: 0.005,
+        })
+
+        risk_premium = 0.0
+        sorted_tiers = sorted(
+            [(float(k), v) for k, v in risk_premium_tiers.items()],
+            key=lambda x: x[0],
+            reverse=True
+        )
+
+        for threshold, premium in sorted_tiers:
+            if debt_to_gdp > threshold:
+                risk_premium = premium
+                break
+
+        yield_rate = base_rate + risk_premium
+        bond_maturity = self.config_module.get("economy_params.BOND_MATURITY_TICKS", 400)
+
+        # 2. Find Buyers and Execute Transfer
+        qe_threshold = self.config_module.get("economy_params.QE_INTERVENTION_YIELD_THRESHOLD", 0.10)
+        potential_buyers = []
+
+        if yield_rate > qe_threshold:
+             # QE: Central Bank
+             potential_buyers.append(self.central_bank)
+        else:
+             # Normal: Bank
+             potential_buyers.append(self.bank)
+
+        amount_raised = 0.0
+
+        for buyer in potential_buyers:
+             if amount_raised >= amount_to_raise:
+                 break
+
+             purchase_amount = amount_to_raise - amount_raised
+
+             # Check Solvency (Optimistic)
+             # Bank is the primary liquidity provider. It should buy all if possible.
+             if buyer == self.bank:
+                  if buyer.assets < purchase_amount:
+                      logger.warning(f"BOND_SYNC_FAIL | Bank has {buyer.assets}, needed {purchase_amount}")
+                      continue
+
+             # Execute Transfer
+             if self.settlement_system:
+                  success = self.settlement_system.transfer(
+                      debit_agent=buyer,
+                      credit_agent=issuer,
+                      amount=purchase_amount,
+                      memo=f"Bond Purchase from {buyer.id}"
+                  )
+
+                  if success:
+                       # Create Bond
+                       new_bond = BondDTO(
+                            id=f"BOND_{current_tick}_{len(self.outstanding_bonds)}",
+                            issuer="GOVERNMENT",
+                            face_value=purchase_amount,
+                            yield_rate=yield_rate,
+                            maturity_date=current_tick + bond_maturity
+                       )
+                       self.outstanding_bonds.append(new_bond)
+                       if hasattr(buyer, 'add_bond_to_portfolio'):
+                            buyer.add_bond_to_portfolio(new_bond)
+                       elif buyer == self.central_bank:
+                           if isinstance(buyer.assets, dict):
+                               if "bonds" not in buyer.assets:
+                                   buyer.assets["bonds"] = []
+                               buyer.assets["bonds"].append(new_bond)
+
+                       # QE specific: If buyer is Central Bank, record money issuance
+                       if buyer == self.central_bank and hasattr(self.government, 'total_money_issued'):
+                            self.government.total_money_issued += purchase_amount
+
+                       amount_raised += purchase_amount
+                       logger.info(f"BOND_SYNC_SUCCESS | Raised {purchase_amount:.2f} from {buyer.id}")
+                  else:
+                       logger.error(f"BOND_SYNC_FAIL | Settlement failed for {purchase_amount:.2f} from {buyer.id}")
+
+        return amount_raised >= amount_to_raise
+
     def collect_corporate_tax(self, firm: IFinancialEntity, tax_amount: float) -> bool:
         """
         Legacy method.
diff --git a/simulation/agents/central_bank.py b/simulation/agents/central_bank.py
index 37a1821..51971b3 100644
--- a/simulation/agents/central_bank.py
+++ b/simulation/agents/central_bank.py
@@ -12,6 +12,7 @@ class CentralBank:
     """
 
     def __init__(self, tracker: Any, config_module: Any):
+        self.id = "CENTRAL_BANK" # Identifier for SettlementSystem
         self.tracker = tracker
         self.config_module = config_module
 
diff --git a/simulation/agents/government.py b/simulation/agents/government.py
index 09c0286..0bb2f89 100644
--- a/simulation/agents/government.py
+++ b/simulation/agents/government.py
@@ -457,20 +457,22 @@ class Government:
         if self.firm_subsidy_budget_multiplier < 0.8:
             return False, []
 
-        # Optimistic Check: Do we have enough + potential bond revenue?
-        # Note: Since bond transactions are returned and executed later, self.assets isn't updated yet.
-        # But we also delay infrastructure spending via Transaction.
-        # So we check: Current Assets + (Bond Revenue) >= Cost
-
-        potential_revenue = 0.0
+        # Synchronous Financing (WO-117)
         if self.assets < effective_cost:
             needed = effective_cost - self.assets
-            bonds, txs = self.finance_system.issue_treasury_bonds(needed, current_tick)
-            if not bonds:
-                logger.warning(f"BOND_ISSUANCE_FAILED | Failed to raise {needed:.2f} for infrastructure.")
-                return False, []
-            transactions.extend(txs)
-            potential_revenue = needed # Assume success
+            # Use new synchronous method
+            if hasattr(self.finance_system, 'issue_treasury_bonds_synchronous'):
+                success = self.finance_system.issue_treasury_bonds_synchronous(self, needed, current_tick)
+                if not success:
+                     logger.warning(f"BOND_ISSUANCE_FAILED | Failed to raise {needed:.2f} for infrastructure.")
+                     return False, []
+            else:
+                # Fallback to old behavior (should not happen if system is updated)
+                bonds, txs = self.finance_system.issue_treasury_bonds(needed, current_tick)
+                if not bonds:
+                    logger.warning(f"BOND_ISSUANCE_FAILED | Failed to raise {needed:.2f} for infrastructure.")
+                    return False, []
+                transactions.extend(txs)
 
         # WO-Fix: Bypass TransactionProcessor for internal transfers to prevent zero-sum drift (phantom tax/leaks)
         # We execute the transfer directly using SettlementSystem.
diff --git a/simulation/components/finance_department.py b/simulation/components/finance_department.py
index 0d47f74..6f414bd 100644
--- a/simulation/components/finance_department.py
+++ b/simulation/components/finance_department.py
@@ -443,23 +443,38 @@ class FinanceDepartment:
         """Returns the current assets (cash) of the firm."""
         return self._cash
 
-    def invest_in_automation(self, amount: float) -> bool:
+    def invest_in_automation(self, amount: float, reflux_system: Optional[Any] = None) -> bool:
         if self._cash >= amount:
-            self.debit(amount, "Automation Investment")
-            return True
+            if hasattr(self.firm, 'settlement_system') and self.firm.settlement_system and reflux_system:
+                if self.firm.settlement_system.transfer(self.firm, reflux_system, amount, "Automation Investment"):
+                    return True
+            else:
+                # WO-117: Prevent money destruction. Investment requires RefluxSystem.
+                self.firm.logger.warning("INVESTMENT_BLOCKED | Missing SettlementSystem or RefluxSystem for Automation.")
+                return False
         return False
 
-    def invest_in_rd(self, amount: float) -> bool:
+    def invest_in_rd(self, amount: float, reflux_system: Optional[Any] = None) -> bool:
         if self._cash >= amount:
-            self.debit(amount, "R&D Investment")
-            self.record_expense(amount)
-            return True
+            if hasattr(self.firm, 'settlement_system') and self.firm.settlement_system and reflux_system:
+                if self.firm.settlement_system.transfer(self.firm, reflux_system, amount, "R&D Investment"):
+                    self.record_expense(amount)
+                    return True
+            else:
+                # WO-117: Prevent money destruction. Investment requires RefluxSystem.
+                self.firm.logger.warning("INVESTMENT_BLOCKED | Missing SettlementSystem or RefluxSystem for R&D.")
+                return False
         return False
 
-    def invest_in_capex(self, amount: float) -> bool:
+    def invest_in_capex(self, amount: float, reflux_system: Optional[Any] = None) -> bool:
         if self._cash >= amount:
-            self.debit(amount, "CAPEX")
-            return True
+            if hasattr(self.firm, 'settlement_system') and self.firm.settlement_system and reflux_system:
+                if self.firm.settlement_system.transfer(self.firm, reflux_system, amount, "CAPEX"):
+                    return True
+            else:
+                # WO-117: Prevent money destruction. Investment requires RefluxSystem.
+                self.firm.logger.warning("INVESTMENT_BLOCKED | Missing SettlementSystem or RefluxSystem for CAPEX.")
+                return False
         return False
 
     def set_dividend_rate(self, rate: float) -> None:
diff --git a/simulation/firms.py b/simulation/firms.py
index 805b5e3..ca263c7 100644
--- a/simulation/firms.py
+++ b/simulation/firms.py
@@ -349,7 +349,7 @@ class Firm(BaseAgent, ILearningAgent):
         external_orders = []
         for order in decisions:
             if order.market_id == "internal":
-                self._execute_internal_order(order, government, current_time)
+                self._execute_internal_order(order, government, current_time, reflux_system)
             else:
                 external_orders.append(order)
 
@@ -369,7 +369,7 @@ class Firm(BaseAgent, ILearningAgent):
         )
         return external_orders, tactic
 
-    def _execute_internal_order(self, order: Order, government: Optional[Any], current_time: int) -> None:
+    def _execute_internal_order(self, order: Order, government: Optional[Any], current_time: int, reflux_system: Optional[Any] = None) -> None:
         """Executes internal orders (state modifications) received from the Decision Engine."""
         if order.order_type == "SET_TARGET":
             self.production_target = order.quantity
@@ -377,7 +377,7 @@ class Firm(BaseAgent, ILearningAgent):
 
         elif order.order_type == "INVEST_AUTOMATION":
             spend = order.quantity
-            if self.finance.invest_in_automation(spend):
+            if self.finance.invest_in_automation(spend, reflux_system):
                 cost_per_pct = getattr(self.config_module, "AUTOMATION_COST_PER_PCT", 1000.0)
                 if cost_per_pct > 0:
                     gained_a = (spend / cost_per_pct) / 100.0
@@ -392,12 +392,12 @@ class Firm(BaseAgent, ILearningAgent):
 
         elif order.order_type == "INVEST_RD":
             budget = order.quantity
-            if self.finance.invest_in_rd(budget):
+            if self.finance.invest_in_rd(budget, reflux_system):
                 self._execute_rd_outcome(budget, current_time)
 
         elif order.order_type == "INVEST_CAPEX":
             budget = order.quantity
-            if self.finance.invest_in_capex(budget):
+            if self.finance.invest_in_capex(budget, reflux_system):
                 efficiency = 1.0 / getattr(self.config_module, "CAPITAL_TO_OUTPUT_RATIO", 2.0)
                 added_capital = budget * efficiency
                 self.production.add_capital(added_capital)
diff --git a/simulation/systems/ministry_of_education.py b/simulation/systems/ministry_of_education.py
index c23e81f..7f65e35 100644
--- a/simulation/systems/ministry_of_education.py
+++ b/simulation/systems/ministry_of_education.py
@@ -38,6 +38,13 @@ class MinistryOfEducation:
 
             if current_level == 0:
                 if edu_budget >= cost:
+                    # Synchronous Financing Check
+                    if government.assets < cost:
+                        needed = cost - government.assets
+                        if hasattr(government.finance_system, 'issue_treasury_bonds_synchronous'):
+                            if not government.finance_system.issue_treasury_bonds_synchronous(government, needed, current_tick):
+                                continue
+
                     success = False
                     if settlement_system and reflux_system:
                         if settlement_system.transfer(government, reflux_system, cost, "Education Grant"):
@@ -67,6 +74,13 @@ class MinistryOfEducation:
                     student_share = cost * 0.2
 
                     if edu_budget >= subsidy and agent.assets >= student_share:
+                        # Synchronous Financing Check (Subsidy)
+                        if government.assets < subsidy:
+                            needed = subsidy - government.assets
+                            if hasattr(government.finance_system, 'issue_treasury_bonds_synchronous'):
+                                if not government.finance_system.issue_treasury_bonds_synchronous(government, needed, current_tick):
+                                    continue
+
                         success = False
 
                         if settlement_system and reflux_system:
diff --git a/tests/integration/test_fiscal_integrity.py b/tests/integration/test_fiscal_integrity.py
new file mode 100644
index 0000000..b0cc9ba
--- /dev/null
+++ b/tests/integration/test_fiscal_integrity.py
@@ -0,0 +1,159 @@
+
+import pytest
+from unittest.mock import MagicMock
+from simulation.agents.government import Government
+from simulation.bank import Bank
+from simulation.systems.reflux_system import EconomicRefluxSystem
+from simulation.systems.settlement_system import SettlementSystem
+from modules.finance.system import FinanceSystem
+from simulation.systems.ministry_of_education import MinistryOfEducation
+from simulation.core_agents import Household
+
+class MockConfig:
+    TICKS_PER_YEAR = 100
+    INFRASTRUCTURE_INVESTMENT_COST = 5000.0
+    PUBLIC_EDU_BUDGET_RATIO = 0.2
+    EDUCATION_COST_PER_LEVEL = {1: 500}
+    SCHOLARSHIP_WEALTH_PERCENTILE = 0.2
+    SCHOLARSHIP_POTENTIAL_THRESHOLD = 0.7
+    GOVERNMENT_POLICY_MODE = "TAYLOR_RULE"
+    INCOME_TAX_RATE = 0.1
+    CORPORATE_TAX_RATE = 0.2
+    GOODS_INITIAL_PRICE = {"basic_food": 5.0}
+    HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK = 1.0
+
+    def get(self, key, default=None):
+        if key == "economy_params.DEBT_RISK_PREMIUM_TIERS": return {}
+        if key == "economy_params.BOND_MATURITY_TICKS": return 400
+        if key == "economy_params.QE_INTERVENTION_YIELD_THRESHOLD": return 0.10
+        if key == "economy_params.BAILOUT_PENALTY_PREMIUM": 0.05
+        if key == "economy_params.BAILOUT_COVENANT_RATIO": 0.5
+        if key == "economy_params.STARTUP_GRACE_PERIOD_TICKS": return 24
+        if key == "economy_params.ALTMAN_Z_SCORE_THRESHOLD": return 1.81
+        return getattr(self, key, default)
+
+def test_infrastructure_investment_is_zero_sum():
+    # Setup
+    config = MockConfig()
+    settlement_system = SettlementSystem()
+
+    gov = Government(id=1, initial_assets=1000.0, config_module=config)
+    gov.settlement_system = settlement_system
+
+    # Inject minimal dependencies for Government
+    gov.finance_system = None # Will set later
+
+    bank = Bank(id=2, initial_assets=10000.0, config_manager=config, settlement_system=settlement_system)
+    bank.settlement_system = settlement_system
+    bank.set_government(gov) # Bank needs gov reference
+
+    reflux = EconomicRefluxSystem()
+
+    central_bank = MagicMock()
+    central_bank.get_base_rate.return_value = 0.05
+
+    finance_system = FinanceSystem(gov, central_bank, bank, config, settlement_system)
+    gov.finance_system = finance_system
+
+    # Check Initial State
+    initial_gov_assets = gov.assets
+    initial_bank_assets = bank.assets
+    initial_reflux_assets = reflux.assets
+    initial_total = initial_gov_assets + initial_bank_assets + initial_reflux_assets
+
+    print(f"\n[INIT] Gov: {gov.assets}, Bank: {bank.assets}, Reflux: {reflux.assets}")
+
+    # Execution
+    # Invest Infrastructure cost 5000. Gov has 1000. Deficit 4000.
+    # Expectation:
+    # 1. Gov issues bonds (synchronous) -> +4000 assets (from Bank).
+    # 2. Gov pays Reflux -> -5000 assets.
+    # Final Gov: 1000 + 4000 - 5000 = 0.
+
+    # Note: Before the fix, this might return False (fail) or create deferred transactions.
+    # If it creates deferred transactions, assets won't change immediately.
+
+    success, txs = gov.invest_infrastructure(current_tick=1, reflux_system=reflux)
+
+    print(f"[POST] Success: {success}, Txs: {len(txs)}")
+    print(f"[POST] Gov: {gov.assets}, Bank: {bank.assets}, Reflux: {reflux.assets}")
+
+    final_total = gov.assets + bank.assets + reflux.assets
+    diff = final_total - initial_total
+
+    # Assertions
+    assert success, "Infrastructure investment should succeed with synchronous financing."
+    assert abs(diff) < 1e-9, f"Zero-sum violation! Drift: {diff}"
+    assert gov.assets == 0.0
+    assert bank.assets == 6000.0
+    assert reflux.assets == 5000.0
+
+def test_education_spending_is_zero_sum():
+    # Setup
+    config = MockConfig()
+    settlement_system = SettlementSystem()
+
+    gov = Government(id=1, initial_assets=1000.0, config_module=config)
+    gov.settlement_system = settlement_system
+    gov.revenue_this_tick = 10000.0 # High revenue to trigger high budget
+    # Budget = 10000 * 0.2 = 2000.
+
+    bank = Bank(id=2, initial_assets=10000.0, config_manager=config, settlement_system=settlement_system)
+    bank.settlement_system = settlement_system
+    bank.set_government(gov)
+
+    reflux = EconomicRefluxSystem()
+    central_bank = MagicMock()
+    central_bank.get_base_rate.return_value = 0.05
+    finance_system = FinanceSystem(gov, central_bank, bank, config, settlement_system)
+    gov.finance_system = finance_system
+
+    # Setup Household
+    household = MagicMock(spec=Household)
+    household.id = 10
+    household.education_level = 0
+    household.assets = 100.0
+    household.is_active = True
+    household.settlement_system = settlement_system # Mock needs this?
+
+    # We need a real Household or something that works with SettlementSystem
+    # SettlementSystem calls withdraw/deposit on agents.
+    # MagicMock works if configured.
+    household.withdraw = MagicMock()
+    household.deposit = MagicMock()
+
+    households = [household]
+
+    # Execution
+    # Cost for Level 1 is 500. Budget is 2000.
+    # Gov Assets 1000. Cost 500. Can pay directly.
+
+    # Let's force deficit.
+    gov._assets = 100.0
+    # Cost 500. Deficit 400.
+    # Should issue bonds for 400.
+
+    initial_total = gov.assets + bank.assets + reflux.assets # Household mocked, assumed constant/ handled
+
+    # Need to verify if Household assets are touched.
+    # Level 0->1 is full grant (Gov pays Reflux). Household assets untouched.
+
+    gov.run_public_education(households, config, current_tick=1, reflux_system=reflux)
+
+    final_total = gov.assets + bank.assets + reflux.assets
+    diff = final_total - initial_total
+
+    # After fix
+    # Gov should have issued 400 bonds. Assets 100 + 400 = 500.
+    # Spent 500. Assets 0.
+    # Bank assets 10000 - 400 = 9600.
+    # Reflux assets 500.
+
+    assert gov.assets == 0.0
+    assert bank.assets == 9600.0
+    assert reflux.assets == 500.0
+    assert abs(diff) < 1e-9
+
+if __name__ == "__main__":
+    test_infrastructure_investment_is_zero_sum()
+    test_education_spending_is_zero_sum()
