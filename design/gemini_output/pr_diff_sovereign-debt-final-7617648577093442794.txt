diff --git a/communications/jules_logs/last_run.md b/communications/jules_logs/last_run.md
index deca570..e69de29 100644
--- a/communications/jules_logs/last_run.md
+++ b/communications/jules_logs/last_run.md
@@ -1,2 +0,0 @@
-INFO:JulesBridge:Message sent to session 7617648577093442794
-Message sent successfully to 7617648577093442794
diff --git a/communications/team_assignments.json b/communications/team_assignments.json
index c5bd406..0d418c1 100644
--- a/communications/team_assignments.json
+++ b/communications/team_assignments.json
@@ -6,8 +6,7 @@
       "5283327958326335498": "TD-024: Post-Fix Test Stabilization",
       "15420605320896780216": "TD-024: Pytest Infrastructure Fix",
       "15308963882295599607": "TD-024: Pytest Infrastructure Fix",
-      "15094787074309037083": "WO-068: Macro-Linked Portfolio",
-      "7617648577093442794": "WO-072: Sovereign Debt & Financial Credit"
+      "15094787074309037083": "WO-068: Macro-Linked Portfolio"
     },
     "completed_sessions": {
       "15007179683109829611": "WO-060 - MERGED 2026-01-15",
diff --git a/design/TEAM_LEADER_HANDBOOK.md b/design/TEAM_LEADER_HANDBOOK.md
index 3a3a188..ecdd19b 100644
--- a/design/TEAM_LEADER_HANDBOOK.md
+++ b/design/TEAM_LEADER_HANDBOOK.md
@@ -47,12 +47,11 @@ THEN ÏùΩÏùÑ Î¨∏ÏÑú:
   - design/HANDOVER_*.md (ÏßÅÏ†Ñ ÏÑ∏ÏÖò Ïù∏ÏàòÏù∏Í≥Ñ)
 ```
 
-### Í∏∞Ìöç/Î™ÖÏÑ∏/Í∞êÏÇ¨ Ïãú
+### Í∏∞Ìöç/Î™ÖÏÑ∏ ÏûëÏÑ± Ïãú
 ```
-IF Spec/Work Order ÏûëÏÑ± ÎòêÎäî ÏΩîÎìú Í∞êÏÇ¨(Audit) ÌïÑÏöî
+IF Spec ÎòêÎäî Work Order ÏûëÏÑ± ÌïÑÏöî
 THEN ÎèÑÍµ¨: .\gemini-go.bat
-     Í∏∞Îä•: ÌååÏùº ÎøêÎßå ÏïÑÎãàÎùº <<ÎîîÎ†âÌÜ†Î¶¨>> Ïª®ÌÖçÏä§Ìä∏ Ï£ºÏûÖ Í∞ÄÎä•
-     Ï∂úÎ†•: design/gemini_output/spec_draft.md (ÎòêÎäî ÏßÄÏ†ïÎêú ÌååÏùº)
+     Ï∂úÎ†•: design/gemini_output/spec_draft.md
 ```
 
 ### Jules ÏûëÏóÖ Î∞úÏ£º Ïãú
diff --git a/design/TECH_DEBT_LEDGER.md b/design/TECH_DEBT_LEDGER.md
index 224b391..e10d7f6 100644
--- a/design/TECH_DEBT_LEDGER.md
+++ b/design/TECH_DEBT_LEDGER.md
@@ -6,7 +6,7 @@
 |---|---|---|---|---|
 | TD-024 | 2026-01-15 | `pytest` Ïã§Ìñâ Ïãú ÌÖåÏä§Ìä∏ Í≤ΩÎ°ú Ïò§Î•ò | Phase 26 Ï∞©Ïàò Î∂àÍ∞Ä (ÌÖåÏä§Ìä∏ Ïã†Î¢∞ÏÑ± ÌõºÏÜê) | **BLOCKER** |
 
-## üü° DEFERRED (Phase 27+ ÏÉÅÌôò ÏòàÏ†ï)
+## üü° DEFERRED (Phase 27 ÏÉÅÌôò ÏòàÏ†ï)
 
 | ID | Date | Description | Remediation Plan | Impact | Status |
 |---|---|---|---|---|---|
@@ -15,17 +15,7 @@
 | TD-007 | 2026-01-12 | Industrial Revolution Stress Test Config | Natural Equilibrium Config Tuning | ÎπÑÌòÑÏã§Ï†Å Í≤ΩÏ†ú ÏÉÅÌÉú (Î¨¥Ìïú ÏàòÏöî) | **DEFERRED** |
 | TD-008 | 2026-01-14 | Primitive Valuation Logic in CPR | Implement Altman Z-Score solvency check | Inefficient CPR (Zombie Firms) | **DESIGNED** (P26.5) |
 | TD-009 | 2026-01-14 | CPR Bailouts are Unconditional Grants | Convert to Interest-bearing Loans/Bonds | Lack of Fiscal Consequence | **DESIGNED** (P26.5) |
-| TD-032 | 2026-01-15 | Fixed M&A Threshold (0.7) | Dynamic market-driven valuation | Rigid corporate consolidation | **DEFERRED** |
-| TD-033 | 2026-01-15 | Static Wage Decay Rate (0.02) | Desperation-based adaptive decay | Linear unemployment expectations | **DEFERRED** |
-| TD-034 | 2026-01-15 | Arbitrary Startup Cost (30000.0) | Capital market derived entry cost | Static barrier to entry | **DEFERRED** |
-| TD-035 | 2026-01-15 | Fixed Tax Brackets (Static Multiples) | Policy-driven flexible brackets | Fiscal policy rigidity | **DEFERRED** |
-| TD-036 | 2026-01-15 | Rigid Housing Review Cycle (30 Ticks) | Event-driven housing decisions | Deterministic mobility | **DEFERRED** |
-| TD-037 | 2026-01-15 | Fixed PER Multiplier (10.0) | Sector-specific market derived PER | Generic firm valuation | **DEFERRED** |
-| TD-038 | 2026-01-15 | Magic Numbers in R&D Logic (0.2, 100.0) | S-curve based R&D model | Linearized innovation | **DEFERRED** |
-| TD-039 | 2026-01-15 | Linear Aging Mortality Formula | Quality-of-life weighted mortality | Demographic predictability | **DEFERRED** |
-| TD-040 | 2026-01-15 | Fixed Immigration Trigger (U-rate 5%) | Policy-lever based immigration | Lack of demographic control | **DEFERRED** |
-| TD-041 | 2026-01-15 | Constant M&A Success Prob (0.6) | Premium & Health based probability | Unrealistic takeover dynamics | **DEFERRED** |
-| TD-042 | 2026-01-15 | Rigid AI State Thresholds (e.g. 1%) | Learned or continuous state space | Rule-based AI perception | **DEFERRED** |
+
 
 ---
 
@@ -33,7 +23,6 @@
 
 | ID | Î∞úÏÉùÏùº | Ìï¥Í≤∞Ïùº | Î∂ÄÏ±Ñ ÎÇ¥Ïö© | Ìï¥Í≤∞ Î∞©Î≤ï |
 |---|---|---|---|---|
-| TD-024 | 2026-01-15 | 2026-01-15 | `pytest` Ïã§Ìñâ Ïãú ÌÖåÏä§Ìä∏ Í≤ΩÎ°ú Ïò§Î•ò | Created `pytest.ini` & Removed sys.path hacks |
 | TD-030 | 2026-01-15 | 2026-01-15 | Missing Fractional Reserve System | Implemented Fractional Reserve & Credit Creation (WO-064) |
 | TD-010 | 2026-01-14 | 2026-01-15 | Government AI Sensory Lag | Implemented High-Fidelity Sensory Architecture (WO-066) |
 | TD-025 | 2026-01-14 | 2026-01-15 | Tracker Blindness & Infra Gap | Implemented LKP Fallback (WO-066) |
diff --git a/design/gemini_output/audit_hardcoded_debt.md b/design/gemini_output/audit_hardcoded_debt.md
deleted file mode 100644
index 129c4c9..0000000
--- a/design/gemini_output/audit_hardcoded_debt.md
+++ /dev/null
@@ -1,105 +0,0 @@
-üïµÔ∏è  Generating Report for: 'Task: Identify all hardcoded magic numbers and rule-based heuristics across the codebase. Focus: 1) config.py: Arbitrary constants. 2) simulation/agents/: Hardcoded thresholds, fixed rates, and deterministic if/else decision logic. 3) simulation/systems/: Rigid formulas that should be adaptive. Output: A detailed list of Technical Debts (TD-XXX) with file paths, code snippets, and why they require re-planning for 'Adaptive AI Migration'.'...
-üìñ Attached context: simulation\ai_model.py
-üìñ Attached context: simulation\api.py
-üìñ Attached context: simulation\bank.py
-üìñ Attached context: simulation\base_agent.py
-üìñ Attached context: simulation\core_agents.py
-üìñ Attached context: simulation\core_markets.py
-üìñ Attached context: simulation\decisions.py
-üìñ Attached context: simulation\dtos.py
-üìñ Attached context: simulation\engine.py
-üìñ Attached context: simulation\firms.py
-üìñ Attached context: simulation\loan_market.py
-üìñ Attached context: simulation\models.py
-üìñ Attached context: simulation\portfolio.py
-üìñ Attached context: simulation\schemas.py
-üìñ Attached context: simulation\service_firms.py
-üìñ Attached context: simulation\__init__.py
-üìñ Attached context: simulation\agents\central_bank.py
-üìñ Attached context: simulation\agents\government.py
-üìñ Attached context: simulation\ai\action_selector.py
-üìñ Attached context: simulation\ai\ai_training_manager.py
-üìñ Attached context: simulation\ai\api.py
-üìñ Attached context: simulation\ai\engine_registry.py
-üìñ Attached context: simulation\ai\enums.py
-üìñ Attached context: simulation\ai\firm_ai.py
-üìñ Attached context: simulation\ai\firm_system2_planner.py
-üìñ Attached context: simulation\ai\government_ai.py
-üìñ Attached context: simulation\ai\household_ai.py
-üìñ Attached context: simulation\ai\household_system2.py
-üìñ Attached context: simulation\ai\learning_tracker.py
-üìñ Attached context: simulation\ai\model_wrapper.py
-üìñ Attached context: simulation\ai\q_table_manager.py
-üìñ Attached context: simulation\ai\reward_calculator.py
-üìñ Attached context: simulation\ai\service_firm_ai.py
-üìñ Attached context: simulation\ai\state_builder.py
-üìñ Attached context: simulation\ai\system2_planner.py
-üìñ Attached context: simulation\ai\vectorized_planner.py
-üìñ Attached context: simulation\ai\__init__.py
-üìñ Attached context: simulation\brands\brand_manager.py
-üìñ Attached context: simulation\components\consumption_behavior.py
-üìñ Attached context: simulation\components\finance_department.py
-üìñ Attached context: simulation\components\hr_department.py
-üìñ Attached context: simulation\components\leisure_manager.py
-üìñ Attached context: simulation\components\psychology_component.py
-üìñ Attached context: simulation\db\database.py
-üìñ Attached context: simulation\db\db_manager.py
-üìñ Attached context: simulation\db\repository.py
-üìñ Attached context: simulation\db\schema.py
-üìñ Attached context: simulation\decisions\action_proposal.py
-üìñ Attached context: simulation\decisions\ai_driven_firm_engine.py
-üìñ Attached context: simulation\decisions\ai_driven_household_engine.py
-üìñ Attached context: simulation\decisions\base_decision_engine.py
-üìñ Attached context: simulation\decisions\corporate_manager.py
-üìñ Attached context: simulation\decisions\housing_manager.py
-üìñ Attached context: simulation\decisions\portfolio_manager.py
-üìñ Attached context: simulation\decisions\rule_based_firm_engine.py
-üìñ Attached context: simulation\decisions\rule_based_household_engine.py
-üìñ Attached context: simulation\decisions\standalone_rule_based_firm_engine.py
-üìñ Attached context: simulation\decisions\__init__.py
-üìñ Attached context: simulation\interface\dashboard_connector.py
-üìñ Attached context: simulation\interface\__init__.py
-üìñ Attached context: simulation\interfaces\policy_interface.py
-üìñ Attached context: simulation\markets\order_book_market.py
-üìñ Attached context: simulation\markets\stock_market.py
-üìñ Attached context: simulation\markets\__init__.py
-üìñ Attached context: simulation\metrics\economic_tracker.py
-üìñ Attached context: simulation\metrics\inequality_tracker.py
-üìñ Attached context: simulation\metrics\stock_tracker.py
-üìñ Attached context: simulation\policies\smart_leviathan_policy.py
-üìñ Attached context: simulation\policies\taylor_rule_policy.py
-üìñ Attached context: simulation\systems\bootstrapper.py
-üìñ Attached context: simulation\systems\demographic_manager.py
-üìñ Attached context: simulation\systems\firm_management.py
-üìñ Attached context: simulation\systems\generational_wealth_audit.py
-üìñ Attached context: simulation\systems\housing_system.py
-üìñ Attached context: simulation\systems\immigration_manager.py
-üìñ Attached context: simulation\systems\inheritance_manager.py
-üìñ Attached context: simulation\systems\ma_manager.py
-üìñ Attached context: simulation\systems\ministry_of_education.py
-üìñ Attached context: simulation\systems\persistence_manager.py
-üìñ Attached context: simulation\systems\reflux_system.py
-üìñ Attached context: simulation\systems\tax_agency.py
-üìñ Attached context: simulation\systems\technology_manager.py
-üìñ Attached context: simulation\systems\transaction_processor.py
-üìñ Attached context: simulation\utils\shadow_logger.py
-üìñ Attached context: simulation\viewmodels\agent_state_viewmodel.py
-üìñ Attached context: simulation\viewmodels\economic_indicators_viewmodel.py
-üìñ Attached context: simulation\viewmodels\market_history_viewmodel.py
-üìñ Attached context: simulation\viewmodels\snapshot_viewmodel.py
-üìñ Attached context: config.py
-üöÄ [GeminiWorker] Running task with manual: reporter.md
-
-‚úÖ Report Saved: C:\coding\economics\reports\temp\report_20260115_133455_Task__Identify_all_h.md
-============================================================
-# Report: Analysis of Hardcoded Heuristics and Technical Debt
-
-## Executive Summary
-The codebase contains a significant amount of technical debt in the form of hardcoded "magic numbers," fixed thresholds, and rule-based heuristics. This makes the simulation rigid and predictable. Migrating to a truly adaptive AI system will require refactoring these components into dynamic, learnable mechanisms.
-
-## Detailed Analysis
-
-### 1. Configuration File (`config.py`)
-The `config.py` file centralizes many 
-...
-============================================================
diff --git a/design/gemini_output/pr_diff_sovereign-debt-wip-7617648577093442794.txt b/design/gemini_output/pr_diff_sovereign-debt-wip-7617648577093442794.txt
deleted file mode 100644
index 585d9ef..0000000
--- a/design/gemini_output/pr_diff_sovereign-debt-wip-7617648577093442794.txt
+++ /dev/null
@@ -1,807 +0,0 @@
-diff --git a/insights/mass_liquidation_risk_report.md b/insights/mass_liquidation_risk_report.md
-new file mode 100644
-index 0000000..d1e8d35
---- /dev/null
-+++ b/insights/mass_liquidation_risk_report.md
-@@ -0,0 +1,29 @@
-+# Mass Liquidation Risk Report
-+
-+## Introduction
-+
-+The introduction of a sovereign debt market and the transition from grants to interest-bearing bailout loans fundamentally changes the economic simulation. While these changes are designed to create a more realistic and responsible economic model, they also introduce new systemic risks. This report outlines the potential for mass liquidation events and the cascading failures that could result.
-+
-+## Key Risk Factors
-+
-+1.  **Zombie Firm Collapse:** The implementation of the Altman Z-Score will correctly identify and lead to the liquidation of "zombie firms" that are no longer financially viable. However, a sudden, simultaneous collapse of multiple zombie firms could trigger a deflationary spiral.
-+
-+2.  **Credit Crunch:** As the government issues bonds to finance its spending, it will compete with the private sector for a limited pool of capital. This "crowding out" effect will drive up interest rates, making it more expensive for firms to borrow and invest. A severe credit crunch could stifle economic growth and lead to a wave of bankruptcies.
-+
-+3.  **Sovereign Debt Crisis:** If the government's debt-to-GDP ratio rises to unsustainable levels, investor confidence could collapse, leading to a spike in bond yields. A sovereign debt crisis would force the government to implement austerity measures, further depressing the economy and potentially leading to a "doom loop" of rising debt and falling growth.
-+
-+## Potential Cascading Failures
-+
-+*   **Bank Insolvency:** A wave of corporate bankruptcies could lead to a surge in non-performing loans, threatening the solvency of the banking system.
-+*   **Mass Unemployment:** The liquidation of firms will lead to job losses, reducing aggregate demand and further depressing the economy.
-+*   **Deflationary Spiral:** Falling prices and wages could increase the real burden of debt, leading to a vicious cycle of defaults, bankruptcies, and economic contraction.
-+
-+## Mitigation Strategies
-+
-+*   **Central Bank Intervention:** The Central Bank can act as a lender of last resort, providing liquidity to the banking system and purchasing government bonds to keep interest rates low.
-+*   **Counter-cyclical Fiscal Policy:** The government can use fiscal stimulus to support the economy during a downturn, but this must be balanced against the risk of a sovereign debt crisis.
-+*   **Orderly Liquidation:** Mechanisms could be put in place to ensure the orderly liquidation of failed firms, preventing a fire sale of assets that could depress prices and trigger a wider panic.
-+
-+## Conclusion
-+
-+The new economic model is more realistic, but it is also more fragile. The risk of mass liquidation events is real and should be carefully monitored. A combination of prudent fiscal policy, proactive central banking, and robust financial regulation will be needed to mitigate these risks and ensure the long-term stability of the simulated economy.
-diff --git a/modules/finance/api.py b/modules/finance/api.py
-new file mode 100644
-index 0000000..34eae27
---- /dev/null
-+++ b/modules/finance/api.py
-@@ -0,0 +1,34 @@
-+from typing import Protocol, Dict, List
-+from dataclasses import dataclass
-+
-+@dataclass
-+class BondDTO:
-+    """Data Transfer Object for government bonds."""
-+    id: str
-+    issuer: str
-+    face_value: float
-+    yield_rate: float
-+    maturity_date: int
-+
-+@dataclass
-+class BailoutLoanDTO:
-+    """Data Transfer Object for corporate bailout loans."""
-+    firm_id: int
-+    amount: float
-+    interest_rate: float
-+    covenants: Dict[str, bool]
-+
-+class IFinanceSystem(Protocol):
-+    """Interface for the sovereign debt and corporate bailout system."""
-+
-+    def evaluate_solvency(self, firm: 'Firm', current_tick: int) -> bool:
-+        """Evaluates a firm's solvency to determine bailout eligibility."""
-+        ...
-+
-+    def issue_treasury_bonds(self, amount: float) -> List[BondDTO]:
-+        """Issues new treasury bonds to the market."""
-+        ...
-+
-+    def service_debt(self) -> None:
-+        """Manages the servicing of outstanding government debt."""
-+        ...
-diff --git a/modules/finance/system.py b/modules/finance/system.py
-new file mode 100644
-index 0000000..73b866e
---- /dev/null
-+++ b/modules/finance/system.py
-@@ -0,0 +1,97 @@
-+from typing import List, Dict
-+from modules.finance.api import IFinanceSystem, BondDTO, BailoutLoanDTO
-+# Forward reference for type hinting
-+from simulation.firms import Firm
-+
-+class FinanceSystem(IFinanceSystem):
-+    """Manages sovereign debt, corporate bailouts, and solvency checks."""
-+
-+    def __init__(self, government: 'Government', central_bank: 'CentralBank', config_module: any):
-+        self.government = government
-+        self.central_bank = central_bank
-+        self.config_module = config_module
-+        self.outstanding_bonds: List[BondDTO] = []
-+
-+    def evaluate_solvency(self, firm: 'Firm', current_tick: int) -> bool:
-+        """
-+        Evaluates a firm's solvency to determine bailout eligibility.
-+        - Startups (< 24 ticks old) are checked for a 3-month wage runway.
-+        - Established firms are evaluated using the Altman Z-Score.
-+        """
-+        startup_grace_period = getattr(self.config_module, "STARTUP_GRACE_PERIOD_TICKS", 24)
-+        z_score_threshold = getattr(self.config_module, "ALTMAN_Z_SCORE_THRESHOLD", 1.81)
-+
-+        if firm.age < startup_grace_period:
-+            # Runway Check for startups
-+            monthly_wage_bill = firm.hr.get_total_wage_bill() * 4  # Approximate monthly
-+            required_runway = monthly_wage_bill * 3
-+            return firm.assets >= required_runway
-+        else:
-+            # Altman Z-Score for established firms
-+            z_score = firm.finance.calculate_altman_z_score()
-+            return z_score > z_score_threshold
-+
-+    def issue_treasury_bonds(self, amount: float, current_tick: int) -> List[BondDTO]:
-+        """
-+        Issues new treasury bonds to the market.
-+        Yield is determined by the base rate plus a risk premium based on Debt-to-GDP ratio.
-+        """
-+        # This is a simplified auction. A real implementation would involve market participants.
-+        base_rate = self.central_bank.get_interest_rate()
-+        debt_to_gdp = self.government.get_debt_to_gdp_ratio()
-+
-+        # Exponential risk premium
-+        risk_premium = 0.0
-+        if debt_to_gdp > 1.2:
-+            risk_premium = 0.05
-+        elif debt_to_gdp > 0.9:
-+            risk_premium = 0.02
-+        elif debt_to_gdp > 0.6:
-+            risk_premium = 0.005
-+
-+        yield_rate = base_rate + risk_premium
-+
-+        # For now, assume the central bank buys all bonds as the buyer of last resort
-+        new_bond = BondDTO(
-+            id=f"BOND_{current_tick}",
-+            issuer="GOVERNMENT",
-+            face_value=amount,
-+            yield_rate=yield_rate,
-+            maturity_date=current_tick + getattr(self.config_module, "BOND_MATURITY_TICKS", 400) # 4 years
-+        )
-+        self.outstanding_bonds.append(new_bond)
-+        self.central_bank.purchase_bonds(new_bond)
-+        self.government.assets += amount
-+
-+        return [new_bond]
-+
-+    def grant_bailout_loan(self, firm: 'Firm', amount: float) -> BailoutLoanDTO:
-+        """Converts a bailout from a grant to an interest-bearing senior loan."""
-+        base_rate = self.central_bank.get_interest_rate()
-+        penalty_premium = getattr(self.config_module, "BAILOUT_PENALTY_PREMIUM", 0.05)
-+
-+        loan = BailoutLoanDTO(
-+            firm_id=firm.id,
-+            amount=amount,
-+            interest_rate=base_rate + penalty_premium,
-+            covenants={
-+                "dividends_allowed": False,
-+                "executive_salary_freeze": True
-+            }
-+        )
-+
-+        # The government provides the funds, which become a liability for the firm
-+        self.government.assets -= amount
-+        firm.finance.add_liability(amount, loan.interest_rate)
-+
-+        return loan
-+
-+
-+    def service_debt(self, current_tick: int) -> None:
-+        """Manages the servicing of outstanding government debt."""
-+        # This is a simplified version. A real implementation would handle interest payments
-+        # and bond maturation.
-+        matured_bonds = [b for b in self.outstanding_bonds if b.maturity_date <= current_tick]
-+        for bond in matured_bonds:
-+            self.government.assets -= bond.face_value
-+            self.outstanding_bonds.remove(bond)
-diff --git a/simulation/agents/central_bank.py b/simulation/agents/central_bank.py
-index a35ed64..c94968a 100644
---- a/simulation/agents/central_bank.py
-+++ b/simulation/agents/central_bank.py
-@@ -32,6 +32,12 @@ class CentralBank:
-             extra={"tick": 0, "tags": ["central_bank", "init"]}
-         )
- 
-+    def purchase_bonds(self, bond: Any) -> None:
-+        """Purchases government bonds, effectively performing QE."""
-+        # In a real model, this would add to the CB's balance sheet.
-+        # For now, this is a placeholder to complete the transaction loop.
-+        logger.info(f"CENTRAL_BANK_QE | Purchased bond {bond.id} for {bond.face_value:.2f}")
-+
-     def get_base_rate(self) -> float:
-         return self.base_rate
- 
-diff --git a/simulation/agents/government.py b/simulation/agents/government.py
-index 1d53d8c..684a1cd 100644
---- a/simulation/agents/government.py
-+++ b/simulation/agents/government.py
-@@ -102,6 +102,7 @@ class Government:
- 
-         # WO-057-B: Sensory Data Container
-         self.sensory_data: Optional[GovernmentStateDTO] = None
-+        self.finance_system = None
- 
-         logger.info(
-             f"Government {self.id} initialized with assets: {self.assets}",
-@@ -264,62 +265,40 @@ class Government:
-             details=f"Inf={inflation:.2%}, Growth={real_gdp_growth:.2%}, Gap={gdp_gap:.2%}, RateGap={gap:.4f}"
-         )
- 
--    def provide_subsidy(self, target_agent: Any, amount: float, current_tick: int):
--        """
--        Î≥¥Ï°∞Í∏àÏùÑ ÏßÄÍ∏âÌï©ÎãàÎã§.
--        AI Spending Multiplier Ï†ÅÏö©.
--        """
--        # Apply Multiplier based on Target
--        effective_amount = amount
--        agent_type = "household"
--        if hasattr(target_agent, "employees"): # Duck typing Firm
--            effective_amount *= self.firm_subsidy_budget_multiplier
--            agent_type = "firm"
--        else:
--            effective_amount *= self.welfare_budget_multiplier
-+    def provide_household_support(self, household: Any, amount: float, current_tick: int):
-+        """Provides subsidies to households (e.g., unemployment, stimulus)."""
-+        effective_amount = amount * self.welfare_budget_multiplier
- 
-         if effective_amount <= 0:
-             return 0.0
- 
--        if not getattr(self.config_module, "DEFICIT_SPENDING_ENABLED", False):
--            if self.assets < effective_amount:
--                return 0.0
--        else:
--            # WO-057-Active: Debt Ceiling Logic
--            if self.sensory_data and self.sensory_data.current_gdp > 0:
--                limit_ratio = getattr(self.config_module, "DEFICIT_SPENDING_LIMIT_RATIO", 0.3)
--                debt_limit = self.sensory_data.current_gdp * limit_ratio
--
--                projected_assets = self.assets - effective_amount
--
--                if abs(projected_assets) > debt_limit and projected_assets < 0:
--                    logger.warning(
--                        f"FISCAL_CLIFF_REACHED | Spending blocked. Debt {abs(self.assets):.2f} vs Limit {debt_limit:.2f}",
--                        extra={"tick": current_tick, "agent_id": self.id, "tags": ["fiscal_cliff", "deficit"]}
--                    )
--                    return 0.0
-+        if self.assets < effective_amount:
-+            needed = effective_amount - self.assets
-+            self.finance_system.issue_treasury_bonds(needed, current_tick)
- 
-         self.assets -= effective_amount
-         self.total_spent_subsidies += effective_amount
-         self.expenditure_this_tick += effective_amount
--
--        self.total_money_issued += effective_amount
--
--        target_agent.assets += effective_amount
-+        household.assets += effective_amount
-         self.current_tick_stats["welfare_spending"] += effective_amount
- 
-         logger.info(
--            f"SUBSIDY_PAID | Paid {effective_amount:.2f} subsidy to {target_agent.id} ({agent_type})",
--            extra={
--                "tick": current_tick,
--                "agent_id": self.id,
--                "amount": effective_amount,
--                "target_id": target_agent.id,
--                "tags": ["subsidy", "expenditure"]
--            }
-+            f"HOUSEHOLD_SUPPORT | Paid {effective_amount:.2f} to {household.id}",
-+            extra={"tick": current_tick, "agent_id": self.id, "amount": effective_amount, "target_id": household.id}
-         )
-         return effective_amount
- 
-+    def provide_firm_bailout(self, firm: Any, amount: float, current_tick: int):
-+        """Provides a bailout loan to a firm if it's eligible."""
-+        if self.finance_system.evaluate_solvency(firm, current_tick):
-+            logger.info(f"BAILOUT_APPROVED | Firm {firm.id} is eligible for a bailout.")
-+            loan = self.finance_system.grant_bailout_loan(firm, amount)
-+            self.expenditure_this_tick += amount
-+            return loan
-+        else:
-+            logger.warning(f"BAILOUT_DENIED | Firm {firm.id} is insolvent and not eligible for a bailout.")
-+            return None
-+
-     def get_survival_cost(self, market_data: Dict[str, Any]) -> float:
-         """ Calculates current survival cost based on food prices. """
-         avg_food_price = 0.0
-@@ -398,8 +377,7 @@ class Government:
- 
-                 # B. Unemployment Benefit
-                 if not agent.is_employed:
--                    # provide_subsidy now applies welfare_budget_multiplier
--                    self.provide_subsidy(agent, benefit_amount, current_tick)
-+                    self.provide_household_support(agent, benefit_amount, current_tick)
-                     total_welfare_paid += benefit_amount
- 
-         # 3. Stimulus Check (Legacy Logic, now influenced by AI multiplier)
-@@ -445,23 +423,11 @@ class Government:
-         if self.firm_subsidy_budget_multiplier < 0.8:
-             return False
- 
--        # WO-057-Active CRITICAL FIX: Apply Debt Ceiling to Infrastructure
--        if getattr(self.config_module, "DEFICIT_SPENDING_ENABLED", False):
--            if self.sensory_data and self.sensory_data.current_gdp > 0:
--                limit_ratio = getattr(self.config_module, "DEFICIT_SPENDING_LIMIT_RATIO", 0.3)
--                debt_limit = self.sensory_data.current_gdp * limit_ratio
--                projected_assets = self.assets - effective_cost
--                if abs(projected_assets) > debt_limit and projected_assets < 0:
--                    logger.warning(
--                        f"FISCAL_CLIFF_REACHED | Infrastructure investment blocked. Debt {abs(self.assets):.2f} vs Limit {debt_limit:.2f}",
--                        extra={"tick": current_tick, "agent_id": self.id, "tags": ["fiscal_cliff", "deficit"]}
--                    )
--                    return False
--        elif self.assets < effective_cost:
--            return False # Fallback to old behavior if deficit spending is off
-+        if self.assets < effective_cost:
-+            needed = effective_cost - self.assets
-+            self.finance_system.issue_treasury_bonds(needed, current_tick)
- 
-         self.assets -= effective_cost
--        self.total_money_issued += effective_cost
-         self.expenditure_this_tick += effective_cost
-         if reflux_system:
-             reflux_system.capture(effective_cost, str(self.id), "infrastructure")
-@@ -532,6 +498,14 @@ class Government:
-             "perceived_public_opinion": self.perceived_public_opinion
-         }
- 
-+    def get_debt_to_gdp_ratio(self) -> float:
-+        """Calculates the debt-to-GDP ratio."""
-+        if not self.sensory_data or self.sensory_data.current_gdp == 0:
-+            return 0.0
-+
-+        debt = max(0.0, -self.assets)
-+        return debt / self.sensory_data.current_gdp
-+
-     # WO-054: Public Education System
-     def run_public_education(self, agents: List[Any], config_module: Any, current_tick: int, reflux_system: Any = None) -> None:
-         """
-diff --git a/simulation/bank.py b/simulation/bank.py
-index 57d02a0..10bb398 100644
---- a/simulation/bank.py
-+++ b/simulation/bank.py
-@@ -71,6 +71,10 @@ class Bank:
-             extra={"tick": 0, "agent_id": self.id, "tags": ["init", "bank"]},
-         )
- 
-+    def get_interest_rate(self) -> float:
-+        """Returns the current base interest rate."""
-+        return self.base_rate
-+
-     def _get_config(self, key: str, default: Any) -> Any:
-         return getattr(self.config_module, key, default)
- 
-diff --git a/simulation/components/finance_department.py b/simulation/components/finance_department.py
-index 3320bfd..1ae122d 100644
---- a/simulation/components/finance_department.py
-+++ b/simulation/components/finance_department.py
-@@ -175,6 +175,43 @@ class FinanceDepartment:
- 
-         return 0.0
- 
-+    def add_liability(self, amount: float, interest_rate: float):
-+        """Adds a liability (like a loan) to the firm's balance sheet."""
-+        # This is a simplified implementation. A real one would track multiple loans.
-+        self.firm.assets += amount  # The loan increases cash assets
-+        # In a more complex model, this would be a separate liability account
-+        # For now, we'll just track the total debt.
-+        if not hasattr(self.firm, 'total_debt'):
-+            self.firm.total_debt = 0.0
-+        self.firm.total_debt += amount
-+
-+    def calculate_altman_z_score(self) -> float:
-+        """
-+        Calculates the Altman Z-Score for solvency, simplified for this model.
-+        Z = 1.2*X1 + 1.4*X2 + 3.3*X3
-+        X1: Working Capital / Total Assets
-+        X2: Retained Earnings / Total Assets
-+        X3: Average Profit / Total Assets
-+        """
-+        total_assets = self.firm.assets + self.firm.capital_stock + self.firm.get_inventory_value()
-+        if total_assets == 0:
-+            return 0.0
-+
-+        # X1: Working Capital / Total Assets
-+        # Working Capital = Current Assets - Current Liabilities. Assume liabilities are total_debt for now.
-+        working_capital = self.firm.assets - getattr(self.firm, 'total_debt', 0.0)
-+        x1 = working_capital / total_assets
-+
-+        # X2: Retained Earnings / Total Assets
-+        x2 = self.retained_earnings / total_assets
-+
-+        # X3: Average Profit / Total Assets
-+        avg_profit = sum(self.profit_history) / len(self.profit_history) if self.profit_history else 0.0
-+        x3 = avg_profit / total_assets
-+
-+        z_score = 1.2 * x1 + 1.4 * x2 + 3.3 * x3
-+        return z_score
-+
-     def check_bankruptcy(self):
-         if self.current_profit < 0:
-             self.consecutive_loss_turns += 1
-diff --git a/simulation/engine.py b/simulation/engine.py
-index 8906d0d..41bd182 100644
---- a/simulation/engine.py
-+++ b/simulation/engine.py
-@@ -35,6 +35,7 @@ from simulation.systems.generational_wealth_audit import GenerationalWealthAudit
- from simulation.decisions.housing_manager import HousingManager # For rank/tier helper
- from simulation.ai.vectorized_planner import VectorizedHouseholdPlanner
- from simulation.systems.transaction_processor import TransactionProcessor # SoC Refactor
-+from modules.finance.system import FinanceSystem
- 
- # Use the repository pattern for data access
- from simulation.db.repository import SimulationRepository
-@@ -114,6 +115,14 @@ class Simulation:
-         # similar to how markets are handled, or we can add it if needed.
-         # But it doesn't participate in normal transactions.
- 
-+        # Finance System (Sovereign Debt)
-+        self.finance_system = FinanceSystem(
-+            government=self.government,
-+            central_bank=self.central_bank,
-+            config_module=self.config_module
-+        )
-+        self.government.finance_system = self.finance_system # Inject into government
-+
-         # Phase 17-3A: Initialize Real Estate Units
-         self.real_estate_units: List[RealEstateUnit] = [
-             RealEstateUnit(id=i, estimated_value=self.config_module.INITIAL_PROPERTY_VALUE,
-@@ -518,6 +527,13 @@ class Simulation:
-         # 4. Election Check
-         self.government.check_election(self.time)
- 
-+        # Age firms
-+        for firm in self.firms:
-+            firm.age += 1
-+
-+        # Service national debt
-+        self.finance_system.service_debt(self.time)
-+
-         # Phase 4: Welfare Check (Executes Subsidies based on Policy)
-         self.government.run_welfare_check(list(self.agents.values()), market_data, self.time)
- 
-diff --git a/simulation/firms.py b/simulation/firms.py
-index 204b7d4..21ff0c1 100644
---- a/simulation/firms.py
-+++ b/simulation/firms.py
-@@ -133,6 +133,7 @@ class Firm(BaseAgent):
-         self.automation_level: float = 0.0 # 0.0 to 1.0
-         self.system2_planner: Optional[FirmSystem2Planner] = None # Initialized later
- 
-+        self.age = 0
-         self.decision_engine.loan_market = loan_market
- 
-     def init_ipo(self, stock_market: StockMarket):
-diff --git a/tests/test_ai_driven_firm_engine.py b/tests/test_ai_driven_firm_engine.py
-index c1cc839..b837a96 100644
---- a/tests/test_ai_driven_firm_engine.py
-+++ b/tests/test_ai_driven_firm_engine.py
-@@ -48,18 +48,30 @@ def mock_firm(mock_config):
-     firm.employees = []
-     firm.profit_history = []
-     firm.productivity_factor = 1.0
-+    firm.age = 25 # Add age for solvency checks
-+    firm.finance = Mock() # Mock the finance department
-     return firm
- 
- 
- def test_adjust_price_tactic(firm_decision_engine_instance, mock_firm):
-     """Test that the ADJUST_PRICE tactic correctly adjusts the price."""
-+    from simulation.dtos import DecisionContext
-+
-     mock_firm.inventory["food"] = 200
-     mock_firm.production_target = 100
--    firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
--        Tactic.ADJUST_PRICE
-+    firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
-+        (Tactic.ADJUST_PRICE, 1.0)
-     )
- 
--    orders, _ = firm_decision_engine_instance.make_decisions(mock_firm, {}, [], {}, 1)
-+    context = DecisionContext(
-+        firm=mock_firm,
-+        markets={},
-+        goods_data=[],
-+        market_data={},
-+        current_time=1,
-+        government=None,
-+    )
-+    orders, _ = firm_decision_engine_instance.make_decisions(context)
- 
-     assert len(orders) == 1
-     order = orders[0]
-diff --git a/tests/test_engine.py b/tests/test_engine.py
-index c1d15e5..1276bf0 100644
---- a/tests/test_engine.py
-+++ b/tests/test_engine.py
-@@ -180,6 +180,7 @@ def mock_firms(mock_config_module):
-     f1.is_active = True
-     f1.total_shares = 1000.0
-     f1.treasury_shares = 0.0
-+    f1.age = 25 # Set age for testing
- 
-     f2 = Firm(
-         id=102,
-@@ -195,6 +196,7 @@ def mock_firms(mock_config_module):
-     f2.is_active = False  # Inactive firm
-     f2.total_shares = 1000.0
-     f2.treasury_shares = 0.0
-+    f2.age = 25 # Set age for testing
-     return [f1, f2]
- 
- 
-@@ -256,6 +258,8 @@ def simulation_instance(
-         mock_config_module,
-         mock_goods_data,
-     )
-+    sim.government.finance_system = Mock()
-+    sim.government.get_debt_to_gdp_ratio = Mock(return_value=0.5)
-     return sim
- 
- 
-diff --git a/tests/test_firm_decision_engine_new.py b/tests/test_firm_decision_engine_new.py
-index 57f1492..826fe96 100644
---- a/tests/test_firm_decision_engine_new.py
-+++ b/tests/test_firm_decision_engine_new.py
-@@ -62,8 +62,10 @@ def mock_firm(mock_config):
-     firm.cost_this_turn = 0.0
-     firm.profit_history = deque(maxlen=mock_config.PROFIT_HISTORY_TICKS)
-     firm.specialization = "food"
--    # Add a mock for the logger attribute
-     firm.logger = MagicMock()
-+    firm.age = 25 # Add age for solvency checks
-+    firm.finance = Mock() # Mock the finance department
-+    firm.hr = Mock() # Mock the HR department
-     return firm
- 
- 
-@@ -93,7 +95,7 @@ class TestFirmDecisionEngine:
-     def test_make_decisions_overstock_reduces_target(
-         self, firm_decision_engine_instance, mock_firm, mock_config
-     ):
--        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
-+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
-             Tactic.ADJUST_PRODUCTION, Aggressiveness.NORMAL
-         )
-         mock_firm.inventory["food"] = 150.0 # Force overstock (150 > 100 * 1.2)
-@@ -106,6 +108,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
- 
-@@ -120,7 +123,7 @@ class TestFirmDecisionEngine:
-     ):
-         mock_firm.inventory["food"] = 50.0
-         initial_target = mock_firm.production_target
--        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
-+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
-             Tactic.ADJUST_PRODUCTION, Aggressiveness.NORMAL
-         )
- 
-@@ -130,6 +133,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
- 
-@@ -144,7 +148,7 @@ class TestFirmDecisionEngine:
-     ):
-         mock_firm.inventory["food"] = 100.0
-         initial_target = mock_firm.production_target
--        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
-+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
-             Tactic.ADJUST_PRODUCTION, Aggressiveness.NORMAL
-         )
- 
-@@ -154,6 +158,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
- 
-@@ -162,7 +167,7 @@ class TestFirmDecisionEngine:
-     def test_make_decisions_target_min_max_bounds(
-         self, firm_decision_engine_instance, mock_firm, mock_config
-     ):
--        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
-+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
-             Tactic.ADJUST_PRODUCTION, Aggressiveness.NORMAL
-         )
-         # Test min bound
-@@ -174,6 +179,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
-         assert mock_firm.production_target == mock_config.FIRM_MIN_PRODUCTION_TARGET
-@@ -187,6 +193,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
-         assert mock_firm.production_target == mock_config.FIRM_MAX_PRODUCTION_TARGET
-@@ -196,7 +203,7 @@ class TestFirmDecisionEngine:
-     ):
-         mock_firm.employees = []
-         mock_firm.inventory["food"] = 0  # Ensure production is needed
--        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
-+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
-             Tactic.ADJUST_WAGES, Aggressiveness.NORMAL
-         )
- 
-@@ -206,6 +213,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={"avg_wage": 10.0},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
- 
-@@ -214,7 +222,7 @@ class TestFirmDecisionEngine:
-         ]
-         assert len(buy_labor_orders) > 0
-         assert buy_labor_orders[0].quantity == 1.0
--        assert buy_labor_orders[0].market_id == "labor_market"
-+        assert buy_labor_orders[0].market_id == "labor"
- 
-     def test_make_decisions_hires_for_needed_labor(
-         self, firm_decision_engine_instance, mock_firm, mock_config
-@@ -222,7 +230,7 @@ class TestFirmDecisionEngine:
-         mock_firm.employees = [Mock()]
-         mock_firm.production_target = 500
-         mock_firm.inventory["food"] = 0  # Ensure production is needed
--        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
-+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
-             Tactic.ADJUST_WAGES, Aggressiveness.NORMAL
-         )
- 
-@@ -232,6 +240,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={"avg_wage": 10.0},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
- 
-@@ -246,7 +255,7 @@ class TestFirmDecisionEngine:
-     ):
-         mock_firm.employees = [Mock() for _ in range(mock_config.FIRM_MAX_EMPLOYEES)]
-         mock_firm.production_target = 500
--        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
-+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
-             Tactic.ADJUST_WAGES, Aggressiveness.NORMAL
-         )
- 
-@@ -256,6 +265,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
- 
-@@ -270,7 +280,7 @@ class TestFirmDecisionEngine:
-         mock_firm.employees = [Mock() for _ in range(10)]
-         mock_firm.production_target = 0
-         mock_firm.inventory = {"food": 1000}
--        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
-+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
-             Tactic.ADJUST_WAGES, Aggressiveness.NORMAL
-         )
- 
-@@ -280,6 +290,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
- 
-@@ -312,7 +323,7 @@ class TestFirmDecisionEngine:
-         assert labor_order is not None
-         assert labor_order.agent_id == mock_firm.id
-         assert labor_order.quantity == 1.0
--        assert labor_order.market_id == "labor_market"
-+        assert labor_order.market_id == "labor"
- 
-     def test_make_decisions_does_not_sell_if_understocked(
-         self, firm_decision_engine_instance, mock_firm
-@@ -327,6 +338,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
-         sell_orders = [
-@@ -347,6 +359,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
-         sell_orders = [
-@@ -368,6 +381,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
-         sell_order = next(
-@@ -389,6 +403,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
-         sell_order = next(
-@@ -412,6 +427,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
-         sell_order = next(
-@@ -429,6 +445,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
-         sell_order = next(
-@@ -450,6 +467,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
-         sell_order = next(
-@@ -473,6 +491,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
-         sell_order = next(
-@@ -498,6 +517,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
- 
-@@ -523,6 +543,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
- 
-@@ -548,6 +569,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
- 
-@@ -576,6 +598,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
-         sell_order = next(
-@@ -594,6 +617,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
-         sell_order = next(
diff --git a/design/gemini_output/pr_diff_sovereign_debt_wip.txt b/design/gemini_output/pr_diff_sovereign_debt_wip.txt
deleted file mode 100644
index 585d9ef..0000000
--- a/design/gemini_output/pr_diff_sovereign_debt_wip.txt
+++ /dev/null
@@ -1,807 +0,0 @@
-diff --git a/insights/mass_liquidation_risk_report.md b/insights/mass_liquidation_risk_report.md
-new file mode 100644
-index 0000000..d1e8d35
---- /dev/null
-+++ b/insights/mass_liquidation_risk_report.md
-@@ -0,0 +1,29 @@
-+# Mass Liquidation Risk Report
-+
-+## Introduction
-+
-+The introduction of a sovereign debt market and the transition from grants to interest-bearing bailout loans fundamentally changes the economic simulation. While these changes are designed to create a more realistic and responsible economic model, they also introduce new systemic risks. This report outlines the potential for mass liquidation events and the cascading failures that could result.
-+
-+## Key Risk Factors
-+
-+1.  **Zombie Firm Collapse:** The implementation of the Altman Z-Score will correctly identify and lead to the liquidation of "zombie firms" that are no longer financially viable. However, a sudden, simultaneous collapse of multiple zombie firms could trigger a deflationary spiral.
-+
-+2.  **Credit Crunch:** As the government issues bonds to finance its spending, it will compete with the private sector for a limited pool of capital. This "crowding out" effect will drive up interest rates, making it more expensive for firms to borrow and invest. A severe credit crunch could stifle economic growth and lead to a wave of bankruptcies.
-+
-+3.  **Sovereign Debt Crisis:** If the government's debt-to-GDP ratio rises to unsustainable levels, investor confidence could collapse, leading to a spike in bond yields. A sovereign debt crisis would force the government to implement austerity measures, further depressing the economy and potentially leading to a "doom loop" of rising debt and falling growth.
-+
-+## Potential Cascading Failures
-+
-+*   **Bank Insolvency:** A wave of corporate bankruptcies could lead to a surge in non-performing loans, threatening the solvency of the banking system.
-+*   **Mass Unemployment:** The liquidation of firms will lead to job losses, reducing aggregate demand and further depressing the economy.
-+*   **Deflationary Spiral:** Falling prices and wages could increase the real burden of debt, leading to a vicious cycle of defaults, bankruptcies, and economic contraction.
-+
-+## Mitigation Strategies
-+
-+*   **Central Bank Intervention:** The Central Bank can act as a lender of last resort, providing liquidity to the banking system and purchasing government bonds to keep interest rates low.
-+*   **Counter-cyclical Fiscal Policy:** The government can use fiscal stimulus to support the economy during a downturn, but this must be balanced against the risk of a sovereign debt crisis.
-+*   **Orderly Liquidation:** Mechanisms could be put in place to ensure the orderly liquidation of failed firms, preventing a fire sale of assets that could depress prices and trigger a wider panic.
-+
-+## Conclusion
-+
-+The new economic model is more realistic, but it is also more fragile. The risk of mass liquidation events is real and should be carefully monitored. A combination of prudent fiscal policy, proactive central banking, and robust financial regulation will be needed to mitigate these risks and ensure the long-term stability of the simulated economy.
-diff --git a/modules/finance/api.py b/modules/finance/api.py
-new file mode 100644
-index 0000000..34eae27
---- /dev/null
-+++ b/modules/finance/api.py
-@@ -0,0 +1,34 @@
-+from typing import Protocol, Dict, List
-+from dataclasses import dataclass
-+
-+@dataclass
-+class BondDTO:
-+    """Data Transfer Object for government bonds."""
-+    id: str
-+    issuer: str
-+    face_value: float
-+    yield_rate: float
-+    maturity_date: int
-+
-+@dataclass
-+class BailoutLoanDTO:
-+    """Data Transfer Object for corporate bailout loans."""
-+    firm_id: int
-+    amount: float
-+    interest_rate: float
-+    covenants: Dict[str, bool]
-+
-+class IFinanceSystem(Protocol):
-+    """Interface for the sovereign debt and corporate bailout system."""
-+
-+    def evaluate_solvency(self, firm: 'Firm', current_tick: int) -> bool:
-+        """Evaluates a firm's solvency to determine bailout eligibility."""
-+        ...
-+
-+    def issue_treasury_bonds(self, amount: float) -> List[BondDTO]:
-+        """Issues new treasury bonds to the market."""
-+        ...
-+
-+    def service_debt(self) -> None:
-+        """Manages the servicing of outstanding government debt."""
-+        ...
-diff --git a/modules/finance/system.py b/modules/finance/system.py
-new file mode 100644
-index 0000000..73b866e
---- /dev/null
-+++ b/modules/finance/system.py
-@@ -0,0 +1,97 @@
-+from typing import List, Dict
-+from modules.finance.api import IFinanceSystem, BondDTO, BailoutLoanDTO
-+# Forward reference for type hinting
-+from simulation.firms import Firm
-+
-+class FinanceSystem(IFinanceSystem):
-+    """Manages sovereign debt, corporate bailouts, and solvency checks."""
-+
-+    def __init__(self, government: 'Government', central_bank: 'CentralBank', config_module: any):
-+        self.government = government
-+        self.central_bank = central_bank
-+        self.config_module = config_module
-+        self.outstanding_bonds: List[BondDTO] = []
-+
-+    def evaluate_solvency(self, firm: 'Firm', current_tick: int) -> bool:
-+        """
-+        Evaluates a firm's solvency to determine bailout eligibility.
-+        - Startups (< 24 ticks old) are checked for a 3-month wage runway.
-+        - Established firms are evaluated using the Altman Z-Score.
-+        """
-+        startup_grace_period = getattr(self.config_module, "STARTUP_GRACE_PERIOD_TICKS", 24)
-+        z_score_threshold = getattr(self.config_module, "ALTMAN_Z_SCORE_THRESHOLD", 1.81)
-+
-+        if firm.age < startup_grace_period:
-+            # Runway Check for startups
-+            monthly_wage_bill = firm.hr.get_total_wage_bill() * 4  # Approximate monthly
-+            required_runway = monthly_wage_bill * 3
-+            return firm.assets >= required_runway
-+        else:
-+            # Altman Z-Score for established firms
-+            z_score = firm.finance.calculate_altman_z_score()
-+            return z_score > z_score_threshold
-+
-+    def issue_treasury_bonds(self, amount: float, current_tick: int) -> List[BondDTO]:
-+        """
-+        Issues new treasury bonds to the market.
-+        Yield is determined by the base rate plus a risk premium based on Debt-to-GDP ratio.
-+        """
-+        # This is a simplified auction. A real implementation would involve market participants.
-+        base_rate = self.central_bank.get_interest_rate()
-+        debt_to_gdp = self.government.get_debt_to_gdp_ratio()
-+
-+        # Exponential risk premium
-+        risk_premium = 0.0
-+        if debt_to_gdp > 1.2:
-+            risk_premium = 0.05
-+        elif debt_to_gdp > 0.9:
-+            risk_premium = 0.02
-+        elif debt_to_gdp > 0.6:
-+            risk_premium = 0.005
-+
-+        yield_rate = base_rate + risk_premium
-+
-+        # For now, assume the central bank buys all bonds as the buyer of last resort
-+        new_bond = BondDTO(
-+            id=f"BOND_{current_tick}",
-+            issuer="GOVERNMENT",
-+            face_value=amount,
-+            yield_rate=yield_rate,
-+            maturity_date=current_tick + getattr(self.config_module, "BOND_MATURITY_TICKS", 400) # 4 years
-+        )
-+        self.outstanding_bonds.append(new_bond)
-+        self.central_bank.purchase_bonds(new_bond)
-+        self.government.assets += amount
-+
-+        return [new_bond]
-+
-+    def grant_bailout_loan(self, firm: 'Firm', amount: float) -> BailoutLoanDTO:
-+        """Converts a bailout from a grant to an interest-bearing senior loan."""
-+        base_rate = self.central_bank.get_interest_rate()
-+        penalty_premium = getattr(self.config_module, "BAILOUT_PENALTY_PREMIUM", 0.05)
-+
-+        loan = BailoutLoanDTO(
-+            firm_id=firm.id,
-+            amount=amount,
-+            interest_rate=base_rate + penalty_premium,
-+            covenants={
-+                "dividends_allowed": False,
-+                "executive_salary_freeze": True
-+            }
-+        )
-+
-+        # The government provides the funds, which become a liability for the firm
-+        self.government.assets -= amount
-+        firm.finance.add_liability(amount, loan.interest_rate)
-+
-+        return loan
-+
-+
-+    def service_debt(self, current_tick: int) -> None:
-+        """Manages the servicing of outstanding government debt."""
-+        # This is a simplified version. A real implementation would handle interest payments
-+        # and bond maturation.
-+        matured_bonds = [b for b in self.outstanding_bonds if b.maturity_date <= current_tick]
-+        for bond in matured_bonds:
-+            self.government.assets -= bond.face_value
-+            self.outstanding_bonds.remove(bond)
-diff --git a/simulation/agents/central_bank.py b/simulation/agents/central_bank.py
-index a35ed64..c94968a 100644
---- a/simulation/agents/central_bank.py
-+++ b/simulation/agents/central_bank.py
-@@ -32,6 +32,12 @@ class CentralBank:
-             extra={"tick": 0, "tags": ["central_bank", "init"]}
-         )
- 
-+    def purchase_bonds(self, bond: Any) -> None:
-+        """Purchases government bonds, effectively performing QE."""
-+        # In a real model, this would add to the CB's balance sheet.
-+        # For now, this is a placeholder to complete the transaction loop.
-+        logger.info(f"CENTRAL_BANK_QE | Purchased bond {bond.id} for {bond.face_value:.2f}")
-+
-     def get_base_rate(self) -> float:
-         return self.base_rate
- 
-diff --git a/simulation/agents/government.py b/simulation/agents/government.py
-index 1d53d8c..684a1cd 100644
---- a/simulation/agents/government.py
-+++ b/simulation/agents/government.py
-@@ -102,6 +102,7 @@ class Government:
- 
-         # WO-057-B: Sensory Data Container
-         self.sensory_data: Optional[GovernmentStateDTO] = None
-+        self.finance_system = None
- 
-         logger.info(
-             f"Government {self.id} initialized with assets: {self.assets}",
-@@ -264,62 +265,40 @@ class Government:
-             details=f"Inf={inflation:.2%}, Growth={real_gdp_growth:.2%}, Gap={gdp_gap:.2%}, RateGap={gap:.4f}"
-         )
- 
--    def provide_subsidy(self, target_agent: Any, amount: float, current_tick: int):
--        """
--        Î≥¥Ï°∞Í∏àÏùÑ ÏßÄÍ∏âÌï©ÎãàÎã§.
--        AI Spending Multiplier Ï†ÅÏö©.
--        """
--        # Apply Multiplier based on Target
--        effective_amount = amount
--        agent_type = "household"
--        if hasattr(target_agent, "employees"): # Duck typing Firm
--            effective_amount *= self.firm_subsidy_budget_multiplier
--            agent_type = "firm"
--        else:
--            effective_amount *= self.welfare_budget_multiplier
-+    def provide_household_support(self, household: Any, amount: float, current_tick: int):
-+        """Provides subsidies to households (e.g., unemployment, stimulus)."""
-+        effective_amount = amount * self.welfare_budget_multiplier
- 
-         if effective_amount <= 0:
-             return 0.0
- 
--        if not getattr(self.config_module, "DEFICIT_SPENDING_ENABLED", False):
--            if self.assets < effective_amount:
--                return 0.0
--        else:
--            # WO-057-Active: Debt Ceiling Logic
--            if self.sensory_data and self.sensory_data.current_gdp > 0:
--                limit_ratio = getattr(self.config_module, "DEFICIT_SPENDING_LIMIT_RATIO", 0.3)
--                debt_limit = self.sensory_data.current_gdp * limit_ratio
--
--                projected_assets = self.assets - effective_amount
--
--                if abs(projected_assets) > debt_limit and projected_assets < 0:
--                    logger.warning(
--                        f"FISCAL_CLIFF_REACHED | Spending blocked. Debt {abs(self.assets):.2f} vs Limit {debt_limit:.2f}",
--                        extra={"tick": current_tick, "agent_id": self.id, "tags": ["fiscal_cliff", "deficit"]}
--                    )
--                    return 0.0
-+        if self.assets < effective_amount:
-+            needed = effective_amount - self.assets
-+            self.finance_system.issue_treasury_bonds(needed, current_tick)
- 
-         self.assets -= effective_amount
-         self.total_spent_subsidies += effective_amount
-         self.expenditure_this_tick += effective_amount
--
--        self.total_money_issued += effective_amount
--
--        target_agent.assets += effective_amount
-+        household.assets += effective_amount
-         self.current_tick_stats["welfare_spending"] += effective_amount
- 
-         logger.info(
--            f"SUBSIDY_PAID | Paid {effective_amount:.2f} subsidy to {target_agent.id} ({agent_type})",
--            extra={
--                "tick": current_tick,
--                "agent_id": self.id,
--                "amount": effective_amount,
--                "target_id": target_agent.id,
--                "tags": ["subsidy", "expenditure"]
--            }
-+            f"HOUSEHOLD_SUPPORT | Paid {effective_amount:.2f} to {household.id}",
-+            extra={"tick": current_tick, "agent_id": self.id, "amount": effective_amount, "target_id": household.id}
-         )
-         return effective_amount
- 
-+    def provide_firm_bailout(self, firm: Any, amount: float, current_tick: int):
-+        """Provides a bailout loan to a firm if it's eligible."""
-+        if self.finance_system.evaluate_solvency(firm, current_tick):
-+            logger.info(f"BAILOUT_APPROVED | Firm {firm.id} is eligible for a bailout.")
-+            loan = self.finance_system.grant_bailout_loan(firm, amount)
-+            self.expenditure_this_tick += amount
-+            return loan
-+        else:
-+            logger.warning(f"BAILOUT_DENIED | Firm {firm.id} is insolvent and not eligible for a bailout.")
-+            return None
-+
-     def get_survival_cost(self, market_data: Dict[str, Any]) -> float:
-         """ Calculates current survival cost based on food prices. """
-         avg_food_price = 0.0
-@@ -398,8 +377,7 @@ class Government:
- 
-                 # B. Unemployment Benefit
-                 if not agent.is_employed:
--                    # provide_subsidy now applies welfare_budget_multiplier
--                    self.provide_subsidy(agent, benefit_amount, current_tick)
-+                    self.provide_household_support(agent, benefit_amount, current_tick)
-                     total_welfare_paid += benefit_amount
- 
-         # 3. Stimulus Check (Legacy Logic, now influenced by AI multiplier)
-@@ -445,23 +423,11 @@ class Government:
-         if self.firm_subsidy_budget_multiplier < 0.8:
-             return False
- 
--        # WO-057-Active CRITICAL FIX: Apply Debt Ceiling to Infrastructure
--        if getattr(self.config_module, "DEFICIT_SPENDING_ENABLED", False):
--            if self.sensory_data and self.sensory_data.current_gdp > 0:
--                limit_ratio = getattr(self.config_module, "DEFICIT_SPENDING_LIMIT_RATIO", 0.3)
--                debt_limit = self.sensory_data.current_gdp * limit_ratio
--                projected_assets = self.assets - effective_cost
--                if abs(projected_assets) > debt_limit and projected_assets < 0:
--                    logger.warning(
--                        f"FISCAL_CLIFF_REACHED | Infrastructure investment blocked. Debt {abs(self.assets):.2f} vs Limit {debt_limit:.2f}",
--                        extra={"tick": current_tick, "agent_id": self.id, "tags": ["fiscal_cliff", "deficit"]}
--                    )
--                    return False
--        elif self.assets < effective_cost:
--            return False # Fallback to old behavior if deficit spending is off
-+        if self.assets < effective_cost:
-+            needed = effective_cost - self.assets
-+            self.finance_system.issue_treasury_bonds(needed, current_tick)
- 
-         self.assets -= effective_cost
--        self.total_money_issued += effective_cost
-         self.expenditure_this_tick += effective_cost
-         if reflux_system:
-             reflux_system.capture(effective_cost, str(self.id), "infrastructure")
-@@ -532,6 +498,14 @@ class Government:
-             "perceived_public_opinion": self.perceived_public_opinion
-         }
- 
-+    def get_debt_to_gdp_ratio(self) -> float:
-+        """Calculates the debt-to-GDP ratio."""
-+        if not self.sensory_data or self.sensory_data.current_gdp == 0:
-+            return 0.0
-+
-+        debt = max(0.0, -self.assets)
-+        return debt / self.sensory_data.current_gdp
-+
-     # WO-054: Public Education System
-     def run_public_education(self, agents: List[Any], config_module: Any, current_tick: int, reflux_system: Any = None) -> None:
-         """
-diff --git a/simulation/bank.py b/simulation/bank.py
-index 57d02a0..10bb398 100644
---- a/simulation/bank.py
-+++ b/simulation/bank.py
-@@ -71,6 +71,10 @@ class Bank:
-             extra={"tick": 0, "agent_id": self.id, "tags": ["init", "bank"]},
-         )
- 
-+    def get_interest_rate(self) -> float:
-+        """Returns the current base interest rate."""
-+        return self.base_rate
-+
-     def _get_config(self, key: str, default: Any) -> Any:
-         return getattr(self.config_module, key, default)
- 
-diff --git a/simulation/components/finance_department.py b/simulation/components/finance_department.py
-index 3320bfd..1ae122d 100644
---- a/simulation/components/finance_department.py
-+++ b/simulation/components/finance_department.py
-@@ -175,6 +175,43 @@ class FinanceDepartment:
- 
-         return 0.0
- 
-+    def add_liability(self, amount: float, interest_rate: float):
-+        """Adds a liability (like a loan) to the firm's balance sheet."""
-+        # This is a simplified implementation. A real one would track multiple loans.
-+        self.firm.assets += amount  # The loan increases cash assets
-+        # In a more complex model, this would be a separate liability account
-+        # For now, we'll just track the total debt.
-+        if not hasattr(self.firm, 'total_debt'):
-+            self.firm.total_debt = 0.0
-+        self.firm.total_debt += amount
-+
-+    def calculate_altman_z_score(self) -> float:
-+        """
-+        Calculates the Altman Z-Score for solvency, simplified for this model.
-+        Z = 1.2*X1 + 1.4*X2 + 3.3*X3
-+        X1: Working Capital / Total Assets
-+        X2: Retained Earnings / Total Assets
-+        X3: Average Profit / Total Assets
-+        """
-+        total_assets = self.firm.assets + self.firm.capital_stock + self.firm.get_inventory_value()
-+        if total_assets == 0:
-+            return 0.0
-+
-+        # X1: Working Capital / Total Assets
-+        # Working Capital = Current Assets - Current Liabilities. Assume liabilities are total_debt for now.
-+        working_capital = self.firm.assets - getattr(self.firm, 'total_debt', 0.0)
-+        x1 = working_capital / total_assets
-+
-+        # X2: Retained Earnings / Total Assets
-+        x2 = self.retained_earnings / total_assets
-+
-+        # X3: Average Profit / Total Assets
-+        avg_profit = sum(self.profit_history) / len(self.profit_history) if self.profit_history else 0.0
-+        x3 = avg_profit / total_assets
-+
-+        z_score = 1.2 * x1 + 1.4 * x2 + 3.3 * x3
-+        return z_score
-+
-     def check_bankruptcy(self):
-         if self.current_profit < 0:
-             self.consecutive_loss_turns += 1
-diff --git a/simulation/engine.py b/simulation/engine.py
-index 8906d0d..41bd182 100644
---- a/simulation/engine.py
-+++ b/simulation/engine.py
-@@ -35,6 +35,7 @@ from simulation.systems.generational_wealth_audit import GenerationalWealthAudit
- from simulation.decisions.housing_manager import HousingManager # For rank/tier helper
- from simulation.ai.vectorized_planner import VectorizedHouseholdPlanner
- from simulation.systems.transaction_processor import TransactionProcessor # SoC Refactor
-+from modules.finance.system import FinanceSystem
- 
- # Use the repository pattern for data access
- from simulation.db.repository import SimulationRepository
-@@ -114,6 +115,14 @@ class Simulation:
-         # similar to how markets are handled, or we can add it if needed.
-         # But it doesn't participate in normal transactions.
- 
-+        # Finance System (Sovereign Debt)
-+        self.finance_system = FinanceSystem(
-+            government=self.government,
-+            central_bank=self.central_bank,
-+            config_module=self.config_module
-+        )
-+        self.government.finance_system = self.finance_system # Inject into government
-+
-         # Phase 17-3A: Initialize Real Estate Units
-         self.real_estate_units: List[RealEstateUnit] = [
-             RealEstateUnit(id=i, estimated_value=self.config_module.INITIAL_PROPERTY_VALUE,
-@@ -518,6 +527,13 @@ class Simulation:
-         # 4. Election Check
-         self.government.check_election(self.time)
- 
-+        # Age firms
-+        for firm in self.firms:
-+            firm.age += 1
-+
-+        # Service national debt
-+        self.finance_system.service_debt(self.time)
-+
-         # Phase 4: Welfare Check (Executes Subsidies based on Policy)
-         self.government.run_welfare_check(list(self.agents.values()), market_data, self.time)
- 
-diff --git a/simulation/firms.py b/simulation/firms.py
-index 204b7d4..21ff0c1 100644
---- a/simulation/firms.py
-+++ b/simulation/firms.py
-@@ -133,6 +133,7 @@ class Firm(BaseAgent):
-         self.automation_level: float = 0.0 # 0.0 to 1.0
-         self.system2_planner: Optional[FirmSystem2Planner] = None # Initialized later
- 
-+        self.age = 0
-         self.decision_engine.loan_market = loan_market
- 
-     def init_ipo(self, stock_market: StockMarket):
-diff --git a/tests/test_ai_driven_firm_engine.py b/tests/test_ai_driven_firm_engine.py
-index c1cc839..b837a96 100644
---- a/tests/test_ai_driven_firm_engine.py
-+++ b/tests/test_ai_driven_firm_engine.py
-@@ -48,18 +48,30 @@ def mock_firm(mock_config):
-     firm.employees = []
-     firm.profit_history = []
-     firm.productivity_factor = 1.0
-+    firm.age = 25 # Add age for solvency checks
-+    firm.finance = Mock() # Mock the finance department
-     return firm
- 
- 
- def test_adjust_price_tactic(firm_decision_engine_instance, mock_firm):
-     """Test that the ADJUST_PRICE tactic correctly adjusts the price."""
-+    from simulation.dtos import DecisionContext
-+
-     mock_firm.inventory["food"] = 200
-     mock_firm.production_target = 100
--    firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
--        Tactic.ADJUST_PRICE
-+    firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
-+        (Tactic.ADJUST_PRICE, 1.0)
-     )
- 
--    orders, _ = firm_decision_engine_instance.make_decisions(mock_firm, {}, [], {}, 1)
-+    context = DecisionContext(
-+        firm=mock_firm,
-+        markets={},
-+        goods_data=[],
-+        market_data={},
-+        current_time=1,
-+        government=None,
-+    )
-+    orders, _ = firm_decision_engine_instance.make_decisions(context)
- 
-     assert len(orders) == 1
-     order = orders[0]
-diff --git a/tests/test_engine.py b/tests/test_engine.py
-index c1d15e5..1276bf0 100644
---- a/tests/test_engine.py
-+++ b/tests/test_engine.py
-@@ -180,6 +180,7 @@ def mock_firms(mock_config_module):
-     f1.is_active = True
-     f1.total_shares = 1000.0
-     f1.treasury_shares = 0.0
-+    f1.age = 25 # Set age for testing
- 
-     f2 = Firm(
-         id=102,
-@@ -195,6 +196,7 @@ def mock_firms(mock_config_module):
-     f2.is_active = False  # Inactive firm
-     f2.total_shares = 1000.0
-     f2.treasury_shares = 0.0
-+    f2.age = 25 # Set age for testing
-     return [f1, f2]
- 
- 
-@@ -256,6 +258,8 @@ def simulation_instance(
-         mock_config_module,
-         mock_goods_data,
-     )
-+    sim.government.finance_system = Mock()
-+    sim.government.get_debt_to_gdp_ratio = Mock(return_value=0.5)
-     return sim
- 
- 
-diff --git a/tests/test_firm_decision_engine_new.py b/tests/test_firm_decision_engine_new.py
-index 57f1492..826fe96 100644
---- a/tests/test_firm_decision_engine_new.py
-+++ b/tests/test_firm_decision_engine_new.py
-@@ -62,8 +62,10 @@ def mock_firm(mock_config):
-     firm.cost_this_turn = 0.0
-     firm.profit_history = deque(maxlen=mock_config.PROFIT_HISTORY_TICKS)
-     firm.specialization = "food"
--    # Add a mock for the logger attribute
-     firm.logger = MagicMock()
-+    firm.age = 25 # Add age for solvency checks
-+    firm.finance = Mock() # Mock the finance department
-+    firm.hr = Mock() # Mock the HR department
-     return firm
- 
- 
-@@ -93,7 +95,7 @@ class TestFirmDecisionEngine:
-     def test_make_decisions_overstock_reduces_target(
-         self, firm_decision_engine_instance, mock_firm, mock_config
-     ):
--        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
-+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
-             Tactic.ADJUST_PRODUCTION, Aggressiveness.NORMAL
-         )
-         mock_firm.inventory["food"] = 150.0 # Force overstock (150 > 100 * 1.2)
-@@ -106,6 +108,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
- 
-@@ -120,7 +123,7 @@ class TestFirmDecisionEngine:
-     ):
-         mock_firm.inventory["food"] = 50.0
-         initial_target = mock_firm.production_target
--        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
-+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
-             Tactic.ADJUST_PRODUCTION, Aggressiveness.NORMAL
-         )
- 
-@@ -130,6 +133,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
- 
-@@ -144,7 +148,7 @@ class TestFirmDecisionEngine:
-     ):
-         mock_firm.inventory["food"] = 100.0
-         initial_target = mock_firm.production_target
--        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
-+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
-             Tactic.ADJUST_PRODUCTION, Aggressiveness.NORMAL
-         )
- 
-@@ -154,6 +158,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
- 
-@@ -162,7 +167,7 @@ class TestFirmDecisionEngine:
-     def test_make_decisions_target_min_max_bounds(
-         self, firm_decision_engine_instance, mock_firm, mock_config
-     ):
--        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
-+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
-             Tactic.ADJUST_PRODUCTION, Aggressiveness.NORMAL
-         )
-         # Test min bound
-@@ -174,6 +179,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
-         assert mock_firm.production_target == mock_config.FIRM_MIN_PRODUCTION_TARGET
-@@ -187,6 +193,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
-         assert mock_firm.production_target == mock_config.FIRM_MAX_PRODUCTION_TARGET
-@@ -196,7 +203,7 @@ class TestFirmDecisionEngine:
-     ):
-         mock_firm.employees = []
-         mock_firm.inventory["food"] = 0  # Ensure production is needed
--        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
-+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
-             Tactic.ADJUST_WAGES, Aggressiveness.NORMAL
-         )
- 
-@@ -206,6 +213,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={"avg_wage": 10.0},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
- 
-@@ -214,7 +222,7 @@ class TestFirmDecisionEngine:
-         ]
-         assert len(buy_labor_orders) > 0
-         assert buy_labor_orders[0].quantity == 1.0
--        assert buy_labor_orders[0].market_id == "labor_market"
-+        assert buy_labor_orders[0].market_id == "labor"
- 
-     def test_make_decisions_hires_for_needed_labor(
-         self, firm_decision_engine_instance, mock_firm, mock_config
-@@ -222,7 +230,7 @@ class TestFirmDecisionEngine:
-         mock_firm.employees = [Mock()]
-         mock_firm.production_target = 500
-         mock_firm.inventory["food"] = 0  # Ensure production is needed
--        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
-+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
-             Tactic.ADJUST_WAGES, Aggressiveness.NORMAL
-         )
- 
-@@ -232,6 +240,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={"avg_wage": 10.0},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
- 
-@@ -246,7 +255,7 @@ class TestFirmDecisionEngine:
-     ):
-         mock_firm.employees = [Mock() for _ in range(mock_config.FIRM_MAX_EMPLOYEES)]
-         mock_firm.production_target = 500
--        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
-+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
-             Tactic.ADJUST_WAGES, Aggressiveness.NORMAL
-         )
- 
-@@ -256,6 +265,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
- 
-@@ -270,7 +280,7 @@ class TestFirmDecisionEngine:
-         mock_firm.employees = [Mock() for _ in range(10)]
-         mock_firm.production_target = 0
-         mock_firm.inventory = {"food": 1000}
--        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
-+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
-             Tactic.ADJUST_WAGES, Aggressiveness.NORMAL
-         )
- 
-@@ -280,6 +290,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
- 
-@@ -312,7 +323,7 @@ class TestFirmDecisionEngine:
-         assert labor_order is not None
-         assert labor_order.agent_id == mock_firm.id
-         assert labor_order.quantity == 1.0
--        assert labor_order.market_id == "labor_market"
-+        assert labor_order.market_id == "labor"
- 
-     def test_make_decisions_does_not_sell_if_understocked(
-         self, firm_decision_engine_instance, mock_firm
-@@ -327,6 +338,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
-         sell_orders = [
-@@ -347,6 +359,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
-         sell_orders = [
-@@ -368,6 +381,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
-         sell_order = next(
-@@ -389,6 +403,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
-         sell_order = next(
-@@ -412,6 +427,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
-         sell_order = next(
-@@ -429,6 +445,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
-         sell_order = next(
-@@ -450,6 +467,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
-         sell_order = next(
-@@ -473,6 +491,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
-         sell_order = next(
-@@ -498,6 +517,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
- 
-@@ -523,6 +543,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
- 
-@@ -548,6 +569,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
- 
-@@ -576,6 +598,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
-         sell_order = next(
-@@ -594,6 +617,7 @@ class TestFirmDecisionEngine:
-             goods_data=[],
-             market_data={},
-             current_time=1,
-+            government=None,
-         )
-         orders, _ = firm_decision_engine_instance.make_decisions(context)
-         sell_order = next(
diff --git a/design/gemini_output/pr_review_sovereign-debt-wip-7617648577093442794.md b/design/gemini_output/pr_review_sovereign-debt-wip-7617648577093442794.md
deleted file mode 100644
index 4be5c3d..0000000
--- a/design/gemini_output/pr_review_sovereign-debt-wip-7617648577093442794.md
+++ /dev/null
@@ -1,43 +0,0 @@
-# üèõÔ∏è Architecture Review: Sovereign Debt & Financial Credit (WO-072 WIP)
-
-**Reviewer:** Antigravity (Team Leader)
-**Target Branch:** `jules/sovereign-debt-wip-7617648577093442794`
-**Status:** üü° CONDITIONAL APPROVAL (Logic Refinement Required)
-
----
-
-## üîç 1. Î™ÖÏÑ∏ Ï§ÄÏàò Ïó¨Î∂Ä (Specification Compliance)
-
-| Ìï≠Î™© | ÏÉÅÌÉú | Î∂ÑÏÑù Î∞è ÌîºÎìúÎ∞± |
-|---|---|---|
-| **Startup Grace Period** | ‚úÖ Ï§ÄÏàò | `firm.age < 24` Î°úÏßÅÏù¥ `evaluate_solvency`Ïóê Ï†ïÌôïÌûà Î∞òÏòÅÎê®. |
-| **Altman Z-Score** | ‚úÖ Ï§ÄÏàò | `1.2*X1 + 1.4*X2 + 3.3*X3` Í≥µÏãùÏù¥ FinanceDepartmentÏóê Ï†ÅÏ†àÌûà Íµ¨ÌòÑÎê®. |
-| **Bailout Loan Covenants** | ‚ö†Ô∏è Î∂ÄÎ∂Ñ ÎØ∏Ìù° | Î∞∞Îãπ Í∏àÏßÄ, ÏûÑÍ∏à ÎèôÍ≤∞ÏùÄ Î∞òÏòÅÎêòÏóàÏúºÎÇò, **Î™ÖÏÑ∏ÏÑúÏùò 'Ïù¥Ïùµ Î∞úÏÉù Ïãú 50% Í∞ïÏ†ú ÏÉÅÌôò' Ï°∞Ìï≠Ïù¥ ÎàÑÎùΩÎê®.** |
-| **Sovereign Bond Yield** | ‚úÖ Ï§ÄÏàò | Debt-to-GDP Í∏∞Î∞òÏùò Risk Premium Í∞ÄÏÇ∞ Î°úÏßÅÏù¥ Íµ¨ÌòÑÎê®. |
-| **CB Intervention (QE)** | ‚ùå ÏúÑÎ∞ò | Î™ÖÏÑ∏ÏÑú: **"Í∏àÎ¶¨ 10% Ï¥àÍ≥º ÏãúÏóêÎßå ÏàòÎèôÏ†Å Îß§ÏûÖ"** / ÌòÑÏû¨: **"Î™®Îì† Î∞úÌñâ Ï±ÑÍ∂åÏùÑ Ï§ëÏïôÏùÄÌñâÏù¥ Îß§ÏûÖ"**. Crowding Out Ìö®Í≥ºÍ∞Ä ÏÉÅÏáÑÎê† Ïö∞Î†§Í∞Ä ÌÅº. |
-
----
-
-## üö© 2. Í∏∞Ïà† Î∂ÄÏ±Ñ Î∞è ÌïòÎìúÏΩîÎî© (Technical Debt Audit Alignment)
-
-Î∞©Í∏à Ï†Ñ ÏôÑÎ£åÎêú ÏΩîÎìú Ï†ÑÏàò Ï°∞ÏÇ¨(Audit) Í≤∞Í≥ºÏôÄ ÎåÄÏ°∞ÌñàÏùÑ Îïå, ÏÉàÎ°úÏö¥ Î∂ÄÏ±ÑÍ∞Ä ÏãùÎ≥ÑÎêòÏóàÏäµÎãàÎã§.
-
-- **[New Debt] Static Bond Maturity**: `BOND_MATURITY_TICKS = 400`Ïù¥ ÌïòÎìúÏΩîÎî©ÎêòÏñ¥ ÏãúÏû• ÏÉÅÌô©Ïóê Îî∞Î•∏ Îã®Í∏∞/Ïû•Í∏∞ Ï±ÑÍ∂å Ïö¥Ïö©Ïù¥ Î∂àÍ∞ÄÎä•Ìï®. (TD-043 ÏòàÏ†ï)
-- **[New Debt] Hardcoded Risk Premium Tiers**: Debt-to-GDP Íµ¨Í∞Ñ(0.6, 0.9, 1.2)Í≥º Í∞ÄÏÇ∞ Í∏àÎ¶¨(0.005, 0.02, 0.05)Í∞Ä `if/elif`Î°ú Í≥†Ï†ïÎê®. Ïù¥Îäî Ï†ïÏ±Ö AIÍ∞Ä ÌïôÏäµÌï† Ïó¨ÏßÄÎ•º Ï∞®Îã®Ìï®.
-
----
-
-## üõ†Ô∏è 3. Ï£ºÏöî ÏàòÏ†ï Í∂åÍ≥† ÏÇ¨Ìï≠ (Action Items)
-
-1. **FinanceSystem.issue_treasury_bonds**: Ï§ëÏïôÏùÄÌñâÏùò Î¨¥Ï°∞Í±¥Ï†Å Îß§ÏûÖÏùÑ Ï§ëÎã®ÌïòÍ≥†, Í∏àÎ¶¨Í∞Ä ÏùºÏ†ï ÏàòÏ§Ä(10%) Ïù¥ÌïòÏùº ÎïåÎäî ÏãúÏû•(ÏùÄÌñâ/Í∞ÄÍ≥Ñ)Ïóê Î®ºÏ†Ä ÌåêÎß§Î•º ÏãúÎèÑÌïòÍ±∞ÎÇò Î∞úÌñâÏóê Ïã§Ìå®ÌïòÎäî Î°úÏßÅ(Crowding Out Ïú†ÎèÑ)ÏùÑ Ï∂îÍ∞ÄÌï¥Ïïº Ìï®.
-2. **Bailout Covenants**: `mandatory_repayment = 0.5 * profit` Î°úÏßÅÏùÑ Í∏∞ÏóÖÏùò ÏàòÏùµ Ï†ïÏÇ∞ Ï£ºÍ∏∞(`Firm.finalize_turn`)Ïóê Ï£ºÏûÖÌï¥Ïïº Ìï®.
-3. **Runway Check**: ÌòÑÏû¨ `assets` Í∏∞Ï§ÄÏóêÏÑú Î™ÖÏÑ∏ÏÑúÏóê Î™ÖÏãúÎêú `cash_reserve` ÎòêÎäî `liquid_assets` Í∏∞Ï§ÄÏúºÎ°ú Î≤îÏúÑÎ•º Ï¢ÅÌûàÎäî Í≤ÉÏùÑ Í∂åÏû•Ìï®. (Í≥†Ï†ï ÏûêÏÇ∞ÏúºÎ°ú ÏûÑÍ∏àÏùÑ Ï§Ñ ÏàòÎäî ÏóÜÍ∏∞ ÎïåÎ¨∏)
-
----
-
-## üß™ 4. ÌÖåÏä§Ìä∏ Ïã§Ìå®Ïóê ÎåÄÌïú ÏûÖÏû•
-
-JulesÍ∞Ä ÏßÅÎ©¥Ìïú ÎåÄÍ∑úÎ™® ÌÖåÏä§Ìä∏ Ïã§Ìå®Îäî `Firm`Í≥º `Government`Ïóê ÌïÑÎìúÍ∞Ä Ï∂îÍ∞ÄÎêòÎ©¥ÏÑú Î∞úÏÉùÌïòÎäî **Fixture Î∂àÏùºÏπò** Î¨∏Ï†úÏûÖÎãàÎã§. 
-- ÌïµÏã¨ Î°úÏßÅ(ÏÉÅÍ∏∞ Action Items)Ïù¥ ÏàòÏ†ïÎêú ÌõÑÏóê Í≥µÌÜµ `conftest.py` ÎòêÎäî Mock ÏÉùÏÑ± Î°úÏßÅÏùÑ ÏóÖÎç∞Ïù¥Ìä∏ÌïòÎäî Í≤ÉÏù¥ Ìö®Ïú®Ï†ÅÏûÖÎãàÎã§.
-
-**Í≤∞Î°†:** JulesÏóêÍ≤å ÏúÑ Action ItemsÎ•º Ï†ÑÎã¨ÌïòÏó¨ Î°úÏßÅÏùÑ Î®ºÏ†Ä Î≥¥Í∞ïÌïòÎèÑÎ°ù ÏßÄÏãúÌïòÍ≤†ÏäµÎãàÎã§.
diff --git a/design/gemini_output/pr_review_sovereign_debt_wip.md b/design/gemini_output/pr_review_sovereign_debt_wip.md
deleted file mode 100644
index 7f8d6f9..0000000
--- a/design/gemini_output/pr_review_sovereign_debt_wip.md
+++ /dev/null
@@ -1,26 +0,0 @@
-Traceback (most recent call last):
-  File "C:\coding\economics\scripts\gemini_worker.py", line 303, in main
-    worker.execute(
-    ~~~~~~~~~~~~~~^
-        args.instruction,
-        ^^^^^^^^^^^^^^^^^
-    ...<2 lines>...
-        output_file=getattr(args, 'output', None)
-        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-    )
-    ^
-  File "C:\coding\economics\scripts\gemini_worker.py", line 244, in execute
-    print(f"\u2696\ufe0f Validating Protocol: '{instruction}'...")
-    ~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-UnicodeEncodeError: 'cp949' codec can't encode character '\u2696' in position 0: illegal multibyte sequence
-
-During handling of the above exception, another exception occurred:
-
-Traceback (most recent call last):
-  File "C:\coding\economics\scripts\gemini_worker.py", line 315, in <module>
-    main()
-    ~~~~^^
-  File "C:\coding\economics\scripts\gemini_worker.py", line 311, in main
-    print(f"\u274c Error: {e}")
-    ~~~~~^^^^^^^^^^^^^^^^^^
-UnicodeEncodeError: 'cp949' codec can't encode character '\u274c' in position 0: illegal multibyte sequence
diff --git a/gemini-go.bat b/gemini-go.bat
index 2dc634e..22c8ff9 100644
--- a/gemini-go.bat
+++ b/gemini-go.bat
@@ -7,13 +7,12 @@ set PYTHONIOENCODING=utf-8
 :: Gemini-CLI HITL 2.0: Spec Drafting
 :: ==============================================================================
 ::
-:: +-----------------------------------------------------------------------------+
-:: |  ANTIGRAVITY SELF-REFERENCE MANUAL                                          |
-:: |  Available workers: spec, git, verify, context, scribe, audit               |
-:: |  Usage: python scripts/gemini_worker.py <worker> "<instruction>" -c ...     |
-:: |  << DIR CONTEXT >>: Dir path is allowed for -c (Auto-recurse all .py)       |
-:: |  OUTPUT: design\gemini_output\spec_draft.md (or designated file)            |
-:: +-----------------------------------------------------------------------------+
+:: +-------------------------------------------------------------------------+
+:: |  ANTIGRAVITY SELF-REFERENCE MANUAL                                      |
+:: |  Available workers: spec, git, verify, context, scribe                  |
+:: |  Usage: python scripts/gemini_worker.py <worker> "<instruction>" -c ... |
+:: |  OUTPUT: design\gemini_output\spec_draft.md                             |
+:: +-------------------------------------------------------------------------+
 ::
 :: ==============================================================================
 :: [CURRENT CONTEXT]
@@ -30,14 +29,14 @@ echo [Gemini-CLI] Drafting spec...
 echo ============================================================
 
 :: [COMMAND SLOT]
-:: Target: Technical Debt Audit (Hardcoded/Rule-based)
-:: Task: Identify all magic numbers and rigid heuristics.
+:: Target: Phase 26.5 Sovereign Debt & Bailout Refactor
+:: Task: Create Zero-Question Spec for National Debt and Loan-based CPR
 
-python scripts/gemini_worker.py audit "Task: Identify all hardcoded magic numbers and rule-based heuristics across the codebase. Focus: 1) config.py: Arbitrary constants. 2) simulation/agents/: Hardcoded thresholds, fixed rates, and deterministic if/else decision logic. 3) simulation/systems/: Rigid formulas that should be adaptive. Output: A detailed list of Technical Debts (TD-XXX) with file paths, code snippets, and why they require re-planning for 'Adaptive AI Migration'." -c simulation/ config.py > design\gemini_output\audit_hardcoded_debt.md 2>&1
+python scripts/gemini_worker.py spec "Task: Create a detailed specification for 'Sovereign Debt & Corporate Bailout System'. Context: Currently, bailouts are free grants. We need to convert them to Senior Debt Loans and introduce Government Bonds (Sovereign Debt) to bridge fiscal deficits. Key Requirements: 1) CPR Refactor: AS-IS Grants -> TO-BE Interest-bearing Loans. Covenants: No dividends and executive salary freeze for debtors. 2) Solvency Check: Simplified Altman Z-Score (LiquidAssets, RetainedEarnings) to filter 'Zombie Firms'. 3) Bond Issuance: Market-driven bond yields acting as a benchmark. Roles of Banks, Households, and CB (QE). Include: Data structures (BondDTO, BailoutLoanDTO), pseudo-code for eligibility/issuance logic, and Phase 26 integration. Output: Markdown format." -c simulation/agents/government.py simulation/systems/bootstrapper.py simulation/agents/firm.py > design\gemini_output\spec_draft.md 2>&1
 
 if %ERRORLEVEL% NEQ 0 (
-    echo [ERROR] Gemini task execution failed. Check logs.
+    echo [ERROR] Spec drafting failed.
 ) else (
-    echo [SUCCESS] Gemini task completed successfully. Check design\gemini_output\
+    echo [SUCCESS] Spec draft saved to design\gemini_output\spec_draft.md
 )
 endlocal
diff --git a/insights/mass_liquidation_risk_report.md b/insights/mass_liquidation_risk_report.md
new file mode 100644
index 0000000..d1e8d35
--- /dev/null
+++ b/insights/mass_liquidation_risk_report.md
@@ -0,0 +1,29 @@
+# Mass Liquidation Risk Report
+
+## Introduction
+
+The introduction of a sovereign debt market and the transition from grants to interest-bearing bailout loans fundamentally changes the economic simulation. While these changes are designed to create a more realistic and responsible economic model, they also introduce new systemic risks. This report outlines the potential for mass liquidation events and the cascading failures that could result.
+
+## Key Risk Factors
+
+1.  **Zombie Firm Collapse:** The implementation of the Altman Z-Score will correctly identify and lead to the liquidation of "zombie firms" that are no longer financially viable. However, a sudden, simultaneous collapse of multiple zombie firms could trigger a deflationary spiral.
+
+2.  **Credit Crunch:** As the government issues bonds to finance its spending, it will compete with the private sector for a limited pool of capital. This "crowding out" effect will drive up interest rates, making it more expensive for firms to borrow and invest. A severe credit crunch could stifle economic growth and lead to a wave of bankruptcies.
+
+3.  **Sovereign Debt Crisis:** If the government's debt-to-GDP ratio rises to unsustainable levels, investor confidence could collapse, leading to a spike in bond yields. A sovereign debt crisis would force the government to implement austerity measures, further depressing the economy and potentially leading to a "doom loop" of rising debt and falling growth.
+
+## Potential Cascading Failures
+
+*   **Bank Insolvency:** A wave of corporate bankruptcies could lead to a surge in non-performing loans, threatening the solvency of the banking system.
+*   **Mass Unemployment:** The liquidation of firms will lead to job losses, reducing aggregate demand and further depressing the economy.
+*   **Deflationary Spiral:** Falling prices and wages could increase the real burden of debt, leading to a vicious cycle of defaults, bankruptcies, and economic contraction.
+
+## Mitigation Strategies
+
+*   **Central Bank Intervention:** The Central Bank can act as a lender of last resort, providing liquidity to the banking system and purchasing government bonds to keep interest rates low.
+*   **Counter-cyclical Fiscal Policy:** The government can use fiscal stimulus to support the economy during a downturn, but this must be balanced against the risk of a sovereign debt crisis.
+*   **Orderly Liquidation:** Mechanisms could be put in place to ensure the orderly liquidation of failed firms, preventing a fire sale of assets that could depress prices and trigger a wider panic.
+
+## Conclusion
+
+The new economic model is more realistic, but it is also more fragile. The risk of mass liquidation events is real and should be carefully monitored. A combination of prudent fiscal policy, proactive central banking, and robust financial regulation will be needed to mitigate these risks and ensure the long-term stability of the simulated economy.
diff --git a/jules-go.bat b/jules-go.bat
index 50fc50a..6941d8e 100644
--- a/jules-go.bat
+++ b/jules-go.bat
@@ -24,8 +24,8 @@ set PYTHONIOENCODING=utf-8
 ::
 :: ==============================================================================
 :: [CURRENT CONTEXT]
-:: Target: WO-072 (Sovereign Debt)
-:: Action: Logic Review & Correction Dispatch
+:: Target: TD-024 (Pytest Path Fix) - Phase 26 Pre-requisite
+:: Action: Jules Warm-up Task
 :: ==============================================================================
 set PYTHONIOENCODING=utf-8
 
@@ -33,13 +33,13 @@ if not exist "communications\jules_logs" (
     mkdir "communications\jules_logs"
 )
 
-echo [Jules-Bridge] Sending message to WO-072 session...
+echo [Jules-Bridge] Creating TD-024 session...
 echo ----------------------------------------------------
 
 :: [COMMAND SLOT]
-:: Target: WO-072 (Sovereign Debt) - Action: Core Logic Correction
-:: Î¶¨Î∑∞ Í≤∞Í≥º(QE Ï°∞Í±¥, ÏÉÅÌôò Í∑úÏïΩ, ÌïòÎìúÏΩîÎî©)Î•º Î∞îÌÉïÏúºÎ°ú Î°úÏßÅ ÏàòÏ†ïÏùÑ ÏßÄÏãúÌï©ÎãàÎã§.
-python scripts/jules_bridge.py send-message 7617648577093442794 "Review complete. I have identified 3 critical logic gaps in your WIP PR. Prioritize fixing these before worrying about the unit tests: 1) QE Violation: Limit Central Bank intervention only when yields exceed 10%. Currently, you are masking the Crowding Out effect. 2) Missing Covenant: Implement mandatory repayment (50% of profit) in the bailout loan logic. 3) New Hardcoding Debt: Refactor static bond maturity and risk premium tiers to use config constants. See 'design/gemini_output/pr_review_sovereign-debt-wip-7617648577093442794.md' for details. Fix the heart of the system first." > communications\jules_logs\last_run.md 2>&1
+:: Target: WO-072 (Phase 26.5)
+:: Action: Implement Sovereign Debt & Bailout Finance System
+python scripts/jules_bridge.py create "WO-072: Sovereign Debt & Financial Credit" "Mission: 'Í≥µÏßú Ï†êÏã¨'Ïùò ÏãúÎåÄÎ•º ÎÅùÎÇ¥Í≥† Î∂ÄÏ±Ñ Í∏∞Î∞òÏùò Ï±ÖÏûÑ Í≤ΩÏ†úÎ•º Íµ¨Ï∂ïÌïòÎùº. Reference: design/specs/SOVEREIGN_DEBT_SPEC.md. Tasks: 1) modules/finance/api.pyÏóê DTO Î∞è Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ Ï†ïÏùò. 2) Altman Z-Score Í∏∞Î∞ò ÏÜîÎ≤§Ïãú Ï≤¥ÌÅ¨ Íµ¨ÌòÑ (Startup Grace Period Ï§ÄÏàò). 3) Íµ≠Ï±Ñ Î∞úÌñâ Î∞è ÏãúÏû• Í∏àÎ¶¨ ÌòïÏÑ± Î°úÏßÅ Íµ¨ÌòÑ. 4) Íµ¨Ï†úÍ∏àÏúµÏùÑ Î≥¥Ï°∞Í∏àÏóêÏÑú Ïù¥ÏûêÎ∂Ä ÎåÄÏ∂úÎ°ú Ï†ÑÌôòÌïòÎùº. Success Criteria: Z-Score 1.81 ÎØ∏ÎßåÏùò Ï¢ÄÎπÑ Í∏∞ÏóÖ Ìá¥Ï∂ú Î∞è Íµ≠Ï±Ñ Í∏àÎ¶¨Ïóê Îî∞Î•∏ ÏûêÍ∏à ÏúÑÏ∂ï(Crowding out) Ï¶ùÎ™Ö. Reporting: insights/Ïóê mass liquidation Î¶¨Ïä§ÌÅ¨ Î≥¥Í≥†." > communications\jules_logs\last_run.md 2>&1
 
 if %ERRORLEVEL% NEQ 0 (
     echo [ERROR] Command failed. Check logs.
diff --git a/modules/finance/api.py b/modules/finance/api.py
new file mode 100644
index 0000000..34eae27
--- /dev/null
+++ b/modules/finance/api.py
@@ -0,0 +1,34 @@
+from typing import Protocol, Dict, List
+from dataclasses import dataclass
+
+@dataclass
+class BondDTO:
+    """Data Transfer Object for government bonds."""
+    id: str
+    issuer: str
+    face_value: float
+    yield_rate: float
+    maturity_date: int
+
+@dataclass
+class BailoutLoanDTO:
+    """Data Transfer Object for corporate bailout loans."""
+    firm_id: int
+    amount: float
+    interest_rate: float
+    covenants: Dict[str, bool]
+
+class IFinanceSystem(Protocol):
+    """Interface for the sovereign debt and corporate bailout system."""
+
+    def evaluate_solvency(self, firm: 'Firm', current_tick: int) -> bool:
+        """Evaluates a firm's solvency to determine bailout eligibility."""
+        ...
+
+    def issue_treasury_bonds(self, amount: float) -> List[BondDTO]:
+        """Issues new treasury bonds to the market."""
+        ...
+
+    def service_debt(self) -> None:
+        """Manages the servicing of outstanding government debt."""
+        ...
diff --git a/modules/finance/system.py b/modules/finance/system.py
new file mode 100644
index 0000000..a26556f
--- /dev/null
+++ b/modules/finance/system.py
@@ -0,0 +1,115 @@
+from typing import List, Dict
+from modules.finance.api import IFinanceSystem, BondDTO, BailoutLoanDTO
+# Forward reference for type hinting
+from simulation.firms import Firm
+
+class FinanceSystem(IFinanceSystem):
+    """Manages sovereign debt, corporate bailouts, and solvency checks."""
+
+    def __init__(self, government: 'Government', central_bank: 'CentralBank', bank: 'Bank', config_module: any):
+        self.government = government
+        self.central_bank = central_bank
+        self.bank = bank
+        self.config_module = config_module
+        self.outstanding_bonds: List[BondDTO] = []
+
+    def evaluate_solvency(self, firm: 'Firm', current_tick: int) -> bool:
+        """
+        Evaluates a firm's solvency to determine bailout eligibility.
+        - Startups (< 24 ticks old) are checked for a 3-month wage runway.
+        - Established firms are evaluated using the Altman Z-Score.
+        """
+        startup_grace_period = getattr(self.config_module, "STARTUP_GRACE_PERIOD_TICKS", 24)
+        z_score_threshold = getattr(self.config_module, "ALTMAN_Z_SCORE_THRESHOLD", 1.81)
+
+        if firm.age < startup_grace_period:
+            # Runway Check for startups
+            monthly_wage_bill = firm.hr.get_total_wage_bill() * 4  # Approximate monthly
+            required_runway = monthly_wage_bill * 3
+            return firm.cash_reserve >= required_runway
+        else:
+            # Altman Z-Score for established firms
+            z_score = firm.finance.calculate_altman_z_score()
+            return z_score > z_score_threshold
+
+    def issue_treasury_bonds(self, amount: float, current_tick: int) -> List[BondDTO]:
+        """
+        Issues new treasury bonds to the market, allowing for crowding out.
+        The Central Bank only intervenes if yields exceed a critical threshold.
+        """
+        base_rate = self.central_bank.get_interest_rate()
+        debt_to_gdp = self.government.get_debt_to_gdp_ratio()
+
+        # Config-driven risk premium tiers
+        risk_premium_tiers = getattr(self.config_module, "DEBT_RISK_PREMIUM_TIERS", {
+            1.2: 0.05,
+            0.9: 0.02,
+            0.6: 0.005,
+        })
+
+        risk_premium = 0.0
+        for threshold, premium in sorted(risk_premium_tiers.items(), reverse=True):
+            if debt_to_gdp > threshold:
+                risk_premium = premium
+                break
+
+        yield_rate = base_rate + risk_premium
+
+        bond_maturity = getattr(self.config_module, "BOND_MATURITY_TICKS", 400)
+        new_bond = BondDTO(
+            id=f"BOND_{current_tick}",
+            issuer="GOVERNMENT",
+            face_value=amount,
+            yield_rate=yield_rate,
+            maturity_date=current_tick + bond_maturity
+        )
+
+        qe_threshold = getattr(self.config_module, "QE_INTERVENTION_YIELD_THRESHOLD", 0.10)
+        if yield_rate > qe_threshold:
+            # Central Bank intervenes as buyer of last resort
+            self.central_bank.purchase_bonds(new_bond)
+            # Money is created here, which is the point of QE.
+        else:
+            # Sell to the market (simplified: the commercial bank buys it)
+            if self.bank.assets >= amount:
+                self.bank.assets -= amount
+            else:
+                # Bond issuance fails if no one can buy it
+                return []
+
+        self.outstanding_bonds.append(new_bond)
+        self.government.assets += amount
+
+        return [new_bond]
+
+    def grant_bailout_loan(self, firm: 'Firm', amount: float) -> BailoutLoanDTO:
+        """Converts a bailout from a grant to an interest-bearing senior loan."""
+        base_rate = self.central_bank.get_interest_rate()
+        penalty_premium = getattr(self.config_module, "BAILOUT_PENALTY_PREMIUM", 0.05)
+
+        loan = BailoutLoanDTO(
+            firm_id=firm.id,
+            amount=amount,
+            interest_rate=base_rate + penalty_premium,
+            covenants={
+                "dividends_allowed": False,
+                "executive_salary_freeze": True,
+                "mandatory_repayment": 0.5
+            }
+        )
+
+        # The government provides the funds, which become a liability for the firm
+        self.government.assets -= amount
+        firm.finance.add_liability(amount, loan.interest_rate)
+
+        return loan
+
+
+    def service_debt(self, current_tick: int) -> None:
+        """Manages the servicing of outstanding government debt."""
+        # This is a simplified version. A real implementation would handle interest payments
+        # and bond maturation.
+        matured_bonds = [b for b in self.outstanding_bonds if b.maturity_date <= current_tick]
+        for bond in matured_bonds:
+            self.government.assets -= bond.face_value
+            self.outstanding_bonds.remove(bond)
diff --git a/reports/temp/report_20260115_133455_Task__Identify_all_h.md b/reports/temp/report_20260115_133455_Task__Identify_all_h.md
deleted file mode 100644
index edd576b..0000000
--- a/reports/temp/report_20260115_133455_Task__Identify_all_h.md
+++ /dev/null
@@ -1,84 +0,0 @@
-# Report: Analysis of Hardcoded Heuristics and Technical Debt
-
-## Executive Summary
-The codebase contains a significant amount of technical debt in the form of hardcoded "magic numbers," fixed thresholds, and rule-based heuristics. This makes the simulation rigid and predictable. Migrating to a truly adaptive AI system will require refactoring these components into dynamic, learnable mechanisms.
-
-## Detailed Analysis
-
-### 1. Configuration File (`config.py`)
-The `config.py` file centralizes many constants, but many of these represent static rules rather than flexible parameters. An adaptive AI should be able to adjust these values based on the economic climate.
-
--   **TD-001: Fixed M&A Thresholds**
-    -   **Location**: `config.py`
-    -   **Snippet**: `HOSTILE_TAKEOVER_DISCOUNT_THRESHOLD = 0.7`
-    -   **Analysis**: This sets a fixed 70% discount threshold for identifying hostile takeover targets. In a real economy, this "discount" is variable, influenced by market sentiment, interest rates, and sector health. An adaptive AI should determine the takeover threshold dynamically.
-
--   **TD-002: Static Severance and Labor Rules**
-    -   **Location**: `config.py`
-    -   **Snippet**: `SEVERANCE_PAY_WEEKS = 4`, `WAGE_DECAY_RATE = 0.02`
-    -   **Analysis**: The number of severance weeks and the rate at which an unemployed agent's wage expectation decays are fixed. These should be influenced by labor laws (which could be a government AI policy), unemployment rates, and the agent's financial desperation.
-
--   **TD-003: Arbitrary Population and Startup Costs**
-    -   **Location**: `config.py`
-    -   **Snippet**: `POPULATION_IMMIGRATION_THRESHOLD = 80`, `STARTUP_COST = 30000.0`
-    -   **Analysis**: Immigration triggers and startup costs are static. These should be emergent properties of the economy, influenced by housing availability, cost of living, and access to capital.
-
--   **TD-004: Inflexible Tax Brackets**
-    -   **Location**: `config.py`
-    -   **Snippet**: `TAX_BRACKETS = [(0.5, 0.0), (1.0, 0.05), ...]`
-    -   **Analysis**: The income tax brackets are defined as static multiples of survival cost. A government AI should have the flexibility to adjust not only the rates but also the bracket thresholds themselves as part of its fiscal policy.
-
-### 2. Agent and Decision Logic (`simulation/`)
-Agents' decision-making processes are frequently constrained by simplistic, hardcoded `if/else` logic and fixed formulas, preventing nuanced or learned behaviors.
-
--   **TD-005: Rigid Housing Decision Trigger**
-    -   **Location**: `simulation/core_agents.py` (Household.decide_housing)
-    -   **Snippet**: `if not (self.is_homeless or current_time % 30 == 0): return`
-    -   **Analysis**: Housing decisions are only reviewed on a fixed 30-tick cycle or when homeless. This is an arbitrary schedule. An agent should be able to reconsider housing based on life events (new job, change in wealth) or market shocks, not just a timer.
-
--   **TD-006: Fixed Shadow Wage Formula**
-    -   **Location**: `simulation/core_agents.py` (Household._calculate_shadow_reservation_wage)
-    -   **Snippet**: `self.shadow_reservation_wage *= (1.0 - 0.02)`
-    -   **Analysis**: The reservation wage decays at a fixed rate of 2% per tick when unemployed. This rate should be adaptive, potentially decreasing faster if the agent's survival need is high or slower if the agent has a large financial buffer.
-
--   **TD-007: Simplistic Firm Valuation**
-    -   **Location**: `simulation/firms.py` (Firm.calculate_valuation)
-    -   **Snippet**: `profit_premium = max(0.0, avg_profit) * getattr(self.config_module, "VALUATION_PER_MULTIPLIER", 10.0)`
-    -   **Analysis**: The Price-to-Earnings (PER) multiplier for valuing a firm's profit potential is a hardcoded constant (10.0). In reality, the PER is highly dynamic and sector-dependent. This should be a market-derived value.
-
--   **TD-008: Hardcoded R&D Logic**
-    -   **Location**: `simulation/decisions/corporate_manager.py` (_manage_r_and_d)
-    -   **Snippet**: `denominator = max(firm.revenue_this_turn * 0.2, 100.0)`
-    -   **Analysis**: The formula to determine the base chance of R&D success contains magic numbers (`0.2`, `100.0`). The relationship between budget and success should be more complex, perhaps a learnable function or S-curve, rather than a simple linear ratio.
-
-### 3. System-Level Rules (`simulation/systems/`)
-The systems that govern the simulation's "physics" rely on rigid formulas and probabilities, limiting emergent behavior.
-
--   **TD-009: Fixed Mortality Formula**
-    -   **Location**: `simulation/systems/demographic_manager.py` (process_aging)
-    -   **Snippet**: `if agent.age > 80: death_prob = 0.05 + (agent.age - 80) * 0.01`
-    -   **Analysis**: The probability of natural death is a simple, hardcoded linear function of age past 80. This model does not account for wealth, access to services, or overall quality of life, which should influence lifespan.
-
--   **TD-010: Rigid Immigration Trigger**
-    -   **Location**: `simulation/systems/immigration_manager.py` (process_immigration)
-    -   **Snippet**: `condition_labor_shortage = unemployment_rate < 0.05`
-    -   **Analysis**: Immigration is triggered by a fixed unemployment rate threshold of 5%. This should be a policy lever for the government AI, allowing it to open or close borders based on a wider range of economic indicators (e.g., wage pressure, GDP growth, housing capacity).
-
--   **TD-011: Fixed Hostile Takeover Probability**
-    -   **Location**: `simulation/systems/ma_manager.py` (_attempt_hostile_takeover)
-    -   **Snippet**: `success_prob = 0.6`
-    -   **Analysis**: The success probability of a hostile takeover is a static 60%. This should be a dynamic calculation based on the predator's offer premium, the target's financial health, and potentially the loyalty of its existing shareholders (a currently unmodeled concept).
-
--   **TD-012: Static AI State Discretization**
-    -   **Location**: `simulation/ai/government_ai.py` (_get_state)
-    -   **Snippet**: `if inf_gap_val < -0.01: s_inf = 0`
-    -   **Analysis**: The AI's entire state representation is based on hardcoded thresholds (e.g., inflation gap < -1%). These boundaries are arbitrary. A more advanced AI could work with continuous data or learn the optimal thresholds itself.
-
-## Risk Assessment
-The pervasive use of hardcoded heuristics presents several risks:
--   **Brittleness**: The simulation is not resilient to edge cases or scenarios that fall outside the predefined rules.
--   **Unrealistic Behavior**: The fixed logic prevents agents from developing novel or nuanced strategies, leading to predictable and less realistic emergent outcomes.
--   **Difficult Evolution**: Migrating to an adaptive AI will require significant refactoring. Each hardcoded rule is a point of friction that must be individually replaced with a more flexible system.
-
-## Conclusion
-The current codebase serves as a solid foundation, but its reliance on static rules and magic numbers is a significant technical debt. A dedicated "Adaptive AI Migration" phase is required. The priority should be to replace fixed decision thresholds, static formulas, and arbitrary constants with systems that allow for dynamic, AI-driven parameterization and learned behavioral models.
diff --git a/scripts/gemini_worker.py b/scripts/gemini_worker.py
index 1a0e8a5..2454cc5 100644
--- a/scripts/gemini_worker.py
+++ b/scripts/gemini_worker.py
@@ -41,27 +41,17 @@ class BaseGeminiWorker(ABC):
         context_block = ""
         if context_files:
             context_block += "\n\n[Context Files]\n"
-            expanded_files = []
-            for item in context_files:
-                path = BASE_DIR / item
-                if path.is_dir():
-                    # If it's a directory, add all .py files within it
-                    for py_file in path.glob("**/*.py"):
-                        expanded_files.append(py_file.relative_to(BASE_DIR))
-                else:
-                    expanded_files.append(Path(item))
-
-            for rel_path in expanded_files:
-                abs_path = BASE_DIR / rel_path
-                if abs_path.exists() and abs_path.is_file():
+            for file_path in context_files:
+                path = BASE_DIR / file_path
+                if path.exists():
                     try:
-                        content = abs_path.read_text(encoding='utf-8')
-                        context_block += f"\nFile: {rel_path}\n```\n{content}\n```\n"
-                        print(f"üìñ Attached context: {rel_path}")
+                        content = path.read_text(encoding='utf-8')
+                        context_block += f"\nFile: {file_path}\n```\n{content}\n```\n"
+                        print(f"üìñ Attached context: {file_path}")
                     except Exception as e:
-                        print(f"‚ö†Ô∏è Failed to read context file {rel_path}: {e}")
+                        print(f"‚ö†Ô∏è Failed to read context file {file_path}: {e}")
                 else:
-                    print(f"‚ö†Ô∏è Context file not found or is not a file: {rel_path}")
+                    print(f"‚ö†Ô∏è Context file not found: {file_path}")
 
         full_input = f"{system_prompt}{context_block}\n\n---\n\n{instruction}"
 
@@ -281,11 +271,6 @@ def main():
     validator_parser.add_argument("instruction", help="Instruction for the validator")
     validator_parser.add_argument("--context", "-c", nargs="+", help="List of files to read as context")
 
-    # Auditor (Uses Reporter logic)
-    auditor_parser = subparsers.add_parser("audit", help="Identify technical debt and patterns")
-    auditor_parser.add_argument("instruction", help="Instruction for the auditor")
-    auditor_parser.add_argument("--context", "-c", nargs="+", help="List of files to read as context")
-
     args = parser.parse_args()
 
     try:
@@ -294,8 +279,7 @@ def main():
             "git": GitOperator,
             "reporter": Reporter,
             "context": ContextManager,
-            "verify": Validator,
-            "audit": Reporter
+            "verify": Validator
         }
         
         if args.worker_type in worker_map:
diff --git a/scripts/jules_bridge.py b/scripts/jules_bridge.py
index bde3551..36c4819 100644
--- a/scripts/jules_bridge.py
+++ b/scripts/jules_bridge.py
@@ -14,14 +14,11 @@ from enum import Enum
 import logging
 from pathlib import Path
 
-# Configuration
-BASE_DIR = Path(__file__).parent.parent
-
 # Load .env file
 try:
     from dotenv import load_dotenv
     # Find .env in project root
-    env_path = BASE_DIR / ".env"
+    env_path = Path(__file__).parent.parent / ".env"
     load_dotenv(env_path)
 except ImportError:
     pass  # dotenv not installed, rely on system env vars
@@ -29,6 +26,7 @@ except ImportError:
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger("JulesBridge")
 
+# Configuration
 JULES_API_BASE = "https://jules.googleapis.com/v1alpha"
 JULES_API_KEY = os.getenv("JULES_API_KEY")
 
@@ -232,54 +230,12 @@ class JulesBridge:
         logger.warning("Timed out waiting for agent response.")
         return None
 
-    def sync_git(self, title: str) -> bool:
-        """
-        Auto-push latest changes to ensure Jules gets fresh code.
-        Returns True if successful.
-        """
-        import subprocess
-        print(f"üì¶ Syncing Git changes for task: {title}...")
-        try:
-            # Check if there are changes to commit
-            status_result = subprocess.run(
-                ["git", "status", "--porcelain"],
-                capture_output=True, text=True, cwd=BASE_DIR
-            )
-            if status_result.stdout.strip():
-                # There are uncommitted changes
-                subprocess.run(["git", "add", "."], cwd=BASE_DIR, check=True)
-                subprocess.run(
-                    ["git", "commit", "-m", f"chore: Pre-Jules dispatch for {title}"],
-                    cwd=BASE_DIR, check=True
-                )
-                print("   ‚úÖ Changes committed")
-            else:
-                print("   ‚ÑπÔ∏è No uncommitted changes")
-            
-            # Always push to ensure remote is up-to-date
-            push_result = subprocess.run(
-                ["git", "push"],
-                capture_output=True, text=True, cwd=BASE_DIR
-            )
-            if push_result.returncode == 0:
-                print("   ‚úÖ Pushed to remote")
-                return True
-            else:
-                print(f"   ‚ö†Ô∏è Push warning: {push_result.stderr.strip()}")
-                return False
-        except subprocess.CalledProcessError as e:
-            print(f"   ‚ö†Ô∏è Git operation failed: {e}")
-            return False
-        except FileNotFoundError:
-            print("   ‚ö†Ô∏è Git not found")
-            return False
-
 
 # =============================================================================
 # Session Registry (team_assignments.json ÏûêÎèô Í¥ÄÎ¶¨)
 # =============================================================================
 
-REGISTRY_PATH = BASE_DIR / "communications" / "team_assignments.json"
+REGISTRY_PATH = Path(__file__).parent.parent / "communications" / "team_assignments.json"
 
 def _load_registry() -> Dict:
     if REGISTRY_PATH.exists():
@@ -397,7 +353,6 @@ if __name__ == "__main__":
         print("  python jules_bridge.py list-sources")
         print("  python jules_bridge.py list-sessions")
         print("  python jules_bridge.py create <title> <prompt>")
-        print("  python jules_bridge.py sync-git <title>")
         print("  python jules_bridge.py status <session_id>")
         sys.exit(1)
     
@@ -421,18 +376,48 @@ if __name__ == "__main__":
         title = sys.argv[2]
         prompt = sys.argv[3]
         
-        # Auto-sync Git
-        bridge.sync_git(title)
+        # Auto-push before creating session (ensures Jules gets latest code)
+        import subprocess
+        print("üì¶ Auto-pushing latest changes to ensure Jules gets fresh code...")
+        try:
+            # Check if there are changes to commit
+            status_result = subprocess.run(
+                ["git", "status", "--porcelain"],
+                capture_output=True, text=True, cwd=Path(__file__).parent.parent
+            )
+            if status_result.stdout.strip():
+                # There are uncommitted changes
+                subprocess.run(
+                    ["git", "add", "."],
+                    cwd=Path(__file__).parent.parent, check=True
+                )
+                subprocess.run(
+                    ["git", "commit", "-m", f"chore: Pre-Jules dispatch for {title}"],
+                    cwd=Path(__file__).parent.parent, check=True
+                )
+                print("   ‚úÖ Changes committed")
+            else:
+                print("   ‚ÑπÔ∏è No uncommitted changes")
+            
+            # Always push to ensure remote is up-to-date
+            push_result = subprocess.run(
+                ["git", "push"],
+                capture_output=True, text=True, cwd=Path(__file__).parent.parent
+            )
+            if push_result.returncode == 0:
+                print("   ‚úÖ Pushed to remote")
+            else:
+                print(f"   ‚ö†Ô∏è Push warning: {push_result.stderr.strip()}")
+        except subprocess.CalledProcessError as e:
+            print(f"   ‚ö†Ô∏è Git operation failed: {e} (continuing anyway)")
+        except FileNotFoundError:
+            print("   ‚ö†Ô∏è Git not found (continuing anyway)")
         
         session = bridge.create_session(prompt=prompt, title=title)
         register_session(session.id, title)  # ÏûêÎèô Îì±Î°ù
-        print(f"‚úÖ Session created: {session.id}")
-        print(f"‚úÖ Name: {session.name}")
-        print(f"‚úÖ Registered to team_assignments.json")
-
-    elif command == "sync-git" and len(sys.argv) >= 3:
-        title = sys.argv[2]
-        bridge.sync_git(title)
+        print(f"Session created: {session.id}")
+        print(f"Name: {session.name}")
+        print(f"Registered to team_assignments.json")
     
     elif command == "status" and len(sys.argv) >= 3:
         session_id = sys.argv[2]
diff --git a/simulation/agents/central_bank.py b/simulation/agents/central_bank.py
index a35ed64..c94968a 100644
--- a/simulation/agents/central_bank.py
+++ b/simulation/agents/central_bank.py
@@ -32,6 +32,12 @@ class CentralBank:
             extra={"tick": 0, "tags": ["central_bank", "init"]}
         )
 
+    def purchase_bonds(self, bond: Any) -> None:
+        """Purchases government bonds, effectively performing QE."""
+        # In a real model, this would add to the CB's balance sheet.
+        # For now, this is a placeholder to complete the transaction loop.
+        logger.info(f"CENTRAL_BANK_QE | Purchased bond {bond.id} for {bond.face_value:.2f}")
+
     def get_base_rate(self) -> float:
         return self.base_rate
 
diff --git a/simulation/agents/government.py b/simulation/agents/government.py
index 1d53d8c..684a1cd 100644
--- a/simulation/agents/government.py
+++ b/simulation/agents/government.py
@@ -102,6 +102,7 @@ class Government:
 
         # WO-057-B: Sensory Data Container
         self.sensory_data: Optional[GovernmentStateDTO] = None
+        self.finance_system = None
 
         logger.info(
             f"Government {self.id} initialized with assets: {self.assets}",
@@ -264,62 +265,40 @@ class Government:
             details=f"Inf={inflation:.2%}, Growth={real_gdp_growth:.2%}, Gap={gdp_gap:.2%}, RateGap={gap:.4f}"
         )
 
-    def provide_subsidy(self, target_agent: Any, amount: float, current_tick: int):
-        """
-        Î≥¥Ï°∞Í∏àÏùÑ ÏßÄÍ∏âÌï©ÎãàÎã§.
-        AI Spending Multiplier Ï†ÅÏö©.
-        """
-        # Apply Multiplier based on Target
-        effective_amount = amount
-        agent_type = "household"
-        if hasattr(target_agent, "employees"): # Duck typing Firm
-            effective_amount *= self.firm_subsidy_budget_multiplier
-            agent_type = "firm"
-        else:
-            effective_amount *= self.welfare_budget_multiplier
+    def provide_household_support(self, household: Any, amount: float, current_tick: int):
+        """Provides subsidies to households (e.g., unemployment, stimulus)."""
+        effective_amount = amount * self.welfare_budget_multiplier
 
         if effective_amount <= 0:
             return 0.0
 
-        if not getattr(self.config_module, "DEFICIT_SPENDING_ENABLED", False):
-            if self.assets < effective_amount:
-                return 0.0
-        else:
-            # WO-057-Active: Debt Ceiling Logic
-            if self.sensory_data and self.sensory_data.current_gdp > 0:
-                limit_ratio = getattr(self.config_module, "DEFICIT_SPENDING_LIMIT_RATIO", 0.3)
-                debt_limit = self.sensory_data.current_gdp * limit_ratio
-
-                projected_assets = self.assets - effective_amount
-
-                if abs(projected_assets) > debt_limit and projected_assets < 0:
-                    logger.warning(
-                        f"FISCAL_CLIFF_REACHED | Spending blocked. Debt {abs(self.assets):.2f} vs Limit {debt_limit:.2f}",
-                        extra={"tick": current_tick, "agent_id": self.id, "tags": ["fiscal_cliff", "deficit"]}
-                    )
-                    return 0.0
+        if self.assets < effective_amount:
+            needed = effective_amount - self.assets
+            self.finance_system.issue_treasury_bonds(needed, current_tick)
 
         self.assets -= effective_amount
         self.total_spent_subsidies += effective_amount
         self.expenditure_this_tick += effective_amount
-
-        self.total_money_issued += effective_amount
-
-        target_agent.assets += effective_amount
+        household.assets += effective_amount
         self.current_tick_stats["welfare_spending"] += effective_amount
 
         logger.info(
-            f"SUBSIDY_PAID | Paid {effective_amount:.2f} subsidy to {target_agent.id} ({agent_type})",
-            extra={
-                "tick": current_tick,
-                "agent_id": self.id,
-                "amount": effective_amount,
-                "target_id": target_agent.id,
-                "tags": ["subsidy", "expenditure"]
-            }
+            f"HOUSEHOLD_SUPPORT | Paid {effective_amount:.2f} to {household.id}",
+            extra={"tick": current_tick, "agent_id": self.id, "amount": effective_amount, "target_id": household.id}
         )
         return effective_amount
 
+    def provide_firm_bailout(self, firm: Any, amount: float, current_tick: int):
+        """Provides a bailout loan to a firm if it's eligible."""
+        if self.finance_system.evaluate_solvency(firm, current_tick):
+            logger.info(f"BAILOUT_APPROVED | Firm {firm.id} is eligible for a bailout.")
+            loan = self.finance_system.grant_bailout_loan(firm, amount)
+            self.expenditure_this_tick += amount
+            return loan
+        else:
+            logger.warning(f"BAILOUT_DENIED | Firm {firm.id} is insolvent and not eligible for a bailout.")
+            return None
+
     def get_survival_cost(self, market_data: Dict[str, Any]) -> float:
         """ Calculates current survival cost based on food prices. """
         avg_food_price = 0.0
@@ -398,8 +377,7 @@ class Government:
 
                 # B. Unemployment Benefit
                 if not agent.is_employed:
-                    # provide_subsidy now applies welfare_budget_multiplier
-                    self.provide_subsidy(agent, benefit_amount, current_tick)
+                    self.provide_household_support(agent, benefit_amount, current_tick)
                     total_welfare_paid += benefit_amount
 
         # 3. Stimulus Check (Legacy Logic, now influenced by AI multiplier)
@@ -445,23 +423,11 @@ class Government:
         if self.firm_subsidy_budget_multiplier < 0.8:
             return False
 
-        # WO-057-Active CRITICAL FIX: Apply Debt Ceiling to Infrastructure
-        if getattr(self.config_module, "DEFICIT_SPENDING_ENABLED", False):
-            if self.sensory_data and self.sensory_data.current_gdp > 0:
-                limit_ratio = getattr(self.config_module, "DEFICIT_SPENDING_LIMIT_RATIO", 0.3)
-                debt_limit = self.sensory_data.current_gdp * limit_ratio
-                projected_assets = self.assets - effective_cost
-                if abs(projected_assets) > debt_limit and projected_assets < 0:
-                    logger.warning(
-                        f"FISCAL_CLIFF_REACHED | Infrastructure investment blocked. Debt {abs(self.assets):.2f} vs Limit {debt_limit:.2f}",
-                        extra={"tick": current_tick, "agent_id": self.id, "tags": ["fiscal_cliff", "deficit"]}
-                    )
-                    return False
-        elif self.assets < effective_cost:
-            return False # Fallback to old behavior if deficit spending is off
+        if self.assets < effective_cost:
+            needed = effective_cost - self.assets
+            self.finance_system.issue_treasury_bonds(needed, current_tick)
 
         self.assets -= effective_cost
-        self.total_money_issued += effective_cost
         self.expenditure_this_tick += effective_cost
         if reflux_system:
             reflux_system.capture(effective_cost, str(self.id), "infrastructure")
@@ -532,6 +498,14 @@ class Government:
             "perceived_public_opinion": self.perceived_public_opinion
         }
 
+    def get_debt_to_gdp_ratio(self) -> float:
+        """Calculates the debt-to-GDP ratio."""
+        if not self.sensory_data or self.sensory_data.current_gdp == 0:
+            return 0.0
+
+        debt = max(0.0, -self.assets)
+        return debt / self.sensory_data.current_gdp
+
     # WO-054: Public Education System
     def run_public_education(self, agents: List[Any], config_module: Any, current_tick: int, reflux_system: Any = None) -> None:
         """
diff --git a/simulation/bank.py b/simulation/bank.py
index 57d02a0..10bb398 100644
--- a/simulation/bank.py
+++ b/simulation/bank.py
@@ -71,6 +71,10 @@ class Bank:
             extra={"tick": 0, "agent_id": self.id, "tags": ["init", "bank"]},
         )
 
+    def get_interest_rate(self) -> float:
+        """Returns the current base interest rate."""
+        return self.base_rate
+
     def _get_config(self, key: str, default: Any) -> Any:
         return getattr(self.config_module, key, default)
 
diff --git a/simulation/components/finance_department.py b/simulation/components/finance_department.py
index 3320bfd..a747a4a 100644
--- a/simulation/components/finance_department.py
+++ b/simulation/components/finance_department.py
@@ -91,6 +91,12 @@ class FinanceDepartment:
 
     def distribute_dividends(self, households: List[Household], current_time: int) -> List[Transaction]:
         """Public Shareholders Dividend"""
+        if getattr(self.firm, 'has_bailout_loan', False) and self.current_profit > 0:
+            repayment = self.current_profit * 0.5
+            self.firm.total_debt -= repayment
+            self.current_profit -= repayment
+            self.firm.logger.info(f"BAILOUT_REPAYMENT | Firm {self.firm.id} repaid {repayment:.2f} of its bailout loan.")
+
         transactions = []
         distributable_profit = max(0, self.current_profit * self.firm.dividend_rate)
 
@@ -175,6 +181,43 @@ class FinanceDepartment:
 
         return 0.0
 
+    def add_liability(self, amount: float, interest_rate: float):
+        """Adds a liability (like a loan) to the firm's balance sheet."""
+        # This is a simplified implementation. A real one would track multiple loans.
+        self.firm.assets += amount  # The loan increases cash assets
+        # In a more complex model, this would be a separate liability account
+        # For now, we'll just track the total debt.
+        if not hasattr(self.firm, 'total_debt'):
+            self.firm.total_debt = 0.0
+        self.firm.total_debt += amount
+
+    def calculate_altman_z_score(self) -> float:
+        """
+        Calculates the Altman Z-Score for solvency, simplified for this model.
+        Z = 1.2*X1 + 1.4*X2 + 3.3*X3
+        X1: Working Capital / Total Assets
+        X2: Retained Earnings / Total Assets
+        X3: Average Profit / Total Assets
+        """
+        total_assets = self.firm.assets + self.firm.capital_stock + self.firm.get_inventory_value()
+        if total_assets == 0:
+            return 0.0
+
+        # X1: Working Capital / Total Assets
+        # Working Capital = Current Assets - Current Liabilities. Assume liabilities are total_debt for now.
+        working_capital = self.firm.assets - getattr(self.firm, 'total_debt', 0.0)
+        x1 = working_capital / total_assets
+
+        # X2: Retained Earnings / Total Assets
+        x2 = self.retained_earnings / total_assets
+
+        # X3: Average Profit / Total Assets
+        avg_profit = sum(self.profit_history) / len(self.profit_history) if self.profit_history else 0.0
+        x3 = avg_profit / total_assets
+
+        z_score = 1.2 * x1 + 1.4 * x2 + 3.3 * x3
+        return z_score
+
     def check_bankruptcy(self):
         if self.current_profit < 0:
             self.consecutive_loss_turns += 1
diff --git a/simulation/engine.py b/simulation/engine.py
index 8906d0d..138163a 100644
--- a/simulation/engine.py
+++ b/simulation/engine.py
@@ -35,6 +35,7 @@ from simulation.systems.generational_wealth_audit import GenerationalWealthAudit
 from simulation.decisions.housing_manager import HousingManager # For rank/tier helper
 from simulation.ai.vectorized_planner import VectorizedHouseholdPlanner
 from simulation.systems.transaction_processor import TransactionProcessor # SoC Refactor
+from modules.finance.system import FinanceSystem
 
 # Use the repository pattern for data access
 from simulation.db.repository import SimulationRepository
@@ -114,6 +115,15 @@ class Simulation:
         # similar to how markets are handled, or we can add it if needed.
         # But it doesn't participate in normal transactions.
 
+        # Finance System (Sovereign Debt)
+        self.finance_system = FinanceSystem(
+            government=self.government,
+            central_bank=self.central_bank,
+            bank=self.bank,
+            config_module=self.config_module
+        )
+        self.government.finance_system = self.finance_system # Inject into government
+
         # Phase 17-3A: Initialize Real Estate Units
         self.real_estate_units: List[RealEstateUnit] = [
             RealEstateUnit(id=i, estimated_value=self.config_module.INITIAL_PROPERTY_VALUE,
@@ -518,6 +528,13 @@ class Simulation:
         # 4. Election Check
         self.government.check_election(self.time)
 
+        # Age firms
+        for firm in self.firms:
+            firm.age += 1
+
+        # Service national debt
+        self.finance_system.service_debt(self.time)
+
         # Phase 4: Welfare Check (Executes Subsidies based on Policy)
         self.government.run_welfare_check(list(self.agents.values()), market_data, self.time)
 
diff --git a/simulation/firms.py b/simulation/firms.py
index 204b7d4..14b6700 100644
--- a/simulation/firms.py
+++ b/simulation/firms.py
@@ -133,6 +133,9 @@ class Firm(BaseAgent):
         self.automation_level: float = 0.0 # 0.0 to 1.0
         self.system2_planner: Optional[FirmSystem2Planner] = None # Initialized later
 
+        self.age = 0
+        self.cash_reserve = initial_capital
+        self.has_bailout_loan = False
         self.decision_engine.loan_market = loan_market
 
     def init_ipo(self, stock_market: StockMarket):
diff --git a/tests/test_ai_driven_firm_engine.py b/tests/test_ai_driven_firm_engine.py
index c1cc839..b837a96 100644
--- a/tests/test_ai_driven_firm_engine.py
+++ b/tests/test_ai_driven_firm_engine.py
@@ -48,18 +48,30 @@ def mock_firm(mock_config):
     firm.employees = []
     firm.profit_history = []
     firm.productivity_factor = 1.0
+    firm.age = 25 # Add age for solvency checks
+    firm.finance = Mock() # Mock the finance department
     return firm
 
 
 def test_adjust_price_tactic(firm_decision_engine_instance, mock_firm):
     """Test that the ADJUST_PRICE tactic correctly adjusts the price."""
+    from simulation.dtos import DecisionContext
+
     mock_firm.inventory["food"] = 200
     mock_firm.production_target = 100
-    firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
-        Tactic.ADJUST_PRICE
+    firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
+        (Tactic.ADJUST_PRICE, 1.0)
     )
 
-    orders, _ = firm_decision_engine_instance.make_decisions(mock_firm, {}, [], {}, 1)
+    context = DecisionContext(
+        firm=mock_firm,
+        markets={},
+        goods_data=[],
+        market_data={},
+        current_time=1,
+        government=None,
+    )
+    orders, _ = firm_decision_engine_instance.make_decisions(context)
 
     assert len(orders) == 1
     order = orders[0]
diff --git a/tests/test_engine.py b/tests/test_engine.py
index c1d15e5..1276bf0 100644
--- a/tests/test_engine.py
+++ b/tests/test_engine.py
@@ -180,6 +180,7 @@ def mock_firms(mock_config_module):
     f1.is_active = True
     f1.total_shares = 1000.0
     f1.treasury_shares = 0.0
+    f1.age = 25 # Set age for testing
 
     f2 = Firm(
         id=102,
@@ -195,6 +196,7 @@ def mock_firms(mock_config_module):
     f2.is_active = False  # Inactive firm
     f2.total_shares = 1000.0
     f2.treasury_shares = 0.0
+    f2.age = 25 # Set age for testing
     return [f1, f2]
 
 
@@ -256,6 +258,8 @@ def simulation_instance(
         mock_config_module,
         mock_goods_data,
     )
+    sim.government.finance_system = Mock()
+    sim.government.get_debt_to_gdp_ratio = Mock(return_value=0.5)
     return sim
 
 
diff --git a/tests/test_firm_decision_engine_new.py b/tests/test_firm_decision_engine_new.py
index 57f1492..826fe96 100644
--- a/tests/test_firm_decision_engine_new.py
+++ b/tests/test_firm_decision_engine_new.py
@@ -62,8 +62,10 @@ def mock_firm(mock_config):
     firm.cost_this_turn = 0.0
     firm.profit_history = deque(maxlen=mock_config.PROFIT_HISTORY_TICKS)
     firm.specialization = "food"
-    # Add a mock for the logger attribute
     firm.logger = MagicMock()
+    firm.age = 25 # Add age for solvency checks
+    firm.finance = Mock() # Mock the finance department
+    firm.hr = Mock() # Mock the HR department
     return firm
 
 
@@ -93,7 +95,7 @@ class TestFirmDecisionEngine:
     def test_make_decisions_overstock_reduces_target(
         self, firm_decision_engine_instance, mock_firm, mock_config
     ):
-        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
             Tactic.ADJUST_PRODUCTION, Aggressiveness.NORMAL
         )
         mock_firm.inventory["food"] = 150.0 # Force overstock (150 > 100 * 1.2)
@@ -106,6 +108,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
 
@@ -120,7 +123,7 @@ class TestFirmDecisionEngine:
     ):
         mock_firm.inventory["food"] = 50.0
         initial_target = mock_firm.production_target
-        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
             Tactic.ADJUST_PRODUCTION, Aggressiveness.NORMAL
         )
 
@@ -130,6 +133,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
 
@@ -144,7 +148,7 @@ class TestFirmDecisionEngine:
     ):
         mock_firm.inventory["food"] = 100.0
         initial_target = mock_firm.production_target
-        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
             Tactic.ADJUST_PRODUCTION, Aggressiveness.NORMAL
         )
 
@@ -154,6 +158,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
 
@@ -162,7 +167,7 @@ class TestFirmDecisionEngine:
     def test_make_decisions_target_min_max_bounds(
         self, firm_decision_engine_instance, mock_firm, mock_config
     ):
-        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
             Tactic.ADJUST_PRODUCTION, Aggressiveness.NORMAL
         )
         # Test min bound
@@ -174,6 +179,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
         assert mock_firm.production_target == mock_config.FIRM_MIN_PRODUCTION_TARGET
@@ -187,6 +193,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
         assert mock_firm.production_target == mock_config.FIRM_MAX_PRODUCTION_TARGET
@@ -196,7 +203,7 @@ class TestFirmDecisionEngine:
     ):
         mock_firm.employees = []
         mock_firm.inventory["food"] = 0  # Ensure production is needed
-        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
             Tactic.ADJUST_WAGES, Aggressiveness.NORMAL
         )
 
@@ -206,6 +213,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={"avg_wage": 10.0},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
 
@@ -214,7 +222,7 @@ class TestFirmDecisionEngine:
         ]
         assert len(buy_labor_orders) > 0
         assert buy_labor_orders[0].quantity == 1.0
-        assert buy_labor_orders[0].market_id == "labor_market"
+        assert buy_labor_orders[0].market_id == "labor"
 
     def test_make_decisions_hires_for_needed_labor(
         self, firm_decision_engine_instance, mock_firm, mock_config
@@ -222,7 +230,7 @@ class TestFirmDecisionEngine:
         mock_firm.employees = [Mock()]
         mock_firm.production_target = 500
         mock_firm.inventory["food"] = 0  # Ensure production is needed
-        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
             Tactic.ADJUST_WAGES, Aggressiveness.NORMAL
         )
 
@@ -232,6 +240,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={"avg_wage": 10.0},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
 
@@ -246,7 +255,7 @@ class TestFirmDecisionEngine:
     ):
         mock_firm.employees = [Mock() for _ in range(mock_config.FIRM_MAX_EMPLOYEES)]
         mock_firm.production_target = 500
-        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
             Tactic.ADJUST_WAGES, Aggressiveness.NORMAL
         )
 
@@ -256,6 +265,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
 
@@ -270,7 +280,7 @@ class TestFirmDecisionEngine:
         mock_firm.employees = [Mock() for _ in range(10)]
         mock_firm.production_target = 0
         mock_firm.inventory = {"food": 1000}
-        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
             Tactic.ADJUST_WAGES, Aggressiveness.NORMAL
         )
 
@@ -280,6 +290,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
 
@@ -312,7 +323,7 @@ class TestFirmDecisionEngine:
         assert labor_order is not None
         assert labor_order.agent_id == mock_firm.id
         assert labor_order.quantity == 1.0
-        assert labor_order.market_id == "labor_market"
+        assert labor_order.market_id == "labor"
 
     def test_make_decisions_does_not_sell_if_understocked(
         self, firm_decision_engine_instance, mock_firm
@@ -327,6 +338,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
         sell_orders = [
@@ -347,6 +359,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
         sell_orders = [
@@ -368,6 +381,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
         sell_order = next(
@@ -389,6 +403,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
         sell_order = next(
@@ -412,6 +427,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
         sell_order = next(
@@ -429,6 +445,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
         sell_order = next(
@@ -450,6 +467,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
         sell_order = next(
@@ -473,6 +491,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
         sell_order = next(
@@ -498,6 +517,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
 
@@ -523,6 +543,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
 
@@ -548,6 +569,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
 
@@ -576,6 +598,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
         sell_order = next(
@@ -594,6 +617,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
         sell_order = next(
