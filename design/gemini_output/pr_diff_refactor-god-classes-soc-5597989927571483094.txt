diff --git a/simulation/components/agent_lifecycle.py b/simulation/components/agent_lifecycle.py
new file mode 100644
index 0000000..aca97c3
--- /dev/null
+++ b/simulation/components/agent_lifecycle.py
@@ -0,0 +1,39 @@
+"""
+Implements the AgentLifecycleComponent which manages the daily routine of a Household agent.
+"""
+from typing import Any, Dict, Protocol
+from simulation.systems.api import IAgentLifecycleComponent, LifecycleContext
+
+class AgentLifecycleComponent(IAgentLifecycleComponent):
+    """
+    Manages the 'run_tick' logic for a Household: Work -> Consume -> Tax -> Psychology.
+    """
+
+    def __init__(self, owner: Any, config: Any):
+        self.owner = owner # Household
+        self.config = config
+
+    def run_tick(self, context: LifecycleContext) -> None:
+        """
+        Orchestrates the household's tick-level updates.
+        """
+        household = context["household"]
+        market_data = context["market_data"]
+        time = context["time"]
+
+        # 1. Work (via LaborManager)
+        # Assuming a fixed 8 hours of work per tick if employed
+        work_hours = 8.0 if household.is_employed else 0.0
+        household.labor_manager.work(work_hours)
+
+        # 2. Consume (via EconomyManager/CommerceSystem)
+        # Consumption is now handled by CommerceSystem before calling update_needs.
+        # We deliberately skip calling household.decide_and_consume here to avoid
+        # double consumption (Architecture Ambiguity Fix).
+        # The logic flow is: CommerceSystem -> execute consumption -> household.update_needs -> Lifecycle.run_tick
+
+        # 3. Pay Taxes (via EconomyManager)
+        household.economy_manager.pay_taxes()
+
+        # 4. Update Psychological Needs (via PsychologyComponent)
+        household.psychology.update_needs(time, market_data)
diff --git a/simulation/components/market_component.py b/simulation/components/market_component.py
new file mode 100644
index 0000000..bc3de41
--- /dev/null
+++ b/simulation/components/market_component.py
@@ -0,0 +1,60 @@
+"""
+Implements the MarketComponent which handles utility-based seller selection.
+"""
+from typing import Any, Dict, Optional, Tuple
+from simulation.systems.api import IMarketComponent, MarketInteractionContext
+
+class MarketComponent(IMarketComponent):
+    """
+    Handles market interactions for the Household, specifically choosing the best seller.
+    """
+
+    def __init__(self, owner: Any, config: Any):
+        self.owner = owner # Household
+        self.config = config
+
+    def choose_best_seller(self, item_id: str, context: MarketInteractionContext) -> Tuple[Optional[int], float]:
+        """
+        Selects the best seller based on Utility = (Quality^alpha * (1+Awareness)^beta * Loyalty) / Price.
+        """
+        markets = context["markets"]
+        market = markets.get(item_id)
+        if not market:
+            return None, 0.0
+
+        # Assumes market has get_all_asks method returning list of orders
+        if not hasattr(market, 'get_all_asks'):
+            return None, 0.0
+
+        asks = market.get_all_asks(item_id)
+        if not asks:
+            return None, 0.0
+
+        best_u = -float('inf')
+        best_seller = None
+        best_price = 0.0
+
+        beta = getattr(self.config, "BRAND_SENSITIVITY_BETA", 0.5)
+
+        for ask in asks:
+            price = ask.price
+            seller_id = ask.agent_id
+
+            # Metadata
+            brand_data = getattr(ask, 'brand_info', {}) or {}
+            quality = brand_data.get("perceived_quality", 1.0)
+            awareness = brand_data.get("brand_awareness", 0.0)
+
+            loyalty = self.owner.brand_loyalty.get(seller_id, 1.0)
+            quality_pref = getattr(self.owner, 'quality_preference', 0.5)
+
+            # Utility Calculation
+            numerator = (quality ** quality_pref) * ((1.0 + awareness) ** beta)
+            utility = (numerator * loyalty) / max(0.01, price)
+
+            if utility > best_u:
+                best_u = utility
+                best_seller = seller_id
+                best_price = price
+
+        return best_seller, best_price
diff --git a/simulation/core_agents.py b/simulation/core_agents.py
index c1c0a01..016718b 100644
--- a/simulation/core_agents.py
+++ b/simulation/core_agents.py
@@ -31,6 +31,9 @@ from simulation.utils.shadow_logger import log_shadow
 from simulation.components.demographics_component import DemographicsComponent
 from simulation.components.economy_manager import EconomyManager
 from simulation.components.labor_manager import LaborManager
+from simulation.components.agent_lifecycle import AgentLifecycleComponent
+from simulation.components.market_component import MarketComponent
+from simulation.systems.api import LifecycleContext, MarketInteractionContext, LearningUpdateContext, ILearningAgent
 
 if TYPE_CHECKING:
     from simulation.loan_market import LoanMarket
@@ -91,7 +94,7 @@ class Skill:
         self.observability = observability
 
 
-class Household(BaseAgent):
+class Household(BaseAgent, ILearningAgent):
     """
     Í∞ÄÍ≥Ñ Ï£ºÏ≤¥. ÏÜåÎπÑÏôÄ ÎÖ∏Îèô Í≥µÍ∏âÏùò Ï£ºÏ≤¥Ïù¥Î©∞, Îã§ÏñëÌïú ÏöïÍµ¨Î•º Í∞ÄÏßÄÍ≥† ÏùòÏÇ¨Í≤∞Ï†ïÏùÑ ÏàòÌñâÌï©ÎãàÎã§.
     Í≤ΩÏ†ú ÏãúÎÆ¨Î†àÏù¥ÏÖò ÎÇ¥ÏóêÏÑú Ïû¨Ìôî ÏÜåÎπÑ, ÎÖ∏Îèô ÏãúÏû• Ï∞∏Ïó¨, ÏûêÏÇ∞ Í¥ÄÎ¶¨ Îì±Ïùò ÌôúÎèôÏùÑ Ìï©ÎãàÎã§.
@@ -206,6 +209,8 @@ class Household(BaseAgent):
         self.leisure = LeisureManager(self, config_module)
         self.economy_manager = EconomyManager(self, config_module)
         self.labor_manager = LaborManager(self, config_module)
+        self.lifecycle_component = AgentLifecycleComponent(self, config_module)
+        self.market_component = MarketComponent(self, config_module)
         self.shares_owned: Dict[int, float] = {}
         self.is_employed: bool = False
         self.labor_skill: float = 1.0
@@ -865,57 +870,10 @@ class Household(BaseAgent):
     def choose_best_seller(self, markets: Dict[str, "Market"], item_id: str) -> Tuple[Optional[int], float]:
         """
         Phase 6: Utility-based Seller Selection.
-        Returns (BestSellerID, BestAskPrice)
+        Delegates to MarketComponent.
         """
-        market = markets.get(item_id)
-        if not market:
-            return None, 0.0
-        
-        # This requires Market to expose 'get_all_asks' with Seller Info
-        # We assume order_book_market has get_all_asks(item_id) returning list of SellOrders
-        # And SellOrder has agent_id.
-        # But we need metadata (Quality, Awareness) which isn't in Order DTO yet?
-        # WAIT. The Spec said "Firm places order, it stamps current Brand/Quality on it".
-        # I didn't verify SellOrder metadata.
-        # IF metadata is missing, we default to 0.5.
-        
-        asks = market.get_all_asks(item_id) # Should return List[Order]
-        if not asks:
-            return None, 0.0
-            
-        best_u = -float('inf')
-        best_seller = None
-        best_price = 0.0
-        
-        avg_sales = 10.0 # Default network effect base if unknown
-        
-        for ask in asks:
-            price = ask.price
-            seller_id = ask.agent_id
-            
-            # Phase 6: Read brand metadata from Order (Firm stamps it on SellOrder)
-            brand_data = ask.brand_info or {}
-            quality = brand_data.get("perceived_quality", 1.0)
-            awareness = brand_data.get("brand_awareness", 0.0)
-            
-            loyalty = self.brand_loyalty.get(seller_id, 1.0)
-            
-            # Utility Function: U = (Quality * (1 + Awareness * Pref) * Loyalty) / Price
-            # Beta (Brand Sensitivity) from Config
-            beta = getattr(self.config_module, "BRAND_SENSITIVITY_BETA", 0.5)
-            
-            # Revised Formula: Q^alpha * (1+A)^beta / P
-            # Note: Previous code used (1 + A * Pref). Spec says (1+A)^beta or similar.
-            # Architect Prime Spec: U = (Q^alpha * (1+A)^beta) / P
-            numerator = (quality ** self.quality_preference) * ((1.0 + awareness) ** beta)
-            utility = (numerator * loyalty) / max(0.01, price)
-            
-            if utility > best_u:
-                best_u = utility
-                best_seller = seller_id
-                best_price = price
-        
-        return best_seller, best_price
+        context: MarketInteractionContext = {"markets": markets}
+        return self.market_component.choose_best_seller(item_id, context)
 
     def execute_tactic(
         self,
@@ -962,30 +920,14 @@ class Household(BaseAgent):
     @override
     def update_needs(self, current_tick: int, market_data: Optional[Dict[str, Any]] = None):
         """
-        Orchestrates the household's tick-level updates in a specific order:
-        1. Work to earn income.
-        2. Consume goods to satisfy needs.
-        3. Pay taxes.
-        4. Update psychological needs.
+        Delegates the household's tick-level updates to AgentLifecycleComponent.
         """
-        # 1. Work (via LaborManager)
-        # Assuming a fixed 8 hours of work per tick if employed
-        work_hours = 8.0 if self.is_employed else 0.0
-        self.labor_manager.work(work_hours)
-
-        # 2. Consume (via ConsumptionBehavior, which should call EconomyManager)
-        # The existing decide_and_consume already handles this part.
-        # We just need to ensure the orchestration order.
-        # The actual consumption logic is now in EconomyManager,
-        # but the decision to consume is in ConsumptionBehavior.
-        # Let's assume decide_and_consume calls self.consume which is now delegated.
-        self.decide_and_consume(current_tick, market_data)
-
-        # 3. Pay Taxes (via EconomyManager)
-        self.economy_manager.pay_taxes()
-
-        # 4. Update Psychological Needs (existing PsychologyComponent)
-        self.psychology.update_needs(current_tick, market_data)
+        context: LifecycleContext = {
+            "household": self,
+            "market_data": market_data if market_data else {},
+            "time": current_tick
+        }
+        self.lifecycle_component.run_tick(context)
 
     def _update_skill(self):
         """Delegates skill updates to the LaborManager."""
@@ -1076,3 +1018,23 @@ class Household(BaseAgent):
         # 2. Update expected wage based on inherited education if applicable
         child.education_level = min(self.education_level, 1) # Reset but maybe give a head start
         child.expected_wage = self.expected_wage * 0.8 # Legacy expectations
+
+    def update_learning(self, context: LearningUpdateContext) -> None:
+        """
+        ILearningAgent implementation.
+        Updates the internal AI engine with the new state and reward.
+        """
+        # Inject Leisure Utility if present in context (it might be passed as part of next_agent_data by CommerceSystem? No, it's separate)
+        # Actually in Simulation.run_tick, we were injecting it into agent_data manually.
+        # Ideally, context should carry it or we put it in next_agent_data.
+        # The spec says: context has reward, next_agent_data, next_market_data.
+
+        reward = context["reward"]
+        next_agent_data = context["next_agent_data"]
+        next_market_data = context["next_market_data"]
+
+        self.decision_engine.ai_engine.update_learning_v2(
+            reward=reward,
+            next_agent_data=next_agent_data,
+            next_market_data=next_market_data,
+        )
diff --git a/simulation/engine.py b/simulation/engine.py
index 0acafeb..898a6d0 100644
--- a/simulation/engine.py
+++ b/simulation/engine.py
@@ -36,6 +36,16 @@ from simulation.decisions.housing_manager import HousingManager # For rank/tier
 from simulation.ai.vectorized_planner import VectorizedHouseholdPlanner
 from simulation.systems.transaction_processor import TransactionProcessor # SoC Refactor
 from modules.finance.system import FinanceSystem
+from simulation.systems.api import (
+    EventContext, SocialMobilityContext, SensoryContext, CommerceContext,
+    LearningUpdateContext
+)
+from simulation.systems.social_system import SocialSystem
+from simulation.systems.event_system import EventSystem
+from simulation.systems.sensory_system import SensorySystem
+from simulation.systems.commerce_system import CommerceSystem
+from simulation.systems.labor_market_analyzer import LaborMarketAnalyzer
+from simulation.components.agent_lifecycle import AgentLifecycleComponent
 
 # Use the repository pattern for data access
 from simulation.db.repository import SimulationRepository
@@ -113,16 +123,16 @@ class Simulation:
         self.finance_system: Optional[FinanceSystem] = None
         self.ai_trainer: Optional[AIEngineRegistry] = None
 
+        # New Systems
+        self.social_system: Optional[SocialSystem] = None
+        self.event_system: Optional[EventSystem] = None
+        self.sensory_system: Optional[SensorySystem] = None
+        self.commerce_system: Optional[CommerceSystem] = None
+        self.labor_market_analyzer: Optional[LaborMarketAnalyzer] = None
+
         # Attributes with default values
         self.batch_save_interval: int = 50
         self.household_time_allocation: Dict[int, float] = {}
-        self.inflation_buffer: deque = deque(maxlen=10)
-        self.unemployment_buffer: deque = deque(maxlen=10)
-        self.gdp_growth_buffer: deque = deque(maxlen=10)
-        self.wage_buffer: deque = deque(maxlen=10)
-        self.approval_buffer: deque = deque(maxlen=10)
-        self.last_avg_price_for_sma: float = 10.0
-        self.last_gdp_for_sma: float = 0.0
         self.last_interest_rate: float = 0.0 # Will be set from bank
 
     def finalize_simulation(self):
@@ -134,56 +144,7 @@ class Simulation:
 
 
 
-    def _update_social_ranks(self):
-        """Phase 17-4: Update Social Rank (Percentile)"""
-        # 1. Calculate Scores
-        scores = []
-        # Temporary instance for helper
-        hm = HousingManager(None, self.config_module)
-
-        for h in self.households:
-            if not h.is_active: continue
-
-            consumption_score = h.current_consumption * 10.0 # Weight consumption
-            housing_tier = hm.get_housing_tier(h)
-            housing_score = housing_tier * 1000.0 # Tier 1=1000, Tier 3=3000
-
-            total_score = consumption_score + housing_score
-            scores.append((h.id, total_score))
-
-        # 2. Sort and Assign Rank
-        sorted_scores = sorted(scores, key=lambda x: x[1], reverse=True)
-        n = len(sorted_scores)
-        if n == 0: return
-
-        for rank_idx, (hid, _) in enumerate(sorted_scores):
-            # Rank 0 (Top) -> Percentile 1.0
-            # Rank N-1 (Bottom) -> Percentile 0.0
-            percentile = 1.0 - (rank_idx / n)
-            agent = self.agents.get(hid)
-            if agent:
-                agent.social_rank = percentile
-
-    def _calculate_reference_standard(self) -> Dict[str, float]:
-        """Phase 17-4: Calculate Top 20% Average Standard"""
-        active_households = [h for h in self.households if h.is_active]
-        if not active_households:
-            return {"avg_consumption": 0.0, "avg_housing_tier": 0.0}
-
-        top_20_count = max(1, int(len(active_households) * 0.20))
-        sorted_hh = sorted(active_households, key=lambda h: getattr(h, "social_rank", 0.0), reverse=True)
-        top_20 = sorted_hh[:top_20_count]
-
-        # Temp helper
-        hm = HousingManager(None, self.config_module)
-
-        avg_cons = sum(h.current_consumption for h in top_20) / len(top_20)
-        avg_tier = sum(hm.get_housing_tier(h) for h in top_20) / len(top_20)
-
-        return {
-            "avg_consumption": avg_cons,
-            "avg_housing_tier": avg_tier
-        }
+    # _update_social_ranks and _calculate_reference_standard moved to SocialSystem
 
     def run_tick(self, injectable_sensory_dto: Optional[GovernmentStateDTO] = None) -> None:
         # --- Gold Standard / Money Supply Verification (WO-016) ---
@@ -200,21 +161,14 @@ class Simulation:
             extra={"tick": self.time, "tags": ["tick_start"]},
         )
 
-        # ===== Chaos Injection Events =====
-        if self.time == 200:
-            self.logger.warning("üî• CHAOS: Inflation Shock at Tick 200!")
-            for market_name, market in self.markets.items():
-                if hasattr(market, 'current_price'):
-                    market.current_price *= 1.5
-                if hasattr(market, 'avg_price'):
-                    market.avg_price *= 1.5
-
-        if self.time == 600:
-            self.logger.warning("üî• CHAOS: Recession Shock at Tick 600!")
-            for household in self.households:
-                household.assets *= 0.5
-                # Tech Note WO-057: Asset shock was deemed sufficient.
-                # If further impact is needed, household.monthly_income could also be reduced by 50%.
+        # ===== Chaos Injection Events (via EventSystem) =====
+        if self.event_system:
+             context: EventContext = {
+                 "households": self.households,
+                 "firms": self.firms,
+                 "markets": self.markets
+             }
+             self.event_system.execute_scheduled_events(self.time, context)
 
         # WO-054: Government Public Education Logic (START OF TICK)
         self.government.run_public_education(self.households, self.config_module, self.time, self.reflux_system)
@@ -258,15 +212,15 @@ class Simulation:
             active_firms = {f.id: f for f in self.firms if f.is_active}
             self.stock_market.update_reference_prices(active_firms)
 
-        # Phase 17-4: Update Social Ranks & Calculate Reference Standard
-        if getattr(self.config_module, "ENABLE_VANITY_SYSTEM", False):
-            self._update_social_ranks()
-
+        # Phase 17-4: Update Social Ranks & Calculate Reference Standard (via SocialSystem)
         market_data = self._prepare_market_data(self.tracker)
         
-        # Inject Reference Standard
-        if getattr(self.config_module, "ENABLE_VANITY_SYSTEM", False):
-            ref_std = self._calculate_reference_standard()
+        if getattr(self.config_module, "ENABLE_VANITY_SYSTEM", False) and self.social_system:
+            context: SocialMobilityContext = {
+                "households": self.households
+            }
+            self.social_system.update_social_ranks(context)
+            ref_std = self.social_system.calculate_reference_standard(context)
             market_data["reference_standard"] = ref_std
 
         # Phase 17-5: Leviathan Logic Integration
@@ -278,53 +232,22 @@ class Simulation:
         # 2. Government Gathers Opinion
         self.government.update_public_opinion(self.households)
 
-        # --- WO-057-B: Sensory Module Pipeline ---
-        # Collect Raw Data
-        latest_indicators = self.tracker.get_latest_indicators()
-
-        # Inflation (Price Change)
-        current_price = latest_indicators.get("avg_goods_price", 10.0)
-        last_price = self.last_avg_price_for_sma
-        inflation_rate = (current_price - last_price) / last_price if last_price > 0 else 0.0
-        self.last_avg_price_for_sma = current_price
-
-        # Unemployment
-        unemployment_rate = latest_indicators.get("unemployment_rate", 0.0)
-
-        # GDP Growth
-        current_gdp = latest_indicators.get("total_production", 0.0)
-        last_gdp = self.last_gdp_for_sma
-        gdp_growth = (current_gdp - last_gdp) / last_gdp if last_gdp > 0 else 0.0
-        self.last_gdp_for_sma = current_gdp
-
-        # Wage
-        avg_wage = latest_indicators.get("avg_wage", 0.0)
-
-        # Approval
-        approval = self.government.approval_rating
-
-        # Append to Buffers
-        self.inflation_buffer.append(inflation_rate)
-        self.unemployment_buffer.append(unemployment_rate)
-        self.gdp_growth_buffer.append(gdp_growth)
-        self.wage_buffer.append(avg_wage)
-        self.approval_buffer.append(approval)
-
-        # Calculate SMA
-        def calculate_sma(buffer: deque) -> float:
-            return sum(buffer) / len(buffer) if buffer else 0.0
-
-        sensory_dto = GovernmentStateDTO(
-            tick=self.time,
-            inflation_sma=calculate_sma(self.inflation_buffer),
-            unemployment_sma=calculate_sma(self.unemployment_buffer),
-            gdp_growth_sma=calculate_sma(self.gdp_growth_buffer),
-            wage_sma=calculate_sma(self.wage_buffer),
-            approval_sma=calculate_sma(self.approval_buffer),
-            current_gdp=current_gdp
-        )
+        # --- WO-057-B: Sensory Module Pipeline (via SensorySystem) ---
+        sensory_context: SensoryContext = {
+            "tracker": self.tracker,
+            "government": self.government,
+            "time": self.time
+        }
+
+        # Anti-Pattern Fix: Removed lazy initialization.
+        # Systems MUST be initialized by SimulationInitializer.
+        if self.sensory_system:
+            sensory_dto = self.sensory_system.generate_government_sensory_dto(sensory_context)
+        else:
+            self.logger.error("SensorySystem not initialized! Check SimulationInitializer.")
+            # Fallback to empty DTO to prevent crash if critical, but log error
+            sensory_dto = GovernmentStateDTO(self.time, 0, 0, 0, 0, 0, 0)
 
-        # Supply to Government
         # Supply to Government
         if injectable_sensory_dto and injectable_sensory_dto.tick == self.time:
             self.government.update_sensory_data(injectable_sensory_dto)
@@ -504,12 +427,8 @@ class Simulation:
         self._process_transactions(all_transactions)
 
         # ---------------------------------------------------------
-        # Activate Consumption Logic & Leisure Effects
+        # Activate Consumption Logic & Leisure Effects (via CommerceSystem)
         # ---------------------------------------------------------
-        # After transactions, households have goods in inventory.
-        # Now they must consume them to satisfy needs.
-        household_leisure_effects = {} # Store utility for AI reward injection
-
         # Recalculate vacancy count for correct death classification
         current_vacancies = 0
         labor_market = self.markets.get("labor")
@@ -518,77 +437,25 @@ class Simulation:
                  for order in item_orders:
                      current_vacancies += order.quantity
 
-        # Create a consumption-specific market data context
         consumption_market_data = market_data.copy()
         consumption_market_data["job_vacancies"] = current_vacancies
 
-        # WO-051: Vectorized Consumption Logic
-        # Pre-calculate consumption/purchase decisions for all households
-        batch_decisions = self.breeding_planner.decide_consumption_batch(self.households, consumption_market_data)
-        consume_list = batch_decisions.get('consume', [0] * len(self.households))
-        buy_list = batch_decisions.get('buy', [0] * len(self.households))
-        food_price = batch_decisions.get('price', 5.0)  # Default food price
-
-        for i, household in enumerate(self.households):
-             if household.is_active:
-
-                 # 1. Consumption (Vectorized Optimization)
-                 # Replace decide_and_consume with vectorized result application
-                 consumed_items = {}
-
-                 # 1a. Fast Consumption (Basic Food)
-                 if i < len(consume_list):
-                     c_amt = consume_list[i]
-                     if c_amt > 0:
-                         household.consume("basic_food", c_amt, self.time)
-                         consumed_items["basic_food"] = c_amt
-
-                 # 1b. Fast Purchase (Survival Rescue - Logic Map Item 3)
-                 if i < len(buy_list):
-                     b_amt = buy_list[i]
-                     if b_amt > 0:
-                         cost = b_amt * food_price
-                         if household.assets >= cost:
-                             household.assets -= cost
-                             household.inventory["basic_food"] = household.inventory.get("basic_food", 0) + b_amt
-                             # To prevent money destruction, we route this to Reflux System (Sink)
-                             self.reflux_system.capture(cost, source=f"Household_{household.id}", category="emergency_food")
-                             self.logger.debug(
-                                 f"VECTOR_BUY | Household {household.id} bought {b_amt:.1f} food (Fast Track)",
-                                 extra={"agent_id": household.id, "tags": ["consumption", "vector_buy"]}
-                             )
-                             # Consume immediately if they were starving and bought it?
-                             # The planner separates buy/consume. If they bought, they might consume next tick
-                             # or we can force consume now if consumption was 0?
-                             # Vector planner logic for consumption relies on Inventory > 0.
-                             # If inventory was 0, c_amt is 0.
-                             # If we buy now, we should probably allow immediate consumption.
-                             if c_amt == 0:
-                                 consume_now = min(b_amt, getattr(self.config_module, "FOOD_CONSUMPTION_QUANTITY", 1.0))
-                                 household.consume("basic_food", consume_now, self.time)
-                                 consumed_items["basic_food"] = consume_now
-
-                 # 2. Phase 5: Leisure Effect Application
-                 leisure_hours = household_time_allocation.get(household.id, 0.0)
-                 effect_dto = household.apply_leisure_effect(leisure_hours, consumed_items)
-                 
-                 # 3. Lifecycle Update [BUGFIX: WO-Diag-003]
-                 household.update_needs(self.time, consumption_market_data)
-
-                 # Store utility for reward injection
-                 household_leisure_effects[household.id] = effect_dto.utility_gained
-
-                 # Apply XP to Children (if Parenting)
-                 if effect_dto.leisure_type == "PARENTING" and effect_dto.xp_gained > 0:
-                     for child_id in household.children_ids:
-                         # Children might be in self.agents
-                         child = self.agents.get(child_id)
-                         if child and isinstance(child, Household) and child.is_active:
-                             child.education_xp += effect_dto.xp_gained
-                             self.logger.debug(
-                                 f"PARENTING_XP_TRANSFER | Parent {household.id} -> Child {child_id}. XP: {effect_dto.xp_gained:.4f}",
-                                 extra={"agent_id": household.id, "tags": ["LEISURE_EFFECT", "parenting"]}
-                             )
+        commerce_context: CommerceContext = {
+            "households": self.households,
+            "agents": self.agents,
+            "breeding_planner": self.breeding_planner,
+            "household_time_allocation": household_time_allocation,
+            "reflux_system": self.reflux_system,
+            "market_data": consumption_market_data,
+            "config": self.config_module,
+            "time": self.time
+        }
+
+        if self.commerce_system:
+            household_leisure_effects = self.commerce_system.execute_consumption_and_leisure(commerce_context)
+        else:
+            self.logger.error("CommerceSystem not initialized! Skipping consumption cycle.")
+            household_leisure_effects = {}
 
         # --- Phase 23: Technology Manager Update ---
         self.technology_manager.update(self.time, self)
@@ -640,93 +507,69 @@ class Simulation:
             )
 
 
+        # --- AI Learning Update (Unified) ---
+        market_data_for_learning = self._prepare_market_data(self.tracker)
+
+        # Firms
         for firm in self.firms:
             if firm.is_active and firm.id in firm_pre_states:
-                post_state_data = firm.get_agent_data()
                 agent_data = firm.get_agent_data()
-                market_data = self._prepare_market_data(self.tracker)
                 
-                # Calculate Reward using new method for Firms (Brand Valuation)
                 reward = firm.decision_engine.ai_engine.calculate_reward(
                     firm, firm.get_pre_state_data(), agent_data
                 )
                 
-                # Update Learning V2
-                firm.decision_engine.ai_engine.update_learning_v2(
-                    reward=reward,
-                    next_agent_data=agent_data,
-                    next_market_data=market_data,
-                )
-                
+                context: LearningUpdateContext = {
+                    "reward": reward,
+                    "next_agent_data": agent_data,
+                    "next_market_data": market_data_for_learning
+                }
+                firm.update_learning(context)
+
                 decision_data = AIDecisionData(
                     run_id=self.run_id,
                     tick=self.time,
                     agent_id=firm.id,
                     decision_type="VECTOR_V2",
-                    decision_details={
-                       "reward": reward
-                    },
+                    decision_details={"reward": reward},
                     predicted_reward=None,
                     actual_reward=reward,
                 )
                 self.repository.save_ai_decision(decision_data)
-                self.logger.debug(
-                    f"FIRM_LEARNING_UPDATE | Firm {firm.id} updated learning. Reward: {reward:.2f}",
-                    extra={
-                        "tick": self.time,
-                        "agent_id": firm.id,
-                        "reward": reward,
-                        "tags": ["ai_learning"],
-                    },
-                )
 
-        # --- AI Learning Update for Households ---
+        # Households
         for household in self.households:
             if household.is_active and household.id in household_pre_states:
                 post_state_data = household.get_agent_data()
                 agent_data = household.get_agent_data()
-                market_data = self._prepare_market_data(self.tracker)
                 
-                # Inject Phase 5 Leisure Utility into agent_data for Reward Calculation
                 leisure_utility = household_leisure_effects.get(household.id, 0.0)
                 agent_data["leisure_utility"] = leisure_utility
 
-                # Calculate Reward
                 reward = household.decision_engine.ai_engine._calculate_reward(
                     household.get_pre_state_data(),
                     post_state_data,
                     agent_data,
-                    market_data,
-                )
-                
-                # Update Learning V2
-                household.decision_engine.ai_engine.update_learning_v2(
-                    reward=reward,
-                    next_agent_data=agent_data,
-                    next_market_data=market_data,
+                    market_data_for_learning,
                 )
 
+                context: LearningUpdateContext = {
+                    "reward": reward,
+                    "next_agent_data": agent_data,
+                    "next_market_data": market_data_for_learning
+                }
+                household.update_learning(context)
+
                 decision_data = AIDecisionData(
                     run_id=self.run_id,
                     tick=self.time,
                     agent_id=household.id,
                     decision_type="VECTOR_V2",
-                    decision_details={
-                        "reward": reward
-                    },
+                    decision_details={"reward": reward},
                     predicted_reward=None,
                     actual_reward=reward,
                 )
                 self.repository.save_ai_decision(decision_data)
-                self.logger.debug(
-                    f"HOUSEHOLD_LEARNING_UPDATE | Household {household.id} updated learning. Reward: {reward:.2f}",
-                    extra={
-                        "tick": self.time,
-                        "agent_id": household.id,
-                        "reward": reward,
-                        "tags": ["ai_learning"],
-                    },
-                )
 
         # 8. M&A Î∞è ÌååÏÇ∞ Ï≤òÎ¶¨ (Corporate Metabolism)
         self.ma_manager.process_market_exits_and_entries(self.time)
diff --git a/simulation/firms.py b/simulation/firms.py
index 08568f4..814713d 100644
--- a/simulation/firms.py
+++ b/simulation/firms.py
@@ -21,6 +21,7 @@ from simulation.components.production_department import ProductionDepartment
 from simulation.components.sales_department import SalesDepartment
 from simulation.utils.shadow_logger import log_shadow
 from modules.finance.api import InsufficientFundsError
+from simulation.systems.api import ILearningAgent, LearningUpdateContext
 
 if TYPE_CHECKING:
     from simulation.loan_market import LoanMarket
@@ -29,7 +30,7 @@ if TYPE_CHECKING:
 
 logger = logging.getLogger(__name__)
 
-class Firm(BaseAgent):
+class Firm(BaseAgent, ILearningAgent):
     """Í∏∞ÏóÖ Ï£ºÏ≤¥. ÏÉùÏÇ∞Í≥º Í≥†Ïö©Ïùò Ï£ºÏ≤¥."""
 
     def __init__(
@@ -714,3 +715,20 @@ class Firm(BaseAgent):
             if self.cash_reserve < amount:
                 raise InsufficientFundsError(f"Firm {self.id} has insufficient funds for withdrawal of {amount:.2f}. Available: {self.cash_reserve:.2f}")
             self.cash_reserve -= amount
+
+    def update_learning(self, context: LearningUpdateContext) -> None:
+        """
+        ILearningAgent implementation.
+        Updates the internal AI engine with the new state and reward.
+        """
+        reward = context["reward"]
+        next_agent_data = context["next_agent_data"]
+        next_market_data = context["next_market_data"]
+
+        # ÏóîÏßÑÏùÄ Îçî Ïù¥ÏÉÅ firm.decision_engine.ai_engineÏóê ÏßÅÏ†ë Ï†ëÍ∑ºÌïòÏßÄ ÏïäÍ≥† Ïù¥ Î©îÏÑúÎìúÎ•º ÌÜµÌï¥ ÏöîÏ≤≠Ìï©ÎãàÎã§.
+        if hasattr(self.decision_engine, 'ai_engine'):
+            self.decision_engine.ai_engine.update_learning_v2(
+                reward=reward,
+                next_agent_data=next_agent_data,
+                next_market_data=next_market_data,
+            )
diff --git a/simulation/initialization/initializer.py b/simulation/initialization/initializer.py
index a2578dc..41f5651 100644
--- a/simulation/initialization/initializer.py
+++ b/simulation/initialization/initializer.py
@@ -44,6 +44,11 @@ from modules.finance.system import FinanceSystem
 from simulation.db.repository import SimulationRepository
 from simulation.systems.lifecycle_manager import AgentLifecycleManager
 from simulation.engine import Simulation
+from simulation.systems.social_system import SocialSystem
+from simulation.systems.event_system import EventSystem
+from simulation.systems.sensory_system import SensorySystem
+from simulation.systems.commerce_system import CommerceSystem
+from simulation.systems.labor_market_analyzer import LaborMarketAnalyzer
 
 
 class SimulationInitializer(SimulationInitializerInterface):
@@ -217,6 +222,13 @@ class SimulationInitializer(SimulationInitializerInterface):
             logger=self.logger
         )
 
+        # Initialize New Systems (Social, Event, Sensory, Commerce, Labor)
+        sim.social_system = SocialSystem(self.config)
+        sim.event_system = EventSystem(self.config)
+        sim.sensory_system = SensorySystem(self.config)
+        sim.commerce_system = CommerceSystem(self.config, sim.reflux_system)
+        sim.labor_market_analyzer = LaborMarketAnalyzer(self.config)
+
         sim.household_time_allocation: Dict[int, float] = {}
         sim.inflation_buffer = deque(maxlen=10)
         sim.unemployment_buffer = deque(maxlen=10)
diff --git a/simulation/systems/api.py b/simulation/systems/api.py
index 056bdfb..37a8e3f 100644
--- a/simulation/systems/api.py
+++ b/simulation/systems/api.py
@@ -4,18 +4,21 @@ God Class Î¶¨Ìå©ÌÜ†ÎßÅÏùÑ ÏúÑÌïú ÏÉàÎ°úÏö¥ ÏãúÏä§ÌÖú Î∞è Ïª¥Ìè¨ÎÑåÌä∏Ïùò Í≥ÑÏïΩ
 Ïù¥ ÌååÏùºÏùÄ ÏÉàÎ°úÏö¥ ÏïÑÌÇ§ÌÖçÏ≤ò ÏöîÏÜåÏùò Í≥µÍ∞ú APIÎ•º ÏÑ§Ï†ïÌïòÏó¨ Î™ÖÌôïÌïú Í≤ΩÍ≥ÑÏôÄ ÌÉÄÏûÖ ÏïàÏ†ÑÏÑ±ÏùÑ Î≥¥Ïû•Ìï©ÎãàÎã§.
 """
 from __future__ import annotations
-from typing import List, Dict, Any, Optional, Protocol, TypedDict, Deque
+from typing import List, Dict, Any, Optional, Protocol, TypedDict, Deque, Tuple
 from abc import ABC, abstractmethod
 
 # ÏàúÌôò Ï∞∏Ï°∞Î•º ÌîºÌïòÍ∏∞ ÏúÑÌïú Forward declarations
-if 'TYPE_CHECKING':
-    from simulation.core_agents import Household, Firm
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from simulation.core_agents import Household
+    from simulation.firms import Firm
     from simulation.agents.government import Government
     from simulation.config import SimulationConfig
     from simulation.systems.reflux_system import EconomicRefluxSystem
     from simulation.ai.vectorized_planner import VectorizedHouseholdPlanner
     from simulation.metrics.economic_tracker import EconomicIndicatorTracker
-    from simulation.dtos import GovernmentStateDTO
+    from simulation.dtos import GovernmentStateDTO, LeisureEffectDTO
     from simulation.markets.market import Market
 
 
@@ -26,7 +29,7 @@ if 'TYPE_CHECKING':
 class SocialMobilityContext(TypedDict):
     """ÏÇ¨ÌöåÏ†Å Ïù¥ÎèôÏÑ± Í≥ÑÏÇ∞Ïóê ÌïÑÏöîÌïú Îç∞Ïù¥ÌÑ∞ÏûÖÎãàÎã§."""
     households: List['Household']
-    housing_manager: Any # API Îã®ÏàúÌôîÎ•º ÏúÑÌï¥ Any, Ïã§Ï†úÎ°úÎäî HousingManager Ïù∏Ïä§ÌÑ¥Ïä§
+    # housing_manager: Any # API Îã®ÏàúÌôîÎ•º ÏúÑÌï¥ Any, Ïã§Ï†úÎ°úÎäî HousingManager Ïù∏Ïä§ÌÑ¥Ïä§
 
 class EventContext(TypedDict):
     """Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨Ïóê ÌïÑÏöîÌïú Îç∞Ïù¥ÌÑ∞ÏûÖÎãàÎã§."""
@@ -43,11 +46,12 @@ class SensoryContext(TypedDict):
 class CommerceContext(TypedDict):
     """ÏÉÅÍ±∞Îûò ÏãúÏä§ÌÖúÏù¥ ÏÜåÎπÑÎ•º Ïã§ÌñâÌïòÎäî Îç∞ ÌïÑÏöîÌïú Îç∞Ïù¥ÌÑ∞ÏûÖÎãàÎã§."""
     households: List['Household']
+    agents: Dict[int, Any] # For O(1) lookup
     breeding_planner: 'VectorizedHouseholdPlanner'
     household_time_allocation: Dict[int, float]
     reflux_system: 'EconomicRefluxSystem'
     market_data: Dict[str, Any]
-    config: 'SimulationConfig'
+    config: Any
     time: int
 
 class LifecycleContext(TypedDict):
@@ -72,7 +76,7 @@ class LearningUpdateContext(TypedDict):
 
 class ISocialSystem(Protocol):
     """ÏÇ¨ÌöåÏ†Å ÏàúÏúÑ Î∞è ÏßÄÏúÑÏôÄ Í∞ôÏùÄ ÎèôÏ†Å ÏöîÏÜåÎ•º Í¥ÄÎ¶¨ÌïòÎäî ÏãúÏä§ÌÖúÏùò Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ÏûÖÎãàÎã§."""
-    def __init__(self, config: 'SimulationConfig'): ...
+    def __init__(self, config: Any): ...
 
     def update_social_ranks(self, context: SocialMobilityContext) -> None:
         """Î™®Îì† Í∞ÄÍ≥ÑÏùò ÏÇ¨ÌöåÏ†Å ÏàúÏúÑ Î∞±Î∂ÑÏúÑÎ•º Í≥ÑÏÇ∞ÌïòÍ≥† Ìï†ÎãπÌï©ÎãàÎã§."""
@@ -85,7 +89,7 @@ class ISocialSystem(Protocol):
 
 class IEventSystem(Protocol):
     """ÏòàÏïΩÎêòÍ±∞ÎÇò Ìä∏Î¶¨Í±∞Îêú ÏãúÎÆ¨Î†àÏù¥ÏÖò Ï†ÑÎ∞òÏùò Ïù¥Î≤§Ìä∏Î•º Í¥ÄÎ¶¨ÌïòÎäî ÏãúÏä§ÌÖúÏùò Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ÏûÖÎãàÎã§."""
-    def __init__(self, config: 'SimulationConfig'): ...
+    def __init__(self, config: Any): ...
 
     def execute_scheduled_events(self, time: int, context: EventContext) -> None:
         """ÌòÑÏû¨ Ìã±Ïóê ÏòàÏïΩÎêú Ïπ¥Ïò§Ïä§ Ïù¥Î≤§Ìä∏ÎÇò Îã§Î•∏ ÏãúÎÇòÎ¶¨Ïò§Î•º Ïã§ÌñâÌï©ÎãàÎã§."""
@@ -106,7 +110,7 @@ class ISensorySystem(Protocol):
     last_avg_price_for_sma: float
     last_gdp_for_sma: float
 
-    def __init__(self, config: 'SimulationConfig'): ...
+    def __init__(self, config: Any): ...
 
     def generate_government_sensory_dto(self, context: SensoryContext) -> 'GovernmentStateDTO':
         """Ï£ºÏöî ÏßÄÌëúÏùò SMAÎ•º Í≥ÑÏÇ∞ÌïòÍ≥† DTOÎ°ú Ìå®ÌÇ§ÏßïÌï©ÎãàÎã§."""
@@ -115,10 +119,14 @@ class ISensorySystem(Protocol):
 
 class ICommerceSystem(Protocol):
     """Ìã±Ïùò ÏÜåÎπÑ Î∞è Ïó¨Í∞Ä Î∂ÄÎ∂ÑÏùÑ Í¥ÄÎ¶¨ÌïòÎäî ÏãúÏä§ÌÖúÏùò Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ÏûÖÎãàÎã§."""
-    def __init__(self, config: 'SimulationConfig', reflux_system: 'EconomicRefluxSystem'): ...
+    def __init__(self, config: Any, reflux_system: 'EconomicRefluxSystem'): ...
 
-    def execute_consumption_and_leisure(self, context: CommerceContext) -> None:
-        """Í∞ÄÍ≥Ñ ÏÜåÎπÑ, Í∏¥Í∏â Íµ¨Îß§(fast-track purchases), Ïó¨Í∞Ä Ìö®Í≥ºÎ•º Ï°∞Ïú®Ìï©ÎãàÎã§."""
+    def execute_consumption_and_leisure(self, context: CommerceContext) -> Dict[int, float]:
+        """
+        Í∞ÄÍ≥Ñ ÏÜåÎπÑ, Í∏¥Í∏â Íµ¨Îß§(fast-track purchases), Ïó¨Í∞Ä Ìö®Í≥ºÎ•º Ï°∞Ïú®Ìï©ÎãàÎã§.
+        Returns:
+            Dict[int, float]: Í∞ÄÍ≥Ñ IDÎ≥Ñ Ïó¨Í∞Ä Ìö®Ïö©(Leisure Utility) Îßµ.
+        """
         ...
 
 # ===================================================================
@@ -130,7 +138,7 @@ class IAgentLifecycleComponent(Protocol):
     ÏóêÏù¥Ï†ÑÌä∏Ïùò Ìã±Îãπ ÏÉùÎ™ÖÏ£ºÍ∏∞Î•º Ï°∞Ïú®ÌïòÎäî Ïª¥Ìè¨ÎÑåÌä∏ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ÏûÖÎãàÎã§.
     ÌòºÎûÄÏä§Îü¨Ïõ†Îçò `update_needs` Î©îÏÑúÎìúÎ•º ÎåÄÏ≤¥Ìï©ÎãàÎã§.
     """
-    def __init__(self, owner: 'Household', config: 'SimulationConfig'): ...
+    def __init__(self, owner: 'Household', config: Any): ...
 
     def run_tick(self, context: LifecycleContext) -> None:
         """
@@ -141,9 +149,9 @@ class IAgentLifecycleComponent(Protocol):
 
 class IMarketComponent(Protocol):
     """ÌåêÎß§Ïûê ÏÑ†ÌÉùÍ≥º Í∞ôÏùÄ ÏãúÏû• ÏÉÅÌò∏ÏûëÏö©ÏùÑ Ï±ÖÏûÑÏßÄÎäî Ïª¥Ìè¨ÎÑåÌä∏ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ÏûÖÎãàÎã§."""
-    def __init__(self, owner: 'Household', config: 'SimulationConfig'): ...
+    def __init__(self, owner: 'Household', config: Any): ...
 
-    def choose_best_seller(self, item_id: str, context: MarketInteractionContext) -> tuple[Optional[int], float]:
+    def choose_best_seller(self, item_id: str, context: MarketInteractionContext) -> Tuple[Optional[int], float]:
         """
         Í∞ÄÍ≤©, ÌíàÏßà, Î∏åÎûúÎìú Ïù∏ÏßÄÎèÑ, Ï∂©ÏÑ±ÎèÑÎ•º Ìè¨Ìï®ÌïòÎäî Ìö®Ïö©Ïóê Í∏∞Î∞òÌïòÏó¨
         Ï£ºÏñ¥ÏßÑ ÏïÑÏù¥ÌÖúÏóê ÎåÄÌïú ÏµúÏ†ÅÏùò ÌåêÎß§ÏûêÎ•º ÏÑ†ÌÉùÌï©ÎãàÎã§.
@@ -157,7 +165,7 @@ class ILaborMarketAnalyzer(Protocol):
     """
     market_wage_history: Deque[float]
 
-    def __init__(self, config: 'SimulationConfig'): ...
+    def __init__(self, config: Any): ...
 
     def calculate_shadow_reservation_wage(self, agent: 'Household', market_data: Dict[str, Any]) -> float:
         """Í∞ÄÍ≥ÑÏùò Í≥†Ï†ïÏ†ÅÏù∏ Ïú†Î≥¥ ÏûÑÍ∏àÏùÑ Í≥ÑÏÇ∞Ìï©ÎãàÎã§."""
@@ -186,3 +194,10 @@ class ILearningAgent(Protocol):
         Ïù¥Îäî "Î¨ªÏßÄ ÎßêÍ≥† ÏãúÏºúÎùº(Tell, Don't Ask)" ÏõêÏπôÏùÑ Í∞ïÏ†úÌï©ÎãàÎã§.
         """
         ...
+
+class AgentLifecycleManagerInterface(Protocol):
+    """
+    Interface for AgentLifecycleManager to ensure contract compliance.
+    """
+    def process_lifecycle_events(self, sim: Any) -> None:
+        ...
diff --git a/simulation/systems/commerce_system.py b/simulation/systems/commerce_system.py
new file mode 100644
index 0000000..3b39ef9
--- /dev/null
+++ b/simulation/systems/commerce_system.py
@@ -0,0 +1,112 @@
+"""
+Implements the CommerceSystem which orchestrates consumption, purchases, and leisure.
+"""
+from typing import Any, Dict, List
+import logging
+from simulation.systems.api import ICommerceSystem, CommerceContext
+from simulation.systems.reflux_system import EconomicRefluxSystem
+
+logger = logging.getLogger(__name__)
+
+class CommerceSystem(ICommerceSystem):
+    """
+    Orchestrates the consumption and leisure phase of the tick.
+    """
+
+    def __init__(self, config: Any, reflux_system: EconomicRefluxSystem):
+        self.config = config
+        self.reflux_system = reflux_system
+
+    def execute_consumption_and_leisure(self, context: CommerceContext) -> Dict[int, float]:
+        """
+        Executes vectorized consumption, applies fast-track purchases,
+        and calculates leisure effects.
+
+        Returns:
+            Dict[int, float]: Map of Household ID to Utility Gained.
+        """
+        households = context["households"]
+        breeding_planner = context["breeding_planner"]
+        time_allocation = context["household_time_allocation"]
+        market_data = context["market_data"]
+        current_time = context["time"]
+
+        household_leisure_effects: Dict[int, float] = {}
+
+        # 1. Vectorized Decision Making
+        batch_decisions = breeding_planner.decide_consumption_batch(households, market_data)
+
+        consume_list = batch_decisions.get('consume', [0] * len(households))
+        buy_list = batch_decisions.get('buy', [0] * len(households))
+        food_price = batch_decisions.get('price', 5.0)
+
+        for i, household in enumerate(households):
+            if not household.is_active:
+                continue
+
+            consumed_items = {}
+
+            # 2a. Fast Consumption
+            if i < len(consume_list):
+                c_amt = consume_list[i]
+                if c_amt > 0:
+                    household.consume("basic_food", c_amt, current_time)
+                    consumed_items["basic_food"] = c_amt
+
+            # 2b. Fast Purchase (Emergency Buy)
+            if i < len(buy_list):
+                b_amt = buy_list[i]
+                if b_amt > 0:
+                    cost = b_amt * food_price
+                    if household.assets >= cost:
+                        household.assets -= cost
+                        household.inventory["basic_food"] = household.inventory.get("basic_food", 0) + b_amt
+
+                        # Capture money sink
+                        self.reflux_system.capture(cost, source=f"Household_{household.id}", category="emergency_food")
+
+                        logger.debug(
+                            f"VECTOR_BUY | Household {household.id} bought {b_amt:.1f} food (Fast Track)",
+                            extra={"agent_id": household.id, "tags": ["consumption", "vector_buy"]}
+                        )
+
+                        # Immediate consumption if needed
+                        if c_amt == 0:
+                            consume_now = min(b_amt, getattr(self.config, "FOOD_CONSUMPTION_QUANTITY", 1.0))
+                            household.consume("basic_food", consume_now, current_time)
+                            consumed_items["basic_food"] = consume_now
+
+            # 3. Leisure Effect
+            leisure_hours = time_allocation.get(household.id, 0.0)
+            effect_dto = household.apply_leisure_effect(leisure_hours, consumed_items)
+
+            household_leisure_effects[household.id] = effect_dto.utility_gained
+
+            # 4. Lifecycle Update (Needs, Tax, Psychology)
+            # This is now delegated to AgentLifecycleComponent inside household.update_needs
+            # But wait, household.update_needs calls labor_manager.work()!
+            # work() shouldn't be called here if it was already done or calculated.
+            # In the old `Simulation.run_tick`:
+            # - Transactions happened.
+            # - Then this loop happened.
+            # - household.update_needs() was called here.
+            # - household.update_needs() calls labor_manager.work(8.0)
+
+            # So we must call household.update_needs() here to maintain logic.
+            # BUT, we are refactoring update_needs to AgentLifecycleComponent.
+            # So we should call household.lifecycle.run_tick() ideally.
+            # Since household still has update_needs wrapping the new component (in the intermediate step),
+            # we call household.update_needs().
+
+            household.update_needs(current_time, market_data)
+
+            # 5. Parenting XP Transfer
+            if effect_dto.leisure_type == "PARENTING" and effect_dto.xp_gained > 0:
+                agents = context.get("agents", {})
+                for child_id in household.children_ids:
+                    # Use O(1) lookup from agents dict
+                    child = agents.get(child_id)
+                    if child and getattr(child, "is_active", False):
+                        child.education_xp += effect_dto.xp_gained
+
+        return household_leisure_effects
diff --git a/simulation/systems/event_system.py b/simulation/systems/event_system.py
new file mode 100644
index 0000000..4d9d3c9
--- /dev/null
+++ b/simulation/systems/event_system.py
@@ -0,0 +1,39 @@
+"""
+Implements the EventSystem which handles scheduled chaos events.
+"""
+from typing import Dict, Any, List
+import logging
+from simulation.systems.api import IEventSystem, EventContext
+
+logger = logging.getLogger(__name__)
+
+class EventSystem(IEventSystem):
+    """
+    Manages scheduled events like Inflation Shock and Recession Shock.
+    """
+
+    def __init__(self, config: Any):
+        self.config = config
+
+    def execute_scheduled_events(self, time: int, context: EventContext) -> None:
+        """
+        Checks the current time and executes hardcoded events if they match.
+        """
+        markets = context["markets"]
+        households = context["households"]
+
+        # 1. Inflation Shock at Tick 200
+        if time == 200:
+            logger.warning("üî• CHAOS: Inflation Shock at Tick 200!")
+            for market in markets.values():
+                if hasattr(market, 'current_price'):
+                    market.current_price *= 1.5
+                if hasattr(market, 'avg_price'):
+                    market.avg_price *= 1.5
+
+        # 2. Recession Shock at Tick 600
+        if time == 600:
+            logger.warning("üî• CHAOS: Recession Shock at Tick 600!")
+            for household in households:
+                household.assets *= 0.5
+                # Note: logic to reduce monthly_income could be added here if needed
diff --git a/simulation/systems/labor_market_analyzer.py b/simulation/systems/labor_market_analyzer.py
new file mode 100644
index 0000000..096771b
--- /dev/null
+++ b/simulation/systems/labor_market_analyzer.py
@@ -0,0 +1,60 @@
+"""
+Implements the LaborMarketAnalyzer which tracks market-wide wage history.
+"""
+from collections import deque
+from typing import Any, Dict, Deque
+from simulation.systems.api import ILaborMarketAnalyzer
+
+class LaborMarketAnalyzer(ILaborMarketAnalyzer):
+    """
+    Analyzes labor market trends and calculates shadow reservation wages.
+    """
+
+    def __init__(self, config: Any):
+        self.config = config
+        self.market_wage_history: Deque[float] = deque(maxlen=30)
+
+    def update_market_history(self, market_data: Dict[str, Any]) -> None:
+        """
+        Updates the internal wage history with the latest market average.
+        """
+        avg_market_wage = 0.0
+        if market_data and "labor" in market_data:
+             avg_market_wage = market_data["labor"].get("avg_wage", 0.0)
+
+        if avg_market_wage > 0:
+            self.market_wage_history.append(avg_market_wage)
+
+    def calculate_shadow_reservation_wage(self, agent: Any, market_data: Dict[str, Any]) -> float:
+        """
+        Calculates the shadow reservation wage for an agent based on their status and market history.
+        """
+        # Note: agent is typed Any to avoid circular import, expected to be Household.
+
+        # 1. Startup Cost Index
+        startup_cost_index = 0.0
+        if self.market_wage_history:
+            avg_wage_30 = sum(self.market_wage_history) / len(self.market_wage_history)
+            startup_cost_index = avg_wage_30 * 6.0
+
+        # 2. Sticky Logic
+        current_shadow = getattr(agent, "shadow_reservation_wage", 0.0)
+
+        # Initialize if zero
+        if current_shadow <= 0.0:
+            current_shadow = agent.current_wage if agent.is_employed else agent.expected_wage
+
+        if agent.is_employed:
+            target = max(agent.current_wage, current_shadow)
+            # Wage Increase Rate: 0.05
+            new_shadow = (current_shadow * 0.95) + (target * 0.05)
+        else:
+            # Wage Decay Rate: 0.02
+            new_shadow = current_shadow * (1.0 - 0.02)
+
+            # Apply Floor
+            min_wage = getattr(self.config, "HOUSEHOLD_MIN_WAGE_DEMAND", 6.0)
+            if new_shadow < min_wage:
+                new_shadow = min_wage
+
+        return new_shadow
diff --git a/simulation/systems/sensory_system.py b/simulation/systems/sensory_system.py
new file mode 100644
index 0000000..93a2a0f
--- /dev/null
+++ b/simulation/systems/sensory_system.py
@@ -0,0 +1,78 @@
+"""
+Implements the SensorySystem which processes raw economic indicators into smoothed data for the government.
+"""
+from collections import deque
+from typing import Any, Deque
+from simulation.systems.api import ISensorySystem, SensoryContext
+from simulation.dtos import GovernmentStateDTO
+
+class SensorySystem(ISensorySystem):
+    """
+    Processes raw economic data into SMA buffers and produces Sensory DTOs.
+    Owning the state of buffers.
+    """
+
+    def __init__(self, config: Any):
+        self.config = config
+
+        # State Ownership
+        self.inflation_buffer: Deque[float] = deque(maxlen=10)
+        self.unemployment_buffer: Deque[float] = deque(maxlen=10)
+        self.gdp_growth_buffer: Deque[float] = deque(maxlen=10)
+        self.wage_buffer: Deque[float] = deque(maxlen=10)
+        self.approval_buffer: Deque[float] = deque(maxlen=10)
+
+        self.last_avg_price_for_sma: float = 10.0
+        self.last_gdp_for_sma: float = 0.0
+
+    def generate_government_sensory_dto(self, context: SensoryContext) -> GovernmentStateDTO:
+        """
+        Calculates indicators, updates buffers, and returns the DTO.
+        """
+        tracker = context["tracker"]
+        government = context["government"]
+        time = context["time"]
+
+        latest_indicators = tracker.get_latest_indicators()
+
+        # 1. Inflation (Price Change)
+        current_price = latest_indicators.get("avg_goods_price", 10.0)
+        last_price = self.last_avg_price_for_sma
+        inflation_rate = (current_price - last_price) / last_price if last_price > 0 else 0.0
+        self.last_avg_price_for_sma = current_price
+
+        # 2. Unemployment
+        unemployment_rate = latest_indicators.get("unemployment_rate", 0.0)
+
+        # 3. GDP Growth
+        current_gdp = latest_indicators.get("total_production", 0.0)
+        last_gdp = self.last_gdp_for_sma
+        gdp_growth = (current_gdp - last_gdp) / last_gdp if last_gdp > 0 else 0.0
+        self.last_gdp_for_sma = current_gdp
+
+        # 4. Wage
+        avg_wage = latest_indicators.get("avg_wage", 0.0)
+
+        # 5. Approval
+        approval = government.approval_rating
+
+        # Append to Buffers
+        self.inflation_buffer.append(inflation_rate)
+        self.unemployment_buffer.append(unemployment_rate)
+        self.gdp_growth_buffer.append(gdp_growth)
+        self.wage_buffer.append(avg_wage)
+        self.approval_buffer.append(approval)
+
+        # Calculate SMA
+        def calculate_sma(buffer: Deque[float]) -> float:
+            return sum(buffer) / len(buffer) if buffer else 0.0
+
+        return GovernmentStateDTO(
+            tick=time,
+            inflation_sma=calculate_sma(self.inflation_buffer),
+            unemployment_sma=calculate_sma(self.unemployment_buffer),
+            gdp_growth_sma=calculate_sma(self.gdp_growth_buffer),
+            wage_sma=calculate_sma(self.wage_buffer),
+            approval_sma=calculate_sma(self.approval_buffer),
+            current_gdp=current_gdp
+        )
diff --git a/simulation/systems/social_system.py b/simulation/systems/social_system.py
new file mode 100644
index 0000000..890f44a
--- /dev/null
+++ b/simulation/systems/social_system.py
@@ -0,0 +1,96 @@
+"""
+Implements the SocialSystem which handles social rank updates and reference standard calculation.
+"""
+from typing import Dict, Any, List
+from simulation.systems.api import ISocialSystem, SocialMobilityContext
+from simulation.decisions.housing_manager import HousingManager
+
+class SocialSystem(ISocialSystem):
+    """
+    Manages social mobility, rank calculation, and reference standards for the simulation.
+    """
+
+    def __init__(self, config: Any):
+        self.config = config
+
+    def update_social_ranks(self, context: SocialMobilityContext) -> None:
+        """
+        Calculates and updates the social rank (percentile) for all active households.
+        The score is a weighted sum of consumption and housing tier.
+        """
+        households = context["households"]
+        # HousingManager might be passed in context or instantiated here.
+        # The spec says context has 'housing_manager', but the old code instantiated it.
+        # Let's instantiate it if not provided to be safe, or use what's provided.
+        # For simplicity and to match legacy logic, we instantiate a helper.
+        # But `HousingManager` needs an agent.
+
+        scores = []
+
+        # We need a helper for housing tier. The HousingManager takes (agent, config).
+        # We will reuse it per agent or just create one temporary instance if stateless?
+        # HousingManager.get_housing_tier(agent) uses agent attributes.
+        # So we can just instantiate it once with None agent if the method accepts agent.
+        # Checking HousingManager code... `get_housing_tier` takes `agent`.
+        # The `__init__` takes `agent`, but `get_housing_tier` also takes `agent` as argument.
+        # This seems redundant or one is ignored.
+        # Looking at `simulation/decisions/housing_manager.py`:
+        # class HousingManager: def __init__(self, agent: Any, config: Any): self.agent = agent ...
+        # def get_housing_tier(self, agent: Any) -> float: ...
+        # It seems it can be used statelessly if we pass agent to get_housing_tier.
+
+        hm = context.get("housing_manager")
+        if not hm:
+             hm = HousingManager(None, self.config)
+
+        for h in households:
+            if not h.is_active: continue
+
+            # Calculate Score
+            consumption_score = h.current_consumption * 10.0
+            housing_tier = hm.get_housing_tier(h)
+            housing_score = housing_tier * 1000.0
+
+            total_score = consumption_score + housing_score
+            scores.append((h, total_score))
+
+        # Sort and Assign Rank
+        # Higher score = Better rank (Higher Percentile)
+        scores.sort(key=lambda x: x[1], reverse=True)
+
+        n = len(scores)
+        if n == 0: return
+
+        for rank_idx, (agent, _) in enumerate(scores):
+            # Rank 0 (Top) -> Percentile 1.0
+            # Rank N-1 (Bottom) -> Percentile 0.0
+            percentile = 1.0 - (rank_idx / n)
+            agent.social_rank = percentile
+
+    def calculate_reference_standard(self, context: SocialMobilityContext) -> Dict[str, float]:
+        """
+        Calculates the average consumption and housing tier of the top 20% households.
+        """
+        households = context["households"]
+        active_households = [h for h in households if h.is_active]
+
+        if not active_households:
+            return {"avg_consumption": 0.0, "avg_housing_tier": 0.0}
+
+        # Sort by social rank
+        sorted_hh = sorted(active_households, key=lambda h: getattr(h, "social_rank", 0.0), reverse=True)
+
+        top_20_count = max(1, int(len(active_households) * 0.20))
+        top_20 = sorted_hh[:top_20_count]
+
+        hm = context.get("housing_manager")
+        if not hm:
+             hm = HousingManager(None, self.config)
+
+        avg_cons = sum(h.current_consumption for h in top_20) / len(top_20)
+        avg_tier = sum(hm.get_housing_tier(h) for h in top_20) / len(top_20)
+
+        return {
+            "avg_consumption": avg_cons,
+            "avg_housing_tier": avg_tier
+        }
diff --git a/tests/components/test_agent_lifecycle.py b/tests/components/test_agent_lifecycle.py
new file mode 100644
index 0000000..c7bf726
--- /dev/null
+++ b/tests/components/test_agent_lifecycle.py
@@ -0,0 +1,51 @@
+import pytest
+from unittest.mock import MagicMock
+from simulation.components.agent_lifecycle import AgentLifecycleComponent
+from simulation.systems.api import LifecycleContext
+
+@pytest.fixture
+def lifecycle_component():
+    owner = MagicMock()
+    config = MagicMock()
+    return AgentLifecycleComponent(owner, config)
+
+def test_run_tick_execution_order(lifecycle_component):
+    # Setup
+    household = lifecycle_component.owner
+    household.is_employed = True
+    # Components on household
+    household.labor_manager = MagicMock()
+    household.economy_manager = MagicMock()
+    household.psychology = MagicMock()
+
+    context: LifecycleContext = {
+        "household": household,
+        "market_data": {},
+        "time": 1
+    }
+
+    # Execute
+    lifecycle_component.run_tick(context)
+
+    # Verify execution
+    household.labor_manager.work.assert_called_with(8.0)
+    household.economy_manager.pay_taxes.assert_called_once()
+    household.psychology.update_needs.assert_called_with(1, {})
+
+def test_run_tick_unemployed(lifecycle_component):
+    household = lifecycle_component.owner
+    household.is_employed = False
+    household.labor_manager = MagicMock()
+    household.economy_manager = MagicMock()
+    household.psychology = MagicMock()
+
+    context: LifecycleContext = {
+        "household": household,
+        "market_data": {},
+        "time": 1
+    }
+
+    lifecycle_component.run_tick(context)
+
+    # Work hours should be 0.0
+    household.labor_manager.work.assert_called_with(0.0)
diff --git a/tests/components/test_market_component.py b/tests/components/test_market_component.py
new file mode 100644
index 0000000..223f7f5
--- /dev/null
+++ b/tests/components/test_market_component.py
@@ -0,0 +1,53 @@
+import pytest
+from unittest.mock import MagicMock
+from simulation.components.market_component import MarketComponent
+from simulation.systems.api import MarketInteractionContext
+
+@pytest.fixture
+def market_component():
+    owner = MagicMock()
+    # Default preferences
+    owner.brand_loyalty = {}
+    owner.quality_preference = 0.5
+
+    config = MagicMock()
+    config.BRAND_SENSITIVITY_BETA = 0.5
+    return MarketComponent(owner, config)
+
+def test_choose_best_seller_utility(market_component):
+    # Setup
+    # Seller 1: Price 10, Quality 1.0, Awareness 0.0
+    # Seller 2: Price 12, Quality 1.5, Awareness 0.0
+
+    ask1 = MagicMock()
+    ask1.price = 10.0
+    ask1.agent_id = 1
+    ask1.brand_info = {"perceived_quality": 1.0, "brand_awareness": 0.0}
+
+    ask2 = MagicMock()
+    ask2.price = 12.0
+    ask2.agent_id = 2
+    ask2.brand_info = {"perceived_quality": 1.5, "brand_awareness": 0.0}
+
+    market = MagicMock()
+    market.get_all_asks.return_value = [ask1, ask2]
+
+    context: MarketInteractionContext = {
+        "markets": {"good_x": market}
+    }
+
+    # Execute
+    best_seller, best_price = market_component.choose_best_seller("good_x", context)
+
+    # Calc Utility
+    # U1 = (1.0^0.5 * 1.0^0.5 * 1.0) / 10 = 0.1
+    # U2 = (1.5^0.5 * 1.0^0.5 * 1.0) / 12 = 1.22 / 12 = 0.102
+
+    # U2 > U1
+    assert best_seller == 2
+    assert best_price == 12.0
+
+def test_choose_best_seller_no_market(market_component):
+    context = {"markets": {}}
+    best_seller, _ = market_component.choose_best_seller("missing_good", context)
+    assert best_seller is None
diff --git a/tests/systems/test_commerce_system.py b/tests/systems/test_commerce_system.py
new file mode 100644
index 0000000..549e677
--- /dev/null
+++ b/tests/systems/test_commerce_system.py
@@ -0,0 +1,107 @@
+import pytest
+from unittest.mock import MagicMock
+from simulation.systems.commerce_system import CommerceSystem
+from simulation.systems.api import CommerceContext
+
+@pytest.fixture
+def commerce_system():
+    config = MagicMock()
+    # Mock config values
+    config.FOOD_CONSUMPTION_QUANTITY = 1.0
+    reflux_system = MagicMock()
+    return CommerceSystem(config, reflux_system)
+
+def test_execute_consumption_and_leisure(commerce_system):
+    # Setup Households
+    h1 = MagicMock()
+    h1.id = 1
+    h1.is_active = True
+    h1.assets = 100.0
+    h1.inventory = {"basic_food": 0}
+    # Mock apply_leisure_effect return
+    effect_dto = MagicMock()
+    effect_dto.utility_gained = 5.0
+    effect_dto.leisure_type = "IDLE"
+    h1.apply_leisure_effect.return_value = effect_dto
+
+    households = [h1]
+
+    # Mock Vector Planner
+    planner = MagicMock()
+    # h1 consumes 1, buys 2
+    planner.decide_consumption_batch.return_value = {
+        "consume": [1.0],
+        "buy": [2.0],
+        "price": 10.0
+    }
+
+    # Mock Context
+    context: CommerceContext = {
+        "households": households,
+        "breeding_planner": planner,
+        "household_time_allocation": {1: 8.0},
+        "reflux_system": commerce_system.reflux_system,
+        "market_data": {},
+        "config": commerce_system.config,
+        "time": 1
+    }
+
+    # Execute
+    leisure_effects = commerce_system.execute_consumption_and_leisure(context)
+
+    # Verify
+    # 1. Purchase: Buy 2.0 @ 10.0 = 20.0 cost
+    assert h1.assets == 80.0 # 100 - 20
+    assert h1.inventory["basic_food"] == 2.0
+
+    # 2. Consumption: Consume 1.0 (Fast Consumption)
+    h1.consume.assert_called_with("basic_food", 1.0, 1)
+
+    # 3. Leisure
+    h1.apply_leisure_effect.assert_called_with(8.0, {'basic_food': 1.0})
+
+    # 4. Return Value
+    assert leisure_effects[1] == 5.0
+
+    # 5. Lifecycle Update called
+    h1.update_needs.assert_called_once()
+
+    # 6. Reflux Capture
+    commerce_system.reflux_system.capture.assert_called_with(20.0, source="Household_1", category="emergency_food")
+
+def test_fast_track_consumption_if_needed(commerce_system):
+    # Case: Inventory 0, Consumes 0 (in vector), Buys 2.
+    # Should trigger immediate consumption from bought items.
+
+    h1 = MagicMock()
+    h1.id = 1
+    h1.is_active = True
+    h1.assets = 100.0
+    h1.inventory = {"basic_food": 0}
+
+    effect_dto = MagicMock()
+    effect_dto.utility_gained = 0.0
+    h1.apply_leisure_effect.return_value = effect_dto
+
+    planner = MagicMock()
+    planner.decide_consumption_batch.return_value = {
+        "consume": [0.0], # Planner says consume 0 because inventory was 0
+        "buy": [2.0],
+        "price": 10.0
+    }
+
+    context: CommerceContext = {
+        "households": [h1],
+        "breeding_planner": planner,
+        "household_time_allocation": {},
+        "reflux_system": commerce_system.reflux_system,
+        "market_data": {},
+        "config": commerce_system.config,
+        "time": 1
+    }
+
+    commerce_system.execute_consumption_and_leisure(context)
+
+    # Verify Immediate Consumption
+    # Expect consume call with default 1.0 (from config) or min(bought, default)
+    h1.consume.assert_called_with("basic_food", 1.0, 1)
diff --git a/tests/systems/test_event_system.py b/tests/systems/test_event_system.py
new file mode 100644
index 0000000..f926ac9
--- /dev/null
+++ b/tests/systems/test_event_system.py
@@ -0,0 +1,67 @@
+import pytest
+from unittest.mock import MagicMock
+from simulation.systems.event_system import EventSystem
+from simulation.systems.api import EventContext
+
+@pytest.fixture
+def event_system():
+    config = MagicMock()
+    return EventSystem(config)
+
+def test_inflation_shock(event_system):
+    # Setup
+    market = MagicMock()
+    market.current_price = 100.0
+    market.avg_price = 100.0
+    markets = {"goods": market}
+
+    context: EventContext = {
+        "markets": markets,
+        "households": [],
+        "firms": []
+    }
+
+    # Execute Tick 200
+    event_system.execute_scheduled_events(200, context)
+
+    # Verify
+    assert market.current_price == 150.0
+    assert market.avg_price == 150.0
+
+def test_recession_shock(event_system):
+    # Setup
+    h1 = MagicMock()
+    h1.assets = 1000.0
+    households = [h1]
+
+    context: EventContext = {
+        "markets": {},
+        "households": households,
+        "firms": []
+    }
+
+    # Execute Tick 600
+    event_system.execute_scheduled_events(600, context)
+
+    # Verify
+    assert h1.assets == 500.0
+
+def test_no_event(event_system):
+    # Setup
+    h1 = MagicMock()
+    h1.assets = 1000.0
+    market = MagicMock()
+    market.current_price = 100.0
+
+    context: EventContext = {
+        "markets": {"goods": market},
+        "households": [h1],
+        "firms": []
+    }
+
+    # Execute Tick 100 (No event)
+    event_system.execute_scheduled_events(100, context)
+
+    # Verify
+    assert h1.assets == 1000.0
+    assert market.current_price == 100.0
diff --git a/tests/systems/test_labor_market_analyzer.py b/tests/systems/test_labor_market_analyzer.py
new file mode 100644
index 0000000..e98cc0a
--- /dev/null
+++ b/tests/systems/test_labor_market_analyzer.py
@@ -0,0 +1,56 @@
+import pytest
+from unittest.mock import MagicMock
+from simulation.systems.labor_market_analyzer import LaborMarketAnalyzer
+
+@pytest.fixture
+def analyzer():
+    config = MagicMock()
+    config.HOUSEHOLD_MIN_WAGE_DEMAND = 6.0
+    return LaborMarketAnalyzer(config)
+
+def test_update_market_history(analyzer):
+    market_data = {
+        "labor": {"avg_wage": 15.0}
+    }
+    analyzer.update_market_history(market_data)
+    assert analyzer.market_wage_history[-1] == 15.0
+
+def test_calculate_shadow_reservation_wage_increase(analyzer):
+    # Employed agent, Wage < Shadow? No, usually Wage > Shadow pulls it up.
+    # Logic: new = old * 0.95 + target * 0.05
+    # target = max(current, shadow)
+
+    agent = MagicMock()
+    agent.is_employed = True
+    agent.current_wage = 20.0
+    agent.shadow_reservation_wage = 10.0
+
+    # Target = 20.0
+    # New = 10 * 0.95 + 20 * 0.05 = 9.5 + 1.0 = 10.5
+
+    new_wage = analyzer.calculate_shadow_reservation_wage(agent, {})
+    assert abs(new_wage - 10.5) < 0.001
+
+def test_calculate_shadow_reservation_wage_decay(analyzer):
+    # Unemployed agent
+    # Logic: new = old * 0.98
+
+    agent = MagicMock()
+    agent.is_employed = False
+    agent.shadow_reservation_wage = 10.0
+
+    new_wage = analyzer.calculate_shadow_reservation_wage(agent, {})
+
+    # 10 * 0.98 = 9.8
+    assert abs(new_wage - 9.8) < 0.001
+
+def test_calculate_shadow_reservation_wage_floor(analyzer):
+    agent = MagicMock()
+    agent.is_employed = False
+    agent.shadow_reservation_wage = 6.05
+
+    # Decay -> 6.05 * 0.98 = 5.929
+    # Floor is 6.0
+
+    new_wage = analyzer.calculate_shadow_reservation_wage(agent, {})
+    assert new_wage == 6.0
diff --git a/tests/systems/test_sensory_system.py b/tests/systems/test_sensory_system.py
new file mode 100644
index 0000000..911d961
--- /dev/null
+++ b/tests/systems/test_sensory_system.py
@@ -0,0 +1,80 @@
+import pytest
+from collections import deque
+from unittest.mock import MagicMock
+from simulation.systems.sensory_system import SensorySystem
+from simulation.systems.api import SensoryContext
+
+@pytest.fixture
+def sensory_system():
+    config = MagicMock()
+    return SensorySystem(config)
+
+def test_generate_government_sensory_dto(sensory_system):
+    # Setup
+    tracker = MagicMock()
+    # Mock return of get_latest_indicators
+    tracker.get_latest_indicators.return_value = {
+        "avg_goods_price": 11.0, # Last was 10.0 -> 10% inflation
+        "unemployment_rate": 0.05,
+        "total_production": 110.0, # Last was 0.0 -> ? (Assume 100 base)
+        "avg_wage": 20.0
+    }
+    # Initial state of system
+    sensory_system.last_avg_price_for_sma = 10.0
+    sensory_system.last_gdp_for_sma = 100.0
+
+    government = MagicMock()
+    government.approval_rating = 0.8
+
+    context: SensoryContext = {
+        "tracker": tracker,
+        "government": government,
+        "time": 10
+    }
+
+    # Execute
+    dto = sensory_system.generate_government_sensory_dto(context)
+
+    # Verify DTO
+    assert dto.tick == 10
+
+    # Inflation: (11 - 10) / 10 = 0.1
+    assert sensory_system.inflation_buffer[-1] == 0.1
+    assert dto.inflation_sma == 0.1 # Single value average
+
+    # GDP Growth: (110 - 100) / 100 = 0.1
+    assert sensory_system.gdp_growth_buffer[-1] == 0.1
+    assert dto.gdp_growth_sma == 0.1
+
+    assert dto.unemployment_sma == 0.05
+    assert dto.wage_sma == 20.0
+    assert dto.approval_sma == 0.8
+    assert dto.current_gdp == 110.0
+
+def test_buffer_smoothing(sensory_system):
+    # Add some history
+    sensory_system.inflation_buffer.append(0.0)
+    sensory_system.inflation_buffer.append(0.1)
+
+    # Avg should be 0.05
+
+    tracker = MagicMock()
+    tracker.get_latest_indicators.return_value = {
+        "avg_goods_price": 10.0, # No change from last
+    }
+    sensory_system.last_avg_price_for_sma = 10.0
+
+    government = MagicMock()
+    government.approval_rating = 0.5
+
+    context: SensoryContext = {
+        "tracker": tracker,
+        "government": government,
+        "time": 2
+    }
+
+    dto = sensory_system.generate_government_sensory_dto(context)
+
+    # Buffer: [0.0, 0.1, 0.0] -> Avg = 0.1 / 3 = 0.0333...
+    assert len(sensory_system.inflation_buffer) == 3
+    assert abs(dto.inflation_sma - 0.0333) < 0.001
diff --git a/tests/systems/test_social_system.py b/tests/systems/test_social_system.py
new file mode 100644
index 0000000..ba27200
--- /dev/null
+++ b/tests/systems/test_social_system.py
@@ -0,0 +1,75 @@
+import pytest
+from unittest.mock import MagicMock
+from simulation.systems.social_system import SocialSystem
+from simulation.systems.api import SocialMobilityContext
+
+class MockHousehold:
+    def __init__(self, id, consumption, housing_tier, is_active=True):
+        self.id = id
+        self.current_consumption = consumption
+        self.housing_tier = housing_tier # Helper for mocking HousingManager
+        self.is_active = is_active
+        self.social_rank = 0.0
+
+class MockHousingManager:
+    def __init__(self, agent, config):
+        pass
+    def get_housing_tier(self, agent):
+        return agent.housing_tier
+
+@pytest.fixture
+def social_system():
+    config = MagicMock()
+    return SocialSystem(config)
+
+def test_update_social_ranks(social_system):
+    # Setup
+    h1 = MockHousehold(1, consumption=100, housing_tier=1.0) # Score = 1000 + 1000 = 2000
+    h2 = MockHousehold(2, consumption=200, housing_tier=3.0) # Score = 2000 + 3000 = 5000 (Top)
+    h3 = MockHousehold(3, consumption=50, housing_tier=1.0)  # Score = 500 + 1000 = 1500 (Bottom)
+
+    households = [h1, h2, h3]
+    context: SocialMobilityContext = {
+        "households": households,
+        "housing_manager": MockHousingManager(None, None)
+    }
+
+    # Execute
+    social_system.update_social_ranks(context)
+
+    # Verify
+    # h2 should be Rank 0 -> Percentile 1.0
+    # h1 should be Rank 1 -> Percentile 1 - 1/3 = 0.66
+    # h3 should be Rank 2 -> Percentile 1 - 2/3 = 0.33
+
+    assert h2.social_rank == 1.0
+    assert abs(h1.social_rank - (1.0 - 1/3)) < 0.01
+    assert abs(h3.social_rank - (1.0 - 2/3)) < 0.01
+
+def test_calculate_reference_standard(social_system):
+    # Setup
+    # Top 20% of 5 agents = 1 agent
+    h1 = MockHousehold(1, consumption=100, housing_tier=1.0) # Rank 1.0 (Assume sorted)
+    h1.social_rank = 1.0
+    h2 = MockHousehold(2, consumption=50, housing_tier=1.0)
+    h2.social_rank = 0.8
+    h3 = MockHousehold(3, consumption=10, housing_tier=1.0)
+    h3.social_rank = 0.6
+    h4 = MockHousehold(4, consumption=10, housing_tier=1.0)
+    h4.social_rank = 0.4
+    h5 = MockHousehold(5, consumption=10, housing_tier=1.0)
+    h5.social_rank = 0.2
+
+    households = [h1, h2, h3, h4, h5]
+    context: SocialMobilityContext = {
+        "households": households,
+        "housing_manager": MockHousingManager(None, None)
+    }
+
+    # Execute
+    std = social_system.calculate_reference_standard(context)
+
+    # Verify
+    # Top 1 is h1.
+    assert std["avg_consumption"] == 100.0
+    assert std["avg_housing_tier"] == 1.0
diff --git a/tests/test_engine.py b/tests/test_engine.py
index ac7c33d..b3b9c7b 100644
--- a/tests/test_engine.py
+++ b/tests/test_engine.py
@@ -41,12 +41,21 @@ def mock_config_module():
     mock_config.INHERITANCE_TAX_RATE = 1.0
     mock_config.TICKS_PER_YEAR = 100.0
     mock_config.INITIAL_BASE_ANNUAL_RATE = 0.05
+    # To support string formatting in mock
+    mock_config.initial_base_annual_rate = 0.05
     mock_config.CREDIT_SPREAD_BASE = 0.02
     mock_config.BANK_MARGIN = 0.02
     mock_config.LOAN_DEFAULT_TERM = 50
     mock_config.CREDIT_RECOVERY_TICKS = 100
     mock_config.BANKRUPTCY_XP_PENALTY = 0.2
     mock_config.INVENTORY_HOLDING_COST_RATE = 0.005
+    mock_config.INITIAL_PROPERTY_VALUE = 1000.0
+    mock_config.INITIAL_RENT_PRICE = 10.0
+    mock_config.NUM_HOUSING_UNITS = 10
+    mock_config.HALO_EFFECT = 0.1
+    mock_config.CHILD_MONTHLY_COST = 500.0
+    mock_config.OPPORTUNITY_COST_FACTOR = 0.3
+    mock_config.RAW_MATERIAL_SECTORS = []
     mock_config.MARKETING_DECAY_RATE = 0.8
     mock_config.MARKETING_EFFICIENCY = 0.01
     mock_config.PERCEIVED_QUALITY_ALPHA = 0.2
@@ -113,6 +122,11 @@ def mock_config_module():
         }
     }
 
+    mock_config.EDUCATION_WEALTH_THRESHOLDS = {0: 0, 1: 1000}
+    mock_config.INITIAL_WAGE = 10.0
+    mock_config.EDUCATION_COST_MULTIPLIERS = {0: 1.0, 1: 1.5}
+    mock_config.CONFORMITY_RANGES = {}
+
     return mock_config
 
 # Fixtures for common dependencies
@@ -144,6 +158,7 @@ def mock_households(mock_config_module):
     hh1.update_needs = Mock()
     hh1.talent = Mock(spec=Talent)
     hh1.talent.base_learning_rate = 0.1
+    hh1.inventory_quality = {}
 
     hh2 = Mock(spec=Household)
     hh2.id = 2
@@ -161,6 +176,7 @@ def mock_households(mock_config_module):
     hh2.update_needs = Mock()
     hh2.talent = Mock(spec=Talent)
     hh2.talent.base_learning_rate = 0.1
+    hh2.inventory_quality = {}
     return [hh1, hh2]
 
 
@@ -251,8 +267,21 @@ def simulation_instance(
     mock_logger,
 ):
     from simulation.initialization.initializer import SimulationInitializer
+    from modules.common.config_manager.api import ConfigManager
+
+    # Create a mock ConfigManager
+    mock_config_manager = Mock(spec=ConfigManager)
+    # Configure mock for __format__ (float) by making it behave like a float in formatting
+    # This is tricky with Mock objects.
+    # Instead of mocking __float__ (which is dunder), we mock the attribute that is formatted.
+    # The error is in Bank.__init__: Base Rate: {self.base_rate:.2%}
+    # self.base_rate comes from config.
+    # mock_config_manager.get() should return a float, not a Mock object.
+
+    mock_config_manager.get.return_value = 0.05
 
     initializer = SimulationInitializer(
+        config_manager=mock_config_manager,
         config_module=mock_config_module,
         goods_data=mock_goods_data,
         repository=mock_repository,
@@ -370,6 +399,7 @@ class TestSimulation:
         tx.item_id = "basic_food"
         tx.quantity = 5.0
         tx.price = 10.0
+        tx.quality = 1.0 # Ensure quality is a float
         tx.transaction_type = "goods"
 
         simulation_instance._process_transactions([tx])
@@ -647,8 +677,15 @@ def setup_simulation_for_lifecycle(
     firms = [firm_active, firm_inactive]
 
     from simulation.initialization.initializer import SimulationInitializer
+    from modules.common.config_manager.api import ConfigManager
+
+    mock_config_manager = Mock(spec=ConfigManager)
+    # Configure mock for __format__ (float)
+    mock_config_manager.initial_base_annual_rate = 0.05
+    mock_config_manager.get.return_value = 0.05
 
     initializer = SimulationInitializer(
+        config_manager=mock_config_manager,
         config_module=mock_config_module,
         goods_data=mock_goods_data_for_lifecycle,
         repository=mock_repository,
