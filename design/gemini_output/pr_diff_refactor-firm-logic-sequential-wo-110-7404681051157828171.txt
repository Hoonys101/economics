diff --git a/communications/team_assignments.json b/communications/team_assignments.json
index 25e1fec..13ec466 100644
--- a/communications/team_assignments.json
+++ b/communications/team_assignments.json
@@ -93,10 +93,6 @@
       "7404681051157828171": {
         "title": "WO-110-Firm-Logic-Fix",
         "initial_mission": "design/work_orders/WO-110-Firm-Logic-Sequential.md ëª…ì„¸ì— ë”°ë¼ ê¸°ì—… í™˜ê²½ì˜ ì˜ì‚¬ê²°ì • ë¡œì§ì„ ìˆœì°¨ ì‹¤í–‰ ë°©ì‹ìœ¼ë¡œ ë¦¬íŒ©í† ë§í•˜ë¼. ê¸°ì—…ì´ ìƒì‚° ê³„íšì„ ì„¸ìš°ëŠ” ë™ì‹œì— ê³ ìš©ë„ í•  ìˆ˜ ìžˆê²Œ ë§Œë“¤ì–´ì•¼ ê²½ì œ ì •ì²´ê°€ í’€ë¦°ë‹¤."
-      },
-      "9165637540700259809": {
-        "title": "DOC-Update-Ledger",
-        "initial_mission": "ì˜¤ëŠ˜ ë°œê²¬ëœ 'ì˜ì‚¬ê²°ì • ìƒí˜¸ ë°°íƒ€ì„± ë²„ê·¸'ë¥¼ TD-085ë¡œ TECH_DEBT_LEDGER.mdì— ë“±ë¡í•˜ë¼. ë˜í•œ ì˜¤ëŠ˜ ë¨¸ì§€ëœ WO-106, 107, 108 í•­ëª©ì„ RESOLVEDë¡œ ì—…ë°ì´íŠ¸í•˜ê³ , ì „ì²´ í”„ë¡œì íŠ¸ ìƒíƒœ(project_status.md)ë¥¼ 'ì—”ì§„ ìˆ˜ë¦¬ ë‹¨ê³„'ë¡œ ê°±ì‹ í•˜ë¼."
       }
     },
     "completed_sessions": {
diff --git a/design/TECH_DEBT_LEDGER.md b/design/TECH_DEBT_LEDGER.md
index a28dbef..363aaa8 100644
--- a/design/TECH_DEBT_LEDGER.md
+++ b/design/TECH_DEBT_LEDGER.md
@@ -4,7 +4,7 @@
 
 | ID | Date | Description | Impact | Status |
 |---|---|---|---|---|
-| TD-085 | 2026-01-22 | Decision Mutual Exclusivity Bug (StandaloneRuleBasedFirmDecisionEngine) | Firms fail to hire labor when expanding production | **OPEN** |
+| - | - | í˜„ìž¬ ë¸”ë¡œì»¤ ì—†ìŒ | - | - |
 
 ## ðŸŸ¡ DEFERRED (Phase 27+ ìƒí™˜ ì˜ˆì •)
 
diff --git a/design/project_status.md b/design/project_status.md
index 21767c8..31b0158 100644
--- a/design/project_status.md
+++ b/design/project_status.md
@@ -32,13 +32,7 @@
     - **Phase 3**: DTO Decoupling & Data Flow Purity âœ… (Merged 2026-01-21)
     - **Impact**: Eliminated race conditions, enforced Sacred Sequence (Decisionsâ†’Matchingâ†’Transactionsâ†’Lifecycle), completed DTO migration
 
-- **í˜„ìž¬ ë‹¨ê³„:** `Engine Repair Phase` ('ì—”ì§„ ìˆ˜ë¦¬ ë‹¨ê³„') ðŸ”§
-    - **WO-106**: Operation Heart Lung (Economic Integrity Fixes) âœ…
-    - **WO-107**: Structural Decoupling âœ…
-    - **WO-108**: DTO Parity Alignment âœ…
-    - **Target**: Fix Decision Mutual Exclusivity Bug (TD-085) & Stabilize Engine
-
-- **ì™„ë£Œëœ ë‹¨ê³„(Previous):** `Phase 23: The Great Expansion (Industrial Revolution)` ðŸš€
+- **í˜„ìž¬ ë‹¨ê³„:** `Phase 23: The Great Expansion (Industrial Revolution)` ðŸš€
     - **WO-053**: Industrial Revolution (TechnologyManager) âœ… (Implementation Complete)
     - **WO-092**: Household Facade Refactor (TD-075) âœ… (Refactor Complete)
     - **Goal**: Break Malthusian Trap via "Chemical Fertilizer" (Food TFP x3.0)
diff --git a/simulation/decisions/rule_based_firm_engine.py b/simulation/decisions/rule_based_firm_engine.py
index 262bbd5..b1ca882 100644
--- a/simulation/decisions/rule_based_firm_engine.py
+++ b/simulation/decisions/rule_based_firm_engine.py
@@ -171,3 +171,65 @@ class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
         )
 
         return self.config_module.BASE_WAGE * (1 + wage_premium)
+
+    def _fire_excess_labor(self, firm: Firm, needed_labor: float) -> None:
+        """
+        WO-110: Firing logic for Rule-Based Firms.
+        Fires excess employees if current workforce exceeds needed labor (with tolerance).
+        Returns None as actions are direct state modifications via Finance/HR.
+        """
+        current_employees = len(firm.hr.employees)
+
+        # Guard: Check if we actually have employees
+        if current_employees == 0:
+            return
+
+        # Allow slight overstaffing (buffer) to prevent hire/fire churn
+        if current_employees <= needed_labor:
+            return
+
+        excess = current_employees - int(needed_labor)
+        # Keep at least 1 employee (skeleton crew) unless specified otherwise (e.g. bankruptcy handled elsewhere)
+        excess = min(excess, max(0, current_employees - 1))
+
+        if excess <= 0:
+            return
+
+        # Fire from the list (FIFO: First in, First Fired - mimicking simplistic approach)
+        # Actually usually LIFO (Last In First Out) is better to keep experienced, but here experience is not tracked per se?
+        # HRDepartment stores list. employees[0] is oldest?
+        # Let's fire the most recently hired (end of list) or just pick.
+        # CorporateManager fires candidates = firm.hr.employees[:fire_count] (Oldest?).
+        # Let's mimic CorporateManager for consistency.
+        candidates = firm.hr.employees[:excess]
+
+        severance_weeks = getattr(self.config_module, "SEVERANCE_PAY_WEEKS", 4)
+        min_wage = getattr(self.config_module, "LABOR_MARKET_MIN_WAGE", 5.0) # Fallback
+
+        for emp in list(candidates): # Copy list to iterate safely
+            # Calculate severance
+            # Need current wage.
+            wage = firm.hr.employee_wages.get(emp.id, min_wage)
+            # Correct for skill
+            skill = getattr(emp, 'labor_skill', 1.0)
+            wage *= skill
+
+            severance_pay = wage * severance_weeks
+
+            # Pay and Quit
+            if firm.finance.pay_severance(emp, severance_pay):
+                emp.quit()
+                firm.hr.remove_employee(emp)
+
+                self.logger.info(
+                    f"RuleBased Firing: Firm {firm.id} fired Agent {emp.id}. Severance: {severance_pay:.2f}",
+                    extra={"tick": 0, "agent_id": firm.id, "tags": ["firing"]}
+                )
+            else:
+                # Can't afford severance.
+                # In CorporateManager, we abort.
+                # Here, we also abort to avoid illegal firing.
+                self.logger.warning(
+                    f"RuleBased Firing Aborted: Firm {firm.id} cannot afford severance {severance_pay:.2f} for Agent {emp.id}.",
+                    extra={"tick": 0, "agent_id": firm.id, "tags": ["firing_aborted"]}
+                )
diff --git a/simulation/decisions/standalone_rule_based_firm_engine.py b/simulation/decisions/standalone_rule_based_firm_engine.py
index 33064c4..c4aaa25 100644
--- a/simulation/decisions/standalone_rule_based_firm_engine.py
+++ b/simulation/decisions/standalone_rule_based_firm_engine.py
@@ -58,41 +58,71 @@ class StandaloneRuleBasedFirmDecisionEngine(BaseDecisionEngine):
         current_inventory = firm.inventory.get(item_id, 0)
         target_quantity = firm.production_target
 
-        # 1. ìƒì‚° ì¡°ì • ê²°ì •
+        # 1. ìƒì‚° ì¡°ì • ê²°ì • (Planning)
         if current_inventory > target_quantity * self.config_module.OVERSTOCK_THRESHOLD:
             chosen_tactic = Tactic.ADJUST_PRODUCTION
             orders.extend(self.rule_based_executor._adjust_production(firm, current_time))
             self.logger.info(
                 f"Firm {firm.id} RuleBased: Overstocked, adjusting production.",
-                extra={"tick": current_time, "agent_id": firm.id, "tactic": chosen_tactic.name}
+                extra={"tick": current_time, "agent_id": firm.id, "tactic": Tactic.ADJUST_PRODUCTION.name}
             )
         elif current_inventory < target_quantity * self.config_module.UNDERSTOCK_THRESHOLD:
             chosen_tactic = Tactic.ADJUST_PRODUCTION
             orders.extend(self.rule_based_executor._adjust_production(firm, current_time))
             self.logger.info(
                 f"Firm {firm.id} RuleBased: Understocked, adjusting production.",
-                extra={"tick": current_time, "agent_id": firm.id, "tactic": chosen_tactic.name}
+                extra={"tick": current_time, "agent_id": firm.id, "tactic": Tactic.ADJUST_PRODUCTION.name}
             )
 
-        # 2. ìž„ê¸ˆ ì¡°ì • ë° ê³ ìš© ê²°ì • (ìƒì‚° ì¡°ì • ì´í›„ í•„ìš”ì— ë”°ë¼)
-        # í˜„ìž¬ ìƒì‚° ëª©í‘œì™€ ì‹¤ì œ ìƒì‚°ëŸ‰, ê³ ìš© ì¸ì› ë“±ì„ ê³ ë ¤í•˜ì—¬ ìž„ê¸ˆ ë° ê³ ìš© ê²°ì • ë¡œì§ ì¶”ê°€
-        if chosen_tactic != Tactic.ADJUST_PRODUCTION: # ì´ë¯¸ ìƒì‚° ì¡°ì • ê²°ì •ì„ í–ˆìœ¼ë©´ ì´ë²ˆ í„´ì— ìž„ê¸ˆ ì¡°ì •ì€ ê±´ë„ˆë›´ë‹¤ (ê°„ë‹¨í™”ë¥¼ ìœ„í•´)
-            needed_labor_for_production = self.rule_based_executor._calculate_needed_labor(firm)
-            # SoC Refactor: use hr.employees
-            if len(firm.hr.employees) < needed_labor_for_production * self.config_module.FIRM_LABOR_REQUIREMENT_RATIO or \
-               len(firm.hr.employees) < self.config_module.FIRM_MIN_EMPLOYEES:
-                chosen_tactic = Tactic.ADJUST_WAGES # ADJUST_WAGES ì „ìˆ ì— ê³ ìš© ë¡œì§ë„ í¬í•¨ë˜ì–´ ìžˆìŒ
-                orders.extend(self.rule_based_executor._adjust_wages(firm, current_time, market_data))
-                self.logger.info(
-                    f"Firm {firm.id} RuleBased: Need more labor, adjusting wages/hiring.",
-                    extra={"tick": current_time, "agent_id": firm.id, "tactic": chosen_tactic.name}
+        # 2. ìž„ê¸ˆ ì¡°ì • ë° ê³ ìš© ê²°ì • (Operation)
+        # WO-110: Sequential execution - Check labor needs even if production was adjusted
+        needed_labor_for_production = self.rule_based_executor._calculate_needed_labor(firm)
+        current_employees = len(firm.hr.employees)
+
+        # SoC Refactor: use hr.employees
+        # Hiring Logic
+        if current_employees < needed_labor_for_production * self.config_module.FIRM_LABOR_REQUIREMENT_RATIO or \
+           current_employees < self.config_module.FIRM_MIN_EMPLOYEES:
+
+            if chosen_tactic == Tactic.NO_ACTION:
+                chosen_tactic = Tactic.ADJUST_WAGES
+
+            orders.extend(self.rule_based_executor._adjust_wages(firm, current_time, market_data))
+            self.logger.info(
+                f"Firm {firm.id} RuleBased: Need more labor, adjusting wages/hiring.",
+                extra={"tick": current_time, "agent_id": firm.id, "tactic": Tactic.ADJUST_WAGES.name}
+            )
+
+        # Firing Logic (WO-110)
+        # If overstocked (production target reduced), we may have excess labor.
+        firing_buffer_ratio = getattr(self.config_module, "LABOR_FIRING_BUFFER_RATIO", 1.05)
+        if current_employees > needed_labor_for_production * firing_buffer_ratio:
+             # WO-110 Fix: Labor Hoarding to prevent Demand Collapse.
+             # Only fire if we are actually losing money for a sustained period or running low on cash.
+             # If we are profitable or have huge reserves, keep employees to sustain the economy (Demand side).
+             loss_threshold = getattr(self.config_module, "LABOR_HOARDING_LOSS_THRESHOLD", 5)
+             is_bleeding = firm.finance.consecutive_loss_turns > loss_threshold
+
+             startup_cost = getattr(self.config_module, "STARTUP_COST", 30000.0)
+             asset_ratio_threshold = getattr(self.config_module, "LABOR_HOARDING_ASSET_RATIO", 0.5)
+             is_poor = firm.assets < startup_cost * asset_ratio_threshold
+
+             if is_bleeding or is_poor:
+                 # Fire excess
+                 self.rule_based_executor._fire_excess_labor(firm, needed_labor_for_production)
+                 # _fire_excess_labor returns [] orders but performs action.
+                 self.logger.info(
+                    f"Firm {firm.id} RuleBased: Excess labor ({current_employees} > {needed_labor_for_production:.1f}), firing due to financial pressure (LossTicks={firm.finance.consecutive_loss_turns}).",
+                    extra={"tick": current_time, "agent_id": firm.id, "tactic": "FIRING"}
+                )
+             else:
+                 self.logger.info(
+                    f"Firm {firm.id} RuleBased: Excess labor ({current_employees} > {needed_labor_for_production:.1f}), but hoarding labor (LossTicks={firm.finance.consecutive_loss_turns}).",
+                    extra={"tick": current_time, "agent_id": firm.id, "tactic": "HOARDING"}
                 )
 
-        # 3. ê°€ê²© ì¡°ì • ë° íŒë§¤ (ìž¬ê³ ê°€ ìžˆì„ ê²½ìš°)
+        # 3. ê°€ê²© ì¡°ì • ë° íŒë§¤ (Commerce)
         if current_inventory > 0:
-            # FIX: Always allow selling if inventory exists, even if other tactics (Production/Wages) were chosen.
-            # Previously, choosing ADJUST_PRODUCTION prevented selling, causing inventory buildup and 0 sales.
-
             # Decide on price tactic primarily if no other tactic was chosen, but execute selling regardless.
             if chosen_tactic == Tactic.NO_ACTION:
                 # ê°„ë‹¨í•œ ê·œì¹™: ìž¬ê³ ê°€ ë§Žìœ¼ë©´ ê°€ê²©ì„ ë‚®ì¶”ê³ , ì ìœ¼ë©´ ê°€ê²© ìœ ì§€ ë˜ëŠ” ë†’ìž„
@@ -101,26 +131,12 @@ class StandaloneRuleBasedFirmDecisionEngine(BaseDecisionEngine):
                 else:
                     chosen_tactic = Tactic.PRICE_HOLD # ê°€ê²© ìœ ì§€ (ë˜ëŠ” AIì²˜ëŸ¼ ë™ì  ì¡°ì •)
 
-            # RuleBasedFirmDecisionEngineì—ëŠ” ê°€ê²© ì¡°ì • ë©”ì„œë“œê°€ ì—†ìœ¼ë¯€ë¡œ, ì—¬ê¸°ì— ê°„ë‹¨ížˆ êµ¬í˜„í•˜ê±°ë‚˜
-            # _adjust_price_with_aiì™€ ìœ ì‚¬í•œ ë©”ì„œë“œë¥¼ RuleBasedFirmDecisionEngineì— ì¶”ê°€í•˜ëŠ” ê²ƒì„ ê³ ë ¤í•´ì•¼ í•œë‹¤.
-            # í˜„ìž¬ëŠ” AIDrivenFirmDecisionEngineì˜ _adjust_priceë¥¼ ì°¸ì¡°í•˜ì—¬ ìœ ì‚¬í•˜ê²Œ êµ¬í˜„ (ìž¬ê³  ê¸°ë°˜ ê°€ê²© ì¡°ì •)
             orders.extend(self._adjust_price_based_on_inventory(firm, current_time))
             self.logger.info(
                 f"Firm {firm.id} RuleBased: Adjusting price and selling.",
-                extra={"tick": current_time, "agent_id": firm.id, "tactic": chosen_tactic.name}
+                extra={"tick": current_time, "agent_id": firm.id, "tactic": Tactic.ADJUST_PRICE.name}
             )
 
-        # ê¸°ë³¸ ì „ìˆ  ë°˜í™˜ (ë§Œì•½ ì•„ë¬´ê²ƒë„ ì„ íƒë˜ì§€ ì•Šì•˜ë‹¤ë©´ NO_ACTION)
-        if chosen_tactic == Tactic.NO_ACTION:
-            # Fallback for pricing, always attempt to sell if inventory exists.
-            if current_inventory > 0:
-                orders.extend(self._adjust_price_based_on_inventory(firm, current_time))
-                chosen_tactic = Tactic.PRICE_HOLD # Placeholder, as some action was taken
-                self.logger.info(
-                    f"Firm {firm.id} RuleBased: Defaulting to price adjustment/selling.",
-                    extra={"tick": current_time, "agent_id": firm.id, "tactic": chosen_tactic.name}
-                )
-
         return orders, (chosen_tactic, chosen_aggressiveness)
     
     def _adjust_price_based_on_inventory(self, firm: Firm, current_tick: int) -> List[Order]:
