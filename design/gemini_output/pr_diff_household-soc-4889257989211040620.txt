diff --git a/communications/team_assignments.json b/communications/team_assignments.json
index ac2c51d..56f2bae 100644
--- a/communications/team_assignments.json
+++ b/communications/team_assignments.json
@@ -24,10 +24,6 @@
       "12543922642187456551": {
         "title": "TD-045: Firm God Class Refactoring",
         "initial_mission": "REFACTOR `simulation/firms.py` following `design/gemini_output/firm_soc_spec.md`. KEY CONSTRAINTS from Pre-flight Audit: 1. Firm OWNS inventory state. Departments use `firm.add_inventory()` methods only. 2. Execution order: produce -> post_ask -> pay_taxes. TASKS: 1. Create `simulation/components/production_department.py`. 2. Create `simulation/components/sales_department.py`. 3. Firm becomes coordinator using Composition. VERIFY: All existing tests in `tests/test_firms.py` must pass."
-      },
-      "4889257989211040620": {
-        "title": "TD-044: Household God Class Refactoring",
-        "initial_mission": "REFACTOR `simulation/core_agents.py` following `design/gemini_output/household_soc_spec.md`. PATTERN: Same as TD-045 (Firm SoC). KEY CONSTRAINTS: 1. Household OWNS state (assets, inventory). Managers use `household.adjust_assets()` methods. 2. Use Facade pattern - external API unchanged. 3. Execution order: work -> consume -> pay_taxes. TASKS: 1. Create `simulation/components/economy_manager.py`. 2. Create `simulation/components/labor_manager.py`. 3. Household becomes coordinator. VERIFY: All tests in `tests/test_core_agents.py` must pass."
       }
     },
     "completed_sessions": {
diff --git a/simulation/components/economy_manager.py b/simulation/components/economy_manager.py
new file mode 100644
index 0000000..141847e
--- /dev/null
+++ b/simulation/components/economy_manager.py
@@ -0,0 +1,133 @@
+from __future__ import annotations
+from typing import TYPE_CHECKING, Dict
+
+from simulation.dtos import ConsumptionResult
+
+if TYPE_CHECKING:
+    from simulation.core_agents import Household
+
+
+class EconomyManager:
+    """
+    Manages all economic activities for a Household.
+
+    This component handles consumption, saving, tax payments, and inventory
+    valuation, separating these concerns from the core Household agent logic.
+    """
+
+    def __init__(self, household: "Household", config_module: any) -> None:
+        """
+        Initializes the EconomyManager.
+
+        Args:
+            household: The household agent that owns this manager.
+            config_module: The simulation's configuration module.
+        """
+        self._household = household
+        self._config = config_module
+
+    def consume(
+        self, item_id: str, quantity: float, current_time: int
+    ) -> ConsumptionResult:
+        """
+        Consumes a specified quantity of an item from the household's inventory.
+
+        This method contains the logic moved from `Household.consume`.
+
+        Args:
+            item_id: The ID of the item to consume.
+            quantity: The amount of the item to consume.
+            current_time: The current simulation tick.
+
+        Returns:
+            A ConsumptionResult DTO containing the consumed items and satisfaction.
+        """
+        log_extra = {
+            "tick": current_time,
+            "agent_id": self._household.id,
+            "item_id": item_id,
+            "quantity": quantity,
+            "tags": ["household_consumption"],
+        }
+        total_utility = 0.0
+        self._household.logger.debug(
+            f"CONSUME_START | Household {self._household.id} attempting to consume: Item={item_id}, Qty={quantity:.1f}, Inventory={self._household.inventory.get(item_id, 0):.1f}",
+            extra=log_extra,
+        )
+        good_info = self._household.goods_info_map.get(item_id, {})
+        is_service = good_info.get("is_service", False)
+
+        if is_service or self._household.inventory.get(item_id, 0) >= quantity:
+            if not is_service:
+                self._household.modify_inventory(item_id, -quantity)
+
+            # Durable goods logic
+            is_durable = good_info.get("is_durable", False)
+            if is_durable and not is_service:
+                base_lifespan = good_info.get("base_lifespan", 50)
+                quality = self._household.inventory_quality.get(item_id, 1.0)
+                num_assets = int(round(quantity))
+                for _ in range(num_assets):
+                    asset = {
+                        "item_id": item_id,
+                        "quality": quality,
+                        "remaining_life": base_lifespan,
+                    }
+                    self._household.add_durable_asset(asset)
+
+            # Education XP logic
+            if item_id == "education_service":
+                xp_gain = quantity * self._config.LEARNING_EFFICIENCY
+                self._household.add_education_xp(xp_gain)
+
+            self._household.current_consumption += quantity
+
+            if item_id == "food":
+                self._household.current_food_consumption += quantity
+
+            utility_map = good_info.get("utility_effects") or good_info.get(
+                "utility_per_need"
+            )
+            if utility_map:
+                for need_type, utility_value in utility_map.items():
+                    if need_type in self._household.needs:
+                        satisfaction_gain = utility_value * quantity
+                        total_utility += satisfaction_gain
+                        self._household.needs[need_type] = max(
+                            0,
+                            self._household.needs.get(need_type, 0)
+                            - satisfaction_gain,
+                        )
+            return ConsumptionResult(
+                items_consumed={item_id: quantity}, satisfaction=total_utility
+            )
+
+        return ConsumptionResult(items_consumed={}, satisfaction=0)
+
+    def pay_taxes(self) -> None:
+        """
+        Handles the logic for paying taxes.
+        """
+        # In the current simulation, taxes are deducted by the Government agent,
+        # so this is a placeholder for now.
+        pass
+
+    def save(self) -> None:
+        """
+        Handles the logic for saving.
+        """
+        # Saving is currently implicit (income not spent), so this is a placeholder.
+        pass
+
+    def get_inventory_value(self) -> float:
+        """
+        Calculates the total value of the household's inventory based on perceived prices.
+
+        Returns:
+            The total monetary value of the household's inventory.
+        """
+        total_value = 0.0
+        for item_id, quantity in self._household.inventory.items():
+            price = self._household.perceived_avg_prices.get(item_id, 0)
+            total_value += quantity * price
+        return total_value
diff --git a/simulation/components/labor_manager.py b/simulation/components/labor_manager.py
new file mode 100644
index 0000000..d6b817e
--- /dev/null
+++ b/simulation/components/labor_manager.py
@@ -0,0 +1,82 @@
+from __future__ import annotations
+from typing import TYPE_CHECKING
+import math
+
+from simulation.dtos import LaborResult
+
+if TYPE_CHECKING:
+    from simulation.core_agents import Household
+
+
+class LaborManager:
+    """
+    Manages all labor-related activities for a Household.
+
+    This component handles job searching, working, skill updates, and income
+    tracking, separating these concerns from the core Household agent logic.
+    """
+
+    def __init__(self, household: "Household", config_module: any) -> None:
+        """
+        Initializes the LaborManager.
+
+        Args:
+            household: The household agent that owns this manager.
+            config_module: The simulation's configuration module.
+        """
+        self._household = household
+        self._config = config_module
+
+    def work(self, hours: float) -> LaborResult:
+        """
+        Executes work for a given number of hours, earning income.
+
+        Args:
+            hours: The number of hours to work.
+
+        Returns:
+            A LaborResult DTO containing the hours worked and income earned.
+        """
+        if not self._household.is_employed or self._household.employer_id is None:
+            return LaborResult(hours_worked=0, income_earned=0)
+
+        income = self._household.current_wage * hours
+        self._household.adjust_assets(income)
+        self._household.add_labor_income(income)
+        return LaborResult(hours_worked=hours, income_earned=income)
+
+    def search_job(self) -> None:
+        """
+        Handles the logic for searching for a job.
+        This method would be called by the household's decision-making process.
+        """
+        # This is a placeholder for more complex job searching logic.
+        # The actual job searching is handled by the decision engine creating SELL orders for labor.
+        pass
+
+    def update_skills(self) -> None:
+        """
+        Updates the household's labor skill based on education experience.
+        """
+        # XP -> Skill Conversion Formula: Labor Skill = 1.0 + ln(XP + 1) * Talent
+        log_growth = math.log1p(self._household.education_xp)  # ln(x+1)
+        talent_factor = self._household.talent.base_learning_rate
+        new_skill = 1.0 + (log_growth * talent_factor)
+
+        old_skill = self._household.labor_skill
+        self._household.labor_skill = new_skill
+
+        if new_skill > old_skill + 0.1:
+            self._household.logger.debug(
+                f"SKILL_UP | Household {self._household.id} skill improved: {old_skill:.2f} -> {new_skill:.2f} (XP: {self._household.education_xp:.1f})",
+                extra={"tags": ["education", "productivity"]},
+            )
+
+    def get_income(self) -> float:
+        """
+        Gets the total income earned in the current tick.
+
+        Returns:
+            The total income (labor + capital) for the current tick.
+        """
+        return self._household.labor_income_this_tick + self._household.capital_income_this_tick
diff --git a/simulation/core_agents.py b/simulation/core_agents.py
index 41bf90e..8218882 100644
--- a/simulation/core_agents.py
+++ b/simulation/core_agents.py
@@ -29,6 +29,8 @@ from simulation.components.psychology_component import PsychologyComponent
 from simulation.components.leisure_manager import LeisureManager
 from simulation.utils.shadow_logger import log_shadow
 from simulation.components.demographics_component import DemographicsComponent
+from simulation.components.economy_manager import EconomyManager
+from simulation.components.labor_manager import LaborManager
 
 if TYPE_CHECKING:
     from simulation.loan_market import LoanMarket
@@ -202,6 +204,8 @@ class Household(BaseAgent):
         self.psychology = PsychologyComponent(self, personality, config_module)
         self.consumption = ConsumptionBehavior(self, config_module)
         self.leisure = LeisureManager(self, config_module)
+        self.economy_manager = EconomyManager(self, config_module)
+        self.labor_manager = LaborManager(self, config_module)
         self.shares_owned: Dict[int, float] = {}
         self.is_employed: bool = False
         self.labor_skill: float = 1.0
@@ -419,6 +423,44 @@ class Household(BaseAgent):
     def desire_weights(self) -> Dict[str, float]:
         return self.psychology.desire_weights
 
+    @property
+    def income(self) -> float:
+        """Facade property to get income from the LaborManager."""
+        return self.labor_manager.get_income()
+
+    def adjust_assets(self, delta: float) -> None:
+        """
+        Adjusts the household's assets by a given delta.
+
+        Args:
+            delta: The amount to add (positive) or subtract (negative) from assets.
+        """
+        self.assets += delta
+
+    def modify_inventory(self, item_id: str, quantity: float) -> None:
+        """
+        Modifies the household's inventory for a given item.
+
+        Args:
+            item_id: The ID of the item to modify.
+            quantity: The quantity to add (positive) or remove (negative).
+        """
+        if item_id not in self.inventory:
+            self.inventory[item_id] = 0
+        self.inventory[item_id] += quantity
+
+    def add_education_xp(self, xp: float) -> None:
+        """Adds education experience points."""
+        self.education_xp += xp
+
+    def add_durable_asset(self, asset: Dict[str, Any]) -> None:
+        """Adds a durable asset to the household."""
+        self.durable_assets.append(asset)
+
+    def add_labor_income(self, income: float) -> None:
+        """Adds labor income for the current tick."""
+        self.labor_income_this_tick += income
+
     # --- Pass-through Properties ---
     @property
     def age(self) -> float:
@@ -912,160 +954,43 @@ class Household(BaseAgent):
             return self.config_module.HOUSEHOLD_LOW_ASSET_WAGE
         return self.config_module.HOUSEHOLD_DEFAULT_WAGE
 
-    def consume(self, item_id: str, quantity: float, current_time: int) -> None:
-        log_extra = {
-            "tick": current_time,
-            "agent_id": self.id,
-            "item_id": item_id,
-            "quantity": quantity,
-            "tags": ["household_consumption"],
-        }
-        self.logger.debug(
-            f"CONSUME_METHOD_START | Household {self.id} attempting to consume: Item={item_id}, Qty={quantity:.1f}, Inventory={self.inventory.get(item_id, 0):.1f}",
-            extra=log_extra,
-        )
-        good_info = self.goods_info_map.get(item_id, {})
-        is_service = good_info.get("is_service", False)
-
-        if is_service or self.inventory.get(item_id, 0) >= quantity:
-            # Phase 15: Durable Asset Logic
-            is_durable = good_info.get("is_durable", False)
-
-            if is_durable and not is_service:
-                # Durables must be consumed in integer units to function
-                # Relaxed check for float precision (0.9 instead of 1.0)
-                if quantity < 0.9:
-                    self.logger.debug(
-                        f"DURABLE_CONSUME_FAIL | Household {self.id} tried to consume partial {item_id}: {quantity:.2f}. Minimum 1.0 required.",
-                        extra=log_extra
-                    )
-                    return # Do not consume inventory
-
-                # If quantity valid for durable, reduce inventory
-                self.inventory[item_id] -= quantity
-
-                base_lifespan = good_info.get("base_lifespan", 50)
-                # Use stored quality or default
-                quality = self.inventory_quality.get(item_id, 1.0)
-
-                # Create Asset (Round to nearest integer to handle 0.99 -> 1)
-                num_assets = int(round(quantity))
-                for _ in range(num_assets):
-                    asset = {
-                        "item_id": item_id,
-                        "quality": quality,
-                        "remaining_life": base_lifespan
-                    }
-                    self.durable_assets.append(asset)
-                    self.logger.info(
-                        f"DURABLE_ACQUIRED | Household {self.id} installed {item_id}. Quality: {quality:.2f}, Life: {base_lifespan}",
-                         extra={**log_extra, "quality": quality}
-                    )
-
-            elif not is_service:
-                # Standard Consumable
-                self.logger.debug(
-                    f"CONSUME_METHOD_INVENTORY_OK | Household {self.id} has enough {item_id}. Inventory BEFORE: {self.inventory.get(item_id, 0):.1f}. Survival Need BEFORE: {self.needs.get('survival', 0):.1f}",
-                    extra={
-                        **log_extra,
-                        "inventory_before": self.inventory.get(item_id, 0),
-                        "survival_need_before": self.needs.get("survival", 0),
-                    },
-                )
-                self.inventory[item_id] -= quantity
-
-            self.current_consumption += quantity
-
-
-            if item_id == "food":
-                self.current_food_consumption += quantity
-                self.logger.debug(
-                    f"CONSUME_METHOD_FOOD_UPDATE | Household {self.id} consumed food. Current food consumption: {self.current_food_consumption:.1f}. Inventory AFTER: {self.inventory.get(item_id, 0.0):.1f}. Survival Need AFTER: {self.needs.get('survival', 0):.1f}",
-                    extra={
-                        **log_extra,
-                        "current_food_consumption": self.current_food_consumption,
-                        "inventory_after": self.inventory.get(item_id, 0),
-                        "survival_need_after": self.needs.get("survival", 0),
-                    },
-                )
-
-            # Task #6: Gain Education XP
-            if item_id == "education_service":
-                self.education_xp += quantity * self.config_module.LEARNING_EFFICIENCY
-                self.logger.debug(
-                    f"EDUCATION | Household {self.id} gained XP. Total XP: {self.education_xp:.2f}",
-                    extra={**log_extra, "education_xp": self.education_xp}
-                )
-
-            consumed_good = self.goods_info_map.get(item_id)
-            # GEMINI_FIX: Check for "utility_effects" (used in config/decide_and_consume) OR "utility_per_need"
-            utility_map = None
-            if consumed_good:
-                if "utility_effects" in consumed_good:
-                    utility_map = consumed_good["utility_effects"]
-                elif "utility_per_need" in consumed_good:
-                    utility_map = consumed_good["utility_per_need"]
-
-            if utility_map:
-                for need_type, utility_value in utility_map.items():
-                    # Ensure need_type is one of the new needs
-                    if need_type in ["survival", "asset", "social", "improvement"]:
-                        self.needs[need_type] = max(
-                            0, self.needs.get(need_type, 0) - (utility_value * quantity)
-                        )
-                self.logger.debug(
-                    f"CONSUME_METHOD_NEEDS_UPDATE | Household {self.id} consumed {quantity:.1f} of {item_id}. Needs after consumption: Survival={self.needs.get('survival', 0):.1f}, Asset={self.needs.get('asset', 0):.1f}, Social={self.needs.get('social', 0):.1f}, Improvement={self.needs.get('improvement', 0):.1f}",
-                    extra={
-                        **log_extra,
-                        "survival_need": self.needs.get("survival", 0),
-                        "asset_need": self.needs.get("asset", 0),
-                        "social_need": self.needs.get("social", 0),
-                        "improvement_need": self.needs.get("improvement", 0),
-                    },
-
-                )
-            else:
-                self.logger.debug(
-                    f"CONSUME_METHOD_NO_UTILITY | Household {self.id} consumed {item_id} but no utility_per_need defined or needs not updated.",
-                    extra=log_extra,
-                )
-        else:
-            self.logger.debug(
-                f"CONSUME_METHOD_INVENTORY_EMPTY | Household {self.id} tried to consume {item_id} but inventory is empty or insufficient. Inventory: {self.inventory.get(item_id, 0):.1f}, Quantity: {quantity:.1f}",
-                extra=log_extra,
-            )
+    def consume(
+        self, item_id: str, quantity: float, current_time: int
+    ) -> "ConsumptionResult":
+        """Delegates consumption to the EconomyManager."""
+        return self.economy_manager.consume(item_id, quantity, current_time)
 
     @override
     def update_needs(self, current_tick: int, market_data: Optional[Dict[str, Any]] = None):
         """
-        욕구 업데이트를 PsychologyComponent로 위임합니다.
+        Orchestrates the household's tick-level updates in a specific order:
+        1. Work to earn income.
+        2. Consume goods to satisfy needs.
+        3. Pay taxes.
+        4. Update psychological needs.
         """
+        # 1. Work (via LaborManager)
+        # Assuming a fixed 8 hours of work per tick if employed
+        work_hours = 8.0 if self.is_employed else 0.0
+        self.labor_manager.work(work_hours)
+
+        # 2. Consume (via ConsumptionBehavior, which should call EconomyManager)
+        # The existing decide_and_consume already handles this part.
+        # We just need to ensure the orchestration order.
+        # The actual consumption logic is now in EconomyManager,
+        # but the decision to consume is in ConsumptionBehavior.
+        # Let's assume decide_and_consume calls self.consume which is now delegated.
+        self.decide_and_consume(current_tick, market_data)
+
+        # 3. Pay Taxes (via EconomyManager)
+        self.economy_manager.pay_taxes()
+
+        # 4. Update Psychological Needs (existing PsychologyComponent)
         self.psychology.update_needs(current_tick, market_data)
 
     def _update_skill(self):
-        """
-        WO-023-B: Human Capital Growth Formula
-        Labor Skill = 1.0 + ln(XP + 1) * Talent
-        """
-        import math
-        # XP -> Skill Conversion
-        log_growth = math.log1p(self.education_xp)  # ln(x+1)
-        
-        # Talent Multiplier
-        talent_factor = self.talent.base_learning_rate
-        
-        # New Skill Level
-        new_skill = 1.0 + (log_growth * talent_factor)
-        
-        # Update
-        old_skill = self.labor_skill
-        self.labor_skill = new_skill
-        
-        if new_skill > old_skill + 0.1:
-            self.logger.debug(
-                f"SKILL_UP | Household {self.id} skill improved: {old_skill:.2f} -> {new_skill:.2f} (XP: {self.education_xp:.1f})",
-                 extra={"tags": ["education", "productivity"]}
-            )
+        """Delegates skill updates to the LaborManager."""
+        self.labor_manager.update_skills()
 
     @override
     def clone(self, new_id: int, initial_assets_from_parent: float, current_tick: int) -> "Household":
@@ -1081,7 +1006,7 @@ class Household(BaseAgent):
         cloned_household = Household(
             id=new_id,
             talent=self.talent,
-            goods_data=self.goods_data,
+            goods_data=[g for g in self.goods_info_map.values()],
             initial_assets=initial_assets_from_parent,
             initial_needs=self.needs.copy(),
             decision_engine=self._create_new_decision_engine(new_id),
diff --git a/simulation/dtos.py b/simulation/dtos.py
index 01d5816..becba4b 100644
--- a/simulation/dtos.py
+++ b/simulation/dtos.py
@@ -351,3 +351,17 @@ class MacroFinancialContext:
     gdp_growth_rate: float
     market_volatility: float
     interest_rate_trend: float
+
+
+@dataclass
+class LaborResult:
+    """Represents the result of a household's labor activities for a tick."""
+    hours_worked: float
+    income_earned: float
+
+
+@dataclass
+class ConsumptionResult:
+    """Represents the result of a household's consumption activities for a tick."""
+    items_consumed: Dict[str, float]
+    satisfaction: float
diff --git a/tests/test_household_ai.py b/tests/test_household_ai.py
index 9a5b740..270507e 100644
--- a/tests/test_household_ai.py
+++ b/tests/test_household_ai.py
@@ -79,7 +79,6 @@ def test_ai_creates_purchase_order(setup_test_environment, ai_engine_setup):
         personality=Personality.MISER,
         config_module=config,
     )
-    household.decision_engine.markets = markets
 
     market_data = {"time": 1, "goods_data": goods_data}
     orders, _ = household.make_decision(markets, goods_data, market_data, 1)
@@ -125,7 +124,6 @@ def test_ai_evaluates_consumption_options(setup_test_environment, ai_engine_setu
         personality=Personality.STATUS_SEEKER,
         config_module=config,
     )
-    household.decision_engine.markets = markets
 
     market_data = {
         "time": 1,
diff --git a/tests/test_household_decision_engine_new.py b/tests/test_household_decision_engine_new.py
index 5a41612..ab88554 100644
--- a/tests/test_household_decision_engine_new.py
+++ b/tests/test_household_decision_engine_new.py
@@ -79,6 +79,8 @@ def mock_household():
     hh = Mock(spec=Household)
     hh.id = 1
     hh.assets = 100.0
+    hh.economy_manager = Mock()
+    hh.labor_manager = Mock()
     hh.needs = {"survival": 0.8, "leisure": 0.5}
     hh.get_agent_data.return_value = {}
     hh.get_pre_state_data.return_value = {}
