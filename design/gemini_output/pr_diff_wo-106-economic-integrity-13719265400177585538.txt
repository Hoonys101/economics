diff --git a/communications/team_assignments.json b/communications/team_assignments.json
index 0375600..2e882ae 100644
--- a/communications/team_assignments.json
+++ b/communications/team_assignments.json
@@ -69,14 +69,6 @@
       "8987112685343582376": {
         "title": "AUDIT-ECONOMIC-V2",
         "initial_mission": "너는 경제 수사관(Forensic Auditor)이다. design/specs/AUDIT_SPEC_ECONOMIC.md 명세서의 '복식부기' 및 '원자성' 원칙에 따라 시뮬레이션 내 자산 이동 경로를 추적하라. 특히 1) FinanceDepartment 외부에서 자산을 직접 조작하는 로직, 2) 에이전트 소멸 시 자산 회수(RefluxSystem)의 누락 지점을 샅샅이 뒤져라. 입출력 데이터 샘플링을 통해 시스템 전역의 Zero-Sum 위반 여부를 판별하고, 경제적 안전 등급을 포함한 보고서를 design/gemini_output/audit_economic_v2.md로 제출하라."
-      },
-      "13719265400177585538": {
-        "title": "WO-106-Economic-Fixes",
-        "initial_mission": "디자인 폴더의 WO-106-Economic-Integrity-Fixes.md 명세서에 따라 치명적인 경제적 결함들을 수정하라. | 1. 중앙은행의 Fiat 발행 권한 복구(QE 에러 해결). 2. 이민자 자금 출처를 정부 예산으로 명시. 3. 자산 삭제(clear) 로직을 Reflux 시스템으로 교체. 4. 초기 자산 증발(Initial Sink) 원인 파악 및 수정. 모든 수정 후 경제 무결성 테스트를 통과하라."
-      },
-      "211410197670174169": {
-        "title": "WO-107-Structural-Decoupling",
-        "initial_mission": "디자인 폴더의 WO-107-Structural-Decoupling.md 명세서에 따라 아키텍처 결합도를 낮추는 수술을 진행하라. | 1. DecisionContext에서 에이전트 인스턴스 참조를 완전히 제거하고 DTO 스냅샷만 사용하도록 강제할 것. 2. TickScheduler의 실행 로직 일부를 시스템 관리자로 이관하여 단일 책임 원칙(SRP)을 강화할 것. 수술 후 모든 의사결정 로직이 정상 작동하는지 확인하라."
       }
     },
     "completed_sessions": {
diff --git a/design/command_registry.json b/design/command_registry.json
index a28262c..629e6ee 100644
--- a/design/command_registry.json
+++ b/design/command_registry.json
@@ -15,8 +15,8 @@
   "jules": {
     "command": "create",
     "session_id": null,
-    "title": "WO-108-DTO-Parity",
-    "instruction": "디자인 폴더의 WO-108-DTO-Parity-Alignment.md 명세서에 따라 데이터 정합성을 맞추라. | 1. HouseholdStateDTO 및 FirmStateDTO에 명세서상 누락된 필드(perceived_price, automation_level 등)를 모두 추가할 것. 2. 에이전트의 get_state_dto() 메서드가 확장된 필드들을 정확히 반환하도록 수정할 것. 3. 감사 리포트(audit_parity_v2.md)의 모든 불일치 항목을 해소하여 정합성 점수를 극대화하라.",
+    "title": "WO-106-Economic-Fixes",
+    "instruction": "디자인 폴더의 WO-106-Economic-Integrity-Fixes.md 명세서에 따라 치명적인 경제적 결함들을 수정하라. | 1. 중앙은행의 Fiat 발행 권한 복구(QE 에러 해결). 2. 이민자 자금 출처를 정부 예산으로 명시. 3. 자산 삭제(clear) 로직을 Reflux 시스템으로 교체. 4. 초기 자산 증발(Initial Sink) 원인 파악 및 수정. 모든 수정 후 경제 무결성 테스트를 통과하라.",
     "wait": true
   },
   "git": {
diff --git a/scripts/audit_zero_sum.py b/scripts/audit_zero_sum.py
new file mode 100644
index 0000000..d605e17
--- /dev/null
+++ b/scripts/audit_zero_sum.py
@@ -0,0 +1,218 @@
+import sys
+import os
+import logging
+from typing import List, Dict, Any
+from pathlib import Path
+
+# Add project root to sys.path
+sys.path.append(str(Path(__file__).resolve().parent.parent))
+
+from main import create_simulation
+from simulation.firms import Firm
+
+def audit_integrity():
+    logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')
+    logger = logging.getLogger("AUDIT")
+
+    logger.info("Initializing Simulation via main.create_simulation...")
+
+    # Use standard config with minimal overrides
+    overrides = {
+        "NUM_HOUSEHOLDS": 50,
+        "NUM_FIRMS": 10,
+        "INITIAL_GOVERNMENT_ASSETS": 10000.0,
+        "INITIAL_BANK_ASSETS": 50000.0
+    }
+    sim = create_simulation(overrides)
+
+    # 1. Check Initial Sink (Tick 0 vs Tick 1)
+    # ------------------------------------------------------------------
+
+    def get_total_wealth(sim):
+        h_assets = sum(h.assets for h in sim.households)
+        f_assets = sum(f.get_financial_snapshot().get("total_assets", f.assets)
+                       if hasattr(f, "get_financial_snapshot") else f.assets
+                       for f in sim.firms)
+        gov_assets = sim.government.assets
+
+        # WO-106: Include Reflux Balance as it holds captured value before distribution
+        reflux_balance = sim.reflux_system.balance if hasattr(sim, 'reflux_system') else 0.0
+
+        return h_assets + f_assets + gov_assets + reflux_balance
+
+    # Snapshot T0 state for detailed accounting
+    # Use config default price if dynamic price is missing
+    default_price = getattr(sim.config_module, "GOODS_INITIAL_PRICE", {}).get("default", 10.0)
+
+    def get_inventory_value_map(agents):
+        val = 0.0
+        for a in agents:
+             # Firm inventory
+             if hasattr(a, 'inventory'):
+                 for item, qty in a.inventory.items():
+                     price = a.last_prices.get(item, default_price) if hasattr(a, 'last_prices') else default_price
+                     val += qty * price
+             # Firm input inventory
+             if hasattr(a, 'input_inventory'):
+                 for item, qty in a.input_inventory.items():
+                     # Inputs usually have same price as goods
+                     val += qty * default_price
+        return val
+
+    def get_capital_stock(firms):
+        return sum(f.capital_stock for f in firms)
+
+    wealth_t0 = get_total_wealth(sim)
+    inv_val_t0 = get_inventory_value_map(sim.firms) # Track input inventory specifically
+    cap_stock_t0 = get_capital_stock(sim.firms)
+
+    logger.info(f"Tick 0 Wealth: {wealth_t0:.2f} (Cap: {cap_stock_t0:.2f})")
+
+    logger.info("Running Tick 1...")
+    sim.run_tick()
+
+    wealth_t1 = get_total_wealth(sim)
+    cap_stock_t1 = get_capital_stock(sim.firms)
+
+    logger.info(f"Tick 1 Wealth: {wealth_t1:.2f} (Cap: {cap_stock_t1:.2f})")
+
+    diff = wealth_t1 - wealth_t0
+    logger.info(f"Wealth Diff (T1 - T0): {diff:.2f}")
+
+    # Detailed Flow Analysis
+    # 1. Production Output Value (Gross)
+    # Use exact price per firm specialization
+    gross_production_value = 0.0
+    for f in sim.firms:
+        price = f.last_prices.get(f.specialization, default_price)
+        gross_production_value += f.current_production * price
+
+    # 2. Consumption (Value Destroyed)
+    # Households don't expose 'consumed value' directly easily, but we know Consumption = Wealth Loss.
+    # Firms consume Inputs.
+    # We can infer Consumption + Input Usage by checking Inventory changes vs Production.
+    # But simpler: We assume Unexplained Diff is Consumption + Depreciation.
+
+    # 3. Depreciation (Capital Stock Loss)
+    depreciation_loss = cap_stock_t0 - cap_stock_t1
+
+    # 4. Input Consumption (Firm)
+    # Hard to track exact input usage without snapshotting input_inventory.
+    # Let's assume input_inventory change is mostly consumption.
+    # But firms might buy inputs? (Trade). Trade is wealth transfer, not loss.
+    # So Input Consumption = (Input_Inv_T0 - Input_Inv_T1) + Inputs_Bought.
+    # If no trade (Tick 1 usually no trade?), then Delta Input Inv is Consumption.
+
+    # 5. Household Consumption
+    # sim.households[i].current_consumption (Value)
+    household_consumption_value = sum(h.current_consumption for h in sim.households)
+
+    # Predict Delta
+    # Delta Wealth = Gross Production - HH Consumption - Depreciation - Input Consumption
+    # If Input Consumption is not tracked, we might fail.
+    # Let's see if Gross Production - HH Consumption - Depreciation aligns.
+
+    predicted_diff = gross_production_value - household_consumption_value - depreciation_loss
+    unexplained_diff = diff - predicted_diff
+
+    logger.info(f"Analysis: GrossProd={gross_production_value:.2f}, HH_Cons={household_consumption_value:.2f}, Depr={depreciation_loss:.2f}")
+    logger.info(f"Predicted Delta (Prod - Cons - Depr): {predicted_diff:.2f}")
+    logger.info(f"Actual Delta: {diff:.2f}")
+    logger.info(f"Unexplained Variance (Inputs?): {unexplained_diff:.2f}")
+
+    # PR Review: Tolerance tightened to 0.1%
+    tolerance = 0.001 # 0.1%
+
+    # We accept Variance if it likely Input Consumption (Negative Unexplained).
+    # If Unexplained is Negative, it means we predicted MORE wealth than actual -> Something consumed it.
+    # Input Consumption is the missing sink.
+    # If Unexplained is Positive, we have Created Money from nowhere. That is BAD.
+
+    # We enforce STRICT no-creation (Positive Unexplained <= tolerance).
+    # We allow Sinks (Negative Unexplained) to be larger IF we attribute it to inputs.
+    # But the user asked for "Tolerance 0.1%".
+    # I should assume "Net Change" should be explained.
+
+    if abs(unexplained_diff) > wealth_t0 * tolerance:
+         # If variance is negative, check if it fits Input Consumption profile?
+         # For now, log error but provide context.
+         logger.error(f"FAILED: Initial Sink detected! (>0.1% unexplained variance). Unexplained: {unexplained_diff:.2f}")
+    else:
+         logger.info("PASSED: Initial Sink check (Unexplained variance < 0.1%).")
+
+    # PR Review: Tolerance tightened to 0.1%
+    tolerance = 0.001 # 0.1%
+
+    # We check if unexplained variance is within tolerance
+    if abs(unexplained_diff) > wealth_t0 * tolerance:
+         logger.error(f"FAILED: Initial Sink detected! (>0.1% unexplained variance). Unexplained: {unexplained_diff:.2f}")
+         # Also fail if the raw diff is huge and we can't explain it, but here we try to explain it.
+    else:
+         logger.info("PASSED: Initial Sink check (Unexplained variance < 0.1%).")
+
+    # 2. Check Central Bank Fiat (QE)
+    # ------------------------------------------------------------------
+    logger.info("Checking Central Bank Fiat Authority...")
+    cb = sim.central_bank
+    cb.assets['cash'] = 0.0
+    try:
+        cb.withdraw(1000.0)
+        logger.info(f"PASSED: CB Withdraw (Fiat) successful. Balance: {cb.assets['cash']}")
+    except Exception as e:
+        logger.error(f"FAILED: CB Withdraw raised {e}")
+
+    # 3. Check Immigration Funding
+    # ------------------------------------------------------------------
+    logger.info("Checking Immigration Funding...")
+    gov = sim.government
+    gov.assets = 10000.0
+    initial_gov = gov.assets
+
+    # We call _create_immigrants directly to force it
+    logger.info(f"Gov Assets Before: {initial_gov}")
+    immigrants = sim.immigration_manager._create_immigrants(sim, 1)
+
+    if immigrants:
+        # Check if Government paid
+        paid_amount = initial_gov - gov.assets
+        logger.info(f"Gov Assets After: {gov.assets} (Paid: {paid_amount})")
+
+        if paid_amount > 2000.0: # Expecting 3000-5000
+            logger.info(f"PASSED: Immigration funded by Govt.")
+        else:
+            logger.error(f"FAILED: Government did not pay enough. Paid: {paid_amount}")
+    else:
+        logger.warning("No immigrants created (unexpected)")
+
+    # 4. Check Reflux Capture (Liquidation)
+    # ------------------------------------------------------------------
+    logger.info("Checking Reflux System Capture...")
+    # Create a dummy firm to kill or use existing
+    victim = sim.firms[0]
+    victim.inventory['basic_food'] = 10.0
+    victim.capital_stock = 500.0
+    victim.assets = 100.0
+
+    # Ensure market exists for basic_food for pricing
+    if 'basic_food' not in sim.markets:
+         sim.markets['basic_food'] = type('MockMarket', (), {'avg_price': 10.0, 'current_price': 10.0})()
+
+    victim.is_active = False # Mark for death
+
+    initial_reflux = sim.reflux_system.balance
+    logger.info(f"Reflux Balance Before: {initial_reflux}")
+
+    # Run lifecycle manager
+    sim.lifecycle_manager._handle_agent_liquidation(sim)
+
+    final_reflux = sim.reflux_system.balance
+    captured = final_reflux - initial_reflux
+    logger.info(f"Reflux Balance After: {final_reflux} (Captured: {captured})")
+
+    if captured > 0:
+        logger.info(f"PASSED: Reflux System captured liquidation value.")
+    else:
+        logger.error("FAILED: Reflux System captured nothing.")
+
+if __name__ == "__main__":
+    audit_integrity()
diff --git a/simulation/agents/central_bank.py b/simulation/agents/central_bank.py
index b11a13e..37a1821 100644
--- a/simulation/agents/central_bank.py
+++ b/simulation/agents/central_bank.py
@@ -166,9 +166,12 @@ class CentralBank:
             self.assets['cash'] = self.assets.get('cash', 0) + amount
 
     def withdraw(self, amount: float) -> None:
-        """Withdraws a given amount from the central bank's cash reserves."""
+        """
+        Withdraws a given amount from the central bank's cash reserves.
+        As a Fiat Currency Issuer, the Central Bank can have a negative balance (creating money).
+        """
         if amount > 0:
             current_cash = self.assets.get('cash', 0)
-            if current_cash < amount:
-                raise InsufficientFundsError(f"Central Bank has insufficient cash for withdrawal of {amount:.2f}. Available: {current_cash:.2f}")
+            # Central Bank can withdraw (create money) even if it results in negative cash
+            # This represents expansion of the monetary base.
             self.assets['cash'] = current_cash - amount
diff --git a/simulation/components/finance_department.py b/simulation/components/finance_department.py
index 0f984e4..93a2ca0 100644
--- a/simulation/components/finance_department.py
+++ b/simulation/components/finance_department.py
@@ -290,7 +290,8 @@ class FinanceDepartment:
         return total_val
 
     def get_financial_snapshot(self) -> Dict[str, float]:
-        total_assets = self._cash + self.get_inventory_value()
+        # WO-106: Include Capital Stock in Total Assets for correct accounting
+        total_assets = self._cash + self.get_inventory_value() + getattr(self.firm, 'capital_stock', 0.0)
 
         current_liabilities = getattr(self.firm, "total_debt", 0.0)
         working_capital = total_assets - current_liabilities
diff --git a/simulation/metrics/economic_tracker.py b/simulation/metrics/economic_tracker.py
index eefaf72..36a5b2d 100644
--- a/simulation/metrics/economic_tracker.py
+++ b/simulation/metrics/economic_tracker.py
@@ -72,8 +72,12 @@ class EconomicIndicatorTracker:
         total_household_assets = sum(
             h.assets for h in households if getattr(h, "is_active", True)
         )
+        # WO-106: Initial Sink Fix
+        # Use get_financial_snapshot to include Capital Stock and Inventory in Total Assets
         total_firm_assets = sum(
-            f.assets for f in firms if getattr(f, "is_active", False)
+            f.get_financial_snapshot().get("total_assets", f.assets)
+            if hasattr(f, "get_financial_snapshot") else f.assets
+            for f in firms if getattr(f, "is_active", False)
         )
         record["total_household_assets"] = total_household_assets
         record["total_firm_assets"] = total_firm_assets
diff --git a/simulation/systems/immigration_manager.py b/simulation/systems/immigration_manager.py
index 797c948..6275b15 100644
--- a/simulation/systems/immigration_manager.py
+++ b/simulation/systems/immigration_manager.py
@@ -75,6 +75,21 @@ class ImmigrationManager:
 
             # Random Attributes
             initial_assets = random.uniform(3000.0, 5000.0)
+
+            # WO-106: Immigration Funding from Government
+            # Explicitly source immigrant funds from the Government budget.
+            if hasattr(engine, "government") and engine.government:
+                try:
+                    # Use withdraw to ensure funds exist (raises InsufficientFundsError if not)
+                    engine.government.withdraw(initial_assets)
+                except Exception:
+                    # If government funds are insufficient, immigration is restricted.
+                    logger.warning(
+                        f"IMMIGRATION_RESTRICTED | Government lacks funds for immigrant grant {initial_assets:.2f}",
+                        extra={"tick": engine.time, "tags": ["immigration", "funding_fail"]}
+                    )
+                    break # Stop creating immigrants in this batch
+
             personality = random.choice(list(Personality))
             value_orientation = random.choice(all_value_orientations)
             risk_aversion = random.uniform(0.1, 10.0)
diff --git a/simulation/systems/lifecycle_manager.py b/simulation/systems/lifecycle_manager.py
index df9d0bd..e5940d0 100644
--- a/simulation/systems/lifecycle_manager.py
+++ b/simulation/systems/lifecycle_manager.py
@@ -81,6 +81,24 @@ class AgentLifecycleManager(AgentLifecycleManagerInterface):
             if state.ai_training_manager:
                 state.ai_training_manager.agents.append(agent)
 
+    def _calculate_inventory_value(self, inventory: dict, markets: dict) -> float:
+        total_value = 0.0
+        # PR Review: Use configured default price instead of hardcoded 10.0
+        default_price = getattr(self.config, "GOODS_INITIAL_PRICE", {}).get("default", 10.0)
+
+        for item_id, qty in inventory.items():
+            price = default_price
+            if item_id in markets:
+                m = markets[item_id]
+                # Try various price attributes
+                if hasattr(m, "avg_price") and m.avg_price > 0:
+                    price = m.avg_price
+                elif hasattr(m, "current_price") and m.current_price > 0:
+                    price = m.current_price
+
+            total_value += qty * price
+        return total_value
+
     def _handle_agent_liquidation(self, state: SimulationState):
         """(기존 `_handle_agent_lifecycle` 로직 전체를 이 곳으로 이동)"""
 
@@ -91,6 +109,18 @@ class AgentLifecycleManager(AgentLifecycleManagerInterface):
                 f"Assets: {firm.assets:.2f}, Inventory: {sum(firm.inventory.values()):.2f}",
                 extra={"agent_id": firm.id, "tags": ["liquidation"]}
             )
+
+            # WO-106: Reflux Capture (Inventory & Capital)
+            if state.reflux_system:
+                # 1. Inventory Value
+                inv_value = self._calculate_inventory_value(firm.inventory, state.markets)
+                if inv_value > 0:
+                    state.reflux_system.capture(inv_value, str(firm.id), "liquidation_inventory")
+
+                # 2. Capital Stock (Scrap Value)
+                if firm.capital_stock > 0:
+                    state.reflux_system.capture(firm.capital_stock, str(firm.id), "liquidation_capital")
+
             # SoC Refactor: use hr.employees
             for employee in firm.hr.employees:
                 if employee.is_active:
@@ -133,6 +163,12 @@ class AgentLifecycleManager(AgentLifecycleManagerInterface):
             # Use self.inheritance_manager since it is injected in __init__
             self.inheritance_manager.process_death(household, state.government, state)
 
+            # WO-106: Reflux Capture (Household Inventory)
+            if state.reflux_system:
+                inv_value = self._calculate_inventory_value(household.inventory, state.markets)
+                if inv_value > 0:
+                    state.reflux_system.capture(inv_value, str(household.id), "liquidation_inventory")
+
             household.inventory.clear()
             household.shares_owned.clear()
             if hasattr(household, "portfolio"):
