diff --git a/insights/mass_liquidation_risk_report.md b/insights/mass_liquidation_risk_report.md
new file mode 100644
index 0000000..d1e8d35
--- /dev/null
+++ b/insights/mass_liquidation_risk_report.md
@@ -0,0 +1,29 @@
+# Mass Liquidation Risk Report
+
+## Introduction
+
+The introduction of a sovereign debt market and the transition from grants to interest-bearing bailout loans fundamentally changes the economic simulation. While these changes are designed to create a more realistic and responsible economic model, they also introduce new systemic risks. This report outlines the potential for mass liquidation events and the cascading failures that could result.
+
+## Key Risk Factors
+
+1.  **Zombie Firm Collapse:** The implementation of the Altman Z-Score will correctly identify and lead to the liquidation of "zombie firms" that are no longer financially viable. However, a sudden, simultaneous collapse of multiple zombie firms could trigger a deflationary spiral.
+
+2.  **Credit Crunch:** As the government issues bonds to finance its spending, it will compete with the private sector for a limited pool of capital. This "crowding out" effect will drive up interest rates, making it more expensive for firms to borrow and invest. A severe credit crunch could stifle economic growth and lead to a wave of bankruptcies.
+
+3.  **Sovereign Debt Crisis:** If the government's debt-to-GDP ratio rises to unsustainable levels, investor confidence could collapse, leading to a spike in bond yields. A sovereign debt crisis would force the government to implement austerity measures, further depressing the economy and potentially leading to a "doom loop" of rising debt and falling growth.
+
+## Potential Cascading Failures
+
+*   **Bank Insolvency:** A wave of corporate bankruptcies could lead to a surge in non-performing loans, threatening the solvency of the banking system.
+*   **Mass Unemployment:** The liquidation of firms will lead to job losses, reducing aggregate demand and further depressing the economy.
+*   **Deflationary Spiral:** Falling prices and wages could increase the real burden of debt, leading to a vicious cycle of defaults, bankruptcies, and economic contraction.
+
+## Mitigation Strategies
+
+*   **Central Bank Intervention:** The Central Bank can act as a lender of last resort, providing liquidity to the banking system and purchasing government bonds to keep interest rates low.
+*   **Counter-cyclical Fiscal Policy:** The government can use fiscal stimulus to support the economy during a downturn, but this must be balanced against the risk of a sovereign debt crisis.
+*   **Orderly Liquidation:** Mechanisms could be put in place to ensure the orderly liquidation of failed firms, preventing a fire sale of assets that could depress prices and trigger a wider panic.
+
+## Conclusion
+
+The new economic model is more realistic, but it is also more fragile. The risk of mass liquidation events is real and should be carefully monitored. A combination of prudent fiscal policy, proactive central banking, and robust financial regulation will be needed to mitigate these risks and ensure the long-term stability of the simulated economy.
diff --git a/modules/finance/api.py b/modules/finance/api.py
new file mode 100644
index 0000000..34eae27
--- /dev/null
+++ b/modules/finance/api.py
@@ -0,0 +1,34 @@
+from typing import Protocol, Dict, List
+from dataclasses import dataclass
+
+@dataclass
+class BondDTO:
+    """Data Transfer Object for government bonds."""
+    id: str
+    issuer: str
+    face_value: float
+    yield_rate: float
+    maturity_date: int
+
+@dataclass
+class BailoutLoanDTO:
+    """Data Transfer Object for corporate bailout loans."""
+    firm_id: int
+    amount: float
+    interest_rate: float
+    covenants: Dict[str, bool]
+
+class IFinanceSystem(Protocol):
+    """Interface for the sovereign debt and corporate bailout system."""
+
+    def evaluate_solvency(self, firm: 'Firm', current_tick: int) -> bool:
+        """Evaluates a firm's solvency to determine bailout eligibility."""
+        ...
+
+    def issue_treasury_bonds(self, amount: float) -> List[BondDTO]:
+        """Issues new treasury bonds to the market."""
+        ...
+
+    def service_debt(self) -> None:
+        """Manages the servicing of outstanding government debt."""
+        ...
diff --git a/modules/finance/system.py b/modules/finance/system.py
new file mode 100644
index 0000000..73b866e
--- /dev/null
+++ b/modules/finance/system.py
@@ -0,0 +1,97 @@
+from typing import List, Dict
+from modules.finance.api import IFinanceSystem, BondDTO, BailoutLoanDTO
+# Forward reference for type hinting
+from simulation.firms import Firm
+
+class FinanceSystem(IFinanceSystem):
+    """Manages sovereign debt, corporate bailouts, and solvency checks."""
+
+    def __init__(self, government: 'Government', central_bank: 'CentralBank', config_module: any):
+        self.government = government
+        self.central_bank = central_bank
+        self.config_module = config_module
+        self.outstanding_bonds: List[BondDTO] = []
+
+    def evaluate_solvency(self, firm: 'Firm', current_tick: int) -> bool:
+        """
+        Evaluates a firm's solvency to determine bailout eligibility.
+        - Startups (< 24 ticks old) are checked for a 3-month wage runway.
+        - Established firms are evaluated using the Altman Z-Score.
+        """
+        startup_grace_period = getattr(self.config_module, "STARTUP_GRACE_PERIOD_TICKS", 24)
+        z_score_threshold = getattr(self.config_module, "ALTMAN_Z_SCORE_THRESHOLD", 1.81)
+
+        if firm.age < startup_grace_period:
+            # Runway Check for startups
+            monthly_wage_bill = firm.hr.get_total_wage_bill() * 4  # Approximate monthly
+            required_runway = monthly_wage_bill * 3
+            return firm.assets >= required_runway
+        else:
+            # Altman Z-Score for established firms
+            z_score = firm.finance.calculate_altman_z_score()
+            return z_score > z_score_threshold
+
+    def issue_treasury_bonds(self, amount: float, current_tick: int) -> List[BondDTO]:
+        """
+        Issues new treasury bonds to the market.
+        Yield is determined by the base rate plus a risk premium based on Debt-to-GDP ratio.
+        """
+        # This is a simplified auction. A real implementation would involve market participants.
+        base_rate = self.central_bank.get_interest_rate()
+        debt_to_gdp = self.government.get_debt_to_gdp_ratio()
+
+        # Exponential risk premium
+        risk_premium = 0.0
+        if debt_to_gdp > 1.2:
+            risk_premium = 0.05
+        elif debt_to_gdp > 0.9:
+            risk_premium = 0.02
+        elif debt_to_gdp > 0.6:
+            risk_premium = 0.005
+
+        yield_rate = base_rate + risk_premium
+
+        # For now, assume the central bank buys all bonds as the buyer of last resort
+        new_bond = BondDTO(
+            id=f"BOND_{current_tick}",
+            issuer="GOVERNMENT",
+            face_value=amount,
+            yield_rate=yield_rate,
+            maturity_date=current_tick + getattr(self.config_module, "BOND_MATURITY_TICKS", 400) # 4 years
+        )
+        self.outstanding_bonds.append(new_bond)
+        self.central_bank.purchase_bonds(new_bond)
+        self.government.assets += amount
+
+        return [new_bond]
+
+    def grant_bailout_loan(self, firm: 'Firm', amount: float) -> BailoutLoanDTO:
+        """Converts a bailout from a grant to an interest-bearing senior loan."""
+        base_rate = self.central_bank.get_interest_rate()
+        penalty_premium = getattr(self.config_module, "BAILOUT_PENALTY_PREMIUM", 0.05)
+
+        loan = BailoutLoanDTO(
+            firm_id=firm.id,
+            amount=amount,
+            interest_rate=base_rate + penalty_premium,
+            covenants={
+                "dividends_allowed": False,
+                "executive_salary_freeze": True
+            }
+        )
+
+        # The government provides the funds, which become a liability for the firm
+        self.government.assets -= amount
+        firm.finance.add_liability(amount, loan.interest_rate)
+
+        return loan
+
+
+    def service_debt(self, current_tick: int) -> None:
+        """Manages the servicing of outstanding government debt."""
+        # This is a simplified version. A real implementation would handle interest payments
+        # and bond maturation.
+        matured_bonds = [b for b in self.outstanding_bonds if b.maturity_date <= current_tick]
+        for bond in matured_bonds:
+            self.government.assets -= bond.face_value
+            self.outstanding_bonds.remove(bond)
diff --git a/simulation/agents/central_bank.py b/simulation/agents/central_bank.py
index a35ed64..c94968a 100644
--- a/simulation/agents/central_bank.py
+++ b/simulation/agents/central_bank.py
@@ -32,6 +32,12 @@ class CentralBank:
             extra={"tick": 0, "tags": ["central_bank", "init"]}
         )
 
+    def purchase_bonds(self, bond: Any) -> None:
+        """Purchases government bonds, effectively performing QE."""
+        # In a real model, this would add to the CB's balance sheet.
+        # For now, this is a placeholder to complete the transaction loop.
+        logger.info(f"CENTRAL_BANK_QE | Purchased bond {bond.id} for {bond.face_value:.2f}")
+
     def get_base_rate(self) -> float:
         return self.base_rate
 
diff --git a/simulation/agents/government.py b/simulation/agents/government.py
index 1d53d8c..684a1cd 100644
--- a/simulation/agents/government.py
+++ b/simulation/agents/government.py
@@ -102,6 +102,7 @@ class Government:
 
         # WO-057-B: Sensory Data Container
         self.sensory_data: Optional[GovernmentStateDTO] = None
+        self.finance_system = None
 
         logger.info(
             f"Government {self.id} initialized with assets: {self.assets}",
@@ -264,62 +265,40 @@ class Government:
             details=f"Inf={inflation:.2%}, Growth={real_gdp_growth:.2%}, Gap={gdp_gap:.2%}, RateGap={gap:.4f}"
         )
 
-    def provide_subsidy(self, target_agent: Any, amount: float, current_tick: int):
-        """
-        보조금을 지급합니다.
-        AI Spending Multiplier 적용.
-        """
-        # Apply Multiplier based on Target
-        effective_amount = amount
-        agent_type = "household"
-        if hasattr(target_agent, "employees"): # Duck typing Firm
-            effective_amount *= self.firm_subsidy_budget_multiplier
-            agent_type = "firm"
-        else:
-            effective_amount *= self.welfare_budget_multiplier
+    def provide_household_support(self, household: Any, amount: float, current_tick: int):
+        """Provides subsidies to households (e.g., unemployment, stimulus)."""
+        effective_amount = amount * self.welfare_budget_multiplier
 
         if effective_amount <= 0:
             return 0.0
 
-        if not getattr(self.config_module, "DEFICIT_SPENDING_ENABLED", False):
-            if self.assets < effective_amount:
-                return 0.0
-        else:
-            # WO-057-Active: Debt Ceiling Logic
-            if self.sensory_data and self.sensory_data.current_gdp > 0:
-                limit_ratio = getattr(self.config_module, "DEFICIT_SPENDING_LIMIT_RATIO", 0.3)
-                debt_limit = self.sensory_data.current_gdp * limit_ratio
-
-                projected_assets = self.assets - effective_amount
-
-                if abs(projected_assets) > debt_limit and projected_assets < 0:
-                    logger.warning(
-                        f"FISCAL_CLIFF_REACHED | Spending blocked. Debt {abs(self.assets):.2f} vs Limit {debt_limit:.2f}",
-                        extra={"tick": current_tick, "agent_id": self.id, "tags": ["fiscal_cliff", "deficit"]}
-                    )
-                    return 0.0
+        if self.assets < effective_amount:
+            needed = effective_amount - self.assets
+            self.finance_system.issue_treasury_bonds(needed, current_tick)
 
         self.assets -= effective_amount
         self.total_spent_subsidies += effective_amount
         self.expenditure_this_tick += effective_amount
-
-        self.total_money_issued += effective_amount
-
-        target_agent.assets += effective_amount
+        household.assets += effective_amount
         self.current_tick_stats["welfare_spending"] += effective_amount
 
         logger.info(
-            f"SUBSIDY_PAID | Paid {effective_amount:.2f} subsidy to {target_agent.id} ({agent_type})",
-            extra={
-                "tick": current_tick,
-                "agent_id": self.id,
-                "amount": effective_amount,
-                "target_id": target_agent.id,
-                "tags": ["subsidy", "expenditure"]
-            }
+            f"HOUSEHOLD_SUPPORT | Paid {effective_amount:.2f} to {household.id}",
+            extra={"tick": current_tick, "agent_id": self.id, "amount": effective_amount, "target_id": household.id}
         )
         return effective_amount
 
+    def provide_firm_bailout(self, firm: Any, amount: float, current_tick: int):
+        """Provides a bailout loan to a firm if it's eligible."""
+        if self.finance_system.evaluate_solvency(firm, current_tick):
+            logger.info(f"BAILOUT_APPROVED | Firm {firm.id} is eligible for a bailout.")
+            loan = self.finance_system.grant_bailout_loan(firm, amount)
+            self.expenditure_this_tick += amount
+            return loan
+        else:
+            logger.warning(f"BAILOUT_DENIED | Firm {firm.id} is insolvent and not eligible for a bailout.")
+            return None
+
     def get_survival_cost(self, market_data: Dict[str, Any]) -> float:
         """ Calculates current survival cost based on food prices. """
         avg_food_price = 0.0
@@ -398,8 +377,7 @@ class Government:
 
                 # B. Unemployment Benefit
                 if not agent.is_employed:
-                    # provide_subsidy now applies welfare_budget_multiplier
-                    self.provide_subsidy(agent, benefit_amount, current_tick)
+                    self.provide_household_support(agent, benefit_amount, current_tick)
                     total_welfare_paid += benefit_amount
 
         # 3. Stimulus Check (Legacy Logic, now influenced by AI multiplier)
@@ -445,23 +423,11 @@ class Government:
         if self.firm_subsidy_budget_multiplier < 0.8:
             return False
 
-        # WO-057-Active CRITICAL FIX: Apply Debt Ceiling to Infrastructure
-        if getattr(self.config_module, "DEFICIT_SPENDING_ENABLED", False):
-            if self.sensory_data and self.sensory_data.current_gdp > 0:
-                limit_ratio = getattr(self.config_module, "DEFICIT_SPENDING_LIMIT_RATIO", 0.3)
-                debt_limit = self.sensory_data.current_gdp * limit_ratio
-                projected_assets = self.assets - effective_cost
-                if abs(projected_assets) > debt_limit and projected_assets < 0:
-                    logger.warning(
-                        f"FISCAL_CLIFF_REACHED | Infrastructure investment blocked. Debt {abs(self.assets):.2f} vs Limit {debt_limit:.2f}",
-                        extra={"tick": current_tick, "agent_id": self.id, "tags": ["fiscal_cliff", "deficit"]}
-                    )
-                    return False
-        elif self.assets < effective_cost:
-            return False # Fallback to old behavior if deficit spending is off
+        if self.assets < effective_cost:
+            needed = effective_cost - self.assets
+            self.finance_system.issue_treasury_bonds(needed, current_tick)
 
         self.assets -= effective_cost
-        self.total_money_issued += effective_cost
         self.expenditure_this_tick += effective_cost
         if reflux_system:
             reflux_system.capture(effective_cost, str(self.id), "infrastructure")
@@ -532,6 +498,14 @@ class Government:
             "perceived_public_opinion": self.perceived_public_opinion
         }
 
+    def get_debt_to_gdp_ratio(self) -> float:
+        """Calculates the debt-to-GDP ratio."""
+        if not self.sensory_data or self.sensory_data.current_gdp == 0:
+            return 0.0
+
+        debt = max(0.0, -self.assets)
+        return debt / self.sensory_data.current_gdp
+
     # WO-054: Public Education System
     def run_public_education(self, agents: List[Any], config_module: Any, current_tick: int, reflux_system: Any = None) -> None:
         """
diff --git a/simulation/bank.py b/simulation/bank.py
index 57d02a0..10bb398 100644
--- a/simulation/bank.py
+++ b/simulation/bank.py
@@ -71,6 +71,10 @@ class Bank:
             extra={"tick": 0, "agent_id": self.id, "tags": ["init", "bank"]},
         )
 
+    def get_interest_rate(self) -> float:
+        """Returns the current base interest rate."""
+        return self.base_rate
+
     def _get_config(self, key: str, default: Any) -> Any:
         return getattr(self.config_module, key, default)
 
diff --git a/simulation/components/finance_department.py b/simulation/components/finance_department.py
index 3320bfd..1ae122d 100644
--- a/simulation/components/finance_department.py
+++ b/simulation/components/finance_department.py
@@ -175,6 +175,43 @@ class FinanceDepartment:
 
         return 0.0
 
+    def add_liability(self, amount: float, interest_rate: float):
+        """Adds a liability (like a loan) to the firm's balance sheet."""
+        # This is a simplified implementation. A real one would track multiple loans.
+        self.firm.assets += amount  # The loan increases cash assets
+        # In a more complex model, this would be a separate liability account
+        # For now, we'll just track the total debt.
+        if not hasattr(self.firm, 'total_debt'):
+            self.firm.total_debt = 0.0
+        self.firm.total_debt += amount
+
+    def calculate_altman_z_score(self) -> float:
+        """
+        Calculates the Altman Z-Score for solvency, simplified for this model.
+        Z = 1.2*X1 + 1.4*X2 + 3.3*X3
+        X1: Working Capital / Total Assets
+        X2: Retained Earnings / Total Assets
+        X3: Average Profit / Total Assets
+        """
+        total_assets = self.firm.assets + self.firm.capital_stock + self.firm.get_inventory_value()
+        if total_assets == 0:
+            return 0.0
+
+        # X1: Working Capital / Total Assets
+        # Working Capital = Current Assets - Current Liabilities. Assume liabilities are total_debt for now.
+        working_capital = self.firm.assets - getattr(self.firm, 'total_debt', 0.0)
+        x1 = working_capital / total_assets
+
+        # X2: Retained Earnings / Total Assets
+        x2 = self.retained_earnings / total_assets
+
+        # X3: Average Profit / Total Assets
+        avg_profit = sum(self.profit_history) / len(self.profit_history) if self.profit_history else 0.0
+        x3 = avg_profit / total_assets
+
+        z_score = 1.2 * x1 + 1.4 * x2 + 3.3 * x3
+        return z_score
+
     def check_bankruptcy(self):
         if self.current_profit < 0:
             self.consecutive_loss_turns += 1
diff --git a/simulation/engine.py b/simulation/engine.py
index 8906d0d..41bd182 100644
--- a/simulation/engine.py
+++ b/simulation/engine.py
@@ -35,6 +35,7 @@ from simulation.systems.generational_wealth_audit import GenerationalWealthAudit
 from simulation.decisions.housing_manager import HousingManager # For rank/tier helper
 from simulation.ai.vectorized_planner import VectorizedHouseholdPlanner
 from simulation.systems.transaction_processor import TransactionProcessor # SoC Refactor
+from modules.finance.system import FinanceSystem
 
 # Use the repository pattern for data access
 from simulation.db.repository import SimulationRepository
@@ -114,6 +115,14 @@ class Simulation:
         # similar to how markets are handled, or we can add it if needed.
         # But it doesn't participate in normal transactions.
 
+        # Finance System (Sovereign Debt)
+        self.finance_system = FinanceSystem(
+            government=self.government,
+            central_bank=self.central_bank,
+            config_module=self.config_module
+        )
+        self.government.finance_system = self.finance_system # Inject into government
+
         # Phase 17-3A: Initialize Real Estate Units
         self.real_estate_units: List[RealEstateUnit] = [
             RealEstateUnit(id=i, estimated_value=self.config_module.INITIAL_PROPERTY_VALUE,
@@ -518,6 +527,13 @@ class Simulation:
         # 4. Election Check
         self.government.check_election(self.time)
 
+        # Age firms
+        for firm in self.firms:
+            firm.age += 1
+
+        # Service national debt
+        self.finance_system.service_debt(self.time)
+
         # Phase 4: Welfare Check (Executes Subsidies based on Policy)
         self.government.run_welfare_check(list(self.agents.values()), market_data, self.time)
 
diff --git a/simulation/firms.py b/simulation/firms.py
index 204b7d4..21ff0c1 100644
--- a/simulation/firms.py
+++ b/simulation/firms.py
@@ -133,6 +133,7 @@ class Firm(BaseAgent):
         self.automation_level: float = 0.0 # 0.0 to 1.0
         self.system2_planner: Optional[FirmSystem2Planner] = None # Initialized later
 
+        self.age = 0
         self.decision_engine.loan_market = loan_market
 
     def init_ipo(self, stock_market: StockMarket):
diff --git a/tests/test_ai_driven_firm_engine.py b/tests/test_ai_driven_firm_engine.py
index c1cc839..b837a96 100644
--- a/tests/test_ai_driven_firm_engine.py
+++ b/tests/test_ai_driven_firm_engine.py
@@ -48,18 +48,30 @@ def mock_firm(mock_config):
     firm.employees = []
     firm.profit_history = []
     firm.productivity_factor = 1.0
+    firm.age = 25 # Add age for solvency checks
+    firm.finance = Mock() # Mock the finance department
     return firm
 
 
 def test_adjust_price_tactic(firm_decision_engine_instance, mock_firm):
     """Test that the ADJUST_PRICE tactic correctly adjusts the price."""
+    from simulation.dtos import DecisionContext
+
     mock_firm.inventory["food"] = 200
     mock_firm.production_target = 100
-    firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
-        Tactic.ADJUST_PRICE
+    firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
+        (Tactic.ADJUST_PRICE, 1.0)
     )
 
-    orders, _ = firm_decision_engine_instance.make_decisions(mock_firm, {}, [], {}, 1)
+    context = DecisionContext(
+        firm=mock_firm,
+        markets={},
+        goods_data=[],
+        market_data={},
+        current_time=1,
+        government=None,
+    )
+    orders, _ = firm_decision_engine_instance.make_decisions(context)
 
     assert len(orders) == 1
     order = orders[0]
diff --git a/tests/test_engine.py b/tests/test_engine.py
index c1d15e5..1276bf0 100644
--- a/tests/test_engine.py
+++ b/tests/test_engine.py
@@ -180,6 +180,7 @@ def mock_firms(mock_config_module):
     f1.is_active = True
     f1.total_shares = 1000.0
     f1.treasury_shares = 0.0
+    f1.age = 25 # Set age for testing
 
     f2 = Firm(
         id=102,
@@ -195,6 +196,7 @@ def mock_firms(mock_config_module):
     f2.is_active = False  # Inactive firm
     f2.total_shares = 1000.0
     f2.treasury_shares = 0.0
+    f2.age = 25 # Set age for testing
     return [f1, f2]
 
 
@@ -256,6 +258,8 @@ def simulation_instance(
         mock_config_module,
         mock_goods_data,
     )
+    sim.government.finance_system = Mock()
+    sim.government.get_debt_to_gdp_ratio = Mock(return_value=0.5)
     return sim
 
 
diff --git a/tests/test_firm_decision_engine_new.py b/tests/test_firm_decision_engine_new.py
index 57f1492..826fe96 100644
--- a/tests/test_firm_decision_engine_new.py
+++ b/tests/test_firm_decision_engine_new.py
@@ -62,8 +62,10 @@ def mock_firm(mock_config):
     firm.cost_this_turn = 0.0
     firm.profit_history = deque(maxlen=mock_config.PROFIT_HISTORY_TICKS)
     firm.specialization = "food"
-    # Add a mock for the logger attribute
     firm.logger = MagicMock()
+    firm.age = 25 # Add age for solvency checks
+    firm.finance = Mock() # Mock the finance department
+    firm.hr = Mock() # Mock the HR department
     return firm
 
 
@@ -93,7 +95,7 @@ class TestFirmDecisionEngine:
     def test_make_decisions_overstock_reduces_target(
         self, firm_decision_engine_instance, mock_firm, mock_config
     ):
-        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
             Tactic.ADJUST_PRODUCTION, Aggressiveness.NORMAL
         )
         mock_firm.inventory["food"] = 150.0 # Force overstock (150 > 100 * 1.2)
@@ -106,6 +108,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
 
@@ -120,7 +123,7 @@ class TestFirmDecisionEngine:
     ):
         mock_firm.inventory["food"] = 50.0
         initial_target = mock_firm.production_target
-        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
             Tactic.ADJUST_PRODUCTION, Aggressiveness.NORMAL
         )
 
@@ -130,6 +133,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
 
@@ -144,7 +148,7 @@ class TestFirmDecisionEngine:
     ):
         mock_firm.inventory["food"] = 100.0
         initial_target = mock_firm.production_target
-        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
             Tactic.ADJUST_PRODUCTION, Aggressiveness.NORMAL
         )
 
@@ -154,6 +158,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
 
@@ -162,7 +167,7 @@ class TestFirmDecisionEngine:
     def test_make_decisions_target_min_max_bounds(
         self, firm_decision_engine_instance, mock_firm, mock_config
     ):
-        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
             Tactic.ADJUST_PRODUCTION, Aggressiveness.NORMAL
         )
         # Test min bound
@@ -174,6 +179,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
         assert mock_firm.production_target == mock_config.FIRM_MIN_PRODUCTION_TARGET
@@ -187,6 +193,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
         assert mock_firm.production_target == mock_config.FIRM_MAX_PRODUCTION_TARGET
@@ -196,7 +203,7 @@ class TestFirmDecisionEngine:
     ):
         mock_firm.employees = []
         mock_firm.inventory["food"] = 0  # Ensure production is needed
-        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
             Tactic.ADJUST_WAGES, Aggressiveness.NORMAL
         )
 
@@ -206,6 +213,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={"avg_wage": 10.0},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
 
@@ -214,7 +222,7 @@ class TestFirmDecisionEngine:
         ]
         assert len(buy_labor_orders) > 0
         assert buy_labor_orders[0].quantity == 1.0
-        assert buy_labor_orders[0].market_id == "labor_market"
+        assert buy_labor_orders[0].market_id == "labor"
 
     def test_make_decisions_hires_for_needed_labor(
         self, firm_decision_engine_instance, mock_firm, mock_config
@@ -222,7 +230,7 @@ class TestFirmDecisionEngine:
         mock_firm.employees = [Mock()]
         mock_firm.production_target = 500
         mock_firm.inventory["food"] = 0  # Ensure production is needed
-        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
             Tactic.ADJUST_WAGES, Aggressiveness.NORMAL
         )
 
@@ -232,6 +240,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={"avg_wage": 10.0},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
 
@@ -246,7 +255,7 @@ class TestFirmDecisionEngine:
     ):
         mock_firm.employees = [Mock() for _ in range(mock_config.FIRM_MAX_EMPLOYEES)]
         mock_firm.production_target = 500
-        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
             Tactic.ADJUST_WAGES, Aggressiveness.NORMAL
         )
 
@@ -256,6 +265,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
 
@@ -270,7 +280,7 @@ class TestFirmDecisionEngine:
         mock_firm.employees = [Mock() for _ in range(10)]
         mock_firm.production_target = 0
         mock_firm.inventory = {"food": 1000}
-        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
             Tactic.ADJUST_WAGES, Aggressiveness.NORMAL
         )
 
@@ -280,6 +290,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
 
@@ -312,7 +323,7 @@ class TestFirmDecisionEngine:
         assert labor_order is not None
         assert labor_order.agent_id == mock_firm.id
         assert labor_order.quantity == 1.0
-        assert labor_order.market_id == "labor_market"
+        assert labor_order.market_id == "labor"
 
     def test_make_decisions_does_not_sell_if_understocked(
         self, firm_decision_engine_instance, mock_firm
@@ -327,6 +338,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
         sell_orders = [
@@ -347,6 +359,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
         sell_orders = [
@@ -368,6 +381,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
         sell_order = next(
@@ -389,6 +403,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
         sell_order = next(
@@ -412,6 +427,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
         sell_order = next(
@@ -429,6 +445,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
         sell_order = next(
@@ -450,6 +467,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
         sell_order = next(
@@ -473,6 +491,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
         sell_order = next(
@@ -498,6 +517,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
 
@@ -523,6 +543,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
 
@@ -548,6 +569,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
 
@@ -576,6 +598,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
         sell_order = next(
@@ -594,6 +617,7 @@ class TestFirmDecisionEngine:
             goods_data=[],
             market_data={},
             current_time=1,
+            government=None,
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
         sell_order = next(
