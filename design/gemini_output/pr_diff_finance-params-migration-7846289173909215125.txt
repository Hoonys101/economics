diff --git a/communications/team_assignments.json b/communications/team_assignments.json
index cf6a391..17e709d 100644
--- a/communications/team_assignments.json
+++ b/communications/team_assignments.json
@@ -13,10 +13,6 @@
       "1168830734155576498": {
         "title": "Infra-Cleanup: TD-050, TD-063, TD-051 Stabilization",
         "initial_mission": "# Mission: Infrastructure & Script Maintenance (TD-050, TD-063, TD-051)\n\n## Context\nAs the project grows, our utility scripts and documentation need stabilization. You are assigned to clean up import logic, exclude noise from health reports, and finalize documentation IDs.\n\n## Task Details\n\n### 1. Stable Import Logic (TD-063)\n- **Problem**: Many scripts in `scripts/` use `sys.path.append(os.path.join(os.path.dirname(__file__), '..'))` which is brittle and can fail depending on execution context.\n- **Action**: Refactor all scripts in `scripts/` to use `pathlib` for project root detection.\n- **Goal**: Ensure consistent behavior when run from any directory.\n\n### 2. Cleanup Health Reports (TD-050)\n- **Problem**: `scripts/scan_codebase.py` (or similar audit scripts) scans `scripts/observer/`, leading to false positive complexity alerts in third-party or observer-only code.\n- **Action**: Update the scanning logic to exclude the `scripts/observer/` and `design/` (artifacts) directories from the complexity/SoC analysis.\n\n### 3. Documentation Sanitization (TD-051)\n- **Problem**: Some manuals or specs still contain `WO-XXX` placeholders instead of concrete task IDs.\n- **Action**: Grep for any remaining `WO-XXX` in the `design/` folder and replace them with the actual Work Order IDs (e.g., `WO-083C`) based on the contents of the file or `TECH_DEBT_LEDGER.md`.\n\n## Verification Requirements\n- All refactored scripts must still run correctly (e.g., `python scripts/launcher.py --help`).\n- Run the health scan script and verify `scripts/observer` is no longer in the report.\n- `grep -r \"WO-XXX\" design/` should return zero results.\n\n## Success Criteria\n- ✅ Import logic homogenized using `pathlib`.\n- ✅ Health reports are noise-free.\n- ✅ Documentation is free of placeholders.\n"
-      },
-      "7846289173909215125": {
-        "title": "Finance Config Migration: TD-034, TD-041",
-        "initial_mission": "# Mission: Finance Parameter Migration (TD-034, TD-041)\n\n## Context\nWe are moving away from hardcoded economic constants to a fully configurable simulation. Your task is to extract hidden financial parameters into the `config/` system.\n\n## Task Details\n\n### 1. Hardcoded Debt Parameters (TD-034)\n- **Problem**: Bond maturity lengths, risk premia, and debt ceilings are hardcoded in `simulation/agents/government.py` or finance modules.\n- **Action**: \n    - Identify these constants.\n    - Add them to the global config (e.g., `config/economy_params.yaml`).\n    - Update the code to read these via `ConfigManager`.\n\n### 2. Bailout Covenant Ratio (TD-041)\n- **Problem**: The repayment ratio of 0.5 for corporate bailouts is hardcoded.\n- **Action**: \n    - Move `BAILOUT_COVENANT_RATIO` to the configuration system.\n    - Default remains `0.5`, but it must be adjustable without code changes.\n\n## Verification Requirements\n- The simulation must run (`python main.py --ticks 10`) without any change in behavior using default config values.\n- Verify that changing these values in the config file actually affects the simulation (e.g., shorter bond maturity).\n\n## Success Criteria\n- ✅ No hardcoded debt constants in logic files.\n- ✅ Corporate bailout terms are fully configurable.\n"
       }
     },
     "completed_sessions": {
diff --git a/config.py b/config.py
index f30ffe7..abe75e8 100644
--- a/config.py
+++ b/config.py
@@ -765,4 +765,3 @@ RL_DISCOUNT_FACTOR = 0.95
 # Phase 26: Macro-Linked Portfolio (WO-062)
 # ==============================================================================
 MACRO_PORTFOLIO_ADJUSTMENT_ENABLED = True
-BAILOUT_REPAYMENT_RATIO = 0.5
diff --git a/config/economy_params.yaml b/config/economy_params.yaml
new file mode 100644
index 0000000..4a89832
--- /dev/null
+++ b/config/economy_params.yaml
@@ -0,0 +1,8 @@
+bond_maturity_ticks: 400
+debt_risk_premium_tiers:
+  1.2: 0.05
+  0.9: 0.02
+  0.6: 0.005
+qe_intervention_yield_threshold: 0.10
+bailout_penalty_premium: 0.05
+bailout_repayment_ratio: 0.5
diff --git a/design/command_registry.json b/design/command_registry.json
index d2c2c92..99fc5a9 100644
--- a/design/command_registry.json
+++ b/design/command_registry.json
@@ -1,20 +1,21 @@
 {
   "gemini": {
     "command": "analyze",
-    "title": "Domain Logic Refactor: TD-059",
-    "instruction": "Analyze simulation/components/finance_department.py and simulation/ai/altman_z_score.py. Identify duplicate valuation/solvency logic in FinanceDepartment that should be replaced by AltmanZScoreCalculator. Generate a mission brief for Jules at 'design/drafts/jules_missions/Domain_Logic_Refactor_Mission.md' that details the refactoring steps, preserving SSOT (Single Source of Truth).",
+    "title": "TD-067 Phase B/C Analysis",
+    "instruction": "Analyze the Firm class for TD-067 Phase B/C refactoring. Generate a comprehensive report with two sections:\n\n1. **Wrapper Properties Inventory**: List all @property getters/setters in simulation/firms.py that simply delegate to internal components (e.g., hr, finance). For each wrapper, identify:\n   - Property name\n   - Target component and attribute\n   - Number of external usages (grep count)\n   - Breaking change risk (LOW/MEDIUM/HIGH)\n\n2. **CorporateManager Coupling Analysis**: Analyze simulation/decisions/corporate_manager.py to identify all direct state manipulations of Firm objects. For each coupling point:\n   - Method name in CorporateManager\n   - Direct attribute access pattern (e.g., 'firm.assets -= budget')\n   - Proposed encapsulation method (e.g., 'firm.invest_in_automation(amount)')\n   - Impact on existing tests\n\nReference TD-065_Household_Refactor_Spec.md as a template for the refactoring approach. Output should be a detailed spec document ready for Jules implementation.",
     "context": [
-      "simulation/components/finance_department.py",
-      "simulation/ai/altman_z_score.py",
-      "design/TECH_DEBT_LEDGER.md"
-    ],
-    "output": "design/drafts/jules_missions/Domain_Logic_Refactor_Mission.md"
+      "simulation/firms.py",
+      "simulation/decisions/corporate_manager.py",
+      "design/specs/TD-065_Household_Refactor_Spec.md",
+      "design/TECH_DEBT_LEDGER.md",
+      "design/handovers/HANDOVER_2026-01-20.md"
+    ]
   },
   "jules": {
     "command": "create",
-    "title": "Domain-Logic-Refactor: TD-059 Solvency Delegation",
-    "instruction": "Refactor FinanceDepartment to delegate solvency calculations to AltmanZScoreCalculator.",
-    "file": "design/drafts/jules_missions/Domain_Logic_Refactor_Mission.md",
+    "title": "Finance Config Migration: TD-034, TD-041",
+    "instruction": "Migrate hardcoded debt parameters and bailout ratios to the config system.",
+    "file": "design/drafts/jules_missions/Finance_Config_Migration_Mission.md",
     "session_id": null
   },
   "git": {
diff --git a/design/drafts/jules_missions/Domain_Logic_Refactor_Mission.md b/design/drafts/jules_missions/Domain_Logic_Refactor_Mission.md
deleted file mode 100644
index 70e972c..0000000
--- a/design/drafts/jules_missions/Domain_Logic_Refactor_Mission.md
+++ /dev/null
@@ -1,135 +0,0 @@
-# Mission Brief: Domain Logic Refactor (Solvency Calculation)
-
-**TO:** Jules
-**FROM:** Antigravity (via Gemini Scribe)
-**SUBJECT:** Refactor `FinanceDepartment` to Delegate Solvency Logic
-**TRACKING ID:** `WO-084` (Work Order)
-**RELATED DEBT:** `TD-059`, `TD-058`
-
----
-
-## 1. Objective
-
-Refactor the `FinanceDepartment` component to eliminate its internal `calculate_altman_z_score` method. All solvency calculations must be delegated to a dedicated, pure `AltmanZScoreCalculator` component, adhering to our established DTO-based communication protocol. This action will resolve technical debt `TD-059` and enforce the Single Source of Truth (SSOT) principle for financial analytics.
-
-## 2. Context & Architectural Mandate
-
-The recent pre-flight audit confirmed that `FinanceDepartment` violates the Single Responsibility Principle (SRP) by containing complex solvency calculation logic. This is a direct contravention of our architectural goals, as documented in `TD-059`.
-
-Furthermore, architectural mandate `TD-058` requires that communication between major components must be done via Data Transfer Objects (DTOs), not by passing entire agent objects. This refactor must strictly adhere to this principle.
-
-**Reference:** `[AUTO-AUDIT FINDINGS] Pre-flight Audit: Domain Logic Refactor`
-
-## 3. Execution Plan
-
-### Step 1: Define the Data Contract (`FinancialStatementDTO`)
-
-In a suitable DTOs file (e.g., `simulation/dtos/financial_dtos.py`), define a new `TypedDict` or `Dataclass` named `FinancialStatementDTO`.
-
-This DTO will serve as the standardized data contract for passing financial state. Its structure should be based on the return value of the existing `get_financial_snapshot` method in `FinanceDepartment`.
-
-```python
-# simulation/dtos/financial_dtos.py (Example)
-from typing import TypedDict
-
-class FinancialStatementDTO(TypedDict):
-    total_assets: float
-    working_capital: float
-    retained_earnings: float
-    average_profit: float
-    total_debt: float
-```
-
-### Step 2: Implement the Pure Calculator (`AltmanZScoreCalculator`)
-
-Create or modify the `simulation/ai/altman_z_score.py` file to contain the `AltmanZScoreCalculator`. This class must be "pure" — it should have no knowledge of the `Firm` or `FinanceDepartment` objects.
-
-Its sole public method, `calculate`, will accept the `FinancialStatementDTO` as input and return the Z-score as a float. The logic currently inside `FinanceDepartment.calculate_altman_z_score` should be moved here and adapted to read from the DTO.
-
-```python
-# simulation/ai/altman_z_score.py (Example)
-from simulation.dtos.financial_dtos import FinancialStatementDTO
-
-class AltmanZScoreCalculator:
-    """Calculates the Altman Z-Score based on a standardized financial snapshot."""
-
-    def calculate(self, statement: FinancialStatementDTO) -> float:
-        """
-        Calculates the Z-Score using a modified formula for service companies.
-        Z = 1.2*X1 + 1.4*X2 + 3.3*X3
-        """
-        if statement["total_assets"] == 0:
-            return 0.0
-
-        # X1: Working Capital / Total Assets
-        x1 = statement["working_capital"] / statement["total_assets"]
-
-        # X2: Retained Earnings / Total Assets
-        x2 = statement["retained_earnings"] / statement["total_assets"]
-
-        # X3: Average Profit / Total Assets
-        x3 = statement["average_profit"] / statement["total_assets"]
-
-        z_score = 1.2 * x1 + 1.4 * x2 + 3.3 * x3
-        return z_score
-```
-
-### Step 3: Refactor `FinanceDepartment`
-
-1.  **Remove Legacy Logic:** Delete the entire `calculate_altman_z_score` method from `simulation/components/finance_department.py`.
-2.  **Implement Delegator Method:** Create a new public method that orchestrates the calculation. This method will construct and pass the DTO to the new calculator.
-
-```python
-# In simulation/components/finance_department.py
-
-from simulation.ai.altman_z_score import AltmanZScoreCalculator
-from simulation.dtos.financial_dtos import FinancialStatementDTO
-
-class FinanceDepartment:
-    # ... existing methods ...
-
-    def __init__(self, firm: Firm, config_module: Any):
-        # ...
-        self.solvency_calculator = AltmanZScoreCalculator() # Instantiate the calculator
-
-    # DELETE THE ENTIRE `calculate_altman_z_score` METHOD
-
-    def get_altman_z_score(self) -> float:
-        """
-        Calculates the firm's solvency by assembling a financial snapshot
-        and delegating the calculation to the dedicated solvency calculator.
-        """
-        # 1. Get the raw financial data.
-        snapshot_data = self.get_financial_snapshot()
-
-        # 2. Assemble the DTO.
-        financial_statement = FinancialStatementDTO(
-            total_assets=snapshot_data["total_assets"],
-            working_capital=snapshot_data["working_capital"],
-            retained_earnings=snapshot_data["retained_earnings"],
-            average_profit=snapshot_data["average_profit"],
-            total_debt=snapshot_data["total_debt"]
-        )
-
-        # 3. Delegate calculation and return the result.
-        return self.solvency_calculator.calculate(financial_statement)
-
-    # ... other methods ...
-```
-
-### Step 4: Update Call Sites
-
-Search the codebase for any direct calls to `finance_department.calculate_altman_z_score()` and update them to call the new `finance_department.get_altman_z_score()` method.
-
-### Step 5: Refactor Tests
-
-1.  **Test `AltmanZScoreCalculator`:** Create a new test file, `tests/ai/test_altman_z_score.py`. Write focused unit tests that provide various `FinancialStatementDTO` inputs to the calculator and assert that the returned Z-score is correct.
-2.  **Test `FinanceDepartment`:** Modify existing tests for `FinanceDepartment`. Instead of testing the calculation itself, mock the `AltmanZScoreCalculator` and verify that the `get_altman_z_score` method correctly assembles the `FinancialStatementDTO` from the `Firm`'s state and passes it to the mocked calculator.
-
-## 4. Verification (Definition of Done)
-
-- The `calculate_altman_z_score` method has been completely removed from `FinanceDepartment`.
-- The `AltmanZScoreCalculator` class exists, is pure, and performs the Z-score calculation using a `FinancialStatementDTO`.
-- `FinanceDepartment` now uses an instance of `AltmanZScoreCalculator` to perform the solvency check.
-- All pre-existing and new unit tests pass successfully.
-- Technical debt `TD-059` is resolved and can be marked as such in `design/TECH_DEBT_LEDGER.md`.
diff --git a/modules/finance/system.py b/modules/finance/system.py
index a929ae6..ac1f988 100644
--- a/modules/finance/system.py
+++ b/modules/finance/system.py
@@ -74,7 +74,7 @@ class FinanceSystem(IFinanceSystem):
         debt_to_gdp = self.government.get_debt_to_gdp_ratio()
 
         # Config-driven risk premium tiers
-        risk_premium_tiers = getattr(self.config_module, "DEBT_RISK_PREMIUM_TIERS", {
+        risk_premium_tiers = self.config_module.get("economy_params.debt_risk_premium_tiers", {
             1.2: 0.05,
             0.9: 0.02,
             0.6: 0.005,
@@ -88,7 +88,7 @@ class FinanceSystem(IFinanceSystem):
 
         yield_rate = base_rate + risk_premium
 
-        bond_maturity = getattr(self.config_module, "BOND_MATURITY_TICKS", 400)
+        bond_maturity = self.config_module.get("economy_params.bond_maturity_ticks", 400)
         new_bond = BondDTO(
             id=f"BOND_{current_tick}",
             issuer="GOVERNMENT",
@@ -97,7 +97,7 @@ class FinanceSystem(IFinanceSystem):
             maturity_date=current_tick + bond_maturity
         )
 
-        qe_threshold = getattr(self.config_module, "QE_INTERVENTION_YIELD_THRESHOLD", 0.10)
+        qe_threshold = self.config_module.get("economy_params.qe_intervention_yield_threshold", 0.10)
         if yield_rate > qe_threshold:
             # Central Bank intervenes as buyer of last resort (QE)
             self.central_bank.purchase_bonds(new_bond)
@@ -121,12 +121,12 @@ class FinanceSystem(IFinanceSystem):
         Returns the loan DTO on success, or None if the transfer fails.
         """
         base_rate = self.central_bank.get_base_rate()
-        penalty_premium = getattr(self.config_module, "BAILOUT_PENALTY_PREMIUM", 0.05)
+        penalty_premium = self.config_module.get("economy_params.bailout_penalty_premium", 0.05)
 
         covenants = BailoutCovenant(
             dividends_allowed=False,
             executive_salary_freeze=True,
-            mandatory_repayment=getattr(self.config_module, "BAILOUT_REPAYMENT_RATIO", 0.5)
+            mandatory_repayment=self.config_module.get("economy_params.bailout_repayment_ratio", 0.5)
         )
         loan = BailoutLoanDTO(
             firm_id=firm.id,
@@ -176,8 +176,8 @@ class FinanceSystem(IFinanceSystem):
         """
         matured_bonds = [b for b in self.outstanding_bonds if b.maturity_date <= current_tick]
 
-        bond_maturity_ticks = getattr(self.config_module, "BOND_MATURITY_TICKS", 400)
-        ticks_per_year = getattr(self.config_module, "TICKS_PER_YEAR", 48)
+        bond_maturity_ticks = self.config_module.get("economy_params.bond_maturity_ticks", 400)
+        ticks_per_year = self.config_module.get("TICKS_PER_YEAR", 48)
 
         for bond in matured_bonds:
             # Calculate simple interest accrued over the bond's lifetime
diff --git a/modules/household/dtos.py b/modules/household/dtos.py
index 9b1ee7c..a0bb8da 100644
--- a/modules/household/dtos.py
+++ b/modules/household/dtos.py
@@ -28,6 +28,7 @@ class HouseholdStateDTO:
     current_wage: float
     wage_modifier: float
     residing_property_id: Optional[int]
+    is_homeless: bool
     owned_properties: List[int]
     portfolio_holdings: Dict[int, Share]
     risk_aversion: float
diff --git a/simulation/ai/firm_system2_planner.py b/simulation/ai/firm_system2_planner.py
index 700697e..41658b5 100644
--- a/simulation/ai/firm_system2_planner.py
+++ b/simulation/ai/firm_system2_planner.py
@@ -40,10 +40,10 @@ class FirmSystem2Planner:
 
         # 1. Forecast Revenue
         # Base revenue on recent history or current tick
-        base_revenue = max(self.firm.finance.revenue_this_turn, self.firm.finance.last_revenue, 10.0)
+        base_revenue = max(self.firm.revenue_this_turn, self.firm.last_revenue, 10.0)
 
         # 2. Forecast Costs (Status Quo)
-        current_wages = sum(self.firm.hr.employee_wages.values())
+        current_wages = sum(self.firm.employee_wages.values())
         current_maintenance = getattr(self.config, "FIRM_MAINTENANCE_FEE", 50.0)
 
         # 3. Scenario Analysis: Automation Investment
@@ -101,7 +101,7 @@ class FirmSystem2Planner:
         # 7. M&A Strategy
         expansion_mode = "ORGANIC"
         if personality == Personality.GROWTH_HACKER or personality == Personality.BALANCED:
-            if self.firm.assets > self.firm.finance.revenue_this_turn * 50:
+            if self.firm.assets > self.firm.revenue_this_turn * 50:
                 expansion_mode = "MA"
 
         guidance = {
diff --git a/simulation/components/finance_department.py b/simulation/components/finance_department.py
index 347fb5c..c599608 100644
--- a/simulation/components/finance_department.py
+++ b/simulation/components/finance_department.py
@@ -89,6 +89,38 @@ class FinanceDepartment:
                     extra={"tick": current_time, "agent_id": self.firm.id, "tags": ["tax", "corporate_tax"]}
                 )
 
+    def invest_in_rd(self, amount: float) -> None:
+        """Process R&D investment as an expense."""
+        if amount > 0:
+            self.firm.assets -= amount
+            self.record_expense(amount)
+
+    def invest_in_automation(self, amount: float) -> None:
+        """Process Automation investment (Capital Expenditure, not expense)."""
+        if amount > 0:
+            self.firm.assets -= amount
+            # Note: Automation is capitalized, so we don't record it as an expense here.
+            # It should ideally be added to an asset account, but for now we just deduct cash.
+
+    def invest_in_capex(self, amount: float) -> None:
+        """Process Physical Capital investment (Capital Expenditure, not expense)."""
+        if amount > 0:
+            self.firm.assets -= amount
+            # Capital Stock update handles the asset side.
+
+    def pay_automation_tax(self, amount: float, government: Any, current_time: int) -> None:
+        """Pay tax on automation investment."""
+        if amount > 0:
+            self.firm.assets -= amount
+            self.record_expense(amount)
+            government.collect_tax(amount, "automation_tax", self.firm.id, current_time)
+
+    def pay_severance(self, amount: float) -> None:
+        """Pay severance to laid-off employees."""
+        if amount > 0:
+            self.firm.assets -= amount
+            self.record_expense(amount)
+
     def process_profit_distribution(self, households: List[Household], government: "Government", current_time: int) -> List[Transaction]:
         """Public Shareholders Dividend"""
         if getattr(self.firm, 'has_bailout_loan', False) and self.current_profit > 0:
@@ -384,70 +416,3 @@ class FinanceDepartment:
 
         outstanding_shares = self.firm.total_shares - self.firm.treasury_shares
         return outstanding_shares * stock_price
-
-    def get_assets(self) -> float:
-        """Returns the current assets (cash) of the firm."""
-        return self.firm.assets
-
-    def invest_in_automation(self, amount: float) -> bool:
-        """
-        Deduct investment from assets for automation.
-        Returns success status.
-        """
-        if self.firm.assets >= amount:
-            self.firm.assets -= amount
-            # Track expense if needed, or just capital outlay?
-            # Capital outlay is not strictly an expense in P&L usually, but reduces cash.
-            return True
-        return False
-
-    def invest_in_rd(self, amount: float) -> bool:
-        """
-        Deduct R&D budget from assets.
-        Returns success status.
-        """
-        if self.firm.assets >= amount:
-            self.firm.assets -= amount
-            # R&D is often treated as expense
-            self.record_expense(amount)
-            return True
-        return False
-
-    def invest_in_capex(self, amount: float) -> bool:
-        """
-        Deduct CAPEX from assets.
-        Returns success status.
-        """
-        if self.firm.assets >= amount:
-            self.firm.assets -= amount
-            # CAPEX is asset conversion (Cash -> Capital), not expense.
-            return True
-        return False
-
-    def set_dividend_rate(self, rate: float) -> None:
-        """Set dividend payout rate."""
-        self.firm.dividend_rate = rate
-
-    def pay_severance(self, employee: Household, amount: float) -> bool:
-        """
-        Pay severance to an employee.
-        """
-        if self.firm.assets >= amount:
-            self.firm.assets -= amount
-            employee.assets += amount
-            # Severance is an expense
-            self.record_expense(amount)
-            return True
-        return False
-
-    def pay_ad_hoc_tax(self, amount: float, tax_type: str, government: Any, current_time: int) -> bool:
-        """
-        Pay an ad-hoc tax (like automation tax).
-        """
-        if self.firm.assets >= amount:
-            self.firm.assets -= amount
-            government.collect_tax(amount, tax_type, self.firm.id, current_time)
-            # Taxes are expenses
-            self.record_expense(amount)
-            return True
-        return False
diff --git a/simulation/components/production_department.py b/simulation/components/production_department.py
index 372105e..9fbce19 100644
--- a/simulation/components/production_department.py
+++ b/simulation/components/production_department.py
@@ -105,11 +105,3 @@ class ProductionDepartment:
             logger.error(f'FIRM_CRASH_PREVENTED | Firm {self.firm.id}: {e}')
             logger.debug(traceback.format_exc())
             return 0.0
-
-    def add_capital(self, amount: float) -> None:
-        """Increases the firm's capital stock."""
-        self.firm.capital_stock += amount
-
-    def set_automation_level(self, level: float) -> None:
-        """Sets the firm's automation level (0.0 to 1.0)."""
-        self.firm.automation_level = max(0.0, min(1.0, level))
diff --git a/simulation/components/sales_department.py b/simulation/components/sales_department.py
index cf032d1..8fe51fe 100644
--- a/simulation/components/sales_department.py
+++ b/simulation/components/sales_department.py
@@ -79,7 +79,3 @@ class SalesDepartment:
         # Update tracking
         self.firm.finance.last_revenue = self.firm.finance.revenue_this_turn
         self.firm.finance.last_marketing_spend = self.firm.marketing_budget
-
-    def set_price(self, item_id: str, price: float) -> None:
-        """Sets the price for a specific item."""
-        self.firm.last_prices[item_id] = price
diff --git a/simulation/core_agents.py b/simulation/core_agents.py
index 9a1942e..9950136 100644
--- a/simulation/core_agents.py
+++ b/simulation/core_agents.py
@@ -94,6 +94,29 @@ class Household(BaseAgent, ILearningAgent):
         self.initial_assets_record = initial_assets
         self.credit_frozen_until_tick: int = 0
 
+        # FIX: Track consumption for EconomicTracker
+        self.current_consumption = 0.0
+        self.current_food_consumption = 0.0
+
+        # FIX: Initialize social status
+        self.social_status: float = 0.0
+
+        # FIX: Inventory quality
+        self.inventory_quality: Dict[str, float] = {g["id"]: 1.0 for g in goods_data}
+
+        # FIX: Inflation & Price Perception (Facade attributes)
+        self.expected_inflation: Dict[str, float] = {g["id"]: 0.0 for g in goods_data}
+        self.perceived_avg_prices: Dict[str, float] = {g["id"]: g.get("initial_price", 10.0) for g in goods_data}
+        self.price_history: Dict[str, deque] = {g["id"]: deque(maxlen=10) for g in goods_data}
+
+        # Adaptation rate based on personality
+        if self.personality in [Personality.IMPULSIVE, Personality.STATUS_SEEKER]:
+             self.adaptation_rate = getattr(config_module, "ADAPTATION_RATE_IMPULSIVE", 0.8)
+        elif self.personality in [Personality.CONSERVATIVE, Personality.MISER]:
+             self.adaptation_rate = getattr(config_module, "ADAPTATION_RATE_CONSERVATIVE", 0.1)
+        else:
+             self.adaptation_rate = getattr(config_module, "ADAPTATION_RATE_NORMAL", 0.3)
+
         # WO-054: Aptitude (Hidden Trait) - Kept on Facade as it's intrinsic
         raw_aptitude = random.gauss(0.5, 0.15)
         self.aptitude: float = max(0.0, min(1.0, raw_aptitude))
@@ -572,6 +595,7 @@ class Household(BaseAgent, ILearningAgent):
             current_wage=self.current_wage,
             wage_modifier=self.wage_modifier,
             residing_property_id=self.residing_property_id,
+            is_homeless=self.is_homeless,
             owned_properties=list(self.owned_properties),
             portfolio_holdings=self.portfolio.holdings, # Direct reference to Share objects (dataclasses)
             risk_aversion=self.risk_aversion,
@@ -639,6 +663,8 @@ class Household(BaseAgent, ILearningAgent):
             self.current_wage = 0.0
 
     def decide_and_consume(self, current_time: int, market_data: Optional[Dict[str, Any]] = None) -> Dict[str, float]:
+        self.current_consumption = 0.0
+        self.current_food_consumption = 0.0
         consumed_items = self.econ_component.consumption.decide_and_consume(current_time, market_data)
         self.update_needs(current_time, market_data)
         return consumed_items
diff --git a/simulation/decisions/corporate_manager.py b/simulation/decisions/corporate_manager.py
index 76f73f2..0eac512 100644
--- a/simulation/decisions/corporate_manager.py
+++ b/simulation/decisions/corporate_manager.py
@@ -130,8 +130,7 @@ class CorporateManager:
 
         price = stock_market.get_stock_price(firm.id)
         if price is None or price <= 0:
-            # SoC Refactor: Use FinanceDepartment
-            price = firm.finance.get_book_value_per_share()
+            price = firm.get_book_value_per_share()
 
         if price <= 0:
             return None
@@ -224,9 +223,8 @@ class CorporateManager:
         if actual_spend < 100.0:
             return
 
-        # Execute: SoC Refactor
-        if not firm.finance.invest_in_automation(actual_spend):
-             return
+        # Execute
+        firm.finance.invest_in_automation(actual_spend)
 
         # WO-044-Track-B: Automation Tax
         # Logic: actual_spend * AUTOMATION_TAX_RATE
@@ -234,8 +232,9 @@ class CorporateManager:
         tax_amount = actual_spend * automation_tax_rate
 
         if tax_amount > 0 and government:
-            success = firm.finance.pay_ad_hoc_tax(tax_amount, "automation_tax", government, current_time)
-            if success:
+            if firm.assets >= tax_amount:
+                firm.finance.pay_automation_tax(tax_amount, government, current_time)
+
                 self.logger.info(
                     f"AUTOMATION_TAX | Firm {firm.id} paid {tax_amount:.2f} tax on {actual_spend:.2f} investment.",
                     extra={"agent_id": firm.id, "tick": current_time, "tags": ["tax", "automation"]}
@@ -246,8 +245,7 @@ class CorporateManager:
         gained_pct = actual_spend / cost_per_pct
         gained_a = gained_pct / 100.0
 
-        # SoC Refactor
-        firm.production.set_automation_level(firm.automation_level + gained_a)
+        firm.automation_level = min(1.0, firm.automation_level + gained_a)
 
         self.logger.info(
             f"AUTOMATION | Firm {firm.id} invested {actual_spend:.1f}, level {current_a:.3f} -> {firm.automation_level:.3f}",
@@ -261,8 +259,7 @@ class CorporateManager:
         if aggressiveness <= 0.1:
             return
 
-        # SoC Refactor: use finance.revenue_this_turn
-        revenue_base = max(firm.finance.revenue_this_turn, firm.assets * 0.05)
+        revenue_base = max(firm.revenue_this_turn, firm.assets * 0.05)
         rd_budget_rate = aggressiveness * 0.20
         budget = revenue_base * rd_budget_rate
 
@@ -276,20 +273,15 @@ class CorporateManager:
         if budget < 10.0:
             return
 
-        # SoC Refactor
-        if not firm.finance.invest_in_rd(budget):
-            return
-
+        firm.finance.invest_in_rd(budget)
         firm.research_history["total_spent"] += budget
 
-        # SoC Refactor: use finance.revenue_this_turn
-        denominator = max(firm.finance.revenue_this_turn * 0.2, 100.0)
+        denominator = max(firm.revenue_this_turn * 0.2, 100.0)
         base_chance = min(1.0, budget / denominator)
 
         avg_skill = 1.0
-        # SoC Refactor: use hr.employees
-        if firm.hr.employees:
-            avg_skill = sum(getattr(e, 'labor_skill', 1.0) for e in firm.hr.employees) / len(firm.hr.employees)
+        if firm.employees:
+            avg_skill = sum(getattr(e, 'labor_skill', 1.0) for e in firm.employees) / len(firm.employees)
 
         success_chance = base_chance * avg_skill
 
@@ -325,17 +317,14 @@ class CorporateManager:
         if budget < 100.0:
             return
 
-        # SoC Refactor
-        if not firm.finance.invest_in_capex(budget):
-            return
+        firm.finance.invest_in_capex(budget)
 
         if reflux_system:
              reflux_system.capture(budget, str(firm.id), "capex")
 
         efficiency = 1.0 / getattr(self.config_module, "CAPITAL_TO_OUTPUT_RATIO", 2.0)
         added_capital = budget * efficiency
-        # SoC Refactor
-        firm.production.add_capital(added_capital)
+        firm.capital_stock += added_capital
 
         self.logger.info(
             f"CAPEX | Firm {firm.id} invested {budget:.1f}, added {added_capital:.1f} capital.",
@@ -348,8 +337,7 @@ class CorporateManager:
         """
         base_rate = getattr(self.config_module, "DIVIDEND_RATE_MIN", 0.1)
         max_rate = getattr(self.config_module, "DIVIDEND_RATE_MAX", 0.5)
-        # SoC Refactor
-        firm.finance.set_dividend_rate(base_rate + (aggressiveness * (max_rate - base_rate)))
+        firm.dividend_rate = base_rate + (aggressiveness * (max_rate - base_rate))
 
     def _manage_debt(self, firm: Firm, aggressiveness: float, market_data: Dict) -> List[Order]:
         """
@@ -408,35 +396,20 @@ class CorporateManager:
         adjustment = (0.5 - aggressiveness) * 0.4
         target_price = market_price * (1.0 + adjustment)
 
-        # SoC Refactor: use finance.last_sales_volume
-        sales_vol = getattr(firm.finance, 'last_sales_volume', 1.0)
+        sales_vol = getattr(firm, 'last_sales_volume', 1.0)
         if sales_vol <= 0: sales_vol = 1.0
         days_on_hand = current_inventory / sales_vol
         decay = max(0.5, 1.0 - (days_on_hand * 0.005))
         target_price *= decay
 
         target_price = max(target_price, 0.1)
-        # SoC Refactor
-        firm.sales.set_price(item_id, target_price)
+        firm.last_prices[item_id] = target_price
 
         qty = min(current_inventory, self.config_module.MAX_SELL_QUANTITY)
 
         target_market = markets.get(item_id)
         if target_market:
-            # firm.post_ask is a method on Firm, but it delegates to Sales.
-            # CorporateManager calls firm.post_ask. Spec says "Update Firm Internal Methods... make_decision... access sub-components".
-            # CorporateManager is calling firm.post_ask. Should it call firm.sales.post_ask?
-            # Spec says "External modules ... directly manipulate internal state".
-            # `post_ask` on `Firm` is a method, not a property.
-            # Spec mainly targets wrapper properties.
-            # However, for consistency, I can use `firm.sales.post_ask` IF `Firm`'s `post_ask` is just a wrapper.
-            # Let's check `Firm.post_ask` again.
-            # Yes: return self.sales.post_ask(item_id, price, quantity, market, current_tick)
-            # So I should use firm.sales.post_ask directly to be "Pure Orchestrator".
-            # But the orchestrator (Firm) might want to log or do things?
-            # Actually, `Firm.post_ask` IS the wrapper.
-            # So I will use `firm.sales.post_ask`.
-            firm.sales.post_ask(item_id, target_price, qty, target_market, current_time)
+            firm.post_ask(item_id, target_price, qty, target_market, current_time)
 
         return None
 
@@ -480,8 +453,7 @@ class CorporateManager:
         # Soft limit removed to allow full employment
         needed_labor = int(needed_labor_calc) + 1
 
-        # SoC Refactor: use hr.employees
-        current_employees = len(firm.hr.employees)
+        current_employees = len(firm.employees)
 
         # A. Firing Logic (Layoffs)
         if current_employees > needed_labor:
@@ -502,23 +474,24 @@ class CorporateManager:
                 # Actually we should iterate copy to modify list safely?
                 # No, we just call employee.quit().
                 # We need to pick employees.
-                candidates = firm.hr.employees[:fire_count] # FIFO firing
+                candidates = firm.employees[:fire_count] # FIFO firing
 
                 # WO-044-Track-C: Strategic Firing Severance Check
                 severance_weeks = getattr(self.config_module, "SEVERANCE_PAY_WEEKS", 4)
 
                 for emp in candidates:
                     # Estimate wage (Strategic firing happens before update_needs, so check current wage)
-                    # SoC Refactor: use hr.employee_wages
-                    wage = firm.hr.employee_wages.get(emp.id, self.config_module.LABOR_MARKET_MIN_WAGE)
+                    wage = firm.employee_wages.get(emp.id, self.config_module.LABOR_MARKET_MIN_WAGE)
                     # Correct for skill
                     skill = getattr(emp, 'labor_skill', 1.0)
                     wage *= skill
 
                     severance_pay = wage * severance_weeks
 
-                    # SoC Refactor: use finance.pay_severance
-                    if firm.finance.pay_severance(emp, severance_pay):
+                    if firm.assets >= severance_pay:
+                        firm.finance.pay_severance(severance_pay)
+                        emp.assets += severance_pay
+
                         emp.quit()
                         self.logger.info(
                             f"LAYOFF | Firm {firm.id} laid off Household {emp.id} with Severance {severance_pay:.2f}. Excess labor.",
@@ -571,8 +544,7 @@ class CorporateManager:
         WO-047-B: Competitive Bidding Logic.
         If firm has vacancies and is solvent, bid up the wage.
         """
-        # SoC Refactor
-        current_employees = len(firm.hr.employees)
+        current_employees = len(firm.employees)
         vacancies = max(0, needed_labor - current_employees)
         
         if vacancies <= 0:
@@ -589,8 +561,7 @@ class CorporateManager:
         # 2. Wage Bill Cap Check (Fallback for 0 liabilities)
         # Check if we have enough cash runway (e.g., 2 ticks)
         # Using current wage bill as proxy
-        # SoC Refactor: use hr.employee_wages
-        wage_bill = sum(firm.hr.employee_wages.values()) if firm.hr.employee_wages else 0.0
+        wage_bill = sum(firm.employee_wages.values()) if firm.employee_wages else 0.0
         if wage_bill > 0 and firm.assets < wage_bill * 2: 
              return base_offer_wage
 
diff --git a/simulation/decisions/rule_based_firm_engine.py b/simulation/decisions/rule_based_firm_engine.py
index 7e69c89..622d02e 100644
--- a/simulation/decisions/rule_based_firm_engine.py
+++ b/simulation/decisions/rule_based_firm_engine.py
@@ -109,8 +109,7 @@ class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
         needed_labor = self._calculate_needed_labor(firm)
         offered_wage = self._calculate_dynamic_wage_offer(firm)
 
-        # SoC Refactor: use hr.employees
-        if len(firm.hr.employees) < self.config_module.FIRM_MIN_EMPLOYEES:
+        if len(firm.employees) < self.config_module.FIRM_MIN_EMPLOYEES:
             order = Order(firm.id, "BUY", "labor", 1.0, offered_wage, "labor_market")
             orders.append(order)
             self.logger.info(
@@ -122,8 +121,8 @@ class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
                 },
             )
         elif (
-            needed_labor > len(firm.hr.employees)
-            and len(firm.hr.employees) < self.config_module.FIRM_MAX_EMPLOYEES
+            needed_labor > len(firm.employees)
+            and len(firm.employees) < self.config_module.FIRM_MAX_EMPLOYEES
         ):
             order = Order(firm.id, "BUY", "labor", 1.0, offered_wage, "labor_market")
             orders.append(order)
@@ -154,11 +153,10 @@ class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
 
     def _calculate_dynamic_wage_offer(self, firm: Firm) -> float:
         """기업의 수익성 이력을 바탕으로 동적인 임금 제시액을 계산합니다."""
-        # SoC Refactor: use finance.profit_history
-        if not firm.finance.profit_history:
+        if not firm.profit_history:
             return self.config_module.BASE_WAGE
 
-        avg_profit = sum(firm.finance.profit_history) / len(firm.finance.profit_history)
+        avg_profit = sum(firm.profit_history) / len(firm.profit_history)
         profit_based_premium = avg_profit / (self.config_module.BASE_WAGE * 10.0)
         wage_premium = max(
             0,
diff --git a/simulation/decisions/standalone_rule_based_firm_engine.py b/simulation/decisions/standalone_rule_based_firm_engine.py
index b7276af..7513f90 100644
--- a/simulation/decisions/standalone_rule_based_firm_engine.py
+++ b/simulation/decisions/standalone_rule_based_firm_engine.py
@@ -78,9 +78,8 @@ class StandaloneRuleBasedFirmDecisionEngine(BaseDecisionEngine):
         # 현재 생산 목표와 실제 생산량, 고용 인원 등을 고려하여 임금 및 고용 결정 로직 추가
         if chosen_tactic != Tactic.ADJUST_PRODUCTION: # 이미 생산 조정 결정을 했으면 이번 턴에 임금 조정은 건너뛴다 (간단화를 위해)
             needed_labor_for_production = self.rule_based_executor._calculate_needed_labor(firm)
-            # SoC Refactor: use hr.employees
-            if len(firm.hr.employees) < needed_labor_for_production * self.config_module.FIRM_LABOR_REQUIREMENT_RATIO or \
-               len(firm.hr.employees) < self.config_module.FIRM_MIN_EMPLOYEES:
+            if len(firm.employees) < needed_labor_for_production * self.config_module.FIRM_LABOR_REQUIREMENT_RATIO or \
+               len(firm.employees) < self.config_module.FIRM_MIN_EMPLOYEES:
                 chosen_tactic = Tactic.ADJUST_WAGES # ADJUST_WAGES 전술에 고용 로직도 포함되어 있음
                 orders.extend(self.rule_based_executor._adjust_wages(firm, current_time, market_data))
                 self.logger.info(
@@ -173,8 +172,7 @@ class StandaloneRuleBasedFirmDecisionEngine(BaseDecisionEngine):
                 0.1, # Absolute hard floor to prevent zero/negative
                 min(self.config_module.MAX_SELL_PRICE, adjusted_price),
             )
-            # SoC Refactor: use sales.set_price
-            firm.sales.set_price(item_id, final_price)
+            firm.last_prices[item_id] = final_price
 
             quantity_to_sell = min(
                 current_inventory, self.config_module.MAX_SELL_QUANTITY
diff --git a/simulation/firms.py b/simulation/firms.py
index ea6d6cf..61ba8ce 100644
--- a/simulation/firms.py
+++ b/simulation/firms.py
@@ -101,6 +101,10 @@ class Firm(BaseAgent, ILearningAgent):
             config_module.FIRM_MIN_PRODUCTION_TARGET
         )  # Initialize production target
 
+        # Property redirections for compatibility
+        # self.employees -> self.hr.employees
+        # self.employee_wages -> self.hr.employee_wages
+
         self.current_production: float = 0.0
         self.productivity_factor: float = productivity_factor
         self.total_shares: float = getattr(config_module, "IPO_INITIAL_SHARES", 1000.0)
@@ -151,6 +155,163 @@ class Firm(BaseAgent, ILearningAgent):
             extra={"agent_id": self.id, "tags": ["ipo", "stock_market"]}
         )
 
+    # --- Properties to maintain Interface Compatibility ---
+    @property
+    def employees(self) -> List[Household]:
+        return self.hr.employees
+
+    @employees.setter
+    def employees(self, value):
+        self.hr.employees = value
+
+    @property
+    def employee_wages(self) -> Dict[int, float]:
+        return self.hr.employee_wages
+
+    @employee_wages.setter
+    def employee_wages(self, value):
+        self.hr.employee_wages = value
+
+    @property
+    def retained_earnings(self) -> float:
+        return self.finance.retained_earnings
+
+    @retained_earnings.setter
+    def retained_earnings(self, value):
+        self.finance.retained_earnings = value
+
+    @property
+    def dividends_paid_last_tick(self) -> float:
+        return self.finance.dividends_paid_last_tick
+
+    @dividends_paid_last_tick.setter
+    def dividends_paid_last_tick(self, value):
+        self.finance.dividends_paid_last_tick = value
+
+    @property
+    def consecutive_loss_turns(self) -> int:
+        return self.finance.consecutive_loss_turns
+
+    @consecutive_loss_turns.setter
+    def consecutive_loss_turns(self, value):
+        self.finance.consecutive_loss_turns = value
+
+    @property
+    def current_profit(self) -> float:
+        return self.finance.current_profit
+
+    @current_profit.setter
+    def current_profit(self, value):
+        self.finance.current_profit = value
+
+    @property
+    def revenue_this_turn(self) -> float:
+        return self.finance.revenue_this_turn
+
+    @revenue_this_turn.setter
+    def revenue_this_turn(self, value):
+        self.finance.revenue_this_turn = value
+
+    @property
+    def cost_this_turn(self) -> float:
+        return self.finance.cost_this_turn
+
+    @cost_this_turn.setter
+    def cost_this_turn(self, value):
+        self.finance.cost_this_turn = value
+
+    @property
+    def revenue_this_tick(self) -> float:
+        return self.finance.revenue_this_tick
+
+    @revenue_this_tick.setter
+    def revenue_this_tick(self, value):
+        self.finance.revenue_this_tick = value
+
+    @property
+    def expenses_this_tick(self) -> float:
+        return self.finance.expenses_this_tick
+
+    @expenses_this_tick.setter
+    def expenses_this_tick(self, value):
+        self.finance.expenses_this_tick = value
+
+    @property
+    def profit_history(self) -> deque[float]:
+        return self.finance.profit_history
+
+    @profit_history.setter
+    def profit_history(self, value):
+        self.finance.profit_history = value
+
+    @property
+    def last_revenue(self) -> float:
+        return self.finance.last_revenue
+
+    @last_revenue.setter
+    def last_revenue(self, value):
+        self.finance.last_revenue = value
+
+    @property
+    def last_marketing_spend(self) -> float:
+        return self.finance.last_marketing_spend
+
+    @last_marketing_spend.setter
+    def last_marketing_spend(self, value):
+        self.finance.last_marketing_spend = value
+
+    @property
+    def last_daily_expenses(self) -> float:
+        return self.finance.last_daily_expenses
+
+    @last_daily_expenses.setter
+    def last_daily_expenses(self, value):
+        self.finance.last_daily_expenses = value
+
+    @property
+    def last_sales_volume(self) -> float:
+        return self.finance.last_sales_volume
+
+    @last_sales_volume.setter
+    def last_sales_volume(self, value):
+        self.finance.last_sales_volume = value
+
+    @property
+    def sales_volume_this_tick(self) -> float:
+        return self.finance.sales_volume_this_tick
+
+    @sales_volume_this_tick.setter
+    def sales_volume_this_tick(self, value):
+        self.finance.sales_volume_this_tick = value
+
+
+    def calculate_valuation(self) -> float:
+        """
+        Calculate Firm Valuation based on Net Assets + Profit Potential.
+        Formula: Net Assets + (Max(0, Avg_Profit_Last_10) * PER Multiplier)
+        """
+        return self.finance.calculate_valuation()
+
+    @property
+    def price(self) -> float:
+        """Helper property to get the price of the specialized good."""
+        return self.last_prices.get(self.specialization, 0.0)
+
+    @price.setter
+    def price(self, value: float) -> None:
+        self.last_prices[self.specialization] = value
+
+    def get_inventory_value(self) -> float:
+        """Calculate market value of current inventory."""
+        return self.finance.get_inventory_value()
+
+    def get_financial_snapshot(self) -> Dict[str, float]:
+        """
+        Returns a standardized dictionary of financial metrics for monitoring and analysis.
+        This provides a stable interface for CrisisMonitor and FinanceSystem.
+        """
+        return self.finance.get_financial_snapshot()
+
     def liquidate_assets(self) -> float:
         """
         Liquidate assets.
@@ -210,6 +371,36 @@ class Firm(BaseAgent, ILearningAgent):
     def produce(self, current_time: int, technology_manager: Optional[Any] = None) -> None:
         self.current_production = self.production.produce(current_time, technology_manager)
 
+    def issue_shares(self, quantity: float, price: float) -> float:
+        """
+        신규 주식을 발행합니다 (유상증자).
+        
+        Args:
+            quantity: 발행할 주식 수량
+            price: 주당 발행 가격
+            
+        Returns:
+            조달된 자본금
+        """
+        return self.finance.issue_shares(quantity, price)
+
+    def get_book_value_per_share(self) -> float:
+        """주당 순자산가치(BPS)를 계산합니다. (유통주식수 기준)"""
+        return self.finance.get_book_value_per_share()
+
+    def get_market_cap(self, stock_price: Optional[float] = None) -> float:
+        """
+        시가총액을 계산합니다.
+        
+        Args:
+            stock_price: 주가 (None이면 순자산가치 기반 계산)
+            
+        Returns:
+            시가총액
+        """
+        return self.finance.get_market_cap(stock_price)
+
+
     @override
     def clone(self, new_id: int, initial_assets_from_parent: float, current_tick: int) -> "Firm":
         """
@@ -242,6 +433,10 @@ class Firm(BaseAgent, ILearningAgent):
         )
         return new_firm
 
+    def distribute_dividends(self, households: List[Household], government: "Government", current_time: int) -> List[Transaction]:
+        # SoC Refactor
+        return self.finance.process_profit_distribution(households, government, current_time)
+
     @override
     def get_agent_data(self) -> Dict[str, Any]:
         """AI 의사결정에 필요한 에이전트의 현재 상태 데이터를 반환합니다."""
@@ -250,16 +445,14 @@ class Firm(BaseAgent, ILearningAgent):
             "needs": self.needs.copy(),
             "inventory": self.inventory.copy(),
             "input_inventory": self.input_inventory.copy(), # WO-030
-            # SoC Refactor
-            "employees": [emp.id for emp in self.hr.employees],  # Only pass employee IDs
+            "employees": [emp.id for emp in self.employees],  # Only pass employee IDs
             "is_active": self.is_active,
             "current_production": self.current_production,
             "productivity_factor": self.productivity_factor,
             "production_target": self.production_target,
-            # SoC Refactor
-            "revenue_this_turn": self.finance.revenue_this_turn,
-            "expenses_this_tick": self.finance.expenses_this_tick,
-            "consecutive_loss_turns": self.finance.consecutive_loss_turns,
+            "revenue_this_turn": self.revenue_this_turn,
+            "expenses_this_tick": self.expenses_this_tick,
+            "consecutive_loss_turns": self.consecutive_loss_turns,
             "total_shares": self.total_shares,
             "treasury_shares": self.treasury_shares,
             "dividend_rate": self.dividend_rate,
@@ -279,13 +472,12 @@ class Firm(BaseAgent, ILearningAgent):
         self, markets: Dict[str, Any], goods_data: list[Dict[str, Any]], market_data: Dict[str, Any], current_time: int, government: Optional[Any] = None, reflux_system: Optional[Any] = None, stress_scenario_config: Optional["StressScenarioConfig"] = None
     ) -> tuple[list[Order], Any]:
         log_extra = {"tick": current_time, "agent_id": self.id, "tags": ["firm_action"]}
-        # SoC Refactor
         self.logger.debug(
-            f"FIRM_DECISION_START | Firm {self.id} before decision: Assets={self.assets:.2f}, Employees={len(self.hr.employees)}, is_active={self.is_active}",
+            f"FIRM_DECISION_START | Firm {self.id} before decision: Assets={self.assets:.2f}, Employees={len(self.employees)}, is_active={self.is_active}",
             extra={
                 **log_extra,
                 "assets_before": self.assets,
-                "num_employees_before": len(self.hr.employees),
+                "num_employees_before": len(self.employees),
                 "is_active_before": self.is_active,
             },
         )
@@ -304,13 +496,12 @@ class Firm(BaseAgent, ILearningAgent):
         # WO-056: Shadow Mode Calculation
         self._calculate_invisible_hand_price(markets, current_time)
 
-        # SoC Refactor
         self.logger.debug(
-            f"FIRM_DECISION_END | Firm {self.id} after decision: Assets={self.assets:.2f}, Employees={len(self.hr.employees)}, is_active={self.is_active}, Decisions={len(decisions)}",
+            f"FIRM_DECISION_END | Firm {self.id} after decision: Assets={self.assets:.2f}, Employees={len(self.employees)}, is_active={self.is_active}, Decisions={len(decisions)}",
             extra={
                 **log_extra,
                 "assets_after": self.assets,
-                "num_employees_after": len(self.hr.employees),
+                "num_employees_after": len(self.employees),
                 "is_active_after": self.is_active,
                 "num_decisions": len(decisions),
             },
@@ -369,14 +560,13 @@ class Firm(BaseAgent, ILearningAgent):
     @override
     def update_needs(self, current_time: int, government: Optional[Any] = None, market_data: Optional[Dict[str, Any]] = None, reflux_system: Optional[Any] = None, technology_manager: Optional[Any] = None) -> None:
         log_extra = {"tick": current_time, "agent_id": self.id, "tags": ["firm_needs"]}
-        # SoC Refactor
         self.logger.debug(
-            f"FIRM_NEEDS_UPDATE_START | Firm {self.id} needs before update: Liquidity={self.needs['liquidity_need']:.1f}, Assets={self.assets:.2f}, Employees={len(self.hr.employees)}",
+            f"FIRM_NEEDS_UPDATE_START | Firm {self.id} needs before update: Liquidity={self.needs['liquidity_need']:.1f}, Assets={self.assets:.2f}, Employees={len(self.employees)}",
             extra={
                 **log_extra,
                 "needs_before": self.needs,
                 "assets_before": self.assets,
-                "num_employees_before": len(self.hr.employees),
+                "num_employees_before": len(self.employees),
             },
         )
 
@@ -402,13 +592,12 @@ class Firm(BaseAgent, ILearningAgent):
         if total_wages > 0:
             self.finance.record_expense(total_wages)
             self.logger.info(
-                f"Paid total wages: {total_wages:.2f} to {len(self.hr.employees)} employees.",
+                f"Paid total wages: {total_wages:.2f} to {len(self.employees)} employees.",
                 extra={**log_extra, "total_wages": total_wages},
             )
 
         # 3. Marketing & Brand Update
         marketing_spend = 0.0
-        # SoC Refactor
         if self.assets > 100.0:
             marketing_spend = max(10.0, self.finance.revenue_this_turn * self.marketing_budget_rate)
         
@@ -446,26 +635,25 @@ class Firm(BaseAgent, ILearningAgent):
         self.needs["liquidity_need"] = min(100.0, self.needs["liquidity_need"] + self.config_module.LIQUIDITY_NEED_INCREASE_RATE)
         self.finance.check_bankruptcy()
 
-        # SoC Refactor
-        if self.assets <= self.config_module.ASSETS_CLOSURE_THRESHOLD or self.finance.consecutive_loss_turns >= self.config_module.FIRM_CLOSURE_TURNS_THRESHOLD:
+        if self.assets <= self.config_module.ASSETS_CLOSURE_THRESHOLD or self.consecutive_loss_turns >= self.config_module.FIRM_CLOSURE_TURNS_THRESHOLD:
             self.is_active = False
             self.logger.warning(
-                f"FIRM_INACTIVE | Firm {self.id} closed down. Assets: {self.assets:.2f}, Consecutive Loss Turns: {self.finance.consecutive_loss_turns}",
+                f"FIRM_INACTIVE | Firm {self.id} closed down. Assets: {self.assets:.2f}, Consecutive Loss Turns: {self.consecutive_loss_turns}",
                 extra={
                     **log_extra,
                     "assets": self.assets,
-                    "consecutive_loss_turns": self.finance.consecutive_loss_turns,
+                    "consecutive_loss_turns": self.consecutive_loss_turns,
                     "tags": ["firm_closure"],
                 },
             )
 
         self.logger.debug(
-            f"FIRM_NEEDS_UPDATE_END | Firm {self.id} needs after update: Liquidity={self.needs['liquidity_need']:.1f}, Assets={self.assets:.2f}, Employees={len(self.hr.employees)}, is_active={self.is_active}",
+            f"FIRM_NEEDS_UPDATE_END | Firm {self.id} needs after update: Liquidity={self.needs['liquidity_need']:.1f}, Assets={self.assets:.2f}, Employees={len(self.employees)}, is_active={self.is_active}",
             extra={
                 **log_extra,
                 "needs_after": self.needs,
                 "assets_after": self.assets,
-                "num_employees_after": len(self.hr.employees),
+                "num_employees_after": len(self.employees),
                 "is_active_after": self.is_active,
                 "brand_awareness": self.brand_manager.brand_awareness,
                 "perceived_quality": self.brand_manager.perceived_quality
diff --git a/simulation/initialization/initializer.py b/simulation/initialization/initializer.py
index 49eeff2..7847fbf 100644
--- a/simulation/initialization/initializer.py
+++ b/simulation/initialization/initializer.py
@@ -129,7 +129,7 @@ class SimulationInitializer(SimulationInitializerInterface):
             government=sim.government,
             central_bank=sim.central_bank,
             bank=sim.bank,
-            config_module=self.config
+            config_module=self.config_manager
         )
         sim.government.finance_system = sim.finance_system
 
diff --git a/simulation/systems/immigration_manager.py b/simulation/systems/immigration_manager.py
index 6b43e79..ddea6bf 100644
--- a/simulation/systems/immigration_manager.py
+++ b/simulation/systems/immigration_manager.py
@@ -31,8 +31,9 @@ class ImmigrationManager:
         indicators = engine.tracker.get_latest_indicators()
         unemployment_rate = indicators.get("unemployment_rate", 1.0)
 
-        market_data = engine._prepare_market_data(engine.tracker)
-        job_vacancies = market_data.get("job_vacancies", 0)
+        job_vacancies = 0
+        if "labor" in engine.markets:
+             job_vacancies = engine.markets["labor"].get_total_demand()
 
         total_population = len([h for h in engine.households if h.is_active])
         pop_threshold = getattr(self.config, "POPULATION_IMMIGRATION_THRESHOLD", 80)
diff --git a/simulation/systems/lifecycle_manager.py b/simulation/systems/lifecycle_manager.py
index ea7438a..eb76be4 100644
--- a/simulation/systems/lifecycle_manager.py
+++ b/simulation/systems/lifecycle_manager.py
@@ -88,12 +88,11 @@ class AgentLifecycleManager(AgentLifecycleManagerInterface):
                 f"Assets: {firm.assets:.2f}, Inventory: {sum(firm.inventory.values()):.2f}",
                 extra={"agent_id": firm.id, "tags": ["liquidation"]}
             )
-            # SoC Refactor: use hr.employees
-            for employee in firm.hr.employees:
+            for employee in firm.employees:
                 if employee.is_active:
                     employee.is_employed = False
                     employee.employer_id = None
-            firm.hr.employees = []
+            firm.employees = []
             firm.inventory.clear()
             firm.capital_stock = 0.0
             total_cash = firm.assets
@@ -143,7 +142,6 @@ class AgentLifecycleManager(AgentLifecycleManagerInterface):
         sim.agents[sim.bank.id] = sim.bank
 
         for firm in sim.firms:
-            # SoC Refactor: use hr.employees
-            firm.hr.employees = [
-                emp for emp in firm.hr.employees if emp.is_active and emp.id in sim.agents
+            firm.employees = [
+                emp for emp in firm.employees if emp.is_active and emp.id in sim.agents
             ]
diff --git a/simulation/systems/ma_manager.py b/simulation/systems/ma_manager.py
index 8764567..45cbe2d 100644
--- a/simulation/systems/ma_manager.py
+++ b/simulation/systems/ma_manager.py
@@ -53,8 +53,7 @@ class MAManager:
                 continue
             
             # Standard Distress (Friendly M&A)
-            # SoC Refactor: use finance.consecutive_loss_turns
-            if firm.finance.consecutive_loss_turns >= self.bankruptcy_loss_threshold:
+            if firm.consecutive_loss_turns >= self.bankruptcy_loss_threshold:
                  preys.append(firm)
             elif firm.assets < avg_assets * 0.2:
                 preys.append(firm)
@@ -84,8 +83,7 @@ class MAManager:
             # Or just be rich.
             # Phase 21 Spec: Predator Assets > Target Market Cap * 1.5.
             # Let's filter later. Just identify rich firms.
-            # SoC Refactor: use finance.current_profit
-            if firm.assets > avg_assets * 1.5 and firm.finance.current_profit > 0:
+            if firm.assets > avg_assets * 1.5 and firm.current_profit > 0:
                 predators.append(firm)
 
         # 2. M&A Matching Loop
@@ -188,8 +186,7 @@ class MAManager:
              self.simulation.households_dict[prey.founder_id].assets += price
         
         # 2. Asset Transfer
-        # SoC Refactor: use production.add_capital
-        predator.production.add_capital(prey.capital_stock)
+        predator.capital_stock += prey.capital_stock
         
         # Phase 21: Transfer Automation Tech?
         # If prey has higher automation, predator learns?
@@ -197,8 +194,7 @@ class MAManager:
         # Let's say Predator keeps their own logic, maybe slight boost if Prey was advanced.
         if hasattr(prey, "automation_level") and hasattr(predator, "automation_level"):
             if prey.automation_level > predator.automation_level:
-                new_level = (predator.automation_level + prey.automation_level) / 2.0
-                predator.production.set_automation_level(new_level)
+                predator.automation_level = (predator.automation_level + prey.automation_level) / 2.0
 
         # Inventory
         for item, qty in prey.inventory.items():
@@ -211,17 +207,16 @@ class MAManager:
         # Hostile Takeovers often have deeper cuts
         retention_rate = 0.3 if is_hostile else 0.5
 
-        # SoC Refactor: use hr.employees and hr.hire
-        for emp in list(prey.hr.employees):
+        for emp in list(prey.employees):
             if random.random() > retention_rate:
                 # Fire
                 emp.quit()
                 fired_count += 1
             else:
                 # Retain
-                prey.hr.remove_employee(emp)
-                wage = prey.hr.employee_wages.get(emp.id, 10.0)
-                predator.hr.hire(emp, wage)
+                prey.employees.remove(emp)
+                predator.employees.append(emp)
+                predator.employee_wages[emp.id] = prey.employee_wages.get(emp.id, 10.0)
                 emp.employer_id = predator.id
                 retained_count += 1
                 
@@ -234,8 +229,7 @@ class MAManager:
         recovered = firm.liquidate_assets()
         self.logger.info(f"BANKRUPTCY | Firm {firm.id} liquidated. Recovered Cash: {recovered:,.2f}.")
         
-        # SoC Refactor: use hr.employees
-        for emp in list(firm.hr.employees):
+        for emp in list(firm.employees):
             emp.quit()
             
         firm.is_active = False
diff --git a/simulation/systems/transaction_processor.py b/simulation/systems/transaction_processor.py
index e078897..a4d7830 100644
--- a/simulation/systems/transaction_processor.py
+++ b/simulation/systems/transaction_processor.py
@@ -110,9 +110,8 @@ class TransactionProcessor:
         if isinstance(seller, Household):
             if seller.is_employed and seller.employer_id is not None and seller.employer_id != buyer.id:
                 previous_employer = agents.get(seller.employer_id)
-                if isinstance(previous_employer, Firm):
-                    # SoC Refactor: Use HRDepartment
-                    previous_employer.hr.remove_employee(seller)
+                if isinstance(previous_employer, Firm) and seller in previous_employer.employees:
+                    previous_employer.employees.remove(seller)
 
             seller.is_employed = True
             seller.employer_id = buyer.id
@@ -122,13 +121,10 @@ class TransactionProcessor:
                 seller.labor_income_this_tick += (trade_value - tax_amount)
 
         if isinstance(buyer, Firm):
-            # SoC Refactor: Use HRDepartment and FinanceDepartment
-            if seller not in buyer.hr.employees:
-                buyer.hr.hire(seller, tx.price)
-            else:
-                 buyer.hr.employee_wages[seller.id] = tx.price
-
-            buyer.finance.record_expense(trade_value)
+            if seller not in buyer.employees:
+                buyer.employees.append(seller)
+            buyer.employee_wages[seller.id] = tx.price
+            buyer.cost_this_turn += trade_value
 
             if tx.transaction_type == "research_labor":
                 research_skill = seller.skills.get("research", Skill("research")).value
@@ -158,9 +154,8 @@ class TransactionProcessor:
                 buyer.inventory[tx.item_id] = total_new_qty
 
         if isinstance(seller, Firm):
-            # SoC Refactor: Use FinanceDepartment
-            seller.finance.record_revenue(trade_value)
-            seller.finance.sales_volume_this_tick += tx.quantity
+            seller.revenue_this_turn += trade_value
+            seller.sales_volume_this_tick += tx.quantity
         
         if isinstance(buyer, Household):
             if not is_service:
diff --git a/tests/test_corporate_manager.py b/tests/test_corporate_manager.py
index 3fb5018..eccce0f 100644
--- a/tests/test_corporate_manager.py
+++ b/tests/test_corporate_manager.py
@@ -15,11 +15,6 @@ class MockConfig:
     MAX_SELL_QUANTITY = 100
     LABOR_MARKET_MIN_WAGE = 10.0
     GOODS = {"food": {"production_cost": 10.0}}
-    # Added for automation
-    AUTOMATION_COST_PER_PCT = 1000.0
-    FIRM_SAFETY_MARGIN = 2000.0
-    AUTOMATION_TAX_RATE = 0.05
-    SEVERANCE_PAY_WEEKS = 4
 
 @pytest.fixture
 def firm_mock(golden_firms):
@@ -27,57 +22,16 @@ def firm_mock(golden_firms):
         pytest.skip("Golden firms fixture is empty or failed to load.")
     firm = golden_firms[0]
 
-    # Initialize BaseAgent fields
-    firm.assets = 10000.0 # Default assets
-
-    # --- SoC Components Mocking ---
-    firm.finance = MagicMock()
-    firm.finance.revenue_this_turn = 200.0
-    firm.finance.last_sales_volume = 1.0
-    firm.finance.last_revenue = 200.0
-
-    # Side effects to simulate real behavior on mock firm assets
-    def invest_side_effect(amount):
-        firm.assets -= amount
-        return True
-
-    def pay_tax_side_effect(amount, *args, **kwargs):
-        firm.assets -= amount
-        return True
-
-    def pay_severance_side_effect(emp, amount):
-        firm.assets -= amount
-        # emp is a mock, so emp.assets update is mocked
-        if hasattr(emp, 'assets'):
-             emp.assets += amount
-        return True
-
-    def set_dividend_rate_side_effect(rate):
-        firm.dividend_rate = rate
-
-    firm.finance.invest_in_automation.side_effect = invest_side_effect
-    firm.finance.invest_in_rd.side_effect = invest_side_effect
-    firm.finance.invest_in_capex.side_effect = invest_side_effect
-    firm.finance.pay_severance.side_effect = pay_severance_side_effect
-    firm.finance.pay_ad_hoc_tax.side_effect = pay_tax_side_effect
-    firm.finance.set_dividend_rate.side_effect = set_dividend_rate_side_effect
-    firm.finance.get_book_value_per_share.return_value = 10.0 # Default BPS
-
-    firm.hr = MagicMock()
-    firm.hr.employees = []
-    firm.hr.employee_wages = {}
-
-    firm.production = MagicMock()
-    firm.production.set_automation_level.side_effect = lambda x: setattr(firm, 'automation_level', x)
-    firm.production.add_capital.side_effect = lambda x: setattr(firm, 'capital_stock', firm.capital_stock + x)
-
-    firm.sales = MagicMock()
-    firm.sales.set_price.side_effect = lambda item, price: firm.last_prices.update({item: price})
-
-    # --- Firm Attributes ---
+    # Customize the golden firm for specific tests if needed,
+    # but the goal is to rely on realistic data.
+    # Resetting some values to ensure consistent test state regardless of fixture content
+    # is still reasonable, but we should avoid full mock reconstruction.
+
+    firm.revenue_this_turn = 200.0
     firm.production_target = 100
     firm.productivity_factor = 1.0
     firm.specialization = "food"
+    # Ensure inventory is dictionary as expected by tests
     if not isinstance(firm.inventory, dict):
         firm.inventory = {"food": 50}
     else:
@@ -90,14 +44,27 @@ def firm_mock(golden_firms):
     firm.total_shares = 100
     firm.treasury_shares = 0
     firm.last_prices = {"food": 10.0}
+    firm.employees = []
+    # firm.personality is likely already set in golden fixture, but ensuring it matches test expectation if crucial
     firm.personality = Personality.BALANCED
 
-    firm.system2_planner = None
+    # Ensuring attributes that might be missing in older fixtures or dynamic properties
+    firm.system2_planner = None # Force to None to avoid unconfigured mock issues in guidance
+    firm.revenue_this_turn = 200.0 # explicit float
+    firm.last_revenue = 200.0
+    if not hasattr(firm, 'last_revenue'):
+        firm.last_revenue = 200.0
+    firm.expenses_this_tick = 50.0
+    firm.retained_earnings = 1000.0
+    # firm.profit_history = [] # Let's keep history if it exists
+    firm.employee_wages = {}
     firm.consecutive_loss_ticks_for_bankruptcy_threshold = 5
     firm.automation_level = 0.0
-    firm.total_debt = 0.0
-    firm.bond_obligations = []
+    firm.last_sales_volume = 1.0 # Fix for the TypeError seen in previous run
+    firm.total_debt = 0.0 # Ensure total_debt is float
+    firm.bond_obligations = [] # Add bond obligations
 
+    # Ensure decision_engine chain works for _get_total_liabilities
     if not hasattr(firm, 'decision_engine'):
         firm.decision_engine = MagicMock()
 
@@ -139,7 +106,7 @@ def test_rd_logic(firm_mock, context_mock, monkeypatch):
 
     # Need enough assets to pass safety margin (default 2000)
     firm_mock.assets = 10000.0
-    firm_mock.finance.revenue_this_turn = 1000.0 # Set on finance
+    firm_mock.revenue_this_turn = 1000.0
     expected_budget = 1000.0 * 0.2 # 200
 
     # Force success
@@ -150,7 +117,9 @@ def test_rd_logic(firm_mock, context_mock, monkeypatch):
 
     manager.realize_ceo_actions(firm_mock, context_mock, vector)
 
-    assert firm_mock.assets == 10000.0 - expected_budget
+    # Verify delegation to finance
+    firm_mock.finance.invest_in_rd.assert_called_with(expected_budget)
+
     assert firm_mock.base_quality == pytest.approx(initial_quality + 0.05)
     assert firm_mock.productivity_factor == pytest.approx(initial_prod * 1.05)
 
@@ -179,6 +148,11 @@ def test_hiring_logic(firm_mock, context_mock):
 
 def test_debt_logic_borrow(firm_mock, context_mock):
     manager = CorporateManager(MockConfig())
+    # Assets 1000 (from setup), Debt 0 (assumed default in mock). Leverage 0.
+    # Aggressiveness 0.5 -> Target 1.0 Leverage (1000 Debt)
+    # Ensure total_assets and total_debt are set if computed properties are used
+    # But since it is a mock, we might need to set them if logic depends on them.
+    # The original test manually set assets=1000.
     firm_mock.assets = 1000.0
     firm_mock.total_debt = 0.0
 
diff --git a/tests/test_finance_bailout.py b/tests/test_finance_bailout.py
index 702df77..f2a169b 100644
--- a/tests/test_finance_bailout.py
+++ b/tests/test_finance_bailout.py
@@ -9,6 +9,13 @@ class MockConfig:
     BAILOUT_PENALTY_PREMIUM = 0.05
     BAILOUT_REPAYMENT_RATIO = 0.5
 
+    def get(self, key, default=None):
+        if key == "economy_params.bailout_penalty_premium":
+            return self.BAILOUT_PENALTY_PREMIUM
+        if key == "economy_params.bailout_repayment_ratio":
+            return self.BAILOUT_REPAYMENT_RATIO
+        return default
+
 @pytest.fixture
 def finance_test_environment():
     """Sets up a test environment with mocked financial entities."""
diff --git a/tests/test_firms.py b/tests/test_firms.py
index 743866f..47eeb69 100644
--- a/tests/test_firms.py
+++ b/tests/test_firms.py
@@ -39,7 +39,7 @@ class TestFirmBookValue:
     def test_book_value_no_liabilities(self, firm):
         # Assets 1000, Shares 100, Treasury 100
         firm.treasury_shares = 0
-        assert firm.finance.get_book_value_per_share() == 10.0
+        assert firm.get_book_value_per_share() == 10.0
 
     def test_book_value_with_liabilities(self, firm, mock_decision_engine):
         # Setup Liabilities
@@ -53,12 +53,12 @@ class TestFirmBookValue:
         mock_bank.get_debt_summary.return_value = {"total_principal": 200.0}
 
         # Net Assets = 1000 - 200 = 800. Shares 100.
-        assert firm.finance.get_book_value_per_share() == 8.0
+        assert firm.get_book_value_per_share() == 8.0
 
     def test_book_value_with_treasury_shares(self, firm):
         firm.treasury_shares = 20.0
         # Assets 1000. Outstanding Shares 80.
-        assert firm.finance.get_book_value_per_share() == 12.5
+        assert firm.get_book_value_per_share() == 12.5
 
     def test_book_value_negative_net_assets(self, firm, mock_decision_engine):
          # Setup Huge Liabilities
@@ -72,12 +72,12 @@ class TestFirmBookValue:
 
         # Net Assets = 1000 - 2000 = -1000.
         # Should return 0.0
-        assert firm.finance.get_book_value_per_share() == 0.0
+        assert firm.get_book_value_per_share() == 0.0
 
     def test_book_value_zero_shares(self, firm):
         firm.total_shares = 0.0
         firm.treasury_shares = 0.0
-        assert firm.finance.get_book_value_per_share() == 0.0
+        assert firm.get_book_value_per_share() == 0.0
 
 class TestProductionDepartment:
     @pytest.fixture
