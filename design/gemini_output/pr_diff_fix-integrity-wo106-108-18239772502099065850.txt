diff --git a/design/TECH_DEBT_LEDGER.md b/design/TECH_DEBT_LEDGER.md
index a28dbef..363aaa8 100644
--- a/design/TECH_DEBT_LEDGER.md
+++ b/design/TECH_DEBT_LEDGER.md
@@ -4,7 +4,7 @@
 
 | ID | Date | Description | Impact | Status |
 |---|---|---|---|---|
-| TD-085 | 2026-01-22 | Decision Mutual Exclusivity Bug (StandaloneRuleBasedFirmDecisionEngine) | Firms fail to hire labor when expanding production | **OPEN** |
+| - | - | ÌòÑÏû¨ Î∏îÎ°úÏª§ ÏóÜÏùå | - | - |
 
 ## üü° DEFERRED (Phase 27+ ÏÉÅÌôò ÏòàÏ†ï)
 
diff --git a/design/project_status.md b/design/project_status.md
index 21767c8..31b0158 100644
--- a/design/project_status.md
+++ b/design/project_status.md
@@ -32,13 +32,7 @@
     - **Phase 3**: DTO Decoupling & Data Flow Purity ‚úÖ (Merged 2026-01-21)
     - **Impact**: Eliminated race conditions, enforced Sacred Sequence (Decisions‚ÜíMatching‚ÜíTransactions‚ÜíLifecycle), completed DTO migration
 
-- **ÌòÑÏû¨ Îã®Í≥Ñ:** `Engine Repair Phase` ('ÏóîÏßÑ ÏàòÎ¶¨ Îã®Í≥Ñ') üîß
-    - **WO-106**: Operation Heart Lung (Economic Integrity Fixes) ‚úÖ
-    - **WO-107**: Structural Decoupling ‚úÖ
-    - **WO-108**: DTO Parity Alignment ‚úÖ
-    - **Target**: Fix Decision Mutual Exclusivity Bug (TD-085) & Stabilize Engine
-
-- **ÏôÑÎ£åÎêú Îã®Í≥Ñ(Previous):** `Phase 23: The Great Expansion (Industrial Revolution)` üöÄ
+- **ÌòÑÏû¨ Îã®Í≥Ñ:** `Phase 23: The Great Expansion (Industrial Revolution)` üöÄ
     - **WO-053**: Industrial Revolution (TechnologyManager) ‚úÖ (Implementation Complete)
     - **WO-092**: Household Facade Refactor (TD-075) ‚úÖ (Refactor Complete)
     - **Goal**: Break Malthusian Trap via "Chemical Fertilizer" (Food TFP x3.0)
diff --git a/simulation/decisions/corporate_manager.py b/simulation/decisions/corporate_manager.py
index 38da1a3..b2ba55c 100644
--- a/simulation/decisions/corporate_manager.py
+++ b/simulation/decisions/corporate_manager.py
@@ -44,6 +44,9 @@ class CorporateManager:
 
         guidance = firm.system2_planner.project_future(context.current_time, context.market_data)
 
+        # 0. Production Target Adjustment (Restored Logic)
+        self._manage_production_target(firm)
+
         # 0. Procurement Channel (Raw Materials) - WO-030
         procurement_orders = self._manage_procurement(firm, context.market_data, context.markets)
         orders.extend(procurement_orders)
@@ -468,8 +471,8 @@ class CorporateManager:
         current_inventory = firm.inventory.get(firm.specialization, 0)
         inventory_gap = target_inventory - current_inventory
 
-        if inventory_gap <= 0:
-            return []
+        # if inventory_gap <= 0:
+        #    return []
 
         # Calculate needed labor with Cobb-Douglas inversion?
         # Y = TFP * L^alpha * K^beta
@@ -488,12 +491,15 @@ class CorporateManager:
         if tfp <= 0: tfp = 1.0
 
         needed_labor_calc = 0.0
-        try:
-             # term = Y / (TFP * K^beta)
-             term = inventory_gap / (tfp * (capital ** beta_adjusted))
-             needed_labor_calc = term ** (1.0 / alpha_adjusted)
-        except Exception:
-             needed_labor_calc = 1.0 # Fallback
+        if inventory_gap > 0:
+            try:
+                 # term = Y / (TFP * K^beta)
+                 term = inventory_gap / (tfp * (capital ** beta_adjusted))
+                 needed_labor_calc = term ** (1.0 / alpha_adjusted)
+            except Exception:
+                 needed_labor_calc = 1.0 # Fallback
+        else:
+            needed_labor_calc = 0.0
 
         # Soft limit removed to allow full employment
         needed_labor = int(needed_labor_calc) + 1
@@ -627,3 +633,30 @@ class CorporateManager:
 
         # Ensure we don't accidentally lower it below base
         return max(base_offer_wage, new_wage)
+
+    def _manage_production_target(self, firm: Firm) -> None:
+        """
+        Adjust Production Target based on Inventory Levels.
+        Uses Rule-Based Logic (Legacy behavior restored).
+        """
+        item = firm.specialization
+        current_inventory = firm.inventory.get(item, 0.0)
+        target = firm.production_target
+
+        # Parameters
+        overstock_threshold = getattr(self.config_module, "OVERSTOCK_THRESHOLD", 1.2)
+        understock_threshold = getattr(self.config_module, "UNDERSTOCK_THRESHOLD", 0.8)
+        adj_factor = getattr(self.config_module, "PRODUCTION_ADJUSTMENT_FACTOR", 0.1)
+        min_target = getattr(self.config_module, "FIRM_MIN_PRODUCTION_TARGET", 10.0)
+        max_target = getattr(self.config_module, "FIRM_MAX_PRODUCTION_TARGET", 500.0)
+
+        # Logic
+        if current_inventory > target * overstock_threshold:
+            # Reduce Target
+            new_target = target * (1.0 - adj_factor)
+            firm.production_target = max(min_target, new_target)
+
+        elif current_inventory < target * understock_threshold:
+            # Increase Target
+            new_target = target * (1.0 + adj_factor)
+            firm.production_target = min(max_target, new_target)
diff --git a/tests/modules/finance/test_double_entry.py b/tests/modules/finance/test_double_entry.py
index 6f3a877..82c8bc5 100644
--- a/tests/modules/finance/test_double_entry.py
+++ b/tests/modules/finance/test_double_entry.py
@@ -63,6 +63,15 @@ class MockConfig:
     BAILOUT_PENALTY_PREMIUM = 0.05
     BAILOUT_REPAYMENT_RATIO = 0.5
 
+    def get(self, key, default=None):
+        if key == "economy_params.BAILOUT_PENALTY_PREMIUM":
+            return self.BAILOUT_PENALTY_PREMIUM
+        if key == "economy_params.DEBT_RISK_PREMIUM_TIERS":
+            return self.DEBT_RISK_PREMIUM_TIERS
+        if key == "economy_params.QE_INTERVENTION_YIELD_THRESHOLD":
+            return self.QE_INTERVENTION_YIELD_THRESHOLD
+        return default
+
 
 class TestDoubleEntry(unittest.TestCase):
 
diff --git a/tests/test_firm_decision_engine_new.py b/tests/test_firm_decision_engine_new.py
index 47cf19d..bee3593 100644
--- a/tests/test_firm_decision_engine_new.py
+++ b/tests/test_firm_decision_engine_new.py
@@ -4,7 +4,7 @@ from collections import deque
 
 from simulation.decisions.ai_driven_firm_engine import AIDrivenFirmDecisionEngine
 from simulation.firms import Firm
-from simulation.ai.enums import Tactic, Aggressiveness
+from simulation.schemas import FirmActionVector
 from simulation.dtos import DecisionContext
 
 
@@ -15,7 +15,6 @@ def mock_logger():
         "simulation.decisions.ai_driven_firm_engine.logging.getLogger"
     ) as mock_get_logger:
         mock_logger_instance = MagicMock(name="firm_decision_engine_logger")
-        # ... (rest of the mock setup)
         mock_get_logger.return_value = mock_logger_instance
         yield mock_logger_instance
 
@@ -45,6 +44,28 @@ def mock_config():
     mock_cfg.AI_PRICE_ADJUSTMENT_MEDIUM = 0.10
     mock_cfg.AI_PRICE_ADJUSTMENT_LARGE = 0.15
     mock_cfg.PROFIT_HISTORY_TICKS = 10
+
+    # Hiring Params
+    mock_cfg.LABOR_ALPHA = 0.7
+    mock_cfg.AUTOMATION_LABOR_REDUCTION = 0.5
+    mock_cfg.LABOR_MARKET_MIN_WAGE = 8.0
+
+    # Automation
+    mock_cfg.AUTOMATION_COST_PER_PCT = 1000.0
+    mock_cfg.FIRM_SAFETY_MARGIN = 2000.0
+    mock_cfg.AUTOMATION_TAX_RATE = 0.05
+    mock_cfg.CAPITAL_TO_OUTPUT_RATIO = 2.0
+    mock_cfg.ALTMAN_Z_SCORE_THRESHOLD = 1.81
+    mock_cfg.DIVIDEND_SUSPENSION_LOSS_TICKS = 3
+    mock_cfg.DIVIDEND_RATE_MIN = 0.1
+    mock_cfg.DIVIDEND_RATE_MAX = 0.5
+    mock_cfg.SEVERANCE_PAY_WEEKS = 4
+
+    # SEO
+    mock_cfg.STARTUP_COST = 30000.0
+    mock_cfg.SEO_TRIGGER_RATIO = 0.5
+    mock_cfg.SEO_MAX_SELL_RATIO = 0.1
+
     return mock_cfg
 
 
@@ -63,15 +84,47 @@ def mock_firm(mock_config):
     firm.profit_history = deque(maxlen=mock_config.PROFIT_HISTORY_TICKS)
     firm.specialization = "food"
     firm.logger = MagicMock()
-    firm.age = 25 # Add age for solvency checks
-    firm.finance = Mock() # Mock the finance department
-    firm.hr = Mock() # Mock the HR department
+    firm.age = 25
+    firm.finance = Mock()
+    firm.finance.revenue_this_turn = 0.0
+    firm.finance.last_revenue = 0.0
+    firm.finance.calculate_altman_z_score.return_value = 3.0
+    firm.finance.consecutive_loss_turns = 0
+    firm.finance.last_sales_volume = 100.0
+    firm.hr = Mock()
+    firm.hr.employees = []
+    firm.hr.employee_wages = {}
+    firm.treasury_shares = 1000.0
+    firm.research_history = {"total_spent": 0.0, "success_count": 0, "last_success_tick": 0}
+    firm.base_quality = 1.0
+    firm.sales = Mock()
+    firm.production = Mock() # Add production mock
+    firm.production.set_automation_level = Mock()
+    firm.production.add_capital = Mock()
+    firm.automation_level = 0.0
+    firm.capital_stock = 100.0
+    firm.system2_planner = Mock()
+    firm.system2_planner.project_future.return_value = {} # Default guidance
+
+    # Mock get_agent_data for AI
+    firm.get_agent_data.return_value = {}
+
     return firm
 
 
 @pytest.fixture
 def mock_ai_engine():
-    return Mock()
+    ai = Mock()
+    # Default behavior: Neutral vector
+    ai.decide_action_vector.return_value = FirmActionVector(
+        sales_aggressiveness=0.5,
+        hiring_aggressiveness=0.5,
+        rd_aggressiveness=0.5,
+        capital_aggressiveness=0.5,
+        dividend_aggressiveness=0.5,
+        debt_aggressiveness=0.5
+    )
+    return ai
 
 
 @pytest.fixture
@@ -79,7 +132,7 @@ def firm_decision_engine_instance(mock_config, mock_ai_engine):
     engine = AIDrivenFirmDecisionEngine(
         ai_engine=mock_ai_engine, config_module=mock_config
     )
-    engine.rule_based_engine._calculate_dynamic_wage_offer = Mock(return_value=10.0)
+    # Remove old rule_based_engine mock injection
     return engine
 
 
@@ -87,30 +140,25 @@ class TestFirmDecisionEngine:
     def test_initialization(
         self, firm_decision_engine_instance, mock_ai_engine, mock_config
     ):
-        # Check that the internal rule_based_engine was created and configured
-        assert firm_decision_engine_instance.rule_based_engine is not None
+        assert firm_decision_engine_instance.corporate_manager is not None
         assert firm_decision_engine_instance.ai_engine == mock_ai_engine
         assert firm_decision_engine_instance.config_module == mock_config
 
     def test_make_decisions_overstock_reduces_target(
         self, firm_decision_engine_instance, mock_firm, mock_config
     ):
-        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
-            Tactic.ADJUST_PRODUCTION, Aggressiveness.NORMAL
-        )
         mock_firm.inventory["food"] = 150.0 # Force overstock (150 > 100 * 1.2)
-
         initial_target = mock_firm.production_target
 
         context = DecisionContext(
             firm=mock_firm,
-            markets={},
+            markets={"food": Mock()},
             goods_data=[],
             market_data={},
             current_time=1,
             government=None,
         )
-        orders, _ = firm_decision_engine_instance.make_decisions(context)
+        firm_decision_engine_instance.make_decisions(context)
 
         expected_target = max(
             mock_config.FIRM_MIN_PRODUCTION_TARGET,
@@ -123,19 +171,16 @@ class TestFirmDecisionEngine:
     ):
         mock_firm.inventory["food"] = 50.0
         initial_target = mock_firm.production_target
-        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
-            Tactic.ADJUST_PRODUCTION, Aggressiveness.NORMAL
-        )
 
         context = DecisionContext(
             firm=mock_firm,
-            markets={},
+            markets={"food": Mock()},
             goods_data=[],
             market_data={},
             current_time=1,
             government=None,
         )
-        orders, _ = firm_decision_engine_instance.make_decisions(context)
+        firm_decision_engine_instance.make_decisions(context)
 
         expected_target = min(
             mock_config.FIRM_MAX_PRODUCTION_TARGET,
@@ -148,120 +193,109 @@ class TestFirmDecisionEngine:
     ):
         mock_firm.inventory["food"] = 100.0
         initial_target = mock_firm.production_target
-        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
-            Tactic.ADJUST_PRODUCTION, Aggressiveness.NORMAL
-        )
 
         context = DecisionContext(
             firm=mock_firm,
-            markets={},
+            markets={"food": Mock()},
             goods_data=[],
             market_data={},
             current_time=1,
             government=None,
         )
-        orders, _ = firm_decision_engine_instance.make_decisions(context)
+        firm_decision_engine_instance.make_decisions(context)
 
         assert mock_firm.production_target == initial_target
 
     def test_make_decisions_target_min_max_bounds(
         self, firm_decision_engine_instance, mock_firm, mock_config
     ):
-        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
-            Tactic.ADJUST_PRODUCTION, Aggressiveness.NORMAL
-        )
         # Test min bound
         mock_firm.inventory["food"] = 1000.0
         mock_firm.production_target = mock_config.FIRM_MIN_PRODUCTION_TARGET * 0.5
         context = DecisionContext(
             firm=mock_firm,
-            markets={},
+            markets={"food": Mock()},
             goods_data=[],
             market_data={},
             current_time=1,
             government=None,
         )
-        orders, _ = firm_decision_engine_instance.make_decisions(context)
+        firm_decision_engine_instance.make_decisions(context)
+        # Should increase to MIN (or at least move towards it? No, logic is reduce if overstock)
+        # Wait, if overstock, we reduce target.
+        # If target < MIN, max(MIN, new_target) -> MIN.
         assert mock_firm.production_target == mock_config.FIRM_MIN_PRODUCTION_TARGET
 
         # Test max bound
         mock_firm.inventory["food"] = 0.0
         mock_firm.production_target = mock_config.FIRM_MAX_PRODUCTION_TARGET * 1.5
-        context = DecisionContext(
-            firm=mock_firm,
-            markets={},
-            goods_data=[],
-            market_data={},
-            current_time=1,
-            government=None,
-        )
-        orders, _ = firm_decision_engine_instance.make_decisions(context)
+        firm_decision_engine_instance.make_decisions(context)
+        # If understock, increase target.
+        # If target > MAX, min(MAX, new_target) -> MAX.
         assert mock_firm.production_target == mock_config.FIRM_MAX_PRODUCTION_TARGET
 
-    def test_make_decisions_hires_to_meet_min_employees(
+    def test_make_decisions_price_adjusts_overstock(
         self, firm_decision_engine_instance, mock_firm, mock_config
     ):
-        mock_firm.employees = []
-        mock_firm.inventory["food"] = 0  # Ensure production is needed
-        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
-            Tactic.ADJUST_WAGES, Aggressiveness.NORMAL
-        )
+        mock_firm.inventory["food"] = 150.0
+        mock_firm.last_prices["food"] = 10.0
+        # Aggressiveness 0.5 (Neutral)
 
         context = DecisionContext(
             firm=mock_firm,
-            markets={},
+            markets={"food": Mock()},
             goods_data=[],
-            market_data={"avg_wage": 10.0},
+            market_data={},
             current_time=1,
             government=None,
         )
-        orders, _ = firm_decision_engine_instance.make_decisions(context)
+        firm_decision_engine_instance.make_decisions(context)
 
-        buy_labor_orders = [
-            o for o in orders if o.order_type == "BUY" and o.item_id == "labor"
-        ]
-        assert len(buy_labor_orders) > 0
-        assert buy_labor_orders[0].quantity == 1.0
-        assert buy_labor_orders[0].market_id == "labor"
+        # Check that post_ask was called with lower price
+        # Price logic: target = market_price (10) * (1 + 0) * decay
+        # decay < 1.0 due to overstock
+        mock_firm.sales.post_ask.assert_called()
+        args, _ = mock_firm.sales.post_ask.call_args
+        price = args[1]
+        assert price < 10.0
 
-    def test_make_decisions_hires_for_needed_labor(
+    def test_make_decisions_price_adjusts_understock(
         self, firm_decision_engine_instance, mock_firm, mock_config
     ):
-        mock_firm.employees = [Mock()]
-        mock_firm.production_target = 500
-        mock_firm.inventory["food"] = 0  # Ensure production is needed
-        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
-            Tactic.ADJUST_WAGES, Aggressiveness.NORMAL
+        mock_firm.inventory["food"] = 90.0
+        mock_firm.last_prices["food"] = 10.0
+        # If inventory is low, decay is closer to 1.0 or 1.0.
+        # But if aggressiveness is low (0.0 -> High Margin), price goes UP.
+        # Let's set aggressiveness to 0.0 (High Margin Strategy)
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = FirmActionVector(
+            sales_aggressiveness=0.0, # High Margin -> High Price
+            hiring_aggressiveness=0.5,rd_aggressiveness=0.5,capital_aggressiveness=0.5,dividend_aggressiveness=0.5,debt_aggressiveness=0.5
         )
 
         context = DecisionContext(
             firm=mock_firm,
-            markets={},
+            markets={"food": Mock()},
             goods_data=[],
-            market_data={"avg_wage": 10.0},
+            market_data={"food": {"avg_price": 10.0}},
             current_time=1,
             government=None,
         )
-        orders, _ = firm_decision_engine_instance.make_decisions(context)
+        firm_decision_engine_instance.make_decisions(context)
 
-        buy_labor_orders = [
-            o for o in orders if o.order_type == "BUY" and o.item_id == "labor"
-        ]
-        assert len(buy_labor_orders) > 0
-        assert buy_labor_orders[0].quantity == 1.0
+        mock_firm.sales.post_ask.assert_called()
+        args, _ = mock_firm.sales.post_ask.call_args
+        price = args[1]
+        assert price > 10.0
 
-    def test_make_decisions_does_not_hire_if_max_employees_reached(
+    def test_make_decisions_sell_order_details(
         self, firm_decision_engine_instance, mock_firm, mock_config
     ):
-        mock_firm.employees = [Mock() for _ in range(mock_config.FIRM_MAX_EMPLOYEES)]
-        mock_firm.production_target = 500
-        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
-            Tactic.ADJUST_WAGES, Aggressiveness.NORMAL
-        )
+        mock_firm.inventory["food"] = 90.0
+        mock_config.MAX_SELL_QUANTITY = 100.0
 
         context = DecisionContext(
             firm=mock_firm,
-            markets={},
+            markets={"food": Mock()}, # Market must exist
             goods_data=[],
             market_data={},
             current_time=1,
@@ -269,272 +303,158 @@ class TestFirmDecisionEngine:
         )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
 
-        buy_labor_orders = [
-            o for o in orders if o.order_type == "BUY" and o.item_id == "labor"
-        ]
-        assert len(buy_labor_orders) == 0
+        mock_firm.sales.post_ask.assert_called()
+        args, _ = mock_firm.sales.post_ask.call_args
+        item_id, price, qty, market, tick = args
+        assert item_id == "food"
+        assert qty == 90.0
+        assert market is not None
 
-    def test_make_decisions_does_not_hire_if_no_needed_labor(
+    def test_make_decisions_hires_labor(
         self, firm_decision_engine_instance, mock_firm, mock_config
     ):
-        mock_firm.employees = [Mock() for _ in range(10)]
-        mock_firm.production_target = 0
-        mock_firm.inventory = {"food": 1000}
-        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
-            Tactic.ADJUST_WAGES, Aggressiveness.NORMAL
+        """Verify BUY orders for labor when understaffed."""
+        # 1. Setup Understaffed Firm
+        # Target = 100. Gap = 100.
+        # Production Fxn: L^alpha * K^beta.
+        # Assume high gap to force hiring.
+        mock_firm.production_target = 100.0
+        mock_firm.inventory["food"] = 0.0
+        mock_firm.hr.employees = [] # 0 Employees
+
+        # 2. Aggressiveness for Hiring = 0.8 (High)
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = FirmActionVector(
+            hiring_aggressiveness=0.8,
+            sales_aggressiveness=0.5, rd_aggressiveness=0.5, capital_aggressiveness=0.5, dividend_aggressiveness=0.5, debt_aggressiveness=0.5
         )
 
         context = DecisionContext(
             firm=mock_firm,
             markets={},
             goods_data=[],
-            market_data={},
+            market_data={"labor": {"avg_wage": 10.0}},
             current_time=1,
             government=None,
         )
+
+        # 3. Execution
         orders, _ = firm_decision_engine_instance.make_decisions(context)
 
-        buy_labor_orders = [
-            o for o in orders if o.order_type == "BUY" and o.item_id == "labor"
-        ]
-        assert len(buy_labor_orders) == 0
+        # 4. Verification
+        labor_orders = [o for o in orders if o.item_id == "labor" and o.order_type == "BUY"]
+        assert len(labor_orders) > 0
+        assert labor_orders[0].price > 10.0 # High aggressiveness bids up wage
+        assert labor_orders[0].quantity > 0
 
-    def test_make_decisions_labor_order_details(
+    def test_make_decisions_does_not_hire_when_full(
         self, firm_decision_engine_instance, mock_firm, mock_config
     ):
-        mock_firm.employees = []
-        mock_firm.inventory["food"] = 0  # Ensure production is needed
-        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
-            Tactic.ADJUST_WAGES, Aggressiveness.NORMAL
-        )
-
-        context = DecisionContext(
-            firm=mock_firm,
-            markets={},
-            goods_data=[],
-            market_data={"avg_wage": 10.0},
-            current_time=1,
-        )
-        orders, _ = firm_decision_engine_instance.make_decisions(context)
+        """Verify no labor orders when employees >= needed."""
+        # 1. Setup Full Firm
+        mock_firm.production_target = 10.0
+        mock_firm.inventory["food"] = 0.0
+        # Assume 10 employees is enough for target 10
+        mock_firm.hr.employees = [Mock(id=i, labor_skill=1.0) for i in range(100)]
 
-        labor_order = next(
-            (o for o in orders if o.order_type == "BUY" and o.item_id == "labor"), None
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = FirmActionVector(
+            hiring_aggressiveness=0.5,
+            sales_aggressiveness=0.5, rd_aggressiveness=0.5, capital_aggressiveness=0.5, dividend_aggressiveness=0.5, debt_aggressiveness=0.5
         )
-        assert labor_order is not None
-        assert labor_order.agent_id == mock_firm.id
-        assert labor_order.quantity == 1.0
-        assert labor_order.market_id == "labor"
 
-    def test_make_decisions_does_not_sell_if_understocked(
-        self, firm_decision_engine_instance, mock_firm
-    ):
-        mock_firm.inventory["food"] = 10.0  # Understocked
-        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
-            Tactic.ADJUST_PRICE, Aggressiveness.NORMAL
-        )
         context = DecisionContext(
             firm=mock_firm,
             markets={},
             goods_data=[],
-            market_data={},
+            market_data={"labor": {"avg_wage": 10.0}},
             current_time=1,
             government=None,
         )
-        orders, _ = firm_decision_engine_instance.make_decisions(context)
-        sell_orders = [
-            o for o in orders if o.order_type == "SELL" and o.item_id == "food"
-        ]
-        assert len(sell_orders) == 0
 
-    def test_make_decisions_does_not_sell_if_no_inventory(
-        self, firm_decision_engine_instance, mock_firm
-    ):
-        mock_firm.inventory["food"] = 0.0
-        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
-            Tactic.ADJUST_PRICE, Aggressiveness.NORMAL
-        )
-        context = DecisionContext(
-            firm=mock_firm,
-            markets={},
-            goods_data=[],
-            market_data={},
-            current_time=1,
-            government=None,
-        )
         orders, _ = firm_decision_engine_instance.make_decisions(context)
-        sell_orders = [
-            o for o in orders if o.order_type == "SELL" and o.item_id == "food"
-        ]
-        assert len(sell_orders) == 0
 
-    def test_make_decisions_price_adjusts_overstock(
-        self, firm_decision_engine_instance, mock_firm, mock_config
-    ):
-        mock_firm.inventory["food"] = 150.0
-        mock_firm.last_prices["food"] = 10.0
-        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
-            Tactic.ADJUST_PRICE, Aggressiveness.NORMAL
-        )
-        context = DecisionContext(
-            firm=mock_firm,
-            markets={},
-            goods_data=[],
-            market_data={},
-            current_time=1,
-            government=None,
-        )
-        orders, _ = firm_decision_engine_instance.make_decisions(context)
-        sell_order = next(
-            (o for o in orders if o.order_type == "SELL" and o.item_id == "food"), None
-        )
-        assert sell_order.price < 10.0
+        labor_orders = [o for o in orders if o.item_id == "labor" and o.order_type == "BUY"]
+        assert len(labor_orders) == 0
 
-    def test_make_decisions_price_adjusts_understock(
+    def test_make_decisions_fires_excess_labor(
         self, firm_decision_engine_instance, mock_firm, mock_config
     ):
-        mock_firm.inventory["food"] = 90.0  # Not understocked, but below target
-        mock_firm.last_prices["food"] = 10.0
-        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
-            Tactic.ADJUST_PRICE, Aggressiveness.NORMAL
-        )
-        context = DecisionContext(
-            firm=mock_firm,
-            markets={},
-            goods_data=[],
-            market_data={},
-            current_time=1,
-            government=None,
-        )
-        orders, _ = firm_decision_engine_instance.make_decisions(context)
-        sell_order = next(
-            (o for o in orders if o.order_type == "SELL" and o.item_id == "food"), None
-        )
-        assert sell_order.price > 10.0
+        """Verify emp.quit() is called via finance.pay_severance when overstaffed."""
+        # 1. Setup Overstaffed Firm
+        mock_firm.production_target = 0.0 # No production needed
+        mock_firm.inventory["food"] = 100.0 # Full inventory
+        # 2 Employees, 1 Needed (Skeleton Crew)
+        employee1 = Mock(id=1, labor_skill=1.0)
+        employee1.quit = Mock()
+        employee2 = Mock(id=2, labor_skill=1.0)
+        employee2.quit = Mock()
 
-    def test_make_decisions_sell_price_min_max_bounds(
-        self, firm_decision_engine_instance, mock_firm, mock_config
-    ):
-        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
-            Tactic.ADJUST_PRICE, Aggressiveness.NORMAL
-        )
-        # Test min bound
-        mock_firm.inventory["food"] = 150.0
-        mock_firm.last_prices["food"] = 1.0
-        mock_config.MIN_SELL_PRICE = 5.0
-        context = DecisionContext(
-            firm=mock_firm,
-            markets={},
-            goods_data=[],
-            market_data={},
-            current_time=1,
-            government=None,
-        )
-        orders, _ = firm_decision_engine_instance.make_decisions(context)
-        sell_order = next(
-            (o for o in orders if o.order_type == "SELL" and o.item_id == "food"), None
-        )
-        assert sell_order.price == mock_config.MIN_SELL_PRICE
+        mock_firm.hr.employees = [employee1, employee2]
+        mock_firm.hr.employee_wages = {1: 10.0, 2: 10.0}
 
-        # Test max bound (price would go below MIN_SELL_PRICE)
-        mock_firm.inventory["food"] = 90.0  # Not understocked
-        mock_firm.last_prices["food"] = 100.0
-        mock_config.MAX_SELL_PRICE = 90.0
-        context = DecisionContext(
-            firm=mock_firm,
-            markets={},
-            goods_data=[],
-            market_data={},
-            current_time=1,
-            government=None,
-        )
-        orders, _ = firm_decision_engine_instance.make_decisions(context)
-        sell_order = next(
-            (o for o in orders if o.order_type == "SELL" and o.item_id == "food"), None
-        )
-        assert sell_order.price == mock_config.MAX_SELL_PRICE
+        # Mock Finance to allow severance
+        mock_firm.finance.pay_severance.return_value = True
 
-    def test_make_decisions_sell_quantity_max_bound(
-        self, firm_decision_engine_instance, mock_firm, mock_config
-    ):
-        mock_firm.inventory["food"] = 100.0
-        mock_config.MAX_SELL_QUANTITY = 20.0
-        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
-            Tactic.ADJUST_PRICE, Aggressiveness.NORMAL
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = FirmActionVector(
+            hiring_aggressiveness=0.5,
+            sales_aggressiveness=0.5, rd_aggressiveness=0.5, capital_aggressiveness=0.5, dividend_aggressiveness=0.5, debt_aggressiveness=0.5
         )
-        context = DecisionContext(
-            firm=mock_firm,
-            markets={},
-            goods_data=[],
-            market_data={},
-            current_time=1,
-            government=None,
-        )
-        orders, _ = firm_decision_engine_instance.make_decisions(context)
-        sell_order = next(
-            (o for o in orders if o.order_type == "SELL" and o.item_id == "food"), None
-        )
-        assert sell_order.quantity == mock_config.MAX_SELL_QUANTITY
 
-    def test_make_decisions_sell_order_details(
-        self, firm_decision_engine_instance, mock_firm, mock_config
-    ):
-        mock_firm.inventory["food"] = 90.0  # Not understocked
-        mock_config.MAX_SELL_QUANTITY = (
-            100.0  # Ensure max quantity is not the limiting factor
-        )
-        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
-            Tactic.ADJUST_PRICE, Aggressiveness.NORMAL
-        )
         context = DecisionContext(
             firm=mock_firm,
             markets={},
             goods_data=[],
-            market_data={},
+            market_data={"labor": {"avg_wage": 10.0}},
             current_time=1,
             government=None,
         )
-        orders, _ = firm_decision_engine_instance.make_decisions(context)
-        sell_order = next(
-            (o for o in orders if o.order_type == "SELL" and o.item_id == "food"), None
-        )
-        assert sell_order is not None
-        assert sell_order.agent_id == mock_firm.id
-        assert sell_order.quantity == 90.0
-        assert sell_order.market_id == "goods_market"
 
-    def test_make_decisions_ai_price_increase_small(
+        firm_decision_engine_instance.make_decisions(context)
+
+        # 2. Verify Firing
+        # FIFO firing: employee1 should be fired
+        employee1.quit.assert_called_once()
+        mock_firm.finance.pay_severance.assert_called_once()
+
+    def test_sales_aggressiveness_impact_on_price(
         self, firm_decision_engine_instance, mock_firm, mock_config
     ):
+        """Verify that sales aggressiveness inversely affects price."""
         mock_firm.inventory["food"] = 100.0
         mock_firm.last_prices["food"] = 10.0
-        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
-            Tactic.PRICE_INCREASE_SMALL, Aggressiveness.NORMAL
-        )
-
+        # No decay (100 vs 100) if target matched.
+        # But we need markets.
         context = DecisionContext(
             firm=mock_firm,
-            markets={},
+            markets={"food": Mock()},
             goods_data=[],
             market_data={},
             current_time=1,
             government=None,
         )
-        orders, _ = firm_decision_engine_instance.make_decisions(context)
 
-        sell_order = next(
-            (o for o in orders if o.order_type == "SELL" and o.item_id == "food"), None
-        )
-        assert sell_order is not None
-        expected_price = 10.0 * (1 + mock_config.AI_PRICE_ADJUSTMENT_SMALL)
-        assert sell_order.price == pytest.approx(expected_price)
+        # 1. Low Aggressiveness (0.1) -> High Margin -> Higher Price
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = FirmActionVector(sales_aggressiveness=0.1, hiring_aggressiveness=0.5, rd_aggressiveness=0.5, capital_aggressiveness=0.5, dividend_aggressiveness=0.5, debt_aggressiveness=0.5)
+        firm_decision_engine_instance.make_decisions(context)
+        args_low_agg, _ = mock_firm.sales.post_ask.call_args
+        price_low_agg = args_low_agg[1]
+
+        # 2. High Aggressiveness (0.9) -> High Volume -> Lower Price
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = FirmActionVector(sales_aggressiveness=0.9, hiring_aggressiveness=0.5, rd_aggressiveness=0.5, capital_aggressiveness=0.5, dividend_aggressiveness=0.5, debt_aggressiveness=0.5)
+        firm_decision_engine_instance.make_decisions(context)
+        args_high_agg, _ = mock_firm.sales.post_ask.call_args
+        price_high_agg = args_high_agg[1]
 
-    def test_make_decisions_ai_price_decrease_medium(
+        assert price_low_agg > price_high_agg
+
+    def test_rd_investment(
         self, firm_decision_engine_instance, mock_firm, mock_config
     ):
-        mock_firm.inventory["food"] = 100.0
-        mock_firm.last_prices["food"] = 10.0
-        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
-            Tactic.PRICE_DECREASE_MEDIUM, Aggressiveness.NORMAL
+        """Verify R&D investment when aggressiveness is high."""
+        # Setup High Cash
+        mock_firm.assets = 100000.0
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = FirmActionVector(
+            rd_aggressiveness=0.9,
+            sales_aggressiveness=0.5, hiring_aggressiveness=0.5, capital_aggressiveness=0.5, dividend_aggressiveness=0.5, debt_aggressiveness=0.5
         )
 
         context = DecisionContext(
@@ -545,22 +465,20 @@ class TestFirmDecisionEngine:
             current_time=1,
             government=None,
         )
-        orders, _ = firm_decision_engine_instance.make_decisions(context)
 
-        sell_order = next(
-            (o for o in orders if o.order_type == "SELL" and o.item_id == "food"), None
-        )
-        assert sell_order is not None
-        expected_price = 10.0 * (1 - mock_config.AI_PRICE_ADJUSTMENT_MEDIUM)
-        assert sell_order.price == pytest.approx(expected_price)
+        firm_decision_engine_instance.make_decisions(context)
 
-    def test_make_decisions_ai_price_hold(
+        mock_firm.finance.invest_in_rd.assert_called()
+
+    def test_capex_investment(
         self, firm_decision_engine_instance, mock_firm, mock_config
     ):
-        mock_firm.inventory["food"] = 100.0
-        mock_firm.last_prices["food"] = 10.0
-        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
-            Tactic.PRICE_HOLD, Aggressiveness.NORMAL
+        """Verify Capex investment when aggressiveness is high."""
+        # Setup High Cash
+        mock_firm.assets = 100000.0
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = FirmActionVector(
+            capital_aggressiveness=0.9,
+            sales_aggressiveness=0.5, hiring_aggressiveness=0.5, rd_aggressiveness=0.5, dividend_aggressiveness=0.5, debt_aggressiveness=0.5
         )
 
         context = DecisionContext(
@@ -570,47 +488,26 @@ class TestFirmDecisionEngine:
             market_data={},
             current_time=1,
             government=None,
+            reflux_system=Mock() # Reflux system needed for capex
         )
-        orders, _ = firm_decision_engine_instance.make_decisions(context)
 
-        sell_order = next(
-            (o for o in orders if o.order_type == "SELL" and o.item_id == "food"), None
-        )
-        assert sell_order is not None
-        expected_price = 10.0
-        assert sell_order.price == pytest.approx(expected_price)
+        firm_decision_engine_instance.make_decisions(context)
+
+        mock_firm.finance.invest_in_capex.assert_called()
 
-    def test_make_decisions_ai_price_min_max_bounds(
+    def test_dividend_setting(
         self, firm_decision_engine_instance, mock_firm, mock_config
     ):
-        mock_firm.inventory["food"] = 100.0
-        mock_firm.last_prices["food"] = 1.0
-        mock_config.MIN_SELL_PRICE = 5.0
-        mock_config.MAX_SELL_PRICE = 90.0
+        """Verify dividend rate setting based on aggressiveness."""
+        # Setup Healthy Firm
+        mock_firm.finance.calculate_altman_z_score.return_value = 5.0 # Healthy
+        mock_firm.finance.consecutive_loss_turns = 0
 
-        # Test min bound (price would go below MIN_SELL_PRICE)
-        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
-            Tactic.PRICE_DECREASE_MEDIUM, Aggressiveness.NORMAL
-        )
-        context = DecisionContext(
-            firm=mock_firm,
-            markets={},
-            goods_data=[],
-            market_data={},
-            current_time=1,
-            government=None,
-        )
-        orders, _ = firm_decision_engine_instance.make_decisions(context)
-        sell_order = next(
-            (o for o in orders if o.order_type == "SELL" and o.item_id == "food"), None
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = FirmActionVector(
+            dividend_aggressiveness=0.9, # High Payout
+            sales_aggressiveness=0.5, hiring_aggressiveness=0.5, rd_aggressiveness=0.5, capital_aggressiveness=0.5, debt_aggressiveness=0.5
         )
-        assert sell_order.price == pytest.approx(mock_config.MIN_SELL_PRICE)
 
-        # Test max bound (price would go above MAX_SELL_PRICE)
-        mock_firm.last_prices["food"] = 95.0
-        firm_decision_engine_instance.ai_engine.decide_and_learn.return_value = (
-            Tactic.PRICE_INCREASE_SMALL, Aggressiveness.NORMAL
-        )
         context = DecisionContext(
             firm=mock_firm,
             markets={},
@@ -619,8 +516,11 @@ class TestFirmDecisionEngine:
             current_time=1,
             government=None,
         )
-        orders, _ = firm_decision_engine_instance.make_decisions(context)
-        sell_order = next(
-            (o for o in orders if o.order_type == "SELL" and o.item_id == "food"), None
-        )
-        assert sell_order.price == pytest.approx(mock_config.MAX_SELL_PRICE)
\ No newline at end of file
+
+        firm_decision_engine_instance.make_decisions(context)
+
+        mock_firm.finance.set_dividend_rate.assert_called()
+        # Verify rate is high
+        args, _ = mock_firm.finance.set_dividend_rate.call_args
+        rate = args[0]
+        assert rate > 0.1 # Should be significantly higher than min
