diff --git a/design/TECH_DEBT_LEDGER.md b/design/TECH_DEBT_LEDGER.md
index a150810..d61464e 100644
--- a/design/TECH_DEBT_LEDGER.md
+++ b/design/TECH_DEBT_LEDGER.md
@@ -15,9 +15,7 @@
 
 | ID | Date | Description | Remediation Plan | Impact | Status |
 |---|---|---|---|---|---|
-| **TD-101** | 2026-01-27 | **Shadow Economy (Direct Mutation)** | Enforce use of `SettlementSystem` in all modules | Zero-sum violation | **REOPENED** |
 | **TD-103** | 2026-01-23 | **Leaky AI Abstraction (self-sharing)** | Refactor `DecisionContext` to accept DTOs strictly | Encapsulation Break / Side-effects | **STRUCTURAL_RISK** |
-| **TD-117** | 2026-01-27 | **DTO-Only Decisions (Regression)** | Remove `self` injection in `core_agents.py` | Purity Gate Violation | **REOPENED** |
 | **TD-123** | 2026-01-27 | **God Class: `Household` (840 lines)** | Decompose into Bio/Social/Econ components | Maintenance Overhead | **ACTIVE** |
 | **TD-124** | 2026-01-27 | **God Class: `TransactionProcessor`** | Split into Tax/Settlement/Registry | Scalability Risk | **ACTIVE** |
 | **TD-125** | 2026-01-27 | **Non-atomic Transfer Sequences** | Implement atomic bank/transaction blocks | Monetary Integrity | **ACTIVE** |
@@ -54,6 +52,8 @@
 | TD-116 | 2026-01-26 | Inheritance Residual Evaporation | Integer Distribution (Core Track) | Zero-Sum Integrity | **RESOLVED** |
 | TD-120 | 2026-01-27 | Refactor TransactionProcessor Tax Calls | TaxAgency Injection (Track Bravo) | Maintenance Risk | **RESOLVED** |
 | TD-121 | 2026-01-26 | Newborn Money Leak (DOA) | Initial Needs Config Injection (WO-121) | Agent Viability | **RESOLVED** |
+| TD-101 | 2026-01-27 | Shadow Economy (Direct Mutation) | Enforce `SettlementSystem` usage (WO-125) | Zero-sum violation | **RESOLVED** |
+| TD-117 | 2026-01-27 | DTO-Only Decisions (Regression) | Enforce Purity Gate (WO-125) | Purity Gate Violation | **RESOLVED** |
 
 ---
 
diff --git a/simulation/decisions/base_decision_engine.py b/simulation/decisions/base_decision_engine.py
index 859cb8e..8dae4d1 100644
--- a/simulation/decisions/base_decision_engine.py
+++ b/simulation/decisions/base_decision_engine.py
@@ -23,9 +23,6 @@ class BaseDecisionEngine:
         assert hasattr(context, 'state') and context.state is not None, "Purity Error: context.state DTO is missing."
         assert hasattr(context, 'config') and context.config is not None, "Purity Error: context.config DTO is missing."
         
-        # We allow .household and .firm for now but they should be ignored by new engines.
-        # Once migration is complete, we will explicitly forbid them.
-        
         return self._make_decisions_internal(context, macro_context)
 
     def _make_decisions_internal(
diff --git a/simulation/decisions/rule_based_household_engine.py b/simulation/decisions/rule_based_household_engine.py
index fd91144..5092ae7 100644
--- a/simulation/decisions/rule_based_household_engine.py
+++ b/simulation/decisions/rule_based_household_engine.py
@@ -52,8 +52,6 @@ class RuleBasedHouseholdDecisionEngine(BaseDecisionEngine):
         chosen_tactic: Tactic = Tactic.NO_ACTION
         chosen_aggressiveness: Aggressiveness = Aggressiveness.NEUTRAL
 
-        # Note: Wage modifier evolution (recovery/decay) moved to Household.make_decision
-
         # 1. 생존 욕구 충족 (음식 구매)
         if (
             state.needs["survival"]
diff --git a/simulation/dtos/api.py b/simulation/dtos/api.py
index f79d407..cbfcd7d 100644
--- a/simulation/dtos/api.py
+++ b/simulation/dtos/api.py
@@ -205,7 +205,7 @@ class DecisionContext:
     # Static configuration values relevant to the agent type
     config: Union[HouseholdConfigDTO, FirmConfigDTO]
 
-    # Deprecated: Will be removed after full migration to DTOs
+    # Deprecated: Legacy fields. Will be removed after full migration to DTOs.
     markets: Optional[Dict[str, Any]] = None
     government: Optional[Any] = None
 
diff --git a/simulation/systems/transaction_processor.py b/simulation/systems/transaction_processor.py
index 6154c41..b54d8f9 100644
--- a/simulation/systems/transaction_processor.py
+++ b/simulation/systems/transaction_processor.py
@@ -55,6 +55,9 @@ class TransactionProcessor(SystemInterface):
             # 1. Financial Settlement (Asset Transfer & Taxes)
             # ==================================================================
             settlement = getattr(state, 'settlement_system', None)
+            if not settlement:
+                raise RuntimeError("SettlementSystem is required for TransactionProcessor but is missing in SimulationState.")
+
             success = False
 
             if tx.transaction_type == "lender_of_last_resort":
@@ -81,12 +84,7 @@ class TransactionProcessor(SystemInterface):
 
             elif tx.transaction_type == "asset_transfer":
                  # Standard Transfer (Zero-Sum)
-                 if settlement:
-                     success = settlement.transfer(buyer, seller, trade_value, f"asset_transfer:{tx.item_id}")
-                 else:
-                     buyer.withdraw(trade_value)
-                     seller.deposit(trade_value)
-                     success = True
+                 success = settlement.transfer(buyer, seller, trade_value, f"asset_transfer:{tx.item_id}")
 
                  # Asset Transfer Logic
                  if success:
@@ -97,14 +95,9 @@ class TransactionProcessor(SystemInterface):
 
             elif tx.transaction_type == "escheatment":
                  # Buyer: Agent (Deceased/Closed), Seller: Government
-                 if settlement:
-                     # Atomic Collection via Government (handles transfer and confirmed recording)
-                     result = government.collect_tax(trade_value, "escheatment", buyer, current_time)
-                     success = result['success']
-                 else:
-                     buyer.withdraw(trade_value)
-                     government.deposit(trade_value)
-                     success = True
+                 # Atomic Collection via Government (handles transfer and confirmed recording)
+                 result = government.collect_tax(trade_value, "escheatment", buyer, current_time)
+                 success = result['success']
 
             elif tx.transaction_type == "inheritance_distribution":
                 heir_ids = tx.metadata.get("heir_ids", []) if tx.metadata else []
@@ -123,15 +116,10 @@ class TransactionProcessor(SystemInterface):
                         h_id = heir_ids[i]
                         heir = agents.get(h_id)
                         if heir:
-                            if settlement:
-                                if settlement.transfer(buyer, heir, base_amount, "inheritance_distribution"):
-                                    distributed_sum += base_amount
-                                else:
-                                    all_success = False
-                            else:
-                                buyer.withdraw(base_amount)
-                                heir.deposit(base_amount)
+                            if settlement.transfer(buyer, heir, base_amount, "inheritance_distribution"):
                                 distributed_sum += base_amount
+                            else:
+                                all_success = False
 
                     # Last heir gets the remainder to ensure zero-sum
                     last_heir_id = heir_ids[-1]
@@ -140,12 +128,8 @@ class TransactionProcessor(SystemInterface):
                         remaining_amount = total_cash - distributed_sum
                         # Ensure we don't transfer negative amounts or dust if something went wrong
                         if remaining_amount > 0:
-                            if settlement:
-                                if not settlement.transfer(buyer, last_heir, remaining_amount, "inheritance_distribution_final"):
-                                    all_success = False
-                            else:
-                                buyer.withdraw(remaining_amount)
-                                last_heir.deposit(remaining_amount)
+                            if not settlement.transfer(buyer, last_heir, remaining_amount, "inheritance_distribution_final"):
+                                all_success = False
 
                     success = all_success
 
@@ -158,25 +142,14 @@ class TransactionProcessor(SystemInterface):
                     if buyer.assets < (trade_value + tax_amount):
                         buyer.check_solvency(government)
 
-                if settlement:
-                    success = settlement.transfer(buyer, seller, trade_value, f"goods_trade:{tx.item_id}")
-                    if success and tax_amount > 0:
-                        # Atomic collection from buyer
-                        government.collect_tax(tax_amount, f"sales_tax_{tx.transaction_type}", buyer, current_time)
-                else:
-                    buyer.withdraw(trade_value + tax_amount)
-                    seller.deposit(trade_value)
-                    government.deposit(tax_amount)
-                    success = True
+                success = settlement.transfer(buyer, seller, trade_value, f"goods_trade:{tx.item_id}")
+                if success and tax_amount > 0:
+                    # Atomic collection from buyer
+                    government.collect_tax(tax_amount, f"sales_tax_{tx.transaction_type}", buyer, current_time)
 
             elif tx.transaction_type == "stock":
                 # Stock: NO Sales Tax
-                if settlement:
-                    success = settlement.transfer(buyer, seller, trade_value, f"stock_trade:{tx.item_id}")
-                else:
-                    buyer.withdraw(trade_value)
-                    seller.deposit(trade_value)
-                    success = True
+                success = settlement.transfer(buyer, seller, trade_value, f"stock_trade:{tx.item_id}")
             
             elif tx.transaction_type in ["labor", "research_labor"]:
                 # Labor: Apply Income Tax
@@ -193,91 +166,48 @@ class TransactionProcessor(SystemInterface):
                 tax_amount = government.calculate_income_tax(trade_value, survival_cost)
                 
                 if tax_payer == "FIRM":
-                    if settlement:
-                        success = settlement.transfer(buyer, seller, trade_value, f"labor_wage:{tx.transaction_type}")
-                        if success and tax_amount > 0:
-                            # Atomic collection from Firm
-                            government.collect_tax(tax_amount, "income_tax_firm", buyer, current_time)
-                    else:
-                        buyer.withdraw(trade_value + tax_amount)
-                        seller.deposit(trade_value)
-                        government.deposit(tax_amount)
-                        success = True
+                    success = settlement.transfer(buyer, seller, trade_value, f"labor_wage:{tx.transaction_type}")
+                    if success and tax_amount > 0:
+                        # Atomic collection from Firm
+                        government.collect_tax(tax_amount, "income_tax_firm", buyer, current_time)
                 else:
                     # Household pays tax
-                    if settlement:
-                        # Pay GROSS wage to household, then collect tax from household
-                        success = settlement.transfer(buyer, seller, trade_value, f"labor_wage_gross:{tx.transaction_type}")
-                        if success and tax_amount > 0:
-                            # Atomic collection from Household (Withholding model)
-                            government.collect_tax(tax_amount, "income_tax_household", seller, current_time)
-                    else:
-                        net_wage = trade_value - tax_amount
-                        buyer.withdraw(trade_value)
-                        seller.deposit(net_wage)
-                        government.deposit(tax_amount)
-                        success = True
+                    # Pay GROSS wage to household, then collect tax from household
+                    success = settlement.transfer(buyer, seller, trade_value, f"labor_wage_gross:{tx.transaction_type}")
+                    if success and tax_amount > 0:
+                        # Atomic collection from Household (Withholding model)
+                        government.collect_tax(tax_amount, "income_tax_household", seller, current_time)
             
             elif tx.item_id == "interest_payment":
-                if settlement:
-                    success = settlement.transfer(buyer, seller, trade_value, "interest_payment")
-                else:
-                    buyer.withdraw(trade_value)
-                    seller.deposit(trade_value)
-                    success = True
+                success = settlement.transfer(buyer, seller, trade_value, "interest_payment")
 
                 if success and isinstance(buyer, Firm):
                     buyer.finance.record_expense(trade_value)
 
             elif tx.transaction_type == "dividend":
-                if settlement:
-                    success = settlement.transfer(seller, buyer, trade_value, "dividend_payment")
-                else:
-                    seller.withdraw(trade_value)
-                    buyer.deposit(trade_value)
-                    success = True
+                success = settlement.transfer(seller, buyer, trade_value, "dividend_payment")
 
                 if success and isinstance(buyer, Household) and hasattr(buyer, "capital_income_this_tick"):
                     buyer.capital_income_this_tick += trade_value
             elif tx.transaction_type == "tax":
                 # Atomic Collection via Government
-                if settlement:
-                    result = government.collect_tax(trade_value, tx.item_id, buyer, current_time)
-                    success = result['success']
-                else:
-                    buyer.withdraw(trade_value)
-                    government.deposit(trade_value)
-                    success = True
+                result = government.collect_tax(trade_value, tx.item_id, buyer, current_time)
+                success = result['success']
             elif tx.transaction_type == "infrastructure_spending":
                 # Standard Transfer (Gov -> Reflux)
-                if settlement:
-                    success = settlement.transfer(buyer, seller, trade_value, "infrastructure_spending")
-                else:
-                    buyer.withdraw(trade_value)
-                    seller.deposit(trade_value)
-                    success = True
+                success = settlement.transfer(buyer, seller, trade_value, "infrastructure_spending")
 
             elif tx.transaction_type == "emergency_buy":
                 # Fast Purchase (Buyer -> Reflux/System)
                 # No Sales Tax, Immediate Inventory Update
-                if settlement:
-                    success = settlement.transfer(buyer, seller, trade_value, "emergency_buy")
-                else:
-                    buyer.withdraw(trade_value)
-                    seller.deposit(trade_value)
-                    success = True
+                success = settlement.transfer(buyer, seller, trade_value, "emergency_buy")
 
                 if success:
                     buyer.inventory[tx.item_id] = buyer.inventory.get(tx.item_id, 0.0) + tx.quantity
 
             else:
                 # Default / Other
-                if settlement:
-                    success = settlement.transfer(buyer, seller, trade_value, f"generic:{tx.transaction_type}")
-                else:
-                    buyer.withdraw(trade_value)
-                    seller.deposit(trade_value)
-                    success = True
+                success = settlement.transfer(buyer, seller, trade_value, f"generic:{tx.transaction_type}")
 
             # WO-109: Apply Deferred Effects only on Success
             if success and tx.metadata and tx.metadata.get("triggers_effect"):
diff --git a/tests/test_transaction_processor.py b/tests/test_transaction_processor.py
new file mode 100644
index 0000000..93f24d0
--- /dev/null
+++ b/tests/test_transaction_processor.py
@@ -0,0 +1,138 @@
+import pytest
+from unittest.mock import MagicMock
+from simulation.systems.transaction_processor import TransactionProcessor
+from simulation.models import Transaction
+
+def test_transaction_processor_enforces_settlement():
+    config = MagicMock()
+    config.SALES_TAX_RATE = 0.1
+    config.GOODS = {"apple": {}}
+
+    tp = TransactionProcessor(config)
+    state = MagicMock()
+    state.settlement_system = None
+    # Add a dummy transaction to trigger the loop
+    buyer = MagicMock()
+    buyer.id = 1
+    seller = MagicMock()
+    seller.id = 2
+    state.agents = {1: buyer, 2: seller}
+
+    tx = Transaction(
+        buyer_id=1,
+        seller_id=2,
+        item_id="apple",
+        price=10.0,
+        quantity=1.0,
+        market_id="goods",
+        transaction_type="goods",
+        time=0
+    )
+    state.transactions = [tx]
+
+    # Should raise RuntimeError if settlement_system is missing
+    with pytest.raises(RuntimeError, match="SettlementSystem is required"):
+        tp.execute(state)
+
+def test_transaction_processor_uses_settlement():
+    config = MagicMock()
+    config.SALES_TAX_RATE = 0.1
+    config.GOODS = {"apple": {}}
+
+    tp = TransactionProcessor(config)
+
+    state = MagicMock()
+    gov = MagicMock()
+    state.government = gov
+    gov.calculate_income_tax.return_value = 0.0
+
+    settlement = MagicMock()
+    settlement.transfer.return_value = True
+    state.settlement_system = settlement
+
+    state.market_data = {}
+    state.time = 0
+
+    buyer = MagicMock()
+    buyer.id = 1
+    buyer.assets = 100.0
+    buyer.check_solvency = MagicMock()
+
+    seller = MagicMock()
+    seller.id = 2
+    seller.inventory = {}
+    seller.deposit = MagicMock() # Should not be called directly for trade value
+
+    state.agents = {1: buyer, 2: seller}
+
+    tx = Transaction(
+        buyer_id=1,
+        seller_id=2,
+        item_id="apple",
+        price=10.0,
+        quantity=1.0,
+        market_id="goods",
+        transaction_type="goods",
+        time=0
+    )
+    state.transactions = [tx]
+
+    tp.execute(state)
+
+    # Verify settlement.transfer called
+    settlement.transfer.assert_called_once()
+    args = settlement.transfer.call_args
+    # args: buyer, seller, amount, memo
+    assert args[0][0] == buyer
+    assert args[0][1] == seller
+    assert args[0][2] == 10.0 # 1.0 * 10.0
+
+    # Verify withdraw/deposit NOT called on agents (since we use settlement)
+    # Note: seller.deposit might be called in other logic (e.g. specific minting) but for goods trade it shouldn't
+    # In my code I replaced buyer.withdraw and seller.deposit with settlement.transfer
+    buyer.withdraw.assert_not_called()
+    seller.deposit.assert_not_called()
+
+def test_transaction_processor_skips_on_settlement_failure():
+    config = MagicMock()
+    config.SALES_TAX_RATE = 0.1
+    config.GOODS = {"apple": {}}
+
+    tp = TransactionProcessor(config)
+    state = MagicMock()
+    state.government = MagicMock()
+    state.market_data = {}
+    state.time = 0
+
+    settlement = MagicMock()
+    settlement.transfer.return_value = False # TRANSFER FAILS
+    state.settlement_system = settlement
+
+    buyer = MagicMock()
+    buyer.id = 1
+    buyer.assets = 1000.0 # Fix TypeError comparison
+    buyer.withdraw = MagicMock()
+    buyer.check_solvency = MagicMock()
+
+    seller = MagicMock()
+    seller.id = 2
+
+    state.agents = {1: buyer, 2: seller}
+
+    tx = Transaction(
+        buyer_id=1,
+        seller_id=2,
+        item_id="apple",
+        price=10.0,
+        quantity=1.0,
+        market_id="goods",
+        transaction_type="goods",
+        time=0
+    )
+    state.transactions = [tx]
+
+    tp.execute(state)
+
+    settlement.transfer.assert_called_once()
+    # Fallback should NOT happen
+    buyer.withdraw.assert_not_called()
diff --git a/tests/verify_transaction_processor.py b/tests/verify_transaction_processor.py
deleted file mode 100644
index 73a5398..0000000
--- a/tests/verify_transaction_processor.py
+++ /dev/null
@@ -1,75 +0,0 @@
-from simulation.systems.transaction_processor import TransactionProcessor
-from simulation.models import Transaction
-from unittest.mock import MagicMock
-import logging
-
-def test_tax_collection_args():
-    config = MagicMock()
-    config.SALES_TAX_RATE = 0.1
-    config.GOODS = {"apple": {}}
-
-    tp = TransactionProcessor(config)
-
-    state = MagicMock()
-    gov = MagicMock()
-    state.government = gov
-    # Mock calculate_income_tax for other paths, though we test 'goods' here
-    gov.calculate_income_tax.return_value = 0.0
-
-    state.settlement_system = None # Force fallback or direct call logic
-    state.market_data = {}
-    state.time = 0
-
-    # Buyer Object
-    buyer = MagicMock()
-    buyer.id = 1
-    buyer.assets = 100.0
-    # Add check_solvency mock
-    buyer.check_solvency = MagicMock()
-
-    # Seller Object
-    seller = MagicMock()
-    seller.id = 2
-    seller.inventory = {}
-    seller.deposit = MagicMock()
-
-    state.agents = {1: buyer, 2: seller}
-
-    # Transaction
-    tx = Transaction(
-        buyer_id=1,
-        seller_id=2,
-        item_id="apple",
-        price=10.0,
-        quantity=1.0,
-        market_id="goods",
-        transaction_type="goods",
-        time=0
-    )
-    state.transactions = [tx]
-
-    # Execute
-    tp.execute(state)
-
-    # Verify collect_tax call
-    # gov.collect_tax(tax_amount, tax_type, payer, tick)
-    # Expected: payer is buyer (object), not buyer.id
-
-    if not gov.collect_tax.called:
-        print("collect_tax not called!")
-        return
-
-    args = gov.collect_tax.call_args
-    print(f"Call args: {args}")
-    # args[0] is positional args tuple: (amount, type, payer, tick)
-    payer_arg = args[0][2] # 3rd arg
-
-    if payer_arg == buyer:
-        print("SUCCESS: Payer passed as object.")
-    elif payer_arg == buyer.id:
-        print("FAILURE: Payer passed as ID.")
-    else:
-        print(f"FAILURE: Unknown payer arg: {payer_arg}")
-
-if __name__ == "__main__":
-    test_tax_collection_args()
