diff --git a/analysis/compare_engine_performance.py b/analysis/compare_engine_performance.py
index 007d0f8..9409577 100644
--- a/analysis/compare_engine_performance.py
+++ b/analysis/compare_engine_performance.py
@@ -6,15 +6,19 @@ from typing import List, Dict, Any, Optional
 
 DB_PATH = "simulation_data.db"
 
+
 def get_connection(db_path: str = DB_PATH):
     if not os.path.exists(db_path):
         print(f"Error: Database file '{db_path}' not found.")
         return None
     return sqlite3.connect(db_path)
 
+
 def list_runs(conn: sqlite3.Connection):
     cursor = conn.cursor()
-    cursor.execute("SELECT run_id, start_time, description FROM simulation_runs ORDER BY run_id DESC LIMIT 10")
+    cursor.execute(
+        "SELECT run_id, start_time, description FROM simulation_runs ORDER BY run_id DESC LIMIT 10"
+    )
     runs = cursor.fetchall()
     print("\n--- Recent Simulation Runs ---")
     print(f"{'Run ID':<10} {'Start Time':<25} {'Description'}")
@@ -25,12 +29,14 @@ def list_runs(conn: sqlite3.Connection):
     print("-" * 50)
     return runs
 
+
 def get_run_metrics(conn: sqlite3.Connection, run_id: int) -> Dict[str, Any]:
     metrics = {}
     cursor = conn.cursor()
-    
+
     # 1. Economic Indicators
-    cursor.execute("""
+    cursor.execute(
+        """
         SELECT 
             AVG(total_consumption), 
             AVG(total_household_assets), 
@@ -39,73 +45,82 @@ def get_run_metrics(conn: sqlite3.Connection, run_id: int) -> Dict[str, Any]:
             AVG(food_avg_price)
         FROM economic_indicators 
         WHERE run_id = ?
-    """, (run_id,))
+    """,
+        (run_id,),
+    )
     row = cursor.fetchone()
     if row:
-        metrics['avg_gdp'] = row[0]
-        metrics['avg_household_assets'] = row[1]
-        metrics['avg_firm_assets'] = row[2]
-        metrics['avg_unemployment'] = row[3]
-        metrics['avg_food_price'] = row[4]
-    
+        metrics["avg_gdp"] = row[0]
+        metrics["avg_household_assets"] = row[1]
+        metrics["avg_firm_assets"] = row[2]
+        metrics["avg_unemployment"] = row[3]
+        metrics["avg_food_price"] = row[4]
+
     # 2. Agent Needs (from AgentState) - Optional, takes longer
     # Assuming we want average survival need for households
-    cursor.execute("""
+    cursor.execute(
+        """
         SELECT AVG(needs_survival)
         FROM agent_states
         WHERE run_id = ? AND agent_type = 'Household'
-    """, (run_id,))
+    """,
+        (run_id,),
+    )
     row = cursor.fetchone()
     if row and row[0] is not None:
-         metrics['avg_household_survival_need'] = row[0]
+        metrics["avg_household_survival_need"] = row[0]
     else:
-         metrics['avg_household_survival_need'] = 0.0
+        metrics["avg_household_survival_need"] = 0.0
 
     return metrics
 
+
 def compare_runs(conn: sqlite3.Connection, run_id_1: int, run_id_2: int):
     print(f"\n--- Comparing Run {run_id_1} vs Run {run_id_2} ---")
-    
+
     metrics1 = get_run_metrics(conn, run_id_1)
     metrics2 = get_run_metrics(conn, run_id_2)
-    
+
     if not metrics1 or not metrics2:
         print("Error: Could not retrieve metrics for one or both runs.")
         return
 
-    print(f"{'Metric':<30} | {'Run ' + str(run_id_1):<15} | {'Run ' + str(run_id_2):<15} | {'Diff (%)':<10}")
+    print(
+        f"{'Metric':<30} | {'Run ' + str(run_id_1):<15} | {'Run ' + str(run_id_2):<15} | {'Diff (%)':<10}"
+    )
     print("-" * 80)
-    
+
     compare_keys = [
-        ('Avg GDP', 'avg_gdp'),
-        ('Avg Household Assets', 'avg_household_assets'),
-        ('Avg Firm Assets', 'avg_firm_assets'),
-        ('Avg Unemployment Rate', 'avg_unemployment'),
-        ('Avg Food Price', 'avg_food_price'),
-        ('Avg Survival Need', 'avg_household_survival_need')
+        ("Avg GDP", "avg_gdp"),
+        ("Avg Household Assets", "avg_household_assets"),
+        ("Avg Firm Assets", "avg_firm_assets"),
+        ("Avg Unemployment Rate", "avg_unemployment"),
+        ("Avg Food Price", "avg_food_price"),
+        ("Avg Survival Need", "avg_household_survival_need"),
     ]
-    
+
     for label, key in compare_keys:
         val1 = metrics1.get(key, 0) or 0
         val2 = metrics2.get(key, 0) or 0
-        
+
         diff_pct = 0.0
         if val1 != 0:
             diff_pct = ((val2 - val1) / val1) * 100
         elif val2 != 0:
             diff_pct = 100.0 if val2 > 0 else -100.0
-            
+
         print(f"{label:<30} | {val1:<15.2f} | {val2:<15.2f} | {diff_pct:+.2f}%")
-        
+
     print("-" * 80)
 
+
 def main():
     parser = argparse.ArgumentParser(description="Compare simulation run performance.")
-    parser.add_argument("run1", type=int, nargs='?', help="Run ID 1")
-    parser.add_argument("run2", type=int, nargs='?', help="Run ID 2")
-    
+    parser.add_argument("run1", type=int, nargs="?", help="Run ID 1")
+    parser.add_argument("run2", type=int, nargs="?", help="Run ID 2")
+
     args = parser.parse_args()
-    
+
     conn = get_connection()
     if not conn:
         return
@@ -118,14 +133,15 @@ def main():
                 # Auto-select last two if available
                 r1 = runs[0][0]
                 r2 = runs[1][0]
-                compare_runs(conn, r2, r1) # Compare older (r2) vs newer (r1)
+                compare_runs(conn, r2, r1)  # Compare older (r2) vs newer (r1)
             else:
-                 print("Not enough runs to compare.")
+                print("Not enough runs to compare.")
         else:
             compare_runs(conn, args.run1, args.run2)
-            
+
     finally:
         conn.close()
 
+
 if __name__ == "__main__":
     main()
diff --git a/config.py b/config.py
index 803394a..6a99680 100644
--- a/config.py
+++ b/config.py
@@ -8,20 +8,24 @@ from enum import Enum
 
 # --- Phase 21: Corporate Empires ---
 AUTOMATION_LABOR_REDUCTION = 0.1  # Max 50% reduction in labor alpha
-AUTOMATION_COST_PER_PCT = 10000.0  # Base cost to increase automation by 1% (scaled by assets)
-HOSTILE_TAKEOVER_DISCOUNT_THRESHOLD = 0.7  # Target if Market Cap < 70% of Intrinsic Value
+AUTOMATION_COST_PER_PCT = (
+    10000.0  # Base cost to increase automation by 1% (scaled by assets)
+)
+HOSTILE_TAKEOVER_DISCOUNT_THRESHOLD = (
+    0.7  # Target if Market Cap < 70% of Intrinsic Value
+)
 
 # --- Phase 21.5: Stabilization (WO-044) ---
 # LABOR_ELASTICITY_MIN moved to Phase 21.6
-SEVERANCE_PAY_WEEKS = 4             # í•´ê³  ì‹œ 4ì£¼ì¹˜ ì„ê¸ˆ ì§€ê¸‰
+SEVERANCE_PAY_WEEKS = 4  # í•´ê³  ì‹œ 4ì£¼ì¹˜ ì„ê¸ˆ ì§€ê¸‰
 
 # --- Phase 21.6: The Invisible Hand (WO-045) ---
-LABOR_ELASTICITY_MIN = 0.0              # ê°€ë“œë ˆì¼ ì œê±°
-RESERVATION_WAGE_FLOOR_RATIO = 0.7      # ì‹œì¥ í‰ê· ì˜ 70% ë¯¸ë§Œ ê±°ë¶€
-WAGE_DECAY_RATE = 0.02                  # ì‹¤ì—… ì‹œ í¬ë§ì„ê¸ˆ í•˜ë½ë¥  (2%/í‹±)
-WAGE_RECOVERY_RATE = 0.01               # ì·¨ì—… ì‹œ í¬ë§ì„ê¸ˆ ìƒìŠ¹ë¥  (1%/í‹±)
-RESERVATION_WAGE_FLOOR = 0.3            # ìµœì € í¬ë§ì„ê¸ˆ (ì‹œì¥ í‰ê· ì˜ 30%)
-SURVIVAL_CRITICAL_TURNS = 5             # ìƒì¡´ ê°€ëŠ¥ ì”ì—¬ ê¸°ê°„ ì„ê³„ê°’
+LABOR_ELASTICITY_MIN = 0.0  # ê°€ë“œë ˆì¼ ì œê±°
+RESERVATION_WAGE_FLOOR_RATIO = 0.7  # ì‹œì¥ í‰ê· ì˜ 70% ë¯¸ë§Œ ê±°ë¶€
+WAGE_DECAY_RATE = 0.02  # ì‹¤ì—… ì‹œ í¬ë§ì„ê¸ˆ í•˜ë½ë¥  (2%/í‹±)
+WAGE_RECOVERY_RATE = 0.01  # ì·¨ì—… ì‹œ í¬ë§ì„ê¸ˆ ìƒìŠ¹ë¥  (1%/í‹±)
+RESERVATION_WAGE_FLOOR = 0.3  # ìµœì € í¬ë§ì„ê¸ˆ (ì‹œì¥ í‰ê· ì˜ 30%)
+SURVIVAL_CRITICAL_TURNS = 5  # ìƒì¡´ ê°€ëŠ¥ ì”ì—¬ ê¸°ê°„ ì„ê³„ê°’
 
 
 # --- Phase 20: The Matrix v1 ---
@@ -38,8 +42,8 @@ IMMIGRATION_BATCH_SIZE = 5
 
 # --- Phase 17-4: Vanity System ---
 ENABLE_VANITY_SYSTEM = True
-VANITY_WEIGHT = 1.5           # í—ˆì˜ì‹¬ ê°•ë„ (0=ë¶ˆêµ, 1=ìë³¸ì£¼ì˜, 1.5=í—¬ì¡°ì„ )
-MIMICRY_FACTOR = 0.5          # ëª¨ë°© ì†Œë¹„ ê°•ë„
+VANITY_WEIGHT = 1.5  # í—ˆì˜ì‹¬ ê°•ë„ (0=ë¶ˆêµ, 1=ìë³¸ì£¼ì˜, 1.5=í—¬ì¡°ì„ )
+MIMICRY_FACTOR = 0.5  # ëª¨ë°© ì†Œë¹„ ê°•ë„
 REFERENCE_GROUP_PERCENTILE = 0.20  # ìƒìœ„ 20%
 
 # ì„±ê²© ìœ í˜•ë³„ Conformity ë²”ìœ„ (Biased Randomization)
@@ -49,27 +53,33 @@ CONFORMITY_RANGES = {
     "MISER": (0.1, 0.3),
     "IMPULSIVE": (0.4, 0.6),  # ì¤‘ê°„
     # ê¸°ë³¸ê°’
-    None: (0.3, 0.7)
+    None: (0.3, 0.7),
 }
 
 # --- Gold Standard Mode (WO-016) ---
-GOLD_STANDARD_MODE = True  # True: ê¸ˆë³¸ìœ„ (Full Reserve), False: í˜„ëŒ€ ê¸ˆìœµ (Credit Creation)
-RESERVE_REQ_RATIO = 0.1    # ì§€ê¸‰ì¤€ë¹„ìœ¨ (10%) - WO-064
+GOLD_STANDARD_MODE = (
+    True  # True: ê¸ˆë³¸ìœ„ (Full Reserve), False: í˜„ëŒ€ ê¸ˆìœµ (Credit Creation)
+)
+RESERVE_REQ_RATIO = 0.1  # ì§€ê¸‰ì¤€ë¹„ìœ¨ (10%) - WO-064
 INITIAL_MONEY_SUPPLY = 100_000.0  # ì´ˆê¸° í™”í ì´ëŸ‰ (ê²€ì¦ìš© ê¸°ì¤€ê°’)
 
 # --- Simulation Parameters ---
 NUM_HOUSEHOLDS = 20
 NUM_FIRMS = 4
 SIMULATION_TICKS = 1000
-HOUSEHOLD_MIN_FOOD_INVENTORY = 0.0 # Operation Empty Warehouse: No initial safety net
-TARGET_FOOD_BUFFER_QUANTITY = 5.0 # WO-023: Maslow Constraint Threshold
+HOUSEHOLD_MIN_FOOD_INVENTORY = 0.0  # Operation Empty Warehouse: No initial safety net
+TARGET_FOOD_BUFFER_QUANTITY = 5.0  # WO-023: Maslow Constraint Threshold
+
 
 class EngineType(Enum):
     RULE_BASED = "RuleBased"
     AI_DRIVEN = "AIDriven"
 
+
 DEFAULT_ENGINE_TYPE = EngineType.AI_DRIVEN  # Can be RULE_BASED or AI_DRIVEN
-NEWBORN_ENGINE_TYPE = "AIDriven"  # Default engine for newborns: "AIDriven" or "RuleBased"
+NEWBORN_ENGINE_TYPE = (
+    "AIDriven"  # Default engine for newborns: "AIDriven" or "RuleBased"
+)
 
 # --- Initial Agent Configuration ---
 INITIAL_HOUSEHOLD_ASSETS_RANGE = 0.2
@@ -88,18 +98,18 @@ INITIAL_HOUSEHOLD_NEEDS_MEAN = {
     "labor_need": 0.0,
     "labor_need": 0.0,
     "child_rearing_need": 0.0,
-    "quality": 0.0, # WO-023: New need for consumer goods
+    "quality": 0.0,  # WO-023: New need for consumer goods
 }
 INITIAL_HOUSEHOLD_NEEDS_RANGE = 0.1
 INITIAL_EMPLOYMENT_RATE = 0.5  # ì´ˆê¸° ê³ ìš©ë¥ 
 
-INITIAL_FIRM_CAPITAL_MEAN = 10000.0 # High Initial Capital for Laissez-Faire Runway
+INITIAL_FIRM_CAPITAL_MEAN = 10000.0  # High Initial Capital for Laissez-Faire Runway
 INITIAL_FIRM_CAPITAL_RANGE = 0.2
 INITIAL_FIRM_LIQUIDITY_NEED_MEAN = 200.0
 INITIAL_FIRM_LIQUIDITY_NEED_RANGE = 0.2
 INITIAL_FIRM_INVENTORY_MEAN = 0.0  # Operation Empty Warehouse: No initial safety net
 INITIAL_FIRM_INVENTORY_RANGE = 0.2
-FIRM_PRODUCTIVITY_FACTOR = 20.0 # Laissez-Faire: Double Output
+FIRM_PRODUCTIVITY_FACTOR = 20.0  # Laissez-Faire: Double Output
 
 # --- Goods Configuration ---
 GOODS = {
@@ -145,12 +155,12 @@ GOODS = {
         "production_cost": 5.0,
         "initial_price": 15.0,
         "utility_effects": {"quality": 10},
-        "is_luxury": True, # Treated as luxury/higher tier need
+        "is_luxury": True,  # Treated as luxury/higher tier need
         "sector": "GOODS",
         "is_durable": True,
         "base_lifespan": 50,  # Ticks
         "quality_sensitivity": 0.5,
-        "inputs": {"iron": 1.0}, # WO-030: 1 unit of iron per unit of consumer_goods
+        "inputs": {"iron": 1.0},  # WO-030: 1 unit of iron per unit of consumer_goods
     },
     "luxury_bag": {
         "production_cost": 500,
@@ -168,10 +178,7 @@ HOUSEHOLD_CONSUMABLE_GOODS = ["basic_food", "luxury_food"]
 
 
 # Added for explicit reference
-GOODS_INITIAL_PRICE = {
-    "basic_food": 5.0,
-    "stock": 50.0
-}
+GOODS_INITIAL_PRICE = {"basic_food": 5.0, "stock": 50.0}
 
 
 # --- Firm Specialization ---
@@ -231,7 +238,7 @@ PERCEIVED_PRICE_UPDATE_FACTOR = 0.1
 INVENTORY_HOLDING_COST_RATE = 0.005
 DIVIDEND_RATE = 0.1  # ê¸°ë³¸ ë°°ë‹¹ë¥ 
 DIVIDEND_RATE_MIN = 0.05  # ìµœì†Œ ë°°ë‹¹ë¥  (ì €ë°°ë‹¹ ì •ì±…)
-DIVIDEND_RATE_MAX = 0.5   # ìµœëŒ€ ë°°ë‹¹ë¥  (ê³ ë°°ë‹¹ ì •ì±…)
+DIVIDEND_RATE_MAX = 0.5  # ìµœëŒ€ ë°°ë‹¹ë¥  (ê³ ë°°ë‹¹ ì •ì±…)
 # WAGE_DECAY_RATE removed - Overwritten in Phase 21.6 section
 RND_WAGE_PREMIUM = 1.5
 WAGE_COMPETITION_PREMIUM = 0.2
@@ -285,24 +292,20 @@ SURVIVAL_TO_LABOR_NEED_FACTOR = 0.5
 # --- Household Consumption ---
 # TARGET_FOOD_BUFFER_QUANTITY is already defined above
 PERCEIVED_FAIR_PRICE_THRESHOLD_FACTOR = 0.9
-SURVIVAL_NEED_CONSUMPTION_THRESHOLD = (
-    50.0  # Consume earlier (when hungry > 50)
-)
+SURVIVAL_NEED_CONSUMPTION_THRESHOLD = 50.0  # Consume earlier (when hungry > 50)
 FOOD_CONSUMPTION_QUANTITY = 1.0  # Eat MORE to reduce hunger faster
-FOOD_CONSUMPTION_MAX_PER_TICK = (
-    20.0  # Allow binging
-)
-FOOD_PURCHASE_MAX_PER_TICK = (
-    50.0  # Allow bulk buy
-)
-HOUSEHOLD_MAX_PURCHASE_QUANTITY = 5.0 # Max units per item per tick for bulk buying
+FOOD_CONSUMPTION_MAX_PER_TICK = 20.0  # Allow binging
+FOOD_PURCHASE_MAX_PER_TICK = 50.0  # Allow bulk buy
+HOUSEHOLD_MAX_PURCHASE_QUANTITY = 5.0  # Max units per item per tick for bulk buying
 HOUSEHOLD_FOOD_PRICE_ELASTICITY = (
     0.5  # Factor to adjust demand based on price deviation from average
 )
 HOUSEHOLD_FOOD_STOCKPILE_TARGET_TICKS = (
     5  # How many ticks worth of food a household aims to stockpile when prices are good
 )
-HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK = 2.0  # Increased for Genesis circulation (Jules tuning)
+HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK = (
+    2.0  # Increased for Genesis circulation (Jules tuning)
+)
 HOUSEHOLD_MIN_FOOD_INVENTORY_TICKS = (
     2  # Minimum number of ticks worth of food a household aims to keep in inventory
 )
@@ -327,11 +330,13 @@ AI_WEALTH_REWARD_WEIGHT = 3.0
 
 # --- Genesis: Activation Energy (WO-047: Capital Injection) ---
 INITIAL_HOUSEHOLD_ASSETS_MEAN = 5000.0  # 50.0 -> 5000.0 (100x Booster)
-INITIAL_FIRM_CAPITAL_MEAN = 50000.0   # 1000.0 -> 50000.0 (50x Runway for Regulations)
+INITIAL_FIRM_CAPITAL_MEAN = 50000.0  # 1000.0 -> 50000.0 (50x Runway for Regulations)
 
 # --- Genesis: Market Flexibility Multipliers ---
 GENESIS_PRICE_ADJUSTMENT_MULTIPLIER = 2.0  # Speed up price slashing
-GENESIS_WAGE_FLEXIBILITY_FACTOR = 0.5      # How much faster households drop reservation wage
+GENESIS_WAGE_FLEXIBILITY_FACTOR = (
+    0.5  # How much faster households drop reservation wage
+)
 
 # --- AI Learning Parameters ---
 AI_GAMMA = 0.9
@@ -354,18 +359,18 @@ IMITATION_MUTATION_MAGNITUDE = 0.05
 MASLOW_SURVIVAL_THRESHOLD = 50.0  # ì´ ê°’ ì´ˆê³¼ ì‹œ ìƒìœ„ ìš•êµ¬ ë¹„í™œì„±í™”
 
 # --- Education Service ---
-EDUCATION_SENSITIVITY = 0.1       # êµìœ¡ íš¨ê³¼ ë¯¼ê°ë„
-BASE_LEARNING_RATE = 0.1          # ê¸°ë³¸ í•™ìŠµë¥ 
-MAX_LEARNING_RATE = 0.5           # ìµœëŒ€ í•™ìŠµë¥ 
-LEARNING_EFFICIENCY = 1.0         # XP íšë“ íš¨ìœ¨
-HALO_EFFECT = 0.15                # í•™ë²Œ í”„ë¦¬ë¯¸ì—„ (15% per Level)
-EDUCATION_WEALTH_THRESHOLDS = {   # ìì‚°ë³„ ì‹œì‘ êµìœ¡ ìˆ˜ì¤€
+EDUCATION_SENSITIVITY = 0.1  # êµìœ¡ íš¨ê³¼ ë¯¼ê°ë„
+BASE_LEARNING_RATE = 0.1  # ê¸°ë³¸ í•™ìŠµë¥ 
+MAX_LEARNING_RATE = 0.5  # ìµœëŒ€ í•™ìŠµë¥ 
+LEARNING_EFFICIENCY = 1.0  # XP íšë“ íš¨ìœ¨
+HALO_EFFECT = 0.15  # í•™ë²Œ í”„ë¦¬ë¯¸ì—„ (15% per Level)
+EDUCATION_WEALTH_THRESHOLDS = {  # ìì‚°ë³„ ì‹œì‘ êµìœ¡ ìˆ˜ì¤€
     0: 0.0,
     1: 2000.0,
     2: 5000.0,
     3: 10000.0,
     4: 20000.0,
-    5: 50000.0
+    5: 50000.0,
 }
 
 
@@ -377,11 +382,11 @@ LOAN_DURATION = 20
 DEFAULT_LOAN_DURATION = 10
 
 # --- Banking & Time Scale (Phase 3) ---
-TICKS_PER_YEAR = 100.0          # 1ë…„ = 100í‹± (ëª¨ë“  ì´ì ê³„ì‚°ì˜ ê¸°ì¤€)
-INITIAL_BASE_ANNUAL_RATE = 0.05 # ì—° 5% (í‹±ë‹¹ ê¸ˆë¦¬ê°€ ì•„ë‹˜!)
-LOAN_DEFAULT_TERM = 50          # 6ê°œì›” (50í‹±)
-CREDIT_SPREAD_BASE = 0.02       # ì—° 2% ê°€ì‚°ê¸ˆë¦¬
-BANK_MARGIN = 0.02              # ì˜ˆëŒ€ë§ˆì§„ (ì—° 2%)
+TICKS_PER_YEAR = 100.0  # 1ë…„ = 100í‹± (ëª¨ë“  ì´ì ê³„ì‚°ì˜ ê¸°ì¤€)
+INITIAL_BASE_ANNUAL_RATE = 0.05  # ì—° 5% (í‹±ë‹¹ ê¸ˆë¦¬ê°€ ì•„ë‹˜!)
+LOAN_DEFAULT_TERM = 50  # 6ê°œì›” (50í‹±)
+CREDIT_SPREAD_BASE = 0.02  # ì—° 2% ê°€ì‚°ê¸ˆë¦¬
+BANK_MARGIN = 0.02  # ì˜ˆëŒ€ë§ˆì§„ (ì—° 2%)
 
 
 # --- Liquidity ---
@@ -399,32 +404,31 @@ ROOT_LOGGER_LEVEL = "INFO"
 SECRET_TOKEN = os.getenv("SECRET_TOKEN", "default-secret-token")
 
 
-
 # ==============================================================================
 # Phase 5: Time Allocation & Leisure Constants
 # ==============================================================================
 HOURS_PER_TICK = 24.0
-SHOPPING_HOURS = 2.0   # ì‡¼í•‘ ë° ê°€ì‚¬ ì‹œê°„ (ê³ ì •)
+SHOPPING_HOURS = 2.0  # ì‡¼í•‘ ë° ê°€ì‚¬ ì‹œê°„ (ê³ ì •)
 MAX_WORK_HOURS = 14.0  # ë²•ì •/ë¬¼ë¦¬ì  ìµœëŒ€ ë…¸ë™ ì‹œê°„
-LEISURE_WEIGHT = 0.3   # AI ë³´ìƒ í•¨ìˆ˜ì—ì„œ ì—¬ê°€ íš¨ìš©ì˜ ê°€ì¤‘ì¹˜
+LEISURE_WEIGHT = 0.3  # AI ë³´ìƒ í•¨ìˆ˜ì—ì„œ ì—¬ê°€ íš¨ìš©ì˜ ê°€ì¤‘ì¹˜
 
 # ì—¬ê°€ ìœ í˜•ë³„ ê³„ìˆ˜
 LEISURE_COEFFS = {
     "PARENTING": {
         "condition_item": "education_service",
-        "utility_per_hour": 2.0,   # ì‹œê°„ë‹¹ ì‚¬íšŒì  ë§Œì¡±
-        "xp_gain_per_hour": 0.5    # ì‹œê°„ë‹¹ ìë…€ XP ì¦ê°€
+        "utility_per_hour": 2.0,  # ì‹œê°„ë‹¹ ì‚¬íšŒì  ë§Œì¡±
+        "xp_gain_per_hour": 0.5,  # ì‹œê°„ë‹¹ ìë…€ XP ì¦ê°€
     },
     "ENTERTAINMENT": {
         "condition_item": "luxury_food",  # or clothing
-        "utility_per_hour": 5.0,   # ë†’ì€ ì¦‰ê°ì  ë§Œì¡±
-        "xp_gain_per_hour": 0.0
+        "utility_per_hour": 5.0,  # ë†’ì€ ì¦‰ê°ì  ë§Œì¡±
+        "xp_gain_per_hour": 0.0,
     },
     "SELF_DEV": {
-        "condition_item": None,    # Default (ì¡°ê±´ ì—†ìŒ)
-        "utility_per_hour": 1.0,   # ë‚®ì€ ë§Œì¡±
-        "productivity_gain": 0.001 # ë³¸ì¸ ìƒì‚°ì„± í–¥ìƒ
-    }
+        "condition_item": None,  # Default (ì¡°ê±´ ì—†ìŒ)
+        "utility_per_hour": 1.0,  # ë‚®ì€ ë§Œì¡±
+        "productivity_gain": 0.001,  # ë³¸ì¸ ìƒì‚°ì„± í–¥ìƒ
+    },
 }
 
 
@@ -441,8 +445,8 @@ LEISURE_COEFFS = {
 # ------------------------------------------------------------------------------
 # ê°€ê³„ì˜ í¬ë§ ì„ê¸ˆ ê²°ì •ì— ì‚¬ìš©ë˜ëŠ” ê°’ë“¤
 HOUSEHOLD_LOW_ASSET_THRESHOLD = 100.0  # ìì‚°ì´ ì´ ê°’ ë¯¸ë§Œì´ë©´ ë‚®ì€ ì„ê¸ˆ ìˆ˜ìš©
-HOUSEHOLD_LOW_ASSET_WAGE = 8.0         # ìì‚°ì´ ë‚®ì„ ë•Œ í¬ë§ ì„ê¸ˆ
-HOUSEHOLD_DEFAULT_WAGE = 10.0          # ê¸°ë³¸ í¬ë§ ì„ê¸ˆ
+HOUSEHOLD_LOW_ASSET_WAGE = 8.0  # ìì‚°ì´ ë‚®ì„ ë•Œ í¬ë§ ì„ê¸ˆ
+HOUSEHOLD_DEFAULT_WAGE = 10.0  # ê¸°ë³¸ í¬ë§ ì„ê¸ˆ
 
 # ì‹œì¥ ê°€ê²© í´ë°± (ì‹œì¥ ë°ì´í„° ì—†ì„ ë•Œ ì‚¬ìš©)
 MARKET_PRICE_FALLBACK = 10.0
@@ -466,32 +470,32 @@ FIRM_LABOR_REQUIREMENT_RATIO = 0.9  # í•„ìš” ë…¸ë™ë ¥ ëŒ€ë¹„ í˜„ì¬ ê³ ìš© ë¹„
 # ------------------------------------------------------------------------------
 
 # --- ìš•êµ¬ ê¸°ë°˜ ê°€ì¹˜ í‰ê°€ (Need-Based Valuation) ---
-NEED_FACTOR_BASE = 0.5              # ìš•êµ¬ íŒ©í„° ê¸°ë³¸ê°’ (max_need=0ì¼ ë•Œ)
-NEED_FACTOR_SCALE = 100.0           # ìš•êµ¬ê°’ì„ ì •ê·œí™”í•˜ëŠ” ìŠ¤ì¼€ì¼
-VALUATION_MODIFIER_BASE = 0.9       # ê°€ì¹˜ í‰ê°€ ìˆ˜ì •ì ê¸°ë³¸ê°’
-VALUATION_MODIFIER_RANGE = 0.2      # ê°€ì¹˜ í‰ê°€ ìˆ˜ì •ì ë²”ìœ„ (agg_buyì— ë”°ë¼ ë³€ë™)
+NEED_FACTOR_BASE = 0.5  # ìš•êµ¬ íŒ©í„° ê¸°ë³¸ê°’ (max_need=0ì¼ ë•Œ)
+NEED_FACTOR_SCALE = 100.0  # ìš•êµ¬ê°’ì„ ì •ê·œí™”í•˜ëŠ” ìŠ¤ì¼€ì¼
+VALUATION_MODIFIER_BASE = 0.9  # ê°€ì¹˜ í‰ê°€ ìˆ˜ì •ì ê¸°ë³¸ê°’
+VALUATION_MODIFIER_RANGE = 0.2  # ê°€ì¹˜ í‰ê°€ ìˆ˜ì •ì ë²”ìœ„ (agg_buyì— ë”°ë¼ ë³€ë™)
 
 # --- ìš•êµ¬ ì„ê³„ê°’ (Need Thresholds for Bulk Buying) ---
-BULK_BUY_NEED_THRESHOLD = 70.0      # ì´ ê°’ ì´ìƒì´ë©´ ëŒ€ëŸ‰ êµ¬ë§¤
-BULK_BUY_AGG_THRESHOLD = 0.8        # ê³µê²©ì„±ì´ ì´ ê°’ ì´ìƒì´ë©´ ì¶”ê°€ êµ¬ë§¤
-BULK_BUY_MODERATE_RATIO = 0.6       # ë³´í†µ íŒ¨ë‹‰ êµ¬ë§¤ ì‹œ ìµœëŒ€ ìˆ˜ëŸ‰ ë¹„ìœ¨
+BULK_BUY_NEED_THRESHOLD = 70.0  # ì´ ê°’ ì´ìƒì´ë©´ ëŒ€ëŸ‰ êµ¬ë§¤
+BULK_BUY_AGG_THRESHOLD = 0.8  # ê³µê²©ì„±ì´ ì´ ê°’ ì´ìƒì´ë©´ ì¶”ê°€ êµ¬ë§¤
+BULK_BUY_MODERATE_RATIO = 0.6  # ë³´í†µ íŒ¨ë‹‰ êµ¬ë§¤ ì‹œ ìµœëŒ€ ìˆ˜ëŸ‰ ë¹„ìœ¨
 
 # --- ì˜ˆì‚° ì œí•œ (Budget Constraints) ---
-BUDGET_LIMIT_NORMAL_RATIO = 0.5     # ì¼ë°˜ ìƒí™©ì—ì„œ ìì‚° ëŒ€ë¹„ ì˜ˆì‚° ë¹„ìœ¨
-BUDGET_LIMIT_URGENT_NEED = 80.0     # ì´ ìš•êµ¬ ì´ìƒì´ë©´ ê¸´ê¸‰ ì˜ˆì‚° ì ìš©
-BUDGET_LIMIT_URGENT_RATIO = 0.9     # ê¸´ê¸‰ ìƒí™©ì—ì„œ ìì‚° ëŒ€ë¹„ ì˜ˆì‚° ë¹„ìœ¨
+BUDGET_LIMIT_NORMAL_RATIO = 0.5  # ì¼ë°˜ ìƒí™©ì—ì„œ ìì‚° ëŒ€ë¹„ ì˜ˆì‚° ë¹„ìœ¨
+BUDGET_LIMIT_URGENT_NEED = 80.0  # ì´ ìš•êµ¬ ì´ìƒì´ë©´ ê¸´ê¸‰ ì˜ˆì‚° ì ìš©
+BUDGET_LIMIT_URGENT_RATIO = 0.9  # ê¸´ê¸‰ ìƒí™©ì—ì„œ ìì‚° ëŒ€ë¹„ ì˜ˆì‚° ë¹„ìœ¨
 
 # --- ì§ì¥ ì´ë™ (Job Mobility) ---
-JOB_QUIT_THRESHOLD_BASE = 2.0       # ê¸°ë³¸ í‡´ì§ ì„ê³„ê°’ (ë‚®ì€ ì´ë™ì„±ì¼ ë•Œ)
-JOB_QUIT_PROB_BASE = 0.1            # í‡´ì§ í™•ë¥  ê¸°ë³¸ê°’
-JOB_QUIT_PROB_SCALE = 0.9           # í‡´ì§ í™•ë¥  ìŠ¤ì¼€ì¼ (agg_mobilityì— ë”°ë¼ ë³€ë™)
+JOB_QUIT_THRESHOLD_BASE = 2.0  # ê¸°ë³¸ í‡´ì§ ì„ê³„ê°’ (ë‚®ì€ ì´ë™ì„±ì¼ ë•Œ)
+JOB_QUIT_PROB_BASE = 0.1  # í‡´ì§ í™•ë¥  ê¸°ë³¸ê°’
+JOB_QUIT_PROB_SCALE = 0.9  # í‡´ì§ í™•ë¥  ìŠ¤ì¼€ì¼ (agg_mobilityì— ë”°ë¼ ë³€ë™)
 
 # --- ìœ ë³´ ì„ê¸ˆ (Reservation Wage) ---
-RESERVATION_WAGE_BASE = 1.5         # ìœ ë³´ ì„ê¸ˆ ê³„ì‚° ê¸°ë³¸ê°’
-RESERVATION_WAGE_RANGE = 1.0        # ìœ ë³´ ì„ê¸ˆ ê³„ì‚° ë²”ìœ„
+RESERVATION_WAGE_BASE = 1.5  # ìœ ë³´ ì„ê¸ˆ ê³„ì‚° ê¸°ë³¸ê°’
+RESERVATION_WAGE_RANGE = 1.0  # ìœ ë³´ ì„ê¸ˆ ê³„ì‚° ë²”ìœ„
 
 # --- ìµœì†Œ êµ¬ë§¤ ìˆ˜ëŸ‰ (Minimum Purchase Quantity) ---
-MIN_PURCHASE_QUANTITY = 0.1         # êµ¬ë§¤ë¥¼ ì‹¤í–‰í•˜ê¸° ìœ„í•œ ìµœì†Œ ìˆ˜ëŸ‰
+MIN_PURCHASE_QUANTITY = 0.1  # êµ¬ë§¤ë¥¼ ì‹¤í–‰í•˜ê¸° ìœ„í•œ ìµœì†Œ ìˆ˜ëŸ‰
 
 # ------------------------------------------------------------------------------
 # ğŸ“ AI HYPERPARAMETERS (AI í•™ìŠµ í•˜ì´í¼íŒŒë¼ë¯¸í„°)
@@ -501,11 +505,11 @@ MIN_PURCHASE_QUANTITY = 0.1         # êµ¬ë§¤ë¥¼ ì‹¤í–‰í•˜ê¸° ìœ„í•œ ìµœì†Œ ìˆ˜
 # AI_GAMMA, AI_EPSILON, AI_BASE_ALPHA, AI_LEARNING_FOCUS ëŠ” ì´ë¯¸ ìœ„ì— ì •ì˜ë¨.
 
 # ìƒìœ„/í•˜ìœ„ ì—ì´ì „íŠ¸ ì„ ë³„ ë°±ë¶„ìœ„
-TOP_PERFORMING_PERCENTILE = 0.1     # ìƒìœ„ 10% ì—ì´ì „íŠ¸ (ëª¨ë°© í•™ìŠµ ëŒ€ìƒ)
-UNDER_PERFORMING_PERCENTILE = 0.5   # í•˜ìœ„ 50% ì—ì´ì „íŠ¸ (í•™ìŠµ í•„ìš” ëŒ€ìƒ)
+TOP_PERFORMING_PERCENTILE = 0.1  # ìƒìœ„ 10% ì—ì´ì „íŠ¸ (ëª¨ë°© í•™ìŠµ ëŒ€ìƒ)
+UNDER_PERFORMING_PERCENTILE = 0.5  # í•˜ìœ„ 50% ì—ì´ì „íŠ¸ (í•™ìŠµ í•„ìš” ëŒ€ìƒ)
 
 # --- ê°€ê²© ê²°ì • AI (AI Price Decision) ---
-AI_MIN_PRICE_FLOOR = 0.1            # AIê°€ ì„¤ì • ê°€ëŠ¥í•œ ìµœì € ê°€ê²© í•˜í•œ
+AI_MIN_PRICE_FLOOR = 0.1  # AIê°€ ì„¤ì • ê°€ëŠ¥í•œ ìµœì € ê°€ê²© í•˜í•œ
 
 # ------------------------------------------------------------------------------
 # ğŸ“ˆ STOCK MARKET PARAMETERS (ì£¼ì‹ ì‹œì¥ íŒŒë¼ë¯¸í„°)
@@ -513,61 +517,65 @@ AI_MIN_PRICE_FLOOR = 0.1            # AIê°€ ì„¤ì • ê°€ëŠ¥í•œ ìµœì € ê°€ê²© í•˜
 # ì£¼ì‹ ì‹œì¥ ìš´ì˜ì— í•„ìš”í•œ ì„¤ì •ê°’ë“¤
 
 # --- ê¸°ë³¸ ì„¤ì • ---
-STOCK_MARKET_ENABLED = True         # ì£¼ì‹ ì‹œì¥ í™œì„±í™” ì—¬ë¶€
-STOCK_PRICE_LIMIT_RATE = 0.15       # ì¼ì¼ ê°€ê²© ë³€ë™í­ ì œí•œ (Â±15%) Circuit Breaker
+STOCK_MARKET_ENABLED = True  # ì£¼ì‹ ì‹œì¥ í™œì„±í™” ì—¬ë¶€
+STOCK_PRICE_LIMIT_RATE = 0.15  # ì¼ì¼ ê°€ê²© ë³€ë™í­ ì œí•œ (Â±15%) Circuit Breaker
 
 # --- ì£¼ê°€ ê²°ì • ë°©ì‹ ---
-STOCK_PRICE_METHOD = "book_value"   # "book_value" ë˜ëŠ” "market_price"
-STOCK_BOOK_VALUE_MULTIPLIER = 1.0   # ìˆœìì‚°ê°€ì¹˜ ëŒ€ë¹„ ê¸°ì¤€ ì£¼ê°€ ë°°ìˆ˜ (PBR)
+STOCK_PRICE_METHOD = "book_value"  # "book_value" ë˜ëŠ” "market_price"
+STOCK_BOOK_VALUE_MULTIPLIER = 1.0  # ìˆœìì‚°ê°€ì¹˜ ëŒ€ë¹„ ê¸°ì¤€ ì£¼ê°€ ë°°ìˆ˜ (PBR)
 
 # --- ê±°ë˜ ê´€ë ¨ ---
-STOCK_MIN_ORDER_QUANTITY = 1.0      # ìµœì†Œ ì£¼ë¬¸ ìˆ˜ëŸ‰
-STOCK_ORDER_EXPIRY_TICKS = 5        # ì£¼ë¬¸ ìœ íš¨ ê¸°ê°„ (í‹±)
+STOCK_MIN_ORDER_QUANTITY = 1.0  # ìµœì†Œ ì£¼ë¬¸ ìˆ˜ëŸ‰
+STOCK_ORDER_EXPIRY_TICKS = 5  # ì£¼ë¬¸ ìœ íš¨ ê¸°ê°„ (í‹±)
 STOCK_TRANSACTION_FEE_RATE = 0.001  # ê±°ë˜ ìˆ˜ìˆ˜ë£Œìœ¨ (0.1%)
 
 # --- íˆ¬ì ì˜ì‚¬ê²°ì • ---
 HOUSEHOLD_INVESTMENT_BUDGET_RATIO = 0.2  # ìì‚° ëŒ€ë¹„ ìµœëŒ€ íˆ¬ì ë¹„ìœ¨
 HOUSEHOLD_MIN_ASSETS_FOR_INVESTMENT = 500.0  # íˆ¬ìë¥¼ ìœ„í•œ ìµœì†Œ ìì‚°
 STOCK_SELL_PROFIT_THRESHOLD = 0.15  # ë§¤ë„ ê³ ë ¤ ìˆ˜ìµë¥  ì„ê³„ê°’ (15%)
-STOCK_BUY_DISCOUNT_THRESHOLD = 0.10 # ë§¤ìˆ˜ ê³ ë ¤ í• ì¸ìœ¨ ì„ê³„ê°’ (10%)
-STOCK_INVESTMENT_DIVERSIFICATION_COUNT = 3 # Number of stocks to diversify into
-STOCK_INVESTMENT_EQUITY_DELTA_THRESHOLD = 10.0 # Threshold for buy/sell decisions based on portfolio optimization
+STOCK_BUY_DISCOUNT_THRESHOLD = 0.10  # ë§¤ìˆ˜ ê³ ë ¤ í• ì¸ìœ¨ ì„ê³„ê°’ (10%)
+STOCK_INVESTMENT_DIVERSIFICATION_COUNT = 3  # Number of stocks to diversify into
+STOCK_INVESTMENT_EQUITY_DELTA_THRESHOLD = (
+    10.0  # Threshold for buy/sell decisions based on portfolio optimization
+)
 
 # --- Phase 28: Macro-Stability Stress Testing (Config) ---
-PANIC_SELLING_ASSET_THRESHOLD = 500.0  # ìì‚°ì´ ì´ ê°’ ë¯¸ë§Œì´ë©´ ì£¼ì‹ íŒ¨ë‹‰ ì…€ë§ (ìƒì¡´ ìœ„í˜‘)
-DEBT_REPAYMENT_RATIO = 0.5             # ë¶€ì±„ ìƒí™˜ ì‹œ ìì‚° ëŒ€ë¹„ í• ë‹¹ ë¹„ìœ¨ (ê¸°ë³¸ 50%)
-DEBT_REPAYMENT_CAP = 1.1               # ë¶€ì±„ ìƒí™˜ ìƒí•œì„  (ì›ê¸ˆ * 1.1)
-DEBT_LIQUIDITY_RATIO = 0.9             # ë¶€ì±„ ìƒí™˜ í›„ ìµœì†Œ ìœ ë™ì„± ìœ ì§€ ë¹„ìœ¨ (ìì‚°ì˜ 90%ê¹Œì§€ë§Œ ìƒí™˜)
-DEFAULT_INFLATION_RATE = 0.02          # ê¸°ë³¸ ì¸í”Œë ˆì´ì…˜ìœ¨ (2%)
+PANIC_SELLING_ASSET_THRESHOLD = (
+    500.0  # ìì‚°ì´ ì´ ê°’ ë¯¸ë§Œì´ë©´ ì£¼ì‹ íŒ¨ë‹‰ ì…€ë§ (ìƒì¡´ ìœ„í˜‘)
+)
+DEBT_REPAYMENT_RATIO = 0.5  # ë¶€ì±„ ìƒí™˜ ì‹œ ìì‚° ëŒ€ë¹„ í• ë‹¹ ë¹„ìœ¨ (ê¸°ë³¸ 50%)
+DEBT_REPAYMENT_CAP = 1.1  # ë¶€ì±„ ìƒí™˜ ìƒí•œì„  (ì›ê¸ˆ * 1.1)
+DEBT_LIQUIDITY_RATIO = 0.9  # ë¶€ì±„ ìƒí™˜ í›„ ìµœì†Œ ìœ ë™ì„± ìœ ì§€ ë¹„ìœ¨ (ìì‚°ì˜ 90%ê¹Œì§€ë§Œ ìƒí™˜)
+DEFAULT_INFLATION_RATE = 0.02  # ê¸°ë³¸ ì¸í”Œë ˆì´ì…˜ìœ¨ (2%)
 
 # --- IPO / SEO ---
 IPO_INITIAL_SHARES = 1000.0
-SEO_TRIGGER_RATIO = 0.5              # Trigger SEO when assets < STARTUP_COST * ratio
-SEO_MAX_SELL_RATIO = 0.10            # Max 10% of treasury per tick
+SEO_TRIGGER_RATIO = 0.5  # Trigger SEO when assets < STARTUP_COST * ratio
+SEO_MAX_SELL_RATIO = 0.10  # Max 10% of treasury per tick
 
 # --- Phase 3.1: Government & Taxation ---
-INCOME_TAX_RATE = 0.0                 # Laissez-Faire: Zero Tax
-INCOME_TAX_PAYER = "HOUSEHOLD"         
-CORPORATE_TAX_RATE = 0.0              # Laissez-Faire: Zero Tax
-SALES_TAX_RATE = 0.0                 # Laissez-Faire: Zero Tax
-INHERITANCE_TAX_RATE = 0.0            # Laissez-Faire: Zero Tax
+INCOME_TAX_RATE = 0.0  # Laissez-Faire: Zero Tax
+INCOME_TAX_PAYER = "HOUSEHOLD"
+CORPORATE_TAX_RATE = 0.0  # Laissez-Faire: Zero Tax
+SALES_TAX_RATE = 0.0  # Laissez-Faire: Zero Tax
+INHERITANCE_TAX_RATE = 0.0  # Laissez-Faire: Zero Tax
 
-RD_SUBSIDY_RATE = 0.2                 # R&D(ìë³¸íˆ¬ì) ë³´ì¡°ê¸ˆ (íˆ¬ìì•¡ì˜ 20%)
+RD_SUBSIDY_RATE = 0.2  # R&D(ìë³¸íˆ¬ì) ë³´ì¡°ê¸ˆ (íˆ¬ìì•¡ì˜ 20%)
 INFRASTRUCTURE_INVESTMENT_COST = 5000.0  # ì¸í”„ë¼ íˆ¬ì 1íšŒë‹¹ ë¹„ìš©
-INFRASTRUCTURE_TFP_BOOST = 0.05       # ì¸í”„ë¼ íˆ¬ì ì‹œ ì „ì²´ ìƒì‚°ì„±(TFP) ì¦ê°€ìœ¨
+INFRASTRUCTURE_TFP_BOOST = 0.05  # ì¸í”„ë¼ íˆ¬ì ì‹œ ì „ì²´ ìƒì‚°ì„±(TFP) ì¦ê°€ìœ¨
 
 # --- ë°°ë‹¹ ê´€ë ¨ (ê¸°ì¡´ DIVIDEND_RATE ì°¸ì¡°) ---
 # DIVIDEND_RATEëŠ” ì´ë¯¸ ìœ„ì—ì„œ ì •ì˜ë¨
 
 # --- ì°½ì—… ê´€ë ¨ ---
-STARTUP_MIN_CAPITAL = 5000.0        # ì°½ì—… ìµœì†Œ ìë³¸ê¸ˆ
-STARTUP_INITIAL_SHARES = 100.0      # ì°½ì—… ì‹œ ë°œí–‰ ì£¼ì‹ ìˆ˜
-STARTUP_PROBABILITY = 0.01          # í‹±ë‹¹ ì°½ì—… ì‹œë„ í™•ë¥  (ìê²© ì¶©ì¡± ì‹œ)
+STARTUP_MIN_CAPITAL = 5000.0  # ì°½ì—… ìµœì†Œ ìë³¸ê¸ˆ
+STARTUP_INITIAL_SHARES = 100.0  # ì°½ì—… ì‹œ ë°œí–‰ ì£¼ì‹ ìˆ˜
+STARTUP_PROBABILITY = 0.01  # í‹±ë‹¹ ì°½ì—… ì‹œë„ í™•ë¥  (ìê²© ì¶©ì¡± ì‹œ)
 
 # --- Mitosis Configuration ---
 TARGET_POPULATION = 50
 MITOSIS_BASE_THRESHOLD = 2500.0  # ê¸°ë³¸ ë¶„ì—´ ìì‚° ìš”ê±´ (5000.0 -> 2500.0 for Take 2)
-MITOSIS_SENSITIVITY = 1.5       # ì¸êµ¬ ì••ë°• ë¯¼ê°ë„
+MITOSIS_SENSITIVITY = 1.5  # ì¸êµ¬ ì••ë°• ë¯¼ê°ë„
 MITOSIS_SURVIVAL_THRESHOLD = 20.0  # ë°°ê³ í”” í•œê³„
 MITOSIS_MUTATION_PROBABILITY = 0.2  # ì„±ê²© ëŒì—°ë³€ì´ í™•ë¥ 
 MITOSIS_Q_TABLE_MUTATION_RATE = 0.05  # Q-table ë…¸ì´ì¦ˆ ë¹„ìœ¨
@@ -576,63 +584,62 @@ MITOSIS_Q_TABLE_MUTATION_RATE = 0.05  # Q-table ë…¸ì´ì¦ˆ ë¹„ìœ¨
 
 # --- Phase 7: Adaptive Fiscal Policy ---
 DEFICIT_SPENDING_ENABLED = True
-DEFICIT_SPENDING_LIMIT_RATIO = 0.30     # Max Debt / GDP Ratio
-EMERGENCY_BUDGET_MULTIPLIER_CAP = 2.0   # 2.0x spending in crisis
-NORMAL_BUDGET_MULTIPLIER_CAP = 1.0      # 1.0x spending in normal times
-GOV_ACTION_INTERVAL = 30                # Actuator silent interval
-FISCAL_SENSITIVITY_ALPHA = 0.5          # Output gap -> fiscal stance conversion
-POTENTIAL_GDP_WINDOW = 50               # Ticks for moving average
+DEFICIT_SPENDING_LIMIT_RATIO = 0.30  # Max Debt / GDP Ratio
+EMERGENCY_BUDGET_MULTIPLIER_CAP = 2.0  # 2.0x spending in crisis
+NORMAL_BUDGET_MULTIPLIER_CAP = 1.0  # 1.0x spending in normal times
+GOV_ACTION_INTERVAL = 30  # Actuator silent interval
+FISCAL_SENSITIVITY_ALPHA = 0.5  # Output gap -> fiscal stance conversion
+POTENTIAL_GDP_WINDOW = 50  # Ticks for moving average
 TAX_RATE_MIN = 0.05
 TAX_RATE_MAX = 0.50
-TAX_RATE_BASE = 0.10                    # Neutral rate (boom/bust neutral)
+TAX_RATE_BASE = 0.10  # Neutral rate (boom/bust neutral)
 BUDGET_ALLOCATION_MIN = 0.1
 BUDGET_ALLOCATION_MAX = 1.0
-DEBT_CEILING_RATIO = 2.0                # Max debt/GDP (Increased to 2.0 for stability)
-FISCAL_STANCE_EXPANSION_THRESHOLD = 0.025   # +2.5% stance -> expand
-FISCAL_STANCE_CONTRACTION_THRESHOLD = -0.025 # -2.5% stance -> contract
+DEBT_CEILING_RATIO = 2.0  # Max debt/GDP (Increased to 2.0 for stability)
+FISCAL_STANCE_EXPANSION_THRESHOLD = 0.025  # +2.5% stance -> expand
+FISCAL_STANCE_CONTRACTION_THRESHOLD = -0.025  # -2.5% stance -> contract
 
 # 1. Progressive Tax (Income Tax)
 # Criteria: Multiples of SURVIVAL_COST
 # [HOTFIX: Fiscal Balance] Tax rates reduced by 50%
 TAX_BRACKETS = [
-    (0.5, 0.0),   # Tax Free
+    (0.5, 0.0),  # Tax Free
     (1.0, 0.05),  # Working Class: 5% (was 10%)
     (3.0, 0.10),  # Middle Class: 10% (was 20%)
-    (float('inf'), 0.20) # Wealthy: 20% (was 40%)
+    (float("inf"), 0.20),  # Wealthy: 20% (was 40%)
 ]
 
 # 2. Wealth Tax
 # WEALTH_TAX_THRESHOLD is defined below
 WEALTH_TAX_THRESHOLD = 50000.0
-ANNUAL_WEALTH_TAX_RATE = 0.02   # Annual 2% wealth tax
+ANNUAL_WEALTH_TAX_RATE = 0.02  # Annual 2% wealth tax
 
 # 3. Welfare
 # [WO-020] Operation Darwin: No Free Lunch.
-UNEMPLOYMENT_BENEFIT_RATIO = 0.0 # No unemployment benefit
-STIMULUS_TRIGGER_GDP_DROP = -0.05 # GDP 5% drop trigger
+UNEMPLOYMENT_BENEFIT_RATIO = 0.0  # No unemployment benefit
+STIMULUS_TRIGGER_GDP_DROP = -0.05  # GDP 5% drop trigger
 
 # 4. Bankruptcy Penalty
-CREDIT_RECOVERY_TICKS = 100 # 1 year (100 ticks) credit jail
-BANKRUPTCY_XP_PENALTY = 0.2 # 20% XP penalty
+CREDIT_RECOVERY_TICKS = 100  # 1 year (100 ticks) credit jail
+BANKRUPTCY_XP_PENALTY = 0.2  # 20% XP penalty
+
+FISCAL_MODEL = "MIXED"  # Default regime
 
-FISCAL_MODEL = "MIXED" # Default regime
-    
 # ==============================================================================
 # Phase 6: The Brand Economy
 # ==============================================================================
 # 1. Brand Engine
-MARKETING_DECAY_RATE = 0.8        # Adstock retains 80% per tick
-MARKETING_EFFICIENCY = 0.01       # 1 unit of currency = 0.01 adstock unit
-PERCEIVED_QUALITY_ALPHA = 0.2     # EMA smoothing factor for quality perception
+MARKETING_DECAY_RATE = 0.8  # Adstock retains 80% per tick
+MARKETING_EFFICIENCY = 0.01  # 1 unit of currency = 0.01 adstock unit
+PERCEIVED_QUALITY_ALPHA = 0.2  # EMA smoothing factor for quality perception
 
 # 2. Consumer Behavior
-QUALITY_SENSITIVITY_MEAN = 0.5    # Average preference for quality over price
-BRAND_LOYALTY_DECAY = 0.95        # Loyalty score decays 5% per tick without reinforcement
-NETWORK_EFFECT_WEIGHT = 0.5       # Weight of sales volume in Utility function
-BRAND_SENSITIVITY_BETA = 0.5      # Consumer sensitivity to Brand Awareness
-QUALITY_PREF_SNOB_MIN = 0.7       # Threshold for Snob behavior
-QUALITY_PREF_MISER_MAX = 0.3      # Threshold for Miser behavior
-
+QUALITY_SENSITIVITY_MEAN = 0.5  # Average preference for quality over price
+BRAND_LOYALTY_DECAY = 0.95  # Loyalty score decays 5% per tick without reinforcement
+NETWORK_EFFECT_WEIGHT = 0.5  # Weight of sales volume in Utility function
+BRAND_SENSITIVITY_BETA = 0.5  # Consumer sensitivity to Brand Awareness
+QUALITY_PREF_SNOB_MIN = 0.7  # Threshold for Snob behavior
+QUALITY_PREF_MISER_MAX = 0.3  # Threshold for Miser behavior
 
 
 # 3. AI Reward
@@ -641,46 +648,46 @@ QUALITY_PREF_MISER_MAX = 0.3      # Threshold for Miser behavior
 # ==============================================================================
 # Task #9: Entrepreneurship Constants
 # ==============================================================================
-MIN_FIRMS_THRESHOLD = 5          # ìµœì†Œ ê¸°ì—… ìˆ˜ (ì´í•˜ë¡œ ë–¨ì–´ì§€ë©´ ì°½ì—… ìœ ë„)
-STARTUP_COST = 30000.0           # ì°½ì—… ë¹„ìš© (30,000ìœ¼ë¡œ ìƒí–¥)
-FIRM_MAINTENANCE_FEE = 50.0       # WO-021: 1/4 of legacy 200.0
-CORPORATE_TAX_RATE = 0.0         # Laissez-Faire: Zero Tax
-ENTREPRENEURSHIP_SPIRIT = 0.05   # ìê²© ìˆëŠ” ê°€ê³„ì˜ ì°½ì—… í™•ë¥  (5%)
-STARTUP_CAPITAL_MULTIPLIER = 1.2 # ì°½ì—… ìê²©: cash > STARTUP_COST * ì´ ê°’ (ìê²©: 3600)
+MIN_FIRMS_THRESHOLD = 5  # ìµœì†Œ ê¸°ì—… ìˆ˜ (ì´í•˜ë¡œ ë–¨ì–´ì§€ë©´ ì°½ì—… ìœ ë„)
+STARTUP_COST = 30000.0  # ì°½ì—… ë¹„ìš© (30,000ìœ¼ë¡œ ìƒí–¥)
+FIRM_MAINTENANCE_FEE = 50.0  # WO-021: 1/4 of legacy 200.0
+CORPORATE_TAX_RATE = 0.0  # Laissez-Faire: Zero Tax
+ENTREPRENEURSHIP_SPIRIT = 0.05  # ìê²© ìˆëŠ” ê°€ê³„ì˜ ì°½ì—… í™•ë¥  (5%)
+STARTUP_CAPITAL_MULTIPLIER = 1.2  # ì°½ì—… ìê²©: cash > STARTUP_COST * ì´ ê°’ (ìê²©: 3600)
 
 # ==============================================================================
 # Phase 8: Inflation Psychology (Adaptive Expectations)
 # ==============================================================================
-INFLATION_MEMORY_WINDOW = 10     # Ticks to remember price history
-PRICE_MEMORY_LENGTH = 10         # Length of price history deque (WO-095)
-WAGE_MEMORY_LENGTH = 30          # Length of wage history deque (WO-095)
+INFLATION_MEMORY_WINDOW = 10  # Ticks to remember price history
+PRICE_MEMORY_LENGTH = 10  # Length of price history deque (WO-095)
+WAGE_MEMORY_LENGTH = 30  # Length of wage history deque (WO-095)
 ADAPTATION_RATE_IMPULSIVE = 0.8  # Lambda for impulsive agents
-ADAPTATION_RATE_NORMAL = 0.3     # Lambda for normal agents
-ADAPTATION_RATE_CONSERVATIVE = 0.1 # Lambda for conservative agents
+ADAPTATION_RATE_NORMAL = 0.3  # Lambda for normal agents
+ADAPTATION_RATE_CONSERVATIVE = 0.1  # Lambda for conservative agents
 
 # ==============================================================================
 # Phase 9: M&A & Bankruptcy Parameters
 # ==============================================================================
 MA_ENABLED = True
-VALUATION_PER_MULTIPLIER = 10.0      # PER 10
-MIN_ACQUISITION_CASH_RATIO = 1.5     # Hunter Cash >= Target Valuation * 1.5
-LIQUIDATION_DISCOUNT_RATE = 0.5      # Asset fire sale discount
-BANKRUPTCY_CONSECUTIVE_LOSS_TICKS = 20 # Warning threshold
+VALUATION_PER_MULTIPLIER = 10.0  # PER 10
+MIN_ACQUISITION_CASH_RATIO = 1.5  # Hunter Cash >= Target Valuation * 1.5
+LIQUIDATION_DISCOUNT_RATE = 0.5  # Asset fire sale discount
+BANKRUPTCY_CONSECUTIVE_LOSS_TICKS = 20  # Warning threshold
 
 
-PANIC_BUYING_THRESHOLD = 0.05    # Expected Inflation > 5% -> Hoard
-HOARDING_FACTOR = 0.5            # Buy 50% more than needed
+PANIC_BUYING_THRESHOLD = 0.05  # Expected Inflation > 5% -> Hoard
+HOARDING_FACTOR = 0.5  # Buy 50% more than needed
 
-DEFLATION_WAIT_THRESHOLD = -0.05 # Expected Inflation < -5% -> Delay
-DELAY_FACTOR = 0.5               # Buy 50% less than needed
+DEFLATION_WAIT_THRESHOLD = -0.05  # Expected Inflation < -5% -> Delay
+DELAY_FACTOR = 0.5  # Buy 50% less than needed
 
 # ==============================================================================
 # Phase 10: Central Bank & Monetary Policy
 # ==============================================================================
-CB_UPDATE_INTERVAL = 10         # Central Bank policy update interval (ticks)
-CB_INFLATION_TARGET = 0.02      # Target inflation rate (2%)
-CB_TAYLOR_ALPHA = 1.5           # Taylor Rule weight on inflation
-CB_TAYLOR_BETA = 0.5            # Taylor Rule weight on output gap
+CB_UPDATE_INTERVAL = 10  # Central Bank policy update interval (ticks)
+CB_INFLATION_TARGET = 0.02  # Target inflation rate (2%)
+CB_TAYLOR_ALPHA = 1.5  # Taylor Rule weight on inflation
+CB_TAYLOR_BETA = 0.5  # Taylor Rule weight on output gap
 
 # --- Phase 4.5: Interest Sensitivity ---
 NEUTRAL_REAL_RATE = 0.02
@@ -712,13 +719,18 @@ HOMELESS_PENALTY_PER_TICK = 50.0
 REPRODUCTION_AGE_START = 20
 REPRODUCTION_AGE_END = 45
 CHILDCARE_TIME_REQUIRED = 8.0  # ìë…€ 1ëª…ë‹¹ í•˜ë£¨ í•„ìš” ì‹œê°„
-HOUSEWORK_BASE_HOURS = 6.0     # ê°€êµ¬ ê¸°ë³¸ ê°€ì‚¬ ì‹œê°„ (WO-035: 4~6 hours)
-EDUCATION_COST_MULTIPLIERS = { # êµìœ¡ ìˆ˜ì¤€ë³„ ê¸°ëŒ€ ì„ê¸ˆ ë°°ìˆ˜
-    0: 1.0, 1: 1.5, 2: 2.2, 3: 3.5, 4: 5.0, 5: 8.0
+HOUSEWORK_BASE_HOURS = 6.0  # ê°€êµ¬ ê¸°ë³¸ ê°€ì‚¬ ì‹œê°„ (WO-035: 4~6 hours)
+EDUCATION_COST_MULTIPLIERS = {  # êµìœ¡ ìˆ˜ì¤€ë³„ ê¸°ëŒ€ ì„ê¸ˆ ë°°ìˆ˜
+    0: 1.0,
+    1: 1.5,
+    2: 2.2,
+    3: 3.5,
+    4: 5.0,
+    5: 8.0,
 }
 SOCIAL_CAPILLARITY_COST = 0.5  # ê³„ì¸µ ì´ë™ ë¹„ìš© (K-Factor)
-UNNAMED_CHILD_MORTALITY_RATE = 0.001 # ê¸°ë³¸ ì‚¬ë§ë¥ 
-EDUCATION_LEVEL_DISTRIBUTION = [0.4, 0.3, 0.15, 0.1, 0.04, 0.01] # 0~5ë‹¨ê³„ ë¶„í¬
+UNNAMED_CHILD_MORTALITY_RATE = 0.001  # ê¸°ë³¸ ì‚¬ë§ë¥ 
+EDUCATION_LEVEL_DISTRIBUTION = [0.4, 0.3, 0.15, 0.1, 0.04, 0.01]  # 0~5ë‹¨ê³„ ë¶„í¬
 
 # --- Phase 20: Socio-Tech & System 2 ---
 # ==============================================================================
@@ -726,46 +738,48 @@ SYSTEM2_TICKS_PER_CALC = 10
 SYSTEM2_HORIZON = 100
 SYSTEM2_DISCOUNT_RATE = 0.98
 
-FORMULA_TECH_LEVEL = 0.0   # 0.0: No Formula, 1.0: Full Formula
+FORMULA_TECH_LEVEL = 0.0  # 0.0: No Formula, 1.0: Full Formula
 LACTATION_INTENSITY = 1.0  # Lock Factor (1.0 = Strong Lock)
-HOMEWORK_QUALITY_COEFF = 0.5 # Impact of appliances
+HOMEWORK_QUALITY_COEFF = 0.5  # Impact of appliances
 
 # --- Phase 21.5: Automation Tax ---
 # --- WO-048: Adaptive Breeding Parameters ---
-TECH_CONTRACEPTION_ENABLED = True   # True: System 2 (NPV), False: System 1 (Random)
-BIOLOGICAL_FERTILITY_RATE = 0.15    # í”¼ì„ ì—†ì„ ë•Œì˜ ì›”ê°„ ì„ì‹  í™•ë¥ 
+TECH_CONTRACEPTION_ENABLED = True  # True: System 2 (NPV), False: System 1 (Random)
+BIOLOGICAL_FERTILITY_RATE = 0.15  # í”¼ì„ ì—†ì„ ë•Œì˜ ì›”ê°„ ì„ì‹  í™•ë¥ 
 
 # Cost Factors
-CHILD_MONTHLY_COST = 500.0          # ì§ì ‘ ì–‘ìœ¡ë¹„ (ì‹ë¹„+êµìœ¡ë¹„)
-OPPORTUNITY_COST_FACTOR = 0.2       # ìœ¡ì•„ë¡œ ì¸í•œ ì„ê¸ˆ ê°ì†Œìœ¨ (0.3 -> 0.2 for Take 2)
-RAISING_YEARS = 20                  # ì–‘ìœ¡ ê¸°ê°„ (ì„±ì¸ê¹Œì§€)
+CHILD_MONTHLY_COST = 500.0  # ì§ì ‘ ì–‘ìœ¡ë¹„ (ì‹ë¹„+êµìœ¡ë¹„)
+OPPORTUNITY_COST_FACTOR = 0.2  # ìœ¡ì•„ë¡œ ì¸í•œ ì„ê¸ˆ ê°ì†Œìœ¨ (0.3 -> 0.2 for Take 2)
+RAISING_YEARS = 20  # ì–‘ìœ¡ ê¸°ê°„ (ì„±ì¸ê¹Œì§€)
 
 # Benefit Factors
-CHILD_EMOTIONAL_VALUE_BASE = 500000.0 # ìë…€ 1ëª…ë‹¹ ëŠë¼ëŠ” ì •ì„œì  ê°€ì¹˜ì˜ ì´ëŸ‰ (500kë¡œ ìƒí–¥ - Middle Income Trap ì™„í™”)
-OLD_AGE_SUPPORT_RATE = 0.1          # ìë…€ ì†Œë“ì˜ 10%ë¥¼ ë…¸í›„ ìš©ëˆìœ¼ë¡œ ë°›ìŒ
-SUPPORT_YEARS = 20                  # ì€í‡´ í›„ ë¶€ì–‘ë°›ëŠ” ê¸°ê°„
+CHILD_EMOTIONAL_VALUE_BASE = 500000.0  # ìë…€ 1ëª…ë‹¹ ëŠë¼ëŠ” ì •ì„œì  ê°€ì¹˜ì˜ ì´ëŸ‰ (500kë¡œ ìƒí–¥ - Middle Income Trap ì™„í™”)
+OLD_AGE_SUPPORT_RATE = 0.1  # ìë…€ ì†Œë“ì˜ 10%ë¥¼ ë…¸í›„ ìš©ëˆìœ¼ë¡œ ë°›ìŒ
+SUPPORT_YEARS = 20  # ì€í‡´ í›„ ë¶€ì–‘ë°›ëŠ” ê¸°ê°„
 
 # --- Phase 23: Public Education System (WO-054) ---
 PUBLIC_EDU_BUDGET_RATIO = 0.20  # ì •ë¶€ ì˜ˆì‚°ì˜ 20%ë¥¼ êµìœ¡ì— íˆ¬ì
 EDUCATION_COST_PER_LEVEL = {
-    1: 500,    # ê¸°ì´ˆ êµìœ¡
-    2: 2000,   # ì¤‘ë“± êµìœ¡
-    3: 5000,   # ê³ ë“± êµìœ¡
+    1: 500,  # ê¸°ì´ˆ êµìœ¡
+    2: 2000,  # ì¤‘ë“± êµìœ¡
+    3: 5000,  # ê³ ë“± êµìœ¡
     4: 15000,  # ëŒ€í•™
-    5: 50000   # ëŒ€í•™ì›/ì „ë¬¸ì§
+    5: 50000,  # ëŒ€í•™ì›/ì „ë¬¸ì§
 }
 SCHOLARSHIP_WEALTH_PERCENTILE = 0.20  # í•˜ìœ„ 20%
 SCHOLARSHIP_POTENTIAL_THRESHOLD = 0.7  # ì ì¬ë ¥ ìƒìœ„ 30%
 
 # --- WO-098-DIAG-C: Tech Adoption Barriers (Hotfix) ---
 TECH_FERTILIZER_UNLOCK_TICK = 30  # Unlock earlier (Default 50 -> 30)
-TECH_DIFFUSION_RATE = 0.10        # 2x faster adoption (Default 0.05 -> 0.10)
+TECH_DIFFUSION_RATE = 0.10  # 2x faster adoption (Default 0.05 -> 0.10)
 
 # --- Phase 24: Adaptive Evolution (WO-057) ---
-GOVERNMENT_POLICY_MODE = "AI_ADAPTIVE"  # "TAYLOR_RULE" (WO-056) or "AI_ADAPTIVE" (WO-057)
-TARGET_INFLATION_RATE = 0.02      # 2%
-TARGET_UNEMPLOYMENT_RATE = 0.04   # 4%
-GOV_ACTION_INTERVAL = 30          # ì˜ì‚¬ê²°ì • ì£¼ê¸° (30í‹± = 1ê°œì›”)
+GOVERNMENT_POLICY_MODE = (
+    "AI_ADAPTIVE"  # "TAYLOR_RULE" (WO-056) or "AI_ADAPTIVE" (WO-057)
+)
+TARGET_INFLATION_RATE = 0.02  # 2%
+TARGET_UNEMPLOYMENT_RATE = 0.04  # 4%
+GOV_ACTION_INTERVAL = 30  # ì˜ì‚¬ê²°ì • ì£¼ê¸° (30í‹± = 1ê°œì›”)
 RL_LEARNING_RATE = 0.1
 RL_DISCOUNT_FACTOR = 0.95
 
diff --git a/dashboard/app.py b/dashboard/app.py
index 7d3f3df..9324a0a 100644
--- a/dashboard/app.py
+++ b/dashboard/app.py
@@ -34,29 +34,32 @@ else:
 
     # Chart 1: GDP
     st.subheader("GDP (Real vs. Nominal)")
-    if 'gdp_real' in economic_indicators_df.columns and 'gdp_nominal' in economic_indicators_df.columns:
-        st.line_chart(economic_indicators_df[['gdp_real', 'gdp_nominal']])
+    if (
+        "gdp_real" in economic_indicators_df.columns
+        and "gdp_nominal" in economic_indicators_df.columns
+    ):
+        st.line_chart(economic_indicators_df[["gdp_real", "gdp_nominal"]])
     else:
         st.warning("GDP data not available.")
 
     # Chart 2: Inflation (CPI)
     st.subheader("Inflation (CPI)")
-    if 'cpi' in economic_indicators_df.columns:
-        st.line_chart(economic_indicators_df['cpi'])
+    if "cpi" in economic_indicators_df.columns:
+        st.line_chart(economic_indicators_df["cpi"])
     else:
         st.warning("CPI data not available.")
 
     # Chart 3: Population
     st.subheader("Population")
-    if 'population' in economic_indicators_df.columns:
-        st.line_chart(economic_indicators_df['population'])
+    if "population" in economic_indicators_df.columns:
+        st.line_chart(economic_indicators_df["population"])
     else:
         st.warning("Population data not available.")
 
     # Chart 4: Gini Coefficient
     st.subheader("Gini Coefficient")
-    if 'gini_coefficient' in economic_indicators_df.columns:
-        st.line_chart(economic_indicators_df['gini_coefficient'])
+    if "gini_coefficient" in economic_indicators_df.columns:
+        st.line_chart(economic_indicators_df["gini_coefficient"])
     else:
         st.warning("Gini Coefficient data not available.")
 
diff --git a/design/gemini_output/jules_engine_final.py b/design/gemini_output/jules_engine_final.py
index 138163a..199a503 100644
--- a/design/gemini_output/jules_engine_final.py
+++ b/design/gemini_output/jules_engine_final.py
@@ -18,23 +18,30 @@ from simulation.loan_market import LoanMarket
 from simulation.markets.stock_market import StockMarket
 from simulation.metrics.economic_tracker import EconomicIndicatorTracker
 from simulation.metrics.inequality_tracker import InequalityTracker
-from simulation.metrics.stock_tracker import StockMarketTracker, PersonalityStatisticsTracker
+from simulation.metrics.stock_tracker import (
+    StockMarketTracker,
+    PersonalityStatisticsTracker,
+)
 from simulation.ai_model import AIEngineRegistry
 from simulation.ai.ai_training_manager import AITrainingManager
 from simulation.systems.ma_manager import MAManager
 from simulation.systems.reflux_system import EconomicRefluxSystem
-from simulation.systems.demographic_manager import DemographicManager # Phase 19
-from simulation.systems.immigration_manager import ImmigrationManager # Phase 20-3
-from simulation.systems.inheritance_manager import InheritanceManager # Phase 22 (WO-049)
-from simulation.systems.housing_system import HousingSystem # Phase 22.5
-from simulation.systems.persistence_manager import PersistenceManager # Phase 22.5
-from simulation.systems.firm_management import FirmSystem # Phase 22.5
-from simulation.systems.technology_manager import TechnologyManager # Phase 23 (WO-053)
-from simulation.systems.bootstrapper import Bootstrapper # WO-058
+from simulation.systems.demographic_manager import DemographicManager  # Phase 19
+from simulation.systems.immigration_manager import ImmigrationManager  # Phase 20-3
+from simulation.systems.inheritance_manager import (
+    InheritanceManager,
+)  # Phase 22 (WO-049)
+from simulation.systems.housing_system import HousingSystem  # Phase 22.5
+from simulation.systems.persistence_manager import PersistenceManager  # Phase 22.5
+from simulation.systems.firm_management import FirmSystem  # Phase 22.5
+from simulation.systems.technology_manager import TechnologyManager  # Phase 23 (WO-053)
+from simulation.systems.bootstrapper import Bootstrapper  # WO-058
 from simulation.systems.generational_wealth_audit import GenerationalWealthAudit
-from simulation.decisions.housing_manager import HousingManager # For rank/tier helper
+from simulation.decisions.housing_manager import HousingManager  # For rank/tier helper
 from simulation.ai.vectorized_planner import VectorizedHouseholdPlanner
-from simulation.systems.transaction_processor import TransactionProcessor # SoC Refactor
+from simulation.systems.transaction_processor import (
+    TransactionProcessor,
+)  # SoC Refactor
 from modules.finance.system import FinanceSystem
 
 # Use the repository pattern for data access
@@ -82,21 +89,19 @@ class Simulation:
         self.config_module = config_module
         self.time: int = 0
 
-        self.batch_save_interval = 50 # WO-051: Hardcoded I/O Optimization
+        self.batch_save_interval = 50  # WO-051: Hardcoded I/O Optimization
 
         self.bank = Bank(
             id=self.next_agent_id,
             initial_assets=self.config_module.INITIAL_BANK_ASSETS,
-            config_module=self.config_module
+            config_module=self.config_module,
         )
         self.agents[self.bank.id] = self.bank
         self.next_agent_id += 1
 
         # ì •ë¶€ ì—ì´ì „íŠ¸ ì´ˆê¸°í™”
         self.government = Government(
-            id=self.next_agent_id, 
-            initial_assets=0.0, 
-            config_module=self.config_module
+            id=self.next_agent_id, initial_assets=0.0, config_module=self.config_module
         )
         self.agents[self.government.id] = self.government
         self.next_agent_id += 1
@@ -108,8 +113,7 @@ class Simulation:
 
         # Central Bank Initialization (Phase 10)
         self.central_bank = CentralBank(
-            tracker=self.tracker,
-            config_module=self.config_module
+            tracker=self.tracker, config_module=self.config_module
         )
         # Central Bank is not in self.agents dict as it's a special system agent
         # similar to how markets are handled, or we can add it if needed.
@@ -120,20 +124,25 @@ class Simulation:
             government=self.government,
             central_bank=self.central_bank,
             bank=self.bank,
-            config_module=self.config_module
+            config_module=self.config_module,
         )
-        self.government.finance_system = self.finance_system # Inject into government
+        self.government.finance_system = self.finance_system  # Inject into government
 
         # Phase 17-3A: Initialize Real Estate Units
         self.real_estate_units: List[RealEstateUnit] = [
-            RealEstateUnit(id=i, estimated_value=self.config_module.INITIAL_PROPERTY_VALUE,
-                           rent_price=self.config_module.INITIAL_RENT_PRICE)
+            RealEstateUnit(
+                id=i,
+                estimated_value=self.config_module.INITIAL_PROPERTY_VALUE,
+                rent_price=self.config_module.INITIAL_RENT_PRICE,
+            )
             for i in range(self.config_module.NUM_HOUSING_UNITS)
         ]
 
         # Distribute to top 20% households
         top_20_count = len(self.households) // 5
-        top_households = sorted(self.households, key=lambda h: h.assets, reverse=True)[:top_20_count]
+        top_households = sorted(self.households, key=lambda h: h.assets, reverse=True)[
+            :top_20_count
+        ]
 
         for i, hh in enumerate(top_households):
             if i < len(self.real_estate_units):
@@ -155,12 +164,14 @@ class Simulation:
         )
         # Pass agents reference to LoanMarket for credit check
         self.markets["loan_market"].agents_ref = self.agents
-        
+
         if getattr(self.config_module, "STOCK_MARKET_ENABLED", False):
-            self.stock_market = StockMarket(config_module=self.config_module, logger=self.logger)
+            self.stock_market = StockMarket(
+                config_module=self.config_module, logger=self.logger
+            )
             self.stock_tracker = StockMarketTracker(config_module=self.config_module)
             self.markets["stock_market"] = self.stock_market
-            
+
             # Phase 25/WO-060: Automatic IPO for existing firms
             for firm in self.firms:
                 if hasattr(firm, "init_ipo"):
@@ -171,18 +182,18 @@ class Simulation:
 
         # Phase 17-3B: Housing Market & Initial Sales
         self.markets["housing"] = OrderBookMarket(market_id="housing")
-        
+
         # Government places SELL orders for unowned properties (80 units)
         for unit in self.real_estate_units:
             if unit.owner_id is None:
                 # Sell Order: item_id="unit_{id}", price=estimated_value, qty=1
                 sell_order = Order(
-                    agent_id=self.government.id, # Government ID
+                    agent_id=self.government.id,  # Government ID
                     item_id=f"unit_{unit.id}",
                     price=unit.estimated_value,
                     quantity=1.0,
                     market_id="housing",
-                    order_type="SELL"
+                    order_type="SELL",
                 )
                 if "housing" in self.markets:
                     self.markets["housing"].place_order(sell_order, self.time)
@@ -190,7 +201,7 @@ class Simulation:
         # 2. ì—ì´ì „íŠ¸ ìš•êµ¬ ì—…ë°ì´íŠ¸ (Update Needs)
         for agent in self.households + self.firms:
             agent.update_needs(self.time)
-            
+
         # 3. ì—ì´ì „íŠ¸ ì˜ì‚¬ê²°ì • ë° í–‰ë™ (Decisions & Actions)
         for agent in self.households + self.firms:
             agent.decision_engine.markets = self.markets
@@ -200,15 +211,17 @@ class Simulation:
 
         self.repository = repository
         # self.tracker = EconomicIndicatorTracker(config_module=config_module) # Moved up
-        
+
         # ì¶”ê°€ ì§€í‘œ Tracker ì´ˆê¸°í™”
         self.inequality_tracker = InequalityTracker(config_module=config_module)
-        self.personality_tracker = PersonalityStatisticsTracker(config_module=config_module)
-        
+        self.personality_tracker = PersonalityStatisticsTracker(
+            config_module=config_module
+        )
+
         self.ai_training_manager = AITrainingManager(
             self.households, self.config_module
         )
-        
+
         # M&A Manager System
         self.ma_manager = MAManager(self, self.config_module)
 
@@ -229,16 +242,18 @@ class Simulation:
 
         # Phase 22.5: Persistence Manager (Refactored)
         self.persistence_manager = PersistenceManager(
-            run_id=0, # Placeholder, will be set after run_id is generated below
+            run_id=0,  # Placeholder, will be set after run_id is generated below
             config_module=self.config_module,
-            repository=self.repository
+            repository=self.repository,
         )
 
         # Phase 22.5: Firm System (Refactored)
         self.firm_system = FirmSystem(config_module=self.config_module)
 
         # Phase 23: Technology Manager
-        self.technology_manager = TechnologyManager(config_module=self.config_module, logger=self.logger)
+        self.technology_manager = TechnologyManager(
+            config_module=self.config_module, logger=self.logger
+        )
 
         # [WO-058] Bootstrapper Injection (Economic CPR)
         # Ensure firms have resources to start production
@@ -246,7 +261,9 @@ class Simulation:
         Bootstrapper.force_assign_workers(self.firms, self.households)
 
         # WO-058: Generational Wealth Audit
-        self.generational_wealth_audit = GenerationalWealthAudit(config_module=self.config_module)
+        self.generational_wealth_audit = GenerationalWealthAudit(
+            config_module=self.config_module
+        )
 
         # WO-051: Vectorized Planner Initialization
         self.breeding_planner = VectorizedHouseholdPlanner(self.config_module)
@@ -288,8 +305,6 @@ class Simulation:
         self.repository.close()
         self.logger.info("Simulation finalized and Repository connection closed.")
 
-
-
     def _update_social_ranks(self):
         """Phase 17-4: Update Social Rank (Percentile)"""
         # 1. Calculate Scores
@@ -298,11 +313,12 @@ class Simulation:
         hm = HousingManager(None, self.config_module)
 
         for h in self.households:
-            if not h.is_active: continue
+            if not h.is_active:
+                continue
 
-            consumption_score = h.current_consumption * 10.0 # Weight consumption
+            consumption_score = h.current_consumption * 10.0  # Weight consumption
             housing_tier = hm.get_housing_tier(h)
-            housing_score = housing_tier * 1000.0 # Tier 1=1000, Tier 3=3000
+            housing_score = housing_tier * 1000.0  # Tier 1=1000, Tier 3=3000
 
             total_score = consumption_score + housing_score
             scores.append((h.id, total_score))
@@ -310,7 +326,8 @@ class Simulation:
         # 2. Sort and Assign Rank
         sorted_scores = sorted(scores, key=lambda x: x[1], reverse=True)
         n = len(sorted_scores)
-        if n == 0: return
+        if n == 0:
+            return
 
         for rank_idx, (hid, _) in enumerate(sorted_scores):
             # Rank 0 (Top) -> Percentile 1.0
@@ -327,7 +344,11 @@ class Simulation:
             return {"avg_consumption": 0.0, "avg_housing_tier": 0.0}
 
         top_20_count = max(1, int(len(active_households) * 0.20))
-        sorted_hh = sorted(active_households, key=lambda h: getattr(h, "social_rank", 0.0), reverse=True)
+        sorted_hh = sorted(
+            active_households,
+            key=lambda h: getattr(h, "social_rank", 0.0),
+            reverse=True,
+        )
         top_20 = sorted_hh[:top_20_count]
 
         # Temp helper
@@ -336,18 +357,17 @@ class Simulation:
         avg_cons = sum(h.current_consumption for h in top_20) / len(top_20)
         avg_tier = sum(hm.get_housing_tier(h) for h in top_20) / len(top_20)
 
-        return {
-            "avg_consumption": avg_cons,
-            "avg_housing_tier": avg_tier
-        }
+        return {"avg_consumption": avg_cons, "avg_housing_tier": avg_tier}
 
-    def run_tick(self, injectable_sensory_dto: Optional[GovernmentStateDTO] = None) -> None:
+    def run_tick(
+        self, injectable_sensory_dto: Optional[GovernmentStateDTO] = None
+    ) -> None:
         # --- Gold Standard / Money Supply Verification (WO-016) ---
         if self.time == 0:
             self.baseline_money_supply = self._calculate_total_money()
             self.logger.info(
                 f"MONEY_SUPPLY_BASELINE | Baseline Money Supply set to: {self.baseline_money_supply:.2f}",
-                extra={"tick": self.time, "money_supply": self.baseline_money_supply}
+                extra={"tick": self.time, "money_supply": self.baseline_money_supply},
             )
 
         self.time += 1
@@ -360,9 +380,9 @@ class Simulation:
         if self.time == 200:
             self.logger.warning("ğŸ”¥ CHAOS: Inflation Shock at Tick 200!")
             for market_name, market in self.markets.items():
-                if hasattr(market, 'current_price'):
+                if hasattr(market, "current_price"):
                     market.current_price *= 1.5
-                if hasattr(market, 'avg_price'):
+                if hasattr(market, "avg_price"):
                     market.avg_price *= 1.5
 
         if self.time == 600:
@@ -373,7 +393,9 @@ class Simulation:
                 # If further impact is needed, household.monthly_income could also be reduced by 50%.
 
         # WO-054: Government Public Education Logic (START OF TICK)
-        self.government.run_public_education(self.households, self.config_module, self.time, self.reflux_system)
+        self.government.run_public_education(
+            self.households, self.config_module, self.time, self.reflux_system
+        )
 
         if (
             self.time > 0
@@ -384,19 +406,24 @@ class Simulation:
         # Update Bank Tick (Interest Processing)
         # Phase 4: Pass current_tick to bank for credit jail logic
         # Phase 8-B: Pass reflux_system to capture bank profits
-        if hasattr(self.bank, "run_tick") and "reflux_system" in self.bank.run_tick.__code__.co_varnames:
-             self.bank.run_tick(self.agents, self.time, reflux_system=self.reflux_system)
-        elif hasattr(self.bank, "run_tick") and "current_tick" in self.bank.run_tick.__code__.co_varnames:
-             self.bank.run_tick(self.agents, self.time)
+        if (
+            hasattr(self.bank, "run_tick")
+            and "reflux_system" in self.bank.run_tick.__code__.co_varnames
+        ):
+            self.bank.run_tick(self.agents, self.time, reflux_system=self.reflux_system)
+        elif (
+            hasattr(self.bank, "run_tick")
+            and "current_tick" in self.bank.run_tick.__code__.co_varnames
+        ):
+            self.bank.run_tick(self.agents, self.time)
         else:
-             self.bank.run_tick(self.agents)
-
+            self.bank.run_tick(self.agents)
 
         # Legacy call removed: self.government.update_monetary_policy(...)
 
         # Phase 14-1: Firm Profit Distribution (Operation Reflux)
         for firm in self.firms:
-             firm.distribute_profit(self.agents, self.time)
+            firm.distribute_profit(self.agents, self.time)
 
         for firm in self.firms:
             firm.hires_last_tick = 0
@@ -407,7 +434,13 @@ class Simulation:
 
         # WO-057-Fix: Update tracker with the latest data before government decisions
         money_supply = self._calculate_total_money()
-        self.tracker.track(self.time, self.households, self.firms, self.markets, money_supply=money_supply)
+        self.tracker.track(
+            self.time,
+            self.households,
+            self.firms,
+            self.markets,
+            money_supply=money_supply,
+        )
 
         # [WO-060] Update stock market reference prices at the start of the tick
         if self.stock_market is not None:
@@ -419,7 +452,7 @@ class Simulation:
             self._update_social_ranks()
 
         market_data = self._prepare_market_data(self.tracker)
-        
+
         # Inject Reference Standard
         if getattr(self.config_module, "ENABLE_VANITY_SYSTEM", False):
             ref_std = self._calculate_reference_standard()
@@ -441,7 +474,9 @@ class Simulation:
         # Inflation (Price Change)
         current_price = latest_indicators.get("avg_goods_price", 10.0)
         last_price = self.last_avg_price_for_sma
-        inflation_rate = (current_price - last_price) / last_price if last_price > 0 else 0.0
+        inflation_rate = (
+            (current_price - last_price) / last_price if last_price > 0 else 0.0
+        )
         self.last_avg_price_for_sma = current_price
 
         # Unemployment
@@ -477,7 +512,7 @@ class Simulation:
             gdp_growth_sma=calculate_sma(self.gdp_growth_buffer),
             wage_sma=calculate_sma(self.wage_buffer),
             approval_sma=calculate_sma(self.approval_buffer),
-            current_gdp=current_gdp
+            current_gdp=current_gdp,
         )
 
         # Supply to Government
@@ -486,7 +521,7 @@ class Simulation:
             self.government.update_sensory_data(injectable_sensory_dto)
             self.logger.warning(
                 f"INJECTED_SENSORY_DATA | Overrode sensory data for tick {self.time} with custom DTO.",
-                extra={"tick": self.time, "tags": ["test_injection"]}
+                extra={"tick": self.time, "tags": ["test_injection"]},
             )
         else:
             self.government.update_sensory_data(sensory_dto)
@@ -497,19 +532,29 @@ class Simulation:
             interest_rate_trend = self.bank.base_rate - self.last_interest_rate
             self.last_interest_rate = self.bank.base_rate
 
-            market_volatility = self.stock_tracker.get_market_volatility() if self.stock_tracker else 0.0
+            market_volatility = (
+                self.stock_tracker.get_market_volatility()
+                if self.stock_tracker
+                else 0.0
+            )
 
             macro_financial_context = MacroFinancialContext(
                 inflation_rate=sensory_dto.inflation_sma,
                 gdp_growth_rate=sensory_dto.gdp_growth_sma,
                 market_volatility=market_volatility,
-                interest_rate_trend=interest_rate_trend
+                interest_rate_trend=interest_rate_trend,
             )
 
         # [DEBUG WO-057]
-        self.logger.info(f"DEBUG_WO057 | Tick {self.time} | Indicators: {list(latest_indicators.keys())}")
-        self.logger.info(f"DEBUG_WO057 | AvgPrice: {latest_indicators.get('avg_goods_price', 'MISSING')}")
-        self.logger.info(f"DEBUG_WO057 | SensoryDTO: InfSMA={sensory_dto.inflation_sma:.4f}, UnempSMA={sensory_dto.unemployment_sma:.4f}, DebtRat={sensory_dto.current_gdp:.4f}")
+        self.logger.info(
+            f"DEBUG_WO057 | Tick {self.time} | Indicators: {list(latest_indicators.keys())}"
+        )
+        self.logger.info(
+            f"DEBUG_WO057 | AvgPrice: {latest_indicators.get('avg_goods_price', 'MISSING')}"
+        )
+        self.logger.info(
+            f"DEBUG_WO057 | SensoryDTO: InfSMA={sensory_dto.inflation_sma:.4f}, UnempSMA={sensory_dto.unemployment_sma:.4f}, DebtRat={sensory_dto.current_gdp:.4f}"
+        )
         # -----------------------------------------
 
         # 3. Government Makes Policy Decision
@@ -536,13 +581,17 @@ class Simulation:
         self.finance_system.service_debt(self.time)
 
         # Phase 4: Welfare Check (Executes Subsidies based on Policy)
-        self.government.run_welfare_check(list(self.agents.values()), market_data, self.time)
+        self.government.run_welfare_check(
+            list(self.agents.values()), market_data, self.time
+        )
 
         # Snapshot agents for learning (Pre-state)
         for f in self.firms:
-            if f.is_active: f.pre_state_snapshot = f.get_agent_data()
+            if f.is_active:
+                f.pre_state_snapshot = f.get_agent_data()
         for h in self.households:
-            if h.is_active: h.pre_state_snapshot = h.get_agent_data()
+            if h.is_active:
+                h.pre_state_snapshot = h.get_agent_data()
 
         all_transactions: List[Transaction] = []
 
@@ -550,16 +599,21 @@ class Simulation:
         for firm in self.firms:
             if firm.is_active:
                 # Guard for AI-driven engines (RuleBased engines don't have ai_engine)
-                if hasattr(firm.decision_engine, 'ai_engine') and firm.decision_engine.ai_engine:
+                if (
+                    hasattr(firm.decision_engine, "ai_engine")
+                    and firm.decision_engine.ai_engine
+                ):
                     pre_strategic_state = (
                         firm.decision_engine.ai_engine._get_strategic_state(
                             firm.get_agent_data(), market_data
                         )
                     )
-                    pre_tactical_state = firm.decision_engine.ai_engine._get_tactical_state(
-                        firm.decision_engine.ai_engine.chosen_intention,
-                        firm.get_agent_data(),
-                        market_data,
+                    pre_tactical_state = (
+                        firm.decision_engine.ai_engine._get_tactical_state(
+                            firm.decision_engine.ai_engine.chosen_intention,
+                            firm.get_agent_data(),
+                            market_data,
+                        )
                     )
                     firm_pre_states[firm.id] = {
                         "pre_strategic_state": pre_strategic_state,
@@ -569,42 +623,59 @@ class Simulation:
                     }
 
                 # Phase 8-B: Pass reflux_system to firm.make_decision for CAPEX capture
-                firm_orders, action_vector = firm.make_decision(self.markets, self.goods_data, market_data, self.time, self.government, self.reflux_system)
+                firm_orders, action_vector = firm.make_decision(
+                    self.markets,
+                    self.goods_data,
+                    market_data,
+                    self.time,
+                    self.government,
+                    self.reflux_system,
+                )
                 for order in firm_orders:
                     target_market = self.markets.get(order.market_id)
                     if target_market:
                         target_market.place_order(order, self.time)
-                
-                self.logger.debug(f"TRACE_ENGINE | Firm {firm.id} submitted {len(firm_orders)} orders to markets.")
+
+                self.logger.debug(
+                    f"TRACE_ENGINE | Firm {firm.id} submitted {len(firm_orders)} orders to markets."
+                )
 
         household_pre_states = {}
         household_time_allocation = {}  # Store time allocation for later use
         for household in self.households:
             if household.is_active:
                 # Guard for AI-driven engines (RuleBased engines don't have ai_engine)
-                if hasattr(household.decision_engine, 'ai_engine') and household.decision_engine.ai_engine:
+                if (
+                    hasattr(household.decision_engine, "ai_engine")
+                    and household.decision_engine.ai_engine
+                ):
                     pre_strategic_state = (
                         household.decision_engine.ai_engine._get_strategic_state(
                             household.get_agent_data(), market_data
                         )
                     )
                     household_pre_states[household.id] = {
-                        "pre_strategic_state": pre_strategic_state, # Legacy support
+                        "pre_strategic_state": pre_strategic_state,  # Legacy support
                     }
 
                 # make_decision return (orders, vector)
                 household_orders, action_vector = household.make_decision(
-                    self.markets, self.goods_data, market_data, self.time, self.government, macro_financial_context
+                    self.markets,
+                    self.goods_data,
+                    market_data,
+                    self.time,
+                    self.government,
+                    macro_financial_context,
                 )
 
                 # Phase 5: Calculate Time Allocation (Hydraulic Model)
                 # work_hours = work_agg * MAX_WORK_HOURS
                 # leisure_hours = 24 - work_hours - SHOPPING_HOURS
                 # Guard: RuleBased engines return tuple, not ActionVector DTO
-                if hasattr(action_vector, 'work_aggressiveness'):
+                if hasattr(action_vector, "work_aggressiveness"):
                     work_aggressiveness = action_vector.work_aggressiveness
                 else:
-                    work_aggressiveness = 0.5 # Default for RuleBased
+                    work_aggressiveness = 0.5  # Default for RuleBased
                 max_work_hours = self.config_module.MAX_WORK_HOURS
                 shopping_hours = getattr(self.config_module, "SHOPPING_HOURS", 2.0)
                 hours_per_tick = getattr(self.config_module, "HOURS_PER_TICK", 24.0)
@@ -618,7 +689,9 @@ class Simulation:
                 for order in household_orders:
                     # [Phase 23.5 Fix] Handle INVEST orders for startup creation (Active Entrepreneurship)
                     if order.order_type == "INVEST" and order.market_id == "admin":
-                        self.logger.info(f"FOUND_INVEST_ORDER | Agent {household.id} attempting startup via admin market.")
+                        self.logger.info(
+                            f"FOUND_INVEST_ORDER | Agent {household.id} attempting startup via admin market."
+                        )
                         self.firm_system.spawn_firm(self, household)
                         continue
 
@@ -626,9 +699,14 @@ class Simulation:
                     target_market_id = order.market_id
 
                     # Routing Logic for Deposit/Withdraw/Loan
-                    if order.order_type in ["DEPOSIT", "WITHDRAW", "LOAN_REQUEST", "REPAYMENT"]:
+                    if order.order_type in [
+                        "DEPOSIT",
+                        "WITHDRAW",
+                        "LOAN_REQUEST",
+                        "REPAYMENT",
+                    ]:
                         target_market_id = "loan_market"
-                    elif order.item_id in ["deposit", "currency"]: # Fallback
+                    elif order.item_id in ["deposit", "currency"]:  # Fallback
                         target_market_id = "loan_market"
 
                     household_target_market = self.markets.get(target_market_id)
@@ -641,7 +719,9 @@ class Simulation:
                             extra={"tick": self.time},
                         )
 
-                self.logger.debug(f"TRACE_ENGINE | Household {household.id} submitted {len(household_orders)} orders back to engine.")
+                self.logger.debug(
+                    f"TRACE_ENGINE | Household {household.id} submitted {len(household_orders)} orders back to engine."
+                )
 
         for market in self.markets.values():
             if isinstance(market, OrderBookMarket):
@@ -664,15 +744,15 @@ class Simulation:
         # ---------------------------------------------------------
         # After transactions, households have goods in inventory.
         # Now they must consume them to satisfy needs.
-        household_leisure_effects = {} # Store utility for AI reward injection
+        household_leisure_effects = {}  # Store utility for AI reward injection
 
         # Recalculate vacancy count for correct death classification
         current_vacancies = 0
         labor_market = self.markets.get("labor")
         if labor_market and isinstance(labor_market, OrderBookMarket):
-             for item_orders in labor_market.buy_orders.values():
-                 for order in item_orders:
-                     current_vacancies += order.quantity
+            for item_orders in labor_market.buy_orders.values():
+                for order in item_orders:
+                    current_vacancies += order.quantity
 
         # Create a consumption-specific market data context
         consumption_market_data = market_data.copy()
@@ -680,71 +760,93 @@ class Simulation:
 
         # WO-051: Vectorized Consumption Logic
         # Pre-calculate consumption/purchase decisions for all households
-        batch_decisions = self.breeding_planner.decide_consumption_batch(self.households, consumption_market_data)
-        consume_list = batch_decisions.get('consume', [0] * len(self.households))
-        buy_list = batch_decisions.get('buy', [0] * len(self.households))
-        food_price = batch_decisions.get('price', 5.0)  # Default food price
+        batch_decisions = self.breeding_planner.decide_consumption_batch(
+            self.households, consumption_market_data
+        )
+        consume_list = batch_decisions.get("consume", [0] * len(self.households))
+        buy_list = batch_decisions.get("buy", [0] * len(self.households))
+        food_price = batch_decisions.get("price", 5.0)  # Default food price
 
         for i, household in enumerate(self.households):
-             if household.is_active:
-
-                 # 1. Consumption (Vectorized Optimization)
-                 # Replace decide_and_consume with vectorized result application
-                 consumed_items = {}
-
-                 # 1a. Fast Consumption (Basic Food)
-                 if i < len(consume_list):
-                     c_amt = consume_list[i]
-                     if c_amt > 0:
-                         household.consume("basic_food", c_amt, self.time)
-                         consumed_items["basic_food"] = c_amt
-
-                 # 1b. Fast Purchase (Survival Rescue - Logic Map Item 3)
-                 if i < len(buy_list):
-                     b_amt = buy_list[i]
-                     if b_amt > 0:
-                         cost = b_amt * food_price
-                         if household.assets >= cost:
-                             household.assets -= cost
-                             household.inventory["basic_food"] = household.inventory.get("basic_food", 0) + b_amt
-                             # To prevent money destruction, we route this to Reflux System (Sink)
-                             self.reflux_system.capture(cost, source=f"Household_{household.id}", category="emergency_food")
-                             self.logger.debug(
-                                 f"VECTOR_BUY | Household {household.id} bought {b_amt:.1f} food (Fast Track)",
-                                 extra={"agent_id": household.id, "tags": ["consumption", "vector_buy"]}
-                             )
-                             # Consume immediately if they were starving and bought it?
-                             # The planner separates buy/consume. If they bought, they might consume next tick
-                             # or we can force consume now if consumption was 0?
-                             # Vector planner logic for consumption relies on Inventory > 0.
-                             # If inventory was 0, c_amt is 0.
-                             # If we buy now, we should probably allow immediate consumption.
-                             if c_amt == 0:
-                                 consume_now = min(b_amt, getattr(self.config_module, "FOOD_CONSUMPTION_QUANTITY", 1.0))
-                                 household.consume("basic_food", consume_now, self.time)
-                                 consumed_items["basic_food"] = consume_now
-
-                 # 2. Phase 5: Leisure Effect Application
-                 leisure_hours = household_time_allocation.get(household.id, 0.0)
-                 effect_dto = household.apply_leisure_effect(leisure_hours, consumed_items)
-                 
-                 # 3. Lifecycle Update [BUGFIX: WO-Diag-003]
-                 household.update_needs(self.time, consumption_market_data)
-
-                 # Store utility for reward injection
-                 household_leisure_effects[household.id] = effect_dto.utility_gained
-
-                 # Apply XP to Children (if Parenting)
-                 if effect_dto.leisure_type == "PARENTING" and effect_dto.xp_gained > 0:
-                     for child_id in household.children_ids:
-                         # Children might be in self.agents
-                         child = self.agents.get(child_id)
-                         if child and isinstance(child, Household) and child.is_active:
-                             child.education_xp += effect_dto.xp_gained
-                             self.logger.debug(
-                                 f"PARENTING_XP_TRANSFER | Parent {household.id} -> Child {child_id}. XP: {effect_dto.xp_gained:.4f}",
-                                 extra={"agent_id": household.id, "tags": ["LEISURE_EFFECT", "parenting"]}
-                             )
+            if household.is_active:
+                # 1. Consumption (Vectorized Optimization)
+                # Replace decide_and_consume with vectorized result application
+                consumed_items = {}
+
+                # 1a. Fast Consumption (Basic Food)
+                if i < len(consume_list):
+                    c_amt = consume_list[i]
+                    if c_amt > 0:
+                        household.consume("basic_food", c_amt, self.time)
+                        consumed_items["basic_food"] = c_amt
+
+                # 1b. Fast Purchase (Survival Rescue - Logic Map Item 3)
+                if i < len(buy_list):
+                    b_amt = buy_list[i]
+                    if b_amt > 0:
+                        cost = b_amt * food_price
+                        if household.assets >= cost:
+                            household.assets -= cost
+                            household.inventory["basic_food"] = (
+                                household.inventory.get("basic_food", 0) + b_amt
+                            )
+                            # To prevent money destruction, we route this to Reflux System (Sink)
+                            self.reflux_system.capture(
+                                cost,
+                                source=f"Household_{household.id}",
+                                category="emergency_food",
+                            )
+                            self.logger.debug(
+                                f"VECTOR_BUY | Household {household.id} bought {b_amt:.1f} food (Fast Track)",
+                                extra={
+                                    "agent_id": household.id,
+                                    "tags": ["consumption", "vector_buy"],
+                                },
+                            )
+                            # Consume immediately if they were starving and bought it?
+                            # The planner separates buy/consume. If they bought, they might consume next tick
+                            # or we can force consume now if consumption was 0?
+                            # Vector planner logic for consumption relies on Inventory > 0.
+                            # If inventory was 0, c_amt is 0.
+                            # If we buy now, we should probably allow immediate consumption.
+                            if c_amt == 0:
+                                consume_now = min(
+                                    b_amt,
+                                    getattr(
+                                        self.config_module,
+                                        "FOOD_CONSUMPTION_QUANTITY",
+                                        1.0,
+                                    ),
+                                )
+                                household.consume("basic_food", consume_now, self.time)
+                                consumed_items["basic_food"] = consume_now
+
+                # 2. Phase 5: Leisure Effect Application
+                leisure_hours = household_time_allocation.get(household.id, 0.0)
+                effect_dto = household.apply_leisure_effect(
+                    leisure_hours, consumed_items
+                )
+
+                # 3. Lifecycle Update [BUGFIX: WO-Diag-003]
+                household.update_needs(self.time, consumption_market_data)
+
+                # Store utility for reward injection
+                household_leisure_effects[household.id] = effect_dto.utility_gained
+
+                # Apply XP to Children (if Parenting)
+                if effect_dto.leisure_type == "PARENTING" and effect_dto.xp_gained > 0:
+                    for child_id in household.children_ids:
+                        # Children might be in self.agents
+                        child = self.agents.get(child_id)
+                        if child and isinstance(child, Household) and child.is_active:
+                            child.education_xp += effect_dto.xp_gained
+                            self.logger.debug(
+                                f"PARENTING_XP_TRANSFER | Parent {household.id} -> Child {child_id}. XP: {effect_dto.xp_gained:.4f}",
+                                extra={
+                                    "agent_id": household.id,
+                                    "tags": ["LEISURE_EFFECT", "parenting"],
+                                },
+                            )
 
         # --- Phase 23: Technology Manager Update ---
         self.technology_manager.update(self.time, self)
@@ -755,8 +857,8 @@ class Simulation:
 
         # Phase 17-3B: Housing Market Matching
         if "housing" in self.markets:
-             housing_transactions = self.markets["housing"].match_orders(self.time)
-             all_transactions.extend(housing_transactions)
+            housing_transactions = self.markets["housing"].match_orders(self.time)
+            all_transactions.extend(housing_transactions)
 
         # --- Phase 19: Population Dynamics ---
         # 1. Aging
@@ -812,19 +914,25 @@ class Simulation:
         # Activate Farm Logic (Production & Needs/Wages)
         # ---------------------------------------------------------
         for firm in self.firms:
-             if firm.is_active:
-                 # Phase 23: Pass Technology Manager for Productivity
-                 firm.produce(self.time, technology_manager=self.technology_manager)
-                 # Phase 4: Pass government and market_data for income tax withholding
-                 # Phase 8-B: Pass reflux_system for expense capture
-                 firm.update_needs(self.time, self.government, market_data, self.reflux_system)
-                 
-                 # 2a. ë²•ì¸ì„¸(Corporate Tax) ì§•ìˆ˜ (ì´ìµì´ ë°œìƒí•œ ê²½ìš°)
-                 # [LEVIATHAN UPDATE] use government.calculate_corporate_tax
-                 if firm.is_active and firm.current_profit > 0:
-                     tax_amount = self.government.calculate_corporate_tax(firm.current_profit)
-                     firm.assets -= tax_amount
-                     self.government.collect_tax(tax_amount, "corporate_tax", firm.id, self.time)
+            if firm.is_active:
+                # Phase 23: Pass Technology Manager for Productivity
+                firm.produce(self.time, technology_manager=self.technology_manager)
+                # Phase 4: Pass government and market_data for income tax withholding
+                # Phase 8-B: Pass reflux_system for expense capture
+                firm.update_needs(
+                    self.time, self.government, market_data, self.reflux_system
+                )
+
+                # 2a. ë²•ì¸ì„¸(Corporate Tax) ì§•ìˆ˜ (ì´ìµì´ ë°œìƒí•œ ê²½ìš°)
+                # [LEVIATHAN UPDATE] use government.calculate_corporate_tax
+                if firm.is_active and firm.current_profit > 0:
+                    tax_amount = self.government.calculate_corporate_tax(
+                        firm.current_profit
+                    )
+                    firm.assets -= tax_amount
+                    self.government.collect_tax(
+                        tax_amount, "corporate_tax", firm.id, self.time
+                    )
 
         # 2b. ì •ë¶€ ì¸í”„ë¼ íˆ¬ì (ì˜ˆì‚° ì¶©ì¡± ì‹œ)
         # Phase 8-B: Pass reflux_system to capture infrastructure spending
@@ -832,39 +940,36 @@ class Simulation:
             # ì¸í”„ë¼ íˆ¬ì ì„±ê³µ ì‹œ ëª¨ë“  ê¸°ì—…ì˜ TFP ìƒí–¥ ì¡°ì •
             tfp_boost = getattr(self.config_module, "INFRASTRUCTURE_TFP_BOOST", 0.05)
             for firm in self.firms:
-                firm.productivity_factor *= (1.0 + tfp_boost)
+                firm.productivity_factor *= 1.0 + tfp_boost
             self.logger.info(
-                f"GLOBAL_TFP_BOOST | All firms productivity increased by {tfp_boost*100:.1f}%",
-                extra={"tick": self.time, "tags": ["government", "infrastructure"]}
+                f"GLOBAL_TFP_BOOST | All firms productivity increased by {tfp_boost * 100:.1f}%",
+                extra={"tick": self.time, "tags": ["government", "infrastructure"]},
             )
 
-
         for firm in self.firms:
             if firm.is_active and firm.id in firm_pre_states:
                 post_state_data = firm.get_agent_data()
                 agent_data = firm.get_agent_data()
                 market_data = self._prepare_market_data(self.tracker)
-                
+
                 # Calculate Reward using new method for Firms (Brand Valuation)
                 reward = firm.decision_engine.ai_engine.calculate_reward(
                     firm, firm.get_pre_state_data(), agent_data
                 )
-                
+
                 # Update Learning V2
                 firm.decision_engine.ai_engine.update_learning_v2(
                     reward=reward,
                     next_agent_data=agent_data,
                     next_market_data=market_data,
                 )
-                
+
                 decision_data = AIDecisionData(
                     run_id=self.run_id,
                     tick=self.time,
                     agent_id=firm.id,
                     decision_type="VECTOR_V2",
-                    decision_details={
-                       "reward": reward
-                    },
+                    decision_details={"reward": reward},
                     predicted_reward=None,
                     actual_reward=reward,
                 )
@@ -885,7 +990,7 @@ class Simulation:
                 post_state_data = household.get_agent_data()
                 agent_data = household.get_agent_data()
                 market_data = self._prepare_market_data(self.tracker)
-                
+
                 # Inject Phase 5 Leisure Utility into agent_data for Reward Calculation
                 leisure_utility = household_leisure_effects.get(household.id, 0.0)
                 agent_data["leisure_utility"] = leisure_utility
@@ -897,7 +1002,7 @@ class Simulation:
                     agent_data,
                     market_data,
                 )
-                
+
                 # Update Learning V2
                 household.decision_engine.ai_engine.update_learning_v2(
                     reward=reward,
@@ -910,9 +1015,7 @@ class Simulation:
                     tick=self.time,
                     agent_id=household.id,
                     decision_type="VECTOR_V2",
-                    decision_details={
-                        "reward": reward
-                    },
+                    decision_details={"reward": reward},
                     predicted_reward=None,
                     actual_reward=reward,
                 )
@@ -935,9 +1038,11 @@ class Simulation:
         # They remain in self.agents for ID reference, but won't act in future ticks
         active_firms_count_before = len(self.firms)
         self.firms = [f for f in self.firms if f.is_active]
-        
+
         if len(self.firms) < active_firms_count_before:
-            self.logger.info(f"CLEANUP | Removed {active_firms_count_before - len(self.firms)} inactive firms from execution list.")
+            self.logger.info(
+                f"CLEANUP | Removed {active_firms_count_before - len(self.firms)} inactive firms from execution list."
+            )
 
         # --- Handle Agent Lifecycle (Death, Liquidation) ---
         # Added as per requirement (previously missing in run_tick)
@@ -980,8 +1085,8 @@ class Simulation:
             f.last_sales_volume = f.sales_volume_this_tick
             # Reset current counters
             f.sales_volume_this_tick = 0.0
-            f.expenses_this_tick = 0.0 # Reset expenses as well
-            f.revenue_this_tick = 0.0 # Reset revenue
+            f.expenses_this_tick = 0.0  # Reset expenses as well
+            f.revenue_this_tick = 0.0  # Reset revenue
 
         # --- Gold Standard / Money Supply Verification (WO-016) ---
         if self.time >= 1:
@@ -997,16 +1102,22 @@ class Simulation:
 
             # Log Level: Info normally, Warning if delta is significant (> 1.0)
             msg = f"MONEY_SUPPLY_CHECK | Current: {current_money:.2f}, Expected: {expected_money:.2f}, Delta: {delta:.4f}"
-            extra_data = {"tick": self.time, "current": current_money, "expected": expected_money, "delta": delta, "tags": ["money_supply"]}
+            extra_data = {
+                "tick": self.time,
+                "current": current_money,
+                "expected": expected_money,
+                "delta": delta,
+                "tags": ["money_supply"],
+            }
 
             if abs(delta) > 1.0:
-                 self.logger.warning(msg, extra=extra_data)
+                self.logger.warning(msg, extra=extra_data)
             else:
-                 self.logger.info(msg, extra=extra_data)
+                self.logger.info(msg, extra=extra_data)
 
         # WO-058: Generational Wealth Audit
         if self.time % 100 == 0:
-             self.generational_wealth_audit.run_audit(self.households, self.time)
+            self.generational_wealth_audit.run_audit(self.households, self.time)
 
         self.logger.info(
             f"--- Ending Tick {self.time} ---",
@@ -1019,8 +1130,9 @@ class Simulation:
 
         # Track stock market
         if self.stock_market is not None:
-            self.stock_tracker.track_all_firms([f for f in self.firms if f.is_active], self.stock_market)
-
+            self.stock_tracker.track_all_firms(
+                [f for f in self.firms if f.is_active], self.stock_market
+            )
 
     def _prepare_market_data(self, tracker: EconomicIndicatorTracker) -> Dict[str, Any]:
         """í˜„ì¬ í‹±ì˜ ì‹œì¥ ë°ì´í„°ë¥¼ ì—ì´ì „íŠ¸ì˜ ì˜ì‚¬ê²°ì •ì„ ìœ„í•´ ì¤€ë¹„í•©ë‹ˆë‹¤."""
@@ -1032,7 +1144,9 @@ class Simulation:
         debt_data_map = {}
         deposit_data_map = {}
         for agent_id in self.agents:
-            if isinstance(self.agents[agent_id], Household) or isinstance(self.agents[agent_id], Firm):
+            if isinstance(self.agents[agent_id], Household) or isinstance(
+                self.agents[agent_id], Firm
+            ):
                 debt_data_map[agent_id] = self.bank.get_debt_summary(agent_id)
                 deposit_data_map[agent_id] = self.bank.get_deposit_balance(agent_id)
 
@@ -1041,27 +1155,31 @@ class Simulation:
             if market and isinstance(market, OrderBookMarket):
                 # 1. ì´ë²ˆ í‹±ì˜ í‰ê·  ì²´ê²°ê°€ (ê±°ë˜ê°€ ìˆì—ˆë‹¤ë©´ ê°€ì¥ ì •í™•)
                 avg_price = market.get_daily_avg_price()
-                
+
                 # 2. ê±°ë˜ê°€ ì—†ì—ˆë‹¤ë©´ í˜¸ê°€ì°½ì˜ ìµœì € ë§¤ë„ê°€(Best Ask)
                 if avg_price <= 0:
                     avg_price = market.get_best_ask(good_name) or 0
-                
+
                 # 3. í˜¸ê°€ë„ ì—†ë‹¤ë©´ ì´ì „ í‹±ì˜ ê¸°ë¡ëœ ê°€ê²© (Tracker)
                 if avg_price <= 0:
                     latest = tracker.get_latest_indicators()
                     # Tracker í•„ë“œëª…ì€ {item_id}_avg_price í˜•ì‹ì„ ë”°ë¦„ (EconomicIndicatorTracker ì°¸ê³ )
                     avg_price = latest.get(f"{good_name}_avg_price", 0)
-                
+
                 # 4. ëª¨ë‘ ì—†ë‹¤ë©´ ì„¤ì • íŒŒì¼ì˜ ì´ˆê¸° ê°€ê²©
                 if avg_price <= 0:
-                    avg_price = self.config_module.GOODS[good_name].get("initial_price", 10.0)
-                
+                    avg_price = self.config_module.GOODS[good_name].get(
+                        "initial_price", 10.0
+                    )
+
                 goods_market_data[f"{good_name}_current_sell_price"] = avg_price
 
         # Include Labor Market Data (Use historical data as the order book is cleared)
         latest_indicators = tracker.get_latest_indicators()
-        avg_wage = latest_indicators.get("labor_avg_price", self.config_module.LABOR_MARKET_MIN_WAGE)
-        
+        avg_wage = latest_indicators.get(
+            "labor_avg_price", self.config_module.LABOR_MARKET_MIN_WAGE
+        )
+
         labor_market = self.markets.get("labor")
         best_wage_offer = 0.0
         if labor_market and isinstance(labor_market, OrderBookMarket):
@@ -1075,15 +1193,15 @@ class Simulation:
         # Sum of quantities of all buy orders in the labor market
         job_vacancies = 0
         if labor_market and isinstance(labor_market, OrderBookMarket):
-             # buy_orders is Dict[item_id, List[Order]]
-             # In labor market, item_id is usually "labor" or "research_labor"
-             for item_orders in labor_market.buy_orders.values():
-                 for order in item_orders:
-                     job_vacancies += order.quantity
+            # buy_orders is Dict[item_id, List[Order]]
+            # In labor market, item_id is usually "labor" or "research_labor"
+            for item_orders in labor_market.buy_orders.values():
+                for order in item_orders:
+                    job_vacancies += order.quantity
 
         goods_market_data["labor"] = {
             "avg_wage": avg_wage,
-            "best_wage_offer": best_wage_offer
+            "best_wage_offer": best_wage_offer,
         }
         goods_market_data["job_vacancies"] = job_vacancies
 
@@ -1108,28 +1226,36 @@ class Simulation:
                     price = self.stock_market.get_best_ask(firm.id) or 0
                 if price <= 0:
                     # ì¥ê¸° ê¸°ë¡ì´ë‚˜ ì¥ë¶€ê°€ë¥¼ fallbackìœ¼ë¡œ ì‚¬ìš© ê°€ëŠ¥
-                    price = firm.assets / firm.total_shares if firm.total_shares > 0 else 10.0
+                    price = (
+                        firm.assets / firm.total_shares
+                        if firm.total_shares > 0
+                        else 10.0
+                    )
                 stock_market_data[firm_item_id] = {"avg_price": price}
 
         # Calculate Avg Rent Price (Phase 20-3)
-        rent_prices = [u.rent_price for u in self.real_estate_units if u.owner_id is not None]
-        avg_rent = sum(rent_prices) / len(rent_prices) if rent_prices else self.config_module.INITIAL_RENT_PRICE
+        rent_prices = [
+            u.rent_price for u in self.real_estate_units if u.owner_id is not None
+        ]
+        avg_rent = (
+            sum(rent_prices) / len(rent_prices)
+            if rent_prices
+            else self.config_module.INITIAL_RENT_PRICE
+        )
 
         # Inject Housing Market Data
-        housing_market_data = {
-            "avg_rent_price": avg_rent
-        }
+        housing_market_data = {"avg_rent_price": avg_rent}
 
         return {
             "time": self.time,
             "goods_market": goods_market_data,
-            "housing_market": housing_market_data, # Phase 20-3
-            "loan_market": {"interest_rate": self.bank.base_rate}, # Use bank base rate
+            "housing_market": housing_market_data,  # Phase 20-3
+            "loan_market": {"interest_rate": self.bank.base_rate},  # Use bank base rate
             "stock_market": stock_market_data,
             "all_households": self.households,
             "avg_goods_price": avg_goods_price_for_market_data,
-            "debt_data": debt_data_map, # Injected Debt Data
-            "deposit_data": deposit_data_map, # Injected Deposit Data
+            "debt_data": debt_data_map,  # Injected Debt Data
+            "deposit_data": deposit_data_map,  # Injected Deposit Data
         }
 
     def _calculate_total_money(self) -> float:
@@ -1159,7 +1285,6 @@ class Simulation:
 
         return total
 
-
     def get_all_agents(self) -> List[Any]:
         """ì‹œë®¬ë ˆì´ì…˜ì— ì°¸ì—¬í•˜ëŠ” ëª¨ë“  í™œì„± ì—ì´ì „íŠ¸(ê°€ê³„, ê¸°ì—…, ì€í–‰ ë“±)ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."""
         all_agents = []
@@ -1175,13 +1300,15 @@ class Simulation:
     def _process_transactions(self, transactions: List[Transaction]) -> None:
         """ë°œìƒí•œ ê±°ë˜ë“¤ì„ ì²˜ë¦¬í•˜ì—¬ ì—ì¸¡ëœ ê°€ê³„/ê¸°ì—… ìƒíƒœ ë“±ì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤."""
         # SoC Refactor: Logic moved to TransactionProcessor
-        market_data_cb = lambda: self._prepare_market_data(self.tracker).get("goods_market", {})
+        market_data_cb = lambda: self._prepare_market_data(self.tracker).get(
+            "goods_market", {}
+        )
         self.transaction_processor.process(
             transactions=transactions,
             agents=self.agents,
             government=self.government,
             current_time=self.time,
-            market_data_callback=market_data_cb
+            market_data_callback=market_data_cb,
         )
 
     def _process_stock_transactions(self, transactions: List[Transaction]) -> None:
@@ -1215,60 +1342,69 @@ class Simulation:
                 elif hasattr(seller, "portfolio"):
                     # Secondary market trade
                     seller.portfolio.remove(firm_id, tx.quantity)
-                
+
                 # Sync Legacy Dictionaries for Seller
                 if hasattr(seller, "shares_owned"):
                     if firm_id in seller.portfolio.holdings:
-                        seller.shares_owned[firm_id] = seller.portfolio.holdings[firm_id].quantity
+                        seller.shares_owned[firm_id] = seller.portfolio.holdings[
+                            firm_id
+                        ].quantity
                     elif firm_id in seller.shares_owned:
                         del seller.shares_owned[firm_id]
 
                 # Synchronize Market Shareholder Registry (CRITICAL for Dividends)
                 if self.stock_market:
                     # Sync Buyer
-                    self.stock_market.update_shareholder(buyer.id, firm_id, buyer.portfolio.holdings[firm_id].quantity)
+                    self.stock_market.update_shareholder(
+                        buyer.id, firm_id, buyer.portfolio.holdings[firm_id].quantity
+                    )
                     # Sync Seller
-                    if hasattr(seller, "portfolio") and firm_id in seller.portfolio.holdings:
-                        self.stock_market.update_shareholder(seller.id, firm_id, seller.portfolio.holdings[firm_id].quantity)
+                    if (
+                        hasattr(seller, "portfolio")
+                        and firm_id in seller.portfolio.holdings
+                    ):
+                        self.stock_market.update_shareholder(
+                            seller.id,
+                            firm_id,
+                            seller.portfolio.holdings[firm_id].quantity,
+                        )
                     else:
                         self.stock_market.update_shareholder(seller.id, firm_id, 0.0)
 
                 self.logger.info(
                     f"STOCK_TX | Buyer: {buyer.id}, Seller: {seller.id}, Firm: {firm_id}, Qty: {tx.quantity}, Price: {tx.price}",
-                    extra={"tick": self.time, "tags": ["stock_market", "transaction"]}
+                    extra={"tick": self.time, "tags": ["stock_market", "transaction"]},
                 )
 
-
-
     def _handle_agent_lifecycle(self) -> None:
         """ë¹„í™œì„±í™”ëœ ì—ì´ì „íŠ¸ë¥¼ ì²­ì‚°í•˜ê³  ì‹œë®¬ë ˆì´ì…˜ì—ì„œ ì œê±°í•©ë‹ˆë‹¤."""
-        
+
         # 1. íŒŒì‚° ê¸°ì—… ì²­ì‚° (Firm Liquidation)
         inactive_firms = [f for f in self.firms if not f.is_active]
         for firm in inactive_firms:
             self.logger.info(
                 f"FIRM_LIQUIDATION | Starting liquidation for Firm {firm.id}. "
                 f"Assets: {firm.assets:.2f}, Inventory: {sum(firm.inventory.values()):.2f}",
-                extra={"agent_id": firm.id, "tags": ["liquidation"]}
+                extra={"agent_id": firm.id, "tags": ["liquidation"]},
             )
-            
+
             # 1a. ì§ì› í•´ê³ 
             for employee in firm.employees:
                 if employee.is_active:
                     employee.is_employed = False
                     employee.employer_id = None
             firm.employees = []
-            
+
             # 1b. ì¬ê³  ì†Œë©¸ (ì‹œì¥ì— ë§¤ë„í•˜ëŠ” ëŒ€ì‹  ê°„ë‹¨íˆ ì†Œë©¸)
             total_inventory_value = sum(
-                qty * firm.last_prices.get(item_id, 10.0) 
+                qty * firm.last_prices.get(item_id, 10.0)
                 for item_id, qty in firm.inventory.items()
             )
             firm.inventory.clear()
-            
+
             # 1c. ìë³¸ì¬ ì†Œë©¸
             firm.capital_stock = 0.0
-            
+
             # 1d. í˜„ê¸ˆì„ ì£¼ì£¼(ê°€ê³„)ì—ê²Œ ë¶„ë°°
             total_cash = firm.assets
             if total_cash > 0:
@@ -1276,20 +1412,28 @@ class Simulation:
                 if outstanding_shares > 0:
                     for household in self.households:
                         if household.is_active and firm.id in household.shares_owned:
-                            share_ratio = household.shares_owned[firm.id] / outstanding_shares
+                            share_ratio = (
+                                household.shares_owned[firm.id] / outstanding_shares
+                            )
                             distribution = total_cash * share_ratio
                             household.assets += distribution
                             self.logger.info(
                                 f"LIQUIDATION_DISTRIBUTION | Household {household.id} received "
                                 f"{distribution:.2f} from Firm {firm.id} liquidation",
-                                extra={"agent_id": household.id, "tags": ["liquidation"]}
+                                extra={
+                                    "agent_id": household.id,
+                                    "tags": ["liquidation"],
+                                },
                             )
                 else:
                     # No active shareholders: Escheat to Government (Money Destruction)
                     from simulation.agents.government import Government
+
                     if isinstance(self.government, Government):
-                        self.government.collect_tax(total_cash, "liquidation_escheatment", firm.id, self.time)
-            
+                        self.government.collect_tax(
+                            total_cash, "liquidation_escheatment", firm.id, self.time
+                        )
+
             # 1e. ì£¼ì£¼ë“¤ì˜ í•´ë‹¹ ê¸°ì—… ì£¼ì‹ ë³´ìœ ëŸ‰ ì‚­ì œ
             for household in self.households:
                 if firm.id in household.shares_owned:
@@ -1297,11 +1441,11 @@ class Simulation:
                     # [Mitosis] Update registry
                     if self.stock_market:
                         self.stock_market.update_shareholder(household.id, firm.id, 0)
-            
+
             firm.assets = 0.0
             self.logger.info(
                 f"FIRM_LIQUIDATION_COMPLETE | Firm {firm.id} fully liquidated.",
-                extra={"agent_id": firm.id, "tags": ["liquidation"]}
+                extra={"agent_id": firm.id, "tags": ["liquidation"]},
             )
 
         # 2. ì‚¬ë§ ê°€ê³„ ì²­ì‚° (Household Liquidation)
@@ -1311,7 +1455,7 @@ class Simulation:
             # Replaces Phase 19 DemographicManager logic and standard liquidation
             if hasattr(self, "inheritance_manager"):
                 self.inheritance_manager.process_death(household, self.government, self)
-            
+
             # Remaining cleanup (Inventory/Metadata)
             household.inventory.clear()
             # Shares should be cleared by InheritanceManager, but double check
@@ -1321,7 +1465,7 @@ class Simulation:
             # [Mitosis] Clear shareholder registry for this household
             if self.stock_market:
                 for firm_id in list(self.stock_market.shareholders.keys()):
-                     self.stock_market.update_shareholder(household.id, firm_id, 0)
+                    self.stock_market.update_shareholder(household.id, firm_id, 0)
 
         # 3. ì‹œë®¬ë ˆì´ì…˜ì—ì„œ ë¹„í™œì„± ì—ì´ì „íŠ¸ ì œê±°
         self.households = [h for h in self.households if h.is_active]
diff --git a/design/gemini_output/jules_engine_revised.py b/design/gemini_output/jules_engine_revised.py
index 41bd182..d0e6441 100644
--- a/design/gemini_output/jules_engine_revised.py
+++ b/design/gemini_output/jules_engine_revised.py
@@ -18,23 +18,30 @@ from simulation.loan_market import LoanMarket
 from simulation.markets.stock_market import StockMarket
 from simulation.metrics.economic_tracker import EconomicIndicatorTracker
 from simulation.metrics.inequality_tracker import InequalityTracker
-from simulation.metrics.stock_tracker import StockMarketTracker, PersonalityStatisticsTracker
+from simulation.metrics.stock_tracker import (
+    StockMarketTracker,
+    PersonalityStatisticsTracker,
+)
 from simulation.ai_model import AIEngineRegistry
 from simulation.ai.ai_training_manager import AITrainingManager
 from simulation.systems.ma_manager import MAManager
 from simulation.systems.reflux_system import EconomicRefluxSystem
-from simulation.systems.demographic_manager import DemographicManager # Phase 19
-from simulation.systems.immigration_manager import ImmigrationManager # Phase 20-3
-from simulation.systems.inheritance_manager import InheritanceManager # Phase 22 (WO-049)
-from simulation.systems.housing_system import HousingSystem # Phase 22.5
-from simulation.systems.persistence_manager import PersistenceManager # Phase 22.5
-from simulation.systems.firm_management import FirmSystem # Phase 22.5
-from simulation.systems.technology_manager import TechnologyManager # Phase 23 (WO-053)
-from simulation.systems.bootstrapper import Bootstrapper # WO-058
+from simulation.systems.demographic_manager import DemographicManager  # Phase 19
+from simulation.systems.immigration_manager import ImmigrationManager  # Phase 20-3
+from simulation.systems.inheritance_manager import (
+    InheritanceManager,
+)  # Phase 22 (WO-049)
+from simulation.systems.housing_system import HousingSystem  # Phase 22.5
+from simulation.systems.persistence_manager import PersistenceManager  # Phase 22.5
+from simulation.systems.firm_management import FirmSystem  # Phase 22.5
+from simulation.systems.technology_manager import TechnologyManager  # Phase 23 (WO-053)
+from simulation.systems.bootstrapper import Bootstrapper  # WO-058
 from simulation.systems.generational_wealth_audit import GenerationalWealthAudit
-from simulation.decisions.housing_manager import HousingManager # For rank/tier helper
+from simulation.decisions.housing_manager import HousingManager  # For rank/tier helper
 from simulation.ai.vectorized_planner import VectorizedHouseholdPlanner
-from simulation.systems.transaction_processor import TransactionProcessor # SoC Refactor
+from simulation.systems.transaction_processor import (
+    TransactionProcessor,
+)  # SoC Refactor
 from modules.finance.system import FinanceSystem
 
 # Use the repository pattern for data access
@@ -82,21 +89,19 @@ class Simulation:
         self.config_module = config_module
         self.time: int = 0
 
-        self.batch_save_interval = 50 # WO-051: Hardcoded I/O Optimization
+        self.batch_save_interval = 50  # WO-051: Hardcoded I/O Optimization
 
         self.bank = Bank(
             id=self.next_agent_id,
             initial_assets=self.config_module.INITIAL_BANK_ASSETS,
-            config_module=self.config_module
+            config_module=self.config_module,
         )
         self.agents[self.bank.id] = self.bank
         self.next_agent_id += 1
 
         # ì •ë¶€ ì—ì´ì „íŠ¸ ì´ˆê¸°í™”
         self.government = Government(
-            id=self.next_agent_id, 
-            initial_assets=0.0, 
-            config_module=self.config_module
+            id=self.next_agent_id, initial_assets=0.0, config_module=self.config_module
         )
         self.agents[self.government.id] = self.government
         self.next_agent_id += 1
@@ -108,8 +113,7 @@ class Simulation:
 
         # Central Bank Initialization (Phase 10)
         self.central_bank = CentralBank(
-            tracker=self.tracker,
-            config_module=self.config_module
+            tracker=self.tracker, config_module=self.config_module
         )
         # Central Bank is not in self.agents dict as it's a special system agent
         # similar to how markets are handled, or we can add it if needed.
@@ -119,20 +123,25 @@ class Simulation:
         self.finance_system = FinanceSystem(
             government=self.government,
             central_bank=self.central_bank,
-            config_module=self.config_module
+            config_module=self.config_module,
         )
-        self.government.finance_system = self.finance_system # Inject into government
+        self.government.finance_system = self.finance_system  # Inject into government
 
         # Phase 17-3A: Initialize Real Estate Units
         self.real_estate_units: List[RealEstateUnit] = [
-            RealEstateUnit(id=i, estimated_value=self.config_module.INITIAL_PROPERTY_VALUE,
-                           rent_price=self.config_module.INITIAL_RENT_PRICE)
+            RealEstateUnit(
+                id=i,
+                estimated_value=self.config_module.INITIAL_PROPERTY_VALUE,
+                rent_price=self.config_module.INITIAL_RENT_PRICE,
+            )
             for i in range(self.config_module.NUM_HOUSING_UNITS)
         ]
 
         # Distribute to top 20% households
         top_20_count = len(self.households) // 5
-        top_households = sorted(self.households, key=lambda h: h.assets, reverse=True)[:top_20_count]
+        top_households = sorted(self.households, key=lambda h: h.assets, reverse=True)[
+            :top_20_count
+        ]
 
         for i, hh in enumerate(top_households):
             if i < len(self.real_estate_units):
@@ -154,12 +163,14 @@ class Simulation:
         )
         # Pass agents reference to LoanMarket for credit check
         self.markets["loan_market"].agents_ref = self.agents
-        
+
         if getattr(self.config_module, "STOCK_MARKET_ENABLED", False):
-            self.stock_market = StockMarket(config_module=self.config_module, logger=self.logger)
+            self.stock_market = StockMarket(
+                config_module=self.config_module, logger=self.logger
+            )
             self.stock_tracker = StockMarketTracker(config_module=self.config_module)
             self.markets["stock_market"] = self.stock_market
-            
+
             # Phase 25/WO-060: Automatic IPO for existing firms
             for firm in self.firms:
                 if hasattr(firm, "init_ipo"):
@@ -170,18 +181,18 @@ class Simulation:
 
         # Phase 17-3B: Housing Market & Initial Sales
         self.markets["housing"] = OrderBookMarket(market_id="housing")
-        
+
         # Government places SELL orders for unowned properties (80 units)
         for unit in self.real_estate_units:
             if unit.owner_id is None:
                 # Sell Order: item_id="unit_{id}", price=estimated_value, qty=1
                 sell_order = Order(
-                    agent_id=self.government.id, # Government ID
+                    agent_id=self.government.id,  # Government ID
                     item_id=f"unit_{unit.id}",
                     price=unit.estimated_value,
                     quantity=1.0,
                     market_id="housing",
-                    order_type="SELL"
+                    order_type="SELL",
                 )
                 if "housing" in self.markets:
                     self.markets["housing"].place_order(sell_order, self.time)
@@ -189,7 +200,7 @@ class Simulation:
         # 2. ì—ì´ì „íŠ¸ ìš•êµ¬ ì—…ë°ì´íŠ¸ (Update Needs)
         for agent in self.households + self.firms:
             agent.update_needs(self.time)
-            
+
         # 3. ì—ì´ì „íŠ¸ ì˜ì‚¬ê²°ì • ë° í–‰ë™ (Decisions & Actions)
         for agent in self.households + self.firms:
             agent.decision_engine.markets = self.markets
@@ -199,15 +210,17 @@ class Simulation:
 
         self.repository = repository
         # self.tracker = EconomicIndicatorTracker(config_module=config_module) # Moved up
-        
+
         # ì¶”ê°€ ì§€í‘œ Tracker ì´ˆê¸°í™”
         self.inequality_tracker = InequalityTracker(config_module=config_module)
-        self.personality_tracker = PersonalityStatisticsTracker(config_module=config_module)
-        
+        self.personality_tracker = PersonalityStatisticsTracker(
+            config_module=config_module
+        )
+
         self.ai_training_manager = AITrainingManager(
             self.households, self.config_module
         )
-        
+
         # M&A Manager System
         self.ma_manager = MAManager(self, self.config_module)
 
@@ -228,16 +241,18 @@ class Simulation:
 
         # Phase 22.5: Persistence Manager (Refactored)
         self.persistence_manager = PersistenceManager(
-            run_id=0, # Placeholder, will be set after run_id is generated below
+            run_id=0,  # Placeholder, will be set after run_id is generated below
             config_module=self.config_module,
-            repository=self.repository
+            repository=self.repository,
         )
 
         # Phase 22.5: Firm System (Refactored)
         self.firm_system = FirmSystem(config_module=self.config_module)
 
         # Phase 23: Technology Manager
-        self.technology_manager = TechnologyManager(config_module=self.config_module, logger=self.logger)
+        self.technology_manager = TechnologyManager(
+            config_module=self.config_module, logger=self.logger
+        )
 
         # [WO-058] Bootstrapper Injection (Economic CPR)
         # Ensure firms have resources to start production
@@ -245,7 +260,9 @@ class Simulation:
         Bootstrapper.force_assign_workers(self.firms, self.households)
 
         # WO-058: Generational Wealth Audit
-        self.generational_wealth_audit = GenerationalWealthAudit(config_module=self.config_module)
+        self.generational_wealth_audit = GenerationalWealthAudit(
+            config_module=self.config_module
+        )
 
         # WO-051: Vectorized Planner Initialization
         self.breeding_planner = VectorizedHouseholdPlanner(self.config_module)
@@ -287,8 +304,6 @@ class Simulation:
         self.repository.close()
         self.logger.info("Simulation finalized and Repository connection closed.")
 
-
-
     def _update_social_ranks(self):
         """Phase 17-4: Update Social Rank (Percentile)"""
         # 1. Calculate Scores
@@ -297,11 +312,12 @@ class Simulation:
         hm = HousingManager(None, self.config_module)
 
         for h in self.households:
-            if not h.is_active: continue
+            if not h.is_active:
+                continue
 
-            consumption_score = h.current_consumption * 10.0 # Weight consumption
+            consumption_score = h.current_consumption * 10.0  # Weight consumption
             housing_tier = hm.get_housing_tier(h)
-            housing_score = housing_tier * 1000.0 # Tier 1=1000, Tier 3=3000
+            housing_score = housing_tier * 1000.0  # Tier 1=1000, Tier 3=3000
 
             total_score = consumption_score + housing_score
             scores.append((h.id, total_score))
@@ -309,7 +325,8 @@ class Simulation:
         # 2. Sort and Assign Rank
         sorted_scores = sorted(scores, key=lambda x: x[1], reverse=True)
         n = len(sorted_scores)
-        if n == 0: return
+        if n == 0:
+            return
 
         for rank_idx, (hid, _) in enumerate(sorted_scores):
             # Rank 0 (Top) -> Percentile 1.0
@@ -326,7 +343,11 @@ class Simulation:
             return {"avg_consumption": 0.0, "avg_housing_tier": 0.0}
 
         top_20_count = max(1, int(len(active_households) * 0.20))
-        sorted_hh = sorted(active_households, key=lambda h: getattr(h, "social_rank", 0.0), reverse=True)
+        sorted_hh = sorted(
+            active_households,
+            key=lambda h: getattr(h, "social_rank", 0.0),
+            reverse=True,
+        )
         top_20 = sorted_hh[:top_20_count]
 
         # Temp helper
@@ -335,18 +356,17 @@ class Simulation:
         avg_cons = sum(h.current_consumption for h in top_20) / len(top_20)
         avg_tier = sum(hm.get_housing_tier(h) for h in top_20) / len(top_20)
 
-        return {
-            "avg_consumption": avg_cons,
-            "avg_housing_tier": avg_tier
-        }
+        return {"avg_consumption": avg_cons, "avg_housing_tier": avg_tier}
 
-    def run_tick(self, injectable_sensory_dto: Optional[GovernmentStateDTO] = None) -> None:
+    def run_tick(
+        self, injectable_sensory_dto: Optional[GovernmentStateDTO] = None
+    ) -> None:
         # --- Gold Standard / Money Supply Verification (WO-016) ---
         if self.time == 0:
             self.baseline_money_supply = self._calculate_total_money()
             self.logger.info(
                 f"MONEY_SUPPLY_BASELINE | Baseline Money Supply set to: {self.baseline_money_supply:.2f}",
-                extra={"tick": self.time, "money_supply": self.baseline_money_supply}
+                extra={"tick": self.time, "money_supply": self.baseline_money_supply},
             )
 
         self.time += 1
@@ -359,9 +379,9 @@ class Simulation:
         if self.time == 200:
             self.logger.warning("ğŸ”¥ CHAOS: Inflation Shock at Tick 200!")
             for market_name, market in self.markets.items():
-                if hasattr(market, 'current_price'):
+                if hasattr(market, "current_price"):
                     market.current_price *= 1.5
-                if hasattr(market, 'avg_price'):
+                if hasattr(market, "avg_price"):
                     market.avg_price *= 1.5
 
         if self.time == 600:
@@ -372,7 +392,9 @@ class Simulation:
                 # If further impact is needed, household.monthly_income could also be reduced by 50%.
 
         # WO-054: Government Public Education Logic (START OF TICK)
-        self.government.run_public_education(self.households, self.config_module, self.time, self.reflux_system)
+        self.government.run_public_education(
+            self.households, self.config_module, self.time, self.reflux_system
+        )
 
         if (
             self.time > 0
@@ -383,19 +405,24 @@ class Simulation:
         # Update Bank Tick (Interest Processing)
         # Phase 4: Pass current_tick to bank for credit jail logic
         # Phase 8-B: Pass reflux_system to capture bank profits
-        if hasattr(self.bank, "run_tick") and "reflux_system" in self.bank.run_tick.__code__.co_varnames:
-             self.bank.run_tick(self.agents, self.time, reflux_system=self.reflux_system)
-        elif hasattr(self.bank, "run_tick") and "current_tick" in self.bank.run_tick.__code__.co_varnames:
-             self.bank.run_tick(self.agents, self.time)
+        if (
+            hasattr(self.bank, "run_tick")
+            and "reflux_system" in self.bank.run_tick.__code__.co_varnames
+        ):
+            self.bank.run_tick(self.agents, self.time, reflux_system=self.reflux_system)
+        elif (
+            hasattr(self.bank, "run_tick")
+            and "current_tick" in self.bank.run_tick.__code__.co_varnames
+        ):
+            self.bank.run_tick(self.agents, self.time)
         else:
-             self.bank.run_tick(self.agents)
-
+            self.bank.run_tick(self.agents)
 
         # Legacy call removed: self.government.update_monetary_policy(...)
 
         # Phase 14-1: Firm Profit Distribution (Operation Reflux)
         for firm in self.firms:
-             firm.distribute_profit(self.agents, self.time)
+            firm.distribute_profit(self.agents, self.time)
 
         for firm in self.firms:
             firm.hires_last_tick = 0
@@ -406,7 +433,13 @@ class Simulation:
 
         # WO-057-Fix: Update tracker with the latest data before government decisions
         money_supply = self._calculate_total_money()
-        self.tracker.track(self.time, self.households, self.firms, self.markets, money_supply=money_supply)
+        self.tracker.track(
+            self.time,
+            self.households,
+            self.firms,
+            self.markets,
+            money_supply=money_supply,
+        )
 
         # [WO-060] Update stock market reference prices at the start of the tick
         if self.stock_market is not None:
@@ -418,7 +451,7 @@ class Simulation:
             self._update_social_ranks()
 
         market_data = self._prepare_market_data(self.tracker)
-        
+
         # Inject Reference Standard
         if getattr(self.config_module, "ENABLE_VANITY_SYSTEM", False):
             ref_std = self._calculate_reference_standard()
@@ -440,7 +473,9 @@ class Simulation:
         # Inflation (Price Change)
         current_price = latest_indicators.get("avg_goods_price", 10.0)
         last_price = self.last_avg_price_for_sma
-        inflation_rate = (current_price - last_price) / last_price if last_price > 0 else 0.0
+        inflation_rate = (
+            (current_price - last_price) / last_price if last_price > 0 else 0.0
+        )
         self.last_avg_price_for_sma = current_price
 
         # Unemployment
@@ -476,7 +511,7 @@ class Simulation:
             gdp_growth_sma=calculate_sma(self.gdp_growth_buffer),
             wage_sma=calculate_sma(self.wage_buffer),
             approval_sma=calculate_sma(self.approval_buffer),
-            current_gdp=current_gdp
+            current_gdp=current_gdp,
         )
 
         # Supply to Government
@@ -485,7 +520,7 @@ class Simulation:
             self.government.update_sensory_data(injectable_sensory_dto)
             self.logger.warning(
                 f"INJECTED_SENSORY_DATA | Overrode sensory data for tick {self.time} with custom DTO.",
-                extra={"tick": self.time, "tags": ["test_injection"]}
+                extra={"tick": self.time, "tags": ["test_injection"]},
             )
         else:
             self.government.update_sensory_data(sensory_dto)
@@ -496,19 +531,29 @@ class Simulation:
             interest_rate_trend = self.bank.base_rate - self.last_interest_rate
             self.last_interest_rate = self.bank.base_rate
 
-            market_volatility = self.stock_tracker.get_market_volatility() if self.stock_tracker else 0.0
+            market_volatility = (
+                self.stock_tracker.get_market_volatility()
+                if self.stock_tracker
+                else 0.0
+            )
 
             macro_financial_context = MacroFinancialContext(
                 inflation_rate=sensory_dto.inflation_sma,
                 gdp_growth_rate=sensory_dto.gdp_growth_sma,
                 market_volatility=market_volatility,
-                interest_rate_trend=interest_rate_trend
+                interest_rate_trend=interest_rate_trend,
             )
 
         # [DEBUG WO-057]
-        self.logger.info(f"DEBUG_WO057 | Tick {self.time} | Indicators: {list(latest_indicators.keys())}")
-        self.logger.info(f"DEBUG_WO057 | AvgPrice: {latest_indicators.get('avg_goods_price', 'MISSING')}")
-        self.logger.info(f"DEBUG_WO057 | SensoryDTO: InfSMA={sensory_dto.inflation_sma:.4f}, UnempSMA={sensory_dto.unemployment_sma:.4f}, DebtRat={sensory_dto.current_gdp:.4f}")
+        self.logger.info(
+            f"DEBUG_WO057 | Tick {self.time} | Indicators: {list(latest_indicators.keys())}"
+        )
+        self.logger.info(
+            f"DEBUG_WO057 | AvgPrice: {latest_indicators.get('avg_goods_price', 'MISSING')}"
+        )
+        self.logger.info(
+            f"DEBUG_WO057 | SensoryDTO: InfSMA={sensory_dto.inflation_sma:.4f}, UnempSMA={sensory_dto.unemployment_sma:.4f}, DebtRat={sensory_dto.current_gdp:.4f}"
+        )
         # -----------------------------------------
 
         # 3. Government Makes Policy Decision
@@ -535,13 +580,17 @@ class Simulation:
         self.finance_system.service_debt(self.time)
 
         # Phase 4: Welfare Check (Executes Subsidies based on Policy)
-        self.government.run_welfare_check(list(self.agents.values()), market_data, self.time)
+        self.government.run_welfare_check(
+            list(self.agents.values()), market_data, self.time
+        )
 
         # Snapshot agents for learning (Pre-state)
         for f in self.firms:
-            if f.is_active: f.pre_state_snapshot = f.get_agent_data()
+            if f.is_active:
+                f.pre_state_snapshot = f.get_agent_data()
         for h in self.households:
-            if h.is_active: h.pre_state_snapshot = h.get_agent_data()
+            if h.is_active:
+                h.pre_state_snapshot = h.get_agent_data()
 
         all_transactions: List[Transaction] = []
 
@@ -549,16 +598,21 @@ class Simulation:
         for firm in self.firms:
             if firm.is_active:
                 # Guard for AI-driven engines (RuleBased engines don't have ai_engine)
-                if hasattr(firm.decision_engine, 'ai_engine') and firm.decision_engine.ai_engine:
+                if (
+                    hasattr(firm.decision_engine, "ai_engine")
+                    and firm.decision_engine.ai_engine
+                ):
                     pre_strategic_state = (
                         firm.decision_engine.ai_engine._get_strategic_state(
                             firm.get_agent_data(), market_data
                         )
                     )
-                    pre_tactical_state = firm.decision_engine.ai_engine._get_tactical_state(
-                        firm.decision_engine.ai_engine.chosen_intention,
-                        firm.get_agent_data(),
-                        market_data,
+                    pre_tactical_state = (
+                        firm.decision_engine.ai_engine._get_tactical_state(
+                            firm.decision_engine.ai_engine.chosen_intention,
+                            firm.get_agent_data(),
+                            market_data,
+                        )
                     )
                     firm_pre_states[firm.id] = {
                         "pre_strategic_state": pre_strategic_state,
@@ -568,42 +622,59 @@ class Simulation:
                     }
 
                 # Phase 8-B: Pass reflux_system to firm.make_decision for CAPEX capture
-                firm_orders, action_vector = firm.make_decision(self.markets, self.goods_data, market_data, self.time, self.government, self.reflux_system)
+                firm_orders, action_vector = firm.make_decision(
+                    self.markets,
+                    self.goods_data,
+                    market_data,
+                    self.time,
+                    self.government,
+                    self.reflux_system,
+                )
                 for order in firm_orders:
                     target_market = self.markets.get(order.market_id)
                     if target_market:
                         target_market.place_order(order, self.time)
-                
-                self.logger.debug(f"TRACE_ENGINE | Firm {firm.id} submitted {len(firm_orders)} orders to markets.")
+
+                self.logger.debug(
+                    f"TRACE_ENGINE | Firm {firm.id} submitted {len(firm_orders)} orders to markets."
+                )
 
         household_pre_states = {}
         household_time_allocation = {}  # Store time allocation for later use
         for household in self.households:
             if household.is_active:
                 # Guard for AI-driven engines (RuleBased engines don't have ai_engine)
-                if hasattr(household.decision_engine, 'ai_engine') and household.decision_engine.ai_engine:
+                if (
+                    hasattr(household.decision_engine, "ai_engine")
+                    and household.decision_engine.ai_engine
+                ):
                     pre_strategic_state = (
                         household.decision_engine.ai_engine._get_strategic_state(
                             household.get_agent_data(), market_data
                         )
                     )
                     household_pre_states[household.id] = {
-                        "pre_strategic_state": pre_strategic_state, # Legacy support
+                        "pre_strategic_state": pre_strategic_state,  # Legacy support
                     }
 
                 # make_decision return (orders, vector)
                 household_orders, action_vector = household.make_decision(
-                    self.markets, self.goods_data, market_data, self.time, self.government, macro_financial_context
+                    self.markets,
+                    self.goods_data,
+                    market_data,
+                    self.time,
+                    self.government,
+                    macro_financial_context,
                 )
 
                 # Phase 5: Calculate Time Allocation (Hydraulic Model)
                 # work_hours = work_agg * MAX_WORK_HOURS
                 # leisure_hours = 24 - work_hours - SHOPPING_HOURS
                 # Guard: RuleBased engines return tuple, not ActionVector DTO
-                if hasattr(action_vector, 'work_aggressiveness'):
+                if hasattr(action_vector, "work_aggressiveness"):
                     work_aggressiveness = action_vector.work_aggressiveness
                 else:
-                    work_aggressiveness = 0.5 # Default for RuleBased
+                    work_aggressiveness = 0.5  # Default for RuleBased
                 max_work_hours = self.config_module.MAX_WORK_HOURS
                 shopping_hours = getattr(self.config_module, "SHOPPING_HOURS", 2.0)
                 hours_per_tick = getattr(self.config_module, "HOURS_PER_TICK", 24.0)
@@ -617,7 +688,9 @@ class Simulation:
                 for order in household_orders:
                     # [Phase 23.5 Fix] Handle INVEST orders for startup creation (Active Entrepreneurship)
                     if order.order_type == "INVEST" and order.market_id == "admin":
-                        self.logger.info(f"FOUND_INVEST_ORDER | Agent {household.id} attempting startup via admin market.")
+                        self.logger.info(
+                            f"FOUND_INVEST_ORDER | Agent {household.id} attempting startup via admin market."
+                        )
                         self.firm_system.spawn_firm(self, household)
                         continue
 
@@ -625,9 +698,14 @@ class Simulation:
                     target_market_id = order.market_id
 
                     # Routing Logic for Deposit/Withdraw/Loan
-                    if order.order_type in ["DEPOSIT", "WITHDRAW", "LOAN_REQUEST", "REPAYMENT"]:
+                    if order.order_type in [
+                        "DEPOSIT",
+                        "WITHDRAW",
+                        "LOAN_REQUEST",
+                        "REPAYMENT",
+                    ]:
                         target_market_id = "loan_market"
-                    elif order.item_id in ["deposit", "currency"]: # Fallback
+                    elif order.item_id in ["deposit", "currency"]:  # Fallback
                         target_market_id = "loan_market"
 
                     household_target_market = self.markets.get(target_market_id)
@@ -640,7 +718,9 @@ class Simulation:
                             extra={"tick": self.time},
                         )
 
-                self.logger.debug(f"TRACE_ENGINE | Household {household.id} submitted {len(household_orders)} orders back to engine.")
+                self.logger.debug(
+                    f"TRACE_ENGINE | Household {household.id} submitted {len(household_orders)} orders back to engine."
+                )
 
         for market in self.markets.values():
             if isinstance(market, OrderBookMarket):
@@ -663,15 +743,15 @@ class Simulation:
         # ---------------------------------------------------------
         # After transactions, households have goods in inventory.
         # Now they must consume them to satisfy needs.
-        household_leisure_effects = {} # Store utility for AI reward injection
+        household_leisure_effects = {}  # Store utility for AI reward injection
 
         # Recalculate vacancy count for correct death classification
         current_vacancies = 0
         labor_market = self.markets.get("labor")
         if labor_market and isinstance(labor_market, OrderBookMarket):
-             for item_orders in labor_market.buy_orders.values():
-                 for order in item_orders:
-                     current_vacancies += order.quantity
+            for item_orders in labor_market.buy_orders.values():
+                for order in item_orders:
+                    current_vacancies += order.quantity
 
         # Create a consumption-specific market data context
         consumption_market_data = market_data.copy()
@@ -679,71 +759,93 @@ class Simulation:
 
         # WO-051: Vectorized Consumption Logic
         # Pre-calculate consumption/purchase decisions for all households
-        batch_decisions = self.breeding_planner.decide_consumption_batch(self.households, consumption_market_data)
-        consume_list = batch_decisions.get('consume', [0] * len(self.households))
-        buy_list = batch_decisions.get('buy', [0] * len(self.households))
-        food_price = batch_decisions.get('price', 5.0)  # Default food price
+        batch_decisions = self.breeding_planner.decide_consumption_batch(
+            self.households, consumption_market_data
+        )
+        consume_list = batch_decisions.get("consume", [0] * len(self.households))
+        buy_list = batch_decisions.get("buy", [0] * len(self.households))
+        food_price = batch_decisions.get("price", 5.0)  # Default food price
 
         for i, household in enumerate(self.households):
-             if household.is_active:
-
-                 # 1. Consumption (Vectorized Optimization)
-                 # Replace decide_and_consume with vectorized result application
-                 consumed_items = {}
-
-                 # 1a. Fast Consumption (Basic Food)
-                 if i < len(consume_list):
-                     c_amt = consume_list[i]
-                     if c_amt > 0:
-                         household.consume("basic_food", c_amt, self.time)
-                         consumed_items["basic_food"] = c_amt
-
-                 # 1b. Fast Purchase (Survival Rescue - Logic Map Item 3)
-                 if i < len(buy_list):
-                     b_amt = buy_list[i]
-                     if b_amt > 0:
-                         cost = b_amt * food_price
-                         if household.assets >= cost:
-                             household.assets -= cost
-                             household.inventory["basic_food"] = household.inventory.get("basic_food", 0) + b_amt
-                             # To prevent money destruction, we route this to Reflux System (Sink)
-                             self.reflux_system.capture(cost, source=f"Household_{household.id}", category="emergency_food")
-                             self.logger.debug(
-                                 f"VECTOR_BUY | Household {household.id} bought {b_amt:.1f} food (Fast Track)",
-                                 extra={"agent_id": household.id, "tags": ["consumption", "vector_buy"]}
-                             )
-                             # Consume immediately if they were starving and bought it?
-                             # The planner separates buy/consume. If they bought, they might consume next tick
-                             # or we can force consume now if consumption was 0?
-                             # Vector planner logic for consumption relies on Inventory > 0.
-                             # If inventory was 0, c_amt is 0.
-                             # If we buy now, we should probably allow immediate consumption.
-                             if c_amt == 0:
-                                 consume_now = min(b_amt, getattr(self.config_module, "FOOD_CONSUMPTION_QUANTITY", 1.0))
-                                 household.consume("basic_food", consume_now, self.time)
-                                 consumed_items["basic_food"] = consume_now
-
-                 # 2. Phase 5: Leisure Effect Application
-                 leisure_hours = household_time_allocation.get(household.id, 0.0)
-                 effect_dto = household.apply_leisure_effect(leisure_hours, consumed_items)
-                 
-                 # 3. Lifecycle Update [BUGFIX: WO-Diag-003]
-                 household.update_needs(self.time, consumption_market_data)
-
-                 # Store utility for reward injection
-                 household_leisure_effects[household.id] = effect_dto.utility_gained
-
-                 # Apply XP to Children (if Parenting)
-                 if effect_dto.leisure_type == "PARENTING" and effect_dto.xp_gained > 0:
-                     for child_id in household.children_ids:
-                         # Children might be in self.agents
-                         child = self.agents.get(child_id)
-                         if child and isinstance(child, Household) and child.is_active:
-                             child.education_xp += effect_dto.xp_gained
-                             self.logger.debug(
-                                 f"PARENTING_XP_TRANSFER | Parent {household.id} -> Child {child_id}. XP: {effect_dto.xp_gained:.4f}",
-                                 extra={"agent_id": household.id, "tags": ["LEISURE_EFFECT", "parenting"]}
-                             )
+            if household.is_active:
+                # 1. Consumption (Vectorized Optimization)
+                # Replace decide_and_consume with vectorized result application
+                consumed_items = {}
+
+                # 1a. Fast Consumption (Basic Food)
+                if i < len(consume_list):
+                    c_amt = consume_list[i]
+                    if c_amt > 0:
+                        household.consume("basic_food", c_amt, self.time)
+                        consumed_items["basic_food"] = c_amt
+
+                # 1b. Fast Purchase (Survival Rescue - Logic Map Item 3)
+                if i < len(buy_list):
+                    b_amt = buy_list[i]
+                    if b_amt > 0:
+                        cost = b_amt * food_price
+                        if household.assets >= cost:
+                            household.assets -= cost
+                            household.inventory["basic_food"] = (
+                                household.inventory.get("basic_food", 0) + b_amt
+                            )
+                            # To prevent money destruction, we route this to Reflux System (Sink)
+                            self.reflux_system.capture(
+                                cost,
+                                source=f"Household_{household.id}",
+                                category="emergency_food",
+                            )
+                            self.logger.debug(
+                                f"VECTOR_BUY | Household {household.id} bought {b_amt:.1f} food (Fast Track)",
+                                extra={
+                                    "agent_id": household.id,
+                                    "tags": ["consumption", "vector_buy"],
+                                },
+                            )
+                            # Consume immediately if they were starving and bought it?
+                            # The planner separates buy/consume. If they bought, they might consume next tick
+                            # or we can force consume now if consumption was 0?
+                            # Vector planner logic for consumption relies on Inventory > 0.
+                            # If inventory was 0, c_amt is 0.
+                            # If we buy now, we should probably allow immediate consumption.
+                            if c_amt == 0:
+                                consume_now = min(
+                                    b_amt,
+                                    getattr(
+                                        self.config_module,
+                                        "FOOD_CONSUMPTION_QUANTITY",
+                                        1.0,
+                                    ),
+                                )
+                                household.consume("basic_food", consume_now, self.time)
+                                consumed_items["basic_food"] = consume_now
+
+                # 2. Phase 5: Leisure Effect Application
+                leisure_hours = household_time_allocation.get(household.id, 0.0)
+                effect_dto = household.apply_leisure_effect(
+                    leisure_hours, consumed_items
+                )
+
+                # 3. Lifecycle Update [BUGFIX: WO-Diag-003]
+                household.update_needs(self.time, consumption_market_data)
+
+                # Store utility for reward injection
+                household_leisure_effects[household.id] = effect_dto.utility_gained
+
+                # Apply XP to Children (if Parenting)
+                if effect_dto.leisure_type == "PARENTING" and effect_dto.xp_gained > 0:
+                    for child_id in household.children_ids:
+                        # Children might be in self.agents
+                        child = self.agents.get(child_id)
+                        if child and isinstance(child, Household) and child.is_active:
+                            child.education_xp += effect_dto.xp_gained
+                            self.logger.debug(
+                                f"PARENTING_XP_TRANSFER | Parent {household.id} -> Child {child_id}. XP: {effect_dto.xp_gained:.4f}",
+                                extra={
+                                    "agent_id": household.id,
+                                    "tags": ["LEISURE_EFFECT", "parenting"],
+                                },
+                            )
 
         # --- Phase 23: Technology Manager Update ---
         self.technology_manager.update(self.time, self)
@@ -754,8 +856,8 @@ class Simulation:
 
         # Phase 17-3B: Housing Market Matching
         if "housing" in self.markets:
-             housing_transactions = self.markets["housing"].match_orders(self.time)
-             all_transactions.extend(housing_transactions)
+            housing_transactions = self.markets["housing"].match_orders(self.time)
+            all_transactions.extend(housing_transactions)
 
         # --- Phase 19: Population Dynamics ---
         # 1. Aging
@@ -811,19 +913,25 @@ class Simulation:
         # Activate Farm Logic (Production & Needs/Wages)
         # ---------------------------------------------------------
         for firm in self.firms:
-             if firm.is_active:
-                 # Phase 23: Pass Technology Manager for Productivity
-                 firm.produce(self.time, technology_manager=self.technology_manager)
-                 # Phase 4: Pass government and market_data for income tax withholding
-                 # Phase 8-B: Pass reflux_system for expense capture
-                 firm.update_needs(self.time, self.government, market_data, self.reflux_system)
-                 
-                 # 2a. ë²•ì¸ì„¸(Corporate Tax) ì§•ìˆ˜ (ì´ìµì´ ë°œìƒí•œ ê²½ìš°)
-                 # [LEVIATHAN UPDATE] use government.calculate_corporate_tax
-                 if firm.is_active and firm.current_profit > 0:
-                     tax_amount = self.government.calculate_corporate_tax(firm.current_profit)
-                     firm.assets -= tax_amount
-                     self.government.collect_tax(tax_amount, "corporate_tax", firm.id, self.time)
+            if firm.is_active:
+                # Phase 23: Pass Technology Manager for Productivity
+                firm.produce(self.time, technology_manager=self.technology_manager)
+                # Phase 4: Pass government and market_data for income tax withholding
+                # Phase 8-B: Pass reflux_system for expense capture
+                firm.update_needs(
+                    self.time, self.government, market_data, self.reflux_system
+                )
+
+                # 2a. ë²•ì¸ì„¸(Corporate Tax) ì§•ìˆ˜ (ì´ìµì´ ë°œìƒí•œ ê²½ìš°)
+                # [LEVIATHAN UPDATE] use government.calculate_corporate_tax
+                if firm.is_active and firm.current_profit > 0:
+                    tax_amount = self.government.calculate_corporate_tax(
+                        firm.current_profit
+                    )
+                    firm.assets -= tax_amount
+                    self.government.collect_tax(
+                        tax_amount, "corporate_tax", firm.id, self.time
+                    )
 
         # 2b. ì •ë¶€ ì¸í”„ë¼ íˆ¬ì (ì˜ˆì‚° ì¶©ì¡± ì‹œ)
         # Phase 8-B: Pass reflux_system to capture infrastructure spending
@@ -831,39 +939,36 @@ class Simulation:
             # ì¸í”„ë¼ íˆ¬ì ì„±ê³µ ì‹œ ëª¨ë“  ê¸°ì—…ì˜ TFP ìƒí–¥ ì¡°ì •
             tfp_boost = getattr(self.config_module, "INFRASTRUCTURE_TFP_BOOST", 0.05)
             for firm in self.firms:
-                firm.productivity_factor *= (1.0 + tfp_boost)
+                firm.productivity_factor *= 1.0 + tfp_boost
             self.logger.info(
-                f"GLOBAL_TFP_BOOST | All firms productivity increased by {tfp_boost*100:.1f}%",
-                extra={"tick": self.time, "tags": ["government", "infrastructure"]}
+                f"GLOBAL_TFP_BOOST | All firms productivity increased by {tfp_boost * 100:.1f}%",
+                extra={"tick": self.time, "tags": ["government", "infrastructure"]},
             )
 
-
         for firm in self.firms:
             if firm.is_active and firm.id in firm_pre_states:
                 post_state_data = firm.get_agent_data()
                 agent_data = firm.get_agent_data()
                 market_data = self._prepare_market_data(self.tracker)
-                
+
                 # Calculate Reward using new method for Firms (Brand Valuation)
                 reward = firm.decision_engine.ai_engine.calculate_reward(
                     firm, firm.get_pre_state_data(), agent_data
                 )
-                
+
                 # Update Learning V2
                 firm.decision_engine.ai_engine.update_learning_v2(
                     reward=reward,
                     next_agent_data=agent_data,
                     next_market_data=market_data,
                 )
-                
+
                 decision_data = AIDecisionData(
                     run_id=self.run_id,
                     tick=self.time,
                     agent_id=firm.id,
                     decision_type="VECTOR_V2",
-                    decision_details={
-                       "reward": reward
-                    },
+                    decision_details={"reward": reward},
                     predicted_reward=None,
                     actual_reward=reward,
                 )
@@ -884,7 +989,7 @@ class Simulation:
                 post_state_data = household.get_agent_data()
                 agent_data = household.get_agent_data()
                 market_data = self._prepare_market_data(self.tracker)
-                
+
                 # Inject Phase 5 Leisure Utility into agent_data for Reward Calculation
                 leisure_utility = household_leisure_effects.get(household.id, 0.0)
                 agent_data["leisure_utility"] = leisure_utility
@@ -896,7 +1001,7 @@ class Simulation:
                     agent_data,
                     market_data,
                 )
-                
+
                 # Update Learning V2
                 household.decision_engine.ai_engine.update_learning_v2(
                     reward=reward,
@@ -909,9 +1014,7 @@ class Simulation:
                     tick=self.time,
                     agent_id=household.id,
                     decision_type="VECTOR_V2",
-                    decision_details={
-                        "reward": reward
-                    },
+                    decision_details={"reward": reward},
                     predicted_reward=None,
                     actual_reward=reward,
                 )
@@ -934,9 +1037,11 @@ class Simulation:
         # They remain in self.agents for ID reference, but won't act in future ticks
         active_firms_count_before = len(self.firms)
         self.firms = [f for f in self.firms if f.is_active]
-        
+
         if len(self.firms) < active_firms_count_before:
-            self.logger.info(f"CLEANUP | Removed {active_firms_count_before - len(self.firms)} inactive firms from execution list.")
+            self.logger.info(
+                f"CLEANUP | Removed {active_firms_count_before - len(self.firms)} inactive firms from execution list."
+            )
 
         # --- Handle Agent Lifecycle (Death, Liquidation) ---
         # Added as per requirement (previously missing in run_tick)
@@ -979,8 +1084,8 @@ class Simulation:
             f.last_sales_volume = f.sales_volume_this_tick
             # Reset current counters
             f.sales_volume_this_tick = 0.0
-            f.expenses_this_tick = 0.0 # Reset expenses as well
-            f.revenue_this_tick = 0.0 # Reset revenue
+            f.expenses_this_tick = 0.0  # Reset expenses as well
+            f.revenue_this_tick = 0.0  # Reset revenue
 
         # --- Gold Standard / Money Supply Verification (WO-016) ---
         if self.time >= 1:
@@ -996,16 +1101,22 @@ class Simulation:
 
             # Log Level: Info normally, Warning if delta is significant (> 1.0)
             msg = f"MONEY_SUPPLY_CHECK | Current: {current_money:.2f}, Expected: {expected_money:.2f}, Delta: {delta:.4f}"
-            extra_data = {"tick": self.time, "current": current_money, "expected": expected_money, "delta": delta, "tags": ["money_supply"]}
+            extra_data = {
+                "tick": self.time,
+                "current": current_money,
+                "expected": expected_money,
+                "delta": delta,
+                "tags": ["money_supply"],
+            }
 
             if abs(delta) > 1.0:
-                 self.logger.warning(msg, extra=extra_data)
+                self.logger.warning(msg, extra=extra_data)
             else:
-                 self.logger.info(msg, extra=extra_data)
+                self.logger.info(msg, extra=extra_data)
 
         # WO-058: Generational Wealth Audit
         if self.time % 100 == 0:
-             self.generational_wealth_audit.run_audit(self.households, self.time)
+            self.generational_wealth_audit.run_audit(self.households, self.time)
 
         self.logger.info(
             f"--- Ending Tick {self.time} ---",
@@ -1018,8 +1129,9 @@ class Simulation:
 
         # Track stock market
         if self.stock_market is not None:
-            self.stock_tracker.track_all_firms([f for f in self.firms if f.is_active], self.stock_market)
-
+            self.stock_tracker.track_all_firms(
+                [f for f in self.firms if f.is_active], self.stock_market
+            )
 
     def _prepare_market_data(self, tracker: EconomicIndicatorTracker) -> Dict[str, Any]:
         """í˜„ì¬ í‹±ì˜ ì‹œì¥ ë°ì´í„°ë¥¼ ì—ì´ì „íŠ¸ì˜ ì˜ì‚¬ê²°ì •ì„ ìœ„í•´ ì¤€ë¹„í•©ë‹ˆë‹¤."""
@@ -1031,7 +1143,9 @@ class Simulation:
         debt_data_map = {}
         deposit_data_map = {}
         for agent_id in self.agents:
-            if isinstance(self.agents[agent_id], Household) or isinstance(self.agents[agent_id], Firm):
+            if isinstance(self.agents[agent_id], Household) or isinstance(
+                self.agents[agent_id], Firm
+            ):
                 debt_data_map[agent_id] = self.bank.get_debt_summary(agent_id)
                 deposit_data_map[agent_id] = self.bank.get_deposit_balance(agent_id)
 
@@ -1040,27 +1154,31 @@ class Simulation:
             if market and isinstance(market, OrderBookMarket):
                 # 1. ì´ë²ˆ í‹±ì˜ í‰ê·  ì²´ê²°ê°€ (ê±°ë˜ê°€ ìˆì—ˆë‹¤ë©´ ê°€ì¥ ì •í™•)
                 avg_price = market.get_daily_avg_price()
-                
+
                 # 2. ê±°ë˜ê°€ ì—†ì—ˆë‹¤ë©´ í˜¸ê°€ì°½ì˜ ìµœì € ë§¤ë„ê°€(Best Ask)
                 if avg_price <= 0:
                     avg_price = market.get_best_ask(good_name) or 0
-                
+
                 # 3. í˜¸ê°€ë„ ì—†ë‹¤ë©´ ì´ì „ í‹±ì˜ ê¸°ë¡ëœ ê°€ê²© (Tracker)
                 if avg_price <= 0:
                     latest = tracker.get_latest_indicators()
                     # Tracker í•„ë“œëª…ì€ {item_id}_avg_price í˜•ì‹ì„ ë”°ë¦„ (EconomicIndicatorTracker ì°¸ê³ )
                     avg_price = latest.get(f"{good_name}_avg_price", 0)
-                
+
                 # 4. ëª¨ë‘ ì—†ë‹¤ë©´ ì„¤ì • íŒŒì¼ì˜ ì´ˆê¸° ê°€ê²©
                 if avg_price <= 0:
-                    avg_price = self.config_module.GOODS[good_name].get("initial_price", 10.0)
-                
+                    avg_price = self.config_module.GOODS[good_name].get(
+                        "initial_price", 10.0
+                    )
+
                 goods_market_data[f"{good_name}_current_sell_price"] = avg_price
 
         # Include Labor Market Data (Use historical data as the order book is cleared)
         latest_indicators = tracker.get_latest_indicators()
-        avg_wage = latest_indicators.get("labor_avg_price", self.config_module.LABOR_MARKET_MIN_WAGE)
-        
+        avg_wage = latest_indicators.get(
+            "labor_avg_price", self.config_module.LABOR_MARKET_MIN_WAGE
+        )
+
         labor_market = self.markets.get("labor")
         best_wage_offer = 0.0
         if labor_market and isinstance(labor_market, OrderBookMarket):
@@ -1074,15 +1192,15 @@ class Simulation:
         # Sum of quantities of all buy orders in the labor market
         job_vacancies = 0
         if labor_market and isinstance(labor_market, OrderBookMarket):
-             # buy_orders is Dict[item_id, List[Order]]
-             # In labor market, item_id is usually "labor" or "research_labor"
-             for item_orders in labor_market.buy_orders.values():
-                 for order in item_orders:
-                     job_vacancies += order.quantity
+            # buy_orders is Dict[item_id, List[Order]]
+            # In labor market, item_id is usually "labor" or "research_labor"
+            for item_orders in labor_market.buy_orders.values():
+                for order in item_orders:
+                    job_vacancies += order.quantity
 
         goods_market_data["labor"] = {
             "avg_wage": avg_wage,
-            "best_wage_offer": best_wage_offer
+            "best_wage_offer": best_wage_offer,
         }
         goods_market_data["job_vacancies"] = job_vacancies
 
@@ -1107,28 +1225,36 @@ class Simulation:
                     price = self.stock_market.get_best_ask(firm.id) or 0
                 if price <= 0:
                     # ì¥ê¸° ê¸°ë¡ì´ë‚˜ ì¥ë¶€ê°€ë¥¼ fallbackìœ¼ë¡œ ì‚¬ìš© ê°€ëŠ¥
-                    price = firm.assets / firm.total_shares if firm.total_shares > 0 else 10.0
+                    price = (
+                        firm.assets / firm.total_shares
+                        if firm.total_shares > 0
+                        else 10.0
+                    )
                 stock_market_data[firm_item_id] = {"avg_price": price}
 
         # Calculate Avg Rent Price (Phase 20-3)
-        rent_prices = [u.rent_price for u in self.real_estate_units if u.owner_id is not None]
-        avg_rent = sum(rent_prices) / len(rent_prices) if rent_prices else self.config_module.INITIAL_RENT_PRICE
+        rent_prices = [
+            u.rent_price for u in self.real_estate_units if u.owner_id is not None
+        ]
+        avg_rent = (
+            sum(rent_prices) / len(rent_prices)
+            if rent_prices
+            else self.config_module.INITIAL_RENT_PRICE
+        )
 
         # Inject Housing Market Data
-        housing_market_data = {
-            "avg_rent_price": avg_rent
-        }
+        housing_market_data = {"avg_rent_price": avg_rent}
 
         return {
             "time": self.time,
             "goods_market": goods_market_data,
-            "housing_market": housing_market_data, # Phase 20-3
-            "loan_market": {"interest_rate": self.bank.base_rate}, # Use bank base rate
+            "housing_market": housing_market_data,  # Phase 20-3
+            "loan_market": {"interest_rate": self.bank.base_rate},  # Use bank base rate
             "stock_market": stock_market_data,
             "all_households": self.households,
             "avg_goods_price": avg_goods_price_for_market_data,
-            "debt_data": debt_data_map, # Injected Debt Data
-            "deposit_data": deposit_data_map, # Injected Deposit Data
+            "debt_data": debt_data_map,  # Injected Debt Data
+            "deposit_data": deposit_data_map,  # Injected Deposit Data
         }
 
     def _calculate_total_money(self) -> float:
@@ -1158,7 +1284,6 @@ class Simulation:
 
         return total
 
-
     def get_all_agents(self) -> List[Any]:
         """ì‹œë®¬ë ˆì´ì…˜ì— ì°¸ì—¬í•˜ëŠ” ëª¨ë“  í™œì„± ì—ì´ì „íŠ¸(ê°€ê³„, ê¸°ì—…, ì€í–‰ ë“±)ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."""
         all_agents = []
@@ -1174,13 +1299,15 @@ class Simulation:
     def _process_transactions(self, transactions: List[Transaction]) -> None:
         """ë°œìƒí•œ ê±°ë˜ë“¤ì„ ì²˜ë¦¬í•˜ì—¬ ì—ì¸¡ëœ ê°€ê³„/ê¸°ì—… ìƒíƒœ ë“±ì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤."""
         # SoC Refactor: Logic moved to TransactionProcessor
-        market_data_cb = lambda: self._prepare_market_data(self.tracker).get("goods_market", {})
+        market_data_cb = lambda: self._prepare_market_data(self.tracker).get(
+            "goods_market", {}
+        )
         self.transaction_processor.process(
             transactions=transactions,
             agents=self.agents,
             government=self.government,
             current_time=self.time,
-            market_data_callback=market_data_cb
+            market_data_callback=market_data_cb,
         )
 
     def _process_stock_transactions(self, transactions: List[Transaction]) -> None:
@@ -1214,60 +1341,69 @@ class Simulation:
                 elif hasattr(seller, "portfolio"):
                     # Secondary market trade
                     seller.portfolio.remove(firm_id, tx.quantity)
-                
+
                 # Sync Legacy Dictionaries for Seller
                 if hasattr(seller, "shares_owned"):
                     if firm_id in seller.portfolio.holdings:
-                        seller.shares_owned[firm_id] = seller.portfolio.holdings[firm_id].quantity
+                        seller.shares_owned[firm_id] = seller.portfolio.holdings[
+                            firm_id
+                        ].quantity
                     elif firm_id in seller.shares_owned:
                         del seller.shares_owned[firm_id]
 
                 # Synchronize Market Shareholder Registry (CRITICAL for Dividends)
                 if self.stock_market:
                     # Sync Buyer
-                    self.stock_market.update_shareholder(buyer.id, firm_id, buyer.portfolio.holdings[firm_id].quantity)
+                    self.stock_market.update_shareholder(
+                        buyer.id, firm_id, buyer.portfolio.holdings[firm_id].quantity
+                    )
                     # Sync Seller
-                    if hasattr(seller, "portfolio") and firm_id in seller.portfolio.holdings:
-                        self.stock_market.update_shareholder(seller.id, firm_id, seller.portfolio.holdings[firm_id].quantity)
+                    if (
+                        hasattr(seller, "portfolio")
+                        and firm_id in seller.portfolio.holdings
+                    ):
+                        self.stock_market.update_shareholder(
+                            seller.id,
+                            firm_id,
+                            seller.portfolio.holdings[firm_id].quantity,
+                        )
                     else:
                         self.stock_market.update_shareholder(seller.id, firm_id, 0.0)
 
                 self.logger.info(
                     f"STOCK_TX | Buyer: {buyer.id}, Seller: {seller.id}, Firm: {firm_id}, Qty: {tx.quantity}, Price: {tx.price}",
-                    extra={"tick": self.time, "tags": ["stock_market", "transaction"]}
+                    extra={"tick": self.time, "tags": ["stock_market", "transaction"]},
                 )
 
-
-
     def _handle_agent_lifecycle(self) -> None:
         """ë¹„í™œì„±í™”ëœ ì—ì´ì „íŠ¸ë¥¼ ì²­ì‚°í•˜ê³  ì‹œë®¬ë ˆì´ì…˜ì—ì„œ ì œê±°í•©ë‹ˆë‹¤."""
-        
+
         # 1. íŒŒì‚° ê¸°ì—… ì²­ì‚° (Firm Liquidation)
         inactive_firms = [f for f in self.firms if not f.is_active]
         for firm in inactive_firms:
             self.logger.info(
                 f"FIRM_LIQUIDATION | Starting liquidation for Firm {firm.id}. "
                 f"Assets: {firm.assets:.2f}, Inventory: {sum(firm.inventory.values()):.2f}",
-                extra={"agent_id": firm.id, "tags": ["liquidation"]}
+                extra={"agent_id": firm.id, "tags": ["liquidation"]},
             )
-            
+
             # 1a. ì§ì› í•´ê³ 
             for employee in firm.employees:
                 if employee.is_active:
                     employee.is_employed = False
                     employee.employer_id = None
             firm.employees = []
-            
+
             # 1b. ì¬ê³  ì†Œë©¸ (ì‹œì¥ì— ë§¤ë„í•˜ëŠ” ëŒ€ì‹  ê°„ë‹¨íˆ ì†Œë©¸)
             total_inventory_value = sum(
-                qty * firm.last_prices.get(item_id, 10.0) 
+                qty * firm.last_prices.get(item_id, 10.0)
                 for item_id, qty in firm.inventory.items()
             )
             firm.inventory.clear()
-            
+
             # 1c. ìë³¸ì¬ ì†Œë©¸
             firm.capital_stock = 0.0
-            
+
             # 1d. í˜„ê¸ˆì„ ì£¼ì£¼(ê°€ê³„)ì—ê²Œ ë¶„ë°°
             total_cash = firm.assets
             if total_cash > 0:
@@ -1275,20 +1411,28 @@ class Simulation:
                 if outstanding_shares > 0:
                     for household in self.households:
                         if household.is_active and firm.id in household.shares_owned:
-                            share_ratio = household.shares_owned[firm.id] / outstanding_shares
+                            share_ratio = (
+                                household.shares_owned[firm.id] / outstanding_shares
+                            )
                             distribution = total_cash * share_ratio
                             household.assets += distribution
                             self.logger.info(
                                 f"LIQUIDATION_DISTRIBUTION | Household {household.id} received "
                                 f"{distribution:.2f} from Firm {firm.id} liquidation",
-                                extra={"agent_id": household.id, "tags": ["liquidation"]}
+                                extra={
+                                    "agent_id": household.id,
+                                    "tags": ["liquidation"],
+                                },
                             )
                 else:
                     # No active shareholders: Escheat to Government (Money Destruction)
                     from simulation.agents.government import Government
+
                     if isinstance(self.government, Government):
-                        self.government.collect_tax(total_cash, "liquidation_escheatment", firm.id, self.time)
-            
+                        self.government.collect_tax(
+                            total_cash, "liquidation_escheatment", firm.id, self.time
+                        )
+
             # 1e. ì£¼ì£¼ë“¤ì˜ í•´ë‹¹ ê¸°ì—… ì£¼ì‹ ë³´ìœ ëŸ‰ ì‚­ì œ
             for household in self.households:
                 if firm.id in household.shares_owned:
@@ -1296,11 +1440,11 @@ class Simulation:
                     # [Mitosis] Update registry
                     if self.stock_market:
                         self.stock_market.update_shareholder(household.id, firm.id, 0)
-            
+
             firm.assets = 0.0
             self.logger.info(
                 f"FIRM_LIQUIDATION_COMPLETE | Firm {firm.id} fully liquidated.",
-                extra={"agent_id": firm.id, "tags": ["liquidation"]}
+                extra={"agent_id": firm.id, "tags": ["liquidation"]},
             )
 
         # 2. ì‚¬ë§ ê°€ê³„ ì²­ì‚° (Household Liquidation)
@@ -1310,7 +1454,7 @@ class Simulation:
             # Replaces Phase 19 DemographicManager logic and standard liquidation
             if hasattr(self, "inheritance_manager"):
                 self.inheritance_manager.process_death(household, self.government, self)
-            
+
             # Remaining cleanup (Inventory/Metadata)
             household.inventory.clear()
             # Shares should be cleared by InheritanceManager, but double check
@@ -1320,7 +1464,7 @@ class Simulation:
             # [Mitosis] Clear shareholder registry for this household
             if self.stock_market:
                 for firm_id in list(self.stock_market.shareholders.keys()):
-                     self.stock_market.update_shareholder(household.id, firm_id, 0)
+                    self.stock_market.update_shareholder(household.id, firm_id, 0)
 
         # 3. ì‹œë®¬ë ˆì´ì…˜ì—ì„œ ë¹„í™œì„± ì—ì´ì „íŠ¸ ì œê±°
         self.households = [h for h in self.households if h.is_active]
diff --git a/design/gemini_output/jules_finance_final.py b/design/gemini_output/jules_finance_final.py
index a747a4a..dc4178c 100644
--- a/design/gemini_output/jules_finance_final.py
+++ b/design/gemini_output/jules_finance_final.py
@@ -11,11 +11,13 @@ if TYPE_CHECKING:
 
 logger = logging.getLogger(__name__)
 
+
 class FinanceDepartment:
     """
     Manages maintenance fees, corporate taxes, dividend distribution, and tracks financial metrics.
     Extracted from Firm class (SoC Refactor).
     """
+
     def __init__(self, firm: Firm, config_module: Any):
         self.firm = firm
         self.config_module = config_module
@@ -33,7 +35,9 @@ class FinanceDepartment:
         self.expenses_this_tick: float = 0.0
 
         # History
-        self.profit_history: deque[float] = deque(maxlen=self.config_module.PROFIT_HISTORY_TICKS)
+        self.profit_history: deque[float] = deque(
+            maxlen=self.config_module.PROFIT_HISTORY_TICKS
+        )
         self.last_revenue: float = 0.0
         self.last_marketing_spend: float = 0.0
 
@@ -45,14 +49,19 @@ class FinanceDepartment:
     def record_revenue(self, amount: float):
         self.revenue_this_turn += amount
         self.revenue_this_tick += amount
-        self.current_profit += amount # Basic cash flow add
+        self.current_profit += amount  # Basic cash flow add
 
     def record_expense(self, amount: float):
         self.cost_this_turn += amount
         self.expenses_this_tick += amount
         self.current_profit -= amount
 
-    def pay_maintenance(self, government: Any, reflux_system: Optional[EconomicRefluxSystem], current_time: int):
+    def pay_maintenance(
+        self,
+        government: Any,
+        reflux_system: Optional[EconomicRefluxSystem],
+        current_time: int,
+    ):
         """Pay fixed maintenance fee."""
         fee = getattr(self.config_module, "FIRM_MAINTENANCE_FEE", 50.0)
         payment = min(self.firm.assets, fee)
@@ -60,11 +69,17 @@ class FinanceDepartment:
         if payment > 0:
             self.firm.assets -= payment
             self.record_expense(payment)
-            government.collect_tax(payment, "firm_maintenance", self.firm.id, current_time)
+            government.collect_tax(
+                payment, "firm_maintenance", self.firm.id, current_time
+            )
 
             self.firm.logger.info(
                 f"Paid maintenance fee: {payment:.2f}",
-                extra={"tick": current_time, "agent_id": self.firm.id, "tags": ["tax", "maintenance"]}
+                extra={
+                    "tick": current_time,
+                    "agent_id": self.firm.id,
+                    "tags": ["tax", "maintenance"],
+                },
             )
 
     def pay_taxes(self, government: Any, current_time: int):
@@ -79,23 +94,33 @@ class FinanceDepartment:
 
             if payment > 0:
                 self.firm.assets -= payment
-                government.collect_tax(payment, "corporate_tax", self.firm.id, current_time)
+                government.collect_tax(
+                    payment, "corporate_tax", self.firm.id, current_time
+                )
 
                 after_tax_profit = net_profit - payment
                 self.retained_earnings += after_tax_profit
 
                 self.firm.logger.info(
                     f"Paid corporate tax: {payment:.2f} on profit {net_profit:.2f}. Retained Earnings increased by {after_tax_profit:.2f}",
-                    extra={"tick": current_time, "agent_id": self.firm.id, "tags": ["tax", "corporate_tax"]}
+                    extra={
+                        "tick": current_time,
+                        "agent_id": self.firm.id,
+                        "tags": ["tax", "corporate_tax"],
+                    },
                 )
 
-    def distribute_dividends(self, households: List[Household], current_time: int) -> List[Transaction]:
+    def distribute_dividends(
+        self, households: List[Household], current_time: int
+    ) -> List[Transaction]:
         """Public Shareholders Dividend"""
-        if getattr(self.firm, 'has_bailout_loan', False) and self.current_profit > 0:
+        if getattr(self.firm, "has_bailout_loan", False) and self.current_profit > 0:
             repayment = self.current_profit * 0.5
             self.firm.total_debt -= repayment
             self.current_profit -= repayment
-            self.firm.logger.info(f"BAILOUT_REPAYMENT | Firm {self.firm.id} repaid {repayment:.2f} of its bailout loan.")
+            self.firm.logger.info(
+                f"BAILOUT_REPAYMENT | Firm {self.firm.id} repaid {repayment:.2f} of its bailout loan."
+            )
 
         transactions = []
         distributable_profit = max(0, self.current_profit * self.firm.dividend_rate)
@@ -107,7 +132,9 @@ class FinanceDepartment:
             for household in households:
                 shares = household.shares_owned.get(self.firm.id, 0.0)
                 if shares > 0:
-                    dividend_amount = distributable_profit * (shares / self.firm.total_shares)
+                    dividend_amount = distributable_profit * (
+                        shares / self.firm.total_shares
+                    )
                     transactions.append(
                         Transaction(
                             buyer_id=household.id,
@@ -123,7 +150,13 @@ class FinanceDepartment:
                     self.dividends_paid_last_tick += dividend_amount
                     self.firm.logger.info(
                         f"Firm {self.firm.id} distributed {dividend_amount:.2f} dividend to Household {household.id}.",
-                        extra={"tick": current_time, "agent_id": self.firm.id, "household_id": household.id, "amount": dividend_amount, "tags": ["dividend"]},
+                        extra={
+                            "tick": current_time,
+                            "agent_id": self.firm.id,
+                            "household_id": household.id,
+                            "amount": dividend_amount,
+                            "tags": ["dividend"],
+                        },
                     )
 
         # Reset period counters
@@ -135,7 +168,9 @@ class FinanceDepartment:
 
         return transactions
 
-    def distribute_profit_private(self, agents: Dict[int, Any], current_time: int) -> float:
+    def distribute_profit_private(
+        self, agents: Dict[int, Any], current_time: int
+    ) -> float:
         """Phase 14-1: Private Owner Dividend"""
         if self.firm.owner_id is None:
             return 0.0
@@ -164,9 +199,9 @@ class FinanceDepartment:
             self.firm.assets -= dividend_amount
             owner.assets += dividend_amount
 
-            if hasattr(owner, 'income_capital_cumulative'):
+            if hasattr(owner, "income_capital_cumulative"):
                 owner.income_capital_cumulative += dividend_amount
-            if hasattr(owner, 'capital_income_this_tick'):
+            if hasattr(owner, "capital_income_this_tick"):
                 owner.capital_income_this_tick += dividend_amount
 
             self.retained_earnings -= dividend_amount
@@ -175,7 +210,11 @@ class FinanceDepartment:
             if self.firm.logger:
                 self.firm.logger.info(
                     f"DIVIDEND | Firm {self.firm.id} -> Household {self.firm.owner_id} : ${dividend_amount:.2f}",
-                    extra={"tick": current_time, "event": "DIVIDEND", "amount": dividend_amount}
+                    extra={
+                        "tick": current_time,
+                        "event": "DIVIDEND",
+                        "amount": dividend_amount,
+                    },
                 )
             return dividend_amount
 
@@ -187,7 +226,7 @@ class FinanceDepartment:
         self.firm.assets += amount  # The loan increases cash assets
         # In a more complex model, this would be a separate liability account
         # For now, we'll just track the total debt.
-        if not hasattr(self.firm, 'total_debt'):
+        if not hasattr(self.firm, "total_debt"):
             self.firm.total_debt = 0.0
         self.firm.total_debt += amount
 
@@ -199,20 +238,26 @@ class FinanceDepartment:
         X2: Retained Earnings / Total Assets
         X3: Average Profit / Total Assets
         """
-        total_assets = self.firm.assets + self.firm.capital_stock + self.firm.get_inventory_value()
+        total_assets = (
+            self.firm.assets + self.firm.capital_stock + self.firm.get_inventory_value()
+        )
         if total_assets == 0:
             return 0.0
 
         # X1: Working Capital / Total Assets
         # Working Capital = Current Assets - Current Liabilities. Assume liabilities are total_debt for now.
-        working_capital = self.firm.assets - getattr(self.firm, 'total_debt', 0.0)
+        working_capital = self.firm.assets - getattr(self.firm, "total_debt", 0.0)
         x1 = working_capital / total_assets
 
         # X2: Retained Earnings / Total Assets
         x2 = self.retained_earnings / total_assets
 
         # X3: Average Profit / Total Assets
-        avg_profit = sum(self.profit_history) / len(self.profit_history) if self.profit_history else 0.0
+        avg_profit = (
+            sum(self.profit_history) / len(self.profit_history)
+            if self.profit_history
+            else 0.0
+        )
         x3 = avg_profit / total_assets
 
         z_score = 1.2 * x1 + 1.4 * x2 + 3.3 * x3
diff --git a/design/gemini_output/jules_finance_revised.py b/design/gemini_output/jules_finance_revised.py
index 1ae122d..897a963 100644
--- a/design/gemini_output/jules_finance_revised.py
+++ b/design/gemini_output/jules_finance_revised.py
@@ -11,11 +11,13 @@ if TYPE_CHECKING:
 
 logger = logging.getLogger(__name__)
 
+
 class FinanceDepartment:
     """
     Manages maintenance fees, corporate taxes, dividend distribution, and tracks financial metrics.
     Extracted from Firm class (SoC Refactor).
     """
+
     def __init__(self, firm: Firm, config_module: Any):
         self.firm = firm
         self.config_module = config_module
@@ -33,7 +35,9 @@ class FinanceDepartment:
         self.expenses_this_tick: float = 0.0
 
         # History
-        self.profit_history: deque[float] = deque(maxlen=self.config_module.PROFIT_HISTORY_TICKS)
+        self.profit_history: deque[float] = deque(
+            maxlen=self.config_module.PROFIT_HISTORY_TICKS
+        )
         self.last_revenue: float = 0.0
         self.last_marketing_spend: float = 0.0
 
@@ -45,14 +49,19 @@ class FinanceDepartment:
     def record_revenue(self, amount: float):
         self.revenue_this_turn += amount
         self.revenue_this_tick += amount
-        self.current_profit += amount # Basic cash flow add
+        self.current_profit += amount  # Basic cash flow add
 
     def record_expense(self, amount: float):
         self.cost_this_turn += amount
         self.expenses_this_tick += amount
         self.current_profit -= amount
 
-    def pay_maintenance(self, government: Any, reflux_system: Optional[EconomicRefluxSystem], current_time: int):
+    def pay_maintenance(
+        self,
+        government: Any,
+        reflux_system: Optional[EconomicRefluxSystem],
+        current_time: int,
+    ):
         """Pay fixed maintenance fee."""
         fee = getattr(self.config_module, "FIRM_MAINTENANCE_FEE", 50.0)
         payment = min(self.firm.assets, fee)
@@ -60,11 +69,17 @@ class FinanceDepartment:
         if payment > 0:
             self.firm.assets -= payment
             self.record_expense(payment)
-            government.collect_tax(payment, "firm_maintenance", self.firm.id, current_time)
+            government.collect_tax(
+                payment, "firm_maintenance", self.firm.id, current_time
+            )
 
             self.firm.logger.info(
                 f"Paid maintenance fee: {payment:.2f}",
-                extra={"tick": current_time, "agent_id": self.firm.id, "tags": ["tax", "maintenance"]}
+                extra={
+                    "tick": current_time,
+                    "agent_id": self.firm.id,
+                    "tags": ["tax", "maintenance"],
+                },
             )
 
     def pay_taxes(self, government: Any, current_time: int):
@@ -79,17 +94,25 @@ class FinanceDepartment:
 
             if payment > 0:
                 self.firm.assets -= payment
-                government.collect_tax(payment, "corporate_tax", self.firm.id, current_time)
+                government.collect_tax(
+                    payment, "corporate_tax", self.firm.id, current_time
+                )
 
                 after_tax_profit = net_profit - payment
                 self.retained_earnings += after_tax_profit
 
                 self.firm.logger.info(
                     f"Paid corporate tax: {payment:.2f} on profit {net_profit:.2f}. Retained Earnings increased by {after_tax_profit:.2f}",
-                    extra={"tick": current_time, "agent_id": self.firm.id, "tags": ["tax", "corporate_tax"]}
+                    extra={
+                        "tick": current_time,
+                        "agent_id": self.firm.id,
+                        "tags": ["tax", "corporate_tax"],
+                    },
                 )
 
-    def distribute_dividends(self, households: List[Household], current_time: int) -> List[Transaction]:
+    def distribute_dividends(
+        self, households: List[Household], current_time: int
+    ) -> List[Transaction]:
         """Public Shareholders Dividend"""
         transactions = []
         distributable_profit = max(0, self.current_profit * self.firm.dividend_rate)
@@ -101,7 +124,9 @@ class FinanceDepartment:
             for household in households:
                 shares = household.shares_owned.get(self.firm.id, 0.0)
                 if shares > 0:
-                    dividend_amount = distributable_profit * (shares / self.firm.total_shares)
+                    dividend_amount = distributable_profit * (
+                        shares / self.firm.total_shares
+                    )
                     transactions.append(
                         Transaction(
                             buyer_id=household.id,
@@ -117,7 +142,13 @@ class FinanceDepartment:
                     self.dividends_paid_last_tick += dividend_amount
                     self.firm.logger.info(
                         f"Firm {self.firm.id} distributed {dividend_amount:.2f} dividend to Household {household.id}.",
-                        extra={"tick": current_time, "agent_id": self.firm.id, "household_id": household.id, "amount": dividend_amount, "tags": ["dividend"]},
+                        extra={
+                            "tick": current_time,
+                            "agent_id": self.firm.id,
+                            "household_id": household.id,
+                            "amount": dividend_amount,
+                            "tags": ["dividend"],
+                        },
                     )
 
         # Reset period counters
@@ -129,7 +160,9 @@ class FinanceDepartment:
 
         return transactions
 
-    def distribute_profit_private(self, agents: Dict[int, Any], current_time: int) -> float:
+    def distribute_profit_private(
+        self, agents: Dict[int, Any], current_time: int
+    ) -> float:
         """Phase 14-1: Private Owner Dividend"""
         if self.firm.owner_id is None:
             return 0.0
@@ -158,9 +191,9 @@ class FinanceDepartment:
             self.firm.assets -= dividend_amount
             owner.assets += dividend_amount
 
-            if hasattr(owner, 'income_capital_cumulative'):
+            if hasattr(owner, "income_capital_cumulative"):
                 owner.income_capital_cumulative += dividend_amount
-            if hasattr(owner, 'capital_income_this_tick'):
+            if hasattr(owner, "capital_income_this_tick"):
                 owner.capital_income_this_tick += dividend_amount
 
             self.retained_earnings -= dividend_amount
@@ -169,7 +202,11 @@ class FinanceDepartment:
             if self.firm.logger:
                 self.firm.logger.info(
                     f"DIVIDEND | Firm {self.firm.id} -> Household {self.firm.owner_id} : ${dividend_amount:.2f}",
-                    extra={"tick": current_time, "event": "DIVIDEND", "amount": dividend_amount}
+                    extra={
+                        "tick": current_time,
+                        "event": "DIVIDEND",
+                        "amount": dividend_amount,
+                    },
                 )
             return dividend_amount
 
@@ -181,7 +218,7 @@ class FinanceDepartment:
         self.firm.assets += amount  # The loan increases cash assets
         # In a more complex model, this would be a separate liability account
         # For now, we'll just track the total debt.
-        if not hasattr(self.firm, 'total_debt'):
+        if not hasattr(self.firm, "total_debt"):
             self.firm.total_debt = 0.0
         self.firm.total_debt += amount
 
@@ -193,20 +230,26 @@ class FinanceDepartment:
         X2: Retained Earnings / Total Assets
         X3: Average Profit / Total Assets
         """
-        total_assets = self.firm.assets + self.firm.capital_stock + self.firm.get_inventory_value()
+        total_assets = (
+            self.firm.assets + self.firm.capital_stock + self.firm.get_inventory_value()
+        )
         if total_assets == 0:
             return 0.0
 
         # X1: Working Capital / Total Assets
         # Working Capital = Current Assets - Current Liabilities. Assume liabilities are total_debt for now.
-        working_capital = self.firm.assets - getattr(self.firm, 'total_debt', 0.0)
+        working_capital = self.firm.assets - getattr(self.firm, "total_debt", 0.0)
         x1 = working_capital / total_assets
 
         # X2: Retained Earnings / Total Assets
         x2 = self.retained_earnings / total_assets
 
         # X3: Average Profit / Total Assets
-        avg_profit = sum(self.profit_history) / len(self.profit_history) if self.profit_history else 0.0
+        avg_profit = (
+            sum(self.profit_history) / len(self.profit_history)
+            if self.profit_history
+            else 0.0
+        )
         x3 = avg_profit / total_assets
 
         z_score = 1.2 * x1 + 1.4 * x2 + 3.3 * x3
diff --git a/design/gemini_output/jules_firms_final.py b/design/gemini_output/jules_firms_final.py
index 14b6700..206be29 100644
--- a/design/gemini_output/jules_firms_final.py
+++ b/design/gemini_output/jules_firms_final.py
@@ -26,6 +26,7 @@ if TYPE_CHECKING:
 
 logger = logging.getLogger(__name__)
 
+
 class Firm(BaseAgent):
     """ê¸°ì—… ì£¼ì²´. ìƒì‚°ê³¼ ê³ ìš©ì˜ ì£¼ì²´."""
 
@@ -43,7 +44,7 @@ class Firm(BaseAgent):
         loan_market: Optional[LoanMarket] = None,
         logger: Optional[logging.Logger] = None,
         # Phase 14-2: Innovation
-        sector: str = "FOOD", 
+        sector: str = "FOOD",
         is_visionary: bool = False,
         # Phase 16-B: Personality
         personality: Optional[Personality] = None,
@@ -61,21 +62,23 @@ class Firm(BaseAgent):
         if initial_inventory is not None:
             self.inventory.update(initial_inventory)
         self.specialization = specialization
-        self.inventory_quality: Dict[str, float] = {}  # Phase 15: Weighted Average Quality
-        self.input_inventory: Dict[str, float] = {} # WO-030: Raw Materials
-        
+        self.inventory_quality: Dict[
+            str, float
+        ] = {}  # Phase 15: Weighted Average Quality
+        self.input_inventory: Dict[str, float] = {}  # WO-030: Raw Materials
+
         # Phase 14-2 attributes
         self.sector = sector
         self.is_visionary = is_visionary
-        self.owner_id: Optional[int] = None # Phase 14-1: Shareholder System
-        
+        self.owner_id: Optional[int] = None  # Phase 14-1: Shareholder System
+
         # Phase 16-B: Personality & Innovation Attributes
         self.personality = personality or Personality.BALANCED
         self.base_quality: float = 1.0
         self.research_history: Dict[str, Any] = {
             "total_spent": 0.0,
             "success_count": 0,
-            "last_success_tick": -1
+            "last_success_tick": -1,
         }
 
         # SoC Refactor: HR and Finance Components
@@ -83,11 +86,13 @@ class Firm(BaseAgent):
         self.finance = FinanceDepartment(self, config_module)
 
         # Set bankruptcy threshold based on visionary status
-        base_threshold = getattr(config_module, "BANKRUPTCY_CONSECUTIVE_LOSS_THRESHOLD", 5)
+        base_threshold = getattr(
+            config_module, "BANKRUPTCY_CONSECUTIVE_LOSS_THRESHOLD", 5
+        )
         if self.is_visionary:
             self.consecutive_loss_ticks_for_bankruptcy_threshold = base_threshold * 2
         else:
-             self.consecutive_loss_ticks_for_bankruptcy_threshold = base_threshold
+            self.consecutive_loss_ticks_for_bankruptcy_threshold = base_threshold
 
         self.production_target: float = (
             config_module.FIRM_MIN_PRODUCTION_TARGET
@@ -101,28 +106,30 @@ class Firm(BaseAgent):
         self.productivity_factor: float = productivity_factor
         self.total_shares: float = getattr(config_module, "IPO_INITIAL_SHARES", 1000.0)
         self.last_prices: Dict[str, float] = {}
-        self.hires_last_tick: int = 0 # Handled in HR but maybe exposed here?
-        
+        self.hires_last_tick: int = 0  # Handled in HR but maybe exposed here?
+
         # --- Phase 9: M&A Attributes ---
         self.is_bankrupt: bool = False
         self.valuation: float = 0.0
-        self.consecutive_loss_ticks_for_bankruptcy: int = 0 # Track separately strictly for rule
-        
+        self.consecutive_loss_ticks_for_bankruptcy: int = (
+            0  # Track separately strictly for rule
+        )
+
         # --- Phase 6: Brand Engine ---
         self.brand_manager = BrandManager(self.id, config_module, logger)
-        self.marketing_budget: float = 0.0 # Decision variable
+        self.marketing_budget: float = 0.0  # Decision variable
         self.prev_awareness: float = 0.0  # For AI Reward Calculation
         # ROI Optimization
         self.marketing_budget_rate: float = 0.05  # Initial 5%
 
         # --- ì£¼ì‹ ì‹œì¥ ê´€ë ¨ ì†ì„± ---
         self.founder_id: Optional[int] = None  # ì°½ì—…ì ê°€ê³„ ID
-        self.is_publicly_traded: bool = True   # ìƒì¥ ì—¬ë¶€
+        self.is_publicly_traded: bool = True  # ìƒì¥ ì—¬ë¶€
         self.dividend_rate: float = getattr(
             config_module, "DIVIDEND_RATE", 0.3
         )  # ê¸°ì—…ë³„ ë°°ë‹¹ë¥  (ê¸°ë³¸ê°’: config)
         self.treasury_shares: float = self.total_shares  # ìì‚¬ì£¼ ë³´ìœ ëŸ‰
-        self.capital_stock: float = 100.0   # ì‹¤ë¬¼ ìë³¸ì¬ (ì´ˆê¸°ê°’: 100)
+        self.capital_stock: float = 100.0  # ì‹¤ë¬¼ ìë³¸ì¬ (ì´ˆê¸°ê°’: 100)
 
         # Phase 16-B: Rewards Tracking (Delta storage)
         self.prev_market_share: float = 0.0
@@ -130,8 +137,8 @@ class Firm(BaseAgent):
         self.prev_avg_quality: float = 1.0
 
         # Phase 21: Automation
-        self.automation_level: float = 0.0 # 0.0 to 1.0
-        self.system2_planner: Optional[FirmSystem2Planner] = None # Initialized later
+        self.automation_level: float = 0.0  # 0.0 to 1.0
+        self.system2_planner: Optional[FirmSystem2Planner] = None  # Initialized later
 
         self.age = 0
         self.cash_reserve = initial_capital
@@ -144,7 +151,7 @@ class Firm(BaseAgent):
         stock_market.update_shareholder(self.id, self.id, self.treasury_shares)
         self.logger.info(
             f"IPO | Firm {self.id} initialized IPO with {self.total_shares} shares. Par value: {par_value:.2f}",
-            extra={"agent_id": self.id, "tags": ["ipo", "stock_market"]}
+            extra={"agent_id": self.id, "tags": ["ipo", "stock_market"]},
         )
 
     # --- Properties to maintain Interface Compatibility ---
@@ -276,20 +283,23 @@ class Firm(BaseAgent):
     def sales_volume_this_tick(self, value):
         self.finance.sales_volume_this_tick = value
 
-
     def calculate_valuation(self) -> float:
         """
         Calculate Firm Valuation based on Net Assets + Profit Potential.
         Formula: Net Assets + (Max(0, Avg_Profit_Last_10) * PER Multiplier)
         """
-        net_assets = self.assets + self.get_inventory_value() + self.capital_stock 
-        
+        net_assets = self.assets + self.get_inventory_value() + self.capital_stock
+
         avg_profit = 0.0
         if len(self.finance.profit_history) > 0:
-            avg_profit = sum(self.finance.profit_history) / len(self.finance.profit_history)
-        
-        profit_premium = max(0.0, avg_profit) * getattr(self.config_module, "VALUATION_PER_MULTIPLIER", 10.0)
-        
+            avg_profit = sum(self.finance.profit_history) / len(
+                self.finance.profit_history
+            )
+
+        profit_premium = max(0.0, avg_profit) * getattr(
+            self.config_module, "VALUATION_PER_MULTIPLIER", 10.0
+        )
+
         self.valuation = net_assets + profit_premium
         return self.valuation
 
@@ -299,7 +309,7 @@ class Firm(BaseAgent):
         for item_id, qty in self.inventory.items():
             # Use last known market price or book value? Market price is better.
             # But Firm stores last_prices?
-            price = self.last_prices.get(item_id, 0.0) # Or fetch from market?
+            price = self.last_prices.get(item_id, 0.0)  # Or fetch from market?
             # If no price known, assume 0 or cost? Use valid price if possible.
             total_value += qty * price
         return total_value
@@ -313,17 +323,24 @@ class Firm(BaseAgent):
         """
         # 1. Write off Inventory
         self.inventory.clear()
-        
+
         # 2. Write off Capital Stock
         self.capital_stock = 0.0
-        
+
         # 3. Write off Automation
         self.automation_level = 0.0
 
         self.is_bankrupt = True
         return self.assets
 
-    def post_ask(self, item_id: str, price: float, quantity: float, market: OrderBookMarket, current_tick: int) -> Order:
+    def post_ask(
+        self,
+        item_id: str,
+        price: float,
+        quantity: float,
+        market: OrderBookMarket,
+        current_tick: int,
+    ) -> Order:
         """
         íŒë§¤ ì£¼ë¬¸ì„ ìƒì„±í•˜ê³  ì‹œì¥ì— ì œì¶œí•©ë‹ˆë‹¤.
         Brand Metadataë¥¼ ìë™ìœ¼ë¡œ ì£¼ì…í•©ë‹ˆë‹¤.
@@ -332,7 +349,9 @@ class Firm(BaseAgent):
         brand_snapshot = {
             "brand_awareness": self.brand_manager.brand_awareness,
             "perceived_quality": self.brand_manager.perceived_quality,
-            "quality": self.inventory_quality.get(item_id, 1.0), # Phase 15: Physical Quality
+            "quality": self.inventory_quality.get(
+                item_id, 1.0
+            ),  # Phase 15: Physical Quality
         }
 
         # 2. ì£¼ë¬¸ ìƒì„± (brand_info ìë™ ì£¼ì…)
@@ -343,7 +362,7 @@ class Firm(BaseAgent):
             quantity=quantity,
             price=price,
             market_id=market.id,
-            brand_info=brand_snapshot  # <-- Critical Injection
+            brand_info=brand_snapshot,  # <-- Critical Injection
         )
 
         # 3. ì‹œì¥ì— ì œì¶œ
@@ -351,7 +370,11 @@ class Firm(BaseAgent):
 
         self.logger.debug(
             f"FIRM_POST_ASK | Firm {self.id} posted SELL order for {quantity:.1f} {item_id} @ {price:.2f} with brand_info",
-            extra={"agent_id": self.id, "tick": current_tick, "brand_awareness": brand_snapshot["brand_awareness"]}
+            extra={
+                "agent_id": self.id,
+                "tick": current_tick,
+                "brand_awareness": brand_snapshot["brand_awareness"],
+            },
         )
 
         return order
@@ -391,9 +414,15 @@ class Firm(BaseAgent):
         efficiency = delta_revenue / self.finance.last_marketing_spend
 
         # Decision Rules
-        saturation_level = getattr(self.config_module, "BRAND_AWARENESS_SATURATION", 0.9)
-        high_eff_threshold = getattr(self.config_module, "MARKETING_EFFICIENCY_HIGH_THRESHOLD", 1.5)
-        low_eff_threshold = getattr(self.config_module, "MARKETING_EFFICIENCY_LOW_THRESHOLD", 0.8)
+        saturation_level = getattr(
+            self.config_module, "BRAND_AWARENESS_SATURATION", 0.9
+        )
+        high_eff_threshold = getattr(
+            self.config_module, "MARKETING_EFFICIENCY_HIGH_THRESHOLD", 1.5
+        )
+        low_eff_threshold = getattr(
+            self.config_module, "MARKETING_EFFICIENCY_LOW_THRESHOLD", 0.8
+        )
         min_rate = getattr(self.config_module, "MARKETING_BUDGET_RATE_MIN", 0.01)
         max_rate = getattr(self.config_module, "MARKETING_BUDGET_RATE_MAX", 0.20)
 
@@ -408,7 +437,9 @@ class Firm(BaseAgent):
         self.finance.last_revenue = self.finance.revenue_this_turn
         self.finance.last_marketing_spend = self.marketing_budget
 
-    def produce(self, current_time: int, technology_manager: Optional[Any] = None) -> None:
+    def produce(
+        self, current_time: int, technology_manager: Optional[Any] = None
+    ) -> None:
         """
         Cobb-Douglas ìƒì‚° í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•œ ìƒì‚° ë¡œì§.
         Phase 21: Modified Cobb-Douglas with Automation.
@@ -419,15 +450,22 @@ class Firm(BaseAgent):
                 self.current_production = 0.0
                 return
 
-            log_extra = {"tick": current_time, "agent_id": self.id, "tags": ["production"]}
+            log_extra = {
+                "tick": current_time,
+                "agent_id": self.id,
+                "tags": ["production"],
+            }
 
             # 1. ê°ê°€ìƒê° ì²˜ë¦¬
-            depreciation_rate = getattr(self.config_module, "CAPITAL_DEPRECIATION_RATE", 0.05)
-            self.capital_stock *= (1.0 - depreciation_rate)
+            depreciation_rate = getattr(
+                self.config_module, "CAPITAL_DEPRECIATION_RATE", 0.05
+            )
+            self.capital_stock *= 1.0 - depreciation_rate
 
             # Phase 21: Automation Decay
-            self.automation_level *= 0.995 # Slow decay (0.5% per tick)
-            if self.automation_level < 0.001: self.automation_level = 0.0
+            self.automation_level *= 0.995  # Slow decay (0.5% per tick)
+            if self.automation_level < 0.001:
+                self.automation_level = 0.0
 
             # 2. ë…¸ë™ ë° ìë³¸ íˆ¬ì…ëŸ‰ ê³„ì‚°
             # SoC Refactor: Get total labor skill from HR
@@ -435,13 +473,19 @@ class Firm(BaseAgent):
 
             # 3. Cobb-Douglas Parameters
             base_alpha = getattr(self.config_module, "LABOR_ALPHA", 0.7)
-            automation_reduction = getattr(self.config_module, "AUTOMATION_LABOR_REDUCTION", 0.5)
+            automation_reduction = getattr(
+                self.config_module, "AUTOMATION_LABOR_REDUCTION", 0.5
+            )
 
             # Phase 21: Adjusted Alpha
             # alpha_adjusted = base_alpha * (1 - automation_level * 0.5)
             # If Automation = 1.0, Alpha = 0.7 * 0.5 = 0.35 (Capital dependent)
-            alpha_raw = base_alpha * (1.0 - (self.automation_level * automation_reduction))
-            alpha_adjusted = max(getattr(self.config_module, "LABOR_ELASTICITY_MIN", 0.3), alpha_raw)
+            alpha_raw = base_alpha * (
+                1.0 - (self.automation_level * automation_reduction)
+            )
+            alpha_adjusted = max(
+                getattr(self.config_module, "LABOR_ELASTICITY_MIN", 0.3), alpha_raw
+            )
             beta_adjusted = 1.0 - alpha_adjusted
 
             # Effective Labor & Capital
@@ -450,10 +494,14 @@ class Firm(BaseAgent):
             # Technology Multiplier (WO-053)
             tech_multiplier = 1.0
 
-            tfp = self.productivity_factor * tech_multiplier  # Total Factor Productivity
+            tfp = (
+                self.productivity_factor * tech_multiplier
+            )  # Total Factor Productivity
 
             if technology_manager:
-                tech_multiplier = technology_manager.get_productivity_multiplier(self.id, self.sector)
+                tech_multiplier = technology_manager.get_productivity_multiplier(
+                    self.id, self.sector
+                )
                 tfp *= tech_multiplier
 
             # Phase 15: Quality Calculation
@@ -461,21 +509,27 @@ class Firm(BaseAgent):
 
             item_config = self.config_module.GOODS.get(self.specialization, {})
             quality_sensitivity = item_config.get("quality_sensitivity", 0.5)
-            actual_quality = self.base_quality + (math.log1p(avg_skill) * quality_sensitivity)
+            actual_quality = self.base_quality + (
+                math.log1p(avg_skill) * quality_sensitivity
+            )
 
             self.current_production = 0.0
 
             if total_labor_skill > 0 and capital > 0:
-                produced_quantity = tfp * (total_labor_skill ** alpha_adjusted) * (capital ** beta_adjusted)
+                produced_quantity = (
+                    tfp * (total_labor_skill**alpha_adjusted) * (capital**beta_adjusted)
+                )
             else:
                 produced_quantity = 0.0
 
             if produced_quantity > 0:
                 # WO-030: Input Constraints Logic
-                input_config = self.config_module.GOODS.get(self.specialization, {}).get("inputs", {})
+                input_config = self.config_module.GOODS.get(
+                    self.specialization, {}
+                ).get("inputs", {})
 
                 if input_config:
-                    max_by_inputs = float('inf')
+                    max_by_inputs = float("inf")
                     for mat, req_per_unit in input_config.items():
                         available = self.input_inventory.get(mat, 0.0)
                         if req_per_unit > 0:
@@ -487,7 +541,9 @@ class Firm(BaseAgent):
                     # Deduct used inputs
                     for mat, req_per_unit in input_config.items():
                         amount_to_deduct = actual_produced * req_per_unit
-                        self.input_inventory[mat] = max(0.0, self.input_inventory.get(mat, 0.0) - amount_to_deduct)
+                        self.input_inventory[mat] = max(
+                            0.0, self.input_inventory.get(mat, 0.0) - amount_to_deduct
+                        )
                 else:
                     actual_produced = produced_quantity
 
@@ -497,7 +553,10 @@ class Firm(BaseAgent):
                     current_quality = self.inventory_quality.get(item_id, 1.0)
 
                     total_qty = current_inventory + actual_produced
-                    new_avg_quality = ((current_inventory * current_quality) + (actual_produced * actual_quality)) / total_qty
+                    new_avg_quality = (
+                        (current_inventory * current_quality)
+                        + (actual_produced * actual_quality)
+                    ) / total_qty
 
                     self.inventory_quality[item_id] = new_avg_quality
                     self.inventory[item_id] = total_qty
@@ -506,7 +565,8 @@ class Firm(BaseAgent):
                     self.current_production = 0.0
         except Exception as e:
             import traceback
-            logger.error(f'FIRM_CRASH_PREVENTED | Firm {self.id}: {e}')
+
+            logger.error(f"FIRM_CRASH_PREVENTED | Firm {self.id}: {e}")
             logger.debug(traceback.format_exc())
             self.current_production = 0.0
             return
@@ -514,21 +574,21 @@ class Firm(BaseAgent):
     def issue_shares(self, quantity: float, price: float) -> float:
         """
         ì‹ ê·œ ì£¼ì‹ì„ ë°œí–‰í•©ë‹ˆë‹¤ (ìœ ìƒì¦ì).
-        
+
         Args:
             quantity: ë°œí–‰í•  ì£¼ì‹ ìˆ˜ëŸ‰
             price: ì£¼ë‹¹ ë°œí–‰ ê°€ê²©
-            
+
         Returns:
             ì¡°ë‹¬ëœ ìë³¸ê¸ˆ
         """
         if quantity <= 0 or price <= 0:
             return 0.0
-        
+
         self.total_shares += quantity
         raised_capital = quantity * price
         self.assets += raised_capital
-        
+
         self.logger.info(
             f"Firm {self.id} issued {quantity:.1f} shares at {price:.2f}, "
             f"raising {raised_capital:.2f} capital. Total shares: {self.total_shares:.1f}",
@@ -538,8 +598,8 @@ class Firm(BaseAgent):
                 "price": price,
                 "raised_capital": raised_capital,
                 "total_shares": self.total_shares,
-                "tags": ["stock", "issue"]
-            }
+                "tags": ["stock", "issue"],
+            },
         )
         return raised_capital
 
@@ -552,10 +612,10 @@ class Firm(BaseAgent):
         # Calculate liabilities from bank loans
         liabilities = 0.0
         try:
-            loan_market = getattr(self.decision_engine, 'loan_market', None)
-            if loan_market and hasattr(loan_market, 'bank') and loan_market.bank:
+            loan_market = getattr(self.decision_engine, "loan_market", None)
+            if loan_market and hasattr(loan_market, "bank") and loan_market.bank:
                 debt_summary = loan_market.bank.get_debt_summary(self.id)
-                liabilities = debt_summary.get('total_principal', 0.0)
+                liabilities = debt_summary.get("total_principal", 0.0)
         except Exception:
             pass  # Graceful fallback
 
@@ -565,20 +625,19 @@ class Firm(BaseAgent):
     def get_market_cap(self, stock_price: Optional[float] = None) -> float:
         """
         ì‹œê°€ì´ì•¡ì„ ê³„ì‚°í•©ë‹ˆë‹¤.
-        
+
         Args:
             stock_price: ì£¼ê°€ (Noneì´ë©´ ìˆœìì‚°ê°€ì¹˜ ê¸°ë°˜ ê³„ì‚°)
-            
+
         Returns:
             ì‹œê°€ì´ì•¡
         """
         if stock_price is None:
             stock_price = self.get_book_value_per_share()
-        
+
         outstanding_shares = self.total_shares - self.treasury_shares
         return outstanding_shares * stock_price
 
-
     @override
     def clone(self, new_id: int, initial_assets_from_parent: float) -> "Firm":
         """
@@ -599,7 +658,7 @@ class Firm(BaseAgent):
             initial_inventory=copy.deepcopy(self.inventory),
             loan_market=self.decision_engine.loan_market,  # loan_marketì€ ê³µìœ 
             logger=self.logger,
-            personality=self.personality # Propagate personality
+            personality=self.personality,  # Propagate personality
         )
         new_firm.logger.info(
             f"Firm {self.id} was cloned to new Firm {new_id}",
@@ -611,7 +670,9 @@ class Firm(BaseAgent):
         )
         return new_firm
 
-    def distribute_dividends(self, households: List[Household], current_time: int) -> List[Transaction]:
+    def distribute_dividends(
+        self, households: List[Household], current_time: int
+    ) -> List[Transaction]:
         # SoC Refactor
         return self.finance.distribute_dividends(households, current_time)
 
@@ -622,7 +683,7 @@ class Firm(BaseAgent):
             "assets": self.assets,
             "needs": self.needs.copy(),
             "inventory": self.inventory.copy(),
-            "input_inventory": self.input_inventory.copy(), # WO-030
+            "input_inventory": self.input_inventory.copy(),  # WO-030
             "employees": [emp.id for emp in self.employees],  # Only pass employee IDs
             "is_active": self.is_active,
             "current_production": self.current_production,
@@ -635,19 +696,24 @@ class Firm(BaseAgent):
             "treasury_shares": self.treasury_shares,
             "dividend_rate": self.dividend_rate,
             "capital_stock": self.capital_stock,
-            "base_quality": self.base_quality, # AI needs to know this
+            "base_quality": self.base_quality,  # AI needs to know this
             "inventory_quality": self.inventory_quality.copy(),
-            "automation_level": self.automation_level, # Phase 21
+            "automation_level": self.automation_level,  # Phase 21
         }
 
     def get_pre_state_data(self) -> Dict[str, Any]:
         """AI í•™ìŠµì„ ìœ„í•œ ì´ì „ ìƒíƒœ ë°ì´í„°ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."""
         return getattr(self, "pre_state_snapshot", self.get_agent_data())
 
-
     @override
     def make_decision(
-        self, markets: Dict[str, Any], goods_data: list[Dict[str, Any]], market_data: Dict[str, Any], current_time: int, government: Optional[Any] = None, reflux_system: Optional[Any] = None
+        self,
+        markets: Dict[str, Any],
+        goods_data: list[Dict[str, Any]],
+        market_data: Dict[str, Any],
+        current_time: int,
+        government: Optional[Any] = None,
+        reflux_system: Optional[Any] = None,
     ) -> tuple[list[Order], Any]:
         log_extra = {"tick": current_time, "agent_id": self.id, "tags": ["firm_action"]}
         self.logger.debug(
@@ -685,14 +751,16 @@ class Firm(BaseAgent):
         )
         return decisions, tactic
 
-    def _calculate_invisible_hand_price(self, markets: Dict[str, Any], current_tick: int) -> None:
+    def _calculate_invisible_hand_price(
+        self, markets: Dict[str, Any], current_tick: int
+    ) -> None:
         """
         WO-056: Stage 1 Shadow Mode (Price Discovery 2.0).
         Calculates and logs the shadow price based on Excess Demand.
         """
         market = markets.get(self.specialization)
         # Check if market supports order book inspection
-        if not market or not hasattr(market, 'get_all_bids'):
+        if not market or not hasattr(market, "get_all_bids"):
             return
 
         # 1. Get Demand and Supply (Market-wide for this good)
@@ -731,11 +799,17 @@ class Firm(BaseAgent):
             metric="shadow_price",
             current_value=current_price,
             shadow_value=shadow_price,
-            details=f"Item={self.specialization}, D={demand:.1f}, S={supply:.1f}, Ratio={excess_demand_ratio:.2f}"
+            details=f"Item={self.specialization}, D={demand:.1f}, S={supply:.1f}, Ratio={excess_demand_ratio:.2f}",
         )
 
     @override
-    def update_needs(self, current_time: int, government: Optional[Any] = None, market_data: Optional[Dict[str, Any]] = None, reflux_system: Optional[Any] = None) -> None:
+    def update_needs(
+        self,
+        current_time: int,
+        government: Optional[Any] = None,
+        market_data: Optional[Dict[str, Any]] = None,
+        reflux_system: Optional[Any] = None,
+    ) -> None:
         log_extra = {"tick": current_time, "agent_id": self.id, "tags": ["firm_needs"]}
         self.logger.debug(
             f"FIRM_NEEDS_UPDATE_START | Firm {self.id} needs before update: Liquidity={self.needs['liquidity_need']:.1f}, Assets={self.assets:.2f}, Employees={len(self.employees)}",
@@ -769,24 +843,26 @@ class Firm(BaseAgent):
                 f"Paid total wages: {total_wages:.2f} to {len(self.employees)} employees.",
                 extra={**log_extra, "total_wages": total_wages},
             )
-        
+
         # --- Phase 6: Marketing Spend & Brand Update ---
         # Adaptive Budgeting
         marketing_spend = 0.0
         if self.assets > 100.0:
-            marketing_spend = max(10.0, self.finance.revenue_this_turn * self.marketing_budget_rate)
-        
+            marketing_spend = max(
+                10.0, self.finance.revenue_this_turn * self.marketing_budget_rate
+            )
+
         # Check affordability
         if self.assets < marketing_spend:
-             marketing_spend = 0.0
+            marketing_spend = 0.0
 
         # Apply spend
         if marketing_spend > 0:
-             self.assets -= marketing_spend
-             self.finance.record_expense(marketing_spend)
-             # Phase 8-B: Capture marketing spend (Ad Agency Fee)
-             if reflux_system:
-                 reflux_system.capture(marketing_spend, str(self.id), "marketing")
+            self.assets -= marketing_spend
+            self.finance.record_expense(marketing_spend)
+            # Phase 8-B: Capture marketing spend (Ad Agency Fee)
+            if reflux_system:
+                reflux_system.capture(marketing_spend, str(self.id), "marketing")
 
         # Update state for AI/ROI (Explicitly assign to instance variable)
         self.marketing_budget = marketing_spend
@@ -805,7 +881,9 @@ class Firm(BaseAgent):
             self.finance.pay_taxes(government, current_time)
         # ---------------------------------------------
 
-        brand_premium = self.calculate_brand_premium(market_data) if market_data else 0.0
+        brand_premium = (
+            self.calculate_brand_premium(market_data) if market_data else 0.0
+        )
         self.logger.info(
             f"FIRM_BRAND_METRICS | Firm {self.id}: Awareness={self.brand_manager.brand_awareness:.4f}, "
             f"Quality={self.brand_manager.perceived_quality:.4f}, Premium={brand_premium:.2f}",
@@ -813,8 +891,8 @@ class Firm(BaseAgent):
                 **log_extra,
                 "brand_awareness": self.brand_manager.brand_awareness,
                 "perceived_quality": self.brand_manager.perceived_quality,
-                "brand_premium": brand_premium
-            }
+                "brand_premium": brand_premium,
+            },
         )
 
         self.needs["liquidity_need"] += self.config_module.LIQUIDITY_NEED_INCREASE_RATE
@@ -846,7 +924,7 @@ class Firm(BaseAgent):
                 "num_employees_after": len(self.employees),
                 "is_active_after": self.is_active,
                 "brand_awareness": self.brand_manager.brand_awareness,
-                "perceived_quality": self.brand_manager.perceived_quality
+                "perceived_quality": self.brand_manager.perceived_quality,
             },
         )
 
diff --git a/design/gemini_output/jules_firms_revised.py b/design/gemini_output/jules_firms_revised.py
index d4ba21e..626ce6d 100644
--- a/design/gemini_output/jules_firms_revised.py
+++ b/design/gemini_output/jules_firms_revised.py
@@ -26,6 +26,7 @@ if TYPE_CHECKING:
 
 logger = logging.getLogger(__name__)
 
+
 class Firm(BaseAgent):
     """ê¸°ì—… ì£¼ì²´. ìƒì‚°ê³¼ ê³ ìš©ì˜ ì£¼ì²´."""
 
@@ -43,7 +44,7 @@ class Firm(BaseAgent):
         loan_market: Optional[LoanMarket] = None,
         logger: Optional[logging.Logger] = None,
         # Phase 14-2: Innovation
-        sector: str = "FOOD", 
+        sector: str = "FOOD",
         is_visionary: bool = False,
         # Phase 16-B: Personality
         personality: Optional[Personality] = None,
@@ -61,21 +62,23 @@ class Firm(BaseAgent):
         if initial_inventory is not None:
             self.inventory.update(initial_inventory)
         self.specialization = specialization
-        self.inventory_quality: Dict[str, float] = {}  # Phase 15: Weighted Average Quality
-        self.input_inventory: Dict[str, float] = {} # WO-030: Raw Materials
-        
+        self.inventory_quality: Dict[
+            str, float
+        ] = {}  # Phase 15: Weighted Average Quality
+        self.input_inventory: Dict[str, float] = {}  # WO-030: Raw Materials
+
         # Phase 14-2 attributes
         self.sector = sector
         self.is_visionary = is_visionary
-        self.owner_id: Optional[int] = None # Phase 14-1: Shareholder System
-        
+        self.owner_id: Optional[int] = None  # Phase 14-1: Shareholder System
+
         # Phase 16-B: Personality & Innovation Attributes
         self.personality = personality or Personality.BALANCED
         self.base_quality: float = 1.0
         self.research_history: Dict[str, Any] = {
             "total_spent": 0.0,
             "success_count": 0,
-            "last_success_tick": -1
+            "last_success_tick": -1,
         }
 
         # SoC Refactor: HR and Finance Components
@@ -83,11 +86,13 @@ class Firm(BaseAgent):
         self.finance = FinanceDepartment(self, config_module)
 
         # Set bankruptcy threshold based on visionary status
-        base_threshold = getattr(config_module, "BANKRUPTCY_CONSECUTIVE_LOSS_THRESHOLD", 5)
+        base_threshold = getattr(
+            config_module, "BANKRUPTCY_CONSECUTIVE_LOSS_THRESHOLD", 5
+        )
         if self.is_visionary:
             self.consecutive_loss_ticks_for_bankruptcy_threshold = base_threshold * 2
         else:
-             self.consecutive_loss_ticks_for_bankruptcy_threshold = base_threshold
+            self.consecutive_loss_ticks_for_bankruptcy_threshold = base_threshold
 
         self.production_target: float = (
             config_module.FIRM_MIN_PRODUCTION_TARGET
@@ -101,28 +106,30 @@ class Firm(BaseAgent):
         self.productivity_factor: float = productivity_factor
         self.total_shares: float = getattr(config_module, "IPO_INITIAL_SHARES", 1000.0)
         self.last_prices: Dict[str, float] = {}
-        self.hires_last_tick: int = 0 # Handled in HR but maybe exposed here?
-        
+        self.hires_last_tick: int = 0  # Handled in HR but maybe exposed here?
+
         # --- Phase 9: M&A Attributes ---
         self.is_bankrupt: bool = False
         self.valuation: float = 0.0
-        self.consecutive_loss_ticks_for_bankruptcy: int = 0 # Track separately strictly for rule
-        
+        self.consecutive_loss_ticks_for_bankruptcy: int = (
+            0  # Track separately strictly for rule
+        )
+
         # --- Phase 6: Brand Engine ---
         self.brand_manager = BrandManager(self.id, config_module, logger)
-        self.marketing_budget: float = 0.0 # Decision variable
+        self.marketing_budget: float = 0.0  # Decision variable
         self.prev_awareness: float = 0.0  # For AI Reward Calculation
         # ROI Optimization
         self.marketing_budget_rate: float = 0.05  # Initial 5%
 
         # --- ì£¼ì‹ ì‹œì¥ ê´€ë ¨ ì†ì„± ---
         self.founder_id: Optional[int] = None  # ì°½ì—…ì ê°€ê³„ ID
-        self.is_publicly_traded: bool = True   # ìƒì¥ ì—¬ë¶€
+        self.is_publicly_traded: bool = True  # ìƒì¥ ì—¬ë¶€
         self.dividend_rate: float = getattr(
             config_module, "DIVIDEND_RATE", 0.3
         )  # ê¸°ì—…ë³„ ë°°ë‹¹ë¥  (ê¸°ë³¸ê°’: config)
         self.treasury_shares: float = self.total_shares  # ìì‚¬ì£¼ ë³´ìœ ëŸ‰
-        self.capital_stock: float = 100.0   # ì‹¤ë¬¼ ìë³¸ì¬ (ì´ˆê¸°ê°’: 100)
+        self.capital_stock: float = 100.0  # ì‹¤ë¬¼ ìë³¸ì¬ (ì´ˆê¸°ê°’: 100)
 
         # Phase 16-B: Rewards Tracking (Delta storage)
         self.prev_market_share: float = 0.0
@@ -130,8 +137,8 @@ class Firm(BaseAgent):
         self.prev_avg_quality: float = 1.0
 
         # Phase 21: Automation
-        self.automation_level: float = 0.0 # 0.0 to 1.0
-        self.system2_planner: Optional[FirmSystem2Planner] = None # Initialized later
+        self.automation_level: float = 0.0  # 0.0 to 1.0
+        self.system2_planner: Optional[FirmSystem2Planner] = None  # Initialized later
 
         self.age = 0
         self.cash_reserve = initial_capital
@@ -143,7 +150,7 @@ class Firm(BaseAgent):
         stock_market.update_shareholder(self.id, self.id, self.treasury_shares)
         self.logger.info(
             f"IPO | Firm {self.id} initialized IPO with {self.total_shares} shares. Par value: {par_value:.2f}",
-            extra={"agent_id": self.id, "tags": ["ipo", "stock_market"]}
+            extra={"agent_id": self.id, "tags": ["ipo", "stock_market"]},
         )
 
     # --- Properties to maintain Interface Compatibility ---
@@ -275,20 +282,23 @@ class Firm(BaseAgent):
     def sales_volume_this_tick(self, value):
         self.finance.sales_volume_this_tick = value
 
-
     def calculate_valuation(self) -> float:
         """
         Calculate Firm Valuation based on Net Assets + Profit Potential.
         Formula: Net Assets + (Max(0, Avg_Profit_Last_10) * PER Multiplier)
         """
-        net_assets = self.assets + self.get_inventory_value() + self.capital_stock 
-        
+        net_assets = self.assets + self.get_inventory_value() + self.capital_stock
+
         avg_profit = 0.0
         if len(self.finance.profit_history) > 0:
-            avg_profit = sum(self.finance.profit_history) / len(self.finance.profit_history)
-        
-        profit_premium = max(0.0, avg_profit) * getattr(self.config_module, "VALUATION_PER_MULTIPLIER", 10.0)
-        
+            avg_profit = sum(self.finance.profit_history) / len(
+                self.finance.profit_history
+            )
+
+        profit_premium = max(0.0, avg_profit) * getattr(
+            self.config_module, "VALUATION_PER_MULTIPLIER", 10.0
+        )
+
         self.valuation = net_assets + profit_premium
         return self.valuation
 
@@ -298,7 +308,7 @@ class Firm(BaseAgent):
         for item_id, qty in self.inventory.items():
             # Use last known market price or book value? Market price is better.
             # But Firm stores last_prices?
-            price = self.last_prices.get(item_id, 0.0) # Or fetch from market?
+            price = self.last_prices.get(item_id, 0.0)  # Or fetch from market?
             # If no price known, assume 0 or cost? Use valid price if possible.
             total_value += qty * price
         return total_value
@@ -312,17 +322,24 @@ class Firm(BaseAgent):
         """
         # 1. Write off Inventory
         self.inventory.clear()
-        
+
         # 2. Write off Capital Stock
         self.capital_stock = 0.0
-        
+
         # 3. Write off Automation
         self.automation_level = 0.0
 
         self.is_bankrupt = True
         return self.assets
 
-    def post_ask(self, item_id: str, price: float, quantity: float, market: OrderBookMarket, current_tick: int) -> Order:
+    def post_ask(
+        self,
+        item_id: str,
+        price: float,
+        quantity: float,
+        market: OrderBookMarket,
+        current_tick: int,
+    ) -> Order:
         """
         íŒë§¤ ì£¼ë¬¸ì„ ìƒì„±í•˜ê³  ì‹œì¥ì— ì œì¶œí•©ë‹ˆë‹¤.
         Brand Metadataë¥¼ ìë™ìœ¼ë¡œ ì£¼ì…í•©ë‹ˆë‹¤.
@@ -331,7 +348,9 @@ class Firm(BaseAgent):
         brand_snapshot = {
             "brand_awareness": self.brand_manager.brand_awareness,
             "perceived_quality": self.brand_manager.perceived_quality,
-            "quality": self.inventory_quality.get(item_id, 1.0), # Phase 15: Physical Quality
+            "quality": self.inventory_quality.get(
+                item_id, 1.0
+            ),  # Phase 15: Physical Quality
         }
 
         # 2. ì£¼ë¬¸ ìƒì„± (brand_info ìë™ ì£¼ì…)
@@ -342,7 +361,7 @@ class Firm(BaseAgent):
             quantity=quantity,
             price=price,
             market_id=market.id,
-            brand_info=brand_snapshot  # <-- Critical Injection
+            brand_info=brand_snapshot,  # <-- Critical Injection
         )
 
         # 3. ì‹œì¥ì— ì œì¶œ
@@ -350,7 +369,11 @@ class Firm(BaseAgent):
 
         self.logger.debug(
             f"FIRM_POST_ASK | Firm {self.id} posted SELL order for {quantity:.1f} {item_id} @ {price:.2f} with brand_info",
-            extra={"agent_id": self.id, "tick": current_tick, "brand_awareness": brand_snapshot["brand_awareness"]}
+            extra={
+                "agent_id": self.id,
+                "tick": current_tick,
+                "brand_awareness": brand_snapshot["brand_awareness"],
+            },
         )
 
         return order
@@ -390,9 +413,15 @@ class Firm(BaseAgent):
         efficiency = delta_revenue / self.finance.last_marketing_spend
 
         # Decision Rules
-        saturation_level = getattr(self.config_module, "BRAND_AWARENESS_SATURATION", 0.9)
-        high_eff_threshold = getattr(self.config_module, "MARKETING_EFFICIENCY_HIGH_THRESHOLD", 1.5)
-        low_eff_threshold = getattr(self.config_module, "MARKETING_EFFICIENCY_LOW_THRESHOLD", 0.8)
+        saturation_level = getattr(
+            self.config_module, "BRAND_AWARENESS_SATURATION", 0.9
+        )
+        high_eff_threshold = getattr(
+            self.config_module, "MARKETING_EFFICIENCY_HIGH_THRESHOLD", 1.5
+        )
+        low_eff_threshold = getattr(
+            self.config_module, "MARKETING_EFFICIENCY_LOW_THRESHOLD", 0.8
+        )
         min_rate = getattr(self.config_module, "MARKETING_BUDGET_RATE_MIN", 0.01)
         max_rate = getattr(self.config_module, "MARKETING_BUDGET_RATE_MAX", 0.20)
 
@@ -407,7 +436,9 @@ class Firm(BaseAgent):
         self.finance.last_revenue = self.finance.revenue_this_turn
         self.finance.last_marketing_spend = self.marketing_budget
 
-    def produce(self, current_time: int, technology_manager: Optional[Any] = None) -> None:
+    def produce(
+        self, current_time: int, technology_manager: Optional[Any] = None
+    ) -> None:
         """
         Cobb-Douglas ìƒì‚° í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•œ ìƒì‚° ë¡œì§.
         Phase 21: Modified Cobb-Douglas with Automation.
@@ -418,15 +449,22 @@ class Firm(BaseAgent):
                 self.current_production = 0.0
                 return
 
-            log_extra = {"tick": current_time, "agent_id": self.id, "tags": ["production"]}
+            log_extra = {
+                "tick": current_time,
+                "agent_id": self.id,
+                "tags": ["production"],
+            }
 
             # 1. ê°ê°€ìƒê° ì²˜ë¦¬
-            depreciation_rate = getattr(self.config_module, "CAPITAL_DEPRECIATION_RATE", 0.05)
-            self.capital_stock *= (1.0 - depreciation_rate)
+            depreciation_rate = getattr(
+                self.config_module, "CAPITAL_DEPRECIATION_RATE", 0.05
+            )
+            self.capital_stock *= 1.0 - depreciation_rate
 
             # Phase 21: Automation Decay
-            self.automation_level *= 0.995 # Slow decay (0.5% per tick)
-            if self.automation_level < 0.001: self.automation_level = 0.0
+            self.automation_level *= 0.995  # Slow decay (0.5% per tick)
+            if self.automation_level < 0.001:
+                self.automation_level = 0.0
 
             # 2. ë…¸ë™ ë° ìë³¸ íˆ¬ì…ëŸ‰ ê³„ì‚°
             # SoC Refactor: Get total labor skill from HR
@@ -434,13 +472,19 @@ class Firm(BaseAgent):
 
             # 3. Cobb-Douglas Parameters
             base_alpha = getattr(self.config_module, "LABOR_ALPHA", 0.7)
-            automation_reduction = getattr(self.config_module, "AUTOMATION_LABOR_REDUCTION", 0.5)
+            automation_reduction = getattr(
+                self.config_module, "AUTOMATION_LABOR_REDUCTION", 0.5
+            )
 
             # Phase 21: Adjusted Alpha
             # alpha_adjusted = base_alpha * (1 - automation_level * 0.5)
             # If Automation = 1.0, Alpha = 0.7 * 0.5 = 0.35 (Capital dependent)
-            alpha_raw = base_alpha * (1.0 - (self.automation_level * automation_reduction))
-            alpha_adjusted = max(getattr(self.config_module, "LABOR_ELASTICITY_MIN", 0.3), alpha_raw)
+            alpha_raw = base_alpha * (
+                1.0 - (self.automation_level * automation_reduction)
+            )
+            alpha_adjusted = max(
+                getattr(self.config_module, "LABOR_ELASTICITY_MIN", 0.3), alpha_raw
+            )
             beta_adjusted = 1.0 - alpha_adjusted
 
             # Effective Labor & Capital
@@ -449,10 +493,14 @@ class Firm(BaseAgent):
             # Technology Multiplier (WO-053)
             tech_multiplier = 1.0
 
-            tfp = self.productivity_factor * tech_multiplier  # Total Factor Productivity
+            tfp = (
+                self.productivity_factor * tech_multiplier
+            )  # Total Factor Productivity
 
             if technology_manager:
-                tech_multiplier = technology_manager.get_productivity_multiplier(self.id, self.sector)
+                tech_multiplier = technology_manager.get_productivity_multiplier(
+                    self.id, self.sector
+                )
                 tfp *= tech_multiplier
 
             # Phase 15: Quality Calculation
@@ -460,21 +508,27 @@ class Firm(BaseAgent):
 
             item_config = self.config_module.GOODS.get(self.specialization, {})
             quality_sensitivity = item_config.get("quality_sensitivity", 0.5)
-            actual_quality = self.base_quality + (math.log1p(avg_skill) * quality_sensitivity)
+            actual_quality = self.base_quality + (
+                math.log1p(avg_skill) * quality_sensitivity
+            )
 
             self.current_production = 0.0
 
             if total_labor_skill > 0 and capital > 0:
-                produced_quantity = tfp * (total_labor_skill ** alpha_adjusted) * (capital ** beta_adjusted)
+                produced_quantity = (
+                    tfp * (total_labor_skill**alpha_adjusted) * (capital**beta_adjusted)
+                )
             else:
                 produced_quantity = 0.0
 
             if produced_quantity > 0:
                 # WO-030: Input Constraints Logic
-                input_config = self.config_module.GOODS.get(self.specialization, {}).get("inputs", {})
+                input_config = self.config_module.GOODS.get(
+                    self.specialization, {}
+                ).get("inputs", {})
 
                 if input_config:
-                    max_by_inputs = float('inf')
+                    max_by_inputs = float("inf")
                     for mat, req_per_unit in input_config.items():
                         available = self.input_inventory.get(mat, 0.0)
                         if req_per_unit > 0:
@@ -486,7 +540,9 @@ class Firm(BaseAgent):
                     # Deduct used inputs
                     for mat, req_per_unit in input_config.items():
                         amount_to_deduct = actual_produced * req_per_unit
-                        self.input_inventory[mat] = max(0.0, self.input_inventory.get(mat, 0.0) - amount_to_deduct)
+                        self.input_inventory[mat] = max(
+                            0.0, self.input_inventory.get(mat, 0.0) - amount_to_deduct
+                        )
                 else:
                     actual_produced = produced_quantity
 
@@ -496,7 +552,10 @@ class Firm(BaseAgent):
                     current_quality = self.inventory_quality.get(item_id, 1.0)
 
                     total_qty = current_inventory + actual_produced
-                    new_avg_quality = ((current_inventory * current_quality) + (actual_produced * actual_quality)) / total_qty
+                    new_avg_quality = (
+                        (current_inventory * current_quality)
+                        + (actual_produced * actual_quality)
+                    ) / total_qty
 
                     self.inventory_quality[item_id] = new_avg_quality
                     self.inventory[item_id] = total_qty
@@ -505,7 +564,8 @@ class Firm(BaseAgent):
                     self.current_production = 0.0
         except Exception as e:
             import traceback
-            logger.error(f'FIRM_CRASH_PREVENTED | Firm {self.id}: {e}')
+
+            logger.error(f"FIRM_CRASH_PREVENTED | Firm {self.id}: {e}")
             logger.debug(traceback.format_exc())
             self.current_production = 0.0
             return
@@ -513,21 +573,21 @@ class Firm(BaseAgent):
     def issue_shares(self, quantity: float, price: float) -> float:
         """
         ì‹ ê·œ ì£¼ì‹ì„ ë°œí–‰í•©ë‹ˆë‹¤ (ìœ ìƒì¦ì).
-        
+
         Args:
             quantity: ë°œí–‰í•  ì£¼ì‹ ìˆ˜ëŸ‰
             price: ì£¼ë‹¹ ë°œí–‰ ê°€ê²©
-            
+
         Returns:
             ì¡°ë‹¬ëœ ìë³¸ê¸ˆ
         """
         if quantity <= 0 or price <= 0:
             return 0.0
-        
+
         self.total_shares += quantity
         raised_capital = quantity * price
         self.assets += raised_capital
-        
+
         self.logger.info(
             f"Firm {self.id} issued {quantity:.1f} shares at {price:.2f}, "
             f"raising {raised_capital:.2f} capital. Total shares: {self.total_shares:.1f}",
@@ -537,8 +597,8 @@ class Firm(BaseAgent):
                 "price": price,
                 "raised_capital": raised_capital,
                 "total_shares": self.total_shares,
-                "tags": ["stock", "issue"]
-            }
+                "tags": ["stock", "issue"],
+            },
         )
         return raised_capital
 
@@ -551,10 +611,10 @@ class Firm(BaseAgent):
         # Calculate liabilities from bank loans
         liabilities = 0.0
         try:
-            loan_market = getattr(self.decision_engine, 'loan_market', None)
-            if loan_market and hasattr(loan_market, 'bank') and loan_market.bank:
+            loan_market = getattr(self.decision_engine, "loan_market", None)
+            if loan_market and hasattr(loan_market, "bank") and loan_market.bank:
                 debt_summary = loan_market.bank.get_debt_summary(self.id)
-                liabilities = debt_summary.get('total_principal', 0.0)
+                liabilities = debt_summary.get("total_principal", 0.0)
         except Exception:
             pass  # Graceful fallback
 
@@ -564,20 +624,19 @@ class Firm(BaseAgent):
     def get_market_cap(self, stock_price: Optional[float] = None) -> float:
         """
         ì‹œê°€ì´ì•¡ì„ ê³„ì‚°í•©ë‹ˆë‹¤.
-        
+
         Args:
             stock_price: ì£¼ê°€ (Noneì´ë©´ ìˆœìì‚°ê°€ì¹˜ ê¸°ë°˜ ê³„ì‚°)
-            
+
         Returns:
             ì‹œê°€ì´ì•¡
         """
         if stock_price is None:
             stock_price = self.get_book_value_per_share()
-        
+
         outstanding_shares = self.total_shares - self.treasury_shares
         return outstanding_shares * stock_price
 
-
     @override
     def clone(self, new_id: int, initial_assets_from_parent: float) -> "Firm":
         """
@@ -598,7 +657,7 @@ class Firm(BaseAgent):
             initial_inventory=copy.deepcopy(self.inventory),
             loan_market=self.decision_engine.loan_market,  # loan_marketì€ ê³µìœ 
             logger=self.logger,
-            personality=self.personality # Propagate personality
+            personality=self.personality,  # Propagate personality
         )
         new_firm.logger.info(
             f"Firm {self.id} was cloned to new Firm {new_id}",
@@ -610,7 +669,9 @@ class Firm(BaseAgent):
         )
         return new_firm
 
-    def distribute_dividends(self, households: List[Household], current_time: int) -> List[Transaction]:
+    def distribute_dividends(
+        self, households: List[Household], current_time: int
+    ) -> List[Transaction]:
         # SoC Refactor
         return self.finance.distribute_dividends(households, current_time)
 
@@ -621,7 +682,7 @@ class Firm(BaseAgent):
             "assets": self.assets,
             "needs": self.needs.copy(),
             "inventory": self.inventory.copy(),
-            "input_inventory": self.input_inventory.copy(), # WO-030
+            "input_inventory": self.input_inventory.copy(),  # WO-030
             "employees": [emp.id for emp in self.employees],  # Only pass employee IDs
             "is_active": self.is_active,
             "current_production": self.current_production,
@@ -634,19 +695,24 @@ class Firm(BaseAgent):
             "treasury_shares": self.treasury_shares,
             "dividend_rate": self.dividend_rate,
             "capital_stock": self.capital_stock,
-            "base_quality": self.base_quality, # AI needs to know this
+            "base_quality": self.base_quality,  # AI needs to know this
             "inventory_quality": self.inventory_quality.copy(),
-            "automation_level": self.automation_level, # Phase 21
+            "automation_level": self.automation_level,  # Phase 21
         }
 
     def get_pre_state_data(self) -> Dict[str, Any]:
         """AI í•™ìŠµì„ ìœ„í•œ ì´ì „ ìƒíƒœ ë°ì´í„°ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."""
         return getattr(self, "pre_state_snapshot", self.get_agent_data())
 
-
     @override
     def make_decision(
-        self, markets: Dict[str, Any], goods_data: list[Dict[str, Any]], market_data: Dict[str, Any], current_time: int, government: Optional[Any] = None, reflux_system: Optional[Any] = None
+        self,
+        markets: Dict[str, Any],
+        goods_data: list[Dict[str, Any]],
+        market_data: Dict[str, Any],
+        current_time: int,
+        government: Optional[Any] = None,
+        reflux_system: Optional[Any] = None,
     ) -> tuple[list[Order], Any]:
         log_extra = {"tick": current_time, "agent_id": self.id, "tags": ["firm_action"]}
         self.logger.debug(
@@ -684,14 +750,16 @@ class Firm(BaseAgent):
         )
         return decisions, tactic
 
-    def _calculate_invisible_hand_price(self, markets: Dict[str, Any], current_tick: int) -> None:
+    def _calculate_invisible_hand_price(
+        self, markets: Dict[str, Any], current_tick: int
+    ) -> None:
         """
         WO-056: Stage 1 Shadow Mode (Price Discovery 2.0).
         Calculates and logs the shadow price based on Excess Demand.
         """
         market = markets.get(self.specialization)
         # Check if market supports order book inspection
-        if not market or not hasattr(market, 'get_all_bids'):
+        if not market or not hasattr(market, "get_all_bids"):
             return
 
         # 1. Get Demand and Supply (Market-wide for this good)
@@ -730,11 +798,17 @@ class Firm(BaseAgent):
             metric="shadow_price",
             current_value=current_price,
             shadow_value=shadow_price,
-            details=f"Item={self.specialization}, D={demand:.1f}, S={supply:.1f}, Ratio={excess_demand_ratio:.2f}"
+            details=f"Item={self.specialization}, D={demand:.1f}, S={supply:.1f}, Ratio={excess_demand_ratio:.2f}",
         )
 
     @override
-    def update_needs(self, current_time: int, government: Optional[Any] = None, market_data: Optional[Dict[str, Any]] = None, reflux_system: Optional[Any] = None) -> None:
+    def update_needs(
+        self,
+        current_time: int,
+        government: Optional[Any] = None,
+        market_data: Optional[Dict[str, Any]] = None,
+        reflux_system: Optional[Any] = None,
+    ) -> None:
         log_extra = {"tick": current_time, "agent_id": self.id, "tags": ["firm_needs"]}
         self.logger.debug(
             f"FIRM_NEEDS_UPDATE_START | Firm {self.id} needs before update: Liquidity={self.needs['liquidity_need']:.1f}, Assets={self.assets:.2f}, Employees={len(self.employees)}",
@@ -768,24 +842,26 @@ class Firm(BaseAgent):
                 f"Paid total wages: {total_wages:.2f} to {len(self.employees)} employees.",
                 extra={**log_extra, "total_wages": total_wages},
             )
-        
+
         # --- Phase 6: Marketing Spend & Brand Update ---
         # Adaptive Budgeting
         marketing_spend = 0.0
         if self.assets > 100.0:
-            marketing_spend = max(10.0, self.finance.revenue_this_turn * self.marketing_budget_rate)
-        
+            marketing_spend = max(
+                10.0, self.finance.revenue_this_turn * self.marketing_budget_rate
+            )
+
         # Check affordability
         if self.assets < marketing_spend:
-             marketing_spend = 0.0
+            marketing_spend = 0.0
 
         # Apply spend
         if marketing_spend > 0:
-             self.assets -= marketing_spend
-             self.finance.record_expense(marketing_spend)
-             # Phase 8-B: Capture marketing spend (Ad Agency Fee)
-             if reflux_system:
-                 reflux_system.capture(marketing_spend, str(self.id), "marketing")
+            self.assets -= marketing_spend
+            self.finance.record_expense(marketing_spend)
+            # Phase 8-B: Capture marketing spend (Ad Agency Fee)
+            if reflux_system:
+                reflux_system.capture(marketing_spend, str(self.id), "marketing")
 
         # Update state for AI/ROI (Explicitly assign to instance variable)
         self.marketing_budget = marketing_spend
@@ -804,7 +880,9 @@ class Firm(BaseAgent):
             self.finance.pay_taxes(government, current_time)
         # ---------------------------------------------
 
-        brand_premium = self.calculate_brand_premium(market_data) if market_data else 0.0
+        brand_premium = (
+            self.calculate_brand_premium(market_data) if market_data else 0.0
+        )
         self.logger.info(
             f"FIRM_BRAND_METRICS | Firm {self.id}: Awareness={self.brand_manager.brand_awareness:.4f}, "
             f"Quality={self.brand_manager.perceived_quality:.4f}, Premium={brand_premium:.2f}",
@@ -812,8 +890,8 @@ class Firm(BaseAgent):
                 **log_extra,
                 "brand_awareness": self.brand_manager.brand_awareness,
                 "perceived_quality": self.brand_manager.perceived_quality,
-                "brand_premium": brand_premium
-            }
+                "brand_premium": brand_premium,
+            },
         )
 
         self.needs["liquidity_need"] += self.config_module.LIQUIDITY_NEED_INCREASE_RATE
@@ -845,7 +923,7 @@ class Firm(BaseAgent):
                 "num_employees_after": len(self.employees),
                 "is_active_after": self.is_active,
                 "brand_awareness": self.brand_manager.brand_awareness,
-                "perceived_quality": self.brand_manager.perceived_quality
+                "perceived_quality": self.brand_manager.perceived_quality,
             },
         )
 
diff --git a/design/gemini_output/jules_gov_final.py b/design/gemini_output/jules_gov_final.py
index 684a1cd..d5ffe35 100644
--- a/design/gemini_output/jules_gov_final.py
+++ b/design/gemini_output/jules_gov_final.py
@@ -13,6 +13,7 @@ from simulation.systems.ministry_of_education import MinistryOfEducation
 
 logger = logging.getLogger(__name__)
 
+
 class Government:
     """
     ì •ë¶€ ì—ì´ì „íŠ¸. ì„¸ê¸ˆì„ ì§•ìˆ˜í•˜ê³  ë³´ì¡°ê¸ˆì„ ì§€ê¸‰í•˜ê±°ë‚˜ ì¸í”„ë¼ì— íˆ¬ìí•©ë‹ˆë‹¤.
@@ -22,7 +23,7 @@ class Government:
         self.id = id
         self.assets = initial_assets
         self.config_module = config_module
-        
+
         self.tax_agency = TaxAgency(config_module)
         self.ministry_of_education = MinistryOfEducation(config_module)
 
@@ -33,7 +34,7 @@ class Government:
         # Gold Standard Money Tracking
         self.total_money_issued: float = 0.0
         self.total_money_destroyed: float = 0.0
-        
+
         # ì„¸ìˆ˜ ìœ í˜•ë³„ ì§‘ê³„
         self.tax_revenue: Dict[str, float] = {}
 
@@ -45,7 +46,9 @@ class Government:
         # --- Phase 24: Policy Strategy Selection ---
         policy_mode = getattr(config_module, "GOVERNMENT_POLICY_MODE", "TAYLOR_RULE")
         if policy_mode == "AI_ADAPTIVE":
-            self.policy_engine: IGovernmentPolicy = SmartLeviathanPolicy(self, config_module)
+            self.policy_engine: IGovernmentPolicy = SmartLeviathanPolicy(
+                self, config_module
+            )
         else:
             self.policy_engine: IGovernmentPolicy = TaylorRulePolicy(config_module)
 
@@ -53,28 +56,32 @@ class Government:
         self.ai = getattr(self.policy_engine, "ai", None)
 
         # Political State
-        self.ruling_party: PoliticalParty = PoliticalParty.BLUE # Default
+        self.ruling_party: PoliticalParty = PoliticalParty.BLUE  # Default
         self.approval_rating: float = 0.5
-        self.public_opinion_queue: Deque[float] = deque(maxlen=4) # 4-tick lag
+        self.public_opinion_queue: Deque[float] = deque(maxlen=4)  # 4-tick lag
         self.perceived_public_opinion: float = 0.5
         self.last_election_tick: int = 0
 
         # Policy Levers (Tax Rates)
         self.income_tax_rate: float = getattr(config_module, "INCOME_TAX_RATE", 0.1)
-        self.corporate_tax_rate: float = getattr(config_module, "CORPORATE_TAX_RATE", 0.2)
+        self.corporate_tax_rate: float = getattr(
+            config_module, "CORPORATE_TAX_RATE", 0.2
+        )
 
         # Spending Multipliers (AI Controlled)
         # 1.0 = Normal (Budget Neutral-ish), >1.0 = Stimulus, <1.0 = Austerity
         self.welfare_budget_multiplier: float = 1.0
         self.firm_subsidy_budget_multiplier: float = 1.0
 
-        self.effective_tax_rate: float = self.income_tax_rate # Legacy compatibility
+        self.effective_tax_rate: float = self.income_tax_rate  # Legacy compatibility
         self.total_debt: float = 0.0
         # ---------------------------------------------
 
         # History buffers for visualization
-        self.tax_history: List[Dict[str, Any]] = [] # For Stacked Bar Chart (breakdown per tick)
-        self.welfare_history: List[Dict[str, float]] = [] # For Welfare Line Chart
+        self.tax_history: List[
+            Dict[str, Any]
+        ] = []  # For Stacked Bar Chart (breakdown per tick)
+        self.welfare_history: List[Dict[str, float]] = []  # For Welfare Line Chart
         self.history_window_size = 5000
 
         # Current tick accumulators (reset every tick)
@@ -83,13 +90,13 @@ class Government:
             "welfare_spending": 0.0,
             "stimulus_spending": 0.0,
             "total_collected": 0.0,
-            "education_spending": 0.0 # WO-054
+            "education_spending": 0.0,  # WO-054
         }
 
         # GDP Tracking for Stimulus
         self.gdp_history: List[float] = []
         self.gdp_history_window = 20
-        
+
         # WO-056: Shadow Policy Metrics
         ticks_per_year = int(getattr(config_module, "TICKS_PER_YEAR", 100))
         self.price_history_shadow: Deque[float] = deque(maxlen=ticks_per_year)
@@ -97,7 +104,7 @@ class Government:
         self.revenue_this_tick = 0.0
         self.expenditure_this_tick = 0.0
         self.revenue_breakdown_this_tick = {}
-        
+
         self.average_approval_rating = 0.5
 
         # WO-057-B: Sensory Data Container
@@ -119,13 +126,19 @@ class Government:
         if dto.tick % 50 == 0:
             logger.debug(
                 f"SENSORY_UPDATE | Government received macro data. Inflation_SMA: {dto.inflation_sma:.4f}, Approval_SMA: {dto.approval_sma:.2f}",
-                extra={"tick": dto.tick, "agent_id": self.id, "tags": ["sensory", "wo-057-b"]}
+                extra={
+                    "tick": dto.tick,
+                    "agent_id": self.id,
+                    "tags": ["sensory", "wo-057-b"],
+                },
             )
 
     def calculate_income_tax(self, income: float, survival_cost: float) -> float:
         """Delegates income tax calculation to the TaxAgency."""
         tax_mode = getattr(self.config_module, "TAX_MODE", "PROGRESSIVE")
-        return self.tax_agency.calculate_income_tax(income, survival_cost, self.income_tax_rate, tax_mode)
+        return self.tax_agency.calculate_income_tax(
+            income, survival_cost, self.income_tax_rate, tax_mode
+        )
 
     def calculate_corporate_tax(self, profit: float) -> float:
         """Delegates corporate tax calculation to the TaxAgency."""
@@ -137,15 +150,19 @@ class Government:
         ì´ì „ í‹±ì˜ ë°ì´í„°ë¥¼ Historyì— ì €ì¥í•©ë‹ˆë‹¤.
         """
         if getattr(self, "revenue_breakdown_this_tick", None) is None:
-             self.revenue_breakdown_this_tick = {}
+            self.revenue_breakdown_this_tick = {}
 
         self.revenue_this_tick = 0.0
         self.expenditure_this_tick = 0.0
         self.revenue_breakdown_this_tick = {}
 
-    def collect_tax(self, amount: float, tax_type: str, source_id: int, current_tick: int):
+    def collect_tax(
+        self, amount: float, tax_type: str, source_id: int, current_tick: int
+    ):
         """ì„¸ê¸ˆì„ ì§•ìˆ˜í•©ë‹ˆë‹¤."""
-        return self.tax_agency.collect_tax(self, amount, tax_type, source_id, current_tick)
+        return self.tax_agency.collect_tax(
+            self, amount, tax_type, source_id, current_tick
+        )
 
     def update_public_opinion(self, households: List[Any]):
         """
@@ -169,7 +186,7 @@ class Government:
         if len(self.public_opinion_queue) > 0:
             self.perceived_public_opinion = self.public_opinion_queue[0]
 
-        self.approval_rating = avg_approval # Real-time value (for omniscient logging)
+        self.approval_rating = avg_approval  # Real-time value (for omniscient logging)
 
     def check_election(self, current_tick: int):
         """
@@ -184,35 +201,53 @@ class Government:
             if self.perceived_public_opinion < 0.5:
                 # Flip Party
                 old_party = self.ruling_party
-                self.ruling_party = PoliticalParty.RED if old_party == PoliticalParty.BLUE else PoliticalParty.BLUE
+                self.ruling_party = (
+                    PoliticalParty.RED
+                    if old_party == PoliticalParty.BLUE
+                    else PoliticalParty.BLUE
+                )
 
                 logger.warning(
                     f"ELECTION_RESULTS | REGIME CHANGE! {old_party.name} -> {self.ruling_party.name}. Approval: {self.perceived_public_opinion:.2f}",
-                    extra={"tick": current_tick, "agent_id": self.id, "tags": ["election", "regime_change"]}
+                    extra={
+                        "tick": current_tick,
+                        "agent_id": self.id,
+                        "tags": ["election", "regime_change"],
+                    },
                 )
             else:
                 logger.info(
                     f"ELECTION_RESULTS | INCUMBENT VICTORY ({self.ruling_party.name}). Approval: {self.perceived_public_opinion:.2f}",
-                    extra={"tick": current_tick, "agent_id": self.id, "tags": ["election"]}
+                    extra={
+                        "tick": current_tick,
+                        "agent_id": self.id,
+                        "tags": ["election"],
+                    },
                 )
 
-    def make_policy_decision(self, market_data: Dict[str, Any], current_tick: int, central_bank: "CentralBank"):
+    def make_policy_decision(
+        self,
+        market_data: Dict[str, Any],
+        current_tick: int,
+        central_bank: "CentralBank",
+    ):
         """
         ì •ì±… ì—”ì§„ì—ê²Œ ì˜ì‚¬ê²°ì •ì„ ìœ„ì„í•˜ê³  ê²°ê³¼ë¥¼ ë°˜ì˜í•©ë‹ˆë‹¤.
         (ì „ëµ íŒ¨í„´ ì ìš©: Taylor Rule ë˜ëŠ” AI Adaptive)
         """
         # 1. ì •ì±… ì—”ì§„ ì‹¤í–‰ (Actuator ë° Shadow Mode ë¡œì§ í¬í•¨)
         # WO-057-B FIX: Pass the smoothed sensory data, not the raw market_data
-        decision = self.policy_engine.decide(self, self.sensory_data, current_tick, central_bank)
-        
+        decision = self.policy_engine.decide(
+            self, self.sensory_data, current_tick, central_bank
+        )
+
         # 2. ê²°ê³¼ ë¡œê¹… (ì—”ì§„ ë‚´ë¶€ì—ì„œ ìƒì„¸ ë¡œê¹… ìˆ˜í–‰)
         if decision.get("status") == "EXECUTED":
-             logger.debug(
+            logger.debug(
                 f"POLICY_EXECUTED | Tick: {current_tick} | Action: {decision.get('action_taken')}",
-                extra={"tick": current_tick, "agent_id": self.id}
+                extra={"tick": current_tick, "agent_id": self.id},
             )
 
-
         gdp_gap = 0.0
         if self.potential_gdp > 0:
             current_gdp = market_data.get("total_production", 0.0)
@@ -220,7 +255,9 @@ class Government:
 
             # Simple EMA update for Potential GDP
             alpha = 0.01
-            self.potential_gdp = (alpha * current_gdp) + ((1-alpha) * self.potential_gdp)
+            self.potential_gdp = (alpha * current_gdp) + (
+                (1 - alpha) * self.potential_gdp
+            )
 
         # 1. Calculate Inflation (YoY)
         inflation = 0.0
@@ -243,9 +280,14 @@ class Government:
         target_inflation = getattr(self.config_module, "CB_INFLATION_TARGET", 0.02)
 
         # Neutral Rate assumption: Real Growth
-        neutral_rate = max(0.01, real_gdp_growth) # Floor at 1%?
+        neutral_rate = max(0.01, real_gdp_growth)  # Floor at 1%?
 
-        target_rate = neutral_rate + inflation + 0.5 * (inflation - target_inflation) + 0.5 * gdp_gap
+        target_rate = (
+            neutral_rate
+            + inflation
+            + 0.5 * (inflation - target_inflation)
+            + 0.5 * gdp_gap
+        )
 
         # 6. Log
         # Get current base rate from market_data["loan_market"] or similar
@@ -262,10 +304,12 @@ class Government:
             metric="taylor_rule_rate",
             current_value=current_base_rate,
             shadow_value=target_rate,
-            details=f"Inf={inflation:.2%}, Growth={real_gdp_growth:.2%}, Gap={gdp_gap:.2%}, RateGap={gap:.4f}"
+            details=f"Inf={inflation:.2%}, Growth={real_gdp_growth:.2%}, Gap={gdp_gap:.2%}, RateGap={gap:.4f}",
         )
 
-    def provide_household_support(self, household: Any, amount: float, current_tick: int):
+    def provide_household_support(
+        self, household: Any, amount: float, current_tick: int
+    ):
         """Provides subsidies to households (e.g., unemployment, stimulus)."""
         effective_amount = amount * self.welfare_budget_multiplier
 
@@ -284,7 +328,12 @@ class Government:
 
         logger.info(
             f"HOUSEHOLD_SUPPORT | Paid {effective_amount:.2f} to {household.id}",
-            extra={"tick": current_tick, "agent_id": self.id, "amount": effective_amount, "target_id": household.id}
+            extra={
+                "tick": current_tick,
+                "agent_id": self.id,
+                "amount": effective_amount,
+                "target_id": household.id,
+            },
         )
         return effective_amount
 
@@ -296,22 +345,30 @@ class Government:
             self.expenditure_this_tick += amount
             return loan
         else:
-            logger.warning(f"BAILOUT_DENIED | Firm {firm.id} is insolvent and not eligible for a bailout.")
+            logger.warning(
+                f"BAILOUT_DENIED | Firm {firm.id} is insolvent and not eligible for a bailout."
+            )
             return None
 
     def get_survival_cost(self, market_data: Dict[str, Any]) -> float:
-        """ Calculates current survival cost based on food prices. """
+        """Calculates current survival cost based on food prices."""
         avg_food_price = 0.0
         goods_market = market_data.get("goods_market", {})
         if "basic_food_current_sell_price" in goods_market:
             avg_food_price = goods_market["basic_food_current_sell_price"]
         else:
-            avg_food_price = getattr(self.config_module, "GOODS_INITIAL_PRICE", {}).get("basic_food", 5.0)
+            avg_food_price = getattr(self.config_module, "GOODS_INITIAL_PRICE", {}).get(
+                "basic_food", 5.0
+            )
 
-        daily_food_need = getattr(self.config_module, "HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK", 1.0)
+        daily_food_need = getattr(
+            self.config_module, "HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK", 1.0
+        )
         return max(avg_food_price * daily_food_need, 10.0)
 
-    def run_welfare_check(self, agents: List[Any], market_data: Dict[str, Any], current_tick: int):
+    def run_welfare_check(
+        self, agents: List[Any], market_data: Dict[str, Any], current_tick: int
+    ):
         """
         Government Main Loop Step.
         1. Reset Tick Flow.
@@ -343,12 +400,16 @@ class Government:
         survival_cost = self.get_survival_cost(market_data)
 
         # 2. Wealth Tax & Unemployment Benefit
-        wealth_tax_rate_annual = getattr(self.config_module, "ANNUAL_WEALTH_TAX_RATE", 0.02)
+        wealth_tax_rate_annual = getattr(
+            self.config_module, "ANNUAL_WEALTH_TAX_RATE", 0.02
+        )
         ticks_per_year = getattr(self.config_module, "TICKS_PER_YEAR", 100.0)
         wealth_tax_rate_tick = wealth_tax_rate_annual / ticks_per_year
         wealth_threshold = getattr(self.config_module, "WEALTH_TAX_THRESHOLD", 50000.0)
 
-        unemployment_ratio = getattr(self.config_module, "UNEMPLOYMENT_BENEFIT_RATIO", 0.8)
+        unemployment_ratio = getattr(
+            self.config_module, "UNEMPLOYMENT_BENEFIT_RATIO", 0.8
+        )
         benefit_amount = survival_cost * unemployment_ratio
 
         total_wealth_tax = 0.0
@@ -367,7 +428,9 @@ class Government:
                     tax_amount = (net_worth - wealth_threshold) * wealth_tax_rate_tick
                     if agent.assets >= tax_amount:
                         agent.assets -= tax_amount
-                        self.collect_tax(tax_amount, "wealth_tax", agent.id, current_tick)
+                        self.collect_tax(
+                            tax_amount, "wealth_tax", agent.id, current_tick
+                        )
                         total_wealth_tax += tax_amount
                     else:
                         taken = agent.assets
@@ -397,27 +460,37 @@ class Government:
                     should_stimulus = True
 
         if should_stimulus:
-             stimulus_amount = survival_cost * 5.0
-             active_households = [a for a in agents if hasattr(a, "is_employed") and getattr(a, "is_active", False)]
-
-             total_stimulus = 0.0
-             for h in active_households:
-                 paid = self.provide_subsidy(h, stimulus_amount, current_tick)
-                 total_stimulus += paid
-
-             if total_stimulus > 0:
-                 logger.warning(
-                     f"STIMULUS_TRIGGERED | GDP Drop Detected. Paid {total_stimulus:.2f}.",
-                     extra={"tick": current_tick, "agent_id": self.id, "gdp_current": current_gdp}
-                 )
+            stimulus_amount = survival_cost * 5.0
+            active_households = [
+                a
+                for a in agents
+                if hasattr(a, "is_employed") and getattr(a, "is_active", False)
+            ]
+
+            total_stimulus = 0.0
+            for h in active_households:
+                paid = self.provide_subsidy(h, stimulus_amount, current_tick)
+                total_stimulus += paid
+
+            if total_stimulus > 0:
+                logger.warning(
+                    f"STIMULUS_TRIGGERED | GDP Drop Detected. Paid {total_stimulus:.2f}.",
+                    extra={
+                        "tick": current_tick,
+                        "agent_id": self.id,
+                        "gdp_current": current_gdp,
+                    },
+                )
 
-    def invest_infrastructure(self, current_tick: int, reflux_system: Any = None) -> bool:
+    def invest_infrastructure(
+        self, current_tick: int, reflux_system: Any = None
+    ) -> bool:
         """ì¸í”„ë¼ì— íˆ¬ìí•˜ì—¬ ì „ì²´ ìƒì‚°ì„±ì„ í–¥ìƒì‹œí‚µë‹ˆë‹¤."""
         cost = getattr(self.config_module, "INFRASTRUCTURE_INVESTMENT_COST", 5000.0)
-        
+
         # Apply AI Multiplier? Maybe firm subsidy multiplier applies here too?
         # Let's say BLUE party loves infrastructure.
-        effective_cost = cost # Cost is fixed, but decision to buy depends on funds
+        effective_cost = cost  # Cost is fixed, but decision to buy depends on funds
 
         # If multiplier < 1.0 (Austerity), maybe we skip investment?
         if self.firm_subsidy_budget_multiplier < 0.8:
@@ -440,8 +513,8 @@ class Government:
                 "tick": current_tick,
                 "agent_id": self.id,
                 "level": self.infrastructure_level,
-                "tags": ["investment", "infrastructure"]
-            }
+                "tags": ["investment", "infrastructure"],
+            },
         )
         return True
 
@@ -467,9 +540,11 @@ class Government:
             "tick": current_tick,
             "welfare": self.current_tick_stats["welfare_spending"],
             "stimulus": self.current_tick_stats["stimulus_spending"],
-            "education": self.current_tick_stats.get("education_spending", 0.0), # WO-054
+            "education": self.current_tick_stats.get(
+                "education_spending", 0.0
+            ),  # WO-054
             "debt": self.total_debt,
-            "assets": self.assets
+            "assets": self.assets,
         }
         self.welfare_history.append(welfare_snapshot)
         if len(self.welfare_history) > self.history_window_size:
@@ -479,8 +554,8 @@ class Government:
             "tax_revenue": {},
             "welfare_spending": 0.0,
             "stimulus_spending": 0.0,
-            "education_spending": 0.0, # WO-054
-            "total_collected": 0.0
+            "education_spending": 0.0,  # WO-054
+            "total_collected": 0.0,
         }
 
     def get_monetary_delta(self) -> float:
@@ -495,7 +570,7 @@ class Government:
             "approval_rating": self.approval_rating,
             "income_tax_rate": self.income_tax_rate,
             "corporate_tax_rate": self.corporate_tax_rate,
-            "perceived_public_opinion": self.perceived_public_opinion
+            "perceived_public_opinion": self.perceived_public_opinion,
         }
 
     def get_debt_to_gdp_ratio(self) -> float:
@@ -507,9 +582,17 @@ class Government:
         return debt / self.sensory_data.current_gdp
 
     # WO-054: Public Education System
-    def run_public_education(self, agents: List[Any], config_module: Any, current_tick: int, reflux_system: Any = None) -> None:
+    def run_public_education(
+        self,
+        agents: List[Any],
+        config_module: Any,
+        current_tick: int,
+        reflux_system: Any = None,
+    ) -> None:
         """
         Delegates public education logic to the Ministry of Education.
         """
-        households = [a for a in agents if hasattr(a, 'education_level')]
-        self.ministry_of_education.run_public_education(households, self, current_tick, reflux_system)
+        households = [a for a in agents if hasattr(a, "education_level")]
+        self.ministry_of_education.run_public_education(
+            households, self, current_tick, reflux_system
+        )
diff --git a/design/gemini_output/jules_gov_revised.py b/design/gemini_output/jules_gov_revised.py
index 684a1cd..d5ffe35 100644
--- a/design/gemini_output/jules_gov_revised.py
+++ b/design/gemini_output/jules_gov_revised.py
@@ -13,6 +13,7 @@ from simulation.systems.ministry_of_education import MinistryOfEducation
 
 logger = logging.getLogger(__name__)
 
+
 class Government:
     """
     ì •ë¶€ ì—ì´ì „íŠ¸. ì„¸ê¸ˆì„ ì§•ìˆ˜í•˜ê³  ë³´ì¡°ê¸ˆì„ ì§€ê¸‰í•˜ê±°ë‚˜ ì¸í”„ë¼ì— íˆ¬ìí•©ë‹ˆë‹¤.
@@ -22,7 +23,7 @@ class Government:
         self.id = id
         self.assets = initial_assets
         self.config_module = config_module
-        
+
         self.tax_agency = TaxAgency(config_module)
         self.ministry_of_education = MinistryOfEducation(config_module)
 
@@ -33,7 +34,7 @@ class Government:
         # Gold Standard Money Tracking
         self.total_money_issued: float = 0.0
         self.total_money_destroyed: float = 0.0
-        
+
         # ì„¸ìˆ˜ ìœ í˜•ë³„ ì§‘ê³„
         self.tax_revenue: Dict[str, float] = {}
 
@@ -45,7 +46,9 @@ class Government:
         # --- Phase 24: Policy Strategy Selection ---
         policy_mode = getattr(config_module, "GOVERNMENT_POLICY_MODE", "TAYLOR_RULE")
         if policy_mode == "AI_ADAPTIVE":
-            self.policy_engine: IGovernmentPolicy = SmartLeviathanPolicy(self, config_module)
+            self.policy_engine: IGovernmentPolicy = SmartLeviathanPolicy(
+                self, config_module
+            )
         else:
             self.policy_engine: IGovernmentPolicy = TaylorRulePolicy(config_module)
 
@@ -53,28 +56,32 @@ class Government:
         self.ai = getattr(self.policy_engine, "ai", None)
 
         # Political State
-        self.ruling_party: PoliticalParty = PoliticalParty.BLUE # Default
+        self.ruling_party: PoliticalParty = PoliticalParty.BLUE  # Default
         self.approval_rating: float = 0.5
-        self.public_opinion_queue: Deque[float] = deque(maxlen=4) # 4-tick lag
+        self.public_opinion_queue: Deque[float] = deque(maxlen=4)  # 4-tick lag
         self.perceived_public_opinion: float = 0.5
         self.last_election_tick: int = 0
 
         # Policy Levers (Tax Rates)
         self.income_tax_rate: float = getattr(config_module, "INCOME_TAX_RATE", 0.1)
-        self.corporate_tax_rate: float = getattr(config_module, "CORPORATE_TAX_RATE", 0.2)
+        self.corporate_tax_rate: float = getattr(
+            config_module, "CORPORATE_TAX_RATE", 0.2
+        )
 
         # Spending Multipliers (AI Controlled)
         # 1.0 = Normal (Budget Neutral-ish), >1.0 = Stimulus, <1.0 = Austerity
         self.welfare_budget_multiplier: float = 1.0
         self.firm_subsidy_budget_multiplier: float = 1.0
 
-        self.effective_tax_rate: float = self.income_tax_rate # Legacy compatibility
+        self.effective_tax_rate: float = self.income_tax_rate  # Legacy compatibility
         self.total_debt: float = 0.0
         # ---------------------------------------------
 
         # History buffers for visualization
-        self.tax_history: List[Dict[str, Any]] = [] # For Stacked Bar Chart (breakdown per tick)
-        self.welfare_history: List[Dict[str, float]] = [] # For Welfare Line Chart
+        self.tax_history: List[
+            Dict[str, Any]
+        ] = []  # For Stacked Bar Chart (breakdown per tick)
+        self.welfare_history: List[Dict[str, float]] = []  # For Welfare Line Chart
         self.history_window_size = 5000
 
         # Current tick accumulators (reset every tick)
@@ -83,13 +90,13 @@ class Government:
             "welfare_spending": 0.0,
             "stimulus_spending": 0.0,
             "total_collected": 0.0,
-            "education_spending": 0.0 # WO-054
+            "education_spending": 0.0,  # WO-054
         }
 
         # GDP Tracking for Stimulus
         self.gdp_history: List[float] = []
         self.gdp_history_window = 20
-        
+
         # WO-056: Shadow Policy Metrics
         ticks_per_year = int(getattr(config_module, "TICKS_PER_YEAR", 100))
         self.price_history_shadow: Deque[float] = deque(maxlen=ticks_per_year)
@@ -97,7 +104,7 @@ class Government:
         self.revenue_this_tick = 0.0
         self.expenditure_this_tick = 0.0
         self.revenue_breakdown_this_tick = {}
-        
+
         self.average_approval_rating = 0.5
 
         # WO-057-B: Sensory Data Container
@@ -119,13 +126,19 @@ class Government:
         if dto.tick % 50 == 0:
             logger.debug(
                 f"SENSORY_UPDATE | Government received macro data. Inflation_SMA: {dto.inflation_sma:.4f}, Approval_SMA: {dto.approval_sma:.2f}",
-                extra={"tick": dto.tick, "agent_id": self.id, "tags": ["sensory", "wo-057-b"]}
+                extra={
+                    "tick": dto.tick,
+                    "agent_id": self.id,
+                    "tags": ["sensory", "wo-057-b"],
+                },
             )
 
     def calculate_income_tax(self, income: float, survival_cost: float) -> float:
         """Delegates income tax calculation to the TaxAgency."""
         tax_mode = getattr(self.config_module, "TAX_MODE", "PROGRESSIVE")
-        return self.tax_agency.calculate_income_tax(income, survival_cost, self.income_tax_rate, tax_mode)
+        return self.tax_agency.calculate_income_tax(
+            income, survival_cost, self.income_tax_rate, tax_mode
+        )
 
     def calculate_corporate_tax(self, profit: float) -> float:
         """Delegates corporate tax calculation to the TaxAgency."""
@@ -137,15 +150,19 @@ class Government:
         ì´ì „ í‹±ì˜ ë°ì´í„°ë¥¼ Historyì— ì €ì¥í•©ë‹ˆë‹¤.
         """
         if getattr(self, "revenue_breakdown_this_tick", None) is None:
-             self.revenue_breakdown_this_tick = {}
+            self.revenue_breakdown_this_tick = {}
 
         self.revenue_this_tick = 0.0
         self.expenditure_this_tick = 0.0
         self.revenue_breakdown_this_tick = {}
 
-    def collect_tax(self, amount: float, tax_type: str, source_id: int, current_tick: int):
+    def collect_tax(
+        self, amount: float, tax_type: str, source_id: int, current_tick: int
+    ):
         """ì„¸ê¸ˆì„ ì§•ìˆ˜í•©ë‹ˆë‹¤."""
-        return self.tax_agency.collect_tax(self, amount, tax_type, source_id, current_tick)
+        return self.tax_agency.collect_tax(
+            self, amount, tax_type, source_id, current_tick
+        )
 
     def update_public_opinion(self, households: List[Any]):
         """
@@ -169,7 +186,7 @@ class Government:
         if len(self.public_opinion_queue) > 0:
             self.perceived_public_opinion = self.public_opinion_queue[0]
 
-        self.approval_rating = avg_approval # Real-time value (for omniscient logging)
+        self.approval_rating = avg_approval  # Real-time value (for omniscient logging)
 
     def check_election(self, current_tick: int):
         """
@@ -184,35 +201,53 @@ class Government:
             if self.perceived_public_opinion < 0.5:
                 # Flip Party
                 old_party = self.ruling_party
-                self.ruling_party = PoliticalParty.RED if old_party == PoliticalParty.BLUE else PoliticalParty.BLUE
+                self.ruling_party = (
+                    PoliticalParty.RED
+                    if old_party == PoliticalParty.BLUE
+                    else PoliticalParty.BLUE
+                )
 
                 logger.warning(
                     f"ELECTION_RESULTS | REGIME CHANGE! {old_party.name} -> {self.ruling_party.name}. Approval: {self.perceived_public_opinion:.2f}",
-                    extra={"tick": current_tick, "agent_id": self.id, "tags": ["election", "regime_change"]}
+                    extra={
+                        "tick": current_tick,
+                        "agent_id": self.id,
+                        "tags": ["election", "regime_change"],
+                    },
                 )
             else:
                 logger.info(
                     f"ELECTION_RESULTS | INCUMBENT VICTORY ({self.ruling_party.name}). Approval: {self.perceived_public_opinion:.2f}",
-                    extra={"tick": current_tick, "agent_id": self.id, "tags": ["election"]}
+                    extra={
+                        "tick": current_tick,
+                        "agent_id": self.id,
+                        "tags": ["election"],
+                    },
                 )
 
-    def make_policy_decision(self, market_data: Dict[str, Any], current_tick: int, central_bank: "CentralBank"):
+    def make_policy_decision(
+        self,
+        market_data: Dict[str, Any],
+        current_tick: int,
+        central_bank: "CentralBank",
+    ):
         """
         ì •ì±… ì—”ì§„ì—ê²Œ ì˜ì‚¬ê²°ì •ì„ ìœ„ì„í•˜ê³  ê²°ê³¼ë¥¼ ë°˜ì˜í•©ë‹ˆë‹¤.
         (ì „ëµ íŒ¨í„´ ì ìš©: Taylor Rule ë˜ëŠ” AI Adaptive)
         """
         # 1. ì •ì±… ì—”ì§„ ì‹¤í–‰ (Actuator ë° Shadow Mode ë¡œì§ í¬í•¨)
         # WO-057-B FIX: Pass the smoothed sensory data, not the raw market_data
-        decision = self.policy_engine.decide(self, self.sensory_data, current_tick, central_bank)
-        
+        decision = self.policy_engine.decide(
+            self, self.sensory_data, current_tick, central_bank
+        )
+
         # 2. ê²°ê³¼ ë¡œê¹… (ì—”ì§„ ë‚´ë¶€ì—ì„œ ìƒì„¸ ë¡œê¹… ìˆ˜í–‰)
         if decision.get("status") == "EXECUTED":
-             logger.debug(
+            logger.debug(
                 f"POLICY_EXECUTED | Tick: {current_tick} | Action: {decision.get('action_taken')}",
-                extra={"tick": current_tick, "agent_id": self.id}
+                extra={"tick": current_tick, "agent_id": self.id},
             )
 
-
         gdp_gap = 0.0
         if self.potential_gdp > 0:
             current_gdp = market_data.get("total_production", 0.0)
@@ -220,7 +255,9 @@ class Government:
 
             # Simple EMA update for Potential GDP
             alpha = 0.01
-            self.potential_gdp = (alpha * current_gdp) + ((1-alpha) * self.potential_gdp)
+            self.potential_gdp = (alpha * current_gdp) + (
+                (1 - alpha) * self.potential_gdp
+            )
 
         # 1. Calculate Inflation (YoY)
         inflation = 0.0
@@ -243,9 +280,14 @@ class Government:
         target_inflation = getattr(self.config_module, "CB_INFLATION_TARGET", 0.02)
 
         # Neutral Rate assumption: Real Growth
-        neutral_rate = max(0.01, real_gdp_growth) # Floor at 1%?
+        neutral_rate = max(0.01, real_gdp_growth)  # Floor at 1%?
 
-        target_rate = neutral_rate + inflation + 0.5 * (inflation - target_inflation) + 0.5 * gdp_gap
+        target_rate = (
+            neutral_rate
+            + inflation
+            + 0.5 * (inflation - target_inflation)
+            + 0.5 * gdp_gap
+        )
 
         # 6. Log
         # Get current base rate from market_data["loan_market"] or similar
@@ -262,10 +304,12 @@ class Government:
             metric="taylor_rule_rate",
             current_value=current_base_rate,
             shadow_value=target_rate,
-            details=f"Inf={inflation:.2%}, Growth={real_gdp_growth:.2%}, Gap={gdp_gap:.2%}, RateGap={gap:.4f}"
+            details=f"Inf={inflation:.2%}, Growth={real_gdp_growth:.2%}, Gap={gdp_gap:.2%}, RateGap={gap:.4f}",
         )
 
-    def provide_household_support(self, household: Any, amount: float, current_tick: int):
+    def provide_household_support(
+        self, household: Any, amount: float, current_tick: int
+    ):
         """Provides subsidies to households (e.g., unemployment, stimulus)."""
         effective_amount = amount * self.welfare_budget_multiplier
 
@@ -284,7 +328,12 @@ class Government:
 
         logger.info(
             f"HOUSEHOLD_SUPPORT | Paid {effective_amount:.2f} to {household.id}",
-            extra={"tick": current_tick, "agent_id": self.id, "amount": effective_amount, "target_id": household.id}
+            extra={
+                "tick": current_tick,
+                "agent_id": self.id,
+                "amount": effective_amount,
+                "target_id": household.id,
+            },
         )
         return effective_amount
 
@@ -296,22 +345,30 @@ class Government:
             self.expenditure_this_tick += amount
             return loan
         else:
-            logger.warning(f"BAILOUT_DENIED | Firm {firm.id} is insolvent and not eligible for a bailout.")
+            logger.warning(
+                f"BAILOUT_DENIED | Firm {firm.id} is insolvent and not eligible for a bailout."
+            )
             return None
 
     def get_survival_cost(self, market_data: Dict[str, Any]) -> float:
-        """ Calculates current survival cost based on food prices. """
+        """Calculates current survival cost based on food prices."""
         avg_food_price = 0.0
         goods_market = market_data.get("goods_market", {})
         if "basic_food_current_sell_price" in goods_market:
             avg_food_price = goods_market["basic_food_current_sell_price"]
         else:
-            avg_food_price = getattr(self.config_module, "GOODS_INITIAL_PRICE", {}).get("basic_food", 5.0)
+            avg_food_price = getattr(self.config_module, "GOODS_INITIAL_PRICE", {}).get(
+                "basic_food", 5.0
+            )
 
-        daily_food_need = getattr(self.config_module, "HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK", 1.0)
+        daily_food_need = getattr(
+            self.config_module, "HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK", 1.0
+        )
         return max(avg_food_price * daily_food_need, 10.0)
 
-    def run_welfare_check(self, agents: List[Any], market_data: Dict[str, Any], current_tick: int):
+    def run_welfare_check(
+        self, agents: List[Any], market_data: Dict[str, Any], current_tick: int
+    ):
         """
         Government Main Loop Step.
         1. Reset Tick Flow.
@@ -343,12 +400,16 @@ class Government:
         survival_cost = self.get_survival_cost(market_data)
 
         # 2. Wealth Tax & Unemployment Benefit
-        wealth_tax_rate_annual = getattr(self.config_module, "ANNUAL_WEALTH_TAX_RATE", 0.02)
+        wealth_tax_rate_annual = getattr(
+            self.config_module, "ANNUAL_WEALTH_TAX_RATE", 0.02
+        )
         ticks_per_year = getattr(self.config_module, "TICKS_PER_YEAR", 100.0)
         wealth_tax_rate_tick = wealth_tax_rate_annual / ticks_per_year
         wealth_threshold = getattr(self.config_module, "WEALTH_TAX_THRESHOLD", 50000.0)
 
-        unemployment_ratio = getattr(self.config_module, "UNEMPLOYMENT_BENEFIT_RATIO", 0.8)
+        unemployment_ratio = getattr(
+            self.config_module, "UNEMPLOYMENT_BENEFIT_RATIO", 0.8
+        )
         benefit_amount = survival_cost * unemployment_ratio
 
         total_wealth_tax = 0.0
@@ -367,7 +428,9 @@ class Government:
                     tax_amount = (net_worth - wealth_threshold) * wealth_tax_rate_tick
                     if agent.assets >= tax_amount:
                         agent.assets -= tax_amount
-                        self.collect_tax(tax_amount, "wealth_tax", agent.id, current_tick)
+                        self.collect_tax(
+                            tax_amount, "wealth_tax", agent.id, current_tick
+                        )
                         total_wealth_tax += tax_amount
                     else:
                         taken = agent.assets
@@ -397,27 +460,37 @@ class Government:
                     should_stimulus = True
 
         if should_stimulus:
-             stimulus_amount = survival_cost * 5.0
-             active_households = [a for a in agents if hasattr(a, "is_employed") and getattr(a, "is_active", False)]
-
-             total_stimulus = 0.0
-             for h in active_households:
-                 paid = self.provide_subsidy(h, stimulus_amount, current_tick)
-                 total_stimulus += paid
-
-             if total_stimulus > 0:
-                 logger.warning(
-                     f"STIMULUS_TRIGGERED | GDP Drop Detected. Paid {total_stimulus:.2f}.",
-                     extra={"tick": current_tick, "agent_id": self.id, "gdp_current": current_gdp}
-                 )
+            stimulus_amount = survival_cost * 5.0
+            active_households = [
+                a
+                for a in agents
+                if hasattr(a, "is_employed") and getattr(a, "is_active", False)
+            ]
+
+            total_stimulus = 0.0
+            for h in active_households:
+                paid = self.provide_subsidy(h, stimulus_amount, current_tick)
+                total_stimulus += paid
+
+            if total_stimulus > 0:
+                logger.warning(
+                    f"STIMULUS_TRIGGERED | GDP Drop Detected. Paid {total_stimulus:.2f}.",
+                    extra={
+                        "tick": current_tick,
+                        "agent_id": self.id,
+                        "gdp_current": current_gdp,
+                    },
+                )
 
-    def invest_infrastructure(self, current_tick: int, reflux_system: Any = None) -> bool:
+    def invest_infrastructure(
+        self, current_tick: int, reflux_system: Any = None
+    ) -> bool:
         """ì¸í”„ë¼ì— íˆ¬ìí•˜ì—¬ ì „ì²´ ìƒì‚°ì„±ì„ í–¥ìƒì‹œí‚µë‹ˆë‹¤."""
         cost = getattr(self.config_module, "INFRASTRUCTURE_INVESTMENT_COST", 5000.0)
-        
+
         # Apply AI Multiplier? Maybe firm subsidy multiplier applies here too?
         # Let's say BLUE party loves infrastructure.
-        effective_cost = cost # Cost is fixed, but decision to buy depends on funds
+        effective_cost = cost  # Cost is fixed, but decision to buy depends on funds
 
         # If multiplier < 1.0 (Austerity), maybe we skip investment?
         if self.firm_subsidy_budget_multiplier < 0.8:
@@ -440,8 +513,8 @@ class Government:
                 "tick": current_tick,
                 "agent_id": self.id,
                 "level": self.infrastructure_level,
-                "tags": ["investment", "infrastructure"]
-            }
+                "tags": ["investment", "infrastructure"],
+            },
         )
         return True
 
@@ -467,9 +540,11 @@ class Government:
             "tick": current_tick,
             "welfare": self.current_tick_stats["welfare_spending"],
             "stimulus": self.current_tick_stats["stimulus_spending"],
-            "education": self.current_tick_stats.get("education_spending", 0.0), # WO-054
+            "education": self.current_tick_stats.get(
+                "education_spending", 0.0
+            ),  # WO-054
             "debt": self.total_debt,
-            "assets": self.assets
+            "assets": self.assets,
         }
         self.welfare_history.append(welfare_snapshot)
         if len(self.welfare_history) > self.history_window_size:
@@ -479,8 +554,8 @@ class Government:
             "tax_revenue": {},
             "welfare_spending": 0.0,
             "stimulus_spending": 0.0,
-            "education_spending": 0.0, # WO-054
-            "total_collected": 0.0
+            "education_spending": 0.0,  # WO-054
+            "total_collected": 0.0,
         }
 
     def get_monetary_delta(self) -> float:
@@ -495,7 +570,7 @@ class Government:
             "approval_rating": self.approval_rating,
             "income_tax_rate": self.income_tax_rate,
             "corporate_tax_rate": self.corporate_tax_rate,
-            "perceived_public_opinion": self.perceived_public_opinion
+            "perceived_public_opinion": self.perceived_public_opinion,
         }
 
     def get_debt_to_gdp_ratio(self) -> float:
@@ -507,9 +582,17 @@ class Government:
         return debt / self.sensory_data.current_gdp
 
     # WO-054: Public Education System
-    def run_public_education(self, agents: List[Any], config_module: Any, current_tick: int, reflux_system: Any = None) -> None:
+    def run_public_education(
+        self,
+        agents: List[Any],
+        config_module: Any,
+        current_tick: int,
+        reflux_system: Any = None,
+    ) -> None:
         """
         Delegates public education logic to the Ministry of Education.
         """
-        households = [a for a in agents if hasattr(a, 'education_level')]
-        self.ministry_of_education.run_public_education(households, self, current_tick, reflux_system)
+        households = [a for a in agents if hasattr(a, "education_level")]
+        self.ministry_of_education.run_public_education(
+            households, self, current_tick, reflux_system
+        )
diff --git a/design/gemini_output/jules_hr_final.py b/design/gemini_output/jules_hr_final.py
index 862c2da..8a0dbcd 100644
--- a/design/gemini_output/jules_hr_final.py
+++ b/design/gemini_output/jules_hr_final.py
@@ -8,11 +8,13 @@ if TYPE_CHECKING:
 
 logger = logging.getLogger(__name__)
 
+
 class HRDepartment:
     """
     Manages employees, calculates wages (skill + halo), and handles insolvency firing.
     Extracted from Firm class (SoC Refactor).
     """
+
     def __init__(self, firm: Firm):
         self.firm = firm
         self.employees: List[Household] = []
@@ -24,15 +26,22 @@ class HRDepartment:
         Calculates wage based on skill and halo effect.
         """
         # WO-023-B: Skill-based Wage Bonus
-        actual_skill = getattr(employee, 'labor_skill', 1.0)
+        actual_skill = getattr(employee, "labor_skill", 1.0)
 
         # WO-Sociologist: Halo Effect (Credential Premium)
-        education_level = getattr(employee, 'education_level', 0)
-        halo_modifier = 1.0 + (education_level * getattr(self.firm.config_module, "HALO_EFFECT", 0.0))
+        education_level = getattr(employee, "education_level", 0)
+        halo_modifier = 1.0 + (
+            education_level * getattr(self.firm.config_module, "HALO_EFFECT", 0.0)
+        )
 
         return base_wage * actual_skill * halo_modifier
 
-    def process_payroll(self, current_time: int, government: Optional[Any], market_data: Optional[Dict[str, Any]]) -> float:
+    def process_payroll(
+        self,
+        current_time: int,
+        government: Optional[Any],
+        market_data: Optional[Dict[str, Any]],
+    ) -> float:
         """
         Pays wages to employees. Handles insolvency firing if assets are insufficient.
         Returns total wages paid.
@@ -41,14 +50,16 @@ class HRDepartment:
         total_tax_withheld = 0.0
 
         # Calculate survival cost for tax logic
-        survival_cost = 10.0 # Default fallback
+        survival_cost = 10.0  # Default fallback
         if government and market_data:
             survival_cost = government.get_survival_cost(market_data)
 
         # Iterate over copy to allow modification
         for employee in list(self.employees):
             # Defensive checks
-            if not hasattr(employee, 'employer_id') or not hasattr(employee, 'is_employed'):
+            if not hasattr(employee, "employer_id") or not hasattr(
+                employee, "is_employed"
+            ):
                 self.employees.remove(employee)
                 continue
 
@@ -58,7 +69,9 @@ class HRDepartment:
                     del self.employee_wages[employee.id]
                 continue
 
-            base_wage = self.employee_wages.get(employee.id, self.firm.config_module.LABOR_MARKET_MIN_WAGE)
+            base_wage = self.employee_wages.get(
+                employee.id, self.firm.config_module.LABOR_MARKET_MIN_WAGE
+            )
             wage = self.calculate_wage(employee, base_wage)
 
             # Affordability Check
@@ -79,7 +92,9 @@ class HRDepartment:
                     employee.labor_income_this_tick += net_wage
 
                 if income_tax > 0 and government:
-                    government.collect_tax(income_tax, "income_tax", employee.id, current_time)
+                    government.collect_tax(
+                        income_tax, "income_tax", employee.id, current_time
+                    )
                     total_tax_withheld += income_tax
 
                 total_wages += wage
@@ -104,7 +119,13 @@ class HRDepartment:
 
             self.firm.logger.info(
                 f"SEVERANCE | Firm {self.firm.id} paid severance {severance_pay:.2f} to Household {employee.id}. Firing due to insolvency.",
-                extra={"tick": self.firm.decision_engine.context.current_time if hasattr(self.firm.decision_engine, 'context') else 0, "agent_id": self.firm.id, "severance_pay": severance_pay}
+                extra={
+                    "tick": self.firm.decision_engine.context.current_time
+                    if hasattr(self.firm.decision_engine, "context")
+                    else 0,
+                    "agent_id": self.firm.id,
+                    "severance_pay": severance_pay,
+                },
             )
 
             employee.quit()
@@ -113,7 +134,11 @@ class HRDepartment:
             # Zombie Employee
             self.firm.logger.warning(
                 f"ZOMBIE | Firm {self.firm.id} cannot afford wage OR severance for Household {employee.id}. Employment retained (unpaid).",
-                extra={"tick": 0, "agent_id": self.firm.id, "wage_deficit": wage - self.firm.assets}
+                extra={
+                    "tick": 0,
+                    "agent_id": self.firm.id,
+                    "wage_deficit": wage - self.firm.assets,
+                },
             )
 
     def hire(self, employee: Household, wage: float):
@@ -128,7 +153,7 @@ class HRDepartment:
             del self.employee_wages[employee.id]
 
     def get_total_labor_skill(self) -> float:
-        return sum(getattr(emp, 'labor_skill', 1.0) for emp in self.employees)
+        return sum(getattr(emp, "labor_skill", 1.0) for emp in self.employees)
 
     def get_avg_skill(self) -> float:
         if not self.employees:
diff --git a/design/gemini_output/jules_system_final.py b/design/gemini_output/jules_system_final.py
index a26556f..1ca5bcc 100644
--- a/design/gemini_output/jules_system_final.py
+++ b/design/gemini_output/jules_system_final.py
@@ -1,26 +1,38 @@
 from typing import List, Dict
 from modules.finance.api import IFinanceSystem, BondDTO, BailoutLoanDTO
+
 # Forward reference for type hinting
 from simulation.firms import Firm
 
+
 class FinanceSystem(IFinanceSystem):
     """Manages sovereign debt, corporate bailouts, and solvency checks."""
 
-    def __init__(self, government: 'Government', central_bank: 'CentralBank', bank: 'Bank', config_module: any):
+    def __init__(
+        self,
+        government: "Government",
+        central_bank: "CentralBank",
+        bank: "Bank",
+        config_module: any,
+    ):
         self.government = government
         self.central_bank = central_bank
         self.bank = bank
         self.config_module = config_module
         self.outstanding_bonds: List[BondDTO] = []
 
-    def evaluate_solvency(self, firm: 'Firm', current_tick: int) -> bool:
+    def evaluate_solvency(self, firm: "Firm", current_tick: int) -> bool:
         """
         Evaluates a firm's solvency to determine bailout eligibility.
         - Startups (< 24 ticks old) are checked for a 3-month wage runway.
         - Established firms are evaluated using the Altman Z-Score.
         """
-        startup_grace_period = getattr(self.config_module, "STARTUP_GRACE_PERIOD_TICKS", 24)
-        z_score_threshold = getattr(self.config_module, "ALTMAN_Z_SCORE_THRESHOLD", 1.81)
+        startup_grace_period = getattr(
+            self.config_module, "STARTUP_GRACE_PERIOD_TICKS", 24
+        )
+        z_score_threshold = getattr(
+            self.config_module, "ALTMAN_Z_SCORE_THRESHOLD", 1.81
+        )
 
         if firm.age < startup_grace_period:
             # Runway Check for startups
@@ -41,11 +53,15 @@ class FinanceSystem(IFinanceSystem):
         debt_to_gdp = self.government.get_debt_to_gdp_ratio()
 
         # Config-driven risk premium tiers
-        risk_premium_tiers = getattr(self.config_module, "DEBT_RISK_PREMIUM_TIERS", {
-            1.2: 0.05,
-            0.9: 0.02,
-            0.6: 0.005,
-        })
+        risk_premium_tiers = getattr(
+            self.config_module,
+            "DEBT_RISK_PREMIUM_TIERS",
+            {
+                1.2: 0.05,
+                0.9: 0.02,
+                0.6: 0.005,
+            },
+        )
 
         risk_premium = 0.0
         for threshold, premium in sorted(risk_premium_tiers.items(), reverse=True):
@@ -61,10 +77,12 @@ class FinanceSystem(IFinanceSystem):
             issuer="GOVERNMENT",
             face_value=amount,
             yield_rate=yield_rate,
-            maturity_date=current_tick + bond_maturity
+            maturity_date=current_tick + bond_maturity,
         )
 
-        qe_threshold = getattr(self.config_module, "QE_INTERVENTION_YIELD_THRESHOLD", 0.10)
+        qe_threshold = getattr(
+            self.config_module, "QE_INTERVENTION_YIELD_THRESHOLD", 0.10
+        )
         if yield_rate > qe_threshold:
             # Central Bank intervenes as buyer of last resort
             self.central_bank.purchase_bonds(new_bond)
@@ -82,7 +100,7 @@ class FinanceSystem(IFinanceSystem):
 
         return [new_bond]
 
-    def grant_bailout_loan(self, firm: 'Firm', amount: float) -> BailoutLoanDTO:
+    def grant_bailout_loan(self, firm: "Firm", amount: float) -> BailoutLoanDTO:
         """Converts a bailout from a grant to an interest-bearing senior loan."""
         base_rate = self.central_bank.get_interest_rate()
         penalty_premium = getattr(self.config_module, "BAILOUT_PENALTY_PREMIUM", 0.05)
@@ -94,8 +112,8 @@ class FinanceSystem(IFinanceSystem):
             covenants={
                 "dividends_allowed": False,
                 "executive_salary_freeze": True,
-                "mandatory_repayment": 0.5
-            }
+                "mandatory_repayment": 0.5,
+            },
         )
 
         # The government provides the funds, which become a liability for the firm
@@ -104,12 +122,13 @@ class FinanceSystem(IFinanceSystem):
 
         return loan
 
-
     def service_debt(self, current_tick: int) -> None:
         """Manages the servicing of outstanding government debt."""
         # This is a simplified version. A real implementation would handle interest payments
         # and bond maturation.
-        matured_bonds = [b for b in self.outstanding_bonds if b.maturity_date <= current_tick]
+        matured_bonds = [
+            b for b in self.outstanding_bonds if b.maturity_date <= current_tick
+        ]
         for bond in matured_bonds:
             self.government.assets -= bond.face_value
             self.outstanding_bonds.remove(bond)
diff --git a/design/gemini_output/jules_system_revised.py b/design/gemini_output/jules_system_revised.py
index eca631e..97ea91d 100644
--- a/design/gemini_output/jules_system_revised.py
+++ b/design/gemini_output/jules_system_revised.py
@@ -1,25 +1,33 @@
 from typing import List, Dict
 from modules.finance.api import IFinanceSystem, BondDTO, BailoutLoanDTO
+
 # Forward reference for type hinting
 from simulation.firms import Firm
 
+
 class FinanceSystem(IFinanceSystem):
     """Manages sovereign debt, corporate bailouts, and solvency checks."""
 
-    def __init__(self, government: 'Government', central_bank: 'CentralBank', config_module: any):
+    def __init__(
+        self, government: "Government", central_bank: "CentralBank", config_module: any
+    ):
         self.government = government
         self.central_bank = central_bank
         self.config_module = config_module
         self.outstanding_bonds: List[BondDTO] = []
 
-    def evaluate_solvency(self, firm: 'Firm', current_tick: int) -> bool:
+    def evaluate_solvency(self, firm: "Firm", current_tick: int) -> bool:
         """
         Evaluates a firm's solvency to determine bailout eligibility.
         - Startups (< 24 ticks old) are checked for a 3-month wage runway.
         - Established firms are evaluated using the Altman Z-Score.
         """
-        startup_grace_period = getattr(self.config_module, "STARTUP_GRACE_PERIOD_TICKS", 24)
-        z_score_threshold = getattr(self.config_module, "ALTMAN_Z_SCORE_THRESHOLD", 1.81)
+        startup_grace_period = getattr(
+            self.config_module, "STARTUP_GRACE_PERIOD_TICKS", 24
+        )
+        z_score_threshold = getattr(
+            self.config_module, "ALTMAN_Z_SCORE_THRESHOLD", 1.81
+        )
 
         if firm.age < startup_grace_period:
             # Runway Check for startups
@@ -40,11 +48,15 @@ class FinanceSystem(IFinanceSystem):
         debt_to_gdp = self.government.get_debt_to_gdp_ratio()
 
         # Config-driven risk premium tiers
-        risk_premium_tiers = getattr(self.config_module, "DEBT_RISK_PREMIUM_TIERS", {
-            1.2: 0.05,
-            0.9: 0.02,
-            0.6: 0.005,
-        })
+        risk_premium_tiers = getattr(
+            self.config_module,
+            "DEBT_RISK_PREMIUM_TIERS",
+            {
+                1.2: 0.05,
+                0.9: 0.02,
+                0.6: 0.005,
+            },
+        )
 
         risk_premium = 0.0
         for threshold, premium in sorted(risk_premium_tiers.items(), reverse=True):
@@ -60,10 +72,12 @@ class FinanceSystem(IFinanceSystem):
             issuer="GOVERNMENT",
             face_value=amount,
             yield_rate=yield_rate,
-            maturity_date=current_tick + bond_maturity
+            maturity_date=current_tick + bond_maturity,
         )
 
-        qe_threshold = getattr(self.config_module, "QE_INTERVENTION_YIELD_THRESHOLD", 0.10)
+        qe_threshold = getattr(
+            self.config_module, "QE_INTERVENTION_YIELD_THRESHOLD", 0.10
+        )
         if yield_rate > qe_threshold:
             # Central Bank intervenes as buyer of last resort
             self.central_bank.purchase_bonds(new_bond)
@@ -77,7 +91,7 @@ class FinanceSystem(IFinanceSystem):
 
         return [new_bond]
 
-    def grant_bailout_loan(self, firm: 'Firm', amount: float) -> BailoutLoanDTO:
+    def grant_bailout_loan(self, firm: "Firm", amount: float) -> BailoutLoanDTO:
         """Converts a bailout from a grant to an interest-bearing senior loan."""
         base_rate = self.central_bank.get_interest_rate()
         penalty_premium = getattr(self.config_module, "BAILOUT_PENALTY_PREMIUM", 0.05)
@@ -89,8 +103,8 @@ class FinanceSystem(IFinanceSystem):
             covenants={
                 "dividends_allowed": False,
                 "executive_salary_freeze": True,
-                "mandatory_repayment": 0.5
-            }
+                "mandatory_repayment": 0.5,
+            },
         )
 
         # The government provides the funds, which become a liability for the firm
@@ -99,12 +113,13 @@ class FinanceSystem(IFinanceSystem):
 
         return loan
 
-
     def service_debt(self, current_tick: int) -> None:
         """Manages the servicing of outstanding government debt."""
         # This is a simplified version. A real implementation would handle interest payments
         # and bond maturation.
-        matured_bonds = [b for b in self.outstanding_bonds if b.maturity_date <= current_tick]
+        matured_bonds = [
+            b for b in self.outstanding_bonds if b.maturity_date <= current_tick
+        ]
         for bond in matured_bonds:
             self.government.assets -= bond.face_value
             self.outstanding_bonds.remove(bond)
diff --git a/experiments/run_lab_laffer.py b/experiments/run_lab_laffer.py
index 4684d5d..6501946 100644
--- a/experiments/run_lab_laffer.py
+++ b/experiments/run_lab_laffer.py
@@ -11,6 +11,7 @@ Usage:
 Output:
     results/laffer_experiment.csv
 """
+
 import csv
 import os
 import sys
@@ -56,14 +57,14 @@ def create_config_overrides(tax_rate: float) -> Dict[str, Any]:
 def run_single_experiment(tax_rate: float) -> Dict[str, float]:
     """
     Run a single simulation with the given tax rate.
-    
+
     Returns:
         Dict with experiment results.
     """
-    print(f"\n{'='*60}")
+    print(f"\n{'=' * 60}")
     print(f"Running experiment with tax_rate={tax_rate:.1%}")
-    print(f"{'='*60}")
-    
+    print(f"{'=' * 60}")
+
     # Create simulation with overrides
     overrides = create_config_overrides(tax_rate)
     try:
@@ -77,9 +78,9 @@ def run_single_experiment(tax_rate: float) -> Dict[str, float]:
             "avg_child_xp": 0.0,
             "avg_leisure_hours": 0.0,
             "parenting_count": 0,
-            "error": str(e)
+            "error": str(e),
         }
-    
+
     # Track accumulated metrics for averaging
     accumulated_work_hours = 0.0
     accumulated_leisure_hours = 0.0
@@ -102,37 +103,41 @@ def run_single_experiment(tax_rate: float) -> Dict[str, float]:
                 if agent.is_active:
                     active_households += 1
                     leisure = allocation_map.get(agent.id, 0.0)
-                    work = max(0.0, config.HOURS_PER_TICK - leisure - config.SHOPPING_HOURS)
+                    work = max(
+                        0.0, config.HOURS_PER_TICK - leisure - config.SHOPPING_HOURS
+                    )
 
                     tick_work_hours += work
                     tick_leisure_hours += leisure
 
             if active_households > 0:
-                accumulated_work_hours += (tick_work_hours / active_households)
-                accumulated_leisure_hours += (tick_leisure_hours / active_households)
+                accumulated_work_hours += tick_work_hours / active_households
+                accumulated_leisure_hours += tick_leisure_hours / active_households
                 accumulated_samples += 1
 
         if tick % 100 == 0:
             print(f"  Tick {tick}/{TICKS_PER_RUN}")
-    
+
     # Calculate final metrics
-    total_revenue = sim.government.total_collected_tax if hasattr(sim, 'government') else 0.0
-    
+    total_revenue = (
+        sim.government.total_collected_tax if hasattr(sim, "government") else 0.0
+    )
+
     avg_work_hours = accumulated_work_hours / max(accumulated_samples, 1)
     avg_leisure_hours = accumulated_leisure_hours / max(accumulated_samples, 1)
 
     # Calculate Child XP (Snapshotted at end)
     total_child_xp = 0.0
     child_count = 0
-    
+
     # Assuming children are households with parents? Or specific logic.
     # The prompt implies avg_child_xp. Let's look at all active households.
     # Actually, children are agents.
     for agent in sim.households:
-        if agent.is_active and hasattr(agent, 'education_xp'):
+        if agent.is_active and hasattr(agent, "education_xp"):
             total_child_xp += agent.education_xp
             child_count += 1
-            
+
     avg_child_xp = total_child_xp / max(child_count, 1)
 
     # Parenting count isn't explicitly tracked in global counters,
@@ -141,15 +146,15 @@ def run_single_experiment(tax_rate: float) -> Dict[str, float]:
     # The prompt expects: tax_rate,total_revenue,avg_work_hours,avg_child_xp
 
     # Cleanup
-    sim.finalize_simulation() # Close DB connections
+    sim.finalize_simulation()  # Close DB connections
     del sim
-    
+
     return {
         "tax_rate": tax_rate,
         "total_revenue": total_revenue,
         "avg_work_hours": avg_work_hours,
         "avg_leisure_hours": avg_leisure_hours,
-        "avg_child_xp": avg_child_xp
+        "avg_child_xp": avg_child_xp,
     }
 
 
@@ -162,41 +167,43 @@ def main():
     print(f"Ticks per Run: {TICKS_PER_RUN}")
     print(f"Random Seed: {RANDOM_SEED}")
     print()
-    
+
     # Create output directory
     os.makedirs(OUTPUT_DIR, exist_ok=True)
     output_path = os.path.join(OUTPUT_DIR, OUTPUT_FILE)
-    
+
     # Run experiments
     results: List[Dict[str, Any]] = []
-    
+
     for tax_rate in TAX_RATES:
         result = run_single_experiment(tax_rate)
         results.append(result)
         print(f"Result: Revenue={result.get('total_revenue', 0):.2f}")
-    
+
     # Write CSV
     if results:
         fieldnames = ["tax_rate", "total_revenue", "avg_work_hours", "avg_child_xp"]
         # Filter keys to match expected output if needed, or just include all useful ones
 
-        with open(output_path, 'w', newline='', encoding='utf-8') as f:
-            writer = csv.DictWriter(f, fieldnames=fieldnames, extrasaction='ignore')
+        with open(output_path, "w", newline="", encoding="utf-8") as f:
+            writer = csv.DictWriter(f, fieldnames=fieldnames, extrasaction="ignore")
             writer.writeheader()
             writer.writerows(results)
-        
-        print(f"\n{'='*60}")
+
+        print(f"\n{'=' * 60}")
         print(f"Experiment Complete!")
         print(f"Results saved to: {output_path}")
-        print(f"{'='*60}")
-    
+        print(f"{'=' * 60}")
+
     # Print summary table
     print("\nSUMMARY:")
     print("-" * 60)
     print(f"{'Tax Rate':<12} {'Revenue':<15} {'Avg Work Hrs':<15} {'Avg Child XP':<15}")
     print("-" * 60)
     for r in results:
-        print(f"{r.get('tax_rate', 0):<12.1%} {r.get('total_revenue', 0):<15.2f} {r.get('avg_work_hours', 0):<15.2f} {r.get('avg_child_xp', 0):<15.2f}")
+        print(
+            f"{r.get('tax_rate', 0):<12.1%} {r.get('total_revenue', 0):<15.2f} {r.get('avg_work_hours', 0):<15.2f} {r.get('avg_child_xp', 0):<15.2f}"
+        )
 
 
 if __name__ == "__main__":
diff --git a/main.py b/main.py
index 0ffae3b..58f9072 100644
--- a/main.py
+++ b/main.py
@@ -28,7 +28,7 @@ main_logger = logging.getLogger(__name__)
 
 # --- Setup Logging ---
 setup_logging()  # Call the setup function
-logging.getLogger().setLevel(logging.DEBUG) # Force DEBUG level for all loggers
+logging.getLogger().setLevel(logging.DEBUG)  # Force DEBUG level for all loggers
 
 # Get the SamplingFilter instance and set sampling rates
 sampling_filter: SamplingFilter | None = None
@@ -69,7 +69,7 @@ def create_simulation(overrides: Dict[str, Any] = None) -> Simulation:
 
     # Seed for reproducibility
     if hasattr(config, "RANDOM_SEED"):
-         random.seed(config.RANDOM_SEED)
+        random.seed(config.RANDOM_SEED)
 
     # Initialize the SimulationRepository for this simulation run
     repository = SimulationRepository()
@@ -166,7 +166,9 @@ def create_simulation(overrides: Dict[str, Any] = None) -> Simulation:
 
         # Instantiate HouseholdAI
         ai_decision_engine_instance = ai_trainer.get_engine(value_orientation)
-        household_ai_instance = HouseholdAI(agent_id=i, ai_decision_engine=ai_decision_engine_instance)
+        household_ai_instance = HouseholdAI(
+            agent_id=i, ai_decision_engine=ai_decision_engine_instance
+        )
 
         # Instantiate HouseholdDecisionEngine with the HouseholdAI instance and config_module
         household_decision_engine = AIDrivenHouseholdDecisionEngine(
@@ -181,7 +183,9 @@ def create_simulation(overrides: Dict[str, Any] = None) -> Simulation:
 
         household = Household(
             id=i,
-            talent=Talent(max(0.5, random.gauss(1.0, 0.2)), {}), # WO-023-B: The Lottery of Birth
+            talent=Talent(
+                max(0.5, random.gauss(1.0, 0.2)), {}
+            ),  # WO-023-B: The Lottery of Birth
             goods_data=goods_data,
             initial_assets=initial_assets,
             initial_needs=initial_needs,
@@ -270,19 +274,19 @@ def create_simulation(overrides: Dict[str, Any] = None) -> Simulation:
         founder_household = households[firm.id % num_households]
         firm.owner_id = founder_household.id
         firm.founder_id = founder_household.id
-        
+
         # Add to portfolio
         if hasattr(founder_household, "portfolio"):
             # Portfolio is now a Portfolio object, not a list.
             # Initially, all shares are treasury shares, so we don't add them to the founder's portfolio yet.
             # They are registered as owner/founder in the firm object itself.
             pass
-            
+
         firm_founders[firm.id] = founder_household.id
 
         # Removed legacy share distribution. Firms hold 100% treasury shares initially.
         # Registration in StockMarket is handled by Simulation.init_ipo.
-            
+
     num_to_employ = int(num_households * config.INITIAL_EMPLOYMENT_RATE)
     unemployed_households = list(households)
     random.shuffle(unemployed_households)
@@ -340,7 +344,7 @@ def run_simulation(
 
     original_initial_firm_inventory_mean = None
     if initial_firm_inventory_mean is not None:
-         original_initial_firm_inventory_mean = config.INITIAL_FIRM_INVENTORY_MEAN
+        original_initial_firm_inventory_mean = config.INITIAL_FIRM_INVENTORY_MEAN
 
     sim = create_simulation(overrides=overrides)
 
diff --git a/modules/analysis/crisis_monitor.py b/modules/analysis/crisis_monitor.py
index 65adf50..2365825 100644
--- a/modules/analysis/crisis_monitor.py
+++ b/modules/analysis/crisis_monitor.py
@@ -8,6 +8,7 @@ from modules.finance.domain.corporate_finance import AltmanZScoreCalculator
 if TYPE_CHECKING:
     from simulation.firms import Firm
 
+
 class CrisisMonitor:
     """
     Monitors the financial health of firms and tracks the progression of a crisis.
@@ -44,12 +45,21 @@ class CrisisMonitor:
         os.makedirs("reports", exist_ok=True)
 
         # Initialize CSV
-        with open(self.log_file, 'w', newline='') as f:
+        with open(self.log_file, "w", newline="") as f:
             writer = csv.writer(f)
-            writer.writerow(["tick", "safe_count", "gray_count", "distress_count", "total_active_firms", "survival_rate"])
+            writer.writerow(
+                [
+                    "tick",
+                    "safe_count",
+                    "gray_count",
+                    "distress_count",
+                    "total_active_firms",
+                    "survival_rate",
+                ]
+            )
         self._log_file_initialized = True
 
-    def monitor(self, tick: int, firms: List['Firm']) -> Dict[str, int]:
+    def monitor(self, tick: int, firms: List["Firm"]) -> Dict[str, int]:
         """
         Iterates through active firms, calculates Z-Score, and logs distribution.
         """
@@ -76,9 +86,18 @@ class CrisisMonitor:
         survival_rate = (active_firms_count / total_firms) if total_firms > 0 else 0.0
 
         # Log to CSV
-        with open(self.log_file, 'a', newline='') as f:
+        with open(self.log_file, "a", newline="") as f:
             writer = csv.writer(f)
-            writer.writerow([tick, safe_count, gray_count, distress_count, active_firms_count, survival_rate])
+            writer.writerow(
+                [
+                    tick,
+                    safe_count,
+                    gray_count,
+                    distress_count,
+                    active_firms_count,
+                    survival_rate,
+                ]
+            )
 
         # Log to console
         self.logger.info(
@@ -88,18 +107,18 @@ class CrisisMonitor:
                 "safe_count": safe_count,
                 "gray_count": gray_count,
                 "distress_count": distress_count,
-                "tags": ["crisis_monitor"]
-            }
+                "tags": ["crisis_monitor"],
+            },
         )
 
         return {
             "safe": safe_count,
             "gray": gray_count,
             "distress": distress_count,
-            "active": active_firms_count
+            "active": active_firms_count,
         }
 
-    def _calculate_z_score_for_firm(self, firm: 'Firm') -> float:
+    def _calculate_z_score_for_firm(self, firm: "Firm") -> float:
         """
         Helper to calculate Z-Score for a firm instance using the domain calculator.
         Uses the standardized financial snapshot from the Firm object.
@@ -110,5 +129,5 @@ class CrisisMonitor:
             total_assets=snapshot["total_assets"],
             working_capital=snapshot["working_capital"],
             retained_earnings=snapshot["retained_earnings"],
-            average_profit=snapshot["average_profit"]
+            average_profit=snapshot["average_profit"],
         )
diff --git a/modules/analysis/fiscal_monitor.py b/modules/analysis/fiscal_monitor.py
index b2dfe32..81ba4e0 100644
--- a/modules/analysis/fiscal_monitor.py
+++ b/modules/analysis/fiscal_monitor.py
@@ -1,10 +1,12 @@
 from typing import Any
 from modules.finance.api import IFiscalMonitor
 
+
 class FiscalMonitor(IFiscalMonitor):
     """
     Component for analyzing government fiscal health.
     """
+
     def get_debt_to_gdp_ratio(self, government_dto: Any, world_dto: Any) -> float:
         """
         Calculates the debt-to-GDP ratio.
@@ -16,12 +18,12 @@ class FiscalMonitor(IFiscalMonitor):
         Returns:
             float: The debt-to-GDP ratio. Returns 0.0 if GDP is invalid.
         """
-        debt = getattr(government_dto, 'total_debt', 0.0)
+        debt = getattr(government_dto, "total_debt", 0.0)
 
         # GDP might be in various DTOs depending on context
-        gdp = getattr(world_dto, 'current_gdp', 0.0)
+        gdp = getattr(world_dto, "current_gdp", 0.0)
         if gdp == 0.0:
-            gdp = getattr(world_dto, 'total_production', 0.0)
+            gdp = getattr(world_dto, "total_production", 0.0)
 
         if gdp <= 0:
             return 0.0
diff --git a/modules/analytics/loader.py b/modules/analytics/loader.py
index d4b8957..672b00c 100644
--- a/modules/analytics/loader.py
+++ b/modules/analytics/loader.py
@@ -2,6 +2,7 @@
 Analytics Loader for Simulation Data.
 Handles data loading from SQLite and auxiliary JSON files.
 """
+
 import sqlite3
 import pandas as pd
 import json
@@ -11,6 +12,7 @@ from typing import Optional, Dict, Any
 
 logger = logging.getLogger(__name__)
 
+
 class DataLoader:
     def __init__(self, db_path: str = "simulation_data.db"):
         self.db_path = db_path
@@ -58,7 +60,9 @@ class DataLoader:
         # Note: agent_states can be large, we don't set index by default as time is not unique
         return df
 
-    def load_market_history(self, run_id: Optional[int] = None, market_id: str = "goods_market") -> pd.DataFrame:
+    def load_market_history(
+        self, run_id: Optional[int] = None, market_id: str = "goods_market"
+    ) -> pd.DataFrame:
         """Loads market history for a specific market."""
         # Note: market_history table does not always have run_id in legacy schema,
         # but SimulationRepository.save_market_history inserts it?
@@ -80,9 +84,9 @@ class DataLoader:
 
         query = f"SELECT * FROM market_history WHERE market_id = '{market_id}'"
         if has_run_id and run_id:
-             if run_id == "latest":
-                 run_id = self._get_latest_run_id()
-             query += f" AND run_id = {run_id}"
+            if run_id == "latest":
+                run_id = self._get_latest_run_id()
+            query += f" AND run_id = {run_id}"
 
         query += " ORDER BY time ASC"
 
@@ -93,7 +97,9 @@ class DataLoader:
             df.set_index("time", inplace=True)
         return df
 
-    def load_fiscal_history(self, filepath: str = "reports/fiscal_history.json") -> Dict[str, pd.DataFrame]:
+    def load_fiscal_history(
+        self, filepath: str = "reports/fiscal_history.json"
+    ) -> Dict[str, pd.DataFrame]:
         """Loads fiscal history from JSON artifact."""
         if not os.path.exists(filepath):
             logger.warning(f"Fiscal history file not found at {filepath}")
diff --git a/modules/common/config_manager/api.py b/modules/common/config_manager/api.py
index 866fd3c..387d242 100644
--- a/modules/common/config_manager/api.py
+++ b/modules/common/config_manager/api.py
@@ -2,6 +2,7 @@ from __future__ import annotations
 from typing import Any, Optional
 from pathlib import Path
 
+
 class ConfigManager:
     """
     Manages loading configuration from YAML files and provides a unified access interface.
diff --git a/modules/common/config_manager/impl.py b/modules/common/config_manager/impl.py
index 769a520..31f5582 100644
--- a/modules/common/config_manager/impl.py
+++ b/modules/common/config_manager/impl.py
@@ -10,17 +10,20 @@ logger = logging.getLogger(__name__)
 
 _SENTINEL = object()
 
+
 class ConfigManagerImpl(ConfigManager):
     def __init__(self, config_dir: Path, legacy_config: Optional[Any] = None):
         self._config = {}
         self._legacy_config = legacy_config
         if not config_dir.exists():
-            logger.warning(f"Config directory '{config_dir}' not found. Continuing with empty config.")
+            logger.warning(
+                f"Config directory '{config_dir}' not found. Continuing with empty config."
+            )
             return
 
-        for config_file in config_dir.glob('*.yaml'):
+        for config_file in config_dir.glob("*.yaml"):
             try:
-                with open(config_file, 'r') as f:
+                with open(config_file, "r") as f:
                     data = yaml.safe_load(f)
                     config_key = config_file.stem
                     self._config[config_key] = data
@@ -30,7 +33,7 @@ class ConfigManagerImpl(ConfigManager):
                 logger.error(f"Error loading config file '{config_file}': {e}")
 
     def get(self, key: str, default: Optional[Any] = None) -> Any:
-        parts = key.split('.')
+        parts = key.split(".")
         value = self._config
         try:
             for part in parts:
@@ -38,12 +41,12 @@ class ConfigManagerImpl(ConfigManager):
             return value
         except (KeyError, TypeError):
             if self._legacy_config:
-                legacy_key = key.replace('.', '_').upper()
+                legacy_key = key.replace(".", "_").upper()
                 return getattr(self._legacy_config, legacy_key, default)
             return default
 
     def set_value_for_test(self, key: str, value: Any) -> None:
-        parts = key.split('.')
+        parts = key.split(".")
         node = self._config
         for part in parts[:-1]:
             node = node.setdefault(part, {})
@@ -53,5 +56,7 @@ class ConfigManagerImpl(ConfigManager):
         # Raises AttributeError if key not found, allowing getattr(obj, name, default) to work
         val = self.get(name, _SENTINEL)
         if val is _SENTINEL:
-             raise AttributeError(f"'{type(self).__name__}' object has no attribute '{name}'")
+            raise AttributeError(
+                f"'{type(self).__name__}' object has no attribute '{name}'"
+            )
         return val
diff --git a/modules/finance/api.py b/modules/finance/api.py
index 2645238..667f68f 100644
--- a/modules/finance/api.py
+++ b/modules/finance/api.py
@@ -1,37 +1,48 @@
 from typing import Protocol, Dict, List, Any, Optional
 from dataclasses import dataclass
 
+
 # Forward reference for type hinting
-class Firm: pass
+class Firm:
+    pass
+
 
 @dataclass
 class BondDTO:
     """Data Transfer Object for government bonds."""
+
     id: str
     issuer: str
     face_value: float
     yield_rate: float
     maturity_date: int
 
+
 @dataclass
 class BailoutCovenant:
     """Defines the restrictive conditions attached to a bailout loan."""
+
     dividends_allowed: bool
     executive_salary_freeze: bool
-    mandatory_repayment: float # Ratio of profit to be repaid
+    mandatory_repayment: float  # Ratio of profit to be repaid
+
 
 @dataclass
 class BailoutLoanDTO:
     """Data Transfer Object for corporate bailout loans."""
+
     firm_id: int
     amount: float
     interest_rate: float
     covenants: BailoutCovenant
 
+
 class InsufficientFundsError(Exception):
     """Raised when a withdrawal is attempted with insufficient funds."""
+
     pass
 
+
 class IFinancialEntity(Protocol):
     """Protocol for any entity that can hold and transfer funds."""
 
@@ -54,18 +65,23 @@ class IFinancialEntity(Protocol):
         """
         ...
 
+
 class IBankService(IFinancialEntity, Protocol):
     """Interface for commercial and central banks."""
+
     def add_bond_to_portfolio(self, bond: BondDTO) -> None: ...
 
+
 class IFiscalMonitor(Protocol):
     """Interface for the fiscal health analysis component."""
+
     def get_debt_to_gdp_ratio(self, government_dto: Any, world_dto: Any) -> float: ...
 
+
 class IFinanceSystem(Protocol):
     """Interface for the sovereign debt and corporate bailout system."""
 
-    def evaluate_solvency(self, firm: 'Firm', current_tick: int) -> bool:
+    def evaluate_solvency(self, firm: "Firm", current_tick: int) -> bool:
         """Evaluates a firm's solvency to determine bailout eligibility."""
         ...
 
@@ -77,7 +93,9 @@ class IFinanceSystem(Protocol):
         """Collects corporate tax using atomic settlement."""
         ...
 
-    def grant_bailout_loan(self, firm: 'Firm', amount: float) -> Optional[BailoutLoanDTO]:
+    def grant_bailout_loan(
+        self, firm: "Firm", amount: float
+    ) -> Optional[BailoutLoanDTO]:
         """Converts a bailout from a grant to an interest-bearing senior loan."""
         ...
 
diff --git a/modules/finance/domain/corporate_finance.py b/modules/finance/domain/corporate_finance.py
index a61fc13..7227c72 100644
--- a/modules/finance/domain/corporate_finance.py
+++ b/modules/finance/domain/corporate_finance.py
@@ -1,6 +1,7 @@
 from typing import Protocol, List
 from dataclasses import dataclass
 
+
 class AltmanZScoreCalculator:
     """
     Calculates the Altman Z-Score for a firm to assess its solvency and bankruptcy risk.
@@ -14,7 +15,7 @@ class AltmanZScoreCalculator:
         total_assets: float,
         working_capital: float,
         retained_earnings: float,
-        average_profit: float
+        average_profit: float,
     ) -> float:
         """
         Calculates the Altman Z-Score.
diff --git a/modules/finance/system.py b/modules/finance/system.py
index 98c4180..091f11a 100644
--- a/modules/finance/system.py
+++ b/modules/finance/system.py
@@ -1,18 +1,34 @@
 from typing import List, Dict, Optional, Any, Tuple
 import logging
-from modules.finance.api import IFinanceSystem, BondDTO, BailoutLoanDTO, BailoutCovenant, IFinancialEntity, InsufficientFundsError
+from modules.finance.api import (
+    IFinanceSystem,
+    BondDTO,
+    BailoutLoanDTO,
+    BailoutCovenant,
+    IFinancialEntity,
+    InsufficientFundsError,
+)
 from modules.finance.domain import AltmanZScoreCalculator
 from modules.analysis.fiscal_monitor import FiscalMonitor
+
 # Forward reference for type hinting
 from simulation.firms import Firm
 from simulation.models import Transaction
 
 logger = logging.getLogger(__name__)
 
+
 class FinanceSystem(IFinanceSystem):
     """Manages sovereign debt, corporate bailouts, and solvency checks."""
 
-    def __init__(self, government: 'Government', central_bank: 'CentralBank', bank: 'Bank', config_module: Any, settlement_system: Any = None):
+    def __init__(
+        self,
+        government: "Government",
+        central_bank: "CentralBank",
+        bank: "Bank",
+        config_module: Any,
+        settlement_system: Any = None,
+    ):
         self.government = government
         self.central_bank = central_bank
         self.bank = bank
@@ -21,10 +37,14 @@ class FinanceSystem(IFinanceSystem):
         self.outstanding_bonds: List[BondDTO] = []
         self.fiscal_monitor = FiscalMonitor()
 
-    def evaluate_solvency(self, firm: 'Firm', current_tick: int) -> bool:
+    def evaluate_solvency(self, firm: "Firm", current_tick: int) -> bool:
         """Evaluates a firm's solvency to determine bailout eligibility."""
-        startup_grace_period = self.config_module.get("economy_params.STARTUP_GRACE_PERIOD_TICKS", 24)
-        z_score_threshold = self.config_module.get("economy_params.ALTMAN_Z_SCORE_THRESHOLD", 1.81)
+        startup_grace_period = self.config_module.get(
+            "economy_params.STARTUP_GRACE_PERIOD_TICKS", 24
+        )
+        z_score_threshold = self.config_module.get(
+            "economy_params.ALTMAN_Z_SCORE_THRESHOLD", 1.81
+        )
 
         if firm.age < startup_grace_period:
             # Runway Check for startups
@@ -34,22 +54,26 @@ class FinanceSystem(IFinanceSystem):
         else:
             # Altman Z-Score for established firms
             total_assets = firm.assets + firm.capital_stock + firm.get_inventory_value()
-            working_capital = firm.assets - getattr(firm, 'total_debt', 0.0)
+            working_capital = firm.assets - getattr(firm, "total_debt", 0.0)
             retained_earnings = firm.finance.retained_earnings
 
             # Safe calculation of average profit
             profit_history = firm.finance.profit_history
-            average_profit = sum(profit_history) / len(profit_history) if profit_history else 0.0
+            average_profit = (
+                sum(profit_history) / len(profit_history) if profit_history else 0.0
+            )
 
             z_score = AltmanZScoreCalculator.calculate(
                 total_assets=total_assets,
                 working_capital=working_capital,
                 retained_earnings=retained_earnings,
-                average_profit=average_profit
+                average_profit=average_profit,
             )
             return z_score > z_score_threshold
 
-    def issue_treasury_bonds(self, amount: float, current_tick: int) -> Tuple[List[BondDTO], List[Transaction]]:
+    def issue_treasury_bonds(
+        self, amount: float, current_tick: int
+    ) -> Tuple[List[BondDTO], List[Transaction]]:
         """
         Issues new treasury bonds to the market, allowing for crowding out.
         Returns newly issued bonds AND transactions for bond purchase.
@@ -58,21 +82,26 @@ class FinanceSystem(IFinanceSystem):
         generated_transactions = []
 
         # Use FiscalMonitor for risk assessment
-        world_dto = getattr(self.government, 'sensory_data', None)
-        debt_to_gdp = self.fiscal_monitor.get_debt_to_gdp_ratio(self.government, world_dto)
+        world_dto = getattr(self.government, "sensory_data", None)
+        debt_to_gdp = self.fiscal_monitor.get_debt_to_gdp_ratio(
+            self.government, world_dto
+        )
 
         # Config-driven risk premium tiers
-        risk_premium_tiers = self.config_module.get("economy_params.DEBT_RISK_PREMIUM_TIERS", {
-            1.2: 0.05,
-            0.9: 0.02,
-            0.6: 0.005,
-        })
+        risk_premium_tiers = self.config_module.get(
+            "economy_params.DEBT_RISK_PREMIUM_TIERS",
+            {
+                1.2: 0.05,
+                0.9: 0.02,
+                0.6: 0.005,
+            },
+        )
 
         risk_premium = 0.0
         sorted_tiers = sorted(
             [(float(k), v) for k, v in risk_premium_tiers.items()],
             key=lambda x: x[0],
-            reverse=True
+            reverse=True,
         )
 
         for threshold, premium in sorted_tiers:
@@ -82,16 +111,20 @@ class FinanceSystem(IFinanceSystem):
 
         yield_rate = base_rate + risk_premium
 
-        bond_maturity = self.config_module.get("economy_params.BOND_MATURITY_TICKS", 400)
+        bond_maturity = self.config_module.get(
+            "economy_params.BOND_MATURITY_TICKS", 400
+        )
         new_bond = BondDTO(
             id=f"BOND_{current_tick}_{len(self.outstanding_bonds)}",
             issuer="GOVERNMENT",
             face_value=amount,
             yield_rate=yield_rate,
-            maturity_date=current_tick + bond_maturity
+            maturity_date=current_tick + bond_maturity,
         )
 
-        qe_threshold = self.config_module.get("economy_params.QE_INTERVENTION_YIELD_THRESHOLD", 0.10)
+        qe_threshold = self.config_module.get(
+            "economy_params.QE_INTERVENTION_YIELD_THRESHOLD", 0.10
+        )
         buyer = None
 
         if yield_rate > qe_threshold:
@@ -103,7 +136,9 @@ class FinanceSystem(IFinanceSystem):
             if self.bank.assets >= amount:
                 buyer = self.bank
             else:
-                logger.warning("BOND_ISSUANCE_FAILED | No buyer found (Bank insufficient funds).")
+                logger.warning(
+                    "BOND_ISSUANCE_FAILED | No buyer found (Bank insufficient funds)."
+                )
                 return [], []
 
         # Generate Transaction: Buyer -> Government
@@ -115,19 +150,19 @@ class FinanceSystem(IFinanceSystem):
             price=amount,
             market_id="financial",
             transaction_type="bond_purchase",
-            time=current_tick
+            time=current_tick,
         )
         generated_transactions.append(tx)
 
         # Optimistic State Update
         self.outstanding_bonds.append(new_bond)
-        if hasattr(buyer, 'add_bond_to_portfolio'):
+        if hasattr(buyer, "add_bond_to_portfolio"):
             buyer.add_bond_to_portfolio(new_bond)
         elif buyer == self.central_bank:
             if isinstance(buyer.assets, dict):
-                 if "bonds" not in buyer.assets:
-                     buyer.assets["bonds"] = []
-                 buyer.assets["bonds"].append(new_bond)
+                if "bonds" not in buyer.assets:
+                    buyer.assets["bonds"] = []
+                buyer.assets["bonds"].append(new_bond)
 
         return [new_bond], generated_transactions
 
@@ -137,27 +172,35 @@ class FinanceSystem(IFinanceSystem):
         Tax collection should now be handled via Transaction Generation.
         Kept for interface compatibility but warns usage.
         """
-        logger.warning("FinanceSystem.collect_corporate_tax called. Should be using Transaction Generation.")
+        logger.warning(
+            "FinanceSystem.collect_corporate_tax called. Should be using Transaction Generation."
+        )
         return False
 
-    def grant_bailout_loan(self, firm: 'Firm', amount: float, current_tick: int) -> Tuple[Optional[BailoutLoanDTO], List[Transaction]]:
+    def grant_bailout_loan(
+        self, firm: "Firm", amount: float, current_tick: int
+    ) -> Tuple[Optional[BailoutLoanDTO], List[Transaction]]:
         """
         Converts a bailout from a grant to an interest-bearing senior loan.
         Returns the loan DTO and Transaction.
         """
         base_rate = self.central_bank.get_base_rate()
-        penalty_premium = self.config_module.get("economy_params.BAILOUT_PENALTY_PREMIUM", 0.05)
+        penalty_premium = self.config_module.get(
+            "economy_params.BAILOUT_PENALTY_PREMIUM", 0.05
+        )
 
         covenants = BailoutCovenant(
             dividends_allowed=False,
             executive_salary_freeze=True,
-            mandatory_repayment=self.config_module.get("economy_params.BAILOUT_COVENANT_RATIO", 0.5)
+            mandatory_repayment=self.config_module.get(
+                "economy_params.BAILOUT_COVENANT_RATIO", 0.5
+            ),
         )
         loan = BailoutLoanDTO(
             firm_id=firm.id,
             amount=amount,
             interest_rate=base_rate + penalty_premium,
-            covenants=covenants
+            covenants=covenants,
         )
 
         # Generate Transaction: Government -> Firm
@@ -169,16 +212,26 @@ class FinanceSystem(IFinanceSystem):
             price=amount,
             market_id="financial",
             transaction_type="bailout_loan",
-            time=current_tick
+            time=current_tick,
         )
 
         # Optimistic State Update
-        firm.finance.add_liability(amount, loan.interest_rate)
+        # WO-116: Do not call add_liability() as it adds cash directly.
+        # Cash is transferred via TransactionProcessor. We only record the debt here.
+        if not hasattr(firm, 'total_debt'):
+             firm.total_debt = 0.0
+        firm.total_debt += amount
         firm.has_bailout_loan = True
 
         return loan, [tx]
 
-    def _transfer(self, debtor: IFinancialEntity, creditor: IFinancialEntity, amount: float, memo: str = "FinanceSystem Transfer") -> bool:
+    def _transfer(
+        self,
+        debtor: IFinancialEntity,
+        creditor: IFinancialEntity,
+        amount: float,
+        memo: str = "FinanceSystem Transfer",
+    ) -> bool:
         """
         Legacy method.
         Should not be used in Phase 3 Normalized Sequence.
@@ -197,23 +250,33 @@ class FinanceSystem(IFinanceSystem):
         Returns List of Transactions.
         """
         transactions = []
-        matured_bonds = [b for b in self.outstanding_bonds if b.maturity_date <= current_tick]
+        matured_bonds = [
+            b for b in self.outstanding_bonds if b.maturity_date <= current_tick
+        ]
 
-        bond_maturity_ticks = self.config_module.get("economy_params.BOND_MATURITY_TICKS", 400)
+        bond_maturity_ticks = self.config_module.get(
+            "economy_params.BOND_MATURITY_TICKS", 400
+        )
         ticks_per_year = getattr(self.config_module, "TICKS_PER_YEAR", 48)
 
         for bond in matured_bonds:
             # Calculate simple interest accrued over the bond's lifetime
-            interest_amount = bond.face_value * bond.yield_rate * (bond_maturity_ticks / ticks_per_year)
+            interest_amount = (
+                bond.face_value
+                * bond.yield_rate
+                * (bond_maturity_ticks / ticks_per_year)
+            )
             total_repayment = bond.face_value + interest_amount
 
             # Identify bond holder
-            bond_holder = self.bank # Default
+            bond_holder = self.bank  # Default
 
             # Check Central Bank
-            if hasattr(self.central_bank, 'assets') and isinstance(self.central_bank.assets, dict):
-                 if bond in self.central_bank.assets.get("bonds", []):
-                      bond_holder = self.central_bank
+            if hasattr(self.central_bank, "assets") and isinstance(
+                self.central_bank.assets, dict
+            ):
+                if bond in self.central_bank.assets.get("bonds", []):
+                    bond_holder = self.central_bank
 
             # Generate Transaction: Government -> Holder
             tx = Transaction(
@@ -224,13 +287,13 @@ class FinanceSystem(IFinanceSystem):
                 price=total_repayment,
                 market_id="financial",
                 transaction_type="bond_repayment",
-                time=current_tick
+                time=current_tick,
             )
             transactions.append(tx)
 
             # Optimistic Cleanup
             if bond_holder == self.central_bank:
-                 self.central_bank.assets["bonds"].remove(bond)
+                self.central_bank.assets["bonds"].remove(bond)
 
             self.outstanding_bonds.remove(bond)
 
diff --git a/modules/household/api.py b/modules/household/api.py
index 014357d..60267f5 100644
--- a/modules/household/api.py
+++ b/modules/household/api.py
@@ -5,7 +5,13 @@ from typing import Any, Dict, List, Optional, Tuple, TYPE_CHECKING, Deque
 if TYPE_CHECKING:
     from simulation.core_agents import Household
     from simulation.dtos import LeisureEffectDTO, StressScenarioConfig
-    from modules.household.dtos import CloningRequestDTO, EconContextDTO, SocialContextDTO, HouseholdStateDTO
+    from modules.household.dtos import (
+        CloningRequestDTO,
+        EconContextDTO,
+        SocialContextDTO,
+        HouseholdStateDTO,
+    )
+
 
 class IBioComponent(ABC):
     """Interface for Biological Component."""
@@ -24,6 +30,7 @@ class IBioComponent(ABC):
     @abstractmethod
     def run_lifecycle(self, context: Dict[str, Any]): ...
 
+
 class IEconComponent(ABC):
     """Interface for Economic Component."""
 
@@ -38,7 +45,12 @@ class IEconComponent(ABC):
     def consume(self, item_id: str, quantity: float, current_time: int) -> Any: ...
 
     @abstractmethod
-    def orchestrate_economic_decisions(self, context: EconContextDTO, orders: List[Any], stress_scenario_config: Optional[StressScenarioConfig] = None): ...
+    def orchestrate_economic_decisions(
+        self,
+        context: EconContextDTO,
+        orders: List[Any],
+        stress_scenario_config: Optional[StressScenarioConfig] = None,
+    ): ...
 
     # --- Phase 23: Inflation Expectation & Price Memory ---
     @property
@@ -61,7 +73,7 @@ class IEconComponent(ABC):
     def update_perceived_prices(
         self,
         market_data: Dict[str, Any],
-        stress_scenario_config: Optional[StressScenarioConfig] = None
+        stress_scenario_config: Optional[StressScenarioConfig] = None,
     ) -> None:
         """
         Calculates and updates the agent's inflation expectation and
@@ -69,6 +81,7 @@ class IEconComponent(ABC):
         """
         ...
 
+
 class ISocialComponent(ABC):
     """Interface for Social Component."""
 
@@ -79,4 +92,6 @@ class ISocialComponent(ABC):
     def update_political_opinion(self) -> None: ...
 
     @abstractmethod
-    def apply_leisure_effect(self, leisure_hours: float, consumed_items: Dict[str, float]) -> LeisureEffectDTO: ...
+    def apply_leisure_effect(
+        self, leisure_hours: float, consumed_items: Dict[str, float]
+    ) -> LeisureEffectDTO: ...
diff --git a/modules/household/bio_component.py b/modules/household/bio_component.py
index 9da4111..0317583 100644
--- a/modules/household/bio_component.py
+++ b/modules/household/bio_component.py
@@ -15,6 +15,7 @@ if TYPE_CHECKING:
 
 logger = logging.getLogger(__name__)
 
+
 class BioComponent(IBioComponent):
     """
     Manages biological and demographic aspects of the Household.
@@ -28,7 +29,7 @@ class BioComponent(IBioComponent):
         initial_age: Optional[float] = None,
         gender: Optional[str] = None,
         parent_id: Optional[int] = None,
-        generation: Optional[int] = None
+        generation: Optional[int] = None,
     ):
         self.owner = owner
         self.config_module = config_module
@@ -47,7 +48,7 @@ class BioComponent(IBioComponent):
             gender=gender,
             parent_id=parent_id,
             generation=generation,
-            config_module=config_module
+            config_module=config_module,
         )
 
         self.lifecycle_component = AgentLifecycleComponent(owner, config_module)
@@ -101,7 +102,9 @@ class BioComponent(IBioComponent):
         from simulation.core_agents import Household
 
         # 1. Create offspring demographics data
-        offspring_demo_data = self.demographics.create_offspring_demographics(request.new_id, request.current_tick)
+        offspring_demo_data = self.demographics.create_offspring_demographics(
+            request.new_id, request.current_tick
+        )
 
         # 2. Create new Household instance
         # We need to access owner's properties to pass to constructor
@@ -124,7 +127,7 @@ class BioComponent(IBioComponent):
 
         cloned_household = Household(
             id=request.new_id,
-            talent=self.owner.talent, # Inherit talent object (immutable?) or should copy? Original code passed self.talent.
+            talent=self.owner.talent,  # Inherit talent object (immutable?) or should copy? Original code passed self.talent.
             goods_data=[g for g in self.owner.goods_info_map.values()],
             initial_assets=request.initial_assets_from_parent,
             initial_needs=self.owner.needs.copy(),
@@ -135,14 +138,17 @@ class BioComponent(IBioComponent):
             loan_market=self.owner.decision_engine.loan_market,
             risk_aversion=self.owner.risk_aversion,
             logger=self.owner.logger,
-            **offspring_demo_data
+            **offspring_demo_data,
         )
 
         # Attribute Sync (Biological/Physical mainly, but some Econ state is copied in original clone)
         # Original clone copied: skills, inventory, labor_skill, aptitude.
 
         # Skills (Biological/Learned capability)
-        cloned_household.skills = {k: Skill(v.domain, v.value, v.observability) for k, v in self.owner.skills.items()}
+        cloned_household.skills = {
+            k: Skill(v.domain, v.value, v.observability)
+            for k, v in self.owner.skills.items()
+        }
 
         # Inventory (Inheritance? Usually empty for newborn, but maybe mitosis implies split?)
         # Original code copied inventory, leading to duplication.
@@ -159,4 +165,6 @@ class BioComponent(IBioComponent):
         return cloned_household
 
     def get_generational_similarity(self, other: "Household") -> float:
-        return self.demographics.get_generational_similarity(self.owner.talent.base_learning_rate, other.talent.base_learning_rate)
+        return self.demographics.get_generational_similarity(
+            self.owner.talent.base_learning_rate, other.talent.base_learning_rate
+        )
diff --git a/modules/household/dtos.py b/modules/household/dtos.py
index 5cbb990..c8fc02d 100644
--- a/modules/household/dtos.py
+++ b/modules/household/dtos.py
@@ -8,12 +8,14 @@ from simulation.models import Share
 if TYPE_CHECKING:
     from simulation.core_markets import Market
 
+
 @dataclass
 class HouseholdStateDTO:
     """
     A read-only DTO containing the state of a Household agent.
     Used by the DecisionEngine to make decisions without direct dependency on the Household class.
     """
+
     id: int
     assets: float
     inventory: Dict[str, float]
@@ -46,22 +48,28 @@ class HouseholdStateDTO:
     perceived_fair_price: Dict[str, float] = field(default_factory=dict)
     sentiment_index: float = 0.5
 
+
 @dataclass
 class CloningRequestDTO:
     """Data required to clone a household."""
+
     new_id: int
     initial_assets_from_parent: float
     current_tick: int
 
+
 @dataclass
 class EconContextDTO:
     """Context for economic operations."""
+
     markets: Dict[str, "Market"]
     market_data: Dict[str, Any]
     current_time: int
 
+
 @dataclass
 class SocialContextDTO:
     """Context for social operations."""
+
     current_time: int
     market_data: Optional[Dict[str, Any]] = None
diff --git a/modules/household/econ_component.py b/modules/household/econ_component.py
index 41b9282..d7db4fa 100644
--- a/modules/household/econ_component.py
+++ b/modules/household/econ_component.py
@@ -12,7 +12,10 @@ from simulation.components.labor_manager import LaborManager
 from simulation.components.market_component import MarketComponent
 from simulation.portfolio import Portfolio
 from simulation.ai.system2_planner import System2Planner
-from simulation.ai.household_system2 import HouseholdSystem2Planner, HousingDecisionInputs
+from simulation.ai.household_system2 import (
+    HouseholdSystem2Planner,
+    HousingDecisionInputs,
+)
 from simulation.ai.api import Personality
 from simulation.models import Order, Skill
 from simulation.utils.shadow_logger import log_shadow
@@ -21,11 +24,13 @@ if TYPE_CHECKING:
     from simulation.core_agents import Household
     from simulation.dtos.scenario import StressScenarioConfig
 
+
 class EconComponent(IEconComponent):
     """
     Manages economic state and behavior of the Household.
     Owns ConsumptionBehavior, LaborManager, EconomyManager, MarketComponent, Portfolio.
     """
+
     def __init__(self, owner: "Household", config_module: Any):
         self.owner = owner
         self.config_module = config_module
@@ -58,7 +63,7 @@ class EconComponent(IEconComponent):
 
         # Misc State
         self.durable_assets: List[Dict[str, Any]] = []
-        self.shares_owned: Dict[int, float] = {} # Keeping for legacy compat if needed
+        self.shares_owned: Dict[int, float] = {}  # Keeping for legacy compat if needed
 
         # Income Tracking
         self.labor_income_this_tick: float = 0.0
@@ -73,22 +78,32 @@ class EconComponent(IEconComponent):
         # WO-095: Robust config access to handle Mocks in tests
         # Security Fix: Verified type safety for PRICE_MEMORY_LENGTH
         raw_price_len = getattr(self.config_module, "PRICE_MEMORY_LENGTH", 10)
-        price_memory_len = int(raw_price_len) if isinstance(raw_price_len, (int, float)) else 10
+        price_memory_len = (
+            int(raw_price_len) if isinstance(raw_price_len, (int, float)) else 10
+        )
 
-        self._price_history: defaultdict[str, deque] = defaultdict(lambda: deque(maxlen=price_memory_len))
+        self._price_history: defaultdict[str, deque] = defaultdict(
+            lambda: deque(maxlen=price_memory_len)
+        )
 
         # Initialize perceived prices from config/goods_data if possible
         if hasattr(self.owner, "goods_info_map"):
             for g in self.owner.goods_info_map.values():
-                 self._perceived_avg_prices[g["id"]] = g.get("initial_price", 10.0)
+                self._perceived_avg_prices[g["id"]] = g.get("initial_price", 10.0)
 
         # Adaptation Rate (Personality Based)
-        self._adaptation_rate: float = getattr(self.config_module, "ADAPTATION_RATE_NORMAL", 0.2)
+        self._adaptation_rate: float = getattr(
+            self.config_module, "ADAPTATION_RATE_NORMAL", 0.2
+        )
         if hasattr(self.owner, "personality"):
             if self.owner.personality == Personality.IMPULSIVE:
-                 self._adaptation_rate = getattr(self.config_module, "ADAPTATION_RATE_IMPULSIVE", 0.5)
+                self._adaptation_rate = getattr(
+                    self.config_module, "ADAPTATION_RATE_IMPULSIVE", 0.5
+                )
             elif self.owner.personality == Personality.CONSERVATIVE:
-                 self._adaptation_rate = getattr(self.config_module, "ADAPTATION_RATE_CONSERVATIVE", 0.1)
+                self._adaptation_rate = getattr(
+                    self.config_module, "ADAPTATION_RATE_CONSERVATIVE", 0.1
+                )
 
         # --- Components ---
         self.consumption = ConsumptionBehavior(owner, config_module)
@@ -107,7 +122,9 @@ class EconComponent(IEconComponent):
         self.housing_price_history: deque = deque(maxlen=ticks_per_year)
 
         raw_wage_len = getattr(self.config_module, "WAGE_MEMORY_LENGTH", 30)
-        wage_memory_len = int(raw_wage_len) if isinstance(raw_wage_len, (int, float)) else 30
+        wage_memory_len = (
+            int(raw_wage_len) if isinstance(raw_wage_len, (int, float)) else 30
+        )
 
         self.market_wage_history: deque[float] = deque(maxlen=wage_memory_len)
         self.shadow_reservation_wage: float = 0.0
@@ -189,7 +206,7 @@ class EconComponent(IEconComponent):
     def update_perceived_prices(
         self,
         market_data: Dict[str, Any],
-        stress_scenario_config: Optional["StressScenarioConfig"] = None
+        stress_scenario_config: Optional["StressScenarioConfig"] = None,
     ) -> None:
         """
         Calculates and updates the agent's inflation expectation and
@@ -201,9 +218,11 @@ class EconComponent(IEconComponent):
 
         adaptive_rate = self.adaptation_rate
         if stress_scenario_config and stress_scenario_config.is_active:
-            if stress_scenario_config.scenario_name == 'hyperinflation':
+            if stress_scenario_config.scenario_name == "hyperinflation":
                 if hasattr(stress_scenario_config, "inflation_expectation_multiplier"):
-                     adaptive_rate *= stress_scenario_config.inflation_expectation_multiplier
+                    adaptive_rate *= (
+                        stress_scenario_config.inflation_expectation_multiplier
+                    )
 
         if hasattr(self.owner, "goods_info_map"):
             for good in self.owner.goods_info_map.values():
@@ -218,7 +237,9 @@ class EconComponent(IEconComponent):
                             inflation_t = (actual_price - last_price) / last_price
 
                             old_expect = self.expected_inflation[item_id]
-                            new_expect = old_expect + adaptive_rate * (inflation_t - old_expect)
+                            new_expect = old_expect + adaptive_rate * (
+                                inflation_t - old_expect
+                            )
                             self.expected_inflation[item_id] = new_expect
 
                     history.append(actual_price)
@@ -226,19 +247,23 @@ class EconComponent(IEconComponent):
                     old_perceived_price = self.perceived_avg_prices.get(
                         item_id, actual_price
                     )
-                    update_factor = getattr(self.config_module, "PERCEIVED_PRICE_UPDATE_FACTOR", 0.1)
-                    new_perceived_price = (
-                        update_factor * actual_price
-                    ) + (
-                        (1 - update_factor)
-                        * old_perceived_price
+                    update_factor = getattr(
+                        self.config_module, "PERCEIVED_PRICE_UPDATE_FACTOR", 0.1
+                    )
+                    new_perceived_price = (update_factor * actual_price) + (
+                        (1 - update_factor) * old_perceived_price
                     )
                     self.perceived_avg_prices[item_id] = new_perceived_price
 
     def get_state(self) -> HouseholdStateDTO:
-        pass # Partially implemented if needed, but Household calls components
+        pass  # Partially implemented if needed, but Household calls components
 
-    def orchestrate_economic_decisions(self, context: EconContextDTO, orders: List[Order], stress_scenario_config: Optional["StressScenarioConfig"] = None) -> List[Order]:
+    def orchestrate_economic_decisions(
+        self,
+        context: EconContextDTO,
+        orders: List[Order],
+        stress_scenario_config: Optional["StressScenarioConfig"] = None,
+    ) -> List[Order]:
         """
         Refines and adds to the orders based on System 2 logic, panic rules, and other economic constraints.
         """
@@ -257,7 +282,7 @@ class EconComponent(IEconComponent):
             housing_market = markets.get("housing")
             if housing_market:
                 target_unit_id = None
-                best_price = float('inf')
+                best_price = float("inf")
 
                 # Check for available units
                 if hasattr(housing_market, "sell_orders"):
@@ -269,62 +294,79 @@ class EconComponent(IEconComponent):
                                 target_unit_id = item_id
 
                 if target_unit_id:
-                     # Check affordability (20% down payment)
-                     down_payment = best_price * 0.2
-                     if self.assets >= down_payment:
-                         buy_order = Order(
-                             agent_id=self.owner.id,
-                             item_id=target_unit_id,
-                             price=best_price,
-                             quantity=1.0,
-                             market_id="housing",
-                             order_type="BUY"
-                         )
-                         orders.append(buy_order)
-                         self.logger.info(f"HOUSING_BUY | Household {self.owner.id} decided to buy {target_unit_id} at {best_price}")
+                    # Check affordability (20% down payment)
+                    down_payment = best_price * 0.2
+                    if self.assets >= down_payment:
+                        buy_order = Order(
+                            agent_id=self.owner.id,
+                            item_id=target_unit_id,
+                            price=best_price,
+                            quantity=1.0,
+                            market_id="housing",
+                            order_type="BUY",
+                        )
+                        orders.append(buy_order)
+                        self.logger.info(
+                            f"HOUSING_BUY | Household {self.owner.id} decided to buy {target_unit_id} at {best_price}"
+                        )
 
         # 4. Panic Selling (Deflation)
-        if stress_scenario_config and stress_scenario_config.is_active and stress_scenario_config.scenario_name == 'deflation':
-             threshold = self.config_module.PANIC_SELLING_ASSET_THRESHOLD
-             if self.assets < threshold:
-                 self.logger.warning(f"PANIC_SELLING | Household {self.owner.id} panic selling stocks due to low assets ({self.assets:.1f})")
-                 # Sell ALL stocks
-                 for firm_id, share in self.portfolio.holdings.items():
-                     if share.quantity > 0:
-                         stock_order = Order(
-                             agent_id=self.owner.id,
-                             order_type="SELL",
-                             item_id=f"stock_{firm_id}",
-                             quantity=share.quantity,
-                             price=0.0,
-                             market_id="stock_market"
-                         )
-                         orders.append(stock_order)
+        if (
+            stress_scenario_config
+            and stress_scenario_config.is_active
+            and stress_scenario_config.scenario_name == "deflation"
+        ):
+            threshold = self.config_module.PANIC_SELLING_ASSET_THRESHOLD
+            if self.assets < threshold:
+                self.logger.warning(
+                    f"PANIC_SELLING | Household {self.owner.id} panic selling stocks due to low assets ({self.assets:.1f})"
+                )
+                # Sell ALL stocks
+                for firm_id, share in self.portfolio.holdings.items():
+                    if share.quantity > 0:
+                        stock_order = Order(
+                            agent_id=self.owner.id,
+                            order_type="SELL",
+                            item_id=f"stock_{firm_id}",
+                            quantity=share.quantity,
+                            price=0.0,
+                            market_id="stock_market",
+                        )
+                        orders.append(stock_order)
 
         # 5. Targeted Order Refinement & Internal Commands (QUIT)
         refined_orders = []
 
         # Phase 29: Demand Shock (Consumer Spending Reduction)
-        if stress_scenario_config and stress_scenario_config.is_active and stress_scenario_config.scenario_name == 'phase29_depression':
-             multiplier = stress_scenario_config.demand_shock_multiplier
-             if multiplier is not None:
-                 for order in orders:
-                     if order.order_type == "BUY" and order.item_id not in ["labor", "loan"]:
-                         # Reduce quantity by multiplier (e.g., 0.7 means 70% remains, 30% reduction)
-                         # Only affect Goods (Consumer Spending)
-                         # We assume anything not labor/loan/financial is a good/service.
-                         # Stocks are "stock_X".
-                         if not order.item_id.startswith("stock_"):
+        if (
+            stress_scenario_config
+            and stress_scenario_config.is_active
+            and stress_scenario_config.scenario_name == "phase29_depression"
+        ):
+            multiplier = stress_scenario_config.demand_shock_multiplier
+            if multiplier is not None:
+                for order in orders:
+                    if order.order_type == "BUY" and order.item_id not in [
+                        "labor",
+                        "loan",
+                    ]:
+                        # Reduce quantity by multiplier (e.g., 0.7 means 70% remains, 30% reduction)
+                        # Only affect Goods (Consumer Spending)
+                        # We assume anything not labor/loan/financial is a good/service.
+                        # Stocks are "stock_X".
+                        if not order.item_id.startswith("stock_"):
                             order.quantity *= multiplier
 
         for order in orders:
             if order.order_type == "QUIT":
                 self.owner.quit()
-                continue # Do not forward QUIT order to markets
+                continue  # Do not forward QUIT order to markets
 
             if order.order_type == "BUY" and order.target_agent_id is None:
                 # Select best seller
-                best_seller_id, best_price = self.market_component.choose_best_seller(order.item_id, {"markets": markets})
+                best_seller_id, best_price = self.market_component.choose_best_seller(
+                    order.item_id, {"markets": markets}
+                )
                 if best_seller_id:
                     order.target_agent_id = best_seller_id
             refined_orders.append(order)
@@ -332,7 +374,9 @@ class EconComponent(IEconComponent):
 
         # 6. Forensics
         for order in orders:
-             if order.order_type == "SELL" and (order.item_id == "labor" or order.market_id == "labor"):
+            if order.order_type == "SELL" and (
+                order.item_id == "labor" or order.market_id == "labor"
+            ):
                 self.last_labor_offer_tick = current_time
 
         return orders
@@ -350,7 +394,7 @@ class EconComponent(IEconComponent):
         market_rent = housing_market.get("avg_rent_price", 100.0)
         market_price = housing_market.get("avg_sale_price")
         if not market_price:
-             market_price = market_rent * 12 * 20.0
+            market_price = market_rent * 12 * 20.0
 
         self.housing_price_history.append(market_price)
         risk_free_rate = loan_market.get("interest_rate", 0.05)
@@ -363,7 +407,11 @@ class EconComponent(IEconComponent):
                 price_growth = (end_price - start_price) / start_price
 
         ticks_per_year = getattr(self.config_module, "TICKS_PER_YEAR", 100)
-        income = self.current_wage * ticks_per_year if self.is_employed else self.expected_wage * ticks_per_year
+        income = (
+            self.current_wage * ticks_per_year
+            if self.is_employed
+            else self.expected_wage * ticks_per_year
+        )
 
         inputs = HousingDecisionInputs(
             current_wealth=self.assets,
@@ -371,7 +419,7 @@ class EconComponent(IEconComponent):
             market_rent_monthly=market_rent,
             market_price=market_price,
             risk_free_rate=risk_free_rate,
-            price_growth_expectation=price_growth
+            price_growth_expectation=price_growth,
         )
 
         decision = self.housing_planner.decide(inputs)
@@ -379,17 +427,19 @@ class EconComponent(IEconComponent):
         if decision != self.housing_target_mode:
             self.logger.info(
                 f"HOUSING_DECISION_CHANGE | Household {self.owner.id} switched housing mode: {self.housing_target_mode} -> {decision}",
-                extra={"tick": current_time, "agent_id": self.owner.id}
+                extra={"tick": current_time, "agent_id": self.owner.id},
             )
             self.housing_target_mode = decision
 
-    def _calculate_shadow_reservation_wage(self, market_data: Dict[str, Any], current_tick: int) -> None:
+    def _calculate_shadow_reservation_wage(
+        self, market_data: Dict[str, Any], current_tick: int
+    ) -> None:
         """
         WO-056: Stage 1 Shadow Mode (Labor Market Mechanism).
         """
         avg_market_wage = 0.0
         if market_data and "labor" in market_data:
-             avg_market_wage = market_data["labor"].get("avg_wage", 0.0)
+            avg_market_wage = market_data["labor"].get("avg_wage", 0.0)
 
         if avg_market_wage > 0:
             self.market_wage_history.append(avg_market_wage)
@@ -400,13 +450,17 @@ class EconComponent(IEconComponent):
             startup_cost_index = avg_wage_30 * 6.0
 
         if self.shadow_reservation_wage <= 0.0:
-            self.shadow_reservation_wage = self.current_wage if self.is_employed else self.expected_wage
+            self.shadow_reservation_wage = (
+                self.current_wage if self.is_employed else self.expected_wage
+            )
 
         if self.is_employed:
             target = max(self.current_wage, self.shadow_reservation_wage)
-            self.shadow_reservation_wage = (self.shadow_reservation_wage * 0.95) + (target * 0.05)
+            self.shadow_reservation_wage = (self.shadow_reservation_wage * 0.95) + (
+                target * 0.05
+            )
         else:
-            self.shadow_reservation_wage *= (1.0 - 0.02)
+            self.shadow_reservation_wage *= 1.0 - 0.02
             min_wage = getattr(self.config_module, "HOUSEHOLD_MIN_WAGE_DEMAND", 6.0)
             if self.shadow_reservation_wage < min_wage:
                 self.shadow_reservation_wage = min_wage
@@ -418,5 +472,5 @@ class EconComponent(IEconComponent):
             metric="shadow_wage",
             current_value=self.current_wage if self.is_employed else self.expected_wage,
             shadow_value=self.shadow_reservation_wage,
-            details=f"Employed={self.is_employed}, StartupIdx={startup_cost_index:.2f}"
+            details=f"Employed={self.is_employed}, StartupIdx={startup_cost_index:.2f}",
         )
diff --git a/modules/household/social_component.py b/modules/household/social_component.py
index 21b40bd..375cf4d 100644
--- a/modules/household/social_component.py
+++ b/modules/household/social_component.py
@@ -12,12 +12,20 @@ from simulation.dtos import LeisureEffectDTO
 if TYPE_CHECKING:
     from simulation.core_agents import Household
 
+
 class SocialComponent(ISocialComponent):
     """
     Manages social and psychological aspects of the Household.
     Owns PsychologyComponent and LeisureManager.
     """
-    def __init__(self, owner: "Household", config_module: Any, personality: Personality, initial_assets: float = 0.0):
+
+    def __init__(
+        self,
+        owner: "Household",
+        config_module: Any,
+        personality: Personality,
+        initial_assets: float = 0.0,
+    ):
         self.owner = owner
         self.config_module = config_module
         self.logger = owner.logger
@@ -40,14 +48,18 @@ class SocialComponent(ISocialComponent):
 
         # Vanity - Conformity
         conformity_ranges = getattr(config_module, "CONFORMITY_RANGES", {})
-        c_min, c_max = conformity_ranges.get(personality.name, conformity_ranges.get(None, (0.3, 0.7)))
+        c_min, c_max = conformity_ranges.get(
+            personality.name, conformity_ranges.get(None, (0.3, 0.7))
+        )
         self.conformity: float = random.uniform(c_min, c_max)
         self.social_rank: float = 0.5
 
         # Brand Economy Traits
         # Initialize quality_preference based on Personality and Wealth
         # Note: We use initial_assets here because owner.assets might not be set yet
-        mean_assets = getattr(config_module, "INITIAL_HOUSEHOLD_ASSETS_MEAN", 1000.0) # Fallback
+        mean_assets = getattr(
+            config_module, "INITIAL_HOUSEHOLD_ASSETS_MEAN", 1000.0
+        )  # Fallback
         is_wealthy = initial_assets > mean_assets * 1.5
         is_poor = initial_assets < mean_assets * 0.5
 
@@ -87,5 +99,7 @@ class SocialComponent(ISocialComponent):
         else:
             self.approval_rating = 0
 
-    def apply_leisure_effect(self, leisure_hours: float, consumed_items: Dict[str, float]) -> LeisureEffectDTO:
+    def apply_leisure_effect(
+        self, leisure_hours: float, consumed_items: Dict[str, float]
+    ) -> LeisureEffectDTO:
         return self.leisure.apply_leisure_effect(leisure_hours, consumed_items)
diff --git a/scripts/analyze_harvest_csv.py b/scripts/analyze_harvest_csv.py
index 20e0857..899b4cb 100644
--- a/scripts/analyze_harvest_csv.py
+++ b/scripts/analyze_harvest_csv.py
@@ -1,6 +1,7 @@
 import csv
 import statistics
 
+
 def analyze_harvest():
     data = {
         "tick": [],
@@ -11,10 +12,10 @@ def analyze_harvest():
         "total_inventory": [],
         "total_sales": [],
         "active_food_firms": [],
-        "avg_firm_cash": []
+        "avg_firm_cash": [],
     }
 
-    with open('harvest_data.csv', 'r') as f:
+    with open("harvest_data.csv", "r") as f:
         reader = csv.DictReader(f)
         for row in reader:
             for k in data.keys():
@@ -25,7 +26,7 @@ def analyze_harvest():
     initial_price = data["food_price"][0]
     final_price = data["food_price"][-1]
     price_drop = (initial_price - final_price) / initial_price
-    print(f"Price: {initial_price} -> {final_price} (Drop: {price_drop*100:.1f}%)")
+    print(f"Price: {initial_price} -> {final_price} (Drop: {price_drop * 100:.1f}%)")
 
     # 2. Population Trend
     initial_pop = data["population"][0]
@@ -34,7 +35,9 @@ def analyze_harvest():
     print(f"Population: {initial_pop} -> {final_pop} (Growth: {pop_growth:.2f}x)")
 
     # 3. Engel Trend
-    print(f"Engel Coefficient: Start {data['engel_coeff'][0]:.2f} -> End {data['engel_coeff'][-1]:.2f}")
+    print(
+        f"Engel Coefficient: Start {data['engel_coeff'][0]:.2f} -> End {data['engel_coeff'][-1]:.2f}"
+    )
 
     # 4. Supply Dynamics
     print(f"Total Inventory (Peak): {max(data['total_inventory'])}")
@@ -57,5 +60,6 @@ def analyze_harvest():
     # Detect period where inventory spiked but sales didn't
     # Simple correlation?
 
+
 if __name__ == "__main__":
     analyze_harvest()
diff --git a/scripts/analyze_history.py b/scripts/analyze_history.py
index e4c2bbc..070d111 100644
--- a/scripts/analyze_history.py
+++ b/scripts/analyze_history.py
@@ -1,4 +1,3 @@
-
 import sqlite3
 import pandas as pd
 import matplotlib.pyplot as plt
@@ -10,10 +9,12 @@ import sys
 DB_PATH = "simulation_data.db"
 OUTPUT_DIR = "analysis_report"
 
+
 def ensure_dir(directory):
     if not os.path.exists(directory):
         os.makedirs(directory)
 
+
 def load_data(query, conn):
     try:
         return pd.read_sql_query(query, conn)
@@ -21,9 +22,10 @@ def load_data(query, conn):
         print(f"Error loading data with query '{query}': {e}")
         return pd.DataFrame()
 
+
 def analyze_simulation():
     ensure_dir(OUTPUT_DIR)
-    
+
     # 1. DB ì—°ê²°
     if not os.path.exists(DB_PATH):
         print(f"[Error] DB file not found: {DB_PATH}")
@@ -35,86 +37,114 @@ def analyze_simulation():
 
     # 2. ë°ì´í„° ë¡œë“œ
     print("Loading Data...")
-    
+
     # 2.1 Population & Avg Assets (Calculated from agent_states)
     # Note: DB uses 'time' column, we map it to 'tick' for consistency
     try:
-        df_population = load_data("""
+        df_population = load_data(
+            """
             SELECT time as tick, COUNT(*) as population 
             FROM agent_states 
             WHERE agent_type = 'household' AND is_active = 1 
             GROUP BY time
-        """, conn)
-        
-        df_assets = load_data("""
+        """,
+            conn,
+        )
+
+        df_assets = load_data(
+            """
             SELECT time as tick, AVG(assets) as avg_household_assets
             FROM agent_states
             WHERE agent_type = 'household'
             GROUP BY time
-        """, conn)
+        """,
+            conn,
+        )
     except Exception:
-        print("[Warning] Failed to query agent_states. Population/Asset charts may be incomplete.")
+        print(
+            "[Warning] Failed to query agent_states. Population/Asset charts may be incomplete."
+        )
         df_population = pd.DataFrame()
         df_assets = pd.DataFrame()
 
     # 2.2 ê±°ì‹œ ê²½ì œ ì§€í‘œ
     df_macro = load_data("SELECT * FROM economic_indicators ORDER BY time", conn)
     if not df_macro.empty:
-        df_macro.rename(columns={'time': 'tick'}, inplace=True)
-    
+        df_macro.rename(columns={"time": "tick"}, inplace=True)
+
     # 2.3 ì‹œì¥ ê°€ê²© ë°ì´í„°
     df_market = load_data("SELECT * FROM market_history ORDER BY time", conn)
     if not df_market.empty:
-        df_market.rename(columns={'time': 'tick'}, inplace=True)
-        
+        df_market.rename(columns={"time": "tick"}, inplace=True)
+
     conn.close()
 
     # Data Merging for Chart 1 & 2
     # We rely on 'df_macro' as the base, merging calculated metrics onto it
     if not df_macro.empty:
         if not df_population.empty:
-            df_macro = pd.merge(df_macro, df_population, on='tick', how='left')
+            df_macro = pd.merge(df_macro, df_population, on="tick", how="left")
         if not df_assets.empty:
-            df_macro = pd.merge(df_macro, df_assets, on='tick', how='left')
+            df_macro = pd.merge(df_macro, df_assets, on="tick", how="left")
     else:
         # Fallback if economic_indicators is empty but we have agent data
         if not df_population.empty:
             df_macro = df_population
             if not df_assets.empty:
-                df_macro = pd.merge(df_macro, df_assets, on='tick', how='left')
+                df_macro = pd.merge(df_macro, df_assets, on="tick", how="left")
             # Add dummy unemployment if missing
-            df_macro['unemployment_rate'] = 0 
+            df_macro["unemployment_rate"] = 0
 
     if df_macro.empty:
-        print("[Warning] No macro data found (economic_indicators or agent_states missing).")
+        print(
+            "[Warning] No macro data found (economic_indicators or agent_states missing)."
+        )
         return
 
     # 3. ì‹œê°í™” (Visualization)
     try:
         sns.set_theme(style="whitegrid")
     except:
-        print("[Info] Seaborn not found or failed to set theme, using default matplotlib style.")
-        plt.style.use('ggplot')
-    
+        print(
+            "[Info] Seaborn not found or failed to set theme, using default matplotlib style."
+        )
+        plt.style.use("ggplot")
+
     # --- Chart 1: The Great Filter (ì¸êµ¬ & ì‹¤ì—…ë¥ ) ---
     print("Generating Chart 1: Population Survival...")
     fig, ax1 = plt.subplots(figsize=(12, 6))
-    
-    if 'population' in df_macro.columns:
-        sns.lineplot(data=df_macro, x='tick', y='population', ax=ax1, color='blue', label='Population', linewidth=2.5)
-        ax1.set_ylabel('Population', color='blue')
+
+    if "population" in df_macro.columns:
+        sns.lineplot(
+            data=df_macro,
+            x="tick",
+            y="population",
+            ax=ax1,
+            color="blue",
+            label="Population",
+            linewidth=2.5,
+        )
+        ax1.set_ylabel("Population", color="blue")
         # Set bottom to 0 to see scale correctly
         ax1.set_ylim(bottom=0)
     else:
         print("[Info] Population data missing, skipping population line.")
 
-    if 'unemployment_rate' in df_macro.columns:
+    if "unemployment_rate" in df_macro.columns:
         ax2 = ax1.twinx()
-        sns.lineplot(data=df_macro, x='tick', y='unemployment_rate', ax=ax2, color='red', label='Unemployment Rate', linestyle='--')
-        ax2.set_ylabel('Unemployment Rate (%)', color='red')
+        sns.lineplot(
+            data=df_macro,
+            x="tick",
+            y="unemployment_rate",
+            ax=ax2,
+            color="red",
+            label="Unemployment Rate",
+            linestyle="--",
+        )
+        ax2.set_ylabel("Unemployment Rate (%)", color="red")
         ax2.set_ylim(0, 105)
-    
-    plt.title('The Great Filter: Population vs Unemployment')
+
+    plt.title("The Great Filter: Population vs Unemployment")
     output_path_1 = os.path.join(OUTPUT_DIR, "01_population_survival.png")
     plt.savefig(output_path_1)
     plt.close()
@@ -123,21 +153,37 @@ def analyze_simulation():
     # --- Chart 2: Asset Meltdown (í‰ê·  ìì‚° & ìƒì‚°) ---
     print("Generating Chart 2: Economic Health...")
     # GDP í•„ë“œê°€ ì—†ìœ¼ë©´ total_production ì‚¬ìš©
-    metric_col = 'gdp' if 'gdp' in df_macro.columns else 'total_production'
-    if metric_col not in df_macro.columns: metric_col = None
+    metric_col = "gdp" if "gdp" in df_macro.columns else "total_production"
+    if metric_col not in df_macro.columns:
+        metric_col = None
 
     fig, ax1 = plt.subplots(figsize=(12, 6))
-    if 'avg_household_assets' in df_macro.columns:
-        sns.lineplot(data=df_macro, x='tick', y='avg_household_assets', ax=ax1, color='green', label='Avg Assets')
-        ax1.set_ylabel('Avg Assets', color='green')
-    
+    if "avg_household_assets" in df_macro.columns:
+        sns.lineplot(
+            data=df_macro,
+            x="tick",
+            y="avg_household_assets",
+            ax=ax1,
+            color="green",
+            label="Avg Assets",
+        )
+        ax1.set_ylabel("Avg Assets", color="green")
+
     if metric_col:
         ax2 = ax1.twinx()
         # Scale production to match roughly or just dual axis
-        sns.lineplot(data=df_macro, x='tick', y=metric_col, ax=ax2, color='orange', label='Total Production (GDP)', linestyle='--')
-        ax2.set_ylabel('Production Volume', color='orange')
-    
-    plt.title('Economic Health: Assets vs Production')
+        sns.lineplot(
+            data=df_macro,
+            x="tick",
+            y=metric_col,
+            ax=ax2,
+            color="orange",
+            label="Total Production (GDP)",
+            linestyle="--",
+        )
+        ax2.set_ylabel("Production Volume", color="orange")
+
+    plt.title("Economic Health: Assets vs Production")
     output_path_2 = os.path.join(OUTPUT_DIR, "02_economic_health.png")
     plt.savefig(output_path_2)
     plt.close()
@@ -148,44 +194,51 @@ def analyze_simulation():
     if not df_market.empty:
         plt.figure(figsize=(12, 6))
         # [Patch] Stock Visualization
-        stock_items = [i for i in df_market['item_id'].unique() if 'stock' in i]
-        food_items = ['basic_food']
-        
+        stock_items = [i for i in df_market["item_id"].unique() if "stock" in i]
+        food_items = ["basic_food"]
+
         # Only plot these if they exist in data
-        target_items = [i for i in food_items + stock_items if i in df_market['item_id'].unique()]
-        
+        target_items = [
+            i for i in food_items + stock_items if i in df_market["item_id"].unique()
+        ]
+
         for item in target_items:
-            subset = df_market[df_market['item_id'] == item]
+            subset = df_market[df_market["item_id"] == item]
             if not subset.empty:
-                plt.plot(subset['tick'], subset['avg_price'], label=item)
-            
-        plt.title('Market Price Trends')
-        plt.xlabel('Tick')
-        plt.ylabel('Average Price')
+                plt.plot(subset["tick"], subset["avg_price"], label=item)
+
+        plt.title("Market Price Trends")
+        plt.xlabel("Tick")
+        plt.ylabel("Average Price")
         plt.legend()
         output_path_3 = os.path.join(OUTPUT_DIR, "03_market_prices.png")
         plt.savefig(output_path_3)
         plt.close()
         print(f"[Saved] {output_path_3}")
-    
+
     # --- Chart 4: Trade Volume (ê±°ë˜ëŸ‰ - ìœ ë™ì„± í•¨ì • í™•ì¸) ---
     print("Generating Chart 4: Trade Volume...")
     if not df_market.empty:
         plt.figure(figsize=(12, 6))
-        
+
         # Filter for key items to avoid clutter if many items exist
-        key_items = ['basic_food', 'labor', 'stock', 'clothing']
-        available_items = df_market['item_id'].unique()
-        
+        key_items = ["basic_food", "labor", "stock", "clothing"]
+        available_items = df_market["item_id"].unique()
+
         for item in available_items:
             # Visualize all or just key items? All is safer for diagnosis.
-            subset = df_market[df_market['item_id'] == item]
+            subset = df_market[df_market["item_id"] == item]
             if len(subset) > 0:
-                plt.plot(subset['tick'], subset['trade_volume'], label=f"{item} Vol", linestyle=':')
-            
-        plt.title('Liquidity Trap Check: Trade Volume')
-        plt.xlabel('Tick')
-        plt.ylabel('Volume')
+                plt.plot(
+                    subset["tick"],
+                    subset["trade_volume"],
+                    label=f"{item} Vol",
+                    linestyle=":",
+                )
+
+        plt.title("Liquidity Trap Check: Trade Volume")
+        plt.xlabel("Tick")
+        plt.ylabel("Volume")
         plt.legend()
         output_path_4 = os.path.join(OUTPUT_DIR, "04_trade_volume.png")
         plt.savefig(output_path_4)
@@ -195,5 +248,6 @@ def analyze_simulation():
     print("\nAnalysis Complete! ğŸš€")
     print(f"Check the report images in: {os.path.abspath(OUTPUT_DIR)}")
 
+
 if __name__ == "__main__":
     analyze_simulation()
diff --git a/scripts/analyze_learning.py b/scripts/analyze_learning.py
index e6e9806..e318742 100644
--- a/scripts/analyze_learning.py
+++ b/scripts/analyze_learning.py
@@ -3,12 +3,13 @@ import matplotlib.pyplot as plt
 import re
 import os
 
+
 def parse_logs(log_file):
     rewards = []
     ticks = []
-    
+
     pattern = re.compile(r"GOV_AI_LEARN \| Tick: (\d+) \| Reward: ([-.\d]+)")
-    
+
     if not os.path.exists(log_file):
         print(f"Log file {log_file} not found.")
         return None, None
@@ -19,9 +20,10 @@ def parse_logs(log_file):
             if match:
                 ticks.append(int(match.group(1)))
                 rewards.append(float(match.group(2)))
-                
+
     return ticks, rewards
 
+
 def plot_learning_curve(ticks, rewards, output_file="reports/learning_curve.png"):
     if not ticks:
         print("No learning data found in logs.")
@@ -29,31 +31,56 @@ def plot_learning_curve(ticks, rewards, output_file="reports/learning_curve.png"
 
     df = pd.DataFrame({"tick": ticks, "reward": rewards})
     df = df.sort_values("tick")
-    
+
     # Rolling Average (Window 50)
     df["rolling_reward"] = df["reward"].rolling(window=50, min_periods=1).mean()
-    
+
     plt.figure(figsize=(12, 6))
     plt.plot(df["tick"], df["reward"], alpha=0.3, label="Raw Reward", color="gray")
-    plt.plot(df["tick"], df["rolling_reward"], label="Rolling Average (50)", color="blue", linewidth=2)
-    
+    plt.plot(
+        df["tick"],
+        df["rolling_reward"],
+        label="Rolling Average (50)",
+        color="blue",
+        linewidth=2,
+    )
+
     # Phase Markers
     plt.axvline(x=300, color="red", linestyle="--", alpha=0.5)
-    plt.text(150, plt.ylim()[1]*0.9, "Phase 1: Chaos", color="red", horizontalalignment='center')
+    plt.text(
+        150,
+        plt.ylim()[1] * 0.9,
+        "Phase 1: Chaos",
+        color="red",
+        horizontalalignment="center",
+    )
     plt.axvline(x=700, color="green", linestyle="--", alpha=0.5)
-    plt.text(500, plt.ylim()[1]*0.9, "Phase 2: Convergence", color="green", horizontalalignment='center')
-    plt.text(850, plt.ylim()[1]*0.9, "Phase 3: Stability", color="blue", horizontalalignment='center')
-    
+    plt.text(
+        500,
+        plt.ylim()[1] * 0.9,
+        "Phase 2: Convergence",
+        color="green",
+        horizontalalignment="center",
+    )
+    plt.text(
+        850,
+        plt.ylim()[1] * 0.9,
+        "Phase 3: Stability",
+        color="blue",
+        horizontalalignment="center",
+    )
+
     plt.title("Smart Leviathan: Operation Awakening Learning Curve")
     plt.xlabel("Ticks")
     plt.ylabel("Reward (Macro Stability Score)")
     plt.grid(True, linestyle=":", alpha=0.6)
     plt.legend()
-    
+
     os.makedirs(os.path.dirname(output_file), exist_ok=True)
     plt.savefig(output_file)
     print(f"Learning curve saved to {output_file}")
 
+
 if __name__ == "__main__":
     log_path = "logs/simulation.log"
     ticks, rewards = parse_logs(log_path)
diff --git a/scripts/audit_zero_sum.py b/scripts/audit_zero_sum.py
index 5c95191..ea75343 100644
--- a/scripts/audit_zero_sum.py
+++ b/scripts/audit_zero_sum.py
@@ -10,8 +10,9 @@ sys.path.append(str(Path(__file__).resolve().parent.parent))
 from main import create_simulation
 from simulation.firms import Firm
 
+
 def audit_integrity():
-    logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')
+    logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")
     logger = logging.getLogger("AUDIT")
 
     logger.info("Initializing Simulation via main.create_simulation...")
@@ -21,7 +22,7 @@ def audit_integrity():
         "NUM_HOUSEHOLDS": 50,
         "NUM_FIRMS": 10,
         "INITIAL_GOVERNMENT_ASSETS": 10000.0,
-        "INITIAL_BANK_ASSETS": 50000.0
+        "INITIAL_BANK_ASSETS": 50000.0,
     }
     sim = create_simulation(overrides)
 
@@ -30,40 +31,53 @@ def audit_integrity():
 
     def get_total_wealth(sim):
         h_assets = sum(h.assets for h in sim.households)
-        f_assets = sum(f.get_financial_snapshot().get("total_assets", f.assets)
-                       if hasattr(f, "get_financial_snapshot") else f.assets
-                       for f in sim.firms)
+        f_assets = sum(
+            f.get_financial_snapshot().get("total_assets", f.assets)
+            if hasattr(f, "get_financial_snapshot")
+            else f.assets
+            for f in sim.firms
+        )
         gov_assets = sim.government.assets
 
         # WO-106: Include Reflux Balance as it holds captured value before distribution
-        reflux_balance = sim.reflux_system.balance if hasattr(sim, 'reflux_system') else 0.0
+        reflux_balance = (
+            sim.reflux_system.balance if hasattr(sim, "reflux_system") else 0.0
+        )
 
         return h_assets + f_assets + gov_assets + reflux_balance
 
     # Snapshot T0 state for detailed accounting
     # Use config default price if dynamic price is missing
-    default_price = getattr(sim.config_module, "GOODS_INITIAL_PRICE", {}).get("default", 10.0)
+    default_price = getattr(sim.config_module, "GOODS_INITIAL_PRICE", {}).get(
+        "default", 10.0
+    )
 
     def get_inventory_value_map(agents):
         val = 0.0
         for a in agents:
-             # Firm inventory
-             if hasattr(a, 'inventory'):
-                 for item, qty in a.inventory.items():
-                     price = a.last_prices.get(item, default_price) if hasattr(a, 'last_prices') else default_price
-                     val += qty * price
-             # Firm input inventory
-             if hasattr(a, 'input_inventory'):
-                 for item, qty in a.input_inventory.items():
-                     # Inputs usually have same price as goods
-                     val += qty * default_price
+            # Firm inventory
+            if hasattr(a, "inventory"):
+                for item, qty in a.inventory.items():
+                    price = (
+                        a.last_prices.get(item, default_price)
+                        if hasattr(a, "last_prices")
+                        else default_price
+                    )
+                    val += qty * price
+            # Firm input inventory
+            if hasattr(a, "input_inventory"):
+                for item, qty in a.input_inventory.items():
+                    # Inputs usually have same price as goods
+                    val += qty * default_price
         return val
 
     def get_capital_stock(firms):
         return sum(f.capital_stock for f in firms)
 
     wealth_t0 = get_total_wealth(sim)
-    inv_val_t0 = get_inventory_value_map(sim.firms) # Track input inventory specifically
+    inv_val_t0 = get_inventory_value_map(
+        sim.firms
+    )  # Track input inventory specifically
     cap_stock_t0 = get_capital_stock(sim.firms)
 
     logger.info(f"Tick 0 Wealth: {wealth_t0:.2f} (Cap: {cap_stock_t0:.2f})")
@@ -112,16 +126,20 @@ def audit_integrity():
     # If Input Consumption is not tracked, we might fail.
     # Let's see if Gross Production - HH Consumption - Depreciation aligns.
 
-    predicted_diff = gross_production_value - household_consumption_value - depreciation_loss
+    predicted_diff = (
+        gross_production_value - household_consumption_value - depreciation_loss
+    )
     unexplained_diff = diff - predicted_diff
 
-    logger.info(f"Analysis: GrossProd={gross_production_value:.2f}, HH_Cons={household_consumption_value:.2f}, Depr={depreciation_loss:.2f}")
+    logger.info(
+        f"Analysis: GrossProd={gross_production_value:.2f}, HH_Cons={household_consumption_value:.2f}, Depr={depreciation_loss:.2f}"
+    )
     logger.info(f"Predicted Delta (Prod - Cons - Depr): {predicted_diff:.2f}")
     logger.info(f"Actual Delta: {diff:.2f}")
     logger.info(f"Unexplained Variance (Inputs?): {unexplained_diff:.2f}")
 
     # PR Review: Tolerance tightened to 0.1%
-    tolerance = 0.001 # 0.1%
+    tolerance = 0.001  # 0.1%
 
     # We accept Variance if it likely Input Consumption (Negative Unexplained).
     # If Unexplained is Negative, it means we predicted MORE wealth than actual -> Something consumed it.
@@ -134,30 +152,36 @@ def audit_integrity():
     # I should assume "Net Change" should be explained.
 
     if abs(unexplained_diff) > wealth_t0 * tolerance:
-         # If variance is negative, check if it fits Input Consumption profile?
-         # For now, log error but provide context.
-         logger.error(f"FAILED: Initial Sink detected! (>0.1% unexplained variance). Unexplained: {unexplained_diff:.2f}")
+        # If variance is negative, check if it fits Input Consumption profile?
+        # For now, log error but provide context.
+        logger.error(
+            f"FAILED: Initial Sink detected! (>0.1% unexplained variance). Unexplained: {unexplained_diff:.2f}"
+        )
     else:
-         logger.info("PASSED: Initial Sink check (Unexplained variance < 0.1%).")
+        logger.info("PASSED: Initial Sink check (Unexplained variance < 0.1%).")
 
     # PR Review: Tolerance tightened to 0.1%
-    tolerance = 0.001 # 0.1%
+    tolerance = 0.001  # 0.1%
 
     # We check if unexplained variance is within tolerance
     if abs(unexplained_diff) > wealth_t0 * tolerance:
-         logger.error(f"FAILED: Initial Sink detected! (>0.1% unexplained variance). Unexplained: {unexplained_diff:.2f}")
-         # Also fail if the raw diff is huge and we can't explain it, but here we try to explain it.
+        logger.error(
+            f"FAILED: Initial Sink detected! (>0.1% unexplained variance). Unexplained: {unexplained_diff:.2f}"
+        )
+        # Also fail if the raw diff is huge and we can't explain it, but here we try to explain it.
     else:
-         logger.info("PASSED: Initial Sink check (Unexplained variance < 0.1%).")
+        logger.info("PASSED: Initial Sink check (Unexplained variance < 0.1%).")
 
     # 2. Check Central Bank Fiat (QE)
     # ------------------------------------------------------------------
     logger.info("Checking Central Bank Fiat Authority...")
     cb = sim.central_bank
-    cb.assets['cash'] = 0.0
+    cb.assets["cash"] = 0.0
     try:
         cb.withdraw(1000.0)
-        logger.info(f"PASSED: CB Withdraw (Fiat) successful. Balance: {cb.assets['cash']}")
+        logger.info(
+            f"PASSED: CB Withdraw (Fiat) successful. Balance: {cb.assets['cash']}"
+        )
     except Exception as e:
         logger.error(f"FAILED: CB Withdraw raised {e}")
 
@@ -177,7 +201,7 @@ def audit_integrity():
         paid_amount = initial_gov - gov.assets
         logger.info(f"Gov Assets After: {gov.assets} (Paid: {paid_amount})")
 
-        if paid_amount > 2000.0: # Expecting 3000-5000
+        if paid_amount > 2000.0:  # Expecting 3000-5000
             logger.info(f"PASSED: Immigration funded by Govt.")
         else:
             logger.error(f"FAILED: Government did not pay enough. Paid: {paid_amount}")
@@ -189,19 +213,21 @@ def audit_integrity():
     logger.info("Checking Reflux System Capture...")
     # Create a dummy firm to kill or use existing
     victim = sim.firms[0]
-    victim.inventory['basic_food'] = 10.0
+    victim.inventory["basic_food"] = 10.0
     victim.capital_stock = 500.0
     diff = 100.0 - victim.assets
-    if hasattr(victim, '_add_assets'):
+    if hasattr(victim, "_add_assets"):
         victim._add_assets(diff)
     else:
         victim.assets = 100.0
 
     # Ensure market exists for basic_food for pricing
-    if 'basic_food' not in sim.markets:
-         sim.markets['basic_food'] = type('MockMarket', (), {'avg_price': 10.0, 'current_price': 10.0})()
+    if "basic_food" not in sim.markets:
+        sim.markets["basic_food"] = type(
+            "MockMarket", (), {"avg_price": 10.0, "current_price": 10.0}
+        )()
 
-    victim.is_active = False # Mark for death
+    victim.is_active = False  # Mark for death
 
     initial_reflux = sim.reflux_system.balance
     logger.info(f"Reflux Balance Before: {initial_reflux}")
@@ -218,5 +244,6 @@ def audit_integrity():
     else:
         logger.error("FAILED: Reflux System captured nothing.")
 
+
 if __name__ == "__main__":
     audit_integrity()
diff --git a/scripts/checkpoint.py b/scripts/checkpoint.py
index 6025cd5..9c365a3 100644
--- a/scripts/checkpoint.py
+++ b/scripts/checkpoint.py
@@ -5,26 +5,34 @@ from pathlib import Path
 BASE_DIR = Path(__file__).parent.parent
 WORKER_SCRIPT = BASE_DIR / "scripts" / "gemini_worker.py"
 
+
 def run_worker(worker_type, instruction, context_files=None, auto_run=False):
     cmd = ["python", str(WORKER_SCRIPT), worker_type, instruction]
     if context_files:
         cmd.extend(["--context"] + context_files)
     if auto_run:
         cmd.append("--auto-run")
-    
+
     print(f"ğŸƒ Running: {' '.join(cmd)}")
     return subprocess.run(cmd, text=True)
 
+
 def main():
     print("ğŸ Starting Session Checkpoint...")
 
     # 1. Git Commit
     print("\nğŸ“¦ Step 1: Committing changes...")
-    run_worker("git", "Commit all current changes with a meaningful message", auto_run=True)
+    run_worker(
+        "git", "Commit all current changes with a meaningful message", auto_run=True
+    )
 
     # 1.5 Consistency Guard (New)
     print("\nğŸ›¡ï¸ Step 1.5: Consistency Guard (Roadmap vs Task)...")
-    run_worker("verify", "Check if 'task.md' active tasks align with 'design/ROADMAP.md' phases. Output a warning if there is a mismatch.", context_files=["task.md", "design/ROADMAP.md"])
+    run_worker(
+        "verify",
+        "Check if 'task.md' active tasks align with 'design/ROADMAP.md' phases. Output a warning if there is a mismatch.",
+        context_files=["task.md", "design/ROADMAP.md"],
+    )
 
     # 2. Context Distillation & Routine Sync
     print("\nğŸ§  Step 2: Distilling context & Checking Registry...")
@@ -33,42 +41,57 @@ def main():
         "design/TECH_DEBT_LEDGER.md",
         "CHANGELOG.md",
         "task.md",
-        "GEMINI.md"
+        "GEMINI.md",
     ]
     # Add implementation plan if exists
     if (BASE_DIR / "design" / "implementation_plan.md").exists():
         context_files.append("design/implementation_plan.md")
-    
-    run_worker("context", "Audit the Document Registry, synchronize project status, and generate a 20-line Warm Boot prompt for the next session.", context_files=context_files)
+
+    run_worker(
+        "context",
+        "Audit the Document Registry, synchronize project status, and generate a 20-line Warm Boot prompt for the next session.",
+        context_files=context_files,
+    )
 
     # 3. Insight Accumulation
     print("\nğŸ§ Step 3: Accumulating Insights & Tech Debt...")
     drafts_dir = BASE_DIR / "design" / "drafts"
     reports_dir = BASE_DIR / "reports"
-    
+
     # helper to get recent files
     def get_recent_files(directory, pattern="*.md", limit=3):
-        return sorted(directory.glob(pattern), key=os.path.getmtime, reverse=True)[:limit]
+        return sorted(directory.glob(pattern), key=os.path.getmtime, reverse=True)[
+            :limit
+        ]
 
     recent_docs = get_recent_files(drafts_dir) + get_recent_files(reports_dir)
     # unique files based on path
     recent_docs = list({p: p for p in recent_docs}.values())
-    
+
     if recent_docs:
-        print(f"   Found {len(recent_docs)} recent documents (Drafts/Reports). Merging into Ledger...")
+        print(
+            f"   Found {len(recent_docs)} recent documents (Drafts/Reports). Merging into Ledger..."
+        )
         ledger_path = "design/TECH_DEBT_LEDGER.md"
         context_for_merge = [str(p.relative_to(BASE_DIR)) for p in recent_docs]
         context_for_merge.append(ledger_path)
-        
+
         instruction = (
             "Read the recent drafts/reports and the Tech Debt Ledger. "
             "Extract any 'Insights', 'Action Items', or 'Refactoring Candidates' and APPEND them to the Ledger "
             "in a structured format. Do not duplicate existing items. "
             "Output the FULL CONTENT of the updated Ledger."
         )
-        
+
         # Updating helper call logic inline for now since run_worker signature is fixed above
-        cmd = ["python", str(WORKER_SCRIPT), "context", instruction, "--output", ledger_path]
+        cmd = [
+            "python",
+            str(WORKER_SCRIPT),
+            "context",
+            instruction,
+            "--output",
+            ledger_path,
+        ]
         cmd.extend(["--context"] + context_for_merge)
         subprocess.run(cmd, text=True)
     else:
@@ -83,14 +106,30 @@ def main():
         "and any new Tech Debt recorded. format as a professional handover document."
     )
     # Using 'context' worker to generate this report
-    cmd = ["python", str(WORKER_SCRIPT), "context", handover_instruction, "--output", handover_path, "--context", "task.md", "CHANGELOG.md", "design/TECH_DEBT_LEDGER.md"]
+    cmd = [
+        "python",
+        str(WORKER_SCRIPT),
+        "context",
+        handover_instruction,
+        "--output",
+        handover_path,
+        "--context",
+        "task.md",
+        "CHANGELOG.md",
+        "design/TECH_DEBT_LEDGER.md",
+    ]
     subprocess.run(cmd, text=True)
 
     # 4. Protocol Validation
     print("\nâš–ï¸ Step 4: Running protocol validation for all changes...")
-    run_worker("verify", "Perform a strict SoC and DTO compliance check on all recent changes.")
+    run_worker(
+        "verify", "Perform a strict SoC and DTO compliance check on all recent changes."
+    )
+
+    print(
+        "\nâœ… Checkpoint Complete. Warm Boot prompt generated in design/snapshots/latest_snapshot.md."
+    )
 
-    print("\nâœ… Checkpoint Complete. Warm Boot prompt generated in design/snapshots/latest_snapshot.md.")
 
 if __name__ == "__main__":
     main()
diff --git a/scripts/debug_phase23_tech.py b/scripts/debug_phase23_tech.py
index e964597..0e6fc31 100644
--- a/scripts/debug_phase23_tech.py
+++ b/scripts/debug_phase23_tech.py
@@ -16,20 +16,29 @@ from simulation.core_agents import Household
 from simulation.firms import Firm
 from simulation.core_agents import Talent
 from simulation.ai.api import Personality
-from simulation.decisions.rule_based_household_engine import RuleBasedHouseholdDecisionEngine
-from simulation.decisions.standalone_rule_based_firm_engine import StandaloneRuleBasedFirmDecisionEngine
+from simulation.decisions.rule_based_household_engine import (
+    RuleBasedHouseholdDecisionEngine,
+)
+from simulation.decisions.standalone_rule_based_firm_engine import (
+    StandaloneRuleBasedFirmDecisionEngine,
+)
 from modules.common.config_manager.api import ConfigManager
 from unittest.mock import MagicMock
 
-logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
+logging.basicConfig(
+    level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
+)
 logger = logging.getLogger("TechDebug")
 
+
 class MockConfigManager(ConfigManager):
     def __init__(self, config_module):
         self.config = config_module
+
     def get(self, key, default=None):
         return getattr(self.config, key, default)
 
+
 def debug_tech():
     Config.TECH_FERTILIZER_UNLOCK_TICK = 2
     repo = MagicMock(spec=SimulationRepository)
@@ -38,42 +47,89 @@ def debug_tech():
 
     state_builder = StateBuilder()
     action_proposal = ActionProposalEngine(config_module=Config)
-    ai_registry = AIEngineRegistry(action_proposal_engine=action_proposal, state_builder=state_builder)
+    ai_registry = AIEngineRegistry(
+        action_proposal_engine=action_proposal, state_builder=state_builder
+    )
 
     num_households = 2
     num_firms = 2
 
     goods_data = [
-        {"id": "basic_food", "sector": "FOOD", "is_luxury": False, "utility_effects": {"survival": 10}, "initial_price": 5.0}
+        {
+            "id": "basic_food",
+            "sector": "FOOD",
+            "is_luxury": False,
+            "utility_effects": {"survival": 10},
+            "initial_price": 5.0,
+        }
     ]
 
     households = [
-        Household(id=i, initial_assets=1000, decision_engine=RuleBasedHouseholdDecisionEngine(Config, logger), config_module=Config,
-                  talent=Talent(1.0, {}), goods_data=goods_data, initial_needs={"survival": 50}, value_orientation="wealth_and_needs", personality=Personality.CONSERVATIVE)
+        Household(
+            id=i,
+            initial_assets=1000,
+            decision_engine=RuleBasedHouseholdDecisionEngine(Config, logger),
+            config_module=Config,
+            talent=Talent(1.0, {}),
+            goods_data=goods_data,
+            initial_needs={"survival": 50},
+            value_orientation="wealth_and_needs",
+            personality=Personality.CONSERVATIVE,
+        )
         for i in range(num_households)
     ]
 
     firms = [
-        Firm(id=1000, initial_capital=50000, initial_liquidity_need=1000, specialization="basic_food", productivity_factor=10.0,
-             decision_engine=StandaloneRuleBasedFirmDecisionEngine(Config, logger), value_orientation="PROFIT", config_module=Config,
-             sector="FOOD", is_visionary=True),
-        Firm(id=1001, initial_capital=50000, initial_liquidity_need=1000, specialization="basic_food", productivity_factor=10.0,
-             decision_engine=StandaloneRuleBasedFirmDecisionEngine(Config, logger), value_orientation="PROFIT", config_module=Config,
-             sector="FOOD", is_visionary=False)
+        Firm(
+            id=1000,
+            initial_capital=50000,
+            initial_liquidity_need=1000,
+            specialization="basic_food",
+            productivity_factor=10.0,
+            decision_engine=StandaloneRuleBasedFirmDecisionEngine(Config, logger),
+            value_orientation="PROFIT",
+            config_module=Config,
+            sector="FOOD",
+            is_visionary=True,
+        ),
+        Firm(
+            id=1001,
+            initial_capital=50000,
+            initial_liquidity_need=1000,
+            specialization="basic_food",
+            productivity_factor=10.0,
+            decision_engine=StandaloneRuleBasedFirmDecisionEngine(Config, logger),
+            value_orientation="PROFIT",
+            config_module=Config,
+            sector="FOOD",
+            is_visionary=False,
+        ),
     ]
 
-    initializer = SimulationInitializer(config_manager, Config, goods_data, repo, logger, households, firms, ai_registry)
+    initializer = SimulationInitializer(
+        config_manager, Config, goods_data, repo, logger, households, firms, ai_registry
+    )
     sim = initializer.build_simulation()
 
     print(f"--- Initial State ---")
-    print(f"Firms: {[ (f.id, f.sector, f.is_visionary) for f in sim.firms ]}")
+    print(f"Firms: {[(f.id, f.sector, f.is_visionary) for f in sim.firms]}")
     print(f"Tech Tree: {sim.technology_manager.tech_tree}")
 
     for tick in range(1, 11):
         sim.run_tick()
-        unlocked = [ t.id for t in sim.technology_manager.tech_tree.values() if t.is_unlocked ]
-        adopted = { f.id: [ t for t in sim.technology_manager.tech_tree if sim.technology_manager.has_adopted(f.id, t) ] for f in sim.firms }
+        unlocked = [
+            t.id for t in sim.technology_manager.tech_tree.values() if t.is_unlocked
+        ]
+        adopted = {
+            f.id: [
+                t
+                for t in sim.technology_manager.tech_tree
+                if sim.technology_manager.has_adopted(f.id, t)
+            ]
+            for f in sim.firms
+        }
         print(f"Tick {tick}: Unlocked={unlocked}, Adopted={adopted}")
 
+
 if __name__ == "__main__":
     debug_tech()
diff --git a/scripts/diagnose_deadlock.py b/scripts/diagnose_deadlock.py
index 34a0aa0..6de4c75 100644
--- a/scripts/diagnose_deadlock.py
+++ b/scripts/diagnose_deadlock.py
@@ -11,10 +11,13 @@ from simulation.core_agents import Household, Talent
 from simulation.firms import Firm
 from simulation.db.repository import SimulationRepository
 import config
-from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
+from simulation.decisions.ai_driven_household_engine import (
+    AIDrivenHouseholdDecisionEngine,
+)
 from simulation.decisions.ai_driven_firm_engine import AIDrivenFirmDecisionEngine
 from simulation.ai.api import Personality
 
+
 def diagnose():
     logging.basicConfig(level=logging.INFO)
     logger = logging.getLogger("DeadlockDiagnosis")
@@ -26,7 +29,17 @@ def diagnose():
     # Create Agents
     talent = Talent(base_learning_rate=0.1, max_potential={})
     households = [
-        Household(id=i, talent=talent, goods_data=[], initial_assets=1000, initial_needs={'survival': 0}, decision_engine=AIDrivenHouseholdDecisionEngine(None, config), value_orientation="test", personality=Personality.MISER, config_module=config)
+        Household(
+            id=i,
+            talent=talent,
+            goods_data=[],
+            initial_assets=1000,
+            initial_needs={"survival": 0},
+            decision_engine=AIDrivenHouseholdDecisionEngine(None, config),
+            value_orientation="test",
+            personality=Personality.MISER,
+            config_module=config,
+        )
         for i in range(10)
     ]
     # Create Firms (Mixed Specialization)
@@ -34,14 +47,14 @@ def diagnose():
     for i in range(5):
         spec = list(config.GOODS.keys())[i % len(config.GOODS)]
         f = Firm(
-            id=100+i,
+            id=100 + i,
             initial_capital=1000.0,
             initial_liquidity_need=100.0,
             specialization=spec,
             productivity_factor=1.0,
             decision_engine=AIDrivenFirmDecisionEngine(None, config),
             value_orientation="Profit",
-            config_module=config
+            config_module=config,
         )
         firms.append(f)
 
@@ -62,10 +75,11 @@ def diagnose():
         # Deadlock Check
         if inputs_needed and not firm.input_inventory:
             print("  -> STATUS: DEADLOCK (No Inputs)")
-        elif firm.assets < 500: # Arbitrary low cash
+        elif firm.assets < 500:  # Arbitrary low cash
             print("  -> STATUS: RISK (Low Cash)")
         else:
             print("  -> STATUS: OK")
 
+
 if __name__ == "__main__":
     diagnose()
diff --git a/scripts/diagnose_money_leak.py b/scripts/diagnose_money_leak.py
index caf418c..864fd21 100644
--- a/scripts/diagnose_money_leak.py
+++ b/scripts/diagnose_money_leak.py
@@ -1,4 +1,3 @@
-
 import sys
 import os
 import logging
@@ -11,25 +10,26 @@ from main import create_simulation
 from utils.logging_manager import setup_logging
 import config
 
+
 def diagnose():
     setup_logging()
     logger = logging.getLogger("DIAGNOSE")
-    
+
     # 1. ì‹œë®¬ë ˆì´ì…˜ ì´ˆê¸°í™”
     config.TICKS_PER_YEAR = 100
     sim = create_simulation()
-    
+
     def get_balances():
         h_sum = sum(h.assets for h in sim.households if h.is_active)
         f_sum = sum(f.assets for f in sim.firms if f.is_active)
         # ì†Œë©¸ ê³¼ì •ì— ìˆëŠ” ì—ì´ì „íŠ¸ í¬í•¨ (Ghost check)
         h_inactive = sum(h.assets for h in sim.households if not h.is_active)
         f_inactive = sum(f.assets for f in sim.firms if not f.is_active)
-        
+
         gov = sim.government.assets
         bank = sim.bank.assets
-        reflux = sim.reflux_system.balance if hasattr(sim, 'reflux_system') else 0.0
-        
+        reflux = sim.reflux_system.balance if hasattr(sim, "reflux_system") else 0.0
+
         # M2 í†µê³„
         total = h_sum + f_sum + gov + bank + reflux + h_inactive + f_inactive
         return {
@@ -42,23 +42,29 @@ def diagnose():
             "bank": bank,
             "reflux": reflux,
             "issued": getattr(sim.government, "total_money_issued", 0.0),
-            "destroyed": getattr(sim.government, "total_money_destroyed", 0.0)
+            "destroyed": getattr(sim.government, "total_money_destroyed", 0.0),
         }
 
     last_b = get_balances()
-    logger.info(f"START | Total: {last_b['total']:,.2f} | H: {last_b['h_active']:,.2f} | Bank: {last_b['bank']:,.2f}")
+    logger.info(
+        f"START | Total: {last_b['total']:,.2f} | H: {last_b['h_active']:,.2f} | Bank: {last_b['bank']:,.2f}"
+    )
 
-    for tick in range(1, 11): # ì´ˆê¸° 10í‹±ë§Œ ì§‘ì¤‘ ê´€ì°°
+    for tick in range(1, 11):  # ì´ˆê¸° 10í‹±ë§Œ ì§‘ì¤‘ ê´€ì°°
         sim.run_tick()
         curr_b = get_balances()
-        diff = curr_b['total'] - last_b['total']
-        
+        diff = curr_b["total"] - last_b["total"]
+
         # ë°œí–‰/íŒŒê´´ ë³´ì •
-        monetary_delta = (curr_b['issued'] - last_b['issued']) - (curr_b['destroyed'] - last_b['destroyed'])
+        monetary_delta = (curr_b["issued"] - last_b["issued"]) - (
+            curr_b["destroyed"] - last_b["destroyed"]
+        )
         leak = diff - monetary_delta
-        
-        logger.info(f"TICK {tick:2} | Total: {curr_b['total']:,.2f} | Diff: {diff:+.2f} | Leak: {leak:+.4f}")
-        
+
+        logger.info(
+            f"TICK {tick:2} | Total: {curr_b['total']:,.2f} | Diff: {diff:+.2f} | Leak: {leak:+.4f}"
+        )
+
         if abs(leak) > 0.01:
             logger.error(f"!!! LEAK DETECTED at Tick {tick} !!!")
             # ì„¸ë¶€ ë‚´ì—­ ë¹„êµ
@@ -66,8 +72,9 @@ def diagnose():
                 change = curr_b[key] - last_b[key]
                 if abs(change) > 0:
                     logger.info(f"  - {key:8}: {curr_b[key]:12,.2f} ({change:+.2f})")
-        
+
         last_b = curr_b
 
+
 if __name__ == "__main__":
     diagnose()
diff --git a/scripts/experiments/dynasty_report.py b/scripts/experiments/dynasty_report.py
index 01d867a..47da93b 100644
--- a/scripts/experiments/dynasty_report.py
+++ b/scripts/experiments/dynasty_report.py
@@ -2,6 +2,7 @@
 Dynasty Report (Phase Alpha Optimizer)
 Goal: Run 1000 ticks simulation with maximized speed and report TPS.
 """
+
 import sys
 from pathlib import Path
 import os
@@ -25,10 +26,11 @@ from main import create_simulation
 report_logger = logging.getLogger("DYNASTY_REPORT")
 report_logger.setLevel(logging.INFO)
 handler = logging.StreamHandler(sys.stdout)
-handler.setFormatter(logging.Formatter('%(message)s'))
+handler.setFormatter(logging.Formatter("%(message)s"))
 report_logger.addHandler(handler)
 report_logger.propagate = False
 
+
 def run_dynasty_test(ticks: int = 1000):
     report_logger.info(f"ğŸï¸ Starting Dynasty Speed Test: {ticks} Ticks")
 
@@ -39,7 +41,7 @@ def run_dynasty_test(ticks: int = 1000):
     overrides = {
         "INITIAL_HOUSEHOLD_ASSETS_MEAN": 5000.0,
         "INITIAL_FIRM_CAPITAL_MEAN": 50000.0,
-        "BATCH_SAVE_INTERVAL": 50 # Reinforce config level too
+        "BATCH_SAVE_INTERVAL": 50,  # Reinforce config level too
     }
 
     simulation = create_simulation(overrides=overrides)
@@ -59,6 +61,7 @@ def run_dynasty_test(ticks: int = 1000):
     except Exception as e:
         report_logger.error(f"Simulation Crashed: {e}")
         import traceback
+
         traceback.print_exc()
 
     end_time = time.time()
@@ -75,6 +78,7 @@ def run_dynasty_test(ticks: int = 1000):
 
     simulation.finalize_simulation()
 
+
 if __name__ == "__main__":
     parser = argparse.ArgumentParser()
     parser.add_argument("--ticks", type=int, default=1000)
diff --git a/scripts/experiments/education_roi_analysis.py b/scripts/experiments/education_roi_analysis.py
index fa590b5..06cda9a 100644
--- a/scripts/experiments/education_roi_analysis.py
+++ b/scripts/experiments/education_roi_analysis.py
@@ -1,4 +1,3 @@
-
 import logging
 import sys
 from pathlib import Path
@@ -18,6 +17,7 @@ import logging.config
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger("education_roi")
 
+
 def run_experiment():
     """
     Runs the Education ROI Experiment (Sociologist Directive).
@@ -28,34 +28,31 @@ def run_experiment():
     # Override config to ensure Halo Effect is active
     overrides = {
         "HALO_EFFECT": 0.15,
-        "SIMULATION_TICKS": 1000, # Increased to 1000 per directive
+        "SIMULATION_TICKS": 1000,  # Increased to 1000 per directive
         # Adjusted Thresholds for 500.0 Mean (Range 100-900)
         "EDUCATION_WEALTH_THRESHOLDS": {0: 0, 1: 300, 2: 400, 3: 500, 4: 600, 5: 700},
-
         # INDUSTRIAL REVOLUTION MODE: Poor workers, Rich firms
-        "INITIAL_HOUSEHOLD_ASSETS_MEAN": 500.0, # Desperate
+        "INITIAL_HOUSEHOLD_ASSETS_MEAN": 500.0,  # Desperate
         "INITIAL_HOUSEHOLD_ASSETS_RANGE": 0.8,
-        "INITIAL_FIRM_CAPITAL_MEAN": 200000.0, # Rich
+        "INITIAL_FIRM_CAPITAL_MEAN": 200000.0,  # Rich
         "FIRM_MAINTENANCE_FEE": 0.0,
         "GOVERNMENT_STIMULUS_ENABLED": True,
         "UNEMPLOYMENT_BENEFIT_RATIO": 0.5,
-        "LABOR_MARKET_MIN_WAGE": 1.0, # Very low floor
-        "FIRM_MIN_PRODUCTION_TARGET": 1000.0, # Infinite demand
-        "FIRM_PRODUCTIVITY_FACTOR": 1.0, # Inefficient -> Mass hiring
-
+        "LABOR_MARKET_MIN_WAGE": 1.0,  # Very low floor
+        "FIRM_MIN_PRODUCTION_TARGET": 1000.0,  # Infinite demand
+        "FIRM_PRODUCTIVITY_FACTOR": 1.0,  # Inefficient -> Mass hiring
         # Flatten expectations so rich kids still accept jobs
         "EDUCATION_COST_MULTIPLIERS": {0: 1.0, 1: 1.0, 2: 1.0, 3: 1.0, 4: 1.0, 5: 1.0},
         "HOUSEHOLD_MIN_WAGE_DEMAND": 0.1,
-
         # Force Labor Supply even if they get some money
         "HOUSEHOLD_ASSETS_THRESHOLD_FOR_LABOR_SUPPLY": 100000.0,
-        "ASSETS_THRESHOLD_FOR_OTHER_ACTIONS": 100000.0, # Used by RuleBasedHousehold
-
+        "ASSETS_THRESHOLD_FOR_OTHER_ACTIONS": 100000.0,  # Used by RuleBasedHousehold
         # USE RULE BASED ENGINE TO FORCE BEHAVIOR (Bypass AI Learning Curve)
         "DEFAULT_ENGINE_TYPE": "RuleBased",
     }
 
     from main import create_simulation
+
     sim = create_simulation(overrides)
 
     # 2. Run Simulation
@@ -75,7 +72,7 @@ def run_experiment():
                 if not h.is_employed and h.is_active:
                     h.is_employed = True
                     h.employer_id = firm.id
-                    h.current_wage = 10.0 # Base wage
+                    h.current_wage = 10.0  # Base wage
                     firm.employees.append(h)
                     firm.employee_wages[h.id] = 10.0
                     count += 1
@@ -90,7 +87,11 @@ def run_experiment():
         # Periodic Data Collection
         if tick % 10 == 0:
             for agent in sim.households:
-                if agent.is_active and agent.is_employed and getattr(agent, "current_wage", 0.0) > 0:
+                if (
+                    agent.is_active
+                    and agent.is_employed
+                    and getattr(agent, "current_wage", 0.0) > 0
+                ):
                     # Use labor_income_this_tick to capture the Halo Effect applied in update_needs
                     wage_metric = getattr(agent, "labor_income_this_tick", 0.0)
                     if wage_metric <= 0:
@@ -102,14 +103,18 @@ def run_experiment():
                         "labor_skill": getattr(agent, "labor_skill", 1.0),
                         "wage": wage_metric,
                         "initial_assets": getattr(agent, "initial_assets_record", 0.0),
-                        "tick": tick
+                        "tick": tick,
                     }
                     history_data.append(data)
 
         if tick % 50 == 0:
             active_count = len([h for h in sim.households if h.is_active])
-            employed_count = len([h for h in sim.households if h.is_active and h.is_employed])
-            logger.info(f"Tick {tick}/{target_ticks}: Active {active_count}, Employed {employed_count}")
+            employed_count = len(
+                [h for h in sim.households if h.is_active and h.is_employed]
+            )
+            logger.info(
+                f"Tick {tick}/{target_ticks}: Active {active_count}, Employed {employed_count}"
+            )
 
     # 3. Collect Data from Agents (Cumulative)
     logger.info("Collecting agent data...")
@@ -121,18 +126,32 @@ def run_experiment():
     active_households = [h for h in sim.households if h.is_active]
     final_active_count = len(active_households)
     final_employed_count = len([h for h in active_households if h.is_employed])
-    employment_rate = final_employed_count / final_active_count if final_active_count > 0 else 0.0
+    employment_rate = (
+        final_employed_count / final_active_count if final_active_count > 0 else 0.0
+    )
 
     if df.empty:
-        logger.error("No employed agents found. Simulation failed to generate valid data.")
+        logger.error(
+            "No employed agents found. Simulation failed to generate valid data."
+        )
         # Generate Failure Report
-        _generate_report(None, None, None, None, 0.0, employment_rate, target_ticks, 0, "FAIL - NO DATA")
+        _generate_report(
+            None,
+            None,
+            None,
+            None,
+            0.0,
+            employment_rate,
+            target_ticks,
+            0,
+            "FAIL - NO DATA",
+        )
         return
 
     # 4. Analysis: Mincer Equation
     # log(Wage) = a + b*Edu + c*Skill
 
-    df["log_wage"] = np.log(df["wage"].replace(0, 0.001)) # Avoid log(0)
+    df["log_wage"] = np.log(df["wage"].replace(0, 0.001))  # Avoid log(0)
 
     # Simple Regression using numpy (Least Squares)
     # Model 1: log(Wage) ~ Edu + Skill (Signaling)
@@ -145,7 +164,17 @@ def run_experiment():
         intercept1, coeff_edu_signaling, coeff_skill = beta1
     except Exception as e:
         logger.error(f"Regression failed: {e}")
-        _generate_report(None, None, None, None, 0.0, employment_rate, target_ticks, len(df), f"FAIL - REGRESSION ERROR: {e}")
+        _generate_report(
+            None,
+            None,
+            None,
+            None,
+            0.0,
+            employment_rate,
+            target_ticks,
+            len(df),
+            f"FAIL - REGRESSION ERROR: {e}",
+        )
         return
 
     # Model 2: log(Wage) ~ Edu (Total Return)
@@ -181,11 +210,32 @@ def run_experiment():
     final_status = "[PASS]" if pass_criteria else f"[FAIL] {status_msg}"
 
     # 7. Generate Report
-    _generate_report(coeff_edu_signaling, coeff_skill, intercept1, coeff_edu_total, corr_wealth_edu, employment_rate, target_ticks, len(df), final_status, corr_wealth_wage)
-
-
-def _generate_report(coeff_edu_signaling, coeff_skill, intercept1, coeff_edu_total, corr_wealth_edu, employment_rate, target_ticks, data_points, status, corr_wealth_wage=0.0):
-
+    _generate_report(
+        coeff_edu_signaling,
+        coeff_skill,
+        intercept1,
+        coeff_edu_total,
+        corr_wealth_edu,
+        employment_rate,
+        target_ticks,
+        len(df),
+        final_status,
+        corr_wealth_wage,
+    )
+
+
+def _generate_report(
+    coeff_edu_signaling,
+    coeff_skill,
+    intercept1,
+    coeff_edu_total,
+    corr_wealth_edu,
+    employment_rate,
+    target_ticks,
+    data_points,
+    status,
+    corr_wealth_wage=0.0,
+):
     if coeff_edu_signaling is None:
         # Failure Fallback
         report_content = f"""# ğŸ“ Education ROI & Social Ladder Report (Dynasty Report v2)
@@ -201,7 +251,11 @@ Analysis failed to complete successfully.
 """
     else:
         # Success (or partial success with Fail status)
-        signaling_share = (coeff_edu_signaling / coeff_edu_total * 100) if abs(coeff_edu_total) > 0.001 else 0.0
+        signaling_share = (
+            (coeff_edu_signaling / coeff_edu_total * 100)
+            if abs(coeff_edu_total) > 0.001
+            else 0.0
+        )
 
         report_content = f"""# ğŸ“ Education ROI & Social Ladder Report (Dynasty Report v2)
 
@@ -257,5 +311,6 @@ Simulation confirms the **"Pareto-Iron Law"**:
     logger.info(f"Report generated at {report_path}")
     print(report_content)
 
+
 if __name__ == "__main__":
     run_experiment()
diff --git a/scripts/experiments/golden_age_test.py b/scripts/experiments/golden_age_test.py
index 0ac0fff..692c533 100644
--- a/scripts/experiments/golden_age_test.py
+++ b/scripts/experiments/golden_age_test.py
@@ -1,4 +1,3 @@
-
 import logging
 import sys
 from pathlib import Path
@@ -14,9 +13,12 @@ from typing import List, Dict, Any
 import config
 
 # Configure logger
-logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
+logging.basicConfig(
+    level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
+)
 logger = logging.getLogger("golden_age_test")
 
+
 def run_golden_age_test():
     """
     WO-055: The Golden Age (Grand Integration Test)
@@ -30,38 +32,36 @@ def run_golden_age_test():
         "HALO_EFFECT": 0.20,
         "NUM_HOUSEHOLDS": 100,
         "NUM_FIRMS": 20,
-        
         # WO-053: Fertilizer
         "TECH_FERTILIZER_UNLOCK_TICK": 10,
-        "TECH_DIFFUSION_RATE": 0.05, # Base rate
-        
+        "TECH_DIFFUSION_RATE": 0.05,  # Base rate
         # WO-054: Education
-        "PUBLIC_EDU_BUDGET_RATIO": 0.25, # High priority
+        "PUBLIC_EDU_BUDGET_RATIO": 0.25,  # High priority
         "SCHOLARSHIP_WEALTH_PERCENTILE": 0.20,
         "SCHOLARSHIP_POTENTIAL_THRESHOLD": 0.7,
-        
         # WO-055: Golden Age Stabilization
         "STARTUP_COST": 30000.0,
         "ENTREPRENEURSHIP_SPIRIT": 0.01,
         "INITIAL_HOUSEHOLD_FOOD_INVENTORY": 20.0,
-        
         # Stability
         "GOVERNMENT_STIMULUS_ENABLED": True,
-        "DEFAULT_ENGINE_TYPE": "AIDriven", # Phase 23: Education/Growth requires AI complexity
-        
+        "DEFAULT_ENGINE_TYPE": "AIDriven",  # Phase 23: Education/Growth requires AI complexity
         # Performance
         "BATCH_SAVE_INTERVAL": 100,
     }
 
     from main import create_simulation
+
     sim = create_simulation(overrides)
 
     # 2. Metric Collection Preparation
     history = []
-    
+
     start_time = time.time()
-    
-    logger.info(f"Running simulation for 1,000 ticks. Target: GDP Explosion & Population Boom.")
+
+    logger.info(
+        f"Running simulation for 1,000 ticks. Target: GDP Explosion & Population Boom."
+    )
 
     for tick in range(1, 1001):
         try:
@@ -69,6 +69,7 @@ def run_golden_age_test():
         except Exception as e:
             logger.error(f"âŒ Simulation CRASHED at tick {tick}: {e}")
             import traceback
+
             traceback.print_exc()
             break
 
@@ -76,17 +77,25 @@ def run_golden_age_test():
         if tick % 10 == 0 or tick == 1:
             active_households = [h for h in sim.households if h.is_active]
             pop_size = len(active_households)
-            
+
             # GDP = Total Production * Avg Quality (Simplified for Integration Test)
-            indicators = sim.tracker.get_latest_indicators() if hasattr(sim, 'tracker') else {}
+            indicators = (
+                sim.tracker.get_latest_indicators() if hasattr(sim, "tracker") else {}
+            )
             total_production = indicators.get("total_production", 0.0)
-            
+
             avg_edu = sim.technology_manager.human_capital_index
-            
+
             # Brain Waste: Aptitude >= 0.8 but Education < 3
-            talent_pool = [h for h in active_households if getattr(h, "aptitude", 0.0) >= 0.8]
-            brain_waste_count = len([h for h in talent_pool if getattr(h, "education_level", 0) < 3])
-            brain_waste_rate = (brain_waste_count / len(talent_pool)) if talent_pool else 0.0
+            talent_pool = [
+                h for h in active_households if getattr(h, "aptitude", 0.0) >= 0.8
+            ]
+            brain_waste_count = len(
+                [h for h in talent_pool if getattr(h, "education_level", 0) < 3]
+            )
+            brain_waste_rate = (
+                (brain_waste_count / len(talent_pool)) if talent_pool else 0.0
+            )
 
             # Price Level (CPI proxy)
             price_index = indicators.get("cpi", 1.0)
@@ -98,43 +107,57 @@ def run_golden_age_test():
                 "avg_edu": avg_edu,
                 "brain_waste_rate": brain_waste_rate,
                 "price_index": price_index,
-                "treasury": sim.government.assets
+                "treasury": sim.government.assets,
             }
             history.append(metrics)
 
         if tick % 100 == 0:
             elapsed = time.time() - start_time
-            logger.info(f"Progress: {tick}/1000 | Pop: {len([h for h in sim.households if h.is_active])} | GDP: {total_production:.1f} | Elapsed: {elapsed:.1f}s")
+            logger.info(
+                f"Progress: {tick}/1000 | Pop: {len([h for h in sim.households if h.is_active])} | GDP: {total_production:.1f} | Elapsed: {elapsed:.1f}s"
+            )
 
     # 3. Final Analysis
     df = pd.DataFrame(history)
-    
+
     initial_pop = df["population"].iloc[0]
     final_pop = df["population"].iloc[-1]
-    pop_growth = (final_pop / initial_pop)
-    
-    initial_gdp = df[df["tick"] > 0]["gdp"].head(5).mean() # Average first few to avoid noise
+    pop_growth = final_pop / initial_pop
+
+    initial_gdp = (
+        df[df["tick"] > 0]["gdp"].head(5).mean()
+    )  # Average first few to avoid noise
     final_gdp = df["gdp"].iloc[-1]
     gdp_growth = (final_gdp / initial_gdp) if initial_gdp > 0 else 0.0
-    
+
     final_brain_waste = df["brain_waste_rate"].iloc[-1]
-    
+
     # IGE (Intergenerational Elasticity) proxy at end
     last_snapshot = sim.households
-    df_ige = pd.DataFrame([{
-        "initial_assets": getattr(h, "initial_assets_record", 0.0),
-        "education_level": getattr(h, "education_level", 0)
-    } for h in last_snapshot if h.is_active])
-    
+    df_ige = pd.DataFrame(
+        [
+            {
+                "initial_assets": getattr(h, "initial_assets_record", 0.0),
+                "education_level": getattr(h, "education_level", 0),
+            }
+            for h in last_snapshot
+            if h.is_active
+        ]
+    )
+
     ige_corr = df_ige["initial_assets"].corr(df_ige["education_level"])
-    
+
     # 4. Generate Final Report
     _generate_final_report(pop_growth, gdp_growth, final_brain_waste, ige_corr, df)
 
+
 def _generate_final_report(pop_growth, gdp_growth, brain_waste, ige, df):
-    
-    status = "SUCCESS" if (pop_growth >= 2.0 and gdp_growth >= 5.0 and brain_waste < 0.1) else "PARTIAL SUCCESS"
-    
+    status = (
+        "SUCCESS"
+        if (pop_growth >= 2.0 and gdp_growth >= 5.0 and brain_waste < 0.1)
+        else "PARTIAL SUCCESS"
+    )
+
     report = f"""# ğŸŒŸ WO-055: The Golden Age - Final Integration Report
 
 ## 1. Executive Summary
@@ -173,14 +196,15 @@ def _generate_final_report(pop_growth, gdp_growth, brain_waste, ige, df):
 ---
 *Report generated by Antigravity (Team Lead) on behalf of Architect Prime.*
 """
-    
+
     report_path = "reports/GOLDEN_AGE_FINAL_REPORT.md"
     os.makedirs("reports", exist_ok=True)
     with open(report_path, "w", encoding="utf-8") as f:
         f.write(report)
-    
+
     print(report)
     logger.info(f"âœ… Grand Integration Report generated at {report_path}")
 
+
 if __name__ == "__main__":
     run_golden_age_test()
diff --git a/scripts/experiments/malthusian_trap_baseline.py b/scripts/experiments/malthusian_trap_baseline.py
index baa2542..3171020 100644
--- a/scripts/experiments/malthusian_trap_baseline.py
+++ b/scripts/experiments/malthusian_trap_baseline.py
@@ -13,6 +13,7 @@ from utils.logging_manager import setup_logging
 import config
 from config import EngineType
 
+
 def run_malthusian_experiment():
     # 1. Setup Logging
     setup_logging()
@@ -26,9 +27,9 @@ def run_malthusian_experiment():
         "BIOLOGICAL_FERTILITY_RATE": 0.2,
         "UNEMPLOYMENT_BENEFIT_RATIO": 0.0,
         "GOVERNMENT_STIMULUS_ENABLED": False,
-        "NUM_HOUSEHOLDS": 20, # Start small to allow growth
+        "NUM_HOUSEHOLDS": 20,  # Start small to allow growth
         "SIMULATION_TICKS": 1000,
-        "DEFAULT_ENGINE_TYPE": EngineType.AI_DRIVEN
+        "DEFAULT_ENGINE_TYPE": EngineType.AI_DRIVEN,
     }
 
     print("Initializing Malthusian Trap Experiment...")
@@ -46,7 +47,7 @@ def run_malthusian_experiment():
             # Force System 1 Reproduction (Instinctual)
             for agent in sim.households:
                 if hasattr(agent, "decision_engine"):
-                     agent.decision_engine.reproduction_mode = 'SYSTEM1'
+                    agent.decision_engine.reproduction_mode = "SYSTEM1"
 
             sim.run_tick()
 
@@ -55,7 +56,11 @@ def run_malthusian_experiment():
 
             # Calculate Mean Wage
             employed_agents = [h for h in sim.households if h.is_employed]
-            mean_wage = sum(h.current_wage for h in employed_agents) / len(employed_agents) if employed_agents else 0.0
+            mean_wage = (
+                sum(h.current_wage for h in employed_agents) / len(employed_agents)
+                if employed_agents
+                else 0.0
+            )
 
             # Calculate Survival Cost (Average cost of 1 unit of food * monthly need, approx)
             # Or use the agent's tracked survival cost if available.
@@ -64,9 +69,9 @@ def run_malthusian_experiment():
             food_market = sim.markets.get("basic_food")
             food_price = 5.0
             if food_market and hasattr(food_market, "get_daily_avg_price"):
-                 avg = food_market.get_daily_avg_price()
-                 if avg > 0:
-                     food_price = avg
+                avg = food_market.get_daily_avg_price()
+                if avg > 0:
+                    food_price = avg
 
             survival_cost = food_price * config.HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK
 
@@ -82,17 +87,21 @@ def run_malthusian_experiment():
             attrition = sim.repository.get_attrition_counts(tick, tick, sim.run_id)
             starvation_deaths = attrition.get("death_count", 0)
 
-            history.append({
-                "tick": tick,
-                "population": pop_count,
-                "mean_wage": mean_wage,
-                "survival_cost": survival_cost,
-                "starvation_deaths": starvation_deaths,
-                "food_price": food_price
-            })
+            history.append(
+                {
+                    "tick": tick,
+                    "population": pop_count,
+                    "mean_wage": mean_wage,
+                    "survival_cost": survival_cost,
+                    "starvation_deaths": starvation_deaths,
+                    "food_price": food_price,
+                }
+            )
 
             if tick % 50 == 0:
-                print(f"Tick {tick}: Pop={pop_count}, Wage={mean_wage:.2f}, Cost={survival_cost:.2f}, Deaths={starvation_deaths}")
+                print(
+                    f"Tick {tick}: Pop={pop_count}, Wage={mean_wage:.2f}, Cost={survival_cost:.2f}, Deaths={starvation_deaths}"
+                )
 
     except Exception as e:
         logger.error(f"Simulation crashed at tick {sim.time}: {e}", exc_info=True)
@@ -127,11 +136,18 @@ def run_malthusian_experiment():
         print(f"Population Peak: {iron_ceiling_pop}")
         print(f"Wage at Peak: {iron_ceiling_wage:.2f}")
     else:
-        print("\n[NO IRON CEILING DETECTED] Wages remained above survival cost or population kept growing.")
+        print(
+            "\n[NO IRON CEILING DETECTED] Wages remained above survival cost or population kept growing."
+        )
 
     # Calculate Metric: Population Doubling vs Real Wage Drop
     # Real Wage = Mean Wage / Survival Cost
-    df["real_wage"] = df.apply(lambda row: row["mean_wage"] / row["survival_cost"] if row["survival_cost"] > 0 else 0, axis=1)
+    df["real_wage"] = df.apply(
+        lambda row: row["mean_wage"] / row["survival_cost"]
+        if row["survival_cost"] > 0
+        else 0,
+        axis=1,
+    )
 
     # Find start and end points for doubling (e.g., Start Pop -> 2 * Start Pop)
     start_pop = df.iloc[0]["population"]
@@ -175,7 +191,9 @@ def run_malthusian_experiment():
     # Add sample rows (every 100 ticks)
     for i in range(0, len(df), 100):
         row = df.iloc[i]
-        report_content.append(f"| {row['tick']} | {row['population']} | {row['mean_wage']:.2f} | {row['survival_cost']:.2f} | {row['starvation_deaths']} | {row['real_wage']:.2f} |")
+        report_content.append(
+            f"| {row['tick']} | {row['population']} | {row['mean_wage']:.2f} | {row['survival_cost']:.2f} | {row['starvation_deaths']} | {row['real_wage']:.2f} |"
+        )
 
     os.makedirs("reports", exist_ok=True)
     with open("reports/malthusian_trap_report.md", "w") as f:
@@ -183,5 +201,6 @@ def run_malthusian_experiment():
 
     print("Report generated: reports/malthusian_trap_report.md")
 
+
 if __name__ == "__main__":
     run_malthusian_experiment()
diff --git a/scripts/experiments/verify_wo054.py b/scripts/experiments/verify_wo054.py
index f147af5..702762b 100644
--- a/scripts/experiments/verify_wo054.py
+++ b/scripts/experiments/verify_wo054.py
@@ -1,4 +1,3 @@
-
 import logging
 import sys
 from pathlib import Path
@@ -18,6 +17,7 @@ import logging.config
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger("verify_wo054")
 
+
 def run_experiment():
     """
     Runs the WO-054 Verification Experiment.
@@ -29,27 +29,24 @@ def run_experiment():
     # Override config to enable WO-054 mechanics
     overrides = {
         "HALO_EFFECT": 0.15,
-        "SIMULATION_TICKS": 500, # 500 ticks as requested
-
+        "SIMULATION_TICKS": 500,  # 500 ticks as requested
         # WO-054 Configs
         "PUBLIC_EDU_BUDGET_RATIO": 0.20,
         "SCHOLARSHIP_WEALTH_PERCENTILE": 0.20,
         "SCHOLARSHIP_POTENTIAL_THRESHOLD": 0.7,
-
         # Enable Tech Feedback
         "TECH_DIFFUSION_RATE": 0.05,
-        "TECH_FERTILIZER_UNLOCK_TICK": 50, # Early unlock to see diffusion
-
+        "TECH_FERTILIZER_UNLOCK_TICK": 50,  # Early unlock to see diffusion
         # Reset parameters to somewhat normal but stressed enough to show gap
         "INITIAL_HOUSEHOLD_ASSETS_MEAN": 5000.0,
         "INITIAL_FIRM_CAPITAL_MEAN": 50000.0,
         "GOVERNMENT_STIMULUS_ENABLED": True,
-
         # RuleBased for consistency in short run
         "DEFAULT_ENGINE_TYPE": "RuleBased",
     }
 
     from main import create_simulation
+
     sim = create_simulation(overrides)
 
     # 2. Run Simulation
@@ -65,6 +62,7 @@ def run_experiment():
         except Exception as e:
             logger.error(f"Simulation crashed at tick {tick}: {e}")
             import traceback
+
             traceback.print_exc()
             break
 
@@ -76,7 +74,7 @@ def run_experiment():
                         "agent_id": agent.id,
                         "education_level": getattr(agent, "education_level", 0),
                         "initial_assets": getattr(agent, "initial_assets_record", 0.0),
-                        "tick": tick
+                        "tick": tick,
                     }
                     history_data.append(data)
 
@@ -105,7 +103,9 @@ def run_experiment():
     # WO-054 Target: Drop from 0.96 to < 0.7
     corr_wealth_edu = final_df["initial_assets"].corr(final_df["education_level"])
 
-    logger.info(f"Final Correlation (Initial Assets vs Education): {corr_wealth_edu:.4f}")
+    logger.info(
+        f"Final Correlation (Initial Assets vs Education): {corr_wealth_edu:.4f}"
+    )
 
     # 6. Verification
     pass_criteria = True
@@ -113,13 +113,17 @@ def run_experiment():
 
     if corr_wealth_edu >= 0.7:
         pass_criteria = False
-        status_msg += f"FAIL: IGE (Wealth-Edu Corr) {corr_wealth_edu:.4f} >= 0.7. (Target < 0.7)"
+        status_msg += (
+            f"FAIL: IGE (Wealth-Edu Corr) {corr_wealth_edu:.4f} >= 0.7. (Target < 0.7)"
+        )
     else:
         status_msg += f"PASS: IGE (Wealth-Edu Corr) {corr_wealth_edu:.4f} < 0.7."
 
     # Tech Diffusion Check
     # We can check adoption count
-    adopted_count = sum(len(v) for v in sim.technology_manager.adoption_registry.values())
+    adopted_count = sum(
+        len(v) for v in sim.technology_manager.adoption_registry.values()
+    )
     logger.info(f"Total Tech Adoptions: {adopted_count}")
 
     avg_edu_final = sim.technology_manager.human_capital_index
@@ -135,5 +139,6 @@ def run_experiment():
     print(f"Tech Adoptions: {adopted_count}")
     print(f"Message: {status_msg}")
 
+
 if __name__ == "__main__":
     run_experiment()
diff --git a/scripts/export_wo23_data.py b/scripts/export_wo23_data.py
index 0396137..a0486da 100644
--- a/scripts/export_wo23_data.py
+++ b/scripts/export_wo23_data.py
@@ -1,4 +1,3 @@
-
 import sqlite3
 import pandas as pd
 import os
@@ -13,9 +12,9 @@ if not os.path.exists(db_path):
 conn = sqlite3.connect(db_path)
 
 # Logic to extract Production/Consumption per Sector
-# Transactions Table: 
+# Transactions Table:
 # prod_food (Actually production is not in transactions, it's firm internal state)
-# However, we can approximate 'prod' by 'sales' transaction volume? 
+# However, we can approximate 'prod' by 'sales' transaction volume?
 # Or check market_history (supply)?
 # Let's use `market_history` table if populated.
 
@@ -73,12 +72,12 @@ ORDER BY time
 df_gdp = pd.read_sql_query(query_gdp, conn)
 
 # Merge
-df_merged = pd.merge(df_market, df_gdp, on='tick', how='outer').fillna(0)
+df_merged = pd.merge(df_market, df_gdp, on="tick", how="outer").fillna(0)
 
 # Rename columns to match verify_innovation.py expectation
 # 'cons_food', 'cons_goods' -> we can just duplicate prod columns if we assume equilibrium or use same proxy
-df_merged['cons_food'] = df_merged['prod_food']
-df_merged['cons_goods'] = df_merged['prod_goods']
+df_merged["cons_food"] = df_merged["prod_food"]
+df_merged["cons_goods"] = df_merged["prod_goods"]
 
 # Save
 output_file = "wo23_test_results.csv"
diff --git a/scripts/extract_failure_meta.py b/scripts/extract_failure_meta.py
index ff7610d..d4a1857 100644
--- a/scripts/extract_failure_meta.py
+++ b/scripts/extract_failure_meta.py
@@ -1,31 +1,40 @@
 import sqlite3
 import pandas as pd
 
+
 def extract_meta():
-    conn = sqlite3.connect('simulation_data.db')
-    df = pd.read_sql_query('SELECT time, total_inventory, total_production, total_consumption, total_household_assets, total_firm_assets FROM economic_indicators WHERE run_id = (SELECT MAX(run_id) FROM simulation_runs)', conn)
-    
+    conn = sqlite3.connect("simulation_data.db")
+    df = pd.read_sql_query(
+        "SELECT time, total_inventory, total_production, total_consumption, total_household_assets, total_firm_assets FROM economic_indicators WHERE run_id = (SELECT MAX(run_id) FROM simulation_runs)",
+        conn,
+    )
+
     peak_inv = df["total_inventory"].max()
     peak_tick = df.loc[df["total_inventory"].idxmax(), "time"]
-    zero_inv_tick = df[df["total_inventory"] <= 0.1]["time"].min() if not df[df["total_inventory"] <= 0.1].empty else "Never"
-    
+    zero_inv_tick = (
+        df[df["total_inventory"] <= 0.1]["time"].min()
+        if not df[df["total_inventory"] <= 0.1].empty
+        else "Never"
+    )
+
     total_prod = df["total_production"].sum()
     total_cons = df["total_consumption"].sum()
-    
+
     print(f"Inventory Analysis:")
     print(f"- Peak Inventory: {peak_inv:.2f} units at Tick {peak_tick}")
     print(f"- Inventory Exhaustion: Tick {zero_inv_tick}")
     print(f"- Total Production: {total_prod:.2f} units")
     print(f"- Total Consumption: {total_cons:.2f} units")
     print(f"- Gap: {total_prod - total_cons:.2f} units")
-    
+
     final_hh = df.iloc[-1]["total_household_assets"]
     final_firm = df.iloc[-1]["total_firm_assets"]
     print(f"\nLiquidity Analysis (Tick 1000):")
     print(f"- Household Cash: {final_hh:.2f}")
     print(f"- Firm Cash: {final_firm:.2f}")
-    
+
     conn.close()
 
+
 if __name__ == "__main__":
     extract_meta()
diff --git a/scripts/failure_diagnosis.py b/scripts/failure_diagnosis.py
index 4415d0f..259432e 100644
--- a/scripts/failure_diagnosis.py
+++ b/scripts/failure_diagnosis.py
@@ -2,6 +2,7 @@
 Diagnostic Script for Economic Failure Analysis.
 Focuses on Production vs Consumption gap and Inventory depletion.
 """
+
 import sys
 from pathlib import Path
 import os
@@ -15,27 +16,48 @@ sys.path.append(str(Path(__file__).resolve().parent.parent))
 from modules.analytics.loader import DataLoader
 
 # Setup logging
-logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
+logging.basicConfig(
+    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
+)
 logger = logging.getLogger(__name__)
 
+
 def run_diagnosis(db_path="simulation_data.db", output_dir="reports/figures"):
     logger.info("Starting failure diagnosis...")
     loader = DataLoader(db_path)
     os.makedirs(output_dir, exist_ok=True)
 
     eco_df = loader.load_economic_indicators(run_id="latest")
-    
+
     if eco_df.empty:
         logger.error("No data found.")
         return
 
     # 1. Production vs Consumption Gap
     plt.figure(figsize=(12, 6))
-    plt.plot(eco_df.index, eco_df["total_production"], label="Production", color="blue", alpha=0.7)
-    plt.plot(eco_df.index, eco_df["total_consumption"], label="Consumption", color="orange", alpha=0.7)
-    plt.fill_between(eco_df.index, eco_df["total_production"], eco_df["total_consumption"], 
-                     where=(eco_df["total_production"] < eco_df["total_consumption"]),
-                     color='red', alpha=0.3, label="Deficit (Inventory Drain)")
+    plt.plot(
+        eco_df.index,
+        eco_df["total_production"],
+        label="Production",
+        color="blue",
+        alpha=0.7,
+    )
+    plt.plot(
+        eco_df.index,
+        eco_df["total_consumption"],
+        label="Consumption",
+        color="orange",
+        alpha=0.7,
+    )
+    plt.fill_between(
+        eco_df.index,
+        eco_df["total_production"],
+        eco_df["total_consumption"],
+        where=(eco_df["total_production"] < eco_df["total_consumption"]),
+        color="red",
+        alpha=0.3,
+        label="Deficit (Inventory Drain)",
+    )
     plt.title("Production vs Consumption Gap")
     plt.xlabel("Tick")
     plt.ylabel("Units")
@@ -46,8 +68,10 @@ def run_diagnosis(db_path="simulation_data.db", output_dir="reports/figures"):
 
     # 2. Inventory Levels
     plt.figure(figsize=(12, 6))
-    plt.plot(eco_df.index, eco_df["total_inventory"], label="Total Inventory", color="brown")
-    plt.axhline(y=0, color='black', linestyle='--')
+    plt.plot(
+        eco_df.index, eco_df["total_inventory"], label="Total Inventory", color="brown"
+    )
+    plt.axhline(y=0, color="black", linestyle="--")
     plt.title("Total System Inventory (Market Feed)")
     plt.xlabel("Tick")
     plt.ylabel("Units")
@@ -58,17 +82,23 @@ def run_diagnosis(db_path="simulation_data.db", output_dir="reports/figures"):
 
     # 3. Cash Flow Imbalance
     plt.figure(figsize=(12, 6))
-    plt.stackplot(eco_df.index, eco_df["total_household_assets"], eco_df["total_firm_assets"], 
-                  labels=["Household Assets", "Firm Assets"], colors=["lightblue", "salmon"])
+    plt.stackplot(
+        eco_df.index,
+        eco_df["total_household_assets"],
+        eco_df["total_firm_assets"],
+        labels=["Household Assets", "Firm Assets"],
+        colors=["lightblue", "salmon"],
+    )
     plt.title("Asset Distribution: Money Magnet Effect")
     plt.xlabel("Tick")
     plt.ylabel("Currency")
-    plt.legend(loc='upper right')
+    plt.legend(loc="upper right")
     plt.grid(True)
     plt.savefig(os.path.join(output_dir, "failure_assets.png"))
     plt.close()
 
     logger.info(f"Diagnosis complete. Figures saved in {output_dir}")
 
+
 if __name__ == "__main__":
     run_diagnosis()
diff --git a/scripts/fixture_harvester.py b/scripts/fixture_harvester.py
index 4509c27..85e9d8e 100644
--- a/scripts/fixture_harvester.py
+++ b/scripts/fixture_harvester.py
@@ -3,7 +3,7 @@ Fixture Harvester: Auto-Mock Generation via Golden Sample Recording
 
 This module provides utilities to:
 1. Capture real agent states during simulation runs
-2. Serialize them to JSON "Golden Fixtures"  
+2. Serialize them to JSON "Golden Fixtures"
 3. Load them in tests to create type-safe mock objects
 
 Usage:
@@ -48,6 +48,7 @@ except ImportError:
 @dataclass
 class HouseholdSnapshot:
     """Serializable representation of a Household agent."""
+
     id: int
     assets: float
     is_active: bool
@@ -61,9 +62,10 @@ class HouseholdSnapshot:
     approval_rating: float
 
 
-@dataclass 
+@dataclass
 class FirmSnapshot:
     """Serializable representation of a Firm agent."""
+
     id: int
     assets: float
     is_active: bool
@@ -80,6 +82,7 @@ class FirmSnapshot:
 @dataclass
 class GoldenFixture:
     """Complete fixture containing agent snapshots."""
+
     metadata: Dict[str, Any]
     households: List[HouseholdSnapshot]
     firms: List[FirmSnapshot]
@@ -89,110 +92,117 @@ class GoldenFixture:
 class FixtureHarvester:
     """
     Captures real agent states during simulation runs for test fixtures.
-    
+
     Example:
         harvester = FixtureHarvester(output_dir="tests/goldens")
         harvester.capture_agents(sim.households, sim.firms, tick=100)
         harvester.capture_config(sim.config_module)
         harvester.save_all()
     """
-    
+
     def __init__(self, output_dir: str = "tests/goldens"):
         self.output_dir = Path(output_dir)
         self.output_dir.mkdir(parents=True, exist_ok=True)
-        
+
         self.households: List[HouseholdSnapshot] = []
         self.firms: List[FirmSnapshot] = []
         self.config_snapshot: Dict[str, Any] = {}
         self.metadata: Dict[str, Any] = {
             "captured_at": datetime.now().isoformat(),
-            "tick": 0
+            "tick": 0,
         }
-    
+
     def capture_household(self, household) -> HouseholdSnapshot:
         """Capture a single household's state."""
         return HouseholdSnapshot(
             id=household.id,
-            assets=getattr(household, 'assets', 0.0),
-            is_active=getattr(household, 'is_active', True),
-            is_employed=getattr(household, 'is_employed', False),
-            employer_id=getattr(household, 'employer_id', None),
-            age=getattr(household, 'age', 0),
-            education_level=getattr(household, 'education_level', 1.0),
-            current_wage=getattr(household, 'current_wage', 0.0),
-            needs=dict(getattr(household, 'needs', {})),
-            inventory=dict(getattr(household, 'inventory', {})),
-            approval_rating=getattr(household, 'approval_rating', 1.0)
+            assets=getattr(household, "assets", 0.0),
+            is_active=getattr(household, "is_active", True),
+            is_employed=getattr(household, "is_employed", False),
+            employer_id=getattr(household, "employer_id", None),
+            age=getattr(household, "age", 0),
+            education_level=getattr(household, "education_level", 1.0),
+            current_wage=getattr(household, "current_wage", 0.0),
+            needs=dict(getattr(household, "needs", {})),
+            inventory=dict(getattr(household, "inventory", {})),
+            approval_rating=getattr(household, "approval_rating", 1.0),
         )
-    
+
     def capture_firm(self, firm) -> FirmSnapshot:
         """Capture a single firm's state."""
-        employees = getattr(firm, 'employees', [])
-        employees_count = len(employees) if hasattr(employees, '__len__') else 0
-        
+        employees = getattr(firm, "employees", [])
+        employees_count = len(employees) if hasattr(employees, "__len__") else 0
+
         return FirmSnapshot(
             id=firm.id,
-            assets=getattr(firm, 'assets', 0.0),
-            is_active=getattr(firm, 'is_active', True),
-            specialization=getattr(firm, 'specialization', 'food'),
-            productivity_factor=getattr(firm, 'productivity_factor', 1.0),
+            assets=getattr(firm, "assets", 0.0),
+            is_active=getattr(firm, "is_active", True),
+            specialization=getattr(firm, "specialization", "food"),
+            productivity_factor=getattr(firm, "productivity_factor", 1.0),
             employees_count=employees_count,
-            inventory=dict(getattr(firm, 'inventory', {})),
-            retained_earnings=getattr(firm, 'retained_earnings', 0.0),
-            total_debt=getattr(firm, 'total_debt', 0.0),
-            current_profit=getattr(firm, 'current_profit', 0.0),
-            consecutive_loss_turns=getattr(firm, 'consecutive_loss_turns', 0)
+            inventory=dict(getattr(firm, "inventory", {})),
+            retained_earnings=getattr(firm, "retained_earnings", 0.0),
+            total_debt=getattr(firm, "total_debt", 0.0),
+            current_profit=getattr(firm, "current_profit", 0.0),
+            consecutive_loss_turns=getattr(firm, "consecutive_loss_turns", 0),
         )
-    
+
     def capture_agents(self, households: List, firms: List, tick: int = 0):
         """Capture all agents' states at a given tick."""
         self.metadata["tick"] = tick
         self.metadata["household_count"] = len(households)
         self.metadata["firm_count"] = len(firms)
-        
+
         self.households = [self.capture_household(h) for h in households]
         self.firms = [self.capture_firm(f) for f in firms]
-        
-        print(f"ğŸ“¸ Captured {len(self.households)} households and {len(self.firms)} firms at tick {tick}")
-    
+
+        print(
+            f"ğŸ“¸ Captured {len(self.households)} households and {len(self.firms)} firms at tick {tick}"
+        )
+
     def capture_config(self, config_module):
         """Capture relevant config values."""
         # Extract scalar values from config module
         for attr in dir(config_module):
             if attr.isupper():  # Only capture uppercase constants
                 # Filter out sensitive keys
-                if "TOKEN" in attr or "SECRET" in attr or "KEY" in attr or "PASSWORD" in attr:
+                if (
+                    "TOKEN" in attr
+                    or "SECRET" in attr
+                    or "KEY" in attr
+                    or "PASSWORD" in attr
+                ):
                     continue
 
                 value = getattr(config_module, attr)
                 if isinstance(value, (int, float, str, bool, list, dict)):
                     self.config_snapshot[attr] = value
-    
+
     def save_all(self, filename: Optional[str] = None) -> Path:
         """Save all captured data to a JSON file."""
         if filename is None:
             filename = f"agents_tick_{self.metadata.get('tick', 0)}.json"
-        
+
         filepath = self.output_dir / filename
-        
+
         fixture = GoldenFixture(
             metadata=self.metadata,
             households=self.households,
             firms=self.firms,
-            config_snapshot=self.config_snapshot
+            config_snapshot=self.config_snapshot,
         )
-        
+
         # Convert dataclasses to dicts for JSON serialization
         data = {
             "metadata": fixture.metadata,
             "households": [asdict(h) for h in fixture.households],
             "firms": [asdict(f) for f in fixture.firms],
-            "config_snapshot": fixture.config_snapshot
+            "config_snapshot": fixture.config_snapshot,
         }
-        
-        with open(filepath, 'w', encoding='utf-8') as f:
+
+        with open(filepath, "w", encoding="utf-8") as f:
             json.dump(data, f, indent=2, ensure_ascii=False)
-        
+
         print(f"ğŸ’¾ Saved golden fixture to: {filepath}")
         return filepath
 
@@ -200,29 +210,29 @@ class FixtureHarvester:
 class GoldenLoader:
     """
     Loads golden fixtures and creates type-safe mock objects.
-    
+
     Example:
         fixtures = GoldenLoader.load("tests/goldens/agents_tick_100.json")
         households = fixtures.create_household_mocks()
         firms = fixtures.create_firm_mocks()
     """
-    
+
     def __init__(self, data: Dict[str, Any]):
         self.metadata = data.get("metadata", {})
         self.households_data = data.get("households", [])
         self.firms_data = data.get("firms", [])
         self.config_snapshot = data.get("config_snapshot", {})
-    
+
     @classmethod
     def load(cls, filepath: str) -> "GoldenLoader":
         """Load a golden fixture from file."""
         if GenericGoldenLoader:
             data = GenericGoldenLoader.load_json(filepath)
         else:
-             with open(filepath, 'r', encoding='utf-8') as f:
+            with open(filepath, "r", encoding="utf-8") as f:
                 data = json.load(f)
         return cls(data)
-    
+
     def create_household_mocks(self, mock_class=None):
         """
         Create mock households from golden data.
@@ -231,6 +241,7 @@ class GoldenLoader:
         for h_data in self.households_data:
             # Fallback to old logic or Generic
             from types import SimpleNamespace
+
             if mock_class:
                 mock = MagicMock(spec=mock_class)
             else:
@@ -239,9 +250,9 @@ class GoldenLoader:
                 setattr(mock, key, value)
 
             mock.make_decision = MagicMock(return_value=([], MagicMock()))
-            if not hasattr(mock, 'decision_engine'):
+            if not hasattr(mock, "decision_engine"):
                 mock.decision_engine = MagicMock()
-            if not hasattr(mock.decision_engine, 'ai_engine'):
+            if not hasattr(mock.decision_engine, "ai_engine"):
                 mock.decision_engine.ai_engine = MagicMock()
             mocks.append(mock)
         return mocks
@@ -269,42 +280,45 @@ class GoldenLoader:
                 owned_properties=[],
                 portfolio_holdings={},
                 risk_aversion=1.0,
-                agent_data=h_data, # Use raw dict as agent_data
+                agent_data=h_data,  # Use raw dict as agent_data
                 perceived_prices={},
                 conformity=0.5,
                 social_rank=0.5,
-                approval_rating=float(h_data.get("approval_rating", 1.0))
+                approval_rating=float(h_data.get("approval_rating", 1.0)),
             )
             dtos.append(dto)
         return dtos
-    
+
     def create_firm_mocks(self, mock_class=None):
         """Create mock firms from golden data."""
         mocks = []
         for f_data in self.firms_data:
             from types import SimpleNamespace
+
             if mock_class:
                 mock = MagicMock(spec=mock_class)
             else:
                 mock = SimpleNamespace()
             for key, value in f_data.items():
                 setattr(mock, key, value)
-            
+
             mock.make_decision = MagicMock(return_value=([], MagicMock()))
-            if not hasattr(mock, 'decision_engine'):
+            if not hasattr(mock, "decision_engine"):
                 mock.decision_engine = MagicMock()
-            if not hasattr(mock.decision_engine, 'ai_engine'):
+            if not hasattr(mock.decision_engine, "ai_engine"):
                 mock.decision_engine.ai_engine = MagicMock()
-            if not hasattr(mock, 'hr'):
+            if not hasattr(mock, "hr"):
                 mock.hr = MagicMock()
             mock.hr.employees = []
-            mock.get_financial_snapshot = MagicMock(return_value={
-                "total_assets": f_data.get("assets", 0),
-                "working_capital": f_data.get("assets", 0),
-                "retained_earnings": f_data.get("retained_earnings", 0),
-                "average_profit": f_data.get("current_profit", 0),
-                "total_debt": f_data.get("total_debt", 0)
-            })
+            mock.get_financial_snapshot = MagicMock(
+                return_value={
+                    "total_assets": f_data.get("assets", 0),
+                    "working_capital": f_data.get("assets", 0),
+                    "retained_earnings": f_data.get("retained_earnings", 0),
+                    "average_profit": f_data.get("current_profit", 0),
+                    "total_debt": f_data.get("total_debt", 0),
+                }
+            )
             mocks.append(mock)
         return mocks
 
@@ -343,17 +357,18 @@ class GoldenLoader:
                 employees=[],
                 employees_data={},
                 agent_data=f_data,
-                system2_guidance={}
+                system2_guidance={},
             )
             dtos.append(dto)
         return dtos
-    
+
     def create_config_mock(self):
         """Create a mock config module from golden data."""
         if GenericGoldenLoader:
             return GenericGoldenLoader.dict_to_mock(self.config_snapshot)
         else:
             from types import SimpleNamespace
+
             mock = SimpleNamespace()
             for key, value in self.config_snapshot.items():
                 setattr(mock, key, value)
@@ -364,7 +379,7 @@ class GoldenLoader:
 def quick_harvest(sim, tick: int, output_dir: str = "tests/goldens"):
     """
     Quick one-liner to harvest fixtures from a running simulation.
-    
+
     Usage (in debug script or notebook):
         from scripts.fixture_harvester import quick_harvest
         quick_harvest(sim, tick=100)
@@ -379,7 +394,7 @@ if __name__ == "__main__":
     # Demo: Create a sample golden fixture
     print("ğŸ§ª Fixture Harvester Demo")
     print("=" * 50)
-    
+
     # Create dummy data for demonstration
     class DummyHousehold:
         def __init__(self, id):
@@ -394,7 +409,7 @@ if __name__ == "__main__":
             self.needs = {"survival": 0.5}
             self.inventory = {}
             self.approval_rating = 0.8
-    
+
     class DummyFirm:
         def __init__(self, id):
             self.id = id
@@ -408,29 +423,29 @@ if __name__ == "__main__":
             self.total_debt = 0.0
             self.current_profit = 100.0
             self.consecutive_loss_turns = 0
-    
+
     # Harvest
     households = [DummyHousehold(i) for i in range(5)]
     firms = [DummyFirm(100 + i) for i in range(3)]
-    
+
     harvester = FixtureHarvester(output_dir="tests/goldens")
     harvester.capture_agents(households, firms, tick=0)
     filepath = harvester.save_all("demo_fixture.json")
-    
+
     # Load and verify
     print("\nğŸ“‚ Loading saved fixture...")
     loader = GoldenLoader.load(str(filepath))
-    
+
     mock_households = loader.create_household_mocks()
     mock_firms = loader.create_firm_mocks()
-    
+
     print(f"âœ… Created {len(mock_households)} household mocks")
     print(f"âœ… Created {len(mock_firms)} firm mocks")
     print(f"\nğŸ” Sample Household Mock:")
     print(f"   ID: {mock_households[0].id}")
     print(f"   Assets: {mock_households[0].assets}")
     print(f"   Employed: {mock_households[0].is_employed}")
-    
+
     print(f"\nğŸ” Sample Firm Mock:")
     print(f"   ID: {mock_firms[0].id}")
     print(f"   Assets: {mock_firms[0].assets}")
diff --git a/scripts/gemini_worker.py b/scripts/gemini_worker.py
index f63989e..a49c59e 100644
--- a/scripts/gemini_worker.py
+++ b/scripts/gemini_worker.py
@@ -1,4 +1,3 @@
-
 import subprocess
 import sys
 import os
@@ -11,17 +10,19 @@ from abc import ABC, abstractmethod
 BASE_DIR = Path(__file__).parent.parent
 MANUALS_DIR = BASE_DIR / "design" / "manuals"
 
+
 class BaseGeminiWorker(ABC):
     """
     Abstract base class for Gemini Workers.
     Handles the interaction with gemini-cli using a specific manual.
     """
+
     def __init__(self, manual_filename: str):
         self.manual_path = MANUALS_DIR / manual_filename
-        self.model = None # Default model
+        self.model = None  # Default model
         if not self.manual_path.exists():
             raise FileNotFoundError(f"âŒ Manual not found: {self.manual_path}")
-        
+
         if not shutil.which("gemini"):
             raise EnvironmentError("âŒ 'gemini' command not found in PATH.")
 
@@ -32,7 +33,12 @@ class BaseGeminiWorker(ABC):
         except Exception as e:
             raise RuntimeError(f"âŒ Error reading manual: {e}")
 
-    def run_gemini(self, instruction: str, context_files: list[str] = None, manual_override: Path = None) -> str:
+    def run_gemini(
+        self,
+        instruction: str,
+        context_files: list[str] = None,
+        manual_override: Path = None,
+    ) -> str:
         """
         Executes gemini-cli with the system prompt, context files, and instruction.
         If manual_override is provided, use that manual instead of self.manual_path.
@@ -44,7 +50,7 @@ class BaseGeminiWorker(ABC):
                 system_prompt = f.read()
         except Exception as e:
             raise RuntimeError(f"âŒ Error reading manual {manual_to_use}: {e}")
-        
+
         # Build Context Block
         context_block = ""
         if context_files:
@@ -63,7 +69,7 @@ class BaseGeminiWorker(ABC):
                 abs_path = BASE_DIR / rel_path
                 if abs_path.exists() and abs_path.is_file():
                     try:
-                        content = abs_path.read_text(encoding='utf-8')
+                        content = abs_path.read_text(encoding="utf-8")
                         context_block += f"\nFile: {rel_path}\n```\n{content}\n```\n"
                         print(f"ğŸ“– Attached context: {rel_path}")
                     except Exception as e:
@@ -74,24 +80,26 @@ class BaseGeminiWorker(ABC):
         full_input = f"{system_prompt}{context_block}\n\n---\n\n{instruction}"
 
         print(f"ğŸš€ [GeminiWorker] Running task with manual: {manual_to_use.name}")
-        
+
         try:
             cmd = ["gemini"]
-            if hasattr(self, 'model') and self.model:
+            if hasattr(self, "model") and self.model:
                 cmd.extend(["--model", self.model])
-            
+
             process = subprocess.run(
-                cmd, 
-                input=full_input, 
-                text=True, 
-                capture_output=True, 
-                encoding='utf-8',
-                shell=True 
+                cmd,
+                input=full_input,
+                text=True,
+                capture_output=True,
+                encoding="utf-8",
+                shell=True,
             )
-            
+
             if process.returncode != 0:
-                raise RuntimeError(f"Gemini CLI Error (Code {process.returncode}):\n{process.stderr}")
-            
+                raise RuntimeError(
+                    f"Gemini CLI Error (Code {process.returncode}):\n{process.stderr}"
+                )
+
             return process.stdout
 
         except Exception as e:
@@ -104,15 +112,23 @@ class BaseGeminiWorker(ABC):
         """
         pass
 
+
 class SpecDrafter(BaseGeminiWorker):
     """
     Worker for drafting specifications.
     Saves output to design/drafts/
     """
+
     def __init__(self):
         super().__init__("spec_writer.md")
 
-    def execute(self, instruction: str, context_files: list[str] = None, audit_file: str = None, **kwargs):
+    def execute(
+        self,
+        instruction: str,
+        context_files: list[str] = None,
+        audit_file: str = None,
+        **kwargs,
+    ):
         # 1. Internal Pre-flight Audit (Auto-Encapsulated)
         audit_context = ""
         if context_files:
@@ -128,14 +144,20 @@ class SpecDrafter(BaseGeminiWorker):
             )
             try:
                 # Use reporter.md manual for audit pass (different from spec_writer.md)
-                audit_result = self.run_gemini(audit_instruction, context_files, manual_override=MANUALS_DIR / "reporter.md")
+                audit_result = self.run_gemini(
+                    audit_instruction,
+                    context_files,
+                    manual_override=MANUALS_DIR / "reporter.md",
+                )
                 audit_context = (
-                    "\n\n" + "="*40 + "\n"
+                    "\n\n" + "=" * 40 + "\n"
                     "ğŸ” [AUTO-AUDIT FINDINGS]\n"
                     "The following architectural risks were identified during the internal pre-flight check.\n"
                     "You MUST address these items in the Specification:\n\n"
-                    + audit_result + "\n"
-                    + "="*40 + "\n\n"
+                    + audit_result
+                    + "\n"
+                    + "=" * 40
+                    + "\n\n"
                 )
                 print("âœ… Auto-Audit Complete. Findings integrated into Spec Context.")
             except Exception as e:
@@ -146,50 +168,65 @@ class SpecDrafter(BaseGeminiWorker):
             audit_path = BASE_DIR / audit_file
             if audit_path.exists():
                 print(f"ğŸš¨ Injecting External Audit Findings from: {audit_path.name}")
-                audit_content = audit_path.read_text(encoding='utf-8')
+                audit_content = audit_path.read_text(encoding="utf-8")
                 # Append external audit to internal audit context
                 audit_context += (
-                    "\n\n" + "="*40 + "\n"
+                    "\n\n" + "=" * 40 + "\n"
                     "ğŸš¨ [EXTERNAL AUDIT REPORT]\n"
-                    + audit_content + "\n"
-                    + "="*40 + "\n\n"
+                    + audit_content
+                    + "\n"
+                    + "=" * 40
+                    + "\n\n"
                 )
 
         # 3. Main Spec Drafting
         full_instruction = audit_context + instruction
-        
+
         print(f"ğŸ“„ Drafting Spec with instruction: '{instruction[:60]}...'")
         result = self.run_gemini(full_instruction, context_files)
-        
+
         # Save to draft file
         # Save to draft file or specified output file
         output_file_path = None
-        if kwargs.get('output_file'):
-            output_file_path = Path(kwargs['output_file'])
+        if kwargs.get("output_file"):
+            output_file_path = Path(kwargs["output_file"])
         else:
             output_dir = BASE_DIR / "design" / "drafts"
             output_dir.mkdir(exist_ok=True, parents=True)
-            
-            safe_name = "".join([c if c.isalnum() else "_" for c in instruction[:30] if c.isalnum() or c == ' ']).strip().replace(" ", "_")[:30]
+
+            safe_name = (
+                "".join(
+                    [
+                        c if c.isalnum() else "_"
+                        for c in instruction[:30]
+                        if c.isalnum() or c == " "
+                    ]
+                )
+                .strip()
+                .replace(" ", "_")[:30]
+            )
             from datetime import datetime
-            timestamp = datetime.now().strftime("%H%M%S") 
+
+            timestamp = datetime.now().strftime("%H%M%S")
             output_file_path = output_dir / f"draft_{timestamp}_{safe_name}.md"
-        
+
         # Ensure parent dir exists
         output_file_path.parent.mkdir(exist_ok=True, parents=True)
 
         with open(output_file_path, "w", encoding="utf-8") as f:
             f.write(result)
-            
+
         print(f"\nâœ… Spec Saved: {output_file_path}")
-        print("="*60)
+        print("=" * 60)
         print(result[:1000] + "\n..." if len(result) > 1000 else result)
-        print("="*60)
+        print("=" * 60)
+
 
 class GitReviewer(BaseGeminiWorker):
     """
     Worker for analyzing git diffs and generating code review reports.
     """
+
     def __init__(self):
         super().__init__("git_reviewer.md")
 
@@ -198,26 +235,31 @@ class GitReviewer(BaseGeminiWorker):
         result = self.run_gemini(instruction, context_files)
 
         from datetime import datetime
+
         timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
-        safe_name = "".join([c if c.isalnum() else "_" for c in instruction[:20]]).strip("_")
-        
-        output_dir = BASE_DIR / "design" / "gemini_output" 
+        safe_name = "".join(
+            [c if c.isalnum() else "_" for c in instruction[:20]]
+        ).strip("_")
+
+        output_dir = BASE_DIR / "design" / "gemini_output"
         output_dir.mkdir(exist_ok=True, parents=True)
-        
+
         print("\nğŸ“ [Review Report]")
-        print("="*60)
+        print("=" * 60)
         print(result)
-        print("="*60)
-        
+        print("=" * 60)
+
         output_file = output_dir / f"review_backup_{timestamp}_{safe_name}.md"
         with open(output_file, "w", encoding="utf-8") as f:
             f.write(result)
-            
+
+
 class Reporter(BaseGeminiWorker):
     """
     Worker for analyzing code and generating reports.
     Saves output to reports/temp/
     """
+
     def __init__(self):
         super().__init__("reporter.md")
 
@@ -226,12 +268,15 @@ class Reporter(BaseGeminiWorker):
         result = self.run_gemini(instruction, context_files)
 
         output_file_path = None
-        if kwargs.get('output_file'):
-            output_file_path = Path(kwargs['output_file'])
+        if kwargs.get("output_file"):
+            output_file_path = Path(kwargs["output_file"])
         else:
             from datetime import datetime
+
             timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
-            safe_name = "".join([c if c.isalnum() else "_" for c in instruction[:20]]).strip("_")
+            safe_name = "".join(
+                [c if c.isalnum() else "_" for c in instruction[:20]]
+            ).strip("_")
             output_dir = BASE_DIR / "reports" / "temp"
             output_dir.mkdir(exist_ok=True, parents=True)
             output_file_path = output_dir / f"report_{timestamp}_{safe_name}.md"
@@ -241,61 +286,75 @@ class Reporter(BaseGeminiWorker):
 
         with open(output_file_path, "w", encoding="utf-8") as f:
             f.write(result)
-            
+
         print(f"\nâœ… Report Saved: {output_file_path}")
-        print("="*60)
+        print("=" * 60)
         print(result[:500] + "\n..." if len(result) > 500 else result)
-        print("="*60)
+        print("=" * 60)
+
 
 class GitOperator(BaseGeminiWorker):
     """
     Worker for generating Git commands.
     Can auto-execute commands if requested.
     """
+
     def __init__(self):
         super().__init__("git_operator.md")
 
-    def execute(self, instruction: str, context_files: list[str] = None, auto_run: bool = False, **kwargs):
+    def execute(
+        self,
+        instruction: str,
+        context_files: list[str] = None,
+        auto_run: bool = False,
+        **kwargs,
+    ):
         print(f"ğŸ™ analyzing Git operation: '{instruction}'...")
-        
+
         # Enhance instruction with current git status if possible
         try:
-            status_proc = subprocess.run(["git", "status"], cwd=BASE_DIR, capture_output=True, text=True, encoding='utf-8')
+            status_proc = subprocess.run(
+                ["git", "status"],
+                cwd=BASE_DIR,
+                capture_output=True,
+                text=True,
+                encoding="utf-8",
+            )
             git_status = status_proc.stdout
             instruction += f"\n\n[Current Git Status]\n{git_status}"
         except Exception as e:
             print(f"âš ï¸ Could not fetch git status: {e}")
 
         result = self.run_gemini(instruction, context_files)
-        
+
         # Parse JSON
         import json
         import re
-        
+
         try:
             # Extract JSON block if surrounded by markdown code fences
-            json_match = re.search(r'\{.*\}', result, re.DOTALL)
+            json_match = re.search(r"\{.*\}", result, re.DOTALL)
             if json_match:
                 json_str = json_match.group(0)
             else:
                 json_str = result
 
             plan = json.loads(json_str)
-            
+
             print("\nğŸ¤– [GitPlan]")
             print(f"Reasoning: {plan.get('reasoning', 'No reasoning provided')}")
             print(f"Risk Level: {plan.get('risk_level', 'UNKNOWN')}")
             print("Commands:")
-            for cmd in plan.get('commands', []):
+            for cmd in plan.get("commands", []):
                 print(f"  $ {cmd}")
-                
+
             if auto_run:
-                if plan.get('risk_level') == 'HIGH':
+                if plan.get("risk_level") == "HIGH":
                     print("\nâš ï¸ HIGH RISK DETECTED. Stopping auto-run for safety.")
                     return
 
                 print("\nğŸš€ Auto-Running Commands...")
-                for cmd in plan.get('commands', []):
+                for cmd in plan.get("commands", []):
                     print(f"Executing: {cmd}")
                     # Use string command for shell=True, ensure quotes are handled by shell
                     proc = subprocess.run(cmd, shell=True, cwd=BASE_DIR)
@@ -309,43 +368,58 @@ class GitOperator(BaseGeminiWorker):
         except Exception as e:
             print(f"âŒ Error during execution: {e}")
 
+
 class ContextManager(BaseGeminiWorker):
     """
     Worker for summarizing state and creating snapshots.
     """
+
     def __init__(self):
         super().__init__("context_manager.md")
 
-    def execute(self, instruction: str, context_files: list[str] = None, output_file: str = None, **kwargs):
+    def execute(
+        self,
+        instruction: str,
+        context_files: list[str] = None,
+        output_file: str = None,
+        **kwargs,
+    ):
         print(f"ğŸ§  Distilling Context: '{instruction}'...")
         result = self.run_gemini(instruction, context_files)
-        
-        target_file = Path(output_file) if output_file else BASE_DIR / "design" / "snapshots" / "latest_snapshot.md"
+
+        target_file = (
+            Path(output_file)
+            if output_file
+            else BASE_DIR / "design" / "snapshots" / "latest_snapshot.md"
+        )
         target_file.parent.mkdir(exist_ok=True, parents=True)
-        
+
         with open(target_file, "w", encoding="utf-8") as f:
             f.write(result)
-            
+
         print(f"\nâœ… Content Updated: {target_file}")
-        print("="*60)
+        print("=" * 60)
         print(result[:500] + "..." if len(result) > 500 else result)
-        print("="*60)
+        print("=" * 60)
+
 
 class Validator(BaseGeminiWorker):
     """
     Worker for validating code against architecture rules.
     """
+
     def __init__(self):
         super().__init__("validator.md")
 
     def execute(self, instruction: str, context_files: list[str] = None, **kwargs):
         print(f"âš–ï¸ Validating Protocol: '{instruction}'...")
         result = self.run_gemini(instruction, context_files)
-        
+
         print("\nâš–ï¸ [Validation Results]")
-        print("="*60)
+        print("=" * 60)
         print(result)
-        print("="*60)
+        print("=" * 60)
+
 
 def main():
     parser = argparse.ArgumentParser(description="Gemini Worker Interface")
@@ -355,51 +429,97 @@ def main():
     # Spec Drafter
     spec_parser = subparsers.add_parser("spec", help="Draft a new specification")
     spec_parser.add_argument("instruction", help="Instruction for the spec writer")
-    spec_parser.add_argument("--context", "-c", nargs="+", help="List of files to read as context")
-    spec_parser.add_argument("--audit", "-a", help="Path to Pre-flight Audit report to inject as context")
+    spec_parser.add_argument(
+        "--context", "-c", nargs="+", help="List of files to read as context"
+    )
+    spec_parser.add_argument(
+        "--audit", "-a", help="Path to Pre-flight Audit report to inject as context"
+    )
 
     spec_parser.add_argument("--output", "-o", help="Specific output file path")
-    spec_parser.add_argument("--model", "-m", help="Gemini model to use (e.g. pro, flash)")
+    spec_parser.add_argument(
+        "--model", "-m", help="Gemini model to use (e.g. pro, flash)"
+    )
 
     # Git Operator
     git_parser = subparsers.add_parser("git", help="Generate git commands")
     git_parser.add_argument("instruction", help="Instruction for the git operator")
-    git_parser.add_argument("--context", "-c", nargs="+", help="List of files to read as context")
-    git_parser.add_argument("--auto-run", action="store_true", help="Automatically execute the generated commands")
-    git_parser.add_argument("--model", "-m", help="Gemini model to use (e.g. pro, flash)")
+    git_parser.add_argument(
+        "--context", "-c", nargs="+", help="List of files to read as context"
+    )
+    git_parser.add_argument(
+        "--auto-run",
+        action="store_true",
+        help="Automatically execute the generated commands",
+    )
+    git_parser.add_argument(
+        "--model", "-m", help="Gemini model to use (e.g. pro, flash)"
+    )
 
     # Reporter
     reporter_parser = subparsers.add_parser("reporter", help="Analyze and Report")
     reporter_parser.add_argument("instruction", help="Instruction for the reporter")
-    reporter_parser.add_argument("--context", "-c", nargs="+", help="List of files to read as context")
+    reporter_parser.add_argument(
+        "--context", "-c", nargs="+", help="List of files to read as context"
+    )
     reporter_parser.add_argument("--output", "-o", help="Specific output file path")
-    reporter_parser.add_argument("--model", "-m", help="Gemini model to use (e.g. pro, flash)")
+    reporter_parser.add_argument(
+        "--model", "-m", help="Gemini model to use (e.g. pro, flash)"
+    )
 
     # Context Manager / Scribe
-    context_parser = subparsers.add_parser("context", help="Manage session context and snapshots")
-    context_parser.add_argument("instruction", help="Instruction for the context manager")
-    context_parser.add_argument("--context", "-c", nargs="+", help="List of files to read as context")
-    context_parser.add_argument("--output", "-o", help="Specific output file path (optional)")
-    context_parser.add_argument("--model", "-m", help="Gemini model to use (e.g. pro, flash)")
+    context_parser = subparsers.add_parser(
+        "context", help="Manage session context and snapshots"
+    )
+    context_parser.add_argument(
+        "instruction", help="Instruction for the context manager"
+    )
+    context_parser.add_argument(
+        "--context", "-c", nargs="+", help="List of files to read as context"
+    )
+    context_parser.add_argument(
+        "--output", "-o", help="Specific output file path (optional)"
+    )
+    context_parser.add_argument(
+        "--model", "-m", help="Gemini model to use (e.g. pro, flash)"
+    )
 
     # Validator
-    validator_parser = subparsers.add_parser("verify", help="Validate protocol and architecture")
+    validator_parser = subparsers.add_parser(
+        "verify", help="Validate protocol and architecture"
+    )
     validator_parser.add_argument("instruction", help="Instruction for the validator")
-    validator_parser.add_argument("--context", "-c", nargs="+", help="List of files to read as context")
-    validator_parser.add_argument("--model", "-m", help="Gemini model to use (e.g. pro, flash)")
+    validator_parser.add_argument(
+        "--context", "-c", nargs="+", help="List of files to read as context"
+    )
+    validator_parser.add_argument(
+        "--model", "-m", help="Gemini model to use (e.g. pro, flash)"
+    )
 
     # Auditor (Uses Reporter logic)
-    auditor_parser = subparsers.add_parser("audit", help="Identify technical debt and patterns")
+    auditor_parser = subparsers.add_parser(
+        "audit", help="Identify technical debt and patterns"
+    )
     auditor_parser.add_argument("instruction", help="Instruction for the auditor")
-    auditor_parser.add_argument("--context", "-c", nargs="+", help="List of files to read as context")
+    auditor_parser.add_argument(
+        "--context", "-c", nargs="+", help="List of files to read as context"
+    )
     auditor_parser.add_argument("--output", "-o", help="Specific output file path")
-    auditor_parser.add_argument("--model", "-m", help="Gemini model to use (e.g. pro, flash)")
+    auditor_parser.add_argument(
+        "--model", "-m", help="Gemini model to use (e.g. pro, flash)"
+    )
 
     # Git Reviewer
-    reviewer_parser = subparsers.add_parser("git-review", help="Analyze git diffs and report issues")
+    reviewer_parser = subparsers.add_parser(
+        "git-review", help="Analyze git diffs and report issues"
+    )
     reviewer_parser.add_argument("instruction", help="Instruction for the reviewer")
-    reviewer_parser.add_argument("--context", "-c", nargs="+", help="List of files to read as context")
-    reviewer_parser.add_argument("--model", "-m", help="Gemini model to use (e.g. pro, flash)")
+    reviewer_parser.add_argument(
+        "--context", "-c", nargs="+", help="List of files to read as context"
+    )
+    reviewer_parser.add_argument(
+        "--model", "-m", help="Gemini model to use (e.g. pro, flash)"
+    )
 
     args = parser.parse_args()
 
@@ -411,28 +531,28 @@ def main():
             "context": ContextManager,
             "verify": Validator,
             "audit": Reporter,
-            "git-review": GitReviewer
+            "git-review": GitReviewer,
         }
-        
+
         if args.worker_type in worker_map:
             worker = worker_map[args.worker_type]()
 
-            
             # Inject model if specified
-            if getattr(args, 'model', None):
+            if getattr(args, "model", None):
                 worker.model = args.model
-                
+
             worker.execute(
-                args.instruction, 
-                context_files=getattr(args, 'context', None),
-                auto_run=getattr(args, 'auto_run', False),
-                output_file=getattr(args, 'output', None),
-                audit_file=getattr(args, 'audit', None)
+                args.instruction,
+                context_files=getattr(args, "context", None),
+                auto_run=getattr(args, "auto_run", False),
+                output_file=getattr(args, "output", None),
+                audit_file=getattr(args, "audit", None),
             )
-            
+
     except Exception as e:
         print(f"âŒ Error: {e}")
         sys.exit(1)
 
+
 if __name__ == "__main__":
     main()
diff --git a/scripts/generate_golden_fixtures.py b/scripts/generate_golden_fixtures.py
index dc75d0f..0b7bbb2 100644
--- a/scripts/generate_golden_fixtures.py
+++ b/scripts/generate_golden_fixtures.py
@@ -9,8 +9,9 @@ sys.path.append(str(root_dir))
 
 # Mock matplotlib to prevent "no display name" errors on headless systems
 import unittest.mock
-sys.modules['matplotlib'] = unittest.mock.MagicMock()
-sys.modules['matplotlib.pyplot'] = unittest.mock.MagicMock()
+
+sys.modules["matplotlib"] = unittest.mock.MagicMock()
+sys.modules["matplotlib.pyplot"] = unittest.mock.MagicMock()
 
 try:
     from main import create_simulation
@@ -19,6 +20,7 @@ except ImportError as e:
     print(f"âŒ ImportError: {e}")
     sys.exit(1)
 
+
 def generate_golden_fixtures():
     print("ğŸš€ Starting Golden Fixture Generation...")
 
@@ -31,6 +33,7 @@ def generate_golden_fixtures():
     except Exception as e:
         print(f"âŒ Failed to create simulation: {e}")
         import traceback
+
         traceback.print_exc()
         return
 
@@ -40,7 +43,7 @@ def generate_golden_fixtures():
     capture_schedule = {
         0: "initial_state.json",
         10: "early_economy.json",
-        100: "stable_economy.json"
+        100: "stable_economy.json",
     }
 
     max_tick = max(capture_schedule.keys())
@@ -63,20 +66,23 @@ def generate_golden_fixtures():
             except Exception as e:
                 print(f"âŒ Failed to capture fixture at tick {current_tick}: {e}")
                 import traceback
+
                 traceback.print_exc()
 
         if sim.time < max_tick:
             try:
                 sim.run_tick()
             except Exception as e:
-                 print(f"âŒ Simulation failed at tick {current_tick}: {e}")
-                 import traceback
-                 traceback.print_exc()
-                 break
+                print(f"âŒ Simulation failed at tick {current_tick}: {e}")
+                import traceback
+
+                traceback.print_exc()
+                break
         else:
             break
 
     print("âœ… Golden Fixture Generation Complete.")
 
+
 if __name__ == "__main__":
     generate_golden_fixtures()
diff --git a/scripts/generate_learning_curve.py b/scripts/generate_learning_curve.py
index b09fee1..c81fdf3 100644
--- a/scripts/generate_learning_curve.py
+++ b/scripts/generate_learning_curve.py
@@ -1,4 +1,3 @@
-
 import re
 import os
 import statistics
@@ -6,13 +5,14 @@ import statistics
 LOG_FILE = "simulation.log"
 OUTPUT_FILE = "reports/learning_report.txt"
 
+
 def generate_learning_report():
     """
     Parses the simulation log to extract AI rewards and generates a statistical text report.
     Replaces image generation to avoid binary conflicts.
     """
     rewards = {}
-    
+
     print(f"Parsing log file: {LOG_FILE}")
     if not os.path.exists(LOG_FILE):
         print(f"Error: Log file not found at {LOG_FILE}")
@@ -39,39 +39,44 @@ def generate_learning_report():
     # Analyze Shocks
     # Shock 1: Inflation (Tick 200) -> Analyze 150-199 vs 200-249
     # Shock 2: Recession (Tick 600) -> Analyze 550-599 vs 600-649
-    
+
     def get_avg(start, end):
         vals = [rewards[t] for t in range(start, end) if t in rewards]
         return statistics.mean(vals) if vals else None
 
     s1_pre = get_avg(150, 200)
     s1_post = get_avg(200, 250)
-    
+
     s2_pre = get_avg(550, 600)
     s2_post = get_avg(600, 650)
-    
+
     report_lines = []
     report_lines.append("=== AI Learning Analysis Report (Operation Show Therapy) ===")
-    
+
     if s1_pre is not None and s1_post is not None:
         delta1 = s1_post - s1_pre
-        report_lines.append(f"Shock 1 (Inflation @ 200): Pre={s1_pre:.2f}, Post={s1_post:.2f}, Delta={delta1:.2f}")
+        report_lines.append(
+            f"Shock 1 (Inflation @ 200): Pre={s1_pre:.2f}, Post={s1_post:.2f}, Delta={delta1:.2f}"
+        )
     else:
         report_lines.append("Shock 1: Insufficient data.")
 
     if s2_pre is not None and s2_post is not None:
         delta2 = s2_post - s2_pre
-        report_lines.append(f"Shock 2 (Recession @ 600): Pre={s2_pre:.2f}, Post={s2_post:.2f}, Delta={delta2:.2f}")
+        report_lines.append(
+            f"Shock 2 (Recession @ 600): Pre={s2_pre:.2f}, Post={s2_post:.2f}, Delta={delta2:.2f}"
+        )
     else:
         report_lines.append("Shock 2: Insufficient data.")
-        
+
     full_report = "\n".join(report_lines)
     print(full_report)
-    
+
     os.makedirs(os.path.dirname(OUTPUT_FILE), exist_ok=True)
     with open(OUTPUT_FILE, "w") as f:
         f.write(full_report)
     print(f"\nReport saved to {OUTPUT_FILE}")
 
+
 if __name__ == "__main__":
     generate_learning_report()
diff --git a/scripts/generate_phase1_report.py b/scripts/generate_phase1_report.py
index a7fd5fe..d833b9c 100644
--- a/scripts/generate_phase1_report.py
+++ b/scripts/generate_phase1_report.py
@@ -7,6 +7,7 @@ SUMMARY_FILE = "iron_test_summary.csv"
 REPORT_FILE = "reports/PHASE1_FINAL_REPORT.md"
 CRUCIBLE_LOGS = "reports/crucible_logs.txt"
 
+
 def parse_logs():
     events = {
         "LOAN_REJECTED": [],
@@ -14,61 +15,62 @@ def parse_logs():
         "PANIC_DISCOUNT": [],  # Fire Sale
         "STARTUP": [],
         "MONEY_SUPPLY_CHECK": [],
-        "DEBT_CEILING_HIT": []
+        "DEBT_CEILING_HIT": [],
     }
-    
+
     try:
         # Try finding the latest log file. If iron_test_log.txt is old, try full_log.txt
-        # Ideally, iron_test.py should output to a specific file. 
+        # Ideally, iron_test.py should output to a specific file.
         # For now, we scan 'full_log.txt' as it's the main appender.
         target_log = "full_log.txt"
-        
-        with open(target_log, 'r', encoding='utf-8') as f:
+
+        with open(target_log, "r", encoding="utf-8") as f:
             lines = f.readlines()
-            
+
         # Filter for current run (naive approach: last N lines or scan all)
         # We'll scan the last 20000 lines to capture the recent run
         recent_lines = lines[-50000:] if len(lines) > 50000 else lines
-        
+
         relevant_logs = []
-        
+
         for line in recent_lines:
             for key in events.keys():
                 if key in line:
                     events[key].append(line.strip())
                     relevant_logs.append(line.strip())
-                    
+
         return events, relevant_logs
     except FileNotFoundError:
         return events, []
 
+
 def generate_report():
     events, relevant_logs = parse_logs()
-    
+
     summary_df = pd.DataFrame()
     if os.path.exists(SUMMARY_FILE):
         try:
             summary_df = pd.read_csv(SUMMARY_FILE)
         except:
             pass
-            
+
     # Calculate Metrics
     num_startups = len(events["STARTUP"])
     num_liquidations = len(events["FIRM_LIQUIDATION"])
     num_fire_sales = len(events["PANIC_DISCOUNT"])
     num_loan_rejections = len(events["LOAN_REJECTED"])
-    
+
     # Money Supply Check
     deltas = []
     for line in events["MONEY_SUPPLY_CHECK"]:
         match = re.search(r"Delta: (-?\d+\.\d+)", line)
         if match:
             deltas.append(float(match.group(1)))
-            
+
     max_delta = max([abs(d) for d in deltas]) if deltas else 0.0
     avg_delta = sum([abs(d) for d in deltas]) / len(deltas) if deltas else 0.0
     conservation_status = "PASSED" if max_delta < 1.0 else "FAILED"
-    
+
     # Create Report Content
     content = f"""# Phase 1 Final Validation: The Crucible Test Report
 
@@ -101,15 +103,16 @@ def generate_report():
 """
 
     # Save Report
-    with open(REPORT_FILE, 'w', encoding='utf-8') as f:
+    with open(REPORT_FILE, "w", encoding="utf-8") as f:
         f.write(content)
-        
+
     # Save Log Excerpts
-    with open(CRUCIBLE_LOGS, 'w', encoding='utf-8') as f:
+    with open(CRUCIBLE_LOGS, "w", encoding="utf-8") as f:
         f.write("\n".join(relevant_logs))
-        
+
     print(f"Report generated: {REPORT_FILE}")
     print(f"Logs extracted: {CRUCIBLE_LOGS}")
 
+
 if __name__ == "__main__":
     generate_report()
diff --git a/scripts/git_sync_checker.py b/scripts/git_sync_checker.py
index 197d152..4fff838 100644
--- a/scripts/git_sync_checker.py
+++ b/scripts/git_sync_checker.py
@@ -3,6 +3,7 @@ import subprocess
 import re
 import os
 
+
 def run_command(command, cwd=None):
     """Run a shell command and return stdout. Raises error on failure."""
     try:
@@ -13,20 +14,21 @@ def run_command(command, cwd=None):
             stdout=subprocess.PIPE,
             stderr=subprocess.PIPE,
             text=True,
-            encoding='utf-8',
-            errors='replace'
+            encoding="utf-8",
+            errors="replace",
         )
         return result.stdout.strip()
     except subprocess.CalledProcessError as e:
         print(f"Error running command: {' '.join(command)}\nstderr: {e.stderr}")
         raise
 
+
 def sync_and_find_commit(identifier):
     """
     Syncs with remote and finds the latest commit hash for a given session ID or branch name.
     """
     sys.stderr.write(f"ğŸ”„ Syncing Git to find latest commit for: {identifier}...\n")
-    
+
     # 1. Force Fetch All
     try:
         run_command(["git", "fetch", "--all"])
@@ -37,24 +39,26 @@ def sync_and_find_commit(identifier):
 
     # Determine if identifier is a session ID (digits) or branch name
     target_branch = None
-    if re.match(r'^\d+$', identifier):
+    if re.match(r"^\d+$", identifier):
         # Session ID: Find remote branch containing this ID
-        sys.stderr.write(f"   ğŸ” Searching for remote branches containing session ID: {identifier}\n")
+        sys.stderr.write(
+            f"   ğŸ” Searching for remote branches containing session ID: {identifier}\n"
+        )
         try:
             # List all remote branches
             remote_branches_output = run_command(["git", "branch", "-r"])
             branches = [b.strip() for b in remote_branches_output.splitlines()]
-            
+
             # Filter for branches containing the session ID
             matches = [b for b in branches if identifier in b]
-            
+
             if not matches:
                 sys.stderr.write("   âŒ No remote branch found for this session ID.\n")
                 return None
-            
+
             target_branch = matches[0].replace("origin/", "")
             sys.stderr.write(f"   âœ… Found target branch: {target_branch}\n")
-            
+
         except Exception as e:
             sys.stderr.write(f"   âŒ Error finding branch: {e}\n")
             return None
@@ -67,30 +71,35 @@ def sync_and_find_commit(identifier):
     try:
         output = run_command(["git", "ls-remote", "origin", target_branch])
         if not output:
-             sys.stderr.write("   âŒ ls-remote returned no result. Branch might not exist on remote.\n")
-             return None
-            
+            sys.stderr.write(
+                "   âŒ ls-remote returned no result. Branch might not exist on remote.\n"
+            )
+            return None
+
         parts = output.split()
         if parts:
             latest_commit_hash = parts[0]
             sys.stderr.write(f"   ğŸ¯ Latest Remote Commit: {latest_commit_hash}\n")
             return latest_commit_hash
         else:
-             sys.stderr.write("   âŒ Could not parse ls-remote output.\n")
-             return None
+            sys.stderr.write("   âŒ Could not parse ls-remote output.\n")
+            return None
 
     except Exception as e:
         sys.stderr.write(f"   âŒ ls-remote failed: {e}\n")
         return None
 
+
 if __name__ == "__main__":
     if len(sys.argv) < 2:
-        sys.stderr.write("Usage: python git_sync_checker.py <session_id_or_branch_name>\n")
+        sys.stderr.write(
+            "Usage: python git_sync_checker.py <session_id_or_branch_name>\n"
+        )
         sys.exit(1)
-    
+
     identifier = sys.argv[1]
     last_commit = sync_and_find_commit(identifier)
-    
+
     if last_commit:
         # STDOUT ONLY contains the hash
         print(last_commit)
diff --git a/scripts/iron_test.py b/scripts/iron_test.py
index 993afae..5481e94 100644
--- a/scripts/iron_test.py
+++ b/scripts/iron_test.py
@@ -7,13 +7,14 @@ Tasks:
 3. Analyze results against thresholds.
 4. Output report.
 """
+
 import sys
 from pathlib import Path
 import os
 import argparse
 import logging
 import json
-import time # Added for TPS
+import time  # Added for TPS
 
 # Add project root to path
 sys.path.append(str(Path(__file__).resolve().parent.parent))
@@ -23,36 +24,39 @@ from main import create_simulation
 
 # Configure Logging
 # Force configuration after main import might have messed with it
-logging.getLogger().setLevel(logging.ERROR) # Suppress all other logs (e.g. from Matplotlib, Systems)
+logging.getLogger().setLevel(
+    logging.ERROR
+)  # Suppress all other logs (e.g. from Matplotlib, Systems)
 logger = logging.getLogger("IRON_TEST")
 logger.setLevel(logging.INFO)
 if not logger.handlers:
     handler = logging.StreamHandler(sys.stdout)
-    handler.setFormatter(logging.Formatter('%(asctime)s | %(levelname)s | %(message)s'))
+    handler.setFormatter(logging.Formatter("%(asctime)s | %(levelname)s | %(message)s"))
     logger.addHandler(handler)
 logger.propagate = False
 
+
 def run_simulation(ticks: int, overrides: dict = None):
     logger.info(f"=== IRON TEST START: {ticks} Ticks ===")
 
-    start_time = time.time() # Start Timer
+    start_time = time.time()  # Start Timer
 
     # Initialize Simulation via Factory
     simulation = create_simulation(overrides=overrides)
     households = simulation.households
     # Note: SimulationRepository is already handled in create_simulation
-    
+
     # 5. Baseline for GDP
-    simulation.run_tick() # Tick 1
+    simulation.run_tick()  # Tick 1
     initial_indicators = simulation.tracker.get_latest_indicators()
     initial_gdp = initial_indicators.get("total_production", 0.0)
     logger.info(f"Baseline GDP (Physical): {initial_gdp}")
-    
+
     # Metrics tracking
     labor_share_sum = 0.0
     labor_share_count = 0
     max_unemployment = 0.0
-    
+
     passed = True
     failure_reason = ""
 
@@ -60,7 +64,7 @@ def run_simulation(ticks: int, overrides: dict = None):
     for t in range(2, ticks + 1):
         try:
             simulation.run_tick()
-            
+
             indicators = simulation.tracker.get_latest_indicators()
             current_gdp = indicators.get("total_production", 0.0)
 
@@ -77,14 +81,15 @@ def run_simulation(ticks: int, overrides: dict = None):
             velocity = indicators.get("velocity_of_money", 0.0)
             turnover = indicators.get("inventory_turnover", 0.0)
 
-            if t > 10: # Warmup
+            if t > 10:  # Warmup
                 labor_share_sum += l_share
                 labor_share_count += 1
 
             # 3. Unemployment
             u_rate = indicators.get("unemployment_rate", 0.0) / 100.0
-            if t > 10: # Warmup
-                if u_rate > max_unemployment: max_unemployment = u_rate
+            if t > 10:  # Warmup
+                if u_rate > max_unemployment:
+                    max_unemployment = u_rate
 
             if t % 50 == 0:
                 avg_ls = labor_share_sum / max(1, labor_share_count)
@@ -102,25 +107,26 @@ def run_simulation(ticks: int, overrides: dict = None):
             passed = False
             failure_reason = f"Crash: {e}"
             import traceback
+
             traceback.print_exc()
             break
 
     # Final Checks
-    end_time = time.time() # End Timer
+    end_time = time.time()  # End Timer
     total_time = end_time - start_time
     tps = ticks / total_time if total_time > 0 else 0
 
     final_indicators = simulation.tracker.get_latest_indicators()
     final_gdp = final_indicators.get("total_production", 0.0)
     final_pop = sum(1 for h in households if h.is_active)
-    
+
     # Verification Rules
-    if final_pop < config.NUM_HOUSEHOLDS * 0.5: # Pop collapse check
+    if final_pop < config.NUM_HOUSEHOLDS * 0.5:  # Pop collapse check
         passed = False
         failure_reason += " | Population Collapse"
 
     avg_labor_share = labor_share_sum / max(1, labor_share_count)
-    if avg_labor_share < 0.01: # 1% Average Labor Share Minimum
+    if avg_labor_share < 0.01:  # 1% Average Labor Share Minimum
         passed = False
         failure_reason += f" | Labor Share Too Low (Avg: {avg_labor_share:.1%})"
 
@@ -131,9 +137,9 @@ def run_simulation(ticks: int, overrides: dict = None):
     # Note: User requirements say "Verification: Labor Share >= 30%".
     # User instructions for Analysis: "Labor Share < 30% -> Increase Cost".
     # This implies failing the test is EXPECTED during tuning.
-    
+
     simulation.finalize_simulation()
-    
+
     # Report
     # Report Generation Disabled for Git Safety
     # with open("reports/iron_test_phase21_result.md", "w") as f:
@@ -150,7 +156,10 @@ def run_simulation(ticks: int, overrides: dict = None):
     #     if not passed:
     #         f.write(f"**Reason**: {failure_reason}\n")
 
-    logger.info(f"Test Complete. Verdict: {'PASS' if passed else 'FAIL'} | TPS: {tps:.2f}")
+    logger.info(
+        f"Test Complete. Verdict: {'PASS' if passed else 'FAIL'} | TPS: {tps:.2f}"
+    )
+
 
 if __name__ == "__main__":
     parser = argparse.ArgumentParser()
@@ -178,20 +187,28 @@ if __name__ == "__main__":
 
     # [Genesis Fix] Inject Liquidity to prevent immediate collapse
     overrides["INITIAL_HOUSEHOLD_ASSETS_MEAN"] = 5000.0
-    overrides["INITIAL_FIRM_CAPITAL_MEAN"] = 50000.0 # Huge runway
-    overrides["INITIAL_FIRM_INVENTORY_MEAN"] = 5.0 # Low -> force immediate hiring
-    overrides["INITIAL_HOUSEHOLD_FOOD_INVENTORY"] = 2.0 # Force Immediate Demand
-    overrides["FIRM_MAINTENANCE_FEE"] = 0.0 # No bleed during startup
-    overrides["FIRM_PRODUCTIVITY_FACTOR"] = 5.0 # WO-047: Balanced Labor Intensity (was 0.1 = extreme)
-    overrides["FIRM_MIN_PRODUCTION_TARGET"] = 30.0 # Force Medium Production (Sustainable)
-    overrides["HOUSEHOLD_ASSETS_THRESHOLD_FOR_LABOR_SUPPLY"] = 10000.0 # Force labor participation
-    overrides["INVENTORY_HOLDING_COST_RATE"] = 0.001 # Reduce bleeding
-    overrides["LABOR_MARKET_MIN_WAGE"] = 12.0 # Close Bid-Ask spread
-    overrides["AUTOMATION_COST_PER_PCT"] = 1e9 # Disable Automation Spending
-    overrides["INITIAL_FIRM_CAPITAL_MEAN"] = 200000.0 # Massive Runway for 100 ticks
-    overrides["DIVIDEND_RATE_MIN"] = 0.0 # Prevent capital drain (Public)
-    overrides["DIVIDEND_RATE_MAX"] = 0.0 # Prevent capital drain (Public)
-    overrides["FIRM_SAFETY_MARGIN"] = 190000.0 # Protect 95% of Capital
-    overrides["CAPITAL_DEPRECIATION_RATE"] = 0.0 # Disable depreciation to prevent Zombie Economy (AI requires training to invest)
+    overrides["INITIAL_FIRM_CAPITAL_MEAN"] = 50000.0  # Huge runway
+    overrides["INITIAL_FIRM_INVENTORY_MEAN"] = 5.0  # Low -> force immediate hiring
+    overrides["INITIAL_HOUSEHOLD_FOOD_INVENTORY"] = 2.0  # Force Immediate Demand
+    overrides["FIRM_MAINTENANCE_FEE"] = 0.0  # No bleed during startup
+    overrides["FIRM_PRODUCTIVITY_FACTOR"] = (
+        5.0  # WO-047: Balanced Labor Intensity (was 0.1 = extreme)
+    )
+    overrides["FIRM_MIN_PRODUCTION_TARGET"] = (
+        30.0  # Force Medium Production (Sustainable)
+    )
+    overrides["HOUSEHOLD_ASSETS_THRESHOLD_FOR_LABOR_SUPPLY"] = (
+        10000.0  # Force labor participation
+    )
+    overrides["INVENTORY_HOLDING_COST_RATE"] = 0.001  # Reduce bleeding
+    overrides["LABOR_MARKET_MIN_WAGE"] = 12.0  # Close Bid-Ask spread
+    overrides["AUTOMATION_COST_PER_PCT"] = 1e9  # Disable Automation Spending
+    overrides["INITIAL_FIRM_CAPITAL_MEAN"] = 200000.0  # Massive Runway for 100 ticks
+    overrides["DIVIDEND_RATE_MIN"] = 0.0  # Prevent capital drain (Public)
+    overrides["DIVIDEND_RATE_MAX"] = 0.0  # Prevent capital drain (Public)
+    overrides["FIRM_SAFETY_MARGIN"] = 190000.0  # Protect 95% of Capital
+    overrides["CAPITAL_DEPRECIATION_RATE"] = (
+        0.0  # Disable depreciation to prevent Zombie Economy (AI requires training to invest)
+    )
 
     run_simulation(ticks, overrides)
diff --git a/scripts/jules_bridge.py b/scripts/jules_bridge.py
index 08e801b..758a4dd 100644
--- a/scripts/jules_bridge.py
+++ b/scripts/jules_bridge.py
@@ -5,6 +5,7 @@ Phase 23: AI Agent Orchestration
 This script allows Antigravity to programmatically create Jules sessions,
 monitor their progress, and retrieve results.
 """
+
 import os
 import json
 import requests
@@ -20,6 +21,7 @@ BASE_DIR = Path(__file__).parent.parent
 # Load .env file
 try:
     from dotenv import load_dotenv
+
     # Find .env in project root
     env_path = BASE_DIR / ".env"
     load_dotenv(env_path)
@@ -38,6 +40,7 @@ DEFAULT_SOURCE = "sources/github/Hoonys101/economics"
 
 class AutomationMode(Enum):
     """Jules automation modes."""
+
     MANUAL = "MANUAL"  # No auto PR
     AUTO_CREATE_PR = "AUTO_CREATE_PR"  # Auto create PR on completion
 
@@ -45,6 +48,7 @@ class AutomationMode(Enum):
 @dataclass
 class JulesSession:
     """Represents a Jules session."""
+
     id: str
     name: str
     title: str
@@ -66,15 +70,12 @@ class JulesBridge:
             raise ValueError("JULES_API_KEY not set. Add it to your .env file.")
         self.headers = {
             "X-Goog-Api-Key": self.api_key,
-            "Content-Type": "application/json"
+            "Content-Type": "application/json",
         }
 
     def list_sources(self) -> List[Dict[str, Any]]:
         """List all available sources (connected repositories)."""
-        response = requests.get(
-            f"{JULES_API_BASE}/sources",
-            headers=self.headers
-        )
+        response = requests.get(f"{JULES_API_BASE}/sources", headers=self.headers)
         response.raise_for_status()
         data = response.json()
         return data.get("sources", [])
@@ -86,11 +87,11 @@ class JulesBridge:
         source: str = DEFAULT_SOURCE,
         starting_branch: str = "main",
         automation_mode: AutomationMode = AutomationMode.AUTO_CREATE_PR,
-        require_plan_approval: bool = False
+        require_plan_approval: bool = False,
     ) -> JulesSession:
         """
         Create a new Jules session with the given task.
-        
+
         Args:
             prompt: The task description for Jules.
             title: Session title (will be PR title if auto-created).
@@ -98,38 +99,36 @@ class JulesBridge:
             starting_branch: Branch to base work on.
             automation_mode: Whether to auto-create PR.
             require_plan_approval: If True, waits for explicit approval.
-            
+
         Returns:
             JulesSession object with session details.
         """
         if source != DEFAULT_SOURCE:
             # Safety Guard: Prevent accidental assignment to wrong project
-            logger.warning(f"Target source '{source}' differs from default '{DEFAULT_SOURCE}'.")
+            logger.warning(
+                f"Target source '{source}' differs from default '{DEFAULT_SOURCE}'."
+            )
             # For strict mode, we could raise an error here.
             # raise ValueError(f"Project Safety Guard: Cannot assign to external source '{source}'")
 
         # Auto-inject pipe instruction for AI context
         if "|" in prompt:
             prompt = "[SYSTEM: Treat '|' as a newline character.] " + prompt
-            
+
         payload = {
             "prompt": prompt,
             "title": title,
             "sourceContext": {
                 "source": source,
-                "githubRepoContext": {
-                    "startingBranch": starting_branch
-                }
+                "githubRepoContext": {"startingBranch": starting_branch},
             },
             "automationMode": automation_mode.value,
-            "requirePlanApproval": require_plan_approval
+            "requirePlanApproval": require_plan_approval,
         }
 
         logger.info(f"Creating Jules session: {title}")
         response = requests.post(
-            f"{JULES_API_BASE}/sessions",
-            headers=self.headers,
-            json=payload
+            f"{JULES_API_BASE}/sessions", headers=self.headers, json=payload
         )
         response.raise_for_status()
         data = response.json()
@@ -139,14 +138,13 @@ class JulesBridge:
             name=data["name"],
             title=data["title"],
             prompt=data["prompt"],
-            source=source
+            source=source,
         )
 
     def get_session(self, session_id: str, compact: bool = False) -> Dict[str, Any]:
         """Get details of a specific session. Use compact=True for minimal output."""
         response = requests.get(
-            f"{JULES_API_BASE}/sessions/{session_id}",
-            headers=self.headers
+            f"{JULES_API_BASE}/sessions/{session_id}", headers=self.headers
         )
         response.raise_for_status()
         data = response.json()
@@ -156,33 +154,44 @@ class JulesBridge:
                 "title": data.get("title"),
                 "state": data.get("state"),
                 "updateTime": data.get("updateTime"),
-                "pr_url": next((o["pullRequest"]["url"] for o in data.get("outputs", []) if "pullRequest" in o), None)
+                "pr_url": next(
+                    (
+                        o["pullRequest"]["url"]
+                        for o in data.get("outputs", [])
+                        if "pullRequest" in o
+                    ),
+                    None,
+                ),
             }
         return data
 
-    def list_sessions(self, page_size: int = 10, summary: bool = False) -> List[Dict[str, Any]]:
+    def list_sessions(
+        self, page_size: int = 10, summary: bool = False
+    ) -> List[Dict[str, Any]]:
         """List recent sessions. Use summary=True for minimal output."""
         response = requests.get(
             f"{JULES_API_BASE}/sessions",
             headers=self.headers,
-            params={"pageSize": page_size}
+            params={"pageSize": page_size},
         )
         response.raise_for_status()
         sessions = response.json().get("sessions", [])
         if summary:
-            return [{
-                "id": s.get("id"),
-                "title": s.get("title"),
-                "state": s.get("state"),
-                "updateTime": s.get("updateTime")
-            } for s in sessions]
+            return [
+                {
+                    "id": s.get("id"),
+                    "title": s.get("title"),
+                    "state": s.get("state"),
+                    "updateTime": s.get("updateTime"),
+                }
+                for s in sessions
+            ]
         return sessions
 
     def approve_plan(self, session_id: str) -> bool:
         """Approve the plan for a session that requires approval."""
         response = requests.post(
-            f"{JULES_API_BASE}/sessions/{session_id}:approvePlan",
-            headers=self.headers
+            f"{JULES_API_BASE}/sessions/{session_id}:approvePlan", headers=self.headers
         )
         response.raise_for_status()
         logger.info(f"Plan approved for session {session_id}")
@@ -190,7 +199,7 @@ class JulesBridge:
 
     def send_message(self, session_id: str, message: str) -> bool:
         """Send a follow-up message to an active session."""
-        
+
         # Auto-inject pipe instruction for AI context
         if "|" in message:
             message = "[SYSTEM: Treat '|' as a newline character.] " + message
@@ -199,18 +208,20 @@ class JulesBridge:
         response = requests.post(
             f"{JULES_API_BASE}/sessions/{session_id}:sendMessage",
             headers=self.headers,
-            json=payload
+            json=payload,
         )
         response.raise_for_status()
         logger.info(f"Message sent to session {session_id}")
         return True
 
-    def list_activities(self, session_id: str, page_size: int = 30) -> List[Dict[str, Any]]:
+    def list_activities(
+        self, session_id: str, page_size: int = 30
+    ) -> List[Dict[str, Any]]:
         """List activities in a session."""
         response = requests.get(
             f"{JULES_API_BASE}/sessions/{session_id}/activities",
             headers=self.headers,
-            params={"pageSize": page_size}
+            params={"pageSize": page_size},
         )
         response.raise_for_status()
         return response.json().get("activities", [])
@@ -224,20 +235,26 @@ class JulesBridge:
                 return output["pullRequest"].get("url")
         return None
 
-    def wait_for_agent_response(self, session_id: str, last_act_id: Optional[str] = None, timeout: int = 60) -> Optional[Dict[str, Any]]:
+    def wait_for_agent_response(
+        self, session_id: str, last_act_id: Optional[str] = None, timeout: int = 60
+    ) -> Optional[Dict[str, Any]]:
         """ë©”ì‹œì§€ ì „ì†¡ í›„ ì—ì´ì „íŠ¸ì˜ ì‘ë‹µ(Activity)ì´ ì˜¬ ë•Œê¹Œì§€ ëŒ€ê¸°"""
         import time
+
         start_time = time.time()
         logger.info(f"Waiting for agent response in session {session_id}...")
-        
+
         while time.time() - start_time < timeout:
             activities = self.list_activities(session_id, page_size=5)
             if activities:
                 latest = activities[0]
-                if latest.get("originator") == "agent" and latest.get("id") != last_act_id:
+                if (
+                    latest.get("originator") == "agent"
+                    and latest.get("id") != last_act_id
+                ):
                     return latest
             time.sleep(3)
-        
+
         logger.warning("Timed out waiting for agent response.")
         return None
 
@@ -247,28 +264,31 @@ class JulesBridge:
         Returns True if successful.
         """
         import subprocess
+
         print(f"[GIT] Syncing Git changes for task: {title}...")
         try:
             # Check if there are changes to commit
             status_result = subprocess.run(
                 ["git", "status", "--porcelain"],
-                capture_output=True, text=True, cwd=BASE_DIR
+                capture_output=True,
+                text=True,
+                cwd=BASE_DIR,
             )
             if status_result.stdout.strip():
                 # There are uncommitted changes
                 subprocess.run(["git", "add", "."], cwd=BASE_DIR, check=True)
                 subprocess.run(
                     ["git", "commit", "-m", f"chore: Pre-Jules dispatch for {title}"],
-                    cwd=BASE_DIR, check=True
+                    cwd=BASE_DIR,
+                    check=True,
                 )
                 print("   [x] Changes committed")
             else:
                 print("   [i] No uncommitted changes")
-            
+
             # Always push to ensure remote is up-to-date
             push_result = subprocess.run(
-                ["git", "push"],
-                capture_output=True, text=True, cwd=BASE_DIR
+                ["git", "push"], capture_output=True, text=True, cwd=BASE_DIR
             )
             if push_result.returncode == 0:
                 print("   [x] Pushed to remote")
@@ -290,28 +310,34 @@ class JulesBridge:
 
 REGISTRY_PATH = BASE_DIR / "communications" / "team_assignments.json"
 
+
 def _load_registry() -> Dict:
     if REGISTRY_PATH.exists():
-        with open(REGISTRY_PATH, 'r', encoding='utf-8') as f:
+        with open(REGISTRY_PATH, "r", encoding="utf-8") as f:
             return json.load(f)
-    return {"antigravity": {"project": DEFAULT_SOURCE.split('/')[-1], "active_sessions": {}}}
+    return {
+        "antigravity": {"project": DEFAULT_SOURCE.split("/")[-1], "active_sessions": {}}
+    }
+
 
 def _save_registry(data: Dict):
     REGISTRY_PATH.parent.mkdir(parents=True, exist_ok=True)
-    with open(REGISTRY_PATH, 'w', encoding='utf-8') as f:
+    with open(REGISTRY_PATH, "w", encoding="utf-8") as f:
         json.dump(data, f, indent=2, ensure_ascii=False)
 
+
 def register_session(session_id: str, title: str, prompt: str = ""):
     """ìƒˆ ì„¸ì…˜ì„ ë ˆì§€ìŠ¤íŠ¸ë¦¬ì— ë“±ë¡ (ì´ˆê¸° ë¯¸ì…˜ í¬í•¨)"""
     registry = _load_registry()
     registry.setdefault("antigravity", {}).setdefault("active_sessions", {})
     registry["antigravity"]["active_sessions"][session_id] = {
         "title": title,
-        "initial_mission": prompt
+        "initial_mission": prompt,
     }
     _save_registry(registry)
     logger.info(f"Session registered: {session_id} - {title}")
 
+
 def complete_session(session_id: str):
     """ì„¸ì…˜ì„ ì™„ë£Œ ìƒíƒœë¡œ ë§ˆí‚¹"""
     registry = _load_registry()
@@ -329,11 +355,13 @@ def complete_session(session_id: str):
         _save_registry(registry)
         logger.info(f"Session completed: {session_id}")
 
+
 def get_my_sessions() -> Dict[str, str]:
     """í˜„ì¬ ë‹´ë‹¹ ì„¸ì…˜ ëª©ë¡ ë°˜í™˜ (í† í° ì ˆì•½)"""
     registry = _load_registry()
     return registry.get("antigravity", {}).get("active_sessions", {})
 
+
 def archive_session(session_id: str):
     """ì™„ë£Œëœ ì„¸ì…˜ì„ ë ˆì§€ìŠ¤íŠ¸ë¦¬ì—ì„œ ì œê±°"""
     registry = _load_registry()
@@ -348,18 +376,17 @@ def archive_session(session_id: str):
 # Convenience Functions for Antigravity
 # =============================================================================
 
+
 def assign_task_to_jules(
-    task_description: str,
-    task_title: str,
-    work_order_path: Optional[str] = None
+    task_description: str, task_title: str, work_order_path: Optional[str] = None
 ) -> JulesSession:
     """
     Assign a task to Jules with optional work order context.
     """
     bridge = JulesBridge()
-    
+
     if work_order_path and os.path.exists(work_order_path):
-        with open(work_order_path, 'r', encoding='utf-8') as f:
+        with open(work_order_path, "r", encoding="utf-8") as f:
             work_order_content = f.read()
         full_prompt = f"""## Task
 {task_description}
@@ -382,11 +409,11 @@ def assign_task_to_jules(
 - Create tests for new functionality.
 - Run `pytest` before submitting.
 """
-    
+
     return bridge.create_session(
         prompt=full_prompt,
         title=task_title,
-        automation_mode=AutomationMode.AUTO_CREATE_PR
+        automation_mode=AutomationMode.AUTO_CREATE_PR,
     )
 
 
@@ -395,11 +422,11 @@ def check_jules_status(session_id: str) -> Dict[str, Any]:
     bridge = JulesBridge()
     session = bridge.get_session(session_id)
     activities = bridge.list_activities(session_id, page_size=5)
-    
+
     return {
         "session": session,
         "recent_activities": activities,
-        "pr_url": bridge.get_session_output(session_id)
+        "pr_url": bridge.get_session_output(session_id),
     }
 
 
@@ -409,7 +436,7 @@ def check_jules_status(session_id: str) -> Dict[str, Any]:
 
 if __name__ == "__main__":
     import sys
-    
+
     if len(sys.argv) < 2:
         print("Usage:")
         print("  python jules_bridge.py list-sources")
@@ -418,14 +445,14 @@ if __name__ == "__main__":
         print("  python jules_bridge.py sync-git <title>")
         print("  python jules_bridge.py status <session_id>")
         sys.exit(1)
-    
+
     command = sys.argv[1]
     bridge = JulesBridge()
-    
+
     if command == "list-sources":
         sources = bridge.list_sources()
         print(json.dumps(sources, indent=2))
-    
+
     elif command == "list-sessions":
         use_summary = "--summary" in sys.argv
         limit = 10
@@ -434,24 +461,24 @@ if __name__ == "__main__":
                 limit = int(arg.split("=")[1])
         sessions = bridge.list_sessions(page_size=limit, summary=use_summary)
         print(json.dumps(sessions, indent=2))
-    
+
     elif command == "create" and len(sys.argv) >= 4:
         title = sys.argv[2]
         prompt = sys.argv[3]
-        
+
         # Support for file input via --file or -f
         if (prompt == "--file" or prompt == "-f") and len(sys.argv) >= 5:
             file_path = Path(sys.argv[4])
             if file_path.exists():
-                with open(file_path, 'r', encoding='utf-8') as f:
+                with open(file_path, "r", encoding="utf-8") as f:
                     prompt = f.read()
             else:
                 print(f"âŒ Error: File not found: {file_path}")
                 sys.exit(1)
-        
+
         # Auto-sync Git
         bridge.sync_git(title)
-        
+
         session = bridge.create_session(prompt=prompt, title=title)
         register_session(session.id, title, prompt)  # ìë™ ë“±ë¡ (Prompt í¬í•¨)
         print(f"âœ… Session created: {session.id}")
@@ -461,13 +488,13 @@ if __name__ == "__main__":
     elif command == "sync-git" and len(sys.argv) >= 3:
         title = sys.argv[2]
         bridge.sync_git(title)
-    
+
     elif command == "status" and len(sys.argv) >= 3:
         session_id = sys.argv[2]
         verbose = "--verbose" in sys.argv
-        
+
         status = check_jules_status(session_id)
-        
+
         if verbose:
             print(json.dumps(status, indent=2, default=str))
         else:
@@ -475,13 +502,13 @@ if __name__ == "__main__":
             sess = status.get("session", {})
             acts = status.get("recent_activities", [])
             pr = status.get("pr_url")
-            
+
             print(f"\nğŸ“Š Session Status: {sess.get('title')}")
             print(f"ID: {sess.get('id')}")
             print(f"State: {sess.get('state')}")
             if pr:
                 print(f"ğŸ”— PR: {pr}")
-            
+
             print("\nğŸ“ Latest Activity:")
             if acts:
                 latest = acts[0]
@@ -497,51 +524,59 @@ if __name__ == "__main__":
     elif command == "send-message" and len(sys.argv) >= 4:
         session_id = sys.argv[2]
         message = sys.argv[3]
-        
+
         # Support for file input via --file or -f
         if (message == "--file" or message == "-f") and len(sys.argv) >= 5:
             file_path = Path(sys.argv[4])
             if file_path.exists():
-                with open(file_path, 'r', encoding='utf-8') as f:
+                with open(file_path, "r", encoding="utf-8") as f:
                     message = f.read()
             else:
                 print(f"âŒ Error: File not found: {file_path}")
                 sys.exit(1)
-        
+
         # Safety Check: Ensure we are not messaging a session from another project
         # (This relies on the registry or we could check session source if we fetched it)
-        # For now, we assume if you have the ID, you know what you are doing, 
+        # For now, we assume if you have the ID, you know what you are doing,
         # but let's at least warn if it's not in our local registry.
         registry = _load_registry()
         my_sessions = registry.get("antigravity", {}).get("active_sessions", {})
         if session_id not in my_sessions:
-            print(f"âš ï¸ Warning: Session {session_id} is not in your local active registry. Proceeding anyway...")
+            print(
+                f"âš ï¸ Warning: Session {session_id} is not in your local active registry. Proceeding anyway..."
+            )
 
         activities = bridge.list_activities(session_id, page_size=1)
         last_id = activities[0].get("id") if activities else None
-        
+
         success = bridge.send_message(session_id, message)
         print(f"Message sent successfully to {session_id}")
-        
+
         if "--wait" in sys.argv:
             response = bridge.wait_for_agent_response(session_id, last_act_id=last_id)
             if response:
                 print("\nğŸ¤– Jules Response:")
                 progress = response.get("progressUpdated", {})
                 print(f"Title: {progress.get('title')}")
-                desc = progress.get('description', '')
+                desc = progress.get("description", "")
                 if desc:
-                     print(f"Description: {desc[:500]}..." if len(desc) > 500 else f"Description: {desc}")
+                    print(
+                        f"Description: {desc[:500]}..."
+                        if len(desc) > 500
+                        else f"Description: {desc}"
+                    )
             else:
                 print("\nâ³ No immediate response from agent.")
 
     elif command == "activities" and len(sys.argv) >= 3:
         session_id = sys.argv[2]
-        page_size = int(sys.argv[3]) if len(sys.argv) >= 4 and sys.argv[3].isdigit() else 5
+        page_size = (
+            int(sys.argv[3]) if len(sys.argv) >= 4 and sys.argv[3].isdigit() else 5
+        )
         verbose = "--verbose" in sys.argv
-        
+
         activities = bridge.list_activities(session_id, page_size=page_size)
-        
+
         if verbose:
             print(json.dumps(activities, indent=2, default=str))
         else:
@@ -556,7 +591,7 @@ if __name__ == "__main__":
         session_id = sys.argv[2]
         success = bridge.approve_plan(session_id)
         print(f"Plan approved for {session_id}: {success}")
-    
+
     elif command == "my-sessions":
         sessions = get_my_sessions()
         print(f"\nğŸ—‚ï¸ Active Sessions ({len(sessions)}):")
@@ -570,7 +605,10 @@ if __name__ == "__main__":
                     info = bridge.get_session(sid, compact=True)
                     state = info.get("state", "UNKNOWN")
                     pr = info.get("pr_url", "")
-                    print(f"   ğŸ”„ {sid}: {title} [{state}]" + (f" -> PR: {pr}" if pr else ""))
+                    print(
+                        f"   ğŸ”„ {sid}: {title} [{state}]"
+                        + (f" -> PR: {pr}" if pr else "")
+                    )
                 except Exception:
                     print(f"   â“ {sid}: {title} [Fetch Failed]")
 
@@ -583,44 +621,48 @@ if __name__ == "__main__":
         session_id = sys.argv[2]
         archive_session(session_id)
         print(f"Session {session_id} archived")
-    
+
     elif command == "dashboard":
         limit = 15
         sessions = bridge.list_sessions(page_size=limit)
-        
+
         # Group sessions by project (source)
         projects = {}
         for s in sessions:
             # Active or recently updated sessions
             source_raw = s.get("sourceContext", {}).get("source", "Unknown/Unknown")
-            proj_name = source_raw.split('/')[-1]
-            
+            proj_name = source_raw.split("/")[-1]
+
             if proj_name not in projects:
                 projects[proj_name] = []
             projects[proj_name].append(s)
-            
+
         print("\nğŸ“Š Jules Fleet Project Dashboard")
         print("=" * 60)
-        
+
         if not projects:
             print("   (No active sessions found)")
-        
+
         for proj, sess_list in projects.items():
             print(f"\nğŸ“‚ Project: {proj}")
             for s in sess_list:
                 sid = s.get("id")
                 title = s.get("title", "Untitled Task")
                 state = s.get("state", "UNKNOWN")
-                
+
                 # Visual markers
                 icon = "   "
-                if state == "COMPLETED": icon = "âœ… "
-                elif state == "IN_PROGRESS": icon = "ğŸ”„ "
-                elif state == "PLANNING": icon = "ğŸ“‹ "
-                elif state == "FAILED": icon = "âŒ "
-                
+                if state == "COMPLETED":
+                    icon = "âœ… "
+                elif state == "IN_PROGRESS":
+                    icon = "ğŸ”„ "
+                elif state == "PLANNING":
+                    icon = "ğŸ“‹ "
+                elif state == "FAILED":
+                    icon = "âŒ "
+
                 print(f"{icon}{sid:<20} | {title[:50]:<50} [{state}]")
-        
+
         print("\n" + "=" * 60)
 
     else:
diff --git a/scripts/jules_monitor.py b/scripts/jules_monitor.py
index 6c54d02..ee6a770 100644
--- a/scripts/jules_monitor.py
+++ b/scripts/jules_monitor.py
@@ -27,6 +27,7 @@ from typing import Dict, List, Optional, Set
 # .env íŒŒì¼ ë¡œë“œ
 try:
     from dotenv import load_dotenv
+
     env_path = Path(__file__).parent.parent / ".env"
     load_dotenv(env_path)
 except ImportError:
@@ -38,6 +39,7 @@ from jules_bridge import JulesBridge, JULES_API_KEY
 # Windows í† ìŠ¤íŠ¸ ì•Œë¦¼
 try:
     from win10toast import ToastNotifier
+
     TOAST_AVAILABLE = True
 except ImportError:
     TOAST_AVAILABLE = False
@@ -46,7 +48,7 @@ except ImportError:
 
 class JulesMonitor:
     """Jules ì„¸ì…˜ ëª¨ë‹ˆí„°"""
-    
+
     def __init__(self, bridge: JulesBridge):
         self.bridge = bridge
         self.toaster = ToastNotifier() if TOAST_AVAILABLE else None
@@ -55,37 +57,37 @@ class JulesMonitor:
         self.known_activities: Dict[str, Set[str]] = {}  # session_id -> activity_ids
         self.log_file = Path(__file__).parent.parent / "logs" / "jules_monitor.log"
         self.log_file.parent.mkdir(exist_ok=True)
-    
+
     def log(self, message: str, level: str = "INFO"):
         """ë¡œê·¸ ê¸°ë¡"""
         timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
         log_line = f"[{timestamp}] [{level}] {message}"
         print(log_line)
-        
+
         with open(self.log_file, "a", encoding="utf-8") as f:
             f.write(log_line + "\n")
-    
+
     def notify(self, title: str, message: str, duration: int = 10):
         """Windows í† ìŠ¤íŠ¸ ì•Œë¦¼"""
         self.log(f"ğŸ“¢ NOTIFY: {title} - {message}")
-        
+
         if self.toaster:
             try:
                 self.toaster.show_toast(
                     title=f"ğŸ¤– Jules: {title}",
                     msg=message[:256],  # í† ìŠ¤íŠ¸ ë©”ì‹œì§€ ê¸¸ì´ ì œí•œ
                     duration=duration,
-                    threaded=True
+                    threaded=True,
                 )
             except Exception as e:
                 self.log(f"Toast error: {e}", "ERROR")
-    
+
     def check_sessions(self) -> List[Dict]:
         """ëª¨ë“  ì„¸ì…˜ ì²´í¬"""
         try:
             sessions = self.bridge.list_sessions(page_size=20)
             events = []
-            
+
             for session in sessions:
                 # í•„í„°ë§: 'economics' ì €ì¥ì†Œ ê´€ë ¨ ì„¸ì…˜ë§Œ ì²˜ë¦¬
                 source_name = session.get("sourceContext", {}).get("source", "")
@@ -94,17 +96,19 @@ class JulesMonitor:
 
                 session_id = session.get("id")
                 session_name = session.get("title", "Untitled")
-                
+
                 # ìƒˆ ì„¸ì…˜ ê°ì§€
                 if session_id not in self.known_sessions:
                     self.known_sessions.add(session_id)
                     self.known_activities[session_id] = set()
-                    events.append({
-                        "type": "NEW_SESSION",
-                        "session_id": session_id,
-                        "title": session_name
-                    })
-                
+                    events.append(
+                        {
+                            "type": "NEW_SESSION",
+                            "session_id": session_id,
+                            "title": session_name,
+                        }
+                    )
+
                 # PR ìƒì„± ê°ì§€
                 outputs = session.get("outputs", [])
                 for out in outputs:
@@ -112,109 +116,117 @@ class JulesMonitor:
                         pr_url = out["pullRequest"].get("url")
                         if pr_url and pr_url not in self.known_prs:
                             self.known_prs.add(pr_url)
-                            events.append({
-                                "type": "PR_CREATED",
-                                "session_id": session_id,
-                                "title": session_name,
-                                "pr_url": pr_url
-                            })
-                
+                            events.append(
+                                {
+                                    "type": "PR_CREATED",
+                                    "session_id": session_id,
+                                    "title": session_name,
+                                    "pr_url": pr_url,
+                                }
+                            )
+
                 # í™œë™ ì²´í¬ (ì§ˆë¬¸, ì™„ë£Œ ë“±)
                 activity_events = self.check_activities(session_id, session_name)
                 events.extend(activity_events)
-            
+
             return events
-            
+
         except Exception as e:
             self.log(f"Session check failed: {e}", "ERROR")
             return []
-    
+
     def check_activities(self, session_id: str, session_name: str) -> List[Dict]:
         """ì„¸ì…˜ì˜ í™œë™ ì²´í¬"""
         events = []
-        
+
         try:
             activities = self.bridge.list_activities(session_id, page_size=10)
-            
+
             for act in activities:
                 act_id = act.get("id")
                 if act_id in self.known_activities.get(session_id, set()):
                     continue
-                
+
                 self.known_activities.setdefault(session_id, set()).add(act_id)
-                
+
                 # ì„¸ì…˜ ì™„ë£Œ ê°ì§€
                 if "sessionCompleted" in act:
-                    events.append({
-                        "type": "SESSION_COMPLETED",
-                        "session_id": session_id,
-                        "title": session_name
-                    })
-                
+                    events.append(
+                        {
+                            "type": "SESSION_COMPLETED",
+                            "session_id": session_id,
+                            "title": session_name,
+                        }
+                    )
+
                 # ì§ˆë¬¸/í”¼ë“œë°± ìš”ì²­ ê°ì§€ (agentê°€ ë³´ë‚¸ ë©”ì‹œì§€ ì¤‘ íŠ¹ì • íŒ¨í„´)
                 if act.get("originator") == "agent":
                     progress = act.get("progressUpdated", {})
                     title = progress.get("title", "")
                     desc = progress.get("description", "")
-                    
+
                     # ì§ˆë¬¸ íŒ¨í„´ ê°ì§€
-                    question_keywords = ["question", "clarify", "confirm", "?", "ì§ˆë¬¸", "í™•ì¸"]
+                    question_keywords = [
+                        "question",
+                        "clarify",
+                        "confirm",
+                        "?",
+                        "ì§ˆë¬¸",
+                        "í™•ì¸",
+                    ]
                     if any(kw in (title + desc).lower() for kw in question_keywords):
-                        events.append({
-                            "type": "QUESTION",
-                            "session_id": session_id,
-                            "title": session_name,
-                            "message": title[:100]
-                        })
-                    
+                        events.append(
+                            {
+                                "type": "QUESTION",
+                                "session_id": session_id,
+                                "title": session_name,
+                                "message": title[:100],
+                            }
+                        )
+
                     # ì˜¤ë¥˜ ê°ì§€
-                    if "error" in (title + desc).lower() or "failed" in (title + desc).lower():
-                        events.append({
-                            "type": "ERROR",
-                            "session_id": session_id,
-                            "title": session_name,
-                            "message": title[:100]
-                        })
-        
+                    if (
+                        "error" in (title + desc).lower()
+                        or "failed" in (title + desc).lower()
+                    ):
+                        events.append(
+                            {
+                                "type": "ERROR",
+                                "session_id": session_id,
+                                "title": session_name,
+                                "message": title[:100],
+                            }
+                        )
+
         except Exception as e:
             self.log(f"Activity check failed for {session_id}: {e}", "ERROR")
-        
+
         return events
-    
+
     def process_events(self, events: List[Dict]):
         """ì´ë²¤íŠ¸ ì²˜ë¦¬ ë° ì•Œë¦¼"""
         for event in events:
             event_type = event.get("type")
             session_name = event.get("title", "Unknown")
-            
+
             if event_type == "NEW_SESSION":
                 self.log(f"ğŸ†• New session: {session_name}")
-            
+
             elif event_type == "PR_CREATED":
                 pr_url = event.get("pr_url")
-                self.notify(
-                    "PR ìƒì„±ë¨!",
-                    f"{session_name}\n{pr_url}"
-                )
-            
+                self.notify("PR ìƒì„±ë¨!", f"{session_name}\n{pr_url}")
+
             elif event_type == "SESSION_COMPLETED":
-                self.notify(
-                    "ì‘ì—… ì™„ë£Œ!",
-                    f"{session_name} ì„¸ì…˜ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤."
-                )
-            
+                self.notify("ì‘ì—… ì™„ë£Œ!", f"{session_name} ì„¸ì…˜ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")
+
             elif event_type == "QUESTION":
-                self.notify(
-                    "ì§ˆë¬¸ ìˆìŒ!",
-                    f"{session_name}: {event.get('message', '')}"
-                )
-            
+                self.notify("ì§ˆë¬¸ ìˆìŒ!", f"{session_name}: {event.get('message', '')}")
+
             elif event_type == "ERROR":
                 self.notify(
-                    "âš ï¸ ì˜¤ë¥˜ ë°œìƒ!",
-                    f"{session_name}: {event.get('message', '')}"
+                    "âš ï¸ ì˜¤ë¥˜ ë°œìƒ!", f"{session_name}: {event.get('message', '')}"
                 )
-    
+
     def run_once(self):
         """í•œ ë²ˆ ì²´í¬"""
         self.log("ğŸ” Checking Jules sessions...")
@@ -222,12 +234,12 @@ class JulesMonitor:
         self.process_events(events)
         self.log(f"âœ… Check complete. {len(events)} events found.")
         return events
-    
+
     def run_loop(self, interval: int = 300):
         """ì£¼ê¸°ì  ì²´í¬ ë£¨í”„"""
         self.log(f"ğŸš€ Starting Jules Monitor (interval: {interval}s)")
         self.log(f"ğŸ“ Log file: {self.log_file}")
-        
+
         # ì´ˆê¸° ìƒíƒœ ìˆ˜ì§‘ (ì•Œë¦¼ ì—†ì´)
         try:
             sessions = self.bridge.list_sessions(page_size=20)
@@ -235,12 +247,12 @@ class JulesMonitor:
                 sid = s.get("id")
                 self.known_sessions.add(sid)
                 self.known_activities[sid] = set()
-                
+
                 # ê¸°ì¡´ PR ìˆ˜ì§‘
                 for out in s.get("outputs", []):
                     if "pullRequest" in out:
                         self.known_prs.add(out["pullRequest"].get("url"))
-                
+
                 # ê¸°ì¡´ í™œë™ ìˆ˜ì§‘
                 try:
                     activities = self.bridge.list_activities(sid, page_size=50)
@@ -248,39 +260,41 @@ class JulesMonitor:
                         self.known_activities[sid].add(act.get("id"))
                 except:
                     pass
-            
-            self.log(f"ğŸ“Š Initial state: {len(self.known_sessions)} sessions, {len(self.known_prs)} PRs")
+
+            self.log(
+                f"ğŸ“Š Initial state: {len(self.known_sessions)} sessions, {len(self.known_prs)} PRs"
+            )
         except Exception as e:
             self.log(f"Initial state collection failed: {e}", "ERROR")
-        
+
         # ëª¨ë‹ˆí„°ë§ ë£¨í”„
         while True:
             try:
                 events = self.check_sessions()
                 self.process_events(events)
-                
+
                 if events:
                     self.log(f"ğŸ“¬ {len(events)} new events processed")
-                
+
             except KeyboardInterrupt:
                 self.log("ğŸ›‘ Monitor stopped by user")
                 break
             except Exception as e:
                 self.log(f"Monitor error: {e}", "ERROR")
-            
+
             time.sleep(interval)
-    
+
     def watch_session(self, session_id: str, interval: int = 30):
         """íŠ¹ì • ì„¸ì…˜ ì§‘ì¤‘ ê°ì‹œ"""
         self.log(f"ğŸ‘ï¸ Watching session: {session_id}")
-        
+
         self.known_activities[session_id] = set()
-        
+
         while True:
             try:
                 session = self.bridge.get_session(session_id)
                 session_name = session.get("title", "Unknown")
-                
+
                 # PR ì²´í¬
                 for out in session.get("outputs", []):
                     if "pullRequest" in out:
@@ -288,41 +302,43 @@ class JulesMonitor:
                         if pr_url and pr_url not in self.known_prs:
                             self.known_prs.add(pr_url)
                             self.notify("PR ìƒì„±ë¨!", f"{session_name}\n{pr_url}")
-                
+
                 # í™œë™ ì²´í¬
                 events = self.check_activities(session_id, session_name)
                 self.process_events(events)
-                
+
                 # ì™„ë£Œ ì²´í¬
                 for event in events:
                     if event.get("type") == "SESSION_COMPLETED":
                         self.log("âœ… Session completed. Stopping watch.")
                         return
-                
+
             except KeyboardInterrupt:
                 self.log("ğŸ›‘ Watch stopped by user")
                 break
             except Exception as e:
                 self.log(f"Watch error: {e}", "ERROR")
-            
+
             time.sleep(interval)
 
 
 def main():
     parser = argparse.ArgumentParser(description="Jules Session Monitor")
-    parser.add_argument("--interval", "-i", type=int, default=300, help="ì²´í¬ ê°„ê²© (ì´ˆ, ê¸°ë³¸: 300)")
+    parser.add_argument(
+        "--interval", "-i", type=int, default=300, help="ì²´í¬ ê°„ê²© (ì´ˆ, ê¸°ë³¸: 300)"
+    )
     parser.add_argument("--once", action="store_true", help="í•œ ë²ˆë§Œ ì²´í¬")
     parser.add_argument("--watch", "-w", help="íŠ¹ì • ì„¸ì…˜ ID ê°ì‹œ")
-    
+
     args = parser.parse_args()
-    
+
     if not JULES_API_KEY:
         print("âŒ Error: JULES_API_KEY í™˜ê²½ë³€ìˆ˜ë¥¼ ì„¤ì •í•´ì£¼ì„¸ìš”.")
         sys.exit(1)
-    
+
     bridge = JulesBridge(JULES_API_KEY)
     monitor = JulesMonitor(bridge)
-    
+
     if args.once:
         monitor.run_once()
     elif args.watch:
diff --git a/scripts/launcher.py b/scripts/launcher.py
index a6b8202..e06b5f0 100644
--- a/scripts/launcher.py
+++ b/scripts/launcher.py
@@ -7,6 +7,7 @@ from pathlib import Path
 BASE_DIR = Path(__file__).parent.parent
 REGISTRY_PATH = BASE_DIR / "design" / "command_registry.json"
 
+
 def load_registry():
     if not REGISTRY_PATH.exists():
         print(f"âŒ Registry not found at {REGISTRY_PATH}")
@@ -14,11 +15,19 @@ def load_registry():
     with open(REGISTRY_PATH, "r", encoding="utf-8") as f:
         return json.load(f)
 
+
 def run_command(cmd_list, capture_output=False):
     """Executes a command list securely."""
     print(f"ğŸš€ Executing: {' '.join(cmd_list)}")
     try:
-        result = subprocess.run(cmd_list, cwd=BASE_DIR, capture_output=capture_output, text=True, encoding='utf-8', shell=False)
+        result = subprocess.run(
+            cmd_list,
+            cwd=BASE_DIR,
+            capture_output=capture_output,
+            text=True,
+            encoding="utf-8",
+            shell=False,
+        )
         if result.returncode != 0:
             print(f"âŒ Command failed with return code {result.returncode}")
             if result.stderr:
@@ -28,6 +37,7 @@ def run_command(cmd_list, capture_output=False):
         print(f"âŒ Execution error: {e}")
         return None
 
+
 def run_gemini(args, registry):
     # HITL 2.0: Use the first arg as key if provided, e.g., 'gemini_v2'
     key = args[0] if args else "gemini"
@@ -35,7 +45,7 @@ def run_gemini(args, registry):
     if not data:
         print(f"âŒ Error: Key '{key}' not found in registry.")
         return
-    
+
     worker = data.get("worker", "spec")
     instruction = data.get("instruction", "").replace("\n", "|")
     context = data.get("context", [])
@@ -44,7 +54,12 @@ def run_gemini(args, registry):
     audit = data.get("audit", "")
     model = data.get("model", "")
 
-    cmd = [sys.executable, str(BASE_DIR / "scripts" / "gemini_worker.py"), worker, instruction]
+    cmd = [
+        sys.executable,
+        str(BASE_DIR / "scripts" / "gemini_worker.py"),
+        worker,
+        instruction,
+    ]
     if context:
         cmd.extend(["-c"] + context)
     if output:
@@ -53,9 +68,10 @@ def run_gemini(args, registry):
         cmd.extend(["-a", audit])
     if model:
         cmd.extend(["--model", model])
-    
+
     run_command(cmd)
 
+
 def run_jules(args, registry):
     # HITL 2.0: Use the first arg as key if provided, e.g., 'jules_economic'
     key = args[0] if args else "jules"
@@ -93,19 +109,21 @@ def run_jules(args, registry):
             print(f"âŒ Error: session_id is required for {command}")
             return
         cmd.append(session_id)
-    
+
     if wait:
         cmd.append("--wait")
-    
+
     # Redirect output for Jules as in the bat files
     output_log = BASE_DIR / "communications" / "jules_logs" / "last_run.md"
     output_log.parent.mkdir(parents=True, exist_ok=True)
-    
+
     print(f"ğŸš€ Executing Jules Bridge: {command}...")
     with open(output_log, "w", encoding="utf-8") as f:
         try:
             # We use subprocess.Popen or run with stdout redirection
-            result = subprocess.run(cmd, cwd=BASE_DIR, stdout=f, stderr=f, text=True, shell=True)
+            result = subprocess.run(
+                cmd, cwd=BASE_DIR, stdout=f, stderr=f, text=True, shell=True
+            )
             if result.returncode == 0:
                 print(f"âœ… Success! Log: {output_log}")
             else:
@@ -113,6 +131,7 @@ def run_jules(args, registry):
         except Exception as e:
             print(f"âŒ Error: {e}")
 
+
 def run_git_review(args, registry):
     key = args[0] if args else "git_review"
     data = registry.get(key, {})
@@ -125,51 +144,59 @@ def run_git_review(args, registry):
         instruction = data.get("instruction", "Analyze this PR.").replace("\n", "|")
 
     print(f"ğŸ” [Git-Review] Syncing and analyzing branch: {branch}")
-    
+
     # 1. Get latest commit
-    sync_cmd = [sys.executable, str(BASE_DIR / "scripts" / "git_sync_checker.py"), branch]
+    sync_cmd = [
+        sys.executable,
+        str(BASE_DIR / "scripts" / "git_sync_checker.py"),
+        branch,
+    ]
     res = run_command(sync_cmd, capture_output=True)
     if not res or not res.stdout.strip():
         print("âŒ Failed to get latest commit.")
         return
-    
-    commit_hash = res.stdout.strip().split('\n')[-1] # Take the last line
+
+    commit_hash = res.stdout.strip().split("\n")[-1]  # Take the last line
     print(f"ğŸ“ Target Commit: {commit_hash}")
 
     # 2. Generate Diff
-    short_name = branch.split('/')[-1]
+    short_name = branch.split("/")[-1]
     diff_file = BASE_DIR / "design" / "gemini_output" / f"pr_diff_{short_name}.txt"
     diff_file.parent.mkdir(parents=True, exist_ok=True)
-    
+
     print(f"ğŸ“ Generating diff for {branch}...")
     with open(diff_file, "w", encoding="utf-8") as f:
-        subprocess.run(["git", "diff", f"main..{commit_hash}"], cwd=BASE_DIR, stdout=f, shell=True)
+        subprocess.run(
+            ["git", "diff", f"main..{commit_hash}"], cwd=BASE_DIR, stdout=f, shell=True
+        )
 
     # 3. Gemini Review
     review_output = BASE_DIR / "design" / "gemini_output" / f"pr_review_{short_name}.md"
     gemini_cmd = [
-        sys.executable, 
-        str(BASE_DIR / "scripts" / "gemini_worker.py"), 
-        "git-review", 
-        instruction, 
-        "-c", str(diff_file)
+        sys.executable,
+        str(BASE_DIR / "scripts" / "gemini_worker.py"),
+        "git-review",
+        instruction,
+        "-c",
+        str(diff_file),
     ]
-    
+
     print("ğŸ§  Running AI Code Review...")
     with open(review_output, "w", encoding="utf-8") as f:
         subprocess.run(gemini_cmd, cwd=BASE_DIR, stdout=f, stderr=f, shell=True)
-    
+
     print(f"âœ… Review complete. Report: {review_output}")
 
+
 def run_merge(args, registry):
     key = args[0] if args else "merge"
     data = registry.get(key, {})
-    
+
     if not data and args:
         branch = args[0]
     else:
         branch = data.get("branch", "")
-        
+
     if not branch:
         print("âŒ Error: Branch name required for merge.")
         return
@@ -180,7 +207,7 @@ def run_merge(args, registry):
         ["git", "ls-remote", "--exit-code", "--heads", "origin", branch],
         ["git", "merge", f"origin/{branch}", "--no-edit"],
         ["git", "push", "origin", "main"],
-        ["git", "push", "origin", "--delete", branch]
+        ["git", "push", "origin", "--delete", branch],
     ]
 
     for cmd in commands:
@@ -190,10 +217,12 @@ def run_merge(args, registry):
             return
     print(f"âœ… Branch {branch} successfully merged and cleaned up.")
 
+
 def run_harvest(args, registry):
     cmd = [sys.executable, str(BASE_DIR / "scripts" / "report_harvester.py")]
     run_command(cmd)
 
+
 def main():
     if len(sys.argv) < 2:
         print("Usage: launcher.py <tool> [args...]")
@@ -207,7 +236,7 @@ def main():
         "jules": run_jules,
         "git-review": run_git_review,
         "merge": run_merge,
-        "harvest": run_harvest
+        "harvest": run_harvest,
     }
 
     if tool in dispatch:
@@ -218,5 +247,6 @@ def main():
         print(f"âŒ Unknown tool: {tool}")
         sys.exit(1)
 
+
 if __name__ == "__main__":
     main()
diff --git a/scripts/log_selector.py b/scripts/log_selector.py
index b6f78f4..89de4eb 100644
--- a/scripts/log_selector.py
+++ b/scripts/log_selector.py
@@ -24,7 +24,9 @@ def select_logs(
         if method_name is not None:
             filtered_df = filtered_df[filtered_df["method_name"] == method_name]
         if message_contains is not None:
-            filtered_df = filtered_df[filtered_df["message"].str.contains(message_contains, na=False)]
+            filtered_df = filtered_df[
+                filtered_df["message"].str.contains(message_contains, na=False)
+            ]
         if item_id is not None:
             filtered_df = filtered_df[filtered_df["item_id"] == item_id]
 
diff --git a/scripts/migrate_db.py b/scripts/migrate_db.py
index 9257de3..2c0e9a3 100644
--- a/scripts/migrate_db.py
+++ b/scripts/migrate_db.py
@@ -7,6 +7,7 @@ logger = logging.getLogger(__name__)
 
 DB_PATH = "simulation_data.db"
 
+
 def migrate():
     if not os.path.exists(DB_PATH):
         logger.error(f"Database file {DB_PATH} not found. Nothing to migrate.")
@@ -18,26 +19,33 @@ def migrate():
     # 1. Check agent_states table
     cursor.execute("PRAGMA table_info(agent_states)")
     columns = [row[1] for row in cursor.fetchall()]
-    
+
     if "education_xp" not in columns:
         logger.info("Adding 'education_xp' to 'agent_states'...")
-        cursor.execute("ALTER TABLE agent_states ADD COLUMN education_xp REAL DEFAULT 0.0")
-    
+        cursor.execute(
+            "ALTER TABLE agent_states ADD COLUMN education_xp REAL DEFAULT 0.0"
+        )
+
     if "generation" not in columns:
         logger.info("Adding 'generation' to 'agent_states'...")
-        cursor.execute("ALTER TABLE agent_states ADD COLUMN generation INTEGER DEFAULT 0")
+        cursor.execute(
+            "ALTER TABLE agent_states ADD COLUMN generation INTEGER DEFAULT 0"
+        )
 
     # 2. Check economic_indicators table
     cursor.execute("PRAGMA table_info(economic_indicators)")
     columns = [row[1] for row in cursor.fetchall()]
-    
+
     if "avg_survival_need" not in columns:
         logger.info("Adding 'avg_survival_need' to 'economic_indicators'...")
-        cursor.execute("ALTER TABLE economic_indicators ADD COLUMN avg_survival_need REAL DEFAULT 0.0")
+        cursor.execute(
+            "ALTER TABLE economic_indicators ADD COLUMN avg_survival_need REAL DEFAULT 0.0"
+        )
 
     conn.commit()
     conn.close()
     logger.info("Migration completed successfully.")
 
+
 if __name__ == "__main__":
     migrate()
diff --git a/scripts/observer/scan_codebase.py b/scripts/observer/scan_codebase.py
index d3272eb..7f99ab9 100644
--- a/scripts/observer/scan_codebase.py
+++ b/scripts/observer/scan_codebase.py
@@ -6,126 +6,139 @@ from collections import defaultdict
 import datetime
 
 # Configuration
-TARGET_EXTENSIONS = ['.py', '.tsx', '.ts', '.md']
-IGNORE_DIRS = ['venv', '__pycache__', '.git', 'node_modules', '.gemini', 'reports', 'design', 'observer']
-TAGS_TO_SCAN = ['TODO', 'FIXME', 'HACK', 'REVIEW', 'NOTE', 'XXX']
+TARGET_EXTENSIONS = [".py", ".tsx", ".ts", ".md"]
+IGNORE_DIRS = [
+    "venv",
+    "__pycache__",
+    ".git",
+    "node_modules",
+    ".gemini",
+    "reports",
+    "design",
+    "observer",
+]
+TAGS_TO_SCAN = ["TODO", "FIXME", "HACK", "REVIEW", "NOTE", "XXX"]
+
 
 def scan_file(filepath: str) -> Dict:
-    metrics: Dict[str, Any] = {
-        'lines': 0,
-        'tags': defaultdict(list),
-        'imports': []
-    }
-    
+    metrics: Dict[str, Any] = {"lines": 0, "tags": defaultdict(list), "imports": []}
+
     try:
-        with open(filepath, 'r', encoding='utf-8') as f:
+        with open(filepath, "r", encoding="utf-8") as f:
             lines = f.readlines()
-            metrics['lines'] = len(lines)
-            
+            metrics["lines"] = len(lines)
+
             for i, line in enumerate(lines):
                 # Tag Scanning
                 for tag in TAGS_TO_SCAN:
                     if tag in line:
                         clean_line = line.strip()[:100]  # Truncate for display
-                        metrics['tags'][tag].append((i + 1, clean_line))
-                
+                        metrics["tags"][tag].append((i + 1, clean_line))
+
                 # Import Scanning (Python Only for now)
-                if filepath.endswith('.py'):
-                    if line.strip().startswith('import ') or line.strip().startswith('from '):
-                        metrics['imports'].append(line.strip())
-                        
+                if filepath.endswith(".py"):
+                    if line.strip().startswith("import ") or line.strip().startswith(
+                        "from "
+                    ):
+                        metrics["imports"].append(line.strip())
+
     except Exception as e:
         print(f"Error scanning {filepath}: {e}")
-        
+
     return metrics
 
+
 def scan_directory(root_dir: str) -> Dict[str, Dict]:
     results = {}
-    
+
     for root, dirs, files in os.walk(root_dir):
         # Filter directories
         dirs[:] = [d for d in dirs if d not in IGNORE_DIRS]
-        
+
         for file in files:
             if any(file.endswith(ext) for ext in TARGET_EXTENSIONS):
                 filepath = os.path.join(root, file)
                 rel_path = os.path.relpath(filepath, root_dir)
                 results[rel_path] = scan_file(filepath)
-                
+
     return results
 
-def generate_report(results: Dict[str, Dict], output_format: str = 'markdown') -> str:
+
+def generate_report(results: Dict[str, Dict], output_format: str = "markdown") -> str:
     total_files = len(results)
-    total_lines = sum(r['lines'] for r in results.values())
+    total_lines = sum(r["lines"] for r in results.values())
     total_tags: Dict[str, int] = defaultdict(int)
     tag_locations = defaultdict(list)
-    
+
     # Complexity Analysis
     complex_files = sorted(
-        [(k, v['lines']) for k, v in results.items()], 
-        key=lambda x: x[1], 
-        reverse=True
+        [(k, v["lines"]) for k, v in results.items()], key=lambda x: x[1], reverse=True
     )[:10]
-    
+
     # Tag Aggregation
     for fpath, data in results.items():
-        for tag, items in data['tags'].items():
+        for tag, items in data["tags"].items():
             total_tags[tag] += len(items)
             for lineno, content in items:
                 tag_locations[tag].append((fpath, lineno, content))
 
     report = []
     timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
-    
+
     report.append(f"# ğŸ•µï¸ Observer Scan Report")
     report.append(f"**Date:** {timestamp}")
     report.append(f"**Total Files:** {total_files}")
     report.append(f"**Total Lines:** {total_lines}")
     report.append("")
-    
+
     report.append("## 1. ğŸ—ï¸ Complexity Watchlist (Top 10 Big Files)")
     report.append("| File | Lines | Status |")
     report.append("|---|---|---|")
     for fpath, lines in complex_files:
-        status = "ğŸ”´ Critical" if lines > 800 else "ğŸŸ¡ Warning" if lines > 400 else "ğŸŸ¢ Safe"
+        status = (
+            "ğŸ”´ Critical" if lines > 800 else "ğŸŸ¡ Warning" if lines > 400 else "ğŸŸ¢ Safe"
+        )
         report.append(f"| `{fpath}` | {lines} | {status} |")
     report.append("")
-    
+
     report.append("## 2. ğŸ·ï¸ Tech Debt Tags")
     report.append("| Tag | Count | Description |")
     report.append("|---|---|---|")
     for tag in TAGS_TO_SCAN:
         count = total_tags[tag]
-        desc = "Action Required" if tag in ['FIXME', 'XXX'] else "Review Needed"
+        desc = "Action Required" if tag in ["FIXME", "XXX"] else "Review Needed"
         report.append(f"| **{tag}** | {count} | {desc} |")
     report.append("")
-    
+
     report.append("### Critical Fixes (FIXME/XXX)")
-    critical_tags = tag_locations.get('FIXME', []) + tag_locations.get('XXX', [])
+    critical_tags = tag_locations.get("FIXME", []) + tag_locations.get("XXX", [])
     if not critical_tags:
         report.append("No critical tags found. Great job! ğŸ‰")
     else:
-        for fpath, lineno, content in critical_tags[:20]: # Limit to 20
+        for fpath, lineno, content in critical_tags[:20]:  # Limit to 20
             report.append(f"- [ ] `{fpath}:{lineno}` - {content}")
-    
+
     if len(critical_tags) > 20:
         report.append(f"... and {len(critical_tags) - 20} more.")
-        
+
     return "\n".join(report)
 
+
 if __name__ == "__main__":
     parser = argparse.ArgumentParser(description="Observer Codebase Scanner")
     parser.add_argument("--root", default=".", help="Root directory to scan")
-    parser.add_argument("--output", default="reports/observer_scan.md", help="Output report file")
-    
+    parser.add_argument(
+        "--output", default="reports/observer_scan.md", help="Output report file"
+    )
+
     args = parser.parse_args()
-    
+
     print(f"Scanning codebase at {args.root}...")
     scan_results = scan_directory(args.root)
     report_content = generate_report(scan_results)
-    
+
     os.makedirs(os.path.dirname(args.output), exist_ok=True)
     with open(args.output, "w", encoding="utf-8") as f:
         f.write(report_content)
-        
+
     print(f"Scan complete. Report generated at {args.output}")
diff --git a/scripts/operation_darwin.py b/scripts/operation_darwin.py
index c6871a0..5782425 100644
--- a/scripts/operation_darwin.py
+++ b/scripts/operation_darwin.py
@@ -13,7 +13,7 @@ from main import create_simulation
 import config
 
 # Configure Logger
-logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')
+logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")
 logger = logging.getLogger("OperationDarwin")
 
 # Capture logs to string buffer for analysis
@@ -22,6 +22,7 @@ ch = logging.StreamHandler(log_capture_string)
 ch.setLevel(logging.INFO)
 logging.getLogger().addHandler(ch)
 
+
 def run_test(name, ticks, overrides):
     print(f"\n[Operation Darwin] Running {name} Test ({ticks} ticks)...")
 
@@ -41,20 +42,25 @@ def run_test(name, ticks, overrides):
     except Exception as e:
         print(f"CRITICAL ERROR in {name}: {e}")
         import traceback
+
         traceback.print_exc()
 
     # Capture final metrics
     logs = log_capture_string.getvalue()
     metrics = {
         "GDP": sim.tracker.get_latest_indicators().get("total_production", 0),
-        "MoneyDeltaMax": 0.0
+        "MoneyDeltaMax": 0.0,
     }
 
     # Analyze logs
     mitosis_count = logs.count("MITOSIS")
     death_count = logs.count("HOUSEHOLD_INACTIVE")
     spending_rejected_count = logs.count("SPENDING_REJECTED")
-    money_warnings = [line for line in logs.split('\n') if "MONEY_SUPPLY_CHECK" in line and "WARNING" in line]
+    money_warnings = [
+        line
+        for line in logs.split("\n")
+        if "MONEY_SUPPLY_CHECK" in line and "WARNING" in line
+    ]
 
     metrics["MitosisCount"] = mitosis_count
     metrics["DeathCount"] = death_count
@@ -64,6 +70,7 @@ def run_test(name, ticks, overrides):
     sim.repository.close()
     return metrics, logs
 
+
 def operation_darwin():
     print("=== Operation Darwin: Survival of the Fittest Verification ===")
 
@@ -74,7 +81,7 @@ def operation_darwin():
     # We might increase population to ensure interaction? Default is 20.
     overrides = {
         "SIMULATION_TICKS": 1000,
-        "UNEMPLOYMENT_BENEFIT_RATIO": 0.0 # Force override just in case, though file edit should handle it
+        "UNEMPLOYMENT_BENEFIT_RATIO": 0.0,  # Force override just in case, though file edit should handle it
     }
 
     # --- Test 1: Short Test (100 Ticks) - Money Integrity ---
@@ -86,7 +93,7 @@ def operation_darwin():
     else:
         print(f"âŒ FAIL: Money Warnings Detected: {metrics_short['MoneyWarnings']}")
         # Print first few warnings
-        for line in logs_short.split('\n'):
+        for line in logs_short.split("\n"):
             if "MONEY_SUPPLY_CHECK" in line and "WARNING" in line:
                 print(f"   -> {line}")
                 break
@@ -104,19 +111,27 @@ def operation_darwin():
 
     # 2. Mitosis > 0
     if metrics_full["MitosisCount"] > 0:
-        print(f"âœ… PASS: Evolution Occurred (Mitosis Count: {metrics_full['MitosisCount']})")
+        print(
+            f"âœ… PASS: Evolution Occurred (Mitosis Count: {metrics_full['MitosisCount']})"
+        )
     else:
-        print("âš ï¸ WARNING: No Mitosis detected. (Rich households might not be rich enough?)")
+        print(
+            "âš ï¸ WARNING: No Mitosis detected. (Rich households might not be rich enough?)"
+        )
 
     # 3. Death > 0 (Natural Selection)
     if metrics_full["DeathCount"] > 0:
-        print(f"âœ… PASS: Natural Selection Active (Death Count: {metrics_full['DeathCount']})")
+        print(
+            f"âœ… PASS: Natural Selection Active (Death Count: {metrics_full['DeathCount']})"
+        )
     else:
         print("âš ï¸ WARNING: No Deaths detected. (Starvation condition not met?)")
 
     # 4. Spending Rejected (Hard Stop Verification)
     if metrics_full["SpendingRejected"] > 0:
-        print(f"âœ… PASS: Hard Budget Constraint Active (Rejections: {metrics_full['SpendingRejected']})")
+        print(
+            f"âœ… PASS: Hard Budget Constraint Active (Rejections: {metrics_full['SpendingRejected']})"
+        )
     else:
         print("â„¹ï¸ INFO: No Spending Rejected. (Government was solvent throughout?)")
 
@@ -125,13 +140,13 @@ def operation_darwin():
 Operation Darwin Verification Report
 ====================================
 Short Test (100 Ticks):
-- Money Warnings: {metrics_short['MoneyWarnings']}
+- Money Warnings: {metrics_short["MoneyWarnings"]}
 
 Full Test (1000 Ticks):
-- Final GDP: {metrics_full['GDP']:.2f}
-- Mitosis Events: {metrics_full['MitosisCount']}
-- Death Events: {metrics_full['DeathCount']}
-- Government Spending Rejections: {metrics_full['SpendingRejected']}
+- Final GDP: {metrics_full["GDP"]:.2f}
+- Mitosis Events: {metrics_full["MitosisCount"]}
+- Death Events: {metrics_full["DeathCount"]}
+- Government Spending Rejections: {metrics_full["SpendingRejected"]}
     """
 
     os.makedirs("reports", exist_ok=True)
@@ -139,5 +154,6 @@ Full Test (1000 Ticks):
         f.write(report)
     print("\nReport saved to reports/darwin_report.txt")
 
+
 if __name__ == "__main__":
     operation_darwin()
diff --git a/scripts/operation_forensics.py b/scripts/operation_forensics.py
index fd9e5b6..d5a716e 100644
--- a/scripts/operation_forensics.py
+++ b/scripts/operation_forensics.py
@@ -12,6 +12,7 @@ from main import create_simulation
 from utils.logging_manager import setup_logging
 import config
 
+
 # --- Forensic Log Handler ---
 class ForensicLogHandler(logging.Handler):
     def __init__(self):
@@ -25,30 +26,38 @@ class ForensicLogHandler(logging.Handler):
         self.all_records.append(record.__dict__)
 
         # Specific capturing for forensics
-        if hasattr(record, "agent_id") and hasattr(record, "cause") and record.cause == "starvation":
-             if hasattr(record, "food_inventory"): # Check for forensic fields
-                 data = {
-                     "tick": getattr(record, "tick", 0),
-                     "agent_id": record.agent_id,
-                     "cash_at_death": getattr(record, "cash_at_death", 0.0),
-                     "food_inventory": getattr(record, "food_inventory", 0.0),
-                     "market_food_price": getattr(record, "market_food_price", None),
-                     "last_labor_offer_tick": getattr(record, "last_labor_offer_tick", 0),
-                     "job_vacancies_available": getattr(record, "job_vacancies_available", 0)
-                 }
-                 self.death_records.append(data)
-        
+        if (
+            hasattr(record, "agent_id")
+            and hasattr(record, "cause")
+            and record.cause == "starvation"
+        ):
+            if hasattr(record, "food_inventory"):  # Check for forensic fields
+                data = {
+                    "tick": getattr(record, "tick", 0),
+                    "agent_id": record.agent_id,
+                    "cash_at_death": getattr(record, "cash_at_death", 0.0),
+                    "food_inventory": getattr(record, "food_inventory", 0.0),
+                    "market_food_price": getattr(record, "market_food_price", None),
+                    "last_labor_offer_tick": getattr(
+                        record, "last_labor_offer_tick", 0
+                    ),
+                    "job_vacancies_available": getattr(
+                        record, "job_vacancies_available", 0
+                    ),
+                }
+                self.death_records.append(data)
+
         if "STIMULUS_TRIGGERED" in record.getMessage():
-             self.stimulus_records.append({
-                 "tick": getattr(record, "tick", 0),
-                 "message": record.getMessage()
-             })
+            self.stimulus_records.append(
+                {"tick": getattr(record, "tick", 0), "message": record.getMessage()}
+            )
+
 
 def run_forensic_investigation():
     # 1. Setup Logging
     # [FIX: WO-Diag-003] setup_logging first to avoid clearing handlers
     setup_logging()
-    
+
     forensic_handler = ForensicLogHandler()
     # Attach to root and simulation loggers explicitly due to propagate=False
     logging.getLogger().addHandler(forensic_handler)
@@ -57,24 +66,27 @@ def run_forensic_investigation():
 
     # 2. Run Simulation (STRESS TEST MODE)
     print("Initializing Operation Forensics Simulation (STRESS TEST: Asset=50.0)...")
-    
+
     # [CRITICAL] Runtime Config Override for Stress Test
-    config.INITIAL_HOUSEHOLD_ASSETS_MEAN = 50.0 
-    
+    config.INITIAL_HOUSEHOLD_ASSETS_MEAN = 50.0
+
     sim = create_simulation()
 
     try:
         for i in range(500):
             sim.run_tick()
-            if (i+1) % 50 == 0:
-                print(f"Tick {i+1}/500 complete...")
+            if (i + 1) % 50 == 0:
+                print(f"Tick {i + 1}/500 complete...")
     except Exception as e:
         print(f"Simulation crashed at tick {sim.time}: {e}")
         import traceback
+
         traceback.print_exc()
 
     # 3. Analyze Results
-    print(f"\nSimulation Complete. Analyzing {len(forensic_handler.death_records)} deaths...")
+    print(
+        f"\nSimulation Complete. Analyzing {len(forensic_handler.death_records)} deaths..."
+    )
 
     type_a_count = 0
     type_b_count = 0
@@ -102,10 +114,10 @@ def run_forensic_investigation():
         # Classification Logic (Priority: A -> B -> C -> D)
         is_type_a = vacancies == 0
         is_type_b = (death_tick - last_offer) > 10
-        
+
         price_val = price if price is not None else 999999.0
-        is_type_c = (cash >= price_val)
-        is_type_d = (cash < price_val)
+        is_type_c = cash >= price_val
+        is_type_d = cash < price_val
 
         assigned_type = "Unknown"
 
@@ -125,16 +137,26 @@ def run_forensic_investigation():
             assigned_type = "Unclassified"
 
         # Collect sample cases (first 5 of each type)
-        if len(sample_cases) < 15: 
-            sample_cases.append(f"- **{assigned_type}** | Agent #{record['agent_id']} | Tick: {death_tick} | Cash: {cash:.2f} | Vacancies: {vacancies} | Last Offer: {last_offer} | Price: {price}")
+        if len(sample_cases) < 15:
+            sample_cases.append(
+                f"- **{assigned_type}** | Agent #{record['agent_id']} | Tick: {death_tick} | Cash: {cash:.2f} | Vacancies: {vacancies} | Last Offer: {last_offer} | Price: {price}"
+            )
 
     total = len(unique_deaths)
     if total > 0:
         report_lines.append("## Classification Summary")
-        report_lines.append(f"- **Type A (No Jobs)**: {type_a_count} ({type_a_count/total:.1%})")
-        report_lines.append(f"- **Type B (Won't Work)**: {type_b_count} ({type_b_count/total:.1%})")
-        report_lines.append(f"- **Type C (Won't Eat)**: {type_c_count} ({type_c_count/total:.1%})")
-        report_lines.append(f"- **Type D (Poverty)**: {type_d_count} ({type_d_count/total:.1%})")
+        report_lines.append(
+            f"- **Type A (No Jobs)**: {type_a_count} ({type_a_count / total:.1%})"
+        )
+        report_lines.append(
+            f"- **Type B (Won't Work)**: {type_b_count} ({type_b_count / total:.1%})"
+        )
+        report_lines.append(
+            f"- **Type C (Won't Eat)**: {type_c_count} ({type_c_count / total:.1%})"
+        )
+        report_lines.append(
+            f"- **Type D (Poverty)**: {type_d_count} ({type_d_count / total:.1%})"
+        )
     else:
         report_lines.append("## Classification Summary")
         report_lines.append("- No deaths recorded.")
@@ -152,5 +174,6 @@ def run_forensic_investigation():
     print("\n".join(report_lines))
     print(f"\nReport saved to reports/AUTOPSY_REPORT.md")
 
+
 if __name__ == "__main__":
     run_forensic_investigation()
diff --git a/scripts/operation_heartbeat.py b/scripts/operation_heartbeat.py
index 692d3d4..0ac2b8a 100644
--- a/scripts/operation_heartbeat.py
+++ b/scripts/operation_heartbeat.py
@@ -14,42 +14,43 @@ import config
 # Configure Logger to silence standard info logs during 2000 ticks (too noisy)
 logging.basicConfig(level=logging.WARNING)
 
+
 def operation_heartbeat():
     print("ğŸš€ Operation Heartbeat: Initiating Grand Simulation (2000 Ticks)...")
-    
+
     # 1. Configuration Override
     overrides = {
         "SIMULATION_TICKS": 2000,
-        "NUM_HOUSEHOLDS": 20, # Keep manageable
+        "NUM_HOUSEHOLDS": 20,  # Keep manageable
         "NUM_FIRMS": 5,
         "INITIAL_BASE_ANNUAL_RATE": 0.05,
     }
-    
+
     # 2. Initialize Simulation
     sim = create_simulation(overrides=overrides)
-    
+
     # 3. Execution Loop with Telemetry
     records = []
     print("â¤ï¸ Pulse check started...")
-    
-    metrics = {
-        "prev_price": 10.0
-    }
+
+    metrics = {"prev_price": 10.0}
 
     try:
         for tick in range(1, 2001):
             sim.run_tick()
-            
+
             # Telemetry Extraction
             indicators = sim.tracker.get_latest_indicators()
             current_price = indicators.get("avg_goods_price", 10.0)
-            
+
             # Calculate Period Inflation
             inflation = 0.0
             if metrics["prev_price"] > 0:
-                inflation = (current_price - metrics["prev_price"]) / metrics["prev_price"]
+                inflation = (current_price - metrics["prev_price"]) / metrics[
+                    "prev_price"
+                ]
             metrics["prev_price"] = current_price
-            
+
             # Household Savings Rate Estimate
             total_income = 0.0
             total_consumption = 0.0
@@ -59,11 +60,11 @@ def operation_heartbeat():
                     total_income += h.current_wage
                     total_consumption += h.current_consumption
                     active_households += 1
-            
+
             savings_rate = 0.0
             if total_income > 0:
                 savings_rate = (total_income - total_consumption) / total_income
-                
+
             record = {
                 "Tick": tick,
                 "BaseRate": sim.bank.base_rate,
@@ -74,36 +75,40 @@ def operation_heartbeat():
                 "ActiveHouseholds": active_households,
                 "SavingsRate": savings_rate,
                 "Unemployment": indicators.get("unemployment_rate", 0),
-                "ApprovalRating": sim.government.average_approval_rating
+                "ApprovalRating": sim.government.average_approval_rating,
             }
             records.append(record)
-            
+
             if tick % 100 == 0:
-                print(f"   Tick {tick}: GDP={record['GDP']:.1f}, Rate={record['BaseRate']:.2%}, Firms={record['ActiveFirms']}")
-                
+                print(
+                    f"   Tick {tick}: GDP={record['GDP']:.1f}, Rate={record['BaseRate']:.2%}, Firms={record['ActiveFirms']}"
+                )
+
     except KeyboardInterrupt:
         print("\nâš ï¸ Simulation interrupted by user.")
     except Exception as e:
         print(f"\nâŒ CRITICAL ERROR: {e}")
         import traceback
+
         traceback.print_exc()
     finally:
         sim.repository.close()
-        
+
     # 4. Export Report
     df = pd.DataFrame(records)
     output_path = "simulation_results/final_report.csv"
     os.makedirs("simulation_results", exist_ok=True)
     df.to_csv(output_path, index=False)
     print(f"\nğŸ“„ Report saved to {output_path}")
-    
+
     # 5. Automated Analysis
     analyze_results(df)
 
+
 def analyze_results(df):
     print("\nğŸ” DIAGNOSTIC REPORT")
     print("-" * 50)
-    
+
     # A. The Pulse (Volatility)
     gdp = df["GDP"]
     gdp_std = gdp.std()
@@ -123,17 +128,17 @@ def analyze_results(df):
     print(f"\n2. THE INTERVENTION (Monetary Policy)")
     print(f"   - Rate Volatility: {rate_std:.4f}")
     if rate_std > 0.0001:
-         print("   âœ… PASS: Central Bank is active.")
+        print("   âœ… PASS: Central Bank is active.")
     else:
-         print("   FAIL: Central Bank is asleep (Flat rate).")
-         
+        print("   FAIL: Central Bank is asleep (Flat rate).")
+
     # Check Savings Response
     # Correlation between SavingsRate and Real Rate (Rate - Inflation)
     # df["RealRate"] = df["BaseRate"] - df["Inflation"] # Period inflation mismatch
     # Just check if SavingsRate varies
     savings_std = df["SavingsRate"].std()
     print(f"   - Savings Volatility: {savings_std:.4f}")
-    
+
     # C. The Metabolism (Firms)
     firms_start = df["ActiveFirms"].iloc[0]
     firms_end = df["ActiveFirms"].iloc[-1]
@@ -148,5 +153,6 @@ def analyze_results(df):
     print("-" * 50)
     print("End of Report.")
 
+
 if __name__ == "__main__":
     operation_heartbeat()
diff --git a/scripts/operation_trinity.py b/scripts/operation_trinity.py
index c667ce5..ea750c1 100644
--- a/scripts/operation_trinity.py
+++ b/scripts/operation_trinity.py
@@ -12,11 +12,14 @@ from main import create_simulation
 import config
 
 # Configure Logger to INFO level for higher visibility as requested
-logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')
+logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")
+
 
 def operation_trinity():
-    print("[Operation Trinity]: Initiating Grand Adaptive Interaction Test (2000 Ticks)...")
-    
+    print(
+        "[Operation Trinity]: Initiating Grand Adaptive Interaction Test (2000 Ticks)..."
+    )
+
     # 1. Configuration Override
     overrides = {
         "SIMULATION_TICKS": 2000,
@@ -24,48 +27,56 @@ def operation_trinity():
         "NUM_FIRMS": 10,  # Increased for corporate life cycle monitoring
         "INITIAL_BASE_ANNUAL_RATE": 0.05,
         "TAX_RATE_BASE": 0.10,
-        "DEBT_CEILING_RATIO": 1.5, # Slightly higher as per Architect's Criteria
+        "DEBT_CEILING_RATIO": 1.5,  # Slightly higher as per Architect's Criteria
     }
-    
+
     # 2. Initialize Simulation
     sim = create_simulation(overrides=overrides)
-    
+
     # 3. Execution Loop with Enhanced Telemetry
     records = []
     print("Monitoring 3-Agent Adaptivity...")
-    
-    prev_metrics = {
-        "prev_avg_price": 10.0
-    }
+
+    prev_metrics = {"prev_avg_price": 10.0}
 
     try:
         for tick in range(1, 2001):
             sim.run_tick()
-            
+
             # Telemetry Extraction
             indicators = sim.tracker.get_latest_indicators()
             current_price = indicators.get("avg_goods_price", 10.0)
-            
+
             # Inflation
             inflation = 0.0
             if prev_metrics["prev_avg_price"] > 0:
-                inflation = (current_price - prev_metrics["prev_avg_price"]) / prev_metrics["prev_avg_price"]
+                inflation = (
+                    current_price - prev_metrics["prev_avg_price"]
+                ) / prev_metrics["prev_avg_price"]
             prev_metrics["prev_avg_price"] = current_price
-            
+
             # Firm Metrics (Averaged)
             active_firms = [f for f in sim.firms if f.is_active]
-            avg_marketing_rate = np.mean([f.marketing_budget_rate for f in active_firms]) if active_firms else 0
+            avg_marketing_rate = (
+                np.mean([f.marketing_budget_rate for f in active_firms])
+                if active_firms
+                else 0
+            )
             total_revenue = sum([f.revenue_this_turn for f in active_firms])
-            
+
             # Government Metrics
             gov = sim.government
             debt_ratio = gov.total_debt / max(gov.potential_gdp, 1.0)
-            
+
             # Household Metrics
             active_households = [h for h in sim.households if h.is_active]
             # Fix: consumption_aggressiveness is internal state. Use current_consumption instead.
-            avg_consumption = np.mean([h.current_consumption for h in active_households]) if active_households else 0
-            
+            avg_consumption = (
+                np.mean([h.current_consumption for h in active_households])
+                if active_households
+                else 0
+            )
+
             record = {
                 "Tick": tick,
                 "GDP": indicators.get("total_production", 0),
@@ -80,40 +91,46 @@ def operation_trinity():
                 "TotalRevenue": total_revenue,
                 "AvgConsumption": avg_consumption,
                 "Unemployment": indicators.get("unemployment_rate", 0),
-                "ApprovalRating": gov.average_approval_rating
+                "ApprovalRating": gov.average_approval_rating,
             }
             records.append(record)
-            
+
             if tick % 100 == 0:
-                print(f"   Tick {tick:4}: GDP={record['GDP']:5.1f} | Tax={record['TaxRate']:4.1%} | Debt/GDP={record['DebtRatio']:4.2f} | Firms={record['ActiveFirms']}")
-                
+                print(
+                    f"   Tick {tick:4}: GDP={record['GDP']:5.1f} | Tax={record['TaxRate']:4.1%} | Debt/GDP={record['DebtRatio']:4.2f} | Firms={record['ActiveFirms']}"
+                )
+
     except Exception as e:
         print(f"\nCRITICAL ERROR: {e}")
         import traceback
+
         traceback.print_exc()
     finally:
         sim.repository.close()
-        
+
     # 4. Export Report
     df = pd.DataFrame(records)
     output_path = "simulation_results/trinity_report.csv"
     os.makedirs("simulation_results", exist_ok=True)
     df.to_csv(output_path, index=False)
     print(f"\nReport saved to {output_path}")
-    
+
     # 5. Automated Analysis against Success Criteria
     analyze_trinity(df)
 
+
 def analyze_trinity(df):
     print("\nDIAGNOSTIC REPORT: OPERATION TRINITY")
     print("=" * 60)
-    
+
     # 1. Government (Counter-cyclicality)
     # Correlation between GDP Growth and TaxRate
-    df['GDP_Growth'] = df['GDP'].pct_change()
-    corr_gdp_tax = df['GDP_Growth'].corr(df['TaxRate'])
+    df["GDP_Growth"] = df["GDP"].pct_change()
+    corr_gdp_tax = df["GDP_Growth"].corr(df["TaxRate"])
     print(f"1. GOVERNMENT ADAPTIVITY (Fiscal)")
-    print(f"   - GDP-Tax Correlation: {corr_gdp_tax:.4f} (Expected Positive for Pro-cyclical, Negative/Zero for Counter-cyclical)")
+    print(
+        f"   - GDP-Tax Correlation: {corr_gdp_tax:.4f} (Expected Positive for Pro-cyclical, Negative/Zero for Counter-cyclical)"
+    )
     # Actually, if GDP growth is high, we want TaxRate to increase (Counter-cyclical) -> Positive Correlation
     # Wait, Stance = -OutputGap. OutputGap high -> Stance negative -> TaxRate = Base * (1 - Stance) = Base * (1 + |Stance|) -> TaxRate high.
     # So Positive Correlation is CORRECT for counter-cyclical tax policy.
@@ -132,9 +149,9 @@ def analyze_trinity(df):
         print("   âœ… PASS: Corporate ecosystem is stable.")
     else:
         print("   âŒ FAIL: Mass extinction detected.")
-        
+
     # Marketing ROI Correlation (Revenue vs MarketingRate)
-    corr_rev_mkt = df['TotalRevenue'].corr(df['AvgMarketingRate'])
+    corr_rev_mkt = df["TotalRevenue"].corr(df["AvgMarketingRate"])
     print(f"   - Revenue-Marketing Correlation: {corr_rev_mkt:.4f}")
     if corr_rev_mkt > 0.2:
         print("   âœ… PASS: Marketing spend is responsive to revenue.")
@@ -158,5 +175,6 @@ def analyze_trinity(df):
     print("=" * 60)
     print("End of Trinity Diagnostic.")
 
+
 if __name__ == "__main__":
     operation_trinity()
diff --git a/scripts/pr_manager.py b/scripts/pr_manager.py
index 4be60f2..68f1a78 100644
--- a/scripts/pr_manager.py
+++ b/scripts/pr_manager.py
@@ -3,15 +3,12 @@ import subprocess
 import sys
 from pathlib import Path
 
+
 def run_command(cmd, cwd=None, capture_output=False):
     """Runs a shell command and raises error on failure."""
     print(f"ğŸš€ Running: {' '.join(cmd)}")
     result = subprocess.run(
-        cmd, 
-        cwd=cwd, 
-        check=False, 
-        text=True, 
-        capture_output=capture_output
+        cmd, cwd=cwd, check=False, text=True, capture_output=capture_output
     )
     if result.returncode != 0:
         print(f"âŒ Command failed: {' '.join(cmd)}")
@@ -20,18 +17,23 @@ def run_command(cmd, cwd=None, capture_output=False):
         raise RuntimeError(f"Command failed with code {result.returncode}")
     return result.stdout
 
+
 def main():
     parser = argparse.ArgumentParser(description="PR Manager: Automate Merge & Cleanup")
     parser.add_argument("branch", help="Name of the feature branch to merge")
-    parser.add_argument("--skip-test", action="store_true", help="Skip running tests before merge")
-    parser.add_argument("--remote", default="origin", help="Remote name (default: origin)")
-    
+    parser.add_argument(
+        "--skip-test", action="store_true", help="Skip running tests before merge"
+    )
+    parser.add_argument(
+        "--remote", default="origin", help="Remote name (default: origin)"
+    )
+
     args = parser.parse_args()
     branch = args.branch
-    
+
     try:
         print(f"ğŸ”„ Starting PR Merge Sequence for branch: {branch}")
-        
+
         # 1. Fetch & Checkout
         print("\nğŸ“¦ Step 1: Fetching and checking out...")
         run_command(["git", "fetch", args.remote])
@@ -45,30 +47,33 @@ def main():
             # But let's run a basic synthesis check or just unit tests if possible.
             # For now, let's run ruff as a sanity check.
             run_command(["ruff", "check", "."])
-            print("   (Skipping full pytest to save time, assume CI or manual check was done via test_doctor)")
-        
+            print(
+                "   (Skipping full pytest to save time, assume CI or manual check was done via test_doctor)"
+            )
+
         # 3. Merge to Main
         print("\nğŸ”€ Step 3: Merging into main...")
         run_command(["git", "checkout", "main"])
         run_command(["git", "pull", args.remote, "main"])
         run_command(["git", "merge", branch, "--no-edit"])
-        
+
         # 4. Push
         print("\nâ˜ï¸ Step 4: Pushing to remote...")
         run_command(["git", "push", args.remote, "main"])
-        
+
         # 5. Cleanup
         print("\nğŸ§¹ Step 5: Cleaning up...")
         run_command(["git", "branch", "-d", branch])
         # Optional: delete remote branch? Maybe too risky for auto.
-        # run_command(["git", "push", args.remote, "--delete", branch]) 
-        
+        # run_command(["git", "push", args.remote, "--delete", branch])
+
         print(f"\nâœ… PR Merge Complete! Branch {branch} merged and deleted locally.")
-        
+
     except Exception as e:
         print(f"\nâŒ PR Manager Failed: {e}")
         print("ğŸ’¡ Restoration Suggested: git checkout main")
         sys.exit(1)
 
+
 if __name__ == "__main__":
     main()
diff --git a/scripts/recon_normal_1000.py b/scripts/recon_normal_1000.py
index 1c806a4..ce3f74b 100644
--- a/scripts/recon_normal_1000.py
+++ b/scripts/recon_normal_1000.py
@@ -11,6 +11,7 @@ from main import create_simulation
 from utils.logging_manager import setup_logging
 import config
 
+
 # --- Forensic Log Handler ---
 class ForensicLogHandler(logging.Handler):
     def __init__(self):
@@ -18,24 +19,33 @@ class ForensicLogHandler(logging.Handler):
         self.death_records: List[Dict[str, Any]] = []
 
     def emit(self, record):
-        if hasattr(record, "agent_id") and hasattr(record, "cause") and record.cause == "starvation":
-             if hasattr(record, "food_inventory"):
-                 data = {
-                     "tick": record.tick,
-                     "agent_id": record.agent_id,
-                     "cash_at_death": getattr(record, "cash_at_death", 0.0),
-                     "food_inventory": getattr(record, "food_inventory", 0.0),
-                     "market_food_price": getattr(record, "market_food_price", None),
-                     "last_labor_offer_tick": getattr(record, "last_labor_offer_tick", 0),
-                     "job_vacancies_available": getattr(record, "job_vacancies_available", 0)
-                 }
-                 self.death_records.append(data)
+        if (
+            hasattr(record, "agent_id")
+            and hasattr(record, "cause")
+            and record.cause == "starvation"
+        ):
+            if hasattr(record, "food_inventory"):
+                data = {
+                    "tick": record.tick,
+                    "agent_id": record.agent_id,
+                    "cash_at_death": getattr(record, "cash_at_death", 0.0),
+                    "food_inventory": getattr(record, "food_inventory", 0.0),
+                    "market_food_price": getattr(record, "market_food_price", None),
+                    "last_labor_offer_tick": getattr(
+                        record, "last_labor_offer_tick", 0
+                    ),
+                    "job_vacancies_available": getattr(
+                        record, "job_vacancies_available", 0
+                    ),
+                }
+                self.death_records.append(data)
+
 
 def run_long_term_recon():
     # 1. Setup Logging
     # [FIX: WO-Diag-003] setup_logging first
     setup_logging()
-    
+
     forensic_handler = ForensicLogHandler()
     # Attach to necessary loggers due to propagate=False
     logging.getLogger().addHandler(forensic_handler)
@@ -46,42 +56,47 @@ def run_long_term_recon():
     # Allow dynamic productivity and consumption override from CLI
     prod_factor = 10.0
     cons_rate = 1.0
-    
+
     if len(sys.argv) > 1:
         try:
             prod_factor = float(sys.argv[1])
         except ValueError:
             print(f"Invalid productivity factor '{sys.argv[1]}'. Using default 10.0")
-            
+
     if len(sys.argv) > 2:
         try:
             cons_rate = float(sys.argv[2])
         except ValueError:
             print(f"Invalid consumption rate '{sys.argv[2]}'. Using default 1.0")
 
-    print(f"Initializing Normal Long-Term Recon Simulation (1000 Ticks, Prod={prod_factor}, Cons={cons_rate})...")
-    
+    print(
+        f"Initializing Normal Long-Term Recon Simulation (1000 Ticks, Prod={prod_factor}, Cons={cons_rate})..."
+    )
+
     # [CRITICAL] RESET parameters to Normal for Recon
-    config.INITIAL_HOUSEHOLD_ASSETS_MEAN = 5000.0 
+    config.INITIAL_HOUSEHOLD_ASSETS_MEAN = 5000.0
     config.GOVERNMENT_STIMULUS_ENABLED = True
     config.HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK = cons_rate
     config.FIRM_PRODUCTIVITY_FACTOR = prod_factor
-    
+
     sim = create_simulation()
 
     try:
         total_ticks = 1000
         for i in range(total_ticks):
             sim.run_tick()
-            if (i+1) % 100 == 0:
-                print(f"Tick {i+1}/{total_ticks} complete...")
+            if (i + 1) % 100 == 0:
+                print(f"Tick {i + 1}/{total_ticks} complete...")
     except Exception as e:
         print(f"Simulation crashed at tick {sim.time}: {e}")
         import traceback
+
         traceback.print_exc()
 
     # 3. Analyze Results
-    print(f"\nSimulation Complete. Analyzing {len(forensic_handler.death_records)} deaths...")
+    print(
+        f"\nSimulation Complete. Analyzing {len(forensic_handler.death_records)} deaths..."
+    )
 
     type_a_count = 0
     type_b_count = 0
@@ -109,8 +124,8 @@ def run_long_term_recon():
         is_type_a = vacancies == 0
         is_type_b = (death_tick - last_offer) > 10
         price_val = price if price is not None else 999999.0
-        is_type_c = (cash >= price_val)
-        is_type_d = (cash < price_val)
+        is_type_c = cash >= price_val
+        is_type_d = cash < price_val
 
         assigned_type = "Unknown"
         if is_type_a:
@@ -128,16 +143,26 @@ def run_long_term_recon():
         else:
             assigned_type = "Unclassified"
 
-        if len(sample_cases) < 15: 
-            sample_cases.append(f"- **{assigned_type}** | Agent #{record['agent_id']} | Tick: {death_tick} | Cash: {cash:.2f} | Vacancies: {vacancies} | Last Offer: {last_offer} | Price: {price}")
+        if len(sample_cases) < 15:
+            sample_cases.append(
+                f"- **{assigned_type}** | Agent #{record['agent_id']} | Tick: {death_tick} | Cash: {cash:.2f} | Vacancies: {vacancies} | Last Offer: {last_offer} | Price: {price}"
+            )
 
     total = len(unique_deaths)
     if total > 0:
         report_lines.append("## Classification Summary")
-        report_lines.append(f"- **Type A (No Jobs)**: {type_a_count} ({type_a_count/total:.1%})")
-        report_lines.append(f"- **Type B (Won't Work)**: {type_b_count} ({type_b_count/total:.1%})")
-        report_lines.append(f"- **Type C (Won't Eat)**: {type_c_count} ({type_c_count/total:.1%})")
-        report_lines.append(f"- **Type D (Poverty)**: {type_d_count} ({type_d_count/total:.1%})")
+        report_lines.append(
+            f"- **Type A (No Jobs)**: {type_a_count} ({type_a_count / total:.1%})"
+        )
+        report_lines.append(
+            f"- **Type B (Won't Work)**: {type_b_count} ({type_b_count / total:.1%})"
+        )
+        report_lines.append(
+            f"- **Type C (Won't Eat)**: {type_c_count} ({type_c_count / total:.1%})"
+        )
+        report_lines.append(
+            f"- **Type D (Poverty)**: {type_d_count} ({type_d_count / total:.1%})"
+        )
     else:
         report_lines.append("## Classification Summary")
         report_lines.append("- No deaths recorded. The economy is stable.")
@@ -155,5 +180,6 @@ def run_long_term_recon():
     print("\n".join(report_lines))
     print(f"\nReport saved to reports/RECON_REPORT.md")
 
+
 if __name__ == "__main__":
     run_long_term_recon()
diff --git a/scripts/report_harvester.py b/scripts/report_harvester.py
index 5aa5138..e97f409 100644
--- a/scripts/report_harvester.py
+++ b/scripts/report_harvester.py
@@ -4,15 +4,28 @@ import re
 from typing import List, Set
 
 # Configuration
-BRANCH_PATTERNS = ["refactor-*", "observer-*", "audit-*", "structural-*", "parity-*", "economic-*", "*-action-plan-*", "*-proposal-*", "wo-*"]
+BRANCH_PATTERNS = [
+    "refactor-*",
+    "observer-*",
+    "audit-*",
+    "structural-*",
+    "parity-*",
+    "economic-*",
+    "*-action-plan-*",
+    "*-proposal-*",
+    "wo-*",
+]
 REPORT_DIRS = ["reports/", "design/gemini_output/"]
 LOCAL_STORAGE_DIR = "reports/inbound/"
 LOG_FILE = "design/INBOUND_REPORTS.md"
 
+
 def run_command(cmd: List[str]) -> str:
     try:
         # Windows encoding issue: force utf-8 for git output
-        result = subprocess.run(cmd, capture_output=True, text=True, check=True, encoding="utf-8")
+        result = subprocess.run(
+            cmd, capture_output=True, text=True, check=True, encoding="utf-8"
+        )
         return result.stdout.strip()
     except subprocess.CalledProcessError as e:
         print(f"Error running command {' '.join(cmd)}: {e.stderr}")
@@ -21,6 +34,7 @@ def run_command(cmd: List[str]) -> str:
         print(f"Unexpected error: {e}")
         return ""
 
+
 def get_remote_branches() -> List[str]:
     print("[Harvester] Fetching remote branches...")
     run_command(["git", "fetch", "origin"])
@@ -40,13 +54,14 @@ def get_remote_branches() -> List[str]:
                 break
     return list(set(branches))
 
+
 def get_new_files_in_branch(branch: str) -> List[str]:
     # Use 'git diff origin/main...branch' to get only files changed/added in this branch relative to main
     cmd = ["git", "diff", "origin/main..." + branch, "--name-only"]
     files_raw = run_command(cmd)
     if not files_raw:
         return []
-    
+
     found_files = []
     lines = files_raw.split("\n")
     for line in lines:
@@ -58,15 +73,17 @@ def get_new_files_in_branch(branch: str) -> List[str]:
             found_files.append(line)
     return found_files
 
+
 def clean_branch_name(name: str) -> str:
     """Removes common prefixes to keep the harvested filename short and relevant."""
     name = name.lower()
     prefixes = ["origin/", "audit-", "wo-105-", "wo-"]
     for p in prefixes:
         if name.startswith(p):
-            name = name[len(p):]
+            name = name[len(p) :]
     return name.replace("/", "_")
 
+
 def harvest():
     if not os.path.exists(LOCAL_STORAGE_DIR):
         os.makedirs(LOCAL_STORAGE_DIR)
@@ -82,7 +99,7 @@ def harvest():
         branch_id = branch.replace("origin/", "")
         display_name = clean_branch_name(branch_id)
         files = get_new_files_in_branch(branch)
-        
+
         for file_path in files:
             file_name = os.path.basename(file_path)
             # Safe filename: [cleaned_branch]_[filename]
@@ -95,7 +112,9 @@ def harvest():
                 with open(target_path, "w", encoding="utf-8") as f:
                     f.write(content)
                 new_files_count += 1
-                harvested_log.append(f"- **{file_name}** (from `{branch_id}`) -> `{safe_name}`")
+                harvested_log.append(
+                    f"- **{file_name}** (from `{branch_id}`) -> `{safe_name}`"
+                )
 
     if new_files_count > 0:
         print(f"[Harvester] Successfully harvested {new_files_count} new reports.")
@@ -103,16 +122,18 @@ def harvest():
     else:
         print("[Harvester] No new reports found.")
 
+
 def update_log(new_entries: List[str]):
     from datetime import datetime
+
     timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
-    
+
     header = f"\n## Harvested on {timestamp}\n"
     content = "\n".join(new_entries) + "\n"
-    
+
     file_exists = os.path.exists(LOG_FILE)
     mode = "a" if file_exists else "w"
-    
+
     with open(LOG_FILE, mode, encoding="utf-8") as f:
         if not file_exists:
             f.write("# Inbound Reports Log\n")
@@ -120,5 +141,6 @@ def update_log(new_entries: List[str]):
         f.write(content)
     print(f"[Harvester] Updated {LOG_FILE}")
 
+
 if __name__ == "__main__":
     harvest()
diff --git a/scripts/run_experiment.py b/scripts/run_experiment.py
index 480d79c..7a21c85 100644
--- a/scripts/run_experiment.py
+++ b/scripts/run_experiment.py
@@ -84,6 +84,5 @@ def run_experiment():
     logging.info("\n--- Analyzing Experiment Results ---")
 
 
-
 if __name__ == "__main__":
     run_experiment()
diff --git a/scripts/smoke_test.py b/scripts/smoke_test.py
index f806e81..03d4858 100644
--- a/scripts/smoke_test.py
+++ b/scripts/smoke_test.py
@@ -7,6 +7,7 @@ sys.path.append(os.getcwd())
 
 from main import create_simulation
 
+
 def smoke_test():
     logging.basicConfig(level=logging.INFO)
     logger = logging.getLogger("SmokeTest")
@@ -17,21 +18,24 @@ def smoke_test():
     except Exception as e:
         logger.error(f"Initialization Failed: {e}")
         import traceback
+
         traceback.print_exc()
         sys.exit(1)
 
     logger.info("Running 10 Ticks...")
     try:
         for i in range(10):
-            logger.info(f"--- Tick {i+1} ---")
+            logger.info(f"--- Tick {i + 1} ---")
             sim.run_tick()
     except Exception as e:
         logger.error(f"Simulation Crashed at Tick {sim.time}: {e}")
         import traceback
+
         traceback.print_exc()
         sys.exit(1)
 
     logger.info("Smoke Test Passed!")
 
+
 if __name__ == "__main__":
     smoke_test()
diff --git a/scripts/test_doctor.py b/scripts/test_doctor.py
index 3f40e8a..2b823d5 100644
--- a/scripts/test_doctor.py
+++ b/scripts/test_doctor.py
@@ -5,40 +5,44 @@ from pathlib import Path
 BASE_DIR = Path(__file__).parent.parent
 WORKER_SCRIPT = BASE_DIR / "scripts" / "gemini_worker.py"
 
+
 def run_worker(worker_type, instruction, context_files=None):
     cmd = ["python", str(WORKER_SCRIPT), worker_type, instruction]
     if context_files:
         cmd.extend(["--context"] + context_files)
-    
+
     # We want to capture the output of the worker to print it nicely
-    result = subprocess.run(cmd, text=True, capture_output=True, encoding='utf-8')
+    result = subprocess.run(cmd, text=True, capture_output=True, encoding="utf-8")
     if result.returncode != 0:
         print(f"âŒ Worker failed: {result.stderr}")
         return None
     return result.stdout
 
+
 def main():
     print("ğŸ©º Test Doctor: Initializing...")
-    
+
     # 1. Run Pytest
     print("ğŸ§ª Running Pytest (this may take a moment)...")
     # Run with -v for details, but we'll capture it
-    result = subprocess.run(["pytest"], cwd=BASE_DIR, capture_output=True, text=True, encoding='utf-8')
-    
+    result = subprocess.run(
+        ["pytest"], cwd=BASE_DIR, capture_output=True, text=True, encoding="utf-8"
+    )
+
     if result.returncode == 0:
         print("\nâœ… All Tests Passed! System is healthy.")
-        print(result.stdout[-500:]) # Print last bit of success message
+        print(result.stdout[-500:])  # Print last bit of success message
         sys.exit(0)
-    
+
     # 2. Analyze Failure
     print("\nâš ï¸ Tests Failed. Analyzing logs...")
     log_content = result.stdout + result.stderr
-    
+
     # Save log to temp file to use as context (too big for CLI arg usually)
     log_file = BASE_DIR / "reports" / "temp" / "pytest_failure.log"
     log_file.parent.mkdir(exist_ok=True, parents=True)
-    log_file.write_text(log_content, encoding='utf-8')
-    
+    log_file.write_text(log_content, encoding="utf-8")
+
     instruction = (
         "Analyze the attached pytest log. Identify the failing tests and the ROOT CAUSE. "
         "Summarize the findings in exactly 3 lines: "
@@ -46,18 +50,21 @@ def main():
         "2. Error Message/Type "
         "3. Suggested Fix or Root Cause"
     )
-    
-    summary = run_worker("reporter", instruction, context_files=[f"reports/temp/pytest_failure.log"])
-    
+
+    summary = run_worker(
+        "reporter", instruction, context_files=[f"reports/temp/pytest_failure.log"]
+    )
+
     print("\nğŸ©º Diagnosis Report:")
-    print("="*60)
+    print("=" * 60)
     if summary:
         print(summary)
     else:
         print("Failed to generate summary.")
-    print("="*60)
+    print("=" * 60)
     print(f"\nğŸ“„ Full Log: {log_file}")
     sys.exit(1)
 
+
 if __name__ == "__main__":
     main()
diff --git a/scripts/verify_banking.py b/scripts/verify_banking.py
index 4f94d46..d69b1b6 100644
--- a/scripts/verify_banking.py
+++ b/scripts/verify_banking.py
@@ -15,13 +15,16 @@ from config import (
     NUM_FIRMS,
     INITIAL_HOUSEHOLD_ASSETS_MEAN,
     INITIAL_FIRM_CAPITAL_MEAN,
-    GOLD_STANDARD_MODE
+    GOLD_STANDARD_MODE,
 )
 
 # Configure logging
-logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
+logging.basicConfig(
+    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
+)
 logger = logging.getLogger("verify_banking")
 
+
 def verify_banking_system(num_ticks: int = 200, plot_results: bool = False):
     """
     Runs a simulation to verify the fractional reserve banking system.
@@ -35,18 +38,18 @@ def verify_banking_system(num_ticks: int = 200, plot_results: bool = False):
     overrides = {
         "NUM_HOUSEHOLDS": 50,
         "NUM_FIRMS": 10,
-        "INITIAL_HOUSEHOLD_ASSETS_MEAN": 2000.0, # Enough to deposit
-        "INITIAL_FIRM_CAPITAL_MEAN": 1000.0,     # Low capital -> Demand for loans
-        "GOLD_STANDARD_MODE": False,             # Fractional Reserve Banking
-        "GOVERNMENT_STIMULUS_ENABLED": False,    # Isolate banking effects
-        "FIRM_MAINTENANCE_FEE": 10.0,            # Lower fee to reduce bankruptcy risk during test
-        "SALES_TAX_RATE": 0.0,                   # Disable Taxes to prevent money destruction (Government Sink)
+        "INITIAL_HOUSEHOLD_ASSETS_MEAN": 2000.0,  # Enough to deposit
+        "INITIAL_FIRM_CAPITAL_MEAN": 1000.0,  # Low capital -> Demand for loans
+        "GOLD_STANDARD_MODE": False,  # Fractional Reserve Banking
+        "GOVERNMENT_STIMULUS_ENABLED": False,  # Isolate banking effects
+        "FIRM_MAINTENANCE_FEE": 10.0,  # Lower fee to reduce bankruptcy risk during test
+        "SALES_TAX_RATE": 0.0,  # Disable Taxes to prevent money destruction (Government Sink)
         "INCOME_TAX_RATE": 0.0,
         "CORPORATE_TAX_RATE": 0.0,
-        "INITIAL_BANK_ASSETS": 50000.0,          # Reduced reserves to make Multiplier visible
-        "INITIAL_FIRM_CAPITAL_MEAN": 100.0,      # Starve firms to force borrowing
-        "INFRASTRUCTURE_INVESTMENT_COST": 100.0, # Lower threshold for Gov spending
-        "INITIAL_GOVERNMENT_ASSETS": 10000.0,    # Pump priming to prevent M0 collapse
+        "INITIAL_BANK_ASSETS": 50000.0,  # Reduced reserves to make Multiplier visible
+        "INITIAL_FIRM_CAPITAL_MEAN": 100.0,  # Starve firms to force borrowing
+        "INFRASTRUCTURE_INVESTMENT_COST": 100.0,  # Lower threshold for Gov spending
+        "INITIAL_GOVERNMENT_ASSETS": 10000.0,  # Pump priming to prevent M0 collapse
     }
 
     simulation = create_simulation(overrides)
@@ -72,7 +75,11 @@ def verify_banking_system(num_ticks: int = 200, plot_results: bool = False):
         # Currency in Circulation = Agent Assets (Cash held by Households + Firms)
         # Bank Reserves = Bank Assets (Cash held by Bank)
 
-        currency_in_circulation = sum(agent.assets for agent in simulation.agents.values() if agent.id != bank.id and agent.id != simulation.government.id)
+        currency_in_circulation = sum(
+            agent.assets
+            for agent in simulation.agents.values()
+            if agent.id != bank.id and agent.id != simulation.government.id
+        )
         bank_reserves = bank.assets
         m0 = currency_in_circulation + bank_reserves
 
@@ -94,13 +101,19 @@ def verify_banking_system(num_ticks: int = 200, plot_results: bool = False):
         history_deposits.append(total_deposits)
 
         if tick % 10 == 0:
-            logger.info(f"Tick {tick}: M0={m0:.2f}, M2={m2:.2f}, Mult={money_multiplier:.2f}, Loans={total_loans:.2f}, Deposits={total_deposits:.2f}, BankRes={bank_reserves:.2f}")
+            logger.info(
+                f"Tick {tick}: M0={m0:.2f}, M2={m2:.2f}, Mult={money_multiplier:.2f}, Loans={total_loans:.2f}, Deposits={total_deposits:.2f}, BankRes={bank_reserves:.2f}"
+            )
 
     # --- Verification Checks ---
     logger.info("--- Verification Results ---")
 
     # 1. Money Multiplier Verification
-    avg_multiplier = sum(history_multiplier[-50:]) / 50 if num_ticks >= 50 else sum(history_multiplier) / len(history_multiplier)
+    avg_multiplier = (
+        sum(history_multiplier[-50:]) / 50
+        if num_ticks >= 50
+        else sum(history_multiplier) / len(history_multiplier)
+    )
     max_multiplier = max(history_multiplier)
 
     logger.info(f"Average Money Multiplier (Last 50 ticks): {avg_multiplier:.2f}")
@@ -114,7 +127,9 @@ def verify_banking_system(num_ticks: int = 200, plot_results: bool = False):
     # 2. Solvency Check
     initial_bank_assets = history_bank_assets[0]
     final_bank_assets = history_bank_assets[-1]
-    logger.info(f"Bank Assets: Start={initial_bank_assets:.2f}, End={final_bank_assets:.2f}")
+    logger.info(
+        f"Bank Assets: Start={initial_bank_assets:.2f}, End={final_bank_assets:.2f}"
+    )
 
     if final_bank_assets > 0:
         logger.info("âœ… SUCCESS: Bank is Solvent (Positive Assets).")
@@ -125,33 +140,36 @@ def verify_banking_system(num_ticks: int = 200, plot_results: bool = False):
     if final_bank_assets > initial_bank_assets:
         logger.info("âœ… SUCCESS: Bank is Profitable.")
     else:
-        logger.info("âš ï¸ WARNING: Bank lost assets (could be due to defaults or initial burn).")
+        logger.info(
+            "âš ï¸ WARNING: Bank lost assets (could be due to defaults or initial burn)."
+        )
 
     # Plotting
     if plot_results:
         plt.figure(figsize=(12, 10))
 
         plt.subplot(3, 1, 1)
-        plt.plot(history_m0, label='M0 (Base Money)')
-        plt.plot(history_m2, label='M2 (Money Supply)')
+        plt.plot(history_m0, label="M0 (Base Money)")
+        plt.plot(history_m2, label="M2 (Money Supply)")
         plt.legend()
-        plt.title('Money Supply (M0 vs M2)')
+        plt.title("Money Supply (M0 vs M2)")
 
         plt.subplot(3, 1, 2)
-        plt.plot(history_loans, label='Total Loans')
-        plt.plot(history_deposits, label='Total Deposits')
+        plt.plot(history_loans, label="Total Loans")
+        plt.plot(history_deposits, label="Total Deposits")
         plt.legend()
-        plt.title('Bank Balance Sheet Items')
+        plt.title("Bank Balance Sheet Items")
 
         plt.subplot(3, 1, 3)
-        plt.plot(history_multiplier, label='Money Multiplier', color='green')
+        plt.plot(history_multiplier, label="Money Multiplier", color="green")
         plt.legend()
-        plt.title('Money Multiplier (M2 / M0)')
+        plt.title("Money Multiplier (M2 / M0)")
 
         plt.tight_layout()
-        plt.savefig('reports/banking_verification.png')
+        plt.savefig("reports/banking_verification.png")
         logger.info("Saved plot to reports/banking_verification.png")
 
+
 if __name__ == "__main__":
     parser = argparse.ArgumentParser(description="Verify Banking System Logic")
     parser.add_argument("--ticks", type=int, default=200, help="Number of ticks to run")
diff --git a/scripts/verify_banking_v2.py b/scripts/verify_banking_v2.py
index ed90e19..8935bb8 100644
--- a/scripts/verify_banking_v2.py
+++ b/scripts/verify_banking_v2.py
@@ -1,4 +1,3 @@
-
 import sys
 from pathlib import Path
 import os
@@ -13,10 +12,13 @@ from simulation.bank import Bank, Loan, Deposit
 from simulation.loan_market import LoanMarket
 from simulation.models import Order
 
+
 class TestBankingSystemVerification(unittest.TestCase):
     def setUp(self):
         self.bank = Bank(id=999, initial_assets=1000000.0, config_module=config)
-        self.loan_market = LoanMarket(market_id="loan_market", bank=self.bank, config_module=config)
+        self.loan_market = LoanMarket(
+            market_id="loan_market", bank=self.bank, config_module=config
+        )
 
         self.agent1_id = 1
         self.agent2_id = 2
@@ -32,15 +34,15 @@ class TestBankingSystemVerification(unittest.TestCase):
             item_id="cash",
             quantity=deposit_amount,
             price=1.0,
-            market_id="loan_market"
+            market_id="loan_market",
         )
 
         txs = self.loan_market.place_order(deposit_order, current_tick=1)
 
         self.assertEqual(len(txs), 1)
         self.assertEqual(txs[0].transaction_type, "deposit")
-        self.assertEqual(txs[0].buyer_id, self.agent2_id) # Agent gives money
-        self.assertEqual(txs[0].seller_id, self.bank.id) # Bank receives
+        self.assertEqual(txs[0].buyer_id, self.agent2_id)  # Agent gives money
+        self.assertEqual(txs[0].seller_id, self.bank.id)  # Bank receives
 
         # Check Bank State
         # Bank methods no longer modify assets directly. Assets are moved by Engine via Transactions.
@@ -62,16 +64,16 @@ class TestBankingSystemVerification(unittest.TestCase):
             order_type="LOAN_REQUEST",
             item_id="cash",
             quantity=loan_amount,
-            price=0.07, # Requested rate, ignored by bank logic which uses base+spread
-            market_id="loan_market"
+            price=0.07,  # Requested rate, ignored by bank logic which uses base+spread
+            market_id="loan_market",
         )
 
         txs = self.loan_market.place_order(loan_order, current_tick=1)
 
         self.assertEqual(len(txs), 1)
         self.assertEqual(txs[0].transaction_type, "loan")
-        self.assertEqual(txs[0].buyer_id, self.bank.id) # Bank gives money
-        self.assertEqual(txs[0].seller_id, self.agent1_id) # Agent receives
+        self.assertEqual(txs[0].buyer_id, self.bank.id)  # Bank gives money
+        self.assertEqual(txs[0].seller_id, self.agent1_id)  # Agent receives
 
         # Check Bank State (Simulated)
         if txs:
@@ -87,14 +89,19 @@ class TestBankingSystemVerification(unittest.TestCase):
         deposit = list(self.bank.deposits.values())[0]
 
         ticks_per_year = 100.0
-        expected_loan_interest = (loan.remaining_balance * loan.annual_interest_rate) / ticks_per_year
-        expected_deposit_interest = (deposit.amount * deposit.annual_interest_rate) / ticks_per_year
+        expected_loan_interest = (
+            loan.remaining_balance * loan.annual_interest_rate
+        ) / ticks_per_year
+        expected_deposit_interest = (
+            deposit.amount * deposit.annual_interest_rate
+        ) / ticks_per_year
 
         self.assertGreater(expected_loan_interest, 0)
         self.assertGreater(expected_deposit_interest, 0)
-        self.assertGreater(expected_loan_interest, expected_deposit_interest) # Spread
+        self.assertGreater(expected_loan_interest, expected_deposit_interest)  # Spread
 
         print("âœ… Deposit & Loan Flow Verified")
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     unittest.main()
diff --git a/scripts/verify_banking_v3.py b/scripts/verify_banking_v3.py
index fc77fc0..eaf23ad 100644
--- a/scripts/verify_banking_v3.py
+++ b/scripts/verify_banking_v3.py
@@ -1,4 +1,3 @@
-
 import sys
 from pathlib import Path
 import os
@@ -13,10 +12,13 @@ from simulation.bank import Bank, Loan, Deposit
 from simulation.loan_market import LoanMarket
 from simulation.models import Order
 
+
 class TestBankingTransactionLogic(unittest.TestCase):
     def setUp(self):
         self.bank = Bank(id=999, initial_assets=1000000.0, config_module=config)
-        self.loan_market = LoanMarket(market_id="loan_market", bank=self.bank, config_module=config)
+        self.loan_market = LoanMarket(
+            market_id="loan_market", bank=self.bank, config_module=config
+        )
 
         self.agent_id = 101
 
@@ -35,7 +37,7 @@ class TestBankingTransactionLogic(unittest.TestCase):
             item_id=loan_id,
             quantity=repay_amount,
             price=1.0,
-            market_id="loan_market"
+            market_id="loan_market",
         )
 
         txs = self.loan_market.place_order(repay_order, current_tick=2)
@@ -46,13 +48,18 @@ class TestBankingTransactionLogic(unittest.TestCase):
         # Verify Direction
         # Buyer PAYS -> Seller RECEIVES
         # Repayment: Agent PAYS Bank
-        print(f"Transaction: Buyer={tx.buyer_id}, Seller={tx.seller_id}, Amt={tx.quantity}")
+        print(
+            f"Transaction: Buyer={tx.buyer_id}, Seller={tx.seller_id}, Amt={tx.quantity}"
+        )
 
         self.assertEqual(tx.buyer_id, self.agent_id, "Buyer should be Agent (Paying)")
-        self.assertEqual(tx.seller_id, self.bank.id, "Seller should be Bank (Receiving)")
+        self.assertEqual(
+            tx.seller_id, self.bank.id, "Seller should be Bank (Receiving)"
+        )
         self.assertEqual(tx.quantity, repay_amount)
 
         print("âœ… Repayment Transaction Direction Verified")
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     unittest.main()
diff --git a/scripts/verify_brand_economy.py b/scripts/verify_brand_economy.py
index 4862610..2c49f2a 100644
--- a/scripts/verify_brand_economy.py
+++ b/scripts/verify_brand_economy.py
@@ -1,4 +1,3 @@
-
 import logging
 import sys
 from pathlib import Path
@@ -12,7 +11,9 @@ from simulation.core_agents import Household, Talent
 from simulation.firms import Firm
 from simulation.models import Order
 from simulation.ai.api import Personality
-from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
+from simulation.decisions.ai_driven_household_engine import (
+    AIDrivenHouseholdDecisionEngine,
+)
 from simulation.ai.household_ai import HouseholdAI
 from simulation.ai_model import AIDecisionEngine
 import config
@@ -21,12 +22,13 @@ import config
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger("VERIFY_BRAND")
 
+
 def verify_brand_economy():
     logger.info("=== START: Brand Economy Verification ===")
-    
+
     # 1. Setup Market
     market = OrderBookMarket("goods_market", logger)
-    
+
     # 2. Setup Config Mock
     class MockConfig:
         MARKETING_DECAY_RATE = 0.8
@@ -36,7 +38,7 @@ def verify_brand_economy():
         BRAND_LOYALTY_DECAY = 0.95
         NETWORK_EFFECT_WEIGHT = 0.5
         AI_VALUATION_MULTIPLIER = 1000.0
-        
+
         # Base Agent Configs
         INITIAL_FIRM_LIQUIDITY_NEED = 50.0
         FIRM_MIN_PRODUCTION_TARGET = 10.0
@@ -50,120 +52,191 @@ def verify_brand_economy():
         LIQUIDITY_NEED_INCREASE_RATE = 0
         ASSETS_CLOSURE_THRESHOLD = -1000
         FIRM_CLOSURE_TURNS_THRESHOLD = 999
-        
+
     mock_config = MockConfig()
-    
+
     # --- Mock AI Dependencies ---
     class MockActionProposalEngine:
-        def get_all_actions(self): return []
-    
+        def get_all_actions(self):
+            return []
+
     class MockStateBuilder:
-        def build_state(self, *args): return {}
+        def build_state(self, *args):
+            return {}
 
     mock_action_engine = MockActionProposalEngine()
     mock_state_builder = MockStateBuilder()
 
     # 3. Setup Firms (Brand vs Generic)
     # Firm A: Premium Brand
-    firm_a_ai = AIDecisionEngine("firm_a", mock_action_engine, mock_state_builder) 
-    firm_a = Firm(1, 1000.0, 50.0, "widget", 20.0, firm_a_ai, "profit", mock_config, loan_market=None, logger=logger)
-    
+    firm_a_ai = AIDecisionEngine("firm_a", mock_action_engine, mock_state_builder)
+    firm_a = Firm(
+        1,
+        1000.0,
+        50.0,
+        "widget",
+        20.0,
+        firm_a_ai,
+        "profit",
+        mock_config,
+        loan_market=None,
+        logger=logger,
+    )
+
     # Firm B: Generic
-    firm_b_ai = AIDecisionEngine("firm_b", mock_action_engine, mock_state_builder) 
-    firm_b = Firm(2, 1000.0, 50.0, "widget", 10.0, firm_b_ai, "profit", mock_config, loan_market=None, logger=logger)
-    
+    firm_b_ai = AIDecisionEngine("firm_b", mock_action_engine, mock_state_builder)
+    firm_b = Firm(
+        2,
+        1000.0,
+        50.0,
+        "widget",
+        10.0,
+        firm_b_ai,
+        "profit",
+        mock_config,
+        loan_market=None,
+        logger=logger,
+    )
+
     # --- Step A: Brand Building ---
     logger.info("--- Step A: Building Brand for Firm A ---")
     # Force Firm A to spend on marketing (High Awareness, Same Quality)
     # Direct injection into Brand Manager
-    firm_a.brand_manager.update(100.0, 2.0) # Spend 100, Quality 2.0 -> Perceived Quality ~0.4
-    firm_b.brand_manager.update(0.0, 2.0)   # Spend 0, Quality 2.0 (SAME QUALITY) -> Perceived ~0.4
-                                            # Awareness = 0 for B
-    
-    logger.info(f"Firm A Awareness: {firm_a.brand_manager.brand_awareness:.4f}, Perceived Quality: {firm_a.brand_manager.perceived_quality:.4f}")
-    logger.info(f"Firm B Awareness: {firm_b.brand_manager.brand_awareness:.4f}, Perceived Quality: {firm_b.brand_manager.perceived_quality:.4f}")
-    
-    assert firm_a.brand_manager.brand_awareness > firm_b.brand_manager.brand_awareness, "Firm A should have higher awareness"
-    
+    firm_a.brand_manager.update(
+        100.0, 2.0
+    )  # Spend 100, Quality 2.0 -> Perceived Quality ~0.4
+    firm_b.brand_manager.update(
+        0.0, 2.0
+    )  # Spend 0, Quality 2.0 (SAME QUALITY) -> Perceived ~0.4
+    # Awareness = 0 for B
+
+    logger.info(
+        f"Firm A Awareness: {firm_a.brand_manager.brand_awareness:.4f}, Perceived Quality: {firm_a.brand_manager.perceived_quality:.4f}"
+    )
+    logger.info(
+        f"Firm B Awareness: {firm_b.brand_manager.brand_awareness:.4f}, Perceived Quality: {firm_b.brand_manager.perceived_quality:.4f}"
+    )
+
+    assert (
+        firm_a.brand_manager.brand_awareness > firm_b.brand_manager.brand_awareness
+    ), "Firm A should have higher awareness"
+
     # --- Step B: Market Offering ---
     logger.info("--- Step B: Firms Place Sell Orders ---")
     # Firm A sells at Premium (Price 15) with Brand Metadata
     # Firm B sells at Discount (Price 10) with Generic Metadata
     brand_info_a = {
         "brand_awareness": firm_a.brand_manager.brand_awareness,
-        "perceived_quality": firm_a.brand_manager.perceived_quality
+        "perceived_quality": firm_a.brand_manager.perceived_quality,
     }
     brand_info_b = {
         "brand_awareness": firm_b.brand_manager.brand_awareness,
-        "perceived_quality": firm_b.brand_manager.perceived_quality
+        "perceived_quality": firm_b.brand_manager.perceived_quality,
     }
-    order_a = Order(1, "SELL", "widget", 10.0, 15.0, "goods_market", brand_info=brand_info_a)
-    order_b = Order(2, "SELL", "widget", 10.0, 10.0, "goods_market", brand_info=brand_info_b)
-    
+    order_a = Order(
+        1, "SELL", "widget", 10.0, 15.0, "goods_market", brand_info=brand_info_a
+    )
+    order_b = Order(
+        2, "SELL", "widget", 10.0, 10.0, "goods_market", brand_info=brand_info_b
+    )
+
     market.place_order(order_a, 1)
     market.place_order(order_b, 1)
-    
+
     # --- Step C: Household Choice ---
     logger.info("--- Step C: Household Selection ---")
-    
+
     # Household 1: Quality Seeker (Snob)
-    hh_ai = AIDecisionEngine("hh", mock_action_engine, mock_state_builder) # Dummy
+    hh_ai = AIDecisionEngine("hh", mock_action_engine, mock_state_builder)  # Dummy
     # Need proper init
     talent = Talent(1.0, {})
-    hh_snob = Household(101, talent, [], 100.0, {}, hh_ai, "status", Personality.STATUS_SEEKER, mock_config, logger=logger)
-    hh_snob.quality_preference = 1.0 # Max quality pref
-    
+    hh_snob = Household(
+        101,
+        talent,
+        [],
+        100.0,
+        {},
+        hh_ai,
+        "status",
+        Personality.STATUS_SEEKER,
+        mock_config,
+        logger=logger,
+    )
+    hh_snob.quality_preference = 1.0  # Max quality pref
+
     # Household 2: Miser
-    hh_miser = Household(102, talent, [], 100.0, {}, hh_ai, "needs", Personality.MISER, mock_config, logger=logger)
-    hh_miser.quality_preference = 0.0 # Price only
-    
+    hh_miser = Household(
+        102,
+        talent,
+        [],
+        100.0,
+        {},
+        hh_ai,
+        "needs",
+        Personality.MISER,
+        mock_config,
+        logger=logger,
+    )
+    hh_miser.quality_preference = 0.0  # Price only
+
     # Check Choice
     # Use choose_best_seller directly
-    target_snob, price_snob = hh_snob.choose_best_seller({"goods_market": market}, "widget")
-    target_miser, price_miser = hh_miser.choose_best_seller({"goods_market": market}, "widget")
-    
+    target_snob, price_snob = hh_snob.choose_best_seller(
+        {"goods_market": market}, "widget"
+    )
+    target_miser, price_miser = hh_miser.choose_best_seller(
+        {"goods_market": market}, "widget"
+    )
+
     logger.info(f"Snob chose Firm {target_snob} at {price_snob}")
     logger.info(f"Miser chose Firm {target_miser} at {price_miser}")
-    
+
     # Verify: Snob should choose Firm A (High Quality/Brand) even if price is 15 vs 10
     # U_A = (2.0 * (1 + 0.63*1) * 1) / 15 = (2 * 1.63) / 15 = 3.26 / 15 = 0.217
     # U_B = (1.0 * (1 + 0) * 1) / 10 = 0.1
     # 0.217 > 0.1 -> Choose A.
-    
+
     if target_snob == 1:
         logger.info("PASS: Snob chose Premium Brand (Firm A).")
     else:
         logger.error(f"FAIL: Snob chose Firm {target_snob}. Expected Firm 1.")
-        
+
     if target_miser == 2:
         logger.info("PASS: Miser chose Cheapest (Firm B).")
     else:
         logger.error(f"FAIL: Miser chose Firm {target_miser}. Expected Firm 2.")
-        
+
     # --- Step D: Execution ---
     logger.info("--- Step D: Execution (Targeted Orders) ---")
-    
+
     # Place targeted buy orders
-    buy_snob = Order(101, "BUY", "widget", 1.0, 20.0, "goods_market", target_agent_id=target_snob)
-    buy_miser = Order(102, "BUY", "widget", 1.0, 20.0, "goods_market", target_agent_id=target_miser)
-    
+    buy_snob = Order(
+        101, "BUY", "widget", 1.0, 20.0, "goods_market", target_agent_id=target_snob
+    )
+    buy_miser = Order(
+        102, "BUY", "widget", 1.0, 20.0, "goods_market", target_agent_id=target_miser
+    )
+
     market.place_order(buy_snob, 1)
     market.place_order(buy_miser, 1)
-    
+
     txs = market.match_orders(1)
-    
+
     assert len(txs) == 2, f"Expected 2 transactions, got {len(txs)}"
-    
+
     for tx in txs:
-        logger.info(f"Transaction: Buyer {tx.buyer_id} -> Seller {tx.seller_id} @ {tx.price}")
+        logger.info(
+            f"Transaction: Buyer {tx.buyer_id} -> Seller {tx.seller_id} @ {tx.price}"
+        )
         if tx.buyer_id == 101:
             assert tx.seller_id == 1, "Snob matched wrong seller"
             assert tx.price == 15.0, "Snob paid wrong price (should be Seller Ask)"
         if tx.buyer_id == 102:
             assert tx.seller_id == 2, "Miser matched wrong seller"
             assert tx.price == 10.0, "Miser paid wrong price"
-            
+
     logger.info("=== VERIFICATION SUCCESS ===")
 
+
 if __name__ == "__main__":
     verify_brand_economy()
diff --git a/scripts/verify_durables.py b/scripts/verify_durables.py
index 6f6d30e..d47195f 100644
--- a/scripts/verify_durables.py
+++ b/scripts/verify_durables.py
@@ -1,4 +1,3 @@
-
 import sys
 from pathlib import Path
 import os
@@ -16,6 +15,7 @@ from simulation.core_agents import Household
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger("verify_durables")
 
+
 def generate_ascii_chart(data: List[float], title: str, max_width: int = 50) -> str:
     if not data:
         return "No Data"
@@ -25,7 +25,9 @@ def generate_ascii_chart(data: List[float], title: str, max_width: int = 50) ->
     if max_val == min_val:
         normalized = [0 for _ in data]
     else:
-        normalized = [int((x - min_val) / (max_val - min_val) * max_width) for x in data]
+        normalized = [
+            int((x - min_val) / (max_val - min_val) * max_width) for x in data
+        ]
 
     lines = [f"### {title}"]
     lines.append(f"Range: {min_val:.2f} - {max_val:.2f}")
@@ -36,6 +38,7 @@ def generate_ascii_chart(data: List[float], title: str, max_width: int = 50) ->
     lines.append("```")
     return "\n".join(lines)
 
+
 def run_verification():
     logger.info("Starting Durables Business Cycle Verification...")
 
@@ -56,20 +59,17 @@ def run_verification():
         "GOVERNMENT_STIMULUS_ENABLED": True,
         "INITIAL_FIRM_INVENTORY_MEAN": 0.0,
         "FIRM_MIN_PRODUCTION_TARGET": 50.0,
-
         # Prevent initial panic selling by firms (Give them runway)
         "INITIAL_FIRM_CAPITAL_MEAN": 50000.0,
-
         # Prevent hoarding by households (Don't buy if need is low)
         "NEED_FACTOR_BASE": 0.1,
-
         # Force immediate consumption (installation) of durables
         "INITIAL_HOUSEHOLD_NEEDS_MEAN": {
             "survival": 60.0,
             "asset": 10.0,
             "social": 20.0,
             "improvement": 10.0,
-            "quality": 90.0, # High initial need -> Buy & Install immediately
+            "quality": 90.0,  # High initial need -> Buy & Install immediately
             "liquidity_need": 50.0,
             # Legacy Keys
             "survival_need": 60.0,
@@ -78,7 +78,7 @@ def run_verification():
             "wealth_need": 10.0,
             "imitation_need": 15.0,
             "labor_need": 0.0,
-            "child_rearing_need": 0.0
+            "child_rearing_need": 0.0,
         },
         "NEED_MEDIUM_THRESHOLD": 10.0,
     }
@@ -102,7 +102,7 @@ def run_verification():
         # Metric 1: Sales Volume
         market = sim.markets.get("consumer_goods")
         daily_vol = 0.0
-        daily_price = 15.0 # Default
+        daily_price = 15.0  # Default
 
         if market:
             daily_vol = market.get_daily_volume()
@@ -138,14 +138,16 @@ def run_verification():
                     price = daily_price
                     durable_value += quality * (remaining / base_life) * price
 
-            total_wealth += (cash + durable_value)
+            total_wealth += cash + durable_value
             active_count += 1
 
         avg_wealth = total_wealth / active_count if active_count > 0 else 0.0
         avg_wealth_history.append(avg_wealth)
 
         if tick % 10 == 0:
-            logger.info(f"Tick {tick}: Vol={daily_vol:.1f}, AvgWealth={avg_wealth:.1f}, InvGoods={total_inventory_goods:.1f}, Installed={total_durable_count}")
+            logger.info(
+                f"Tick {tick}: Vol={daily_vol:.1f}, AvgWealth={avg_wealth:.1f}, InvGoods={total_inventory_goods:.1f}, Installed={total_durable_count}"
+            )
 
     # 4. Post-Simulation Analysis (Metric 3: Quality Segmentation)
     logger.info("Calculating Quality Segmentation...")
@@ -155,7 +157,8 @@ def run_verification():
 
     market = sim.markets.get("consumer_goods")
     final_price = market.get_daily_avg_price() if market else 15.0
-    if final_price <= 0: final_price = 15.0
+    if final_price <= 0:
+        final_price = 15.0
 
     for h in sim.households:
         if not h.is_active:
@@ -163,7 +166,9 @@ def run_verification():
 
         cash = h.assets
         durable_val = 0.0
-        owned_durables = [a for a in h.durable_assets if a["item_id"] == "consumer_goods"]
+        owned_durables = [
+            a for a in h.durable_assets if a["item_id"] == "consumer_goods"
+        ]
 
         for asset in owned_durables:
             q = asset["quality"]
@@ -177,12 +182,14 @@ def run_verification():
         if owned_durables:
             avg_q = sum(a["quality"] for a in owned_durables) / len(owned_durables)
 
-        household_wealth_map.append({
-            "id": h.id,
-            "wealth": total,
-            "avg_quality": avg_q,
-            "owned_count": len(owned_durables)
-        })
+        household_wealth_map.append(
+            {
+                "id": h.id,
+                "wealth": total,
+                "avg_quality": avg_q,
+                "owned_count": len(owned_durables),
+            }
+        )
 
     # Sort by wealth descending
     household_wealth_map.sort(key=lambda x: x["wealth"], reverse=True)
@@ -195,7 +202,9 @@ def run_verification():
     bottom_10 = household_wealth_map[-bottom_10_idx:]
 
     avg_q_top = sum(x["avg_quality"] for x in top_10) / len(top_10) if top_10 else 0.0
-    avg_q_bottom = sum(x["avg_quality"] for x in bottom_10) / len(bottom_10) if bottom_10 else 0.0
+    avg_q_bottom = (
+        sum(x["avg_quality"] for x in bottom_10) / len(bottom_10) if bottom_10 else 0.0
+    )
 
     logger.info(f"Top 10% Avg Quality: {avg_q_top:.2f}")
     logger.info(f"Bottom 10% Avg Quality: {avg_q_bottom:.2f}")
@@ -208,19 +217,21 @@ def run_verification():
         generate_ascii_chart(sales_volume_history, "Consumer Goods Sales Volume"),
         "",
         "## 2. Wealth Storage (Asset Accumulation)",
-        generate_ascii_chart(avg_wealth_history, "Avg Household Wealth (Cash + Durable Value)"),
+        generate_ascii_chart(
+            avg_wealth_history, "Avg Household Wealth (Cash + Durable Value)"
+        ),
         "",
         "## 3. Quality Segmentation (at T=100)",
         "| Group | Avg Quality | Avg Wealth | Owned Count (Avg) |",
         "|---|---|---|---|",
-        f"| Top 10% | {avg_q_top:.2f} | {sum(x['wealth'] for x in top_10)/len(top_10):.1f} | {sum(x['owned_count'] for x in top_10)/len(top_10):.1f} |",
-        f"| Bottom 10% | {avg_q_bottom:.2f} | {sum(x['wealth'] for x in bottom_10)/len(bottom_10):.1f} | {sum(x['owned_count'] for x in bottom_10)/len(bottom_10):.1f} |",
+        f"| Top 10% | {avg_q_top:.2f} | {sum(x['wealth'] for x in top_10) / len(top_10):.1f} | {sum(x['owned_count'] for x in top_10) / len(top_10):.1f} |",
+        f"| Bottom 10% | {avg_q_bottom:.2f} | {sum(x['wealth'] for x in bottom_10) / len(bottom_10):.1f} | {sum(x['owned_count'] for x in bottom_10) / len(bottom_10):.1f} |",
         "",
         "## Analysis",
         "- **Cliff & Echo**: Check T=0-10 for spike and ~T=50 for echo.",
         "- **Wealth**: Check for sawtooth pattern.",
         "- **Quality**: Check if Top 10% > Bottom 10% (Expect > 1.0 for rich).",
-        ""
+        "",
     ]
 
     os.makedirs("reports", exist_ok=True)
@@ -229,5 +240,6 @@ def run_verification():
 
     logger.info("Report generated at reports/DURABLES_CYCLE_REPORT.md")
 
+
 if __name__ == "__main__":
     run_verification()
diff --git a/scripts/verify_genesis.py b/scripts/verify_genesis.py
index ae392cd..0f15f93 100644
--- a/scripts/verify_genesis.py
+++ b/scripts/verify_genesis.py
@@ -11,30 +11,31 @@ import config
 from utils.logging_manager import setup_logging
 from scripts.operation_forensics import ForensicLogHandler
 
+
 def run_genesis_verification():
     # 1. Setup Logging
     setup_logging()
-    
+
     forensic_handler = ForensicLogHandler()
     logging.getLogger().addHandler(forensic_handler)
     logging.getLogger("simulation").addHandler(forensic_handler)
     logging.getLogger("main").addHandler(forensic_handler)
-    
+
     # 2. Configure Genesis Parameters
     config.GOVERNMENT_STIMULUS_ENABLED = False
-    
+
     prod_factor = float(sys.argv[1]) if len(sys.argv) > 1 else 5.0
     cons_rate = float(sys.argv[2]) if len(sys.argv) > 2 else 1.0
-    
+
     overrides = {
         "SIMULATION_TICKS": 1000,
         "FIRM_PRODUCTIVITY_FACTOR": prod_factor,
         "HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK": cons_rate,
         "GOVERNMENT_STIMULUS_ENABLED": False,
         "INITIAL_HOUSEHOLD_ASSETS_MEAN": config.INITIAL_HOUSEHOLD_ASSETS_MEAN,
-        "INITIAL_FIRM_CAPITAL_MEAN": config.INITIAL_FIRM_CAPITAL_MEAN
+        "INITIAL_FIRM_CAPITAL_MEAN": config.INITIAL_FIRM_CAPITAL_MEAN,
     }
-    
+
     print(f"--- ğŸš€ Operation Genesis Verification ---")
     print(f"Ticks: {overrides['SIMULATION_TICKS']}")
     print(f"Productivity: {prod_factor}")
@@ -44,40 +45,40 @@ def run_genesis_verification():
 
     # 3. Create and Run Simulation
     sim = create_simulation(overrides=overrides)
-    
+
     simulation_ticks = overrides.get("SIMULATION_TICKS", 100)
     for i in range(simulation_ticks):
         sim.run_tick()
         if (i + 1) % 100 == 0:
-            print(f"Tick {i+1}/{simulation_ticks} complete...")
+            print(f"Tick {i + 1}/{simulation_ticks} complete...")
 
     # 4. Analyze Results
     unique_deaths = set()
     unique_stimulus = []
-    
-    type_a_count = 0 
-    type_b_count = 0 
-    type_c_count = 0 
-    type_d_count = 0 
-    
+
+    type_a_count = 0
+    type_b_count = 0
+    type_c_count = 0
+    type_d_count = 0
+
     report_lines = []
     sample_cases = []
 
     for record_dict in forensic_handler.all_records:
         msg = record_dict.get("msg", "")
-        
+
         if "AGENT_DEATH" in msg or "starvation" in record_dict.get("cause", ""):
             death_tick = record_dict.get("tick", 0)
             agent_id = record_dict.get("agent_id")
-            
+
             if (death_tick, agent_id) in unique_deaths:
                 continue
             unique_deaths.add((death_tick, agent_id))
-            
+
             cash = record_dict.get("cash_at_death", 0.0)
             vacancies = record_dict.get("job_vacancies_available", 0)
             price = record_dict.get("market_food_price", 0.0)
-            
+
             if vacancies == 0:
                 type_a_count += 1
                 assigned_type = "Type A (No Jobs)"
@@ -90,15 +91,17 @@ def run_genesis_verification():
             else:
                 assigned_type = "Unclassified"
 
-            if len(sample_cases) < 15: 
-                sample_cases.append(f"- **{assigned_type}** | Agent #{agent_id} | Tick: {death_tick} | Cash: {cash:.2f} | Vacancies: {vacancies} | Price: {price}")
-        
+            if len(sample_cases) < 15:
+                sample_cases.append(
+                    f"- **{assigned_type}** | Agent #{agent_id} | Tick: {death_tick} | Cash: {cash:.2f} | Vacancies: {vacancies} | Price: {price}"
+                )
+
         elif "STIMULUS_TRIGGERED" in msg:
             unique_stimulus.append(record_dict)
 
     # Generate Report
     total_deaths = len(unique_deaths)
-    
+
     report_lines.append("# ğŸš€ Operation Genesis: Verification Report")
     report_lines.append(f"- **Total Ticks**: {overrides['SIMULATION_TICKS']}")
     report_lines.append(f"- **Total Deaths**: {total_deaths}")
@@ -108,7 +111,11 @@ def run_genesis_verification():
     report_lines.append(f"- **Gov Stimulus Count**: {len(unique_stimulus)}")
     report_lines.append("")
     report_lines.append("## Survival Rate")
-    survival_rate = (1.0 - (total_deaths / config.NUM_HOUSEHOLDS)) if config.NUM_HOUSEHOLDS > 0 else 0
+    survival_rate = (
+        (1.0 - (total_deaths / config.NUM_HOUSEHOLDS))
+        if config.NUM_HOUSEHOLDS > 0
+        else 0
+    )
     report_lines.append(f"**Survival Rate: {survival_rate:.1%}**")
     report_lines.append("")
     report_lines.append("## Sample Cases")
@@ -120,8 +127,9 @@ def run_genesis_verification():
     os.makedirs("reports", exist_ok=True)
     with open("reports/GENESIS_REPORT.md", "w", encoding="utf-8") as f:
         f.write("\n".join(report_lines))
-    
+
     print(f"\nReport saved to reports/GENESIS_REPORT.md")
 
+
 if __name__ == "__main__":
     run_genesis_verification()
diff --git a/scripts/verify_golden_load.py b/scripts/verify_golden_load.py
index 050c267..e240971 100644
--- a/scripts/verify_golden_load.py
+++ b/scripts/verify_golden_load.py
@@ -9,6 +9,7 @@ sys.path.append(str(root_dir))
 
 from simulation.utils.golden_loader import GoldenLoader
 
+
 def verify_golden_load():
     print("ğŸ§ª Verifying Golden Fixture Loading...")
 
@@ -37,28 +38,30 @@ def verify_golden_load():
 
         print(f"âœ… First household type: {type(first_household)}")
         if not isinstance(first_household, MagicMock):
-             print(f"âš ï¸ Warning: Expected MagicMock, got {type(first_household)}.")
+            print(f"âš ï¸ Warning: Expected MagicMock, got {type(first_household)}.")
 
         # Verify attributes
-        if hasattr(first_household, 'id'):
-             print(f"âœ… household.id: {first_household.id}")
+        if hasattr(first_household, "id"):
+            print(f"âœ… household.id: {first_household.id}")
         else:
-             print("âŒ household.id missing")
+            print("âŒ household.id missing")
 
-        val_age = getattr(first_household, 'age', None)
+        val_age = getattr(first_household, "age", None)
         print(f"âœ… household.age (direct): {val_age}")
 
         if val_age is None:
-             print("âŒ household.age is missing!")
-             sys.exit(1)
+            print("âŒ household.age is missing!")
+            sys.exit(1)
 
         print("âœ… Verification Successful")
 
     except Exception as e:
         print(f"âŒ Verification Failed: {e}")
         import traceback
+
         traceback.print_exc()
         sys.exit(1)
 
+
 if __name__ == "__main__":
     verify_golden_load()
diff --git a/scripts/verify_great_reset_stability.py b/scripts/verify_great_reset_stability.py
index 5b8f139..e33dcf9 100644
--- a/scripts/verify_great_reset_stability.py
+++ b/scripts/verify_great_reset_stability.py
@@ -11,6 +11,7 @@ from main import create_simulation
 from utils.logging_manager import setup_logging
 import config
 
+
 # --- Verification Log Handler ---
 class VerificationLogHandler(logging.Handler):
     def __init__(self):
@@ -22,6 +23,7 @@ class VerificationLogHandler(logging.Handler):
         if "DEPOSIT_FAILURE" in msg or "ROLLBACK_FAILED" in msg:
             self.atomicity_failures.append(msg)
 
+
 def verify_great_reset_stability():
     """
     WO-115: Great Reset Stability Verification
@@ -32,7 +34,7 @@ def verify_great_reset_stability():
     setup_logging()
     verification_handler = VerificationLogHandler()
     logging.getLogger().addHandler(verification_handler)
-    
+
     logger = logging.getLogger("VERIFY")
     logger.info("Starting Great Reset Stability Verification (WO-115)...")
 
@@ -40,9 +42,9 @@ def verify_great_reset_stability():
     # Ensure stable parameters for stress test
     config.TICKS_PER_YEAR = 100
     config.GOVERNMENT_STIMULUS_ENABLED = True
-    
+
     sim = create_simulation()
-    
+
     # Baseline M2 (Zero-Sum start)
     # M2 Definition: Sum of all agent assets + bank reserves
     def get_total_m2():
@@ -51,8 +53,8 @@ def verify_great_reset_stability():
         gov_assets = sim.government.assets
         bank_assets = sim.bank.assets
         # Reflux balance (Sunk costs)
-        reflux_bal = sim.reflux_system.balance if hasattr(sim, 'reflux_system') else 0.0
-        
+        reflux_bal = sim.reflux_system.balance if hasattr(sim, "reflux_system") else 0.0
+
         return h_assets + f_assets + gov_assets + bank_assets + reflux_bal
 
     m2_start = get_total_m2()
@@ -68,25 +70,29 @@ def verify_great_reset_stability():
         except Exception as e:
             logger.critical(f"Simulation CRASHED at tick {tick}: {e}")
             break
-            
+
         # Monitor Drift
         current_m2 = get_total_m2()
         drift = current_m2 - m2_start
         drift_history.append(drift)
-        
+
         if tick % 100 == 0:
             debt_to_gdp = sim.government.get_debt_to_gdp_ratio()
-            logger.info(f"Tick {tick:4} | M2: {current_m2:,.2f} | Drift: {drift:+.4f} | Debt/GDP: {debt_to_gdp:.2%}")
+            logger.info(
+                f"Tick {tick:4} | M2: {current_m2:,.2f} | Drift: {drift:+.4f} | Debt/GDP: {debt_to_gdp:.2%}"
+            )
 
     # 4. Final Analysis
     logger.info("Simulation Complete. Finalizing Report.")
-    
+
     m2_end = get_total_m2()
     total_drift = m2_end - m2_start
-    
+
     report = []
     report.append("# Great Reset Stability Report")
-    report.append(f"**Final Status**: {'PASSED' if abs(total_drift) < 1.0 else 'FAILED'}")
+    report.append(
+        f"**Final Status**: {'PASSED' if abs(total_drift) < 1.0 else 'FAILED'}"
+    )
     report.append("")
     report.append(f"- **Start M2**: {m2_start:,.2f}")
     report.append(f"- **End M2**: {m2_end:,.2f}")
@@ -95,7 +101,9 @@ def verify_great_reset_stability():
     report.append("")
     report.append("## Atomicity Integrity")
     if verification_handler.atomicity_failures:
-        report.append(f"**FAILED**: {len(verification_handler.atomicity_failures)} failures detected.")
+        report.append(
+            f"**FAILED**: {len(verification_handler.atomicity_failures)} failures detected."
+        )
         for f in verification_handler.atomicity_failures[:5]:
             report.append(f"- {f}")
     else:
@@ -106,12 +114,15 @@ def verify_great_reset_stability():
         f.write("\n".join(report))
 
     logger.info("Report saved to reports/GREAT_RESET_REPORT.md")
-    
+
     if abs(total_drift) >= 1.0:
-        logger.error(f"CRITICAL: M2 Money Supply Drift detected! Total Leak: {total_drift:.4f}")
+        logger.error(
+            f"CRITICAL: M2 Money Supply Drift detected! Total Leak: {total_drift:.4f}"
+        )
         sys.exit(1)
-    
+
     sys.exit(0)
 
+
 if __name__ == "__main__":
     verify_great_reset_stability()
diff --git a/scripts/verify_inflation_psychology.py b/scripts/verify_inflation_psychology.py
index a6e10f5..8ede8d9 100644
--- a/scripts/verify_inflation_psychology.py
+++ b/scripts/verify_inflation_psychology.py
@@ -1,4 +1,3 @@
-
 import sys
 from pathlib import Path
 import os
@@ -10,12 +9,15 @@ from collections import deque
 sys.path.append(str(Path(__file__).resolve().parent.parent))
 
 from simulation.core_agents import Household, Talent
-from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
+from simulation.decisions.ai_driven_household_engine import (
+    AIDrivenHouseholdDecisionEngine,
+)
 from simulation.ai.api import Personality
 from simulation.dtos import DecisionContext
 from simulation.schemas import HouseholdActionVector
 import config
 
+
 class TestInflationPsychology(unittest.TestCase):
     def setUp(self):
         # Mock Config
@@ -27,12 +29,14 @@ class TestInflationPsychology(unittest.TestCase):
         self.config.DEFLATION_WAIT_THRESHOLD = -0.05
         self.config.DELAY_FACTOR = 0.5
         self.config.GOODS = {"food": {"utility_effects": {"survival": 10.0}}}
-        
+
         # Mock Dependencies
         self.mock_talent = Talent(1.0, {})
         self.mock_ai_engine = MagicMock()
-        self.mock_ai_engine.decide_action_vector.return_value = HouseholdActionVector() # Neutral
-        
+        self.mock_ai_engine.decide_action_vector.return_value = (
+            HouseholdActionVector()
+        )  # Neutral
+
         # Create Household (Impulsive to react fast)
         self.household = Household(
             id=1,
@@ -40,116 +44,122 @@ class TestInflationPsychology(unittest.TestCase):
             goods_data=[{"id": "food", "utility_effects": {"survival": 10.0}}],
             initial_assets=1000.0,
             initial_needs={"survival": 0.0},
-            decision_engine=MagicMock(), # Placeholder
+            decision_engine=MagicMock(),  # Placeholder
             value_orientation="survival",
             personality=Personality.IMPULSIVE,
-            config_module=self.config
+            config_module=self.config,
         )
-        
+
         # Attach Real Decision Engine
         self.decision_engine = AIDrivenHouseholdDecisionEngine(
-            ai_engine=self.mock_ai_engine,
-            config_module=self.config
+            ai_engine=self.mock_ai_engine, config_module=self.config
         )
         self.household.decision_engine = self.decision_engine
 
     def test_panic_buying_scenario(self):
         """Verify Hoarding when Price Rises rapidly"""
         print("\n--- Testing Panic Buying (Inflation) ---")
-        
+
         # 1. Feed Price History (Rising 10% per tick)
         prices = [10.0, 11.0, 12.1, 13.3, 14.6]
-        
+
         for p in prices:
             market_data = {"goods_market": {"food_avg_traded_price": p}}
             self.household.update_perceived_prices(market_data)
-            print(f"Price: {p}, Expected Inflation: {self.household.expected_inflation['food']:.2%}")
-            
+            print(
+                f"Price: {p}, Expected Inflation: {self.household.expected_inflation['food']:.2%}"
+            )
+
         # Check Expectation
         expected = self.household.expected_inflation["food"]
         self.assertGreater(expected, 0.05, "Agent should expect high inflation (>5%)")
-        
+
         # 2. Make Decision
         context = DecisionContext(
             household=self.household,
             markets={},
             goods_data=[],
             market_data={"goods_market": {"food_avg_traded_price": 14.6}},
-            current_time=10
+            current_time=10,
         )
-        
+
         # Mock Config for Needs
-        self.config.BULK_BUY_NEED_THRESHOLD = 100.0 # Don't bulk buy due to need
+        self.config.BULK_BUY_NEED_THRESHOLD = 100.0  # Don't bulk buy due to need
         self.config.BULK_BUY_AGG_THRESHOLD = 1.0
-        self.household.needs["survival"] = 50.0 # Moderate need
-        
+        self.household.needs["survival"] = 50.0  # Moderate need
+
         orders, _ = self.decision_engine.make_decisions(context)
-        
+
         # 3. Verify Hoarding
         # Base Qty = 1.0 (Need 50 isn't urgent enough for max_q)
         # Hoarding Factor = 0.5 -> Expect 1.5 -> Rounded to 1 or 2?
         # Order logic: max(1, int(target_quantity))
-        # 1.0 * 1.5 = 1.5 -> int(1.5) = 1. 
+        # 1.0 * 1.5 = 1.5 -> int(1.5) = 1.
         # Wait, int(1.5) is 1. Hoarding effect lost in integer conversion?
         # Let's check target_quantity float value if possible, or increase base need.
-        
+
         # Let's force Base Qty to 2.0 via Aggressiveness mock
-        self.mock_ai_engine.decide_action_vector.return_value = HouseholdActionVector(consumption_aggressiveness={"food": 0.9})
+        self.mock_ai_engine.decide_action_vector.return_value = HouseholdActionVector(
+            consumption_aggressiveness={"food": 0.9}
+        )
         # 0.9 agg might trigger Bulk Buy Moderate?
         # config.BULK_BUY_AGG_THRESHOLD defaults?
-        
+
         buy_order = next((o for o in orders if o.item_id == "food"), None)
         print(f"Buy Order Quantity: {buy_order.quantity if buy_order else 0}")
-        
-        # If Logic works, it should be > 1. 
+
+        # If Logic works, it should be > 1.
         # With agg 0.9, bulk buy might trigger base 3-5?
-        
+
         self.assertIsNotNone(buy_order)
         # We assume panic buying *increases* the quantity.
         # Let's compare against a Control Group (Neutral Expectation).
-        
+
     def test_deflationary_wait_scenario(self):
         """Verify Delay when Price Drops rapidly"""
         print("\n--- Testing Deflationary Wait (Deflation) ---")
-        
+
         # 1. Feed Price History (Dropping 10% per tick)
-        prices = [20.0, 18.0, 16.2, 14.6, 13.1] # -10% per tick
-        
+        prices = [20.0, 18.0, 16.2, 14.6, 13.1]  # -10% per tick
+
         # Reset household memory
         self.household.price_history["food"].clear()
         self.household.expected_inflation["food"] = 0.0
-        
+
         for p in prices:
             market_data = {"goods_market": {"food_avg_traded_price": p}}
             self.household.update_perceived_prices(market_data)
-            print(f"Price: {p}, Expected Inflation: {self.household.expected_inflation['food']:.2%}")
-            
+            print(
+                f"Price: {p}, Expected Inflation: {self.household.expected_inflation['food']:.2%}"
+            )
+
         expected = self.household.expected_inflation["food"]
         self.assertLess(expected, -0.05, "Agent should expect deflation (<-5%)")
-        
+
         # 2. Make Decision
         # Ensure base buy would be > 1 so we can see reduction
-        self.household.needs["survival"] = 80.0 # High need -> Bulk Buy (Base 10?)
+        self.household.needs["survival"] = 80.0  # High need -> Bulk Buy (Base 10?)
         self.config.BULK_BUY_NEED_THRESHOLD = 70.0
         self.config.HOUSEHOLD_MAX_PURCHASE_QUANTITY = 10.0
-        
+
         # Create Context
         context = DecisionContext(
             household=self.household,
             markets={},
             goods_data=[],
             market_data={"goods_market": {"food_avg_traded_price": 13.1}},
-            current_time=20
+            current_time=20,
         )
-        
+
         orders, _ = self.decision_engine.make_decisions(context)
-        
+
         buy_order = next((o for o in orders if o.item_id == "food"), None)
         qty = buy_order.quantity if buy_order else 0
         print(f"Buy Order Quantity (Deflation): {qty}")
-        
+
         # Should be reduced by DELAY_FACTOR (0.5). Base 10 -> 5.
         self.assertLess(qty, 10, "Should have delayed/reduced consumption")
 
+
 if __name__ == "__main__":
     unittest.main()
diff --git a/scripts/verify_innovation.py b/scripts/verify_innovation.py
index 3034d05..4fce46b 100644
--- a/scripts/verify_innovation.py
+++ b/scripts/verify_innovation.py
@@ -1,4 +1,3 @@
-
 import logging
 import sys
 from pathlib import Path
@@ -16,6 +15,7 @@ from simulation.firms import Firm
 import config as default_config
 from types import SimpleNamespace
 
+
 # Mock Config class
 class Config:
     def __init__(self):
@@ -23,12 +23,15 @@ class Config:
         for key in dir(default_config):
             if not key.startswith("__"):
                 setattr(self, key, getattr(default_config, key))
+
     def update(self, overrides):
         for k, v in overrides.items():
             setattr(self, k, v)
+
     def __getattr__(self, name):
-         # Fallback
-         return getattr(default_config, name, None)
+        # Fallback
+        return getattr(default_config, name, None)
+
 
 GOODS = default_config.GOODS
 
@@ -58,37 +61,46 @@ def run_verification():
     # We can't import create_simulation directly if it depends on config being set up
     # So we used the EconomyEngine directly or import from correct place.
     # Assuming 'from main import create_simulation' works if we are at root.
-    
+
     try:
         from main import create_simulation
+
         sim = create_simulation(overrides)
     except ImportError:
-         # Fallback if main.py structure differs
+        # Fallback if main.py structure differs
         config = Config()
         config.update(overrides)
         # Mock dependencies for Simulation
-        sim = EconomyEngine(households=[], firms=[], ai_trainer=None, repository=None, config_module=config)
+        sim = EconomyEngine(
+            households=[],
+            firms=[],
+            ai_trainer=None,
+            repository=None,
+            config_module=config,
+        )
 
     def force_conservative_vector(*args, **kwargs):
         from simulation.schemas import FirmActionVector
+
         return FirmActionVector(
             sales_aggressiveness=0.5,
             hiring_aggressiveness=0.5,
-            rd_aggressiveness=0.1, # Low R&D
+            rd_aggressiveness=0.1,  # Low R&D
             dividend_aggressiveness=0.8,
             capital_aggressiveness=0.1,
-            debt_aggressiveness=0.0
+            debt_aggressiveness=0.0,
         )
 
     def force_visionary_vector(*args, **kwargs):
         from simulation.schemas import FirmActionVector
+
         return FirmActionVector(
             sales_aggressiveness=0.5,
             hiring_aggressiveness=0.5,
-            rd_aggressiveness=0.9, # High R&D
+            rd_aggressiveness=0.9,  # High R&D
             dividend_aggressiveness=0.0,
             capital_aggressiveness=0.8,
-            debt_aggressiveness=0.5
+            debt_aggressiveness=0.5,
         )
 
     # Manually instantiate Engines
@@ -97,8 +109,10 @@ def run_verification():
 
     # Conservative Engine
     ai_engine_c = FirmAI(agent_id="1001", ai_decision_engine=None)
-    decision_engine_c = AIDrivenFirmDecisionEngine(ai_engine_c, sim.config_module, logger)
-    decision_engine_c.ai_engine.decide_action_vector = force_conservative_vector 
+    decision_engine_c = AIDrivenFirmDecisionEngine(
+        ai_engine_c, sim.config_module, logger
+    )
+    decision_engine_c.ai_engine.decide_action_vector = force_conservative_vector
 
     firm_c = Firm(
         id=1001,
@@ -110,14 +124,16 @@ def run_verification():
         value_orientation="profit",
         config_module=sim.config_module,
         personality=Personality.CASH_COW,
-        logger=logger
+        logger=logger,
     )
     # Ensure attributes exist
     firm_c.base_quality = 1.0
 
     # Visionary Engine
     ai_engine_v = FirmAI(agent_id="1002", ai_decision_engine=None)
-    decision_engine_v = AIDrivenFirmDecisionEngine(ai_engine_v, sim.config_module, logger)
+    decision_engine_v = AIDrivenFirmDecisionEngine(
+        ai_engine_v, sim.config_module, logger
+    )
     decision_engine_v.ai_engine.decide_action_vector = force_visionary_vector
 
     firm_v = Firm(
@@ -130,7 +146,7 @@ def run_verification():
         value_orientation="growth",
         config_module=sim.config_module,
         personality=Personality.GROWTH_HACKER,
-        logger=logger
+        logger=logger,
     )
     firm_v.base_quality = 1.0
 
@@ -159,9 +175,12 @@ def run_verification():
     # Data Collection
     history = {
         "tick": [],
-        "c_quality": [], "v_quality": [],
-        "c_prod": [], "v_prod": [],
-        "c_assets": [], "v_assets": []
+        "c_quality": [],
+        "v_quality": [],
+        "c_prod": [],
+        "v_prod": [],
+        "c_assets": [],
+        "v_assets": [],
     }
 
     print("Starting Innovation War Verification...")
@@ -169,19 +188,21 @@ def run_verification():
         # Give them revenue so they can do R&D
         firm_c.revenue_last_tick = 2000.0
         firm_v.revenue_last_tick = 2000.0
-        
+
         sim.run_tick()
 
         history["tick"].append(tick)
-        history["c_quality"].append(getattr(firm_c, 'base_quality', 1.0))
-        history["v_quality"].append(getattr(firm_v, 'base_quality', 1.0))
+        history["c_quality"].append(getattr(firm_c, "base_quality", 1.0))
+        history["v_quality"].append(getattr(firm_v, "base_quality", 1.0))
         history["c_prod"].append(firm_c.productivity_factor)
         history["v_prod"].append(firm_v.productivity_factor)
         history["c_assets"].append(firm_c.assets)
         history["v_assets"].append(firm_v.assets)
 
         if tick % 20 == 0:
-            print(f"Tick {tick}: C_Qual={firm_c.base_quality:.2f} V_Qual={firm_v.base_quality:.2f}")
+            print(
+                f"Tick {tick}: C_Qual={firm_c.base_quality:.2f} V_Qual={firm_v.base_quality:.2f}"
+            )
 
     # Analysis
     final_v_qual = history["v_quality"][-1]
@@ -201,8 +222,18 @@ def run_verification():
         if not os.path.exists("reports"):
             os.makedirs("reports")
         plt.figure(figsize=(10, 6))
-        plt.plot(history["tick"], history["c_quality"], label="Conservative (Cash Cow)", linestyle="--")
-        plt.plot(history["tick"], history["v_quality"], label="Visionary (Growth Hacker)", linewidth=2)
+        plt.plot(
+            history["tick"],
+            history["c_quality"],
+            label="Conservative (Cash Cow)",
+            linestyle="--",
+        )
+        plt.plot(
+            history["tick"],
+            history["v_quality"],
+            label="Visionary (Growth Hacker)",
+            linewidth=2,
+        )
         plt.title("Innovation War: Quality Trajectory")
         plt.xlabel("Tick")
         plt.ylabel("Base Product Quality")
@@ -212,5 +243,6 @@ def run_verification():
     except Exception as e:
         print(f"Plotting failed: {e}")
 
+
 if __name__ == "__main__":
     run_verification()
diff --git a/scripts/verify_ma_bankruptcy.py b/scripts/verify_ma_bankruptcy.py
index 2f1ebc7..9bdf7a5 100644
--- a/scripts/verify_ma_bankruptcy.py
+++ b/scripts/verify_ma_bankruptcy.py
@@ -12,12 +12,14 @@ from simulation.firms import Firm
 from simulation.systems.ma_manager import MAManager
 import config as Config
 
+
 class MockSimulation:
     def __init__(self, firms, households_dict):
         self.firms = firms
         self.households_dict = households_dict
         self.time = 0
 
+
 class TestPhase9MA(unittest.TestCase):
     def setUp(self):
         logging.basicConfig(level=logging.ERROR)
@@ -29,41 +31,43 @@ class TestPhase9MA(unittest.TestCase):
 
         # Create Mock Firms
         self.predator = Firm(
-            id=1, 
-            initial_capital=100000.0, 
+            id=1,
+            initial_capital=100000.0,
             initial_liquidity_need=100.0,
             specialization="widget",
             productivity_factor=1.0,
             decision_engine=MagicMock(),
             value_orientation="PROFIT",
-            config_module=self.config, 
-            logger=logging.getLogger("Predator")
+            config_module=self.config,
+            logger=logging.getLogger("Predator"),
         )
         self.predator.name = "Predator Corp"
         self.predator.profit_history = [100.0] * 10
-        self.predator.current_profit = 100.0 # Set current profit for logic check
+        self.predator.current_profit = 100.0  # Set current profit for logic check
         self.predator.capital_stock = 10.0
         self.predator.inventory = {"widget": 0}
         self.predator.employees = []
 
         self.prey = Firm(
-            id=2, 
-            initial_capital=1000.0, 
+            id=2,
+            initial_capital=1000.0,
             initial_liquidity_need=100.0,
             specialization="widget",
             productivity_factor=1.0,
             decision_engine=MagicMock(),
             value_orientation="PROFIT",
-            config_module=self.config, 
-            logger=logging.getLogger("Prey")
+            config_module=self.config,
+            logger=logging.getLogger("Prey"),
         )
         self.prey.name = "Prey Inc"
         self.prey.profit_history = [-10.0] * 10
         self.prey.capital_stock = 5.0
         self.prey.inventory = {"widget": 20}
         self.prey.founder_id = 999
-        self.prey.consecutive_loss_ticks = 25 # Trigger potential bankruptcy risk if threshold hit
-        
+        self.prey.consecutive_loss_ticks = (
+            25  # Trigger potential bankruptcy risk if threshold hit
+        )
+
         # Create Dummy Employee
         emp_mock = MagicMock()
         emp_mock.id = 101
@@ -83,16 +87,16 @@ class TestPhase9MA(unittest.TestCase):
         # Assume widget price 0? Firm.get_inventory_value checks last_prices.
         # Let's set last_prices for Prey
         self.prey.last_prices["widget"] = 10.0
-        inventory_value = 20 * 10.0 # 200
-        # Capital Stock: logic in calculate_valuation uses capital_stock value? 
+        inventory_value = 20 * 10.0  # 200
+        # Capital Stock: logic in calculate_valuation uses capital_stock value?
         # Code: net_assets = self.capital + self.get_inventory_value() + self.capital_stock
-        # Note: capital_stock is a float quantity. If it's just added, 5.0 is small. 
+        # Note: capital_stock is a float quantity. If it's just added, 5.0 is small.
         # But let's stick to implementation logic.
-        
-        net_assets = 1000.0 + 200.0 + 5.0 # 1205.0
+
+        net_assets = 1000.0 + 200.0 + 5.0  # 1205.0
         # Profit Premium: Max(0, -10) * 10 = 0
         expected_valuation = 1205.0
-        
+
         self.prey.calculate_valuation()
         self.assertAlmostEqual(self.prey.valuation, expected_valuation, delta=1.0)
 
@@ -100,36 +104,46 @@ class TestPhase9MA(unittest.TestCase):
         # Setup conditions for acquisition
         # Predator Cash 100k > Prey Valuation (~1.2k) * 1.1
         self.prey.last_prices["widget"] = 10.0
-        
+
         # Run Manager
         self.ma_manager.process_market_exits_and_entries(current_tick=1)
-        
+
         # Assertions
         # 1. Prey should be inactive
         self.assertFalse(self.prey.is_active, "Prey should be inactive (acquired)")
-        
+
         # 2. Predator Capital should decrease
         # Offer ~ 1205 * 1.1 = 1325.5
-        self.assertTrue(self.predator.assets < 100000.0, "Predator capital should decrease")
-        
-        
+        self.assertTrue(
+            self.predator.assets < 100000.0, "Predator capital should decrease"
+        )
+
         # 3. Predator Inventory/Capital Stock increase
-        self.assertEqual(self.predator.inventory.get("widget", 0), 20, "Predator should get inventory")
-        self.assertEqual(self.predator.capital_stock, 15.0, "Predator should get capital stock (10+5)")
-        
+        self.assertEqual(
+            self.predator.inventory.get("widget", 0),
+            20,
+            "Predator should get inventory",
+        )
+        self.assertEqual(
+            self.predator.capital_stock,
+            15.0,
+            "Predator should get capital stock (10+5)",
+        )
+
         # 4. Founder Payout
-        self.assertTrue(self.households_dict[999].assets > 0, "Founder should receive payout")
+        self.assertTrue(
+            self.households_dict[999].assets > 0, "Founder should receive payout"
+        )
 
     def test_bankruptcy_liquidation(self):
         # Make Prey insolvent and poor so it can't be acquired (or just isolate it)
         self.prey.assets = -500.0
         self.prey.last_prices["widget"] = 10.0
-        self.sim.firms = [self.prey] # No predator
-        
-        
+        self.sim.firms = [self.prey]  # No predator
+
         # Run Manager
         self.ma_manager.process_market_exits_and_entries(current_tick=1)
-        
+
         # Assertions
         self.assertFalse(self.prey.is_active, "Prey should be inactive (liquidated)")
         self.assertTrue(self.prey.is_bankrupt, "Prey should be marked bankrupt")
@@ -140,5 +154,6 @@ class TestPhase9MA(unittest.TestCase):
         # Final Capital = -500 + 125 = -375.
         self.assertAlmostEqual(self.prey.assets, -375.0, delta=1.0)
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     unittest.main()
diff --git a/scripts/verify_maslow.py b/scripts/verify_maslow.py
index 3a25b40..709bf73 100644
--- a/scripts/verify_maslow.py
+++ b/scripts/verify_maslow.py
@@ -1,4 +1,3 @@
-
 import sys
 from pathlib import Path
 import os
@@ -12,6 +11,7 @@ import config
 from simulation.ai.household_ai import HouseholdAI
 from simulation.schemas import HouseholdActionVector
 
+
 class TestMaslowVerification(unittest.TestCase):
     def setUp(self):
         # Mock Decision Engine and Config
@@ -20,8 +20,7 @@ class TestMaslowVerification(unittest.TestCase):
 
         # Initialize HouseholdAI
         self.ai = HouseholdAI(
-            agent_id="test_household",
-            ai_decision_engine=self.mock_decision_engine
+            agent_id="test_household", ai_decision_engine=self.mock_decision_engine
         )
 
         # Define goods list
@@ -43,29 +42,40 @@ class TestMaslowVerification(unittest.TestCase):
         # Mock Data: Survival Need > Threshold (50.0)
         agent_data = {
             "assets": 1000.0,
-            "needs": {"survival": 80.0}, # Starving!
-            "inventory": {}
+            "needs": {"survival": 80.0},  # Starving!
+            "inventory": {},
         }
         market_data = {}
 
         # Execute Decision
-        action_vector = self.ai.decide_action_vector(agent_data, market_data, self.goods_list)
+        action_vector = self.ai.decide_action_vector(
+            agent_data, market_data, self.goods_list
+        )
 
         # Verify Results
         print(f"Action Vector: {action_vector}")
 
         # 1. Survival Goods (basic_food) should be aggressive (1.0)
-        self.assertEqual(action_vector.consumption_aggressiveness.get("basic_food"), 1.0,
-                         "Survival good (basic_food) should not be gated.")
+        self.assertEqual(
+            action_vector.consumption_aggressiveness.get("basic_food"),
+            1.0,
+            "Survival good (basic_food) should not be gated.",
+        )
 
         # 2. Non-Survival Goods (education_service) should be 0.0
         # education_service has utility {improvement: 15}, survival: 0 (implicit)
-        self.assertEqual(action_vector.consumption_aggressiveness.get("education_service"), 0.0,
-                         "Non-survival good (education_service) should be gated to 0.0.")
+        self.assertEqual(
+            action_vector.consumption_aggressiveness.get("education_service"),
+            0.0,
+            "Non-survival good (education_service) should be gated to 0.0.",
+        )
 
         # 3. Investment should be 0.0
-        self.assertEqual(action_vector.investment_aggressiveness, 0.0,
-                         "Investment should be gated to 0.0 when starving.")
+        self.assertEqual(
+            action_vector.investment_aggressiveness,
+            0.0,
+            "Investment should be gated to 0.0 when starving.",
+        )
 
         print("âœ… Maslow Gating Verified: Starving agents focus on survival.")
 
@@ -75,26 +85,35 @@ class TestMaslowVerification(unittest.TestCase):
         # Mock Data: Survival Need < Threshold (50.0)
         agent_data = {
             "assets": 1000.0,
-            "needs": {"survival": 20.0}, # Not Starving
-            "inventory": {}
+            "needs": {"survival": 20.0},  # Not Starving
+            "inventory": {},
         }
         market_data = {}
 
         # Execute Decision
-        action_vector = self.ai.decide_action_vector(agent_data, market_data, self.goods_list)
+        action_vector = self.ai.decide_action_vector(
+            agent_data, market_data, self.goods_list
+        )
 
         # Verify Results
         print(f"Action Vector: {action_vector}")
 
         # 1. Non-Survival Goods (education_service) should NOT be gated
-        self.assertEqual(action_vector.consumption_aggressiveness.get("education_service"), 1.0,
-                         "Non-survival good (education_service) should NOT be gated when not starving.")
+        self.assertEqual(
+            action_vector.consumption_aggressiveness.get("education_service"),
+            1.0,
+            "Non-survival good (education_service) should NOT be gated when not starving.",
+        )
 
         # 3. Investment should NOT be 0.0 (since assets > 500)
-        self.assertEqual(action_vector.investment_aggressiveness, 1.0,
-                         "Investment should NOT be gated when not starving.")
+        self.assertEqual(
+            action_vector.investment_aggressiveness,
+            1.0,
+            "Investment should NOT be gated when not starving.",
+        )
 
         print("âœ… Maslow Gating Verified: Normal agents can pursue other goals.")
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     unittest.main()
diff --git a/scripts/verify_monetary_policy.py b/scripts/verify_monetary_policy.py
index bc9b63e..e135b38 100644
--- a/scripts/verify_monetary_policy.py
+++ b/scripts/verify_monetary_policy.py
@@ -1,23 +1,29 @@
-
 import sys
 from pathlib import Path
 import os
+
 sys.path.append(str(Path(__file__).resolve().parent.parent))
 
 import unittest
 from unittest.mock import MagicMock
 from simulation.agents.central_bank import CentralBank
 
+
 class MockTracker:
     def __init__(self):
         self.metrics = {"avg_goods_price": [], "total_production": []}
 
     def get_latest_indicators(self):
         return {
-            "avg_goods_price": self.metrics["avg_goods_price"][-1] if self.metrics["avg_goods_price"] else 0,
-            "total_production": self.metrics["total_production"][-1] if self.metrics["total_production"] else 0
+            "avg_goods_price": self.metrics["avg_goods_price"][-1]
+            if self.metrics["avg_goods_price"]
+            else 0,
+            "total_production": self.metrics["total_production"][-1]
+            if self.metrics["total_production"]
+            else 0,
         }
 
+
 class MockConfig:
     INITIAL_BASE_ANNUAL_RATE = 0.05
     CB_UPDATE_INTERVAL = 5
@@ -26,6 +32,7 @@ class MockConfig:
     CB_TAYLOR_BETA = 0.5
     TICKS_PER_YEAR = 100
 
+
 class TestCentralBank(unittest.TestCase):
     def setUp(self):
         self.tracker = MockTracker()
@@ -70,7 +77,7 @@ class TestCentralBank(unittest.TestCase):
         self.tracker.metrics["avg_goods_price"].append(100.2)
 
         self.tracker.metrics["total_production"] = [100.0] * 6
-        self.cb.potential_gdp = 100.0 # No output gap
+        self.cb.potential_gdp = 100.0  # No output gap
 
         # Expected Taylor Rate:
         # i = 0.02 (neutral) + 0.04 (infl) + 1.5 * (0.04 - 0.02) + 0.5 * 0
@@ -136,5 +143,6 @@ class TestCentralBank(unittest.TestCase):
 
         self.assertEqual(self.cb.base_rate, 0.0)
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     unittest.main()
diff --git a/scripts/verify_phase23_harvest.py b/scripts/verify_phase23_harvest.py
index fd5119d..bcd6638 100644
--- a/scripts/verify_phase23_harvest.py
+++ b/scripts/verify_phase23_harvest.py
@@ -1,4 +1,3 @@
-
 import logging
 import sys
 import os
@@ -12,14 +11,20 @@ from collections import defaultdict
 sys.path.append(os.getcwd())
 
 # Setup Logging
-logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
+logging.basicConfig(
+    level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
+)
 logger = logging.getLogger("Phase23Verify")
 
 # Import Simulation Components
 import config as Config
 from simulation.dtos.api import SimulationState, DecisionContext
-from simulation.decisions.standalone_rule_based_firm_engine import StandaloneRuleBasedFirmDecisionEngine
-from simulation.decisions.rule_based_household_engine import RuleBasedHouseholdDecisionEngine
+from simulation.decisions.standalone_rule_based_firm_engine import (
+    StandaloneRuleBasedFirmDecisionEngine,
+)
+from simulation.decisions.rule_based_household_engine import (
+    RuleBasedHouseholdDecisionEngine,
+)
 from simulation.systems.demographic_manager import DemographicManager
 from simulation.initialization.initializer import SimulationInitializer
 from simulation.core_agents import Household, Talent, Personality
@@ -33,25 +38,26 @@ from simulation.components.psychology_component import PsychologyComponent
 # 0. Forensics Patch for Death (Kept for Debugging visibility)
 original_log_death = PsychologyComponent._log_death
 
+
 def patched_log_death(self, current_tick, market_data):
     # Print critical info to stdout for debugging
     print(f"\n[AUTOPSY] Agent {self.owner.id} DIED at Tick {current_tick}")
     print(f"  - Survival Need: {self.owner.needs.get('survival', 'N/A')}")
     print(f"  - Assets: {self.owner.assets}")
     print(f"  - Inventory: {self.owner.inventory}")
-    print(f"  - Thresholds: Survival={self.config.SURVIVAL_NEED_DEATH_THRESHOLD}, Assets={self.config.ASSETS_DEATH_THRESHOLD}")
+    print(
+        f"  - Thresholds: Survival={self.config.SURVIVAL_NEED_DEATH_THRESHOLD}, Assets={self.config.ASSETS_DEATH_THRESHOLD}"
+    )
     original_log_death(self, current_tick, market_data)
 
+
 PsychologyComponent._log_death = patched_log_death
 
+
 class Phase23Verifier:
     def __init__(self):
         self.sim = None
-        self.metrics = {
-            "population": [],
-            "avg_price_food": [],
-            "total_inventory": []
-        }
+        self.metrics = {"population": [], "avg_price_food": [], "total_inventory": []}
 
     def setup_scenario(self):
         logger.info("--- Starting Verification (Final): Phase 23 The Great Harvest ---")
@@ -83,9 +89,9 @@ class Phase23Verifier:
 
         # Optimize Consumption for Survival
         Config.TARGET_FOOD_BUFFER_QUANTITY = 50.0  # Keep 50 ticks of food
-        Config.FOOD_PURCHASE_MAX_PER_TICK = 50.0   # Allow bulk buy
-        Config.HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK = 1.0 # Standard consumption
-        Config.SURVIVAL_CRITICAL_TURNS = 10 # Give them more time before panic
+        Config.FOOD_PURCHASE_MAX_PER_TICK = 50.0  # Allow bulk buy
+        Config.HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK = 1.0  # Standard consumption
+        Config.SURVIVAL_CRITICAL_TURNS = 10  # Give them more time before panic
 
         # --- DYNAMIC OVERRIDES (Moved from config.py) ---
         # WO-110: Use RuleBased Engine for newborns to ensure survival
@@ -94,7 +100,7 @@ class Phase23Verifier:
         # Relax Death Conditions
         Config.SURVIVAL_NEED_DEATH_THRESHOLD = 200.0
         Config.HOUSEHOLD_DEATH_TURNS_THRESHOLD = 50
-        Config.BASE_DESIRE_GROWTH = 0.5 # Slower Hunger
+        Config.BASE_DESIRE_GROWTH = 0.5  # Slower Hunger
         Config.FOOD_CONSUMPTION_QUANTITY = 5.0
 
         # Boost Reproduction (Simulating 'Cheap Food' effect)
@@ -110,44 +116,48 @@ class Phase23Verifier:
         goods_data_list = []
         for gid, ginfo in Config.GOODS.items():
             entry = ginfo.copy()
-            entry['id'] = gid
-            entry['name'] = gid
+            entry["id"] = gid
+            entry["name"] = gid
             goods_data_list.append(entry)
 
         # 3. Create Agents
         households = []
         for i in range(50):
             # Create Engine First
-            engine = RuleBasedHouseholdDecisionEngine(config_module=Config, logger=logger)
+            engine = RuleBasedHouseholdDecisionEngine(
+                config_module=Config, logger=logger
+            )
 
             hh = Household(
                 id=i,
                 talent=Talent(base_learning_rate=0.1, max_potential=1.0),
                 goods_data=goods_data_list,
-                initial_assets=500.0, # Generous start
-                initial_needs={"survival": 0.0}, # Start FULL (0 hunger)
+                initial_assets=500.0,  # Generous start
+                initial_needs={"survival": 0.0},  # Start FULL (0 hunger)
                 decision_engine=engine,
                 value_orientation="wealth_and_needs",
                 personality=Personality.CONSERVATIVE,
-                config_module=Config
+                config_module=Config,
             )
             households.append(hh)
 
         firms = []
         for i in range(10):
             # Create Engine First
-            f_engine = StandaloneRuleBasedFirmDecisionEngine(config_module=Config, logger=logger)
+            f_engine = StandaloneRuleBasedFirmDecisionEngine(
+                config_module=Config, logger=logger
+            )
 
             firm = Firm(
-                id=1000+i,
-                initial_capital=1_000_000.0, # Massive Capital Injection
+                id=1000 + i,
+                initial_capital=1_000_000.0,  # Massive Capital Injection
                 initial_liquidity_need=100.0,
                 specialization="basic_food",
                 productivity_factor=1.0,
                 decision_engine=f_engine,
                 value_orientation="profit",
                 config_module=Config,
-                initial_inventory={"basic_food": 50.0}
+                initial_inventory={"basic_food": 50.0},
             )
             firms.append(firm)
 
@@ -160,7 +170,7 @@ class Phase23Verifier:
             logger=logger,
             households=households,
             firms=firms,
-            ai_trainer=mock_ai_trainer
+            ai_trainer=mock_ai_trainer,
         )
 
         self.sim = initializer.build_simulation()
@@ -182,11 +192,11 @@ class Phase23Verifier:
 
             # If 0, try best ask
             if avg_price == 0 and food_market:
-                 asks = []
-                 for item_orders in food_market.sell_orders.values():
-                     asks.extend([o.price for o in item_orders])
-                 if asks:
-                     avg_price = min(asks)
+                asks = []
+                for item_orders in food_market.sell_orders.values():
+                    asks.extend([o.price for o in item_orders])
+                if asks:
+                    avg_price = min(asks)
 
             total_inv = sum(f.inventory.get("basic_food", 0) for f in self.sim.firms)
 
@@ -196,7 +206,9 @@ class Phase23Verifier:
 
             # Log periodic check
             if tick % 50 == 0:
-                logger.info(f"STATUS Tick {tick}: Pop={pop}, Price={avg_price:.2f}, Inv={total_inv:.2f}")
+                logger.info(
+                    f"STATUS Tick {tick}: Pop={pop}, Price={avg_price:.2f}, Inv={total_inv:.2f}"
+                )
 
             logger.info(f"--- Ending Tick {tick} ---")
 
@@ -230,22 +242,42 @@ class Phase23Verifier:
                 f.write("## Executive Summary\n")
                 f.write("| Metric | Initial | Final | Result |\n")
                 f.write("|---|---|---|---|\n")
-                f.write(f"| Food Price | {price_start:.2f} | {price_end:.2f} | Deflationary Stability |\n")
-                f.write(f"| Population | {start_pop} | {end_pop} | {growth:.2f}x Growth |\n\n")
+                f.write(
+                    f"| Food Price | {price_start:.2f} | {price_end:.2f} | Deflationary Stability |\n"
+                )
+                f.write(
+                    f"| Population | {start_pop} | {end_pop} | {growth:.2f}x Growth |\n\n"
+                )
 
                 f.write("## ğŸ† VICTORY DECLARATION ğŸ†\n")
                 f.write("**We have broken the Malthusian Trap!**\n\n")
-                f.write("The simulation confirms that with high productivity and efficient market clearing (low price floor), ")
-                f.write("food becomes abundant and cheap, driving massive population growth without mass starvation.\n")
-                f.write("The key fix was ensuring newborn agents use `RuleBasedHouseholdDecisionEngine` to survive infancy, ")
-                f.write("coupled with a low `MIN_SELL_PRICE` to prevent inventory gluts.\n\n")
+                f.write(
+                    "The simulation confirms that with high productivity and efficient market clearing (low price floor), "
+                )
+                f.write(
+                    "food becomes abundant and cheap, driving massive population growth without mass starvation.\n"
+                )
+                f.write(
+                    "The key fix was ensuring newborn agents use `RuleBasedHouseholdDecisionEngine` to survive infancy, "
+                )
+                f.write(
+                    "coupled with a low `MIN_SELL_PRICE` to prevent inventory gluts.\n\n"
+                )
 
                 f.write("## Log Analysis: Sequential Execution Pipeline\n")
-                f.write("The logs confirm the separation of concerns within a single tick:\n")
-                f.write("1. **Planning**: Firms adjust production targets based on inventory signals.\n")
-                f.write("2. **Operation**: Firms hire or fire based on the *new* targets.\n")
+                f.write(
+                    "The logs confirm the separation of concerns within a single tick:\n"
+                )
+                f.write(
+                    "1. **Planning**: Firms adjust production targets based on inventory signals.\n"
+                )
+                f.write(
+                    "2. **Operation**: Firms hire or fire based on the *new* targets.\n"
+                )
                 f.write("3. **Commerce**: Firms adjust prices and execute sales.\n\n")
-                f.write("Observation of 'Overstock -> Target Reduction -> Price Cut' loops confirms market responsiveness.\n")
+                f.write(
+                    "Observation of 'Overstock -> Target Reduction -> Price Cut' loops confirms market responsiveness.\n"
+                )
 
         else:
             logger.info("VERDICT: FAILED - Population Stagnant or Crashed.")
@@ -255,7 +287,15 @@ class Phase23Verifier:
             writer = csv.writer(f)
             writer.writerow(["Tick", "Pop", "Price", "Inventory"])
             for i in range(len(self.metrics["population"])):
-                writer.writerow([i+1, self.metrics["population"][i], self.metrics["avg_price_food"][i], self.metrics["total_inventory"][i]])
+                writer.writerow(
+                    [
+                        i + 1,
+                        self.metrics["population"][i],
+                        self.metrics["avg_price_food"][i],
+                        self.metrics["total_inventory"][i],
+                    ]
+                )
+
 
 if __name__ == "__main__":
     v = Phase23Verifier()
diff --git a/scripts/verify_phase4.py b/scripts/verify_phase4.py
index 9aa7362..d8a0480 100644
--- a/scripts/verify_phase4.py
+++ b/scripts/verify_phase4.py
@@ -19,88 +19,95 @@ import config
 
 from simulation.ai.household_ai import HouseholdAI
 from simulation.ai.firm_ai import FirmAI
-from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
+from simulation.decisions.ai_driven_household_engine import (
+    AIDrivenHouseholdDecisionEngine,
+)
 from simulation.decisions.ai_driven_firm_engine import AIDrivenFirmDecisionEngine
 
 # Setup logging
 logging.basicConfig(level=logging.WARNING)
 
+
 def run_phase4_verification(ticks=100, output_file="phase4_verification.csv"):
     print(f"--- Starting Phase 4 Verification Run ({ticks} ticks) ---")
-    
+
     # Initialize components
     # config module is used directly
     repo = SimulationRepository()
-    
+
     state_builder = StateBuilder()
     action_proposal_engine = ActionProposalEngine(config_module=config)
     ai_registry = AIEngineRegistry(
         action_proposal_engine=action_proposal_engine, state_builder=state_builder
     )
-    
+
     # Format goods_data
-    goods_data_list = [
-        {"id": k, **v} for k, v in config.GOODS.items()
-    ]
-    
+    goods_data_list = [{"id": k, **v} for k, v in config.GOODS.items()]
+
     # Create Dummy Agents
     households = []
     for i in range(20):
         vo = "wealth_and_needs"
-        
+
         # Manually create decision engine
         ai_engine_shared = ai_registry.get_engine(vo)
         household_ai = HouseholdAI(
             agent_id=i,
             ai_decision_engine=ai_engine_shared,
-            gamma=0.9, epsilon=0.1, base_alpha=0.1, learning_focus=0.5
+            gamma=0.9,
+            epsilon=0.1,
+            base_alpha=0.1,
+            learning_focus=0.5,
         )
         decision_engine = AIDrivenHouseholdDecisionEngine(
             ai_engine=household_ai,
             config_module=config,
-            logger=logging.getLogger("dummy")
+            logger=logging.getLogger("dummy"),
         )
 
         h = Household(
             id=i,
             talent=Talent(0.1, {}),
             goods_data=goods_data_list,
-            initial_assets=1000.0 if i < 18 else 50.0, # Some poor agents
+            initial_assets=1000.0 if i < 18 else 50.0,  # Some poor agents
             initial_needs={
                 "survival": 0.0,
                 "asset": 10.0,
                 "social": 10.0,
-                "improvement": 10.0
+                "improvement": 10.0,
             },
             decision_engine=decision_engine,
             value_orientation=vo,
             personality=Personality.MISER,
-            config_module=config
+            config_module=config,
         )
         # Set some to unemployed to trigger welfare
         h.is_employed = False
         if i >= 18:
-            h.needs["survival"] = 60.0 # High need
+            h.needs["survival"] = 60.0  # High need
         households.append(h)
 
     firms = []
     # Create 1 firm to hire
     f_id = 20
-    vo_firm = "profit_max" # Or just reuse existing, Firm ignores VO usually or defaults
+    vo_firm = (
+        "profit_max"  # Or just reuse existing, Firm ignores VO usually or defaults
+    )
     # Actually Firm might share same registry or have its own. AIEngineRegistry uses VO strings.
     # Let's use "wealth_and_needs" for firm too or check if valid.
     # main.py loops over ["wealth_and_needs", "needs_and_growth", "needs_and_social_status"]
-    
+
     ai_engine_shared = ai_registry.get_engine("wealth_and_needs")
     firm_ai = FirmAI(
         agent_id=f_id,
         ai_decision_engine=ai_engine_shared,
-        gamma=0.9, epsilon=0.1, base_alpha=0.1, learning_focus=0.5
+        gamma=0.9,
+        epsilon=0.1,
+        base_alpha=0.1,
+        learning_focus=0.5,
     )
     firm_decision_engine = AIDrivenFirmDecisionEngine(
-        ai_engine=firm_ai,
-        config_module=config,
-        logger=logging.getLogger("dummy")
+        ai_engine=firm_ai, config_module=config, logger=logging.getLogger("dummy")
     )
 
     f = Firm(
@@ -111,10 +118,10 @@ def run_phase4_verification(ticks=100, output_file="phase4_verification.csv"):
         productivity_factor=10.0,
         decision_engine=firm_decision_engine,
         value_orientation=vo_firm,
-        config_module=config
+        config_module=config,
     )
     firms.append(f)
-    
+
     # Initialize Simulation
     sim = Simulation(
         households=households,
@@ -122,24 +129,26 @@ def run_phase4_verification(ticks=100, output_file="phase4_verification.csv"):
         ai_trainer=ai_registry,
         repository=repo,
         config_module=config,
-        goods_data=goods_data_list
+        goods_data=goods_data_list,
     )
 
     data_rows = []
 
     for t in range(1, ticks + 1):
         sim.run_tick()
-        
+
         # Collect Metrics
         gov = sim.government
-        
+
         # Gini
-        wealth_dist = sim.inequality_tracker.calculate_wealth_distribution(sim.households, sim.stock_market)
+        wealth_dist = sim.inequality_tracker.calculate_wealth_distribution(
+            sim.households, sim.stock_market
+        )
         gini = wealth_dist.get("gini_total_assets", 0.0)
-        
+
         # Credit Jail Count
         jailed_count = sum(1 for h in sim.households if h.credit_frozen_until_tick > t)
-        
+
         # Welfare Spending (Stimulus + Benefit)
         # Assuming run_welfare_check ran and updated Government stats
         # Note: 'welfare_spending' in current_tick_stats is reset every tick in finalize_tick
@@ -148,11 +157,11 @@ def run_phase4_verification(ticks=100, output_file="phase4_verification.csv"):
         # We can read from history.
         welfare_flow = 0.0
         tax_flow = 0.0
-        
+
         if gov.welfare_history and gov.welfare_history[-1]["tick"] == t:
             last = gov.welfare_history[-1]
             welfare_flow = last.get("welfare", 0.0) + last.get("stimulus", 0.0)
-            
+
         if gov.tax_history and gov.tax_history[-1]["tick"] == t:
             tax_flow = gov.tax_history[-1]["total"]
 
@@ -162,18 +171,20 @@ def run_phase4_verification(ticks=100, output_file="phase4_verification.csv"):
             "Welfare_Spending": welfare_flow,
             "Tax_Revenue": tax_flow,
             "Credit_Jailed_Count": jailed_count,
-            "Gov_Assets": gov.assets
+            "Gov_Assets": gov.assets,
         }
         data_rows.append(row)
-        
+
         if t % 10 == 0:
-            print(f"Tick {t}: Gini={gini:.4f}, Welfare={welfare_flow:.2f}, Tax={tax_flow:.2f}, Jailed={jailed_count}")
+            print(
+                f"Tick {t}: Gini={gini:.4f}, Welfare={welfare_flow:.2f}, Tax={tax_flow:.2f}, Jailed={jailed_count}"
+            )
 
     # Export CSV
     df = pd.DataFrame(data_rows)
     df.to_csv(output_file, index=False)
     print(f"--- Verification Complete. Data saved to {output_file} ---")
-    
+
     # Check if Welfare was paid (Logic Check)
     total_welfare = df["Welfare_Spending"].sum()
     if total_welfare > 0:
@@ -181,5 +192,6 @@ def run_phase4_verification(ticks=100, output_file="phase4_verification.csv"):
     else:
         print("âš ï¸ WARNING: No welfare payments detected. Check unemployment logic.")
 
+
 if __name__ == "__main__":
     run_phase4_verification()
diff --git a/scripts/verify_policy_reaction.py b/scripts/verify_policy_reaction.py
index 7d13a2c..ac49adb 100644
--- a/scripts/verify_policy_reaction.py
+++ b/scripts/verify_policy_reaction.py
@@ -1,4 +1,3 @@
-
 import sys
 from pathlib import Path
 import os
@@ -11,9 +10,12 @@ from main import create_simulation
 from simulation.dtos import GovernmentStateDTO
 
 # Configure logging
-logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
+logging.basicConfig(
+    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
+)
 logger = logging.getLogger("verify_policy_reaction")
 
+
 def verify_policy_reaction(num_ticks: int = 122):
     """
     Runs a simulation to verify the Central Bank's reaction to an inflation shock.
@@ -41,27 +43,34 @@ def verify_policy_reaction(num_ticks: int = 122):
         # Let's burn in for 120 ticks and inject the shock then.
         if tick == 120:
             rate_before_shock = simulation.central_bank.get_base_rate()
-            logger.info(f"Base rate before shock application at tick {tick}: {rate_before_shock:.4f}")
+            logger.info(
+                f"Base rate before shock application at tick {tick}: {rate_before_shock:.4f}"
+            )
             logger.warning(f"INJECTING INFLATION SHOCK at tick {tick}")
 
             # Create a modified DTO with a high inflation rate
             shock_dto = GovernmentStateDTO(
                 tick=tick,
                 inflation_sma=0.15,  # 15% inflation shock
-                unemployment_sma=simulation.tracker.get_latest_indicators().get("unemployment_rate", 0.05),
-                gdp_growth_sma=0, # Assume neutral growth for isolation
-                wage_sma=simulation.tracker.get_latest_indicators().get("avg_wage", 1000),
-                approval_sma=0.5, # Assume neutral approval
-                current_gdp=simulation.tracker.get_latest_indicators().get("total_production", 10000),
+                unemployment_sma=simulation.tracker.get_latest_indicators().get(
+                    "unemployment_rate", 0.05
+                ),
+                gdp_growth_sma=0,  # Assume neutral growth for isolation
+                wage_sma=simulation.tracker.get_latest_indicators().get(
+                    "avg_wage", 1000
+                ),
+                approval_sma=0.5,  # Assume neutral approval
+                current_gdp=simulation.tracker.get_latest_indicators().get(
+                    "total_production", 10000
+                ),
             )
 
         # Pass the shock DTO to run_tick, it will only be used if the tick matches
         simulation.run_tick(injectable_sensory_dto=shock_dto)
 
         if tick >= 119:
-             current_rate = simulation.central_bank.get_base_rate()
-             logger.info(f"Tick {tick}: Central Bank Base Rate: {current_rate:.4f}")
-
+            current_rate = simulation.central_bank.get_base_rate()
+            logger.info(f"Tick {tick}: Central Bank Base Rate: {current_rate:.4f}")
 
     # --- Verification Checks ---
     logger.info("--- Verification Results ---")
@@ -72,10 +81,14 @@ def verify_policy_reaction(num_ticks: int = 122):
 
     if final_base_rate > rate_before_shock:
         print("PASS: Interest Rate Increased")
-        logger.info("âœ… SUCCESS: Central Bank reacted to inflation by increasing the interest rate.")
+        logger.info(
+            "âœ… SUCCESS: Central Bank reacted to inflation by increasing the interest rate."
+        )
     else:
         print("FAIL: Interest Rate Did Not Increase")
-        logger.error("âŒ FAILURE: Central Bank did not increase the interest rate in response to the inflation shock.")
+        logger.error(
+            "âŒ FAILURE: Central Bank did not increase the interest rate in response to the inflation shock."
+        )
 
 
 if __name__ == "__main__":
diff --git a/scripts/verify_portfolio.py b/scripts/verify_portfolio.py
index b1098c8..e448526 100644
--- a/scripts/verify_portfolio.py
+++ b/scripts/verify_portfolio.py
@@ -17,9 +17,10 @@ import config
 from main import create_simulation
 
 # Configure logging
-logging.basicConfig(level=logging.INFO, format='%(message)s')
+logging.basicConfig(level=logging.INFO, format="%(message)s")
 logger = logging.getLogger("verify_portfolio")
 
+
 def run_verification(output_file: str = "reports/verify_portfolio.png"):
     """
     Scenario:
@@ -36,9 +37,9 @@ def run_verification(output_file: str = "reports/verify_portfolio.png"):
     overrides = {
         "SIMULATION_TICKS": 100,
         "INITIAL_BASE_ANNUAL_RATE": 0.05,
-        "CB_UPDATE_INTERVAL": 1000, # Disable auto-update to control manually
+        "CB_UPDATE_INTERVAL": 1000,  # Disable auto-update to control manually
         "STARTUP_COST": 10000.0,
-        "EXPECTED_STARTUP_ROI": 0.15, # Fixed expectation
+        "EXPECTED_STARTUP_ROI": 0.15,  # Fixed expectation
     }
 
     sim = create_simulation(overrides=overrides)
@@ -61,14 +62,17 @@ def run_verification(output_file: str = "reports/verify_portfolio.png"):
     logger.info("Running High Rate Phase (Rate 20%)...")
     for t in range(50):
         sim.run_tick()
-        record_metrics(sim, 50+t, "HighRate")
+        record_metrics(sim, 50 + t, "HighRate")
 
     # 5. Analysis
     df = pd.DataFrame(sim.history_data)
     analyze_results(df, output_file)
 
+
 def record_metrics(sim: Simulation, tick: int, phase: str):
-    total_deposits = sum(sim.bank.deposits.get(d_id).amount for d_id in sim.bank.deposits)
+    total_deposits = sum(
+        sim.bank.deposits.get(d_id).amount for d_id in sim.bank.deposits
+    )
     total_cash = sum(h.assets for h in sim.households)
 
     # Calculate Flow (Change in deposits)
@@ -83,7 +87,7 @@ def record_metrics(sim: Simulation, tick: int, phase: str):
         "base_rate": sim.bank.base_rate,
         "total_deposits": total_deposits,
         "total_cash": total_cash,
-        "deposit_ratio": total_deposits / (total_deposits + total_cash + 1e-9)
+        "deposit_ratio": total_deposits / (total_deposits + total_cash + 1e-9),
     }
 
     # Append to external list (closure)
@@ -93,6 +97,7 @@ def record_metrics(sim: Simulation, tick: int, phase: str):
         sim.history_data = []
     sim.history_data.append(history_entry)
 
+
 def analyze_results(df: pd.DataFrame, output_file: str):
     logger.info("\n--- Verification Results ---")
 
@@ -102,11 +107,11 @@ def analyze_results(df: pd.DataFrame, output_file: str):
     # Shock at T=50.
     # Next rebalance at T=60.
 
-    before_shock = df[df['tick'] < 50]
-    after_shock = df[df['tick'] >= 60] # Look after next rebalance
+    before_shock = df[df["tick"] < 50]
+    after_shock = df[df["tick"] >= 60]  # Look after next rebalance
 
-    avg_dep_pre = before_shock['total_deposits'].mean()
-    avg_dep_post = after_shock['total_deposits'].mean()
+    avg_dep_pre = before_shock["total_deposits"].mean()
+    avg_dep_post = after_shock["total_deposits"].mean()
 
     logger.info(f"Avg Deposits (Pre-Shock): {avg_dep_pre:.2f}")
     logger.info(f"Avg Deposits (Post-Shock): {avg_dep_post:.2f}")
@@ -118,12 +123,12 @@ def analyze_results(df: pd.DataFrame, output_file: str):
 
     # Visualization
     plt.figure(figsize=(10, 6))
-    plt.plot(df['tick'], df['total_deposits'], label='Total Deposits', color='blue')
-    plt.axvline(x=50, color='red', linestyle='--', label='Rate Hike (5%->20%)')
+    plt.plot(df["tick"], df["total_deposits"], label="Total Deposits", color="blue")
+    plt.axvline(x=50, color="red", linestyle="--", label="Rate Hike (5%->20%)")
 
     # Mark rebalancing points
     for x in range(0, 100, 30):
-        plt.axvline(x=x, color='gray', linestyle=':', alpha=0.5)
+        plt.axvline(x=x, color="gray", linestyle=":", alpha=0.5)
 
     plt.title("Friedman Effect Verification: Deposits vs Interest Rate")
     plt.xlabel("Tick")
@@ -135,6 +140,7 @@ def analyze_results(df: pd.DataFrame, output_file: str):
     plt.savefig(output_file)
     logger.info(f"Chart saved to {output_file}")
 
+
 if __name__ == "__main__":
     # Monkey patch record_metrics to store data in sim object
     run_verification()
diff --git a/scripts/verify_reflux.py b/scripts/verify_reflux.py
index a5415d9..6324d94 100644
--- a/scripts/verify_reflux.py
+++ b/scripts/verify_reflux.py
@@ -1,4 +1,3 @@
-
 import logging
 import sys
 from pathlib import Path
@@ -15,9 +14,11 @@ import config
 
 # Setup Logging to capture DIVIDEND events
 from utils.logging_manager import setup_logging
+
 setup_logging()
 logger = logging.getLogger("VERIFY_REFLUX")
 
+
 def run_test_plan_a():
     """
     Test Plan A: 'The Reflux'
@@ -33,20 +34,20 @@ def run_test_plan_a():
     # Override config for Laissez-Faire + Reflux
     overrides = {
         "INCOME_TAX_RATE": 0.0,
-        "CORPORATE_TAX_RATE": 0.0, # Let them keep profit to distribute
+        "CORPORATE_TAX_RATE": 0.0,  # Let them keep profit to distribute
         "SALES_TAX_RATE": 0.0,
         "FIRM_PRODUCTIVITY_FACTOR": 20.0,
         "FIRM_MAINTENANCE_FEE": 50.0,
-        "SIMULATION_TICKS": 400, # Goal is > 200
-        "INITIAL_FIRM_CAPITAL_MEAN": 10000.0, # Same as Laissez-Faire
+        "SIMULATION_TICKS": 400,  # Goal is > 200
+        "INITIAL_FIRM_CAPITAL_MEAN": 10000.0,  # Same as Laissez-Faire
     }
-    
+
     # Apply overrides (Hack: modify config directly as main.run_simulation doesn't support all overrides easily via args)
     # But main.create_simulation does.
     # main.run_simulation accepts specific args, but we might need to modify config module.
     for k, v in overrides.items():
         setattr(config, k, v)
-    
+
     # 2. Run Simulation
     output_file = "reflux_test_results.csv"
     try:
@@ -60,7 +61,7 @@ def run_test_plan_a():
     run_id = repo._get_latest_run_id()
     loader = DataLoader("simulation_data.db")
     eco_df = loader.load_economic_indicators(run_id=run_id)
-    
+
     if eco_df.empty:
         logger.error("No economic data found.")
         return
@@ -68,23 +69,30 @@ def run_test_plan_a():
     # 3.1 Check Log/Event Evidence (Dividends)
     # We can't grep logs easily from here unless we read the log file.
     # But we can check 'total_capital_income' from eco_df.
-    
+
     total_labor = eco_df["total_labor_income"].sum()
     total_capital = eco_df["total_capital_income"].sum()
-    
+
     logger.info(f"Total Labor Income: {total_labor:,.2f}")
     logger.info(f"Total Capital Income: {total_capital:,.2f}")
-    
+
     if total_capital > 0:
         logger.info("SUCCESS: Capital Income detected (Dividends flowing).")
     else:
         logger.error("FAILURE: No Capital Income detected.")
-        
+
     # 3.2 Check Golden Cross
     # Plot Income Composition
     plt.figure(figsize=(10, 6))
-    plt.plot(eco_df.index, eco_df["total_labor_income"], label="Labor Income", color="blue")
-    plt.plot(eco_df.index, eco_df["total_capital_income"], label="Capital Income", color="red")
+    plt.plot(
+        eco_df.index, eco_df["total_labor_income"], label="Labor Income", color="blue"
+    )
+    plt.plot(
+        eco_df.index,
+        eco_df["total_capital_income"],
+        label="Capital Income",
+        color="red",
+    )
     plt.title("Income Composition: Labor vs Capital")
     plt.xlabel("Tick")
     plt.ylabel("Income")
@@ -92,16 +100,16 @@ def run_test_plan_a():
     plt.grid(True)
     plt.savefig("reports/figures/income_composition_reflux.png")
     logger.info("Generated 'reports/figures/income_composition_reflux.png'")
-    
+
     # 3.3 Check Survival
     # Deaths?
     # Get attrition
     attrition = repo.get_attrition_counts(start_tick=0, end_tick=400, run_id=run_id)
     logger.info(f"Attrition: {attrition}")
-    
+
     final_tick = eco_df.index.max()
     logger.info(f"Simulation reached tick: {final_tick}")
-    
+
     if final_tick >= 200:
         logger.info("SUCCESS: Survived beyond 200 ticks.")
     else:
@@ -109,5 +117,6 @@ def run_test_plan_a():
 
     repo.close()
 
+
 if __name__ == "__main__":
     run_test_plan_a()
diff --git a/scripts/verify_stock_market.py b/scripts/verify_stock_market.py
index 7e301a9..a8a0564 100644
--- a/scripts/verify_stock_market.py
+++ b/scripts/verify_stock_market.py
@@ -1,4 +1,3 @@
-
 import sys
 from pathlib import Path
 import os
@@ -8,7 +7,7 @@ from typing import Dict, Any
 # Add project root to sys.path
 sys.path.append(str(Path(__file__).resolve().parent.parent))
 
-import config as global_config # Root config module
+import config as global_config  # Root config module
 
 from simulation.engine import Simulation
 from simulation.models import Order
@@ -18,9 +17,10 @@ from simulation.markets.stock_market import StockMarket
 from simulation.decisions.corporate_manager import CorporateManager
 
 # Setup Logging
-logging.basicConfig(level=logging.INFO, format='%(message)s')
+logging.basicConfig(level=logging.INFO, format="%(message)s")
 logger = logging.getLogger("VERIFY_STOCK")
 
+
 class MockConfig:
     # Mimic config module structure
     NUM_HOUSEHOLDS = 20
@@ -29,179 +29,226 @@ class MockConfig:
     STOCK_PRICE_LIMIT_RATE = 0.30
     DIVIDEND_RATE_MIN = 0.0
     DIVIDEND_RATE_MAX = 0.5
-    
+
     # Copy essential dicts
-    GOODS = getattr(global_config, 'GOODS', {})
-    LABOR_MARKET_MIN_WAGE = getattr(global_config, 'LABOR_MARKET_MIN_WAGE', 10.0)
+    GOODS = getattr(global_config, "GOODS", {})
+    LABOR_MARKET_MIN_WAGE = getattr(global_config, "LABOR_MARKET_MIN_WAGE", 10.0)
     # Add other needed configs
-    FIRM_DEFAULT_TOTAL_SHARES = getattr(global_config, 'FIRM_DEFAULT_TOTAL_SHARES', 1000.0)
-    FIRM_MIN_PRODUCTION_TARGET = getattr(global_config, 'FIRM_MIN_PRODUCTION_TARGET', 10.0)
-    INITIAL_FIRM_LIQUIDITY_NEED = getattr(global_config, 'INITIAL_FIRM_LIQUIDITY_NEED', 500.0)
-    INVENTORY_HOLDING_COST_RATE = getattr(global_config, 'INVENTORY_HOLDING_COST_RATE', 0.01)
-    
+    FIRM_DEFAULT_TOTAL_SHARES = getattr(
+        global_config, "FIRM_DEFAULT_TOTAL_SHARES", 1000.0
+    )
+    FIRM_MIN_PRODUCTION_TARGET = getattr(
+        global_config, "FIRM_MIN_PRODUCTION_TARGET", 10.0
+    )
+    INITIAL_FIRM_LIQUIDITY_NEED = getattr(
+        global_config, "INITIAL_FIRM_LIQUIDITY_NEED", 500.0
+    )
+    INVENTORY_HOLDING_COST_RATE = getattr(
+        global_config, "INVENTORY_HOLDING_COST_RATE", 0.01
+    )
+
     # Add R&D productivity multiplier if needed
-    RND_PRODUCTIVITY_MULTIPLIER = getattr(global_config, 'RND_PRODUCTIVITY_MULTIPLIER', 0.1)
-    MAX_SELL_QUANTITY = getattr(global_config, 'MAX_SELL_QUANTITY', 100.0)
+    RND_PRODUCTIVITY_MULTIPLIER = getattr(
+        global_config, "RND_PRODUCTIVITY_MULTIPLIER", 0.1
+    )
+    MAX_SELL_QUANTITY = getattr(global_config, "MAX_SELL_QUANTITY", 100.0)
+
 
 def run_verification():
     print(">>> STARTING STOCK MARKET VERIFICATION <<<")
-    
+
     # 1. Init Simulation
     config = MockConfig()
     sim = Simulation(
-        households=[], firms=[], ai_trainer=None, repository=None, config_module=config, goods_data=[]
+        households=[],
+        firms=[],
+        ai_trainer=None,
+        repository=None,
+        config_module=config,
+        goods_data=[],
     )
     # Manually populate for control
-    sim.households = [Household(i, 1000.0, [], 'BALANCED', config) for i in range(config.NUM_HOUSEHOLDS)]
-    sim.firms = [Firm(1, 10000.0, 500.0, "food", 1.0, None, 'BALANCED', config, is_visionary=True)]
-    
+    sim.households = [
+        Household(i, 1000.0, [], "BALANCED", config)
+        for i in range(config.NUM_HOUSEHOLDS)
+    ]
+    sim.firms = [
+        Firm(
+            1, 10000.0, 500.0, "food", 1.0, None, "BALANCED", config, is_visionary=True
+        )
+    ]
+
     # Give some shares to households
     firm = sim.firms[0]
     total_shares_start = firm.total_shares
     shares_per_hh = total_shares_start / config.NUM_HOUSEHOLDS
-    
+
     for h in sim.households:
         h.shares_owned[firm.id] = shares_per_hh
         # Set risk aversion: 10 Value Investors, 10 Momentum Traders
         if h.id < 10:
-            h.risk_aversion = 2.0 # Value (High Aversion)
+            h.risk_aversion = 2.0  # Value (High Aversion)
         else:
-            h.risk_aversion = 0.5 # Momentum (Low Aversion)
+            h.risk_aversion = 0.5  # Momentum (Low Aversion)
 
     # Init Stock Market
     sim.stock_market = StockMarket(config, logger)
     sim.markets["stock_market"] = sim.stock_market
-    
+
     # Correctly register firm in market if needed (mitosis registry?)
     # StockMarket usually auto-registers or uses get_daily_avg_price(firm.id) which handles missing.
-    
+
     # 2. Market Run Scenarios
-    
+
     # Scene 1: Bubble Formation (Ticks 1-5)
     print("\n[Phase 1] Bubble Formation (High Dividends)")
-    firm.current_profit = 5000.0 
+    firm.current_profit = 5000.0
     firm.dividend_rate = 0.5
-    
+
     # Pre-seed price
     sim.stock_market.daily_prices[firm.id] = 10.0
-    
+
     for t in range(5):
         # Force dividend distribution manually to trigger signals
         sim.time = t
         firm.distribute_dividends(sim.households, sim.government, t)
-        
+
         # Prepare Market Data
         market_data = {
             "stock_market": {
                 f"stock_{firm.id}": {
-                    "avg_price": sim.stock_market.get_daily_avg_price(firm.id) or 10.0, 
-                    "dividend_yield": 0.05
+                    "avg_price": sim.stock_market.get_daily_avg_price(firm.id) or 10.0,
+                    "dividend_yield": 0.05,
                 }
             }
         }
-        
+
         # Agents generate orders
         for h in sim.households:
             # Inject cash to fuel bubble
-            h.assets += 100.0 
+            h.assets += 100.0
             # Portfolio Manager call
             orders = h.portfolio_manager.generate_stock_orders(
-                h.id, h.shares_owned, h.assets * 0.5, h.assets, market_data, h.risk_aversion, 0.02
+                h.id,
+                h.shares_owned,
+                h.assets * 0.5,
+                h.assets,
+                market_data,
+                h.risk_aversion,
+                0.02,
             )
             for o in orders:
                 sim.stock_market.place_order(o, t)
-                
+
         sim.stock_market.match_orders(t)
         price = sim.stock_market.get_daily_avg_price(firm.id)
         print(f"Tick {t}: Price = {price:.2f}")
 
     peak_price = sim.stock_market.get_daily_avg_price(firm.id)
-    
+
     # Scene 2: Crash (Ticks 6-10)
     print("\n[Phase 2] Crash (Earnings Shock)")
     firm.current_profit = 0.0
     firm.dividend_rate = 0.0
-    
+
     for t in range(6, 11):
         sim.time = t
         market_data = {
             "stock_market": {
                 f"stock_{firm.id}": {
-                    "avg_price": sim.stock_market.get_daily_avg_price(firm.id), 
-                    "dividend_yield": 0.0
+                    "avg_price": sim.stock_market.get_daily_avg_price(firm.id),
+                    "dividend_yield": 0.0,
                 }
             }
         }
-        
+
         for h in sim.households:
             orders = h.portfolio_manager.generate_stock_orders(
-                h.id, h.shares_owned, h.assets * 0.5, h.assets, market_data, h.risk_aversion, 0.02
+                h.id,
+                h.shares_owned,
+                h.assets * 0.5,
+                h.assets,
+                market_data,
+                h.risk_aversion,
+                0.02,
             )
             for o in orders:
                 sim.stock_market.place_order(o, t)
-        
+
         sim.stock_market.match_orders(t)
         price = sim.stock_market.get_daily_avg_price(firm.id)
         print(f"Tick {t}: Price = {price:.2f}")
-        
+
     crash_price = sim.stock_market.get_daily_avg_price(firm.id)
-    
+
     # Scene 3: Buyback (Tick 15)
     print("\n[Phase 3] Treasury Buyback")
-    firm.assets = 100000.0 # Massive cash injection for buyback
-    firm.needs["liquidity_need"] = 100.0 # Low need
-    
+    firm.assets = 100000.0  # Massive cash injection for buyback
+    firm.needs["liquidity_need"] = 100.0  # Low need
+
     initial_shares = firm.total_shares
     print(f"Shares Before Buyback: {initial_shares}")
-    
+
     # Instantiate CorporateManager
     cm = CorporateManager(config, logger)
-    
+
     # Updated Market Data with Low Price (Crash Price)
     market_data = {"stock_market": {f"stock_{firm.id}": {"avg_price": crash_price}}}
-    
+
     # 1. Generate Buyback Orders
     buyback_orders = cm._manage_buybacks(firm, market_data, 15)
     print(f"Buyback Orders Generated: {len(buyback_orders)}")
-    
+
     if buyback_orders:
         buy_order = buyback_orders[0]
         print(f"Buy Order: {buy_order.quantity:.1f} shares @ {buy_order.price:.2f}")
-        
+
         # Place Buy Order
         sim.stock_market.place_order(buy_order, 15)
-        
+
         # Place Matches Sell Order (from Households)
         # Force a household to sell at a lower price to ensure match
         sell_qty = buy_order.quantity
         sim.stock_market.place_order(
-            Order(sim.households[0].id, "SELL", f"stock_{firm.id}", sell_qty, buy_order.price * 0.9, "stock"),
-            15
+            Order(
+                sim.households[0].id,
+                "SELL",
+                f"stock_{firm.id}",
+                sell_qty,
+                buy_order.price * 0.9,
+                "stock",
+            ),
+            15,
         )
-        
+
         # Match Orders
         txs = sim.stock_market.match_orders(15)
         print(f"Matched {len(txs)} transactions.")
-        
+
         # 2. Process Transactions (Logic Verification)
         # We need to manually invoke logic because we aren't running full sim step loop
         # But we can verify if engine's process_transactions works by mocking it or calling it?
         # Sim object has _process_transactions method.
         sim._process_transactions(txs)
-        
+
     final_shares = firm.total_shares
     print(f"Shares After Buyback: {final_shares}")
-    
+
     burnt_amount = initial_shares - final_shares
     if burnt_amount > 0:
-        print(f">>> SUCCESS: {burnt_amount:.1f} Shares Retired (Buyback & Burn Verified)")
+        print(
+            f">>> SUCCESS: {burnt_amount:.1f} Shares Retired (Buyback & Burn Verified)"
+        )
     else:
         print(">>> FAILURE: Shares NOT Reduced")
 
     if peak_price > 10.0 and crash_price < peak_price:
         print(">>> SUCCESS: Bubble & Crash Verified")
     else:
-        print(f">>> FAILURE: Price Dynamics ambiguous (Start:10, Peak:{peak_price:.2f}, Crash:{crash_price:.2f})")
+        print(
+            f">>> FAILURE: Price Dynamics ambiguous (Start:10, Peak:{peak_price:.2f}, Crash:{crash_price:.2f})"
+        )
+
 
 if __name__ == "__main__":
     run_verification()
diff --git a/scripts/verify_wo23.py b/scripts/verify_wo23.py
index fce0011..0c2870d 100644
--- a/scripts/verify_wo23.py
+++ b/scripts/verify_wo23.py
@@ -1,4 +1,3 @@
-
 import logging
 import sys
 from pathlib import Path
@@ -16,9 +15,11 @@ import config
 
 # Setup Logging
 from utils.logging_manager import setup_logging
+
 setup_logging()
 logger = logging.getLogger("VERIFY_WO23")
 
+
 def run_test_plan_b():
     """
     Test Plan B: Innovation & Differentiation (WO-023)
@@ -28,14 +29,14 @@ def run_test_plan_b():
     logger.info("Starting Test Plan B: WO-023 Verification")
 
     # 1. Configure for High Mutability & Specific Environment
-    # Function to tweak engine.py randomness? 
+    # Function to tweak engine.py randomness?
     # Hard to force random.random() < 0.05 from here without mocking.
     # Instead, we rely on running enough spawns or patching.
     # PRO-TIP: We can monkey-patch random.random to return 0.0 once to force Visionary?
-    # Or just increase probability via config if we made it a config param? 
+    # Or just increase probability via config if we made it a config param?
     # I didn't make MUTATION_RATE a config param in engine.py (hardcoded 0.05).
     # So I will Monkey Patch engine.random.random for the check.
-    
+
     # 2. Run Simulation
     # Run for 50 ticks is enough to spawn firms?
     # Genesis spawns initial firms. Does spawn_firm run at Genesis?
@@ -43,37 +44,39 @@ def run_test_plan_b():
     # spawn_firm is for Entrepreneurship (ticks).
     # So we need to wait for entrepreneurship.
     # To speed up, we can set STARTUP_COST low.
-    
+
     overrides = {
-        "STARTUP_COST": 1000.0, # Cheap to spawn
+        "STARTUP_COST": 1000.0,  # Cheap to spawn
         "SIMULATION_TICKS": 100,
         "TARGET_FOOD_BUFFER_QUANTITY": 5.0,
-        "VISIONARY_MUTATION_RATE": 1.0, # Force Visionary Spawn
-        "INITIAL_HOUSEHOLD_ASSETS_MEAN": 5000.0, # WO-023: Verify Logic - Ensure rich enough to spawn
+        "VISIONARY_MUTATION_RATE": 1.0,  # Force Visionary Spawn
+        "INITIAL_HOUSEHOLD_ASSETS_MEAN": 5000.0,  # WO-023: Verify Logic - Ensure rich enough to spawn
     }
-    
+
     for k, v in overrides.items():
         setattr(config, k, v)
 
     output_file = "wo23_test_results.csv"
-    
+
     # Run simulation
     run_simulation(output_filename=output_file)
-    
+
     # 3. Analyze Results
     repo = SimulationRepository()
     # run_id = repo._get_latest_run_id()
     repo.cursor.execute("SELECT MAX(run_id) FROM simulation_runs")
     run_id = repo.cursor.fetchone()[0]
-    
+
     # 3.1 Verify Visionary / Consumer Goods Production
     # Check if any firm produced 'consumer_goods' or has sector 'GOODS'
     # load firm data?
     # We can check economic_indicators 'total_capital_income' (irrelevant)
     # Check 'market_history' for 'consumer_goods'.
-    
-    mh_data = repo.get_market_history(market_id="goods_market", start_tick=0, end_tick=100, item_id="consumer_goods")
-    
+
+    mh_data = repo.get_market_history(
+        market_id="goods_market", start_tick=0, end_tick=100, item_id="consumer_goods"
+    )
+
     has_consumer_goods = False
     if mh_data:
         logger.info(f"Consumer Goods Market Activity detected: {len(mh_data)} records.")
@@ -82,17 +85,21 @@ def run_test_plan_b():
         # Check active firms directly via accessing the simulation instance if possible?
         # run_simulation returns nothing.
         # We can check DB for 'consumer_goods' transactions.
-        txs = repo.get_transactions(start_tick=0, end_tick=100, market_id="goods_market")
+        txs = repo.get_transactions(
+            start_tick=0, end_tick=100, market_id="goods_market"
+        )
         cg_txs = [t for t in txs if t.item_id == "consumer_goods"]
         if cg_txs:
             logger.info(f"Found {len(cg_txs)} transactions for consumer_goods.")
             has_consumer_goods = True
-    
+
     if has_consumer_goods:
         logger.info("SUCCESS: Visionary Firms created and producing Consumer Goods.")
     else:
-        logger.warning("WARNING: No Consumer Goods activity found. Visionary spawn might have failed or taken too long.")
-        
+        logger.warning(
+            "WARNING: No Consumer Goods activity found. Visionary spawn might have failed or taken too long."
+        )
+
     # 3.2 Verify Maslow Constraint
     # We need to find a transaction for consumer_goods where buyer had low food.
     # But we don't save buyer's inventory snapshot at exact transaction time in DB easily.
@@ -105,14 +112,16 @@ def run_test_plan_b():
     # Let's check AgentState for that tick? AgentState is saved daily.
     # Crude check: For every buyer of consumer_goods, check their food inventory in AgentState at that tick.
     # If inventory < 5.0, it's a suspicious pass (or they bought food same tick).
-    
+
     if cg_txs:
         violations = 0
         for tx in cg_txs:
             buyer_id = tx.buyer_id
             tick = tx.tick
             # Get agent state
-            states = repo.get_agent_states(agent_id=buyer_id, start_tick=tick, end_tick=tick)
+            states = repo.get_agent_states(
+                agent_id=buyer_id, start_tick=tick, end_tick=tick
+            )
             if states:
                 food = states[0].inventory.get("basic_food", 0.0)
                 # Note: This is End-of-Tick state. If they consumed food after buying, it might seem low.
@@ -123,17 +132,20 @@ def run_test_plan_b():
                 # If they didn't buy food, end inventory should be > 5.0 (minus consumption?).
                 # Consumption is small (approx 1.0).
                 # So if end state is < 4.0, it's suspicious.
-                
-                if food < 3.0: # Conservative threshold
-                    logger.warning(f"Potential Maslow Violation: Agent {buyer_id} bought goods at tick {tick} but ended with {food:.2f} food.")
+
+                if food < 3.0:  # Conservative threshold
+                    logger.warning(
+                        f"Potential Maslow Violation: Agent {buyer_id} bought goods at tick {tick} but ended with {food:.2f} food."
+                    )
                     violations += 1
-        
+
         if violations == 0:
             logger.info("SUCCESS: No obvious Maslow Constraint violations found.")
         else:
-             logger.warning(f"WARNING: {violations} potential Maslow violations.")
+            logger.warning(f"WARNING: {violations} potential Maslow violations.")
 
     repo.close()
 
+
 if __name__ == "__main__":
     run_test_plan_b()
diff --git a/scripts/visualize_economy.py b/scripts/visualize_economy.py
index cbc0ca4..27bbfe1 100644
--- a/scripts/visualize_economy.py
+++ b/scripts/visualize_economy.py
@@ -2,6 +2,7 @@
 Visualization Script for Economy Simulation.
 Generates charts based on simulation data.
 """
+
 import sys
 from pathlib import Path
 import os
@@ -16,9 +17,12 @@ sys.path.append(str(Path(__file__).resolve().parent.parent))
 from modules.analytics.loader import DataLoader
 
 # Setup logging
-logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
+logging.basicConfig(
+    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
+)
 logger = logging.getLogger(__name__)
 
+
 def generate_charts(db_path="simulation_data.db", output_dir="reports/figures"):
     logger.info("Starting visualization process...")
 
@@ -46,14 +50,18 @@ def generate_charts(db_path="simulation_data.db", output_dir="reports/figures"):
     # Let's use what we have in eco_df.
 
     money_supply = eco_df["total_household_assets"] + eco_df["total_firm_assets"]
-    axes[0].plot(eco_df.index, money_supply, label="Total Money (HH+Firm)", color="green")
+    axes[0].plot(
+        eco_df.index, money_supply, label="Total Money (HH+Firm)", color="green"
+    )
     axes[0].set_title("Total Money Supply")
     axes[0].set_ylabel("Currency")
     axes[0].grid(True)
     axes[0].legend()
 
     # Subplot 2: GDP (Total Production)
-    axes[1].plot(eco_df.index, eco_df["total_production"], label="GDP (Production)", color="blue")
+    axes[1].plot(
+        eco_df.index, eco_df["total_production"], label="GDP (Production)", color="blue"
+    )
     axes[1].set_title("GDP (Total Production)")
     axes[1].set_ylabel("Units")
     axes[1].grid(True)
@@ -61,7 +69,9 @@ def generate_charts(db_path="simulation_data.db", output_dir="reports/figures"):
 
     # Subplot 3: Average Goods Price
     # eco_df has avg_goods_price
-    axes[2].plot(eco_df.index, eco_df["avg_goods_price"], label="Avg Price", color="red")
+    axes[2].plot(
+        eco_df.index, eco_df["avg_goods_price"], label="Avg Price", color="red"
+    )
     axes[2].set_title("Average Goods Price")
     axes[2].set_xlabel("Tick")
     axes[2].set_ylabel("Price")
@@ -80,7 +90,9 @@ def generate_charts(db_path="simulation_data.db", output_dir="reports/figures"):
 
     for tick in ticks:
         # Filter households
-        tick_data = agent_df[(agent_df["time"] == tick) & (agent_df["agent_type"] == "household")]
+        tick_data = agent_df[
+            (agent_df["time"] == tick) & (agent_df["agent_type"] == "household")
+        ]
         assets = tick_data["assets"].values
         if len(assets) > 0:
             gini = gini_coefficient(assets)
@@ -119,27 +131,33 @@ def generate_charts(db_path="simulation_data.db", output_dir="reports/figures"):
     if not gov_states.empty:
         # Sort by time
         gov_states = gov_states.sort_values("time")
-        line1, = ax1.plot(gov_states["time"], gov_states["assets"], label="Gov Assets", color="blue")
+        (line1,) = ax1.plot(
+            gov_states["time"], gov_states["assets"], label="Gov Assets", color="blue"
+        )
     elif "welfare" in fiscal_data and "assets" in fiscal_data["welfare"].columns:
         # Fallback to fiscal_history.json
         assets_data = fiscal_data["welfare"]["assets"]
-        line1, = ax1.plot(assets_data.index, assets_data, label="Gov Assets (Log)", color="blue")
+        (line1,) = ax1.plot(
+            assets_data.index, assets_data, label="Gov Assets (Log)", color="blue"
+        )
     else:
         logger.warning("No government assets data found.")
 
     if line1:
         ax1.set_xlabel("Tick")
         ax1.set_ylabel("Assets", color="blue")
-        ax1.tick_params(axis='y', labelcolor="blue")
+        ax1.tick_params(axis="y", labelcolor="blue")
 
     # Plot Debt (Right Axis) if available
     line2 = None
     if "welfare" in fiscal_data and "debt" in fiscal_data["welfare"].columns:
         ax2 = ax1.twinx()
         debt_data = fiscal_data["welfare"]["debt"]
-        line2, = ax2.plot(debt_data.index, debt_data, label="Total Debt", color="red", linestyle="--")
+        (line2,) = ax2.plot(
+            debt_data.index, debt_data, label="Total Debt", color="red", linestyle="--"
+        )
         ax2.set_ylabel("Debt", color="red")
-        ax2.tick_params(axis='y', labelcolor="red")
+        ax2.tick_params(axis="y", labelcolor="red")
 
     # Legend
     lines = [l for l in [line1, line2] if l is not None]
@@ -158,7 +176,9 @@ def generate_charts(db_path="simulation_data.db", output_dir="reports/figures"):
         welfare_df = fiscal_data["welfare"]
 
         # Merge on index (tick)
-        fiscal_combined = pd.merge(tax_df, welfare_df, left_index=True, right_index=True, how="outer").fillna(0)
+        fiscal_combined = pd.merge(
+            tax_df, welfare_df, left_index=True, right_index=True, how="outer"
+        ).fillna(0)
 
         plt.figure(figsize=(12, 6))
 
@@ -166,13 +186,30 @@ def generate_charts(db_path="simulation_data.db", output_dir="reports/figures"):
         # tax_df columns might be "total", "income_tax", "wealth_tax", ...
         # Use "total" if available, or sum others
         if "total" in tax_df.columns:
-            plt.plot(fiscal_combined.index, fiscal_combined["total"], label="Total Tax Revenue", color="green")
+            plt.plot(
+                fiscal_combined.index,
+                fiscal_combined["total"],
+                label="Total Tax Revenue",
+                color="green",
+            )
 
         # Welfare Spending
         if "welfare" in welfare_df.columns:
-            plt.plot(fiscal_combined.index, fiscal_combined["welfare"], label="Welfare Spending", color="orange", linestyle="--")
+            plt.plot(
+                fiscal_combined.index,
+                fiscal_combined["welfare"],
+                label="Welfare Spending",
+                color="orange",
+                linestyle="--",
+            )
         if "stimulus" in welfare_df.columns:
-            plt.plot(fiscal_combined.index, fiscal_combined["stimulus"], label="Stimulus", color="red", linestyle=":")
+            plt.plot(
+                fiscal_combined.index,
+                fiscal_combined["stimulus"],
+                label="Stimulus",
+                color="red",
+                linestyle=":",
+            )
 
         plt.title("Fiscal Flows: Tax Revenue vs Welfare")
         plt.xlabel("Tick")
@@ -206,15 +243,18 @@ def generate_charts(db_path="simulation_data.db", output_dir="reports/figures"):
             final_assets = gov_states["assets"].iloc[-1]
             print(f"Final Govt Assets: {final_assets:,.2f}")
             if final_assets > 0:
-                print(f"Debt/Assets Ratio: {final_debt/final_assets:.2f}")
+                print(f"Debt/Assets Ratio: {final_debt / final_assets:.2f}")
+
 
 def gini_coefficient(x):
     """Compute Gini coefficient of array of values"""
     import numpy as np
+
     diffsum = 0
     for i, xi in enumerate(x[:-1], 1):
         diffsum += np.sum(np.abs(xi - x[i:]))
-    return diffsum / (len(x)**2 * np.mean(x))
+    return diffsum / (len(x) ** 2 * np.mean(x))
+
 
 if __name__ == "__main__":
     generate_charts()
diff --git a/simulation/action_processor.py b/simulation/action_processor.py
index 55c9c30..6e8d59f 100644
--- a/simulation/action_processor.py
+++ b/simulation/action_processor.py
@@ -11,6 +11,7 @@ if TYPE_CHECKING:
 
 logger = logging.getLogger(__name__)
 
+
 class ActionProcessor:
     """
     Processes actions and transactions in the simulation.
@@ -22,9 +23,7 @@ class ActionProcessor:
         self.world_state = world_state
 
     def process_transactions(
-        self,
-        transactions: List[Transaction],
-        market_data_callback: Callable[[], Any]
+        self, transactions: List[Transaction], market_data_callback: Callable[[], Any]
     ) -> None:
         """
         Delegates transaction processing to the TransactionProcessor system using SimulationState.
@@ -39,6 +38,7 @@ class ActionProcessor:
             market_data = {"goods_market": goods_market_data}
 
             from simulation.dtos.api import SimulationState
+
             state = SimulationState(
                 time=self.world_state.time,
                 households=self.world_state.households,
@@ -55,11 +55,13 @@ class ActionProcessor:
                 tracker=self.world_state.tracker,
                 logger=self.world_state.logger,
                 reflux_system=self.world_state.reflux_system,
-                ai_training_manager=getattr(self.world_state, "ai_training_manager", None),
+                ai_training_manager=getattr(
+                    self.world_state, "ai_training_manager", None
+                ),
                 ai_trainer=getattr(self.world_state, "ai_trainer", None),
                 next_agent_id=self.world_state.next_agent_id,
                 real_estate_units=self.world_state.real_estate_units,
-                transactions=transactions
+                transactions=transactions,
             )
             self.world_state.transaction_processor.execute(state)
         else:
diff --git a/simulation/agents/central_bank.py b/simulation/agents/central_bank.py
index 37a1821..2087c82 100644
--- a/simulation/agents/central_bank.py
+++ b/simulation/agents/central_bank.py
@@ -5,6 +5,7 @@ from modules.finance.api import InsufficientFundsError
 
 logger = logging.getLogger(__name__)
 
+
 class CentralBank:
     """
     Phase 10: Central Bank Agent.
@@ -29,11 +30,11 @@ class CentralBank:
 
         # GDP Potential Tracking (EMA)
         self.potential_gdp = 0.0
-        self.gdp_ema_alpha = 0.05 # Smoothing factor for Potential GDP (slow moving)
+        self.gdp_ema_alpha = 0.05  # Smoothing factor for Potential GDP (slow moving)
 
         logger.info(
             f"CENTRAL_BANK_INIT | Rate: {self.base_rate:.2%}, Target Infl: {self.inflation_target:.2%}",
-            extra={"tick": 0, "tags": ["central_bank", "init"]}
+            extra={"tick": 0, "tags": ["central_bank", "init"]},
         )
 
     def purchase_bonds(self, bond: Any) -> None:
@@ -45,7 +46,7 @@ class CentralBank:
         logger.info(
             f"CENTRAL_BANK_QE | Purchased bond {bond.id} for {bond.face_value:.2f}. "
             f"Total bonds held: {len(self.assets['bonds'])}",
-            extra={"tags": ["central_bank", "qe"]}
+            extra={"tags": ["central_bank", "qe"]},
         )
 
     def get_base_rate(self) -> float:
@@ -64,12 +65,21 @@ class CentralBank:
             if self.potential_gdp == 0.0:
                 self.potential_gdp = current_gdp
             else:
-                self.potential_gdp = (self.gdp_ema_alpha * current_gdp) + ((1 - self.gdp_ema_alpha) * self.potential_gdp)
+                self.potential_gdp = (self.gdp_ema_alpha * current_gdp) + (
+                    (1 - self.gdp_ema_alpha) * self.potential_gdp
+                )
 
         # 2. Check Update Interval (and if AI is not in control)
-        is_ai_controlled = getattr(self.config_module, "GOVERNMENT_POLICY_MODE", "TAYLOR_RULE") == "AI_ADAPTIVE"
+        is_ai_controlled = (
+            getattr(self.config_module, "GOVERNMENT_POLICY_MODE", "TAYLOR_RULE")
+            == "AI_ADAPTIVE"
+        )
 
-        if not is_ai_controlled and current_tick > 0 and current_tick % self.update_interval == 0:
+        if (
+            not is_ai_controlled
+            and current_tick > 0
+            and current_tick % self.update_interval == 0
+        ):
             self.calculate_rate(current_tick, current_gdp)
 
     def calculate_rate(self, current_tick: int, current_gdp: float):
@@ -105,7 +115,9 @@ class CentralBank:
 
                 ticks_per_year = getattr(self.config_module, "TICKS_PER_YEAR", 100)
                 period_inflation = (p_current - p_prev) / p_prev
-                inflation_rate = period_inflation * (ticks_per_year / self.update_interval)
+                inflation_rate = period_inflation * (
+                    ticks_per_year / self.update_interval
+                )
 
         # B. Calculate Output Gap
         output_gap = 0.0
@@ -124,9 +136,12 @@ class CentralBank:
         # My config has ALPHA=1.5. I should assume config ALPHA is the coefficient for (pi - pi*).
         # Formula: i = neutral_rate + inflation_rate + alpha * (inflation_rate - target) + beta * output_gap
 
-        taylor_rate = neutral_rate + inflation_rate + \
-                      self.alpha * (inflation_rate - self.inflation_target) + \
-                      self.beta * output_gap
+        taylor_rate = (
+            neutral_rate
+            + inflation_rate
+            + self.alpha * (inflation_rate - self.inflation_target)
+            + self.beta * output_gap
+        )
 
         # D. Zero Lower Bound (ZLB) and Smoothing
         # ZLB
@@ -142,10 +157,14 @@ class CentralBank:
         self.base_rate = target_rate
 
         old_rate_val = old_rate if isinstance(old_rate, (int, float)) else 0.0
-        new_rate_val = self.base_rate if isinstance(self.base_rate, (int, float)) else 0.0
+        new_rate_val = (
+            self.base_rate if isinstance(self.base_rate, (int, float)) else 0.0
+        )
         infl_val = inflation_rate if isinstance(inflation_rate, (int, float)) else 0.0
         gap_val = output_gap if isinstance(output_gap, (int, float)) else 0.0
-        pot_gdp_val = self.potential_gdp if isinstance(self.potential_gdp, (int, float)) else 0.0
+        pot_gdp_val = (
+            self.potential_gdp if isinstance(self.potential_gdp, (int, float)) else 0.0
+        )
 
         logger.info(
             f"CB_RATE_UPDATE | Rate: {old_rate_val:.2%} -> {new_rate_val:.2%} "
@@ -156,14 +175,14 @@ class CentralBank:
                 "new_rate": self.base_rate,
                 "inflation": inflation_rate,
                 "output_gap": output_gap,
-                "tags": ["central_bank", "policy"]
-            }
+                "tags": ["central_bank", "policy"],
+            },
         )
 
     def deposit(self, amount: float) -> None:
         """Deposits a given amount into the central bank's cash reserves."""
         if amount > 0:
-            self.assets['cash'] = self.assets.get('cash', 0) + amount
+            self.assets["cash"] = self.assets.get("cash", 0) + amount
 
     def withdraw(self, amount: float) -> None:
         """
@@ -171,7 +190,7 @@ class CentralBank:
         As a Fiat Currency Issuer, the Central Bank can have a negative balance (creating money).
         """
         if amount > 0:
-            current_cash = self.assets.get('cash', 0)
+            current_cash = self.assets.get("cash", 0)
             # Central Bank can withdraw (create money) even if it results in negative cash
             # This represents expansion of the monetary base.
-            self.assets['cash'] = current_cash - amount
+            self.assets["cash"] = current_cash - amount
diff --git a/simulation/agents/government.py b/simulation/agents/government.py
index 235d006..e8a3d7c 100644
--- a/simulation/agents/government.py
+++ b/simulation/agents/government.py
@@ -19,6 +19,7 @@ from modules.finance.api import InsufficientFundsError
 
 logger = logging.getLogger(__name__)
 
+
 class Government:
     """
     ì •ë¶€ ì—ì´ì „íŠ¸. ì„¸ê¸ˆì„ ì§•ìˆ˜í•˜ê³  ë³´ì¡°ê¸ˆì„ ì§€ê¸‰í•˜ê±°ë‚˜ ì¸í”„ë¼ì— íˆ¬ìí•©ë‹ˆë‹¤.
@@ -29,7 +30,7 @@ class Government:
         self._assets = initial_assets
         self.config_module = config_module
         self.settlement_system: Optional["ISettlementSystem"] = None
-        
+
         self.tax_agency = TaxAgency(config_module)
         self.ministry_of_education = MinistryOfEducation(config_module)
 
@@ -40,7 +41,7 @@ class Government:
         # Gold Standard Money Tracking
         self.total_money_issued: float = 0.0
         self.total_money_destroyed: float = 0.0
-        
+
         # ì„¸ìˆ˜ ìœ í˜•ë³„ ì§‘ê³„
         self.tax_revenue: Dict[str, float] = {}
 
@@ -52,7 +53,9 @@ class Government:
         # --- Phase 24: Policy Strategy Selection ---
         policy_mode = getattr(config_module, "GOVERNMENT_POLICY_MODE", "TAYLOR_RULE")
         if policy_mode == "AI_ADAPTIVE":
-            self.policy_engine: IGovernmentPolicy = SmartLeviathanPolicy(self, config_module)
+            self.policy_engine: IGovernmentPolicy = SmartLeviathanPolicy(
+                self, config_module
+            )
         else:
             self.policy_engine: IGovernmentPolicy = TaylorRulePolicy(config_module)
 
@@ -60,28 +63,32 @@ class Government:
         self.ai = getattr(self.policy_engine, "ai", None)
 
         # Political State
-        self.ruling_party: PoliticalParty = PoliticalParty.BLUE # Default
+        self.ruling_party: PoliticalParty = PoliticalParty.BLUE  # Default
         self.approval_rating: float = 0.5
-        self.public_opinion_queue: Deque[float] = deque(maxlen=4) # 4-tick lag
+        self.public_opinion_queue: Deque[float] = deque(maxlen=4)  # 4-tick lag
         self.perceived_public_opinion: float = 0.5
         self.last_election_tick: int = 0
 
         # Policy Levers (Tax Rates)
         self.income_tax_rate: float = getattr(config_module, "INCOME_TAX_RATE", 0.1)
-        self.corporate_tax_rate: float = getattr(config_module, "CORPORATE_TAX_RATE", 0.2)
+        self.corporate_tax_rate: float = getattr(
+            config_module, "CORPORATE_TAX_RATE", 0.2
+        )
 
         # Spending Multipliers (AI Controlled)
         # 1.0 = Normal (Budget Neutral-ish), >1.0 = Stimulus, <1.0 = Austerity
         self.welfare_budget_multiplier: float = 1.0
         self.firm_subsidy_budget_multiplier: float = 1.0
 
-        self.effective_tax_rate: float = self.income_tax_rate # Legacy compatibility
+        self.effective_tax_rate: float = self.income_tax_rate  # Legacy compatibility
         self.total_debt: float = 0.0
         # ---------------------------------------------
 
         # History buffers for visualization
-        self.tax_history: List[Dict[str, Any]] = [] # For Stacked Bar Chart (breakdown per tick)
-        self.welfare_history: List[Dict[str, float]] = [] # For Welfare Line Chart
+        self.tax_history: List[
+            Dict[str, Any]
+        ] = []  # For Stacked Bar Chart (breakdown per tick)
+        self.welfare_history: List[Dict[str, float]] = []  # For Welfare Line Chart
         self.history_window_size = 5000
 
         # Current tick accumulators (reset every tick)
@@ -90,13 +97,13 @@ class Government:
             "welfare_spending": 0.0,
             "stimulus_spending": 0.0,
             "total_collected": 0.0,
-            "education_spending": 0.0 # WO-054
+            "education_spending": 0.0,  # WO-054
         }
 
         # GDP Tracking for Stimulus
         self.gdp_history: List[float] = []
         self.gdp_history_window = 20
-        
+
         # WO-056: Shadow Policy Metrics
         ticks_per_year = int(getattr(config_module, "TICKS_PER_YEAR", 100))
         self.price_history_shadow: Deque[float] = deque(maxlen=ticks_per_year)
@@ -104,7 +111,7 @@ class Government:
         self.revenue_this_tick = 0.0
         self.expenditure_this_tick = 0.0
         self.revenue_breakdown_this_tick = {}
-        
+
         self.average_approval_rating = 0.5
 
         # WO-057-B: Sensory Data Container
@@ -136,17 +143,29 @@ class Government:
         self.sensory_data = dto
         # Log reception (Debug)
         if dto.tick % 50 == 0:
-            inf_sma = dto.inflation_sma if isinstance(dto.inflation_sma, (int, float)) else 0.0
-            app_sma = dto.approval_sma if isinstance(dto.approval_sma, (int, float)) else 0.0
+            inf_sma = (
+                dto.inflation_sma
+                if isinstance(dto.inflation_sma, (int, float))
+                else 0.0
+            )
+            app_sma = (
+                dto.approval_sma if isinstance(dto.approval_sma, (int, float)) else 0.0
+            )
             logger.debug(
                 f"SENSORY_UPDATE | Government received macro data. Inflation_SMA: {inf_sma:.4f}, Approval_SMA: {app_sma:.2f}",
-                extra={"tick": dto.tick, "agent_id": self.id, "tags": ["sensory", "wo-057-b"]}
+                extra={
+                    "tick": dto.tick,
+                    "agent_id": self.id,
+                    "tags": ["sensory", "wo-057-b"],
+                },
             )
 
     def calculate_income_tax(self, income: float, survival_cost: float) -> float:
         """Delegates income tax calculation to the TaxAgency."""
         tax_mode = getattr(self.config_module, "TAX_MODE", "PROGRESSIVE")
-        return self.tax_agency.calculate_income_tax(income, survival_cost, self.income_tax_rate, tax_mode)
+        return self.tax_agency.calculate_income_tax(
+            income, survival_cost, self.income_tax_rate, tax_mode
+        )
 
     def calculate_corporate_tax(self, profit: float) -> float:
         """Delegates corporate tax calculation to the TaxAgency."""
@@ -158,7 +177,7 @@ class Government:
         ì´ì „ í‹±ì˜ ë°ì´í„°ë¥¼ Historyì— ì €ì¥í•©ë‹ˆë‹¤.
         """
         if getattr(self, "revenue_breakdown_this_tick", None) is None:
-             self.revenue_breakdown_this_tick = {}
+            self.revenue_breakdown_this_tick = {}
 
         self.revenue_this_tick = 0.0
         self.expenditure_this_tick = 0.0
@@ -169,6 +188,12 @@ class Government:
         # Legacy method support if any direct calls remain, though TickScheduler uses transactions now.
         return self.tax_agency.collect_tax(self, amount, tax_type, payer, current_tick)
 
+    def record_revenue(
+        self, amount: float, tax_type: str, payer_id: Any, current_tick: int
+    ):
+        """Records revenue without collection (manual transfer case)."""
+        self.tax_agency.record_revenue(self, amount, tax_type, payer_id, current_tick)
+
     def update_public_opinion(self, households: List[Any]):
         """
         Aggregates approval ratings from households and updates the opinion queue (Lag).
@@ -201,30 +226,49 @@ class Government:
             if self.perceived_public_opinion < 0.5:
                 # Flip Party
                 old_party = self.ruling_party
-                self.ruling_party = PoliticalParty.RED if old_party == PoliticalParty.BLUE else PoliticalParty.BLUE
+                self.ruling_party = (
+                    PoliticalParty.RED
+                    if old_party == PoliticalParty.BLUE
+                    else PoliticalParty.BLUE
+                )
 
                 logger.warning(
                     f"ELECTION_RESULTS | REGIME CHANGE! {old_party.name} -> {self.ruling_party.name}. Approval: {self.perceived_public_opinion:.2f}",
-                    extra={"tick": current_tick, "agent_id": self.id, "tags": ["election", "regime_change"]}
+                    extra={
+                        "tick": current_tick,
+                        "agent_id": self.id,
+                        "tags": ["election", "regime_change"],
+                    },
                 )
             else:
                 logger.info(
                     f"ELECTION_RESULTS | INCUMBENT VICTORY ({self.ruling_party.name}). Approval: {self.perceived_public_opinion:.2f}",
-                    extra={"tick": current_tick, "agent_id": self.id, "tags": ["election"]}
+                    extra={
+                        "tick": current_tick,
+                        "agent_id": self.id,
+                        "tags": ["election"],
+                    },
                 )
 
-    def make_policy_decision(self, market_data: Dict[str, Any], current_tick: int, central_bank: "CentralBank"):
+    def make_policy_decision(
+        self,
+        market_data: Dict[str, Any],
+        current_tick: int,
+        central_bank: "CentralBank",
+    ):
         """
         ì •ì±… ì—”ì§„ì—ê²Œ ì˜ì‚¬ê²°ì •ì„ ìœ„ì„í•˜ê³  ê²°ê³¼ë¥¼ ë°˜ì˜í•©ë‹ˆë‹¤.
         (ì „ëµ íŒ¨í„´ ì ìš©: Taylor Rule ë˜ëŠ” AI Adaptive)
         """
         # 1. ì •ì±… ì—”ì§„ ì‹¤í–‰ (Actuator ë° Shadow Mode ë¡œì§ í¬í•¨)
-        decision = self.policy_engine.decide(self, self.sensory_data, current_tick, central_bank)
-        
+        decision = self.policy_engine.decide(
+            self, self.sensory_data, current_tick, central_bank
+        )
+
         if decision.get("status") == "EXECUTED":
-             logger.debug(
+            logger.debug(
                 f"POLICY_EXECUTED | Tick: {current_tick} | Action: {decision.get('action_taken')}",
-                extra={"tick": current_tick, "agent_id": self.id}
+                extra={"tick": current_tick, "agent_id": self.id},
             )
 
         gdp_gap = 0.0
@@ -233,7 +277,9 @@ class Government:
             gdp_gap = (current_gdp - self.potential_gdp) / self.potential_gdp
 
             alpha = 0.01
-            self.potential_gdp = (alpha * current_gdp) + ((1-alpha) * self.potential_gdp)
+            self.potential_gdp = (alpha * current_gdp) + (
+                (1 - alpha) * self.potential_gdp
+            )
 
         # 1. Calculate Inflation (YoY)
         inflation = 0.0
@@ -253,7 +299,12 @@ class Government:
 
         target_inflation = getattr(self.config_module, "CB_INFLATION_TARGET", 0.02)
         neutral_rate = max(0.01, real_gdp_growth)
-        target_rate = neutral_rate + inflation + 0.5 * (inflation - target_inflation) + 0.5 * gdp_gap
+        target_rate = (
+            neutral_rate
+            + inflation
+            + 0.5 * (inflation - target_inflation)
+            + 0.5 * gdp_gap
+        )
 
         current_base_rate = 0.05
         if "loan_market" in market_data:
@@ -268,10 +319,12 @@ class Government:
             metric="taylor_rule_rate",
             current_value=current_base_rate,
             shadow_value=target_rate,
-            details=f"Inf={inflation:.2%}, Growth={real_gdp_growth:.2%}, Gap={gdp_gap:.2%}, RateGap={gap:.4f}"
+            details=f"Inf={inflation:.2%}, Growth={real_gdp_growth:.2%}, Gap={gdp_gap:.2%}, RateGap={gap:.4f}",
         )
 
-    def provide_household_support(self, household: Any, amount: float, current_tick: int) -> List[Transaction]:
+    def provide_household_support(
+        self, household: Any, amount: float, current_tick: int
+    ) -> List[Transaction]:
         """Provides subsidies to households (e.g., unemployment, stimulus). Returns transactions."""
         transactions = []
         effective_amount = amount * self.welfare_budget_multiplier
@@ -286,7 +339,9 @@ class Government:
             # FinanceSystem now returns (bonds, transactions)
             bonds, txs = self.finance_system.issue_treasury_bonds(needed, current_tick)
             if not bonds:
-                logger.warning(f"BOND_ISSUANCE_FAILED | Failed to raise {needed:.2f} for household support.")
+                logger.warning(
+                    f"BOND_ISSUANCE_FAILED | Failed to raise {needed:.2f} for household support."
+                )
                 return []
             transactions.extend(txs)
 
@@ -299,7 +354,7 @@ class Government:
             price=effective_amount,
             market_id="system",
             transaction_type="welfare",
-            time=current_tick
+            time=current_tick,
         )
         transactions.append(tx)
 
@@ -309,36 +364,53 @@ class Government:
 
         logger.info(
             f"HOUSEHOLD_SUPPORT | Generated support tx of {effective_amount:.2f} to {household.id}",
-            extra={"tick": current_tick, "agent_id": self.id, "amount": effective_amount, "target_id": household.id}
+            extra={
+                "tick": current_tick,
+                "agent_id": self.id,
+                "amount": effective_amount,
+                "target_id": household.id,
+            },
         )
         return transactions
 
-    def provide_firm_bailout(self, firm: Any, amount: float, current_tick: int) -> Tuple[Optional["BailoutLoanDTO"], List[Transaction]]:
+    def provide_firm_bailout(
+        self, firm: Any, amount: float, current_tick: int
+    ) -> Tuple[Optional["BailoutLoanDTO"], List[Transaction]]:
         """Provides a bailout loan to a firm if it's eligible. Returns (LoanDTO, Transactions)."""
         if self.finance_system.evaluate_solvency(firm, current_tick):
             logger.info(f"BAILOUT_APPROVED | Firm {firm.id} is eligible for a bailout.")
             # FinanceSystem now returns (loan, transactions)
-            loan, txs = self.finance_system.grant_bailout_loan(firm, amount, current_tick)
+            loan, txs = self.finance_system.grant_bailout_loan(
+                firm, amount, current_tick
+            )
             if loan:
                 self.expenditure_this_tick += amount
             return loan, txs
         else:
-            logger.warning(f"BAILOUT_DENIED | Firm {firm.id} is insolvent and not eligible for a bailout.")
+            logger.warning(
+                f"BAILOUT_DENIED | Firm {firm.id} is insolvent and not eligible for a bailout."
+            )
             return None, []
 
     def get_survival_cost(self, market_data: Dict[str, Any]) -> float:
-        """ Calculates current survival cost based on food prices. """
+        """Calculates current survival cost based on food prices."""
         avg_food_price = 0.0
         goods_market = market_data.get("goods_market", {})
         if "basic_food_current_sell_price" in goods_market:
             avg_food_price = goods_market["basic_food_current_sell_price"]
         else:
-            avg_food_price = getattr(self.config_module, "GOODS_INITIAL_PRICE", {}).get("basic_food", 5.0)
+            avg_food_price = getattr(self.config_module, "GOODS_INITIAL_PRICE", {}).get(
+                "basic_food", 5.0
+            )
 
-        daily_food_need = getattr(self.config_module, "HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK", 1.0)
+        daily_food_need = getattr(
+            self.config_module, "HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK", 1.0
+        )
         return max(avg_food_price * daily_food_need, 10.0)
 
-    def run_welfare_check(self, agents: List[Any], market_data: Dict[str, Any], current_tick: int) -> List[Transaction]:
+    def run_welfare_check(
+        self, agents: List[Any], market_data: Dict[str, Any], current_tick: int
+    ) -> List[Transaction]:
         """
         Government Main Loop Step.
         Returns List of Transactions.
@@ -350,12 +422,16 @@ class Government:
         survival_cost = self.get_survival_cost(market_data)
 
         # 2. Wealth Tax & Unemployment Benefit
-        wealth_tax_rate_annual = getattr(self.config_module, "ANNUAL_WEALTH_TAX_RATE", 0.02)
+        wealth_tax_rate_annual = getattr(
+            self.config_module, "ANNUAL_WEALTH_TAX_RATE", 0.02
+        )
         ticks_per_year = getattr(self.config_module, "TICKS_PER_YEAR", 100.0)
         wealth_tax_rate_tick = wealth_tax_rate_annual / ticks_per_year
         wealth_threshold = getattr(self.config_module, "WEALTH_TAX_THRESHOLD", 50000.0)
 
-        unemployment_ratio = getattr(self.config_module, "UNEMPLOYMENT_BENEFIT_RATIO", 0.8)
+        unemployment_ratio = getattr(
+            self.config_module, "UNEMPLOYMENT_BENEFIT_RATIO", 0.8
+        )
         benefit_amount = survival_cost * unemployment_ratio
 
         total_wealth_tax = 0.0
@@ -382,14 +458,16 @@ class Government:
                             price=tax_amount,
                             market_id="system",
                             transaction_type="tax",
-                            time=current_tick
+                            time=current_tick,
                         )
                         transactions.append(tx)
                         total_wealth_tax += tax_amount
 
                 # B. Unemployment Benefit
                 if not agent.is_employed:
-                    txs = self.provide_household_support(agent, benefit_amount, current_tick)
+                    txs = self.provide_household_support(
+                        agent, benefit_amount, current_tick
+                    )
                     transactions.extend(txs)
                     total_welfare_paid += benefit_amount
 
@@ -410,33 +488,43 @@ class Government:
                     should_stimulus = True
 
         if should_stimulus:
-             stimulus_amount = survival_cost * 5.0
-             active_households = [a for a in agents if hasattr(a, "is_employed") and getattr(a, "is_active", False)]
-
-             total_stimulus = 0.0
-             for h in active_households:
-                 txs = self.provide_household_support(h, stimulus_amount, current_tick)
-                 transactions.extend(txs)
-
-                 # Calculate total from txs for logging?
-                 # Assuming 1 welfare tx per support call
-                 for tx in txs:
-                     if tx.transaction_type == 'welfare':
-                         total_stimulus += tx.price
-
-             if total_stimulus > 0:
-                 logger.warning(
-                     f"STIMULUS_TRIGGERED | GDP Drop Detected. Generated stimulus txs total {total_stimulus:.2f}.",
-                     extra={"tick": current_tick, "agent_id": self.id, "gdp_current": current_gdp}
-                 )
+            stimulus_amount = survival_cost * 5.0
+            active_households = [
+                a
+                for a in agents
+                if hasattr(a, "is_employed") and getattr(a, "is_active", False)
+            ]
+
+            total_stimulus = 0.0
+            for h in active_households:
+                txs = self.provide_household_support(h, stimulus_amount, current_tick)
+                transactions.extend(txs)
+
+                # Calculate total from txs for logging?
+                # Assuming 1 welfare tx per support call
+                for tx in txs:
+                    if tx.transaction_type == "welfare":
+                        total_stimulus += tx.price
+
+            if total_stimulus > 0:
+                logger.warning(
+                    f"STIMULUS_TRIGGERED | GDP Drop Detected. Generated stimulus txs total {total_stimulus:.2f}.",
+                    extra={
+                        "tick": current_tick,
+                        "agent_id": self.id,
+                        "gdp_current": current_gdp,
+                    },
+                )
 
         return transactions
 
-    def invest_infrastructure(self, current_tick: int, reflux_system: Any = None) -> Tuple[bool, List[Transaction]]:
+    def invest_infrastructure(
+        self, current_tick: int, reflux_system: Any = None
+    ) -> Tuple[bool, List[Transaction]]:
         """ì¸í”„ë¼ì— íˆ¬ìí•˜ì—¬ ì „ì²´ ìƒì‚°ì„±ì„ í–¥ìƒì‹œí‚µë‹ˆë‹¤. Returns (Success, Transactions)."""
         transactions = []
         cost = getattr(self.config_module, "INFRASTRUCTURE_INVESTMENT_COST", 5000.0)
-        
+
         effective_cost = cost
 
         if self.firm_subsidy_budget_multiplier < 0.8:
@@ -452,26 +540,28 @@ class Government:
             needed = effective_cost - self.assets
             bonds, txs = self.finance_system.issue_treasury_bonds(needed, current_tick)
             if not bonds:
-                logger.warning(f"BOND_ISSUANCE_FAILED | Failed to raise {needed:.2f} for infrastructure.")
+                logger.warning(
+                    f"BOND_ISSUANCE_FAILED | Failed to raise {needed:.2f} for infrastructure."
+                )
                 return False, []
             transactions.extend(txs)
-            potential_revenue = needed # Assume success
+            potential_revenue = needed  # Assume success
 
         # Generate Investment Transaction (Gov -> Reflux)
         # Using RefluxSystem ID (999999) as Receiver
         reflux_id = 999999
-        if reflux_system and hasattr(reflux_system, 'id'):
+        if reflux_system and hasattr(reflux_system, "id"):
             reflux_id = reflux_system.id
 
         tx = Transaction(
-            buyer_id=self.id, # Government Pays
-            seller_id=reflux_id, # Reflux Receives
+            buyer_id=self.id,  # Government Pays
+            seller_id=reflux_id,  # Reflux Receives
             item_id="infrastructure_investment",
             quantity=1.0,
             price=effective_cost,
             market_id="system",
             transaction_type="infrastructure",
-            time=current_tick
+            time=current_tick,
         )
         transactions.append(tx)
 
@@ -488,8 +578,8 @@ class Government:
                 "tick": current_tick,
                 "agent_id": self.id,
                 "level": self.infrastructure_level,
-                "tags": ["investment", "infrastructure"]
-            }
+                "tags": ["investment", "infrastructure"],
+            },
         )
         return True, transactions
 
@@ -503,11 +593,13 @@ class Government:
 
         # WO-057 Deficit Spending: Update total_debt based on FinanceSystem
         if self.finance_system:
-             self.total_debt = sum(b.face_value for b in self.finance_system.outstanding_bonds)
+            self.total_debt = sum(
+                b.face_value for b in self.finance_system.outstanding_bonds
+            )
         elif self.assets < 0:
-             self.total_debt = abs(self.assets)
+            self.total_debt = abs(self.assets)
         else:
-             self.total_debt = 0.0
+            self.total_debt = 0.0
 
         self.tax_history.append(revenue_snapshot)
         if len(self.tax_history) > self.history_window_size:
@@ -517,9 +609,11 @@ class Government:
             "tick": current_tick,
             "welfare": self.current_tick_stats["welfare_spending"],
             "stimulus": self.current_tick_stats["stimulus_spending"],
-            "education": self.current_tick_stats.get("education_spending", 0.0), # WO-054
+            "education": self.current_tick_stats.get(
+                "education_spending", 0.0
+            ),  # WO-054
             "debt": self.total_debt,
-            "assets": self.assets
+            "assets": self.assets,
         }
         self.welfare_history.append(welfare_snapshot)
         if len(self.welfare_history) > self.history_window_size:
@@ -529,8 +623,8 @@ class Government:
             "tax_revenue": {},
             "welfare_spending": 0.0,
             "stimulus_spending": 0.0,
-            "education_spending": 0.0, # WO-054
-            "total_collected": 0.0
+            "education_spending": 0.0,  # WO-054
+            "total_collected": 0.0,
         }
 
     def get_monetary_delta(self) -> float:
@@ -545,7 +639,7 @@ class Government:
             "approval_rating": self.approval_rating,
             "income_tax_rate": self.income_tax_rate,
             "corporate_tax_rate": self.corporate_tax_rate,
-            "perceived_public_opinion": self.perceived_public_opinion
+            "perceived_public_opinion": self.perceived_public_opinion,
         }
 
     def get_debt_to_gdp_ratio(self) -> float:
@@ -565,13 +659,23 @@ class Government:
         """Withdraws a given amount from the government's assets."""
         if amount > 0:
             if self.assets < amount:
-                raise InsufficientFundsError(f"Government {self.id} has insufficient funds for withdrawal of {amount:.2f}. Available: {self.assets:.2f}")
+                raise InsufficientFundsError(
+                    f"Government {self.id} has insufficient funds for withdrawal of {amount:.2f}. Available: {self.assets:.2f}"
+                )
             self._assets -= amount
 
     # WO-054: Public Education System
-    def run_public_education(self, agents: List[Any], config_module: Any, current_tick: int, reflux_system: Any = None) -> None:
+    def run_public_education(
+        self,
+        agents: List[Any],
+        config_module: Any,
+        current_tick: int,
+        reflux_system: Any = None,
+    ) -> None:
         """
         Delegates public education logic to the Ministry of Education.
         """
-        households = [a for a in agents if hasattr(a, 'education_level')]
-        self.ministry_of_education.run_public_education(households, self, current_tick, reflux_system)
+        households = [a for a in agents if hasattr(a, "education_level")]
+        self.ministry_of_education.run_public_education(
+            households, self, current_tick, reflux_system
+        )
diff --git a/simulation/ai/action_selector.py b/simulation/ai/action_selector.py
index 573b74c..d6d12ce 100644
--- a/simulation/ai/action_selector.py
+++ b/simulation/ai/action_selector.py
@@ -32,7 +32,7 @@ class ActionSelector:
         state: Tuple,
         actions: List[Any],
         personality: Optional[Personality] = None,
-        current_tick: Optional[int] = None
+        current_tick: Optional[int] = None,
     ) -> Any:
         """
         í˜„ì¬ ìƒíƒœì—ì„œ Q-í…Œì´ë¸”ì„ ë³´ê³  ìµœì ì˜ í–‰ë™ì„ ì„ íƒí•˜ê±°ë‚˜, íƒí—˜ì„ ìœ„í•´ ë¬´ì‘ìœ„ í–‰ë™ì„ ì„ íƒí•œë‹¤.
diff --git a/simulation/ai/ai_training_manager.py b/simulation/ai/ai_training_manager.py
index 73a2e4b..ab1acd0 100644
--- a/simulation/ai/ai_training_manager.py
+++ b/simulation/ai/ai_training_manager.py
@@ -2,7 +2,7 @@ from __future__ import annotations
 import logging
 import random
 from typing import List, Any, TYPE_CHECKING
-from simulation.ai.api import Personality # Added import
+from simulation.ai.api import Personality  # Added import
 
 if TYPE_CHECKING:
     from simulation.core_agents import Household
@@ -20,7 +20,7 @@ class AITrainingManager:
     def run_imitation_learning_cycle(self, current_tick: int):
         """The main entry point for the imitation learning cycle."""
         logger.info(f"Running imitation learning cycle at tick {current_tick}.")
-        
+
         top_performers = self._get_top_performing_agents()
         if not top_performers:
             logger.info("No top performers found for imitation learning.")
@@ -28,10 +28,12 @@ class AITrainingManager:
 
         under_performers = self._get_under_performing_agents()
         if not under_performers:
-             logger.info("No under performers found for imitation learning.")
-             return
+            logger.info("No under performers found for imitation learning.")
+            return
 
-        logger.info(f"Imitation Cycle: {len(top_performers)} Role Models, {len(under_performers)} Learners.")
+        logger.info(
+            f"Imitation Cycle: {len(top_performers)} Role Models, {len(under_performers)} Learners."
+        )
 
         for learner in under_performers:
             role_model = random.choice(top_performers)
@@ -44,11 +46,13 @@ class AITrainingManager:
 
         # Find the agent with the highest assets
         fittest_agent = max(self.agents, key=lambda x: x.assets)
-        
+
         if fittest_agent.id == target_agent.id:
-            return # Don't clone from self
+            return  # Don't clone from self
 
-        logger.info(f"Cloning from fittest agent {fittest_agent.id} to new agent {target_agent.id}")
+        logger.info(
+            f"Cloning from fittest agent {fittest_agent.id} to new agent {target_agent.id}"
+        )
         self._clone_and_mutate_q_table(fittest_agent, target_agent)
 
     def inherit_brain(self, parent_agent: Household, child_agent: Household) -> None:
@@ -62,7 +66,7 @@ class AITrainingManager:
             child_agent.personality = random.choice(list(Personality))
             logger.info(
                 f"MUTATION | {child_agent.id} mutated personality to {child_agent.personality.name}",
-                extra={"agent_id": child_agent.id, "tags": ["mitosis", "mutation"]}
+                extra={"agent_id": child_agent.id, "tags": ["mitosis", "mutation"]},
             )
         else:
             # Inherit parent personality
@@ -70,20 +74,23 @@ class AITrainingManager:
 
         # Recalculate desire weights based on (possibly new) personality
         # Phase 22.5: Psychology Component update
-        child_agent.psychology.desire_weights = child_agent.psychology._initialize_desire_weights(child_agent.personality)
+        child_agent.psychology.desire_weights = (
+            child_agent.psychology._initialize_desire_weights(child_agent.personality)
+        )
 
         # 2. Q-Table Cloning
         self._clone_and_mutate_q_table(parent_agent, child_agent)
 
         # 3. Education XP Inheritance Bonus (Task #6)
         import math
+
         education_xp = getattr(parent_agent, "education_xp", 0.0)
         sensitivity = getattr(self.config_module, "EDUCATION_SENSITIVITY", 0.1)
         base_rate = getattr(self.config_module, "BASE_LEARNING_RATE", 0.1)
         max_rate = getattr(self.config_module, "MAX_LEARNING_RATE", 0.5)
 
         xp_bonus = math.log1p(education_xp) * sensitivity
-        
+
         # Check if child decision engine has AI engine (RuleBased agents might not)
         if hasattr(child_agent.decision_engine, "ai_engine"):
             child_ai = child_agent.decision_engine.ai_engine
@@ -91,11 +98,12 @@ class AITrainingManager:
 
             logger.info(
                 f"EDUCATION_INHERITANCE | Child {child_agent.id} base_alpha: {child_ai.base_alpha:.4f} (Bonus: {xp_bonus:.4f})",
-                extra={"agent_id": child_agent.id, "tags": ["mitosis", "education"]}
+                extra={"agent_id": child_agent.id, "tags": ["mitosis", "education"]},
             )
 
-
-    def _get_top_performing_agents(self, percentile: float | None = None) -> List[Household]:
+    def _get_top_performing_agents(
+        self, percentile: float | None = None
+    ) -> List[Household]:
         if percentile is None:
             percentile = getattr(self.config_module, "TOP_PERFORMING_PERCENTILE", 0.1)
         """Identifies the top-performing agents based on their assets."""
@@ -106,14 +114,16 @@ class AITrainingManager:
         top_n = max(1, int(len(self.agents) * percentile))
         return sorted_agents[:top_n]
 
-    def _get_under_performing_agents(self, percentile: float | None = None) -> List[Household]:
+    def _get_under_performing_agents(
+        self, percentile: float | None = None
+    ) -> List[Household]:
         if percentile is None:
             percentile = getattr(self.config_module, "UNDER_PERFORMING_PERCENTILE", 0.5)
         """Identifies the under-performing agents based on their assets."""
         if not self.agents:
             return []
 
-        sorted_agents = sorted(self.agents, key=lambda x: x.assets) # Ascending
+        sorted_agents = sorted(self.agents, key=lambda x: x.assets)  # Ascending
         bottom_n = max(1, int(len(self.agents) * percentile))
         return sorted_agents[:bottom_n]
 
@@ -127,7 +137,9 @@ class AITrainingManager:
             return
 
         # FIX: Check if decision engines have 'ai_engine' attribute (skip RuleBased engines)
-        if not hasattr(source_agent.decision_engine, "ai_engine") or not hasattr(target_agent.decision_engine, "ai_engine"):
+        if not hasattr(source_agent.decision_engine, "ai_engine") or not hasattr(
+            target_agent.decision_engine, "ai_engine"
+        ):
             return
 
         source_ai = source_agent.decision_engine.ai_engine
@@ -139,6 +151,7 @@ class AITrainingManager:
             for item_id, source_manager in source_ai.q_consumption.items():
                 if item_id not in target_ai.q_consumption:
                     from simulation.ai.q_table_manager import QTableManager
+
                     target_ai.q_consumption[item_id] = QTableManager()
 
                 target_manager = target_ai.q_consumption[item_id]
@@ -148,7 +161,9 @@ class AITrainingManager:
             self._copy_and_mutate_single_table(source_ai.q_work, target_ai.q_work)
 
         if hasattr(source_ai, "q_investment") and hasattr(target_ai, "q_investment"):
-            self._copy_and_mutate_single_table(source_ai.q_investment, target_ai.q_investment)
+            self._copy_and_mutate_single_table(
+                source_ai.q_investment, target_ai.q_investment
+            )
 
         # --- Handle Legacy Q-Tables (Strategy/Tactic) ---
         # Clone Strategy Q-Table
@@ -156,15 +171,19 @@ class AITrainingManager:
         target_strategy_manager = getattr(target_ai, "q_table_manager_strategy", None)
 
         if source_strategy_manager and target_strategy_manager:
-            self._copy_and_mutate_single_table(source_strategy_manager, target_strategy_manager)
+            self._copy_and_mutate_single_table(
+                source_strategy_manager, target_strategy_manager
+            )
 
         # Clone Tactic Q-Table
         source_tactic_manager = getattr(source_ai, "q_table_manager_tactic", None)
         target_tactic_manager = getattr(target_ai, "q_table_manager_tactic", None)
 
         if source_tactic_manager and target_tactic_manager:
-            self._copy_and_mutate_single_table(source_tactic_manager, target_tactic_manager)
-        
+            self._copy_and_mutate_single_table(
+                source_tactic_manager, target_tactic_manager
+            )
+
         logger.debug(
             f"Cloned and mutated Q-tables from {source_agent.id} to {target_agent.id}."
         )
@@ -178,7 +197,9 @@ class AITrainingManager:
 
         # Mutate the Q-table
         # Use MITOSIS mutation rate if defined, else fallback to imitation rate
-        mitosis_rate = getattr(self.config_module, "MITOSIS_Q_TABLE_MUTATION_RATE", None)
+        mitosis_rate = getattr(
+            self.config_module, "MITOSIS_Q_TABLE_MUTATION_RATE", None
+        )
         imitation_rate = getattr(self.config_module, "IMITATION_MUTATION_RATE", 0.1)
 
         mutation_rate = mitosis_rate if mitosis_rate is not None else imitation_rate
@@ -193,7 +214,7 @@ class AITrainingManager:
                     new_q_table[state][action] += random.uniform(
                         -mutation_magnitude, mutation_magnitude
                     )
-        
+
         target_manager.q_table = new_q_table
 
     def end_episode(self, agents: List[Any]) -> None:
diff --git a/simulation/ai/api.py b/simulation/ai/api.py
index 0f30064..1db2f41 100644
--- a/simulation/ai/api.py
+++ b/simulation/ai/api.py
@@ -106,35 +106,43 @@ class BaseAIEngine(ABC):
         """
         pass
 
-    def _calculate_wealth(self, agent_data: Dict[str, Any], market_data: Dict[str, Any]) -> float:
+    def _calculate_wealth(
+        self, agent_data: Dict[str, Any], market_data: Dict[str, Any]
+    ) -> float:
         """
         ì—ì´ì „íŠ¸ì˜ ìˆœìì‚°(Total Wealth)ì„ ê³„ì‚°í•œë‹¤.
         Wealth = Cash (Assets) + Sum(Inventory * MarketPrice)
         """
         cash = agent_data.get("assets", 0.0)
         inventory = agent_data.get("inventory", {})
-        
+
         # ì‹œì¥ ê°€ê²© ë°ì´í„°ë¥¼ í™œìš©í•˜ì—¬ ì¬ê³  ê°€ì¹˜ í‰ê°€
         # market_data["goods_market"] ì—ëŠ” {item_id_current_sell_price: price} í˜•íƒœì˜ ë°ì´í„°ê°€ ìˆìŒ
         goods_prices = market_data.get("goods_market", {})
         inventory_value = 0.0
-        
+
         for item_id, qty in inventory.items():
-            if item_id == "labor": # ë…¸ë™ë ¥ì€ ì¬ê³  ìì‚°ìœ¼ë¡œ ì¹˜ì§€ ì•ŠìŒ (ë˜ëŠ” ì´ë¯¸ Cashë¡œ ì „í™˜ë¨)
+            if (
+                item_id == "labor"
+            ):  # ë…¸ë™ë ¥ì€ ì¬ê³  ìì‚°ìœ¼ë¡œ ì¹˜ì§€ ì•ŠìŒ (ë˜ëŠ” ì´ë¯¸ Cashë¡œ ì „í™˜ë¨)
                 continue
-            
+
             # 1. ì‹œì¥ ê°€ê²© ì¡°íšŒ
             price_key = f"{item_id}_current_sell_price"
-            market_price = goods_prices.get(price_key, market_data.get("avg_goods_price", 0.0))
-            
+            market_price = goods_prices.get(
+                price_key, market_data.get("avg_goods_price", 0.0)
+            )
+
             # [Patch] 2. ìµœì†Œ ê°€ì¹˜ ë³´ì¥ (ìƒì‚° ì›ê°€ vs ì‹œì¥ê°€ ì¤‘ ë†’ì€ ê²ƒ ì„ íƒ)
             # AIê°€ "ê³ ìš©=ì†í•´"ë¡œ ì˜¤íŒí•˜ëŠ” ê²ƒì„ ë°©ì§€í•˜ê¸° ìœ„í•´, ì‹œì¥ê°€ê°€ ì—†ì–´ë„ ìƒì‚° ì›ê°€ë§Œí¼ì€ ê°€ì¹˜ë¡œ ì¸ì •
-            production_cost = 10.0 # ì„ì‹œ í•˜ë“œì½”ë”© (Configë‚˜ Goods Dataì—ì„œ ê°€ì ¸ì˜¤ëŠ” ê²ƒì´ ì´ìƒì ì„)
-            
+            production_cost = (
+                10.0  # ì„ì‹œ í•˜ë“œì½”ë”© (Configë‚˜ Goods Dataì—ì„œ ê°€ì ¸ì˜¤ëŠ” ê²ƒì´ ì´ìƒì ì„)
+            )
+
             valuation_price = max(market_price, production_cost)
-            
+
             inventory_value += qty * valuation_price
-            
+
         return cash + inventory_value
 
     def _calculate_reward(
@@ -150,7 +158,7 @@ class BaseAIEngine(ABC):
         """
         pre_wealth = self._calculate_wealth(pre_state_data, market_data)
         post_wealth = self._calculate_wealth(post_state_data, market_data)
-        
+
         return post_wealth - pre_wealth
 
     def decide_and_learn(
diff --git a/simulation/ai/enums.py b/simulation/ai/enums.py
index 1317e35..fcc9925 100644
--- a/simulation/ai/enums.py
+++ b/simulation/ai/enums.py
@@ -36,7 +36,9 @@ class Tactic(Enum):
     # --- ê°€ê³„ìš© Tactics ---
     # ì†Œë¹„ ê²°ì •
     EVALUATE_CONSUMPTION_OPTIONS = auto()  # ëª¨ë“  ì†Œë¹„ì¬ êµ¬ë§¤ë¥¼ ì´ í•˜ë‚˜ì˜ ì „ìˆ ë¡œ í†µí•©
-    BUY_FOR_BUFFER = auto() # ê°€ê²©ì´ ìœ ë¦¬í•  ë•Œ í•„ìˆ˜í’ˆ(ì˜ˆ: food)ì˜ ì¸ë²¤í† ë¦¬ ì™„ì¶©ì¬ë¥¼ ì±„ìš°ê¸° ìœ„í•œ êµ¬ë§¤ í–‰ë™.
+    BUY_FOR_BUFFER = (
+        auto()
+    )  # ê°€ê²©ì´ ìœ ë¦¬í•  ë•Œ í•„ìˆ˜í’ˆ(ì˜ˆ: food)ì˜ ì¸ë²¤í† ë¦¬ ì™„ì¶©ì¬ë¥¼ ì±„ìš°ê¸° ìœ„í•œ êµ¬ë§¤ í–‰ë™.
     BUY_BASIC_FOOD = auto()
     BUY_LUXURY_FOOD = auto()
     DO_NOTHING_CONSUMPTION = auto()
@@ -83,13 +85,13 @@ class Personality(Enum):
     MISER = auto()  # ìˆ˜ì „ë…¸í˜• (Asset-Focused)
     STATUS_SEEKER = auto()  # ì§€ìœ„ì¶”êµ¬í˜• (Status-Seeking)
     GROWTH_ORIENTED = auto()  # í•™ìŠµí˜• (Growth-Oriented)
-    IMPULSIVE = auto()     # ì¶©ë™êµ¬ë§¤í˜• (High Adaptation, High Hoarding)
+    IMPULSIVE = auto()  # ì¶©ë™êµ¬ë§¤í˜• (High Adaptation, High Hoarding)
     CONSERVATIVE = auto()  # ë³´ìˆ˜ì í˜• (Low Adaptation)
 
     # --- Firm Personalities (Phase 16-B) ---
-    BALANCED = auto()        # ê· í˜•í˜• (Profit + Brand)
-    GROWTH_HACKER = auto()   # ì„±ì¥í˜• (Market Share + Quality)
-    CASH_COW = auto()        # ìˆ˜ìµí˜• (Dividends + Cash Flow)
+    BALANCED = auto()  # ê· í˜•í˜• (Profit + Brand)
+    GROWTH_HACKER = auto()  # ì„±ì¥í˜• (Market Share + Quality)
+    CASH_COW = auto()  # ìˆ˜ìµí˜• (Dividends + Cash Flow)
 
 
 class Aggressiveness(Enum):
@@ -102,10 +104,12 @@ class Aggressiveness(Enum):
     NEUTRAL = auto()
     AGGRESSIVE = auto()
 
+
 class PoliticalParty(Enum):
     """
     Phase 17-5: Leviathan
     Political Parties with distinct policy biases.
     """
-    BLUE = auto() # Pro-Corporate (Low Corp Tax, Subsidies)
+
+    BLUE = auto()  # Pro-Corporate (Low Corp Tax, Subsidies)
     RED = auto()  # Pro-Household (Low Income Tax, Welfare)
diff --git a/simulation/ai/firm_ai.py b/simulation/ai/firm_ai.py
index 14812c8..f33990f 100644
--- a/simulation/ai/firm_ai.py
+++ b/simulation/ai/firm_ai.py
@@ -35,15 +35,15 @@ class FirmAI(BaseAIEngine):
         super().__init__(agent_id, gamma, epsilon, base_alpha, learning_focus)
         self.ai_decision_engine: AIDecisionEngine | None = None
         self.set_ai_decision_engine(ai_decision_engine)
-        
+
         # 6-Channel Q-Tables (WO-027)
         self.q_sales = QTableManager()
         self.q_hiring = QTableManager()
-        self.q_rd = QTableManager()     # Innovation
-        self.q_capital = QTableManager() # CAPEX
+        self.q_rd = QTableManager()  # Innovation
+        self.q_capital = QTableManager()  # CAPEX
         self.q_dividend = QTableManager()
-        self.q_debt = QTableManager()    # Leverage
-        
+        self.q_debt = QTableManager()  # Leverage
+
         # State Tracking
         self.last_state: Optional[Tuple] = None
         self.last_actions_idx: Dict[str, int] = {}
@@ -51,14 +51,18 @@ class FirmAI(BaseAIEngine):
     def set_ai_decision_engine(self, engine: "AIDecisionEngine"):
         self.ai_decision_engine = engine
 
-    def _get_common_state(self, agent_data: Dict[str, Any], market_data: Dict[str, Any]) -> Tuple:
+    def _get_common_state(
+        self, agent_data: Dict[str, Any], market_data: Dict[str, Any]
+    ) -> Tuple:
         """
         Common state features shared across channels.
         Includes: Profitability, Inventory Level, Cash Level, Debt Metrics
         """
         # 1. Inventory Level (0=Empty, 1=Target, 2=Over)
         target = agent_data.get("production_target", 100)
-        curr = agent_data.get("inventory", {}).get(agent_data.get("specialization", "food"), 0)
+        curr = agent_data.get("inventory", {}).get(
+            agent_data.get("specialization", "food"), 0
+        )
         inv_ratio = curr / target if target > 0 else 0
         inv_idx = self._discretize(inv_ratio, [0.2, 0.5, 0.8, 1.0, 1.2, 1.5])
 
@@ -68,7 +72,9 @@ class FirmAI(BaseAIEngine):
         cash_idx = self._discretize(cash, [100, 500, 1000, 5000, 10000])
 
         # 3. Debt Ratio
-        debt_info = market_data.get("debt_data", {}).get(self.agent_id, {"total_principal": 0.0, "daily_interest_burden": 0.0})
+        debt_info = market_data.get("debt_data", {}).get(
+            self.agent_id, {"total_principal": 0.0, "daily_interest_burden": 0.0}
+        )
         total_debt = debt_info.get("total_principal", 0.0)
         interest_burden = debt_info.get("daily_interest_burden", 0.0)
 
@@ -96,27 +102,27 @@ class FirmAI(BaseAIEngine):
 
         # 1. Sales Channel (Pricing)
         sales_idx = self.action_selector.choose_action(self.q_sales, state, actions)
-        self.last_actions_idx['sales'] = sales_idx
+        self.last_actions_idx["sales"] = sales_idx
 
         # 2. Hiring Channel (Employment)
         hiring_idx = self.action_selector.choose_action(self.q_hiring, state, actions)
-        self.last_actions_idx['hiring'] = hiring_idx
+        self.last_actions_idx["hiring"] = hiring_idx
 
         # 3. R&D Channel (Innovation)
         rd_idx = self.action_selector.choose_action(self.q_rd, state, actions)
-        self.last_actions_idx['rd'] = rd_idx
+        self.last_actions_idx["rd"] = rd_idx
 
         # 4. Capital Channel (CAPEX)
         cap_idx = self.action_selector.choose_action(self.q_capital, state, actions)
-        self.last_actions_idx['capital'] = cap_idx
+        self.last_actions_idx["capital"] = cap_idx
 
         # 5. Dividend Channel
         div_idx = self.action_selector.choose_action(self.q_dividend, state, actions)
-        self.last_actions_idx['dividend'] = div_idx
+        self.last_actions_idx["dividend"] = div_idx
 
         # 6. Debt Channel (Leverage)
         debt_idx = self.action_selector.choose_action(self.q_debt, state, actions)
-        self.last_actions_idx['debt'] = debt_idx
+        self.last_actions_idx["debt"] = debt_idx
 
         vector = FirmActionVector(
             sales_aggressiveness=self.AGGRESSIVENESS_LEVELS[sales_idx],
@@ -124,12 +130,12 @@ class FirmAI(BaseAIEngine):
             rd_aggressiveness=self.AGGRESSIVENESS_LEVELS[rd_idx],
             capital_aggressiveness=self.AGGRESSIVENESS_LEVELS[cap_idx],
             dividend_aggressiveness=self.AGGRESSIVENESS_LEVELS[div_idx],
-            debt_aggressiveness=self.AGGRESSIVENESS_LEVELS[debt_idx]
+            debt_aggressiveness=self.AGGRESSIVENESS_LEVELS[debt_idx],
         )
 
         logger.debug(
             f"FIRM_AI_V2 | Firm {self.agent_id} | Vector: {vector}",
-            extra={"tags": ["ai_v2"]}
+            extra={"tags": ["ai_v2"]},
         )
 
         return vector
@@ -148,15 +154,15 @@ class FirmAI(BaseAIEngine):
 
         next_state = self._get_common_state(next_agent_data, next_market_data)
         all_actions = list(range(len(self.AGGRESSIVENESS_LEVELS)))
-        
+
         # Update All Channels
         managers = [
-            (self.q_sales, 'sales'),
-            (self.q_hiring, 'hiring'),
-            (self.q_rd, 'rd'),
-            (self.q_capital, 'capital'),
-            (self.q_dividend, 'dividend'),
-            (self.q_debt, 'debt'),
+            (self.q_sales, "sales"),
+            (self.q_hiring, "hiring"),
+            (self.q_rd, "rd"),
+            (self.q_capital, "capital"),
+            (self.q_dividend, "dividend"),
+            (self.q_debt, "debt"),
         ]
 
         for q_mgr, key in managers:
@@ -169,10 +175,12 @@ class FirmAI(BaseAIEngine):
                     next_state,
                     all_actions,
                     self.base_alpha,
-                    self.gamma
+                    self.gamma,
                 )
 
-    def calculate_reward(self, firm_agent: "Firm", prev_state: Dict, current_state: Dict) -> float:
+    def calculate_reward(
+        self, firm_agent: "Firm", prev_state: Dict, current_state: Dict
+    ) -> float:
         """
         Calculate reward based on Firm Personality (WO-027).
         """
@@ -190,7 +198,7 @@ class FirmAI(BaseAIEngine):
         current_awareness = firm_agent.brand_manager.brand_awareness
         prev_awareness = firm_agent.prev_awareness
         delta_awareness = current_awareness - prev_awareness
-        firm_agent.prev_awareness = current_awareness # Update state
+        firm_agent.prev_awareness = current_awareness  # Update state
 
         reward = 0.0
 
@@ -208,7 +216,9 @@ class FirmAI(BaseAIEngine):
 
             # Using Revenue Growth as proxy for Market Share Delta
             current_revenue = current_state.get("revenue_this_turn", 0.0)
-            prev_revenue = firm_agent.last_revenue # This might be from 2 ticks ago if not careful
+            prev_revenue = (
+                firm_agent.last_revenue
+            )  # This might be from 2 ticks ago if not careful
             # Better: firm_agent.prev_market_share tracked in Firm class?
             # Let's use simple proxy: Delta Revenue * 0.5
 
@@ -218,13 +228,17 @@ class FirmAI(BaseAIEngine):
             delta_quality = current_quality - prev_quality
             firm_agent.prev_avg_quality = current_quality
 
-            reward = (delta_assets * 0.1) + (delta_quality * 200.0) + (net_profit * 0.01) # Profit matters less
+            reward = (
+                (delta_assets * 0.1) + (delta_quality * 200.0) + (net_profit * 0.01)
+            )  # Profit matters less
 
         elif personality == Personality.CASH_COW:
             # Reward = (Dividends_Paid * 2.0) + (Net_Profit * 1.0) + (Free_Cash_Flow * 0.5)
             # Dividends Paid is needed. It's not in agent_data directly unless we track it.
             # We can track it on the firm agent during the tick.
-            dividends_paid = getattr(firm_agent, 'dividends_paid_last_tick', 0.0) # Need to add this tracking
+            dividends_paid = getattr(
+                firm_agent, "dividends_paid_last_tick", 0.0
+            )  # Need to add this tracking
 
             reward = (dividends_paid * 2.0) + (net_profit * 1.0)
 
@@ -234,15 +248,22 @@ class FirmAI(BaseAIEngine):
 
         logger.debug(
             f"FIRM_REWARD | Firm {firm_agent.id} ({personality.name}) | Reward={reward:.2f}",
-            extra={"agent_id": firm_agent.id}
+            extra={"agent_id": firm_agent.id},
         )
         return reward
 
     # Legacy Methods (Required by BaseAIEngine ABC but unused/deprecated)
-    def _get_strategic_state(self, a, m): pass
-    def _get_tactical_state(self, i, a, m): pass
-    def _get_strategic_actions(self): pass
-    def _get_tactical_actions(self, i): pass
+    def _get_strategic_state(self, a, m):
+        pass
+
+    def _get_tactical_state(self, i, a, m):
+        pass
+
+    def _get_strategic_actions(self):
+        pass
+
+    def _get_tactical_actions(self, i):
+        pass
 
     def _calculate_reward(self, *args):
-        return 0.0 # Deprecated
+        return 0.0  # Deprecated
diff --git a/simulation/ai/firm_system2_planner.py b/simulation/ai/firm_system2_planner.py
index f17deb2..9e5f9be 100644
--- a/simulation/ai/firm_system2_planner.py
+++ b/simulation/ai/firm_system2_planner.py
@@ -5,6 +5,7 @@ from simulation.ai.enums import Personality
 
 logger = logging.getLogger(__name__)
 
+
 class FirmSystem2Planner:
     """
     Firm System 2 Planner (Phase 21).
@@ -15,7 +16,7 @@ class FirmSystem2Planner:
     """
 
     def __init__(self, firm: Any, config_module: Any):
-        self.firm = firm # Deprecated, keep for compatibility if needed or pass None
+        self.firm = firm  # Deprecated, keep for compatibility if needed or pass None
         self.config = config_module
         self.logger = logging.getLogger(__name__)
 
@@ -28,13 +29,21 @@ class FirmSystem2Planner:
         self.last_calc_tick = -999
         self.cached_guidance: Dict[str, Any] = {}
 
-    def project_future(self, current_tick: int, market_data: Dict[str, Any], firm_state: Optional[Any] = None) -> Dict[str, Any]:
+    def project_future(
+        self,
+        current_tick: int,
+        market_data: Dict[str, Any],
+        firm_state: Optional[Any] = None,
+    ) -> Dict[str, Any]:
         """
         Projects future cash flows to determine strategic direction.
         Returns guidance dictionary.
         Uses firm_state (FirmStateDTO).
         """
-        if current_tick - self.last_calc_tick < self.calc_interval and self.cached_guidance:
+        if (
+            current_tick - self.last_calc_tick < self.calc_interval
+            and self.cached_guidance
+        ):
             return self.cached_guidance
 
         self.last_calc_tick = current_tick
@@ -45,12 +54,12 @@ class FirmSystem2Planner:
 
         # Abstraction layer to access data from DTO
         revenue = firm_state.revenue_this_turn
-        last_revenue = revenue # DTO might not have last_revenue, approximate
+        last_revenue = revenue  # DTO might not have last_revenue, approximate
 
         # Sum wages from employees_data
         current_wages = 0.0
         if firm_state.employees_data:
-            current_wages = sum(e['wage'] for e in firm_state.employees_data.values())
+            current_wages = sum(e["wage"] for e in firm_state.employees_data.values())
 
         automation_level = firm_state.automation_level
 
@@ -80,7 +89,9 @@ class FirmSystem2Planner:
         # 3. Scenario Analysis: Automation Investment
 
         # Scenario A: Status Quo
-        npv_status_quo = self._calculate_npv(base_revenue, current_wages, current_maintenance, 0.0)
+        npv_status_quo = self._calculate_npv(
+            base_revenue, current_wages, current_maintenance, 0.0
+        )
 
         # Scenario B: High Automation (Target 0.8)
         target_a = 0.8
@@ -99,7 +110,12 @@ class FirmSystem2Planner:
         projected_wages_automated = current_wages - wage_savings
 
         # NPV Automated = NPV(Revenue, Lower Wages) - Investment Cost
-        npv_automated = self._calculate_npv(base_revenue, projected_wages_automated, current_maintenance, 0.0) - investment_cost
+        npv_automated = (
+            self._calculate_npv(
+                base_revenue, projected_wages_automated, current_maintenance, 0.0
+            )
+            - investment_cost
+        )
 
         # 4. Strategic Decision
         target_automation = current_a
@@ -107,21 +123,24 @@ class FirmSystem2Planner:
         # Hurdle Rate Logic
         hurdle = 1.1
         if personality == Personality.CASH_COW:
-             hurdle = 1.0 # No premium needed
+            hurdle = 1.0  # No premium needed
 
         # Check if investment is logically sound (NPV > Status Quo)
         if npv_automated > npv_status_quo * hurdle:
             target_automation = max(target_automation, target_a)
             # If CASH_COW, push it further?
             if personality == Personality.CASH_COW:
-                 target_automation = max(target_automation, 0.9)
+                target_automation = max(target_automation, 0.9)
 
         # 6. R&D Strategy
         rd_intensity = 0.2 if personality == Personality.GROWTH_HACKER else 0.05
 
         # 7. M&A Strategy
         expansion_mode = "ORGANIC"
-        if personality == Personality.GROWTH_HACKER or personality == Personality.BALANCED:
+        if (
+            personality == Personality.GROWTH_HACKER
+            or personality == Personality.BALANCED
+        ):
             if assets > revenue * 50:
                 expansion_mode = "MA"
 
@@ -130,7 +149,7 @@ class FirmSystem2Planner:
             "rd_intensity": rd_intensity,
             "expansion_mode": expansion_mode,
             "npv_status_quo": npv_status_quo,
-            "npv_automated": npv_automated
+            "npv_automated": npv_automated,
         }
 
         self.cached_guidance = guidance
@@ -145,7 +164,7 @@ class FirmSystem2Planner:
             cost = wages + maintenance
             cash_flow = rev - cost - investment_flow
 
-            discount = self.discount_rate ** t
+            discount = self.discount_rate**t
             npv += cash_flow * discount
 
         return npv
diff --git a/simulation/ai/government_ai.py b/simulation/ai/government_ai.py
index 672ffc0..f5cf42d 100644
--- a/simulation/ai/government_ai.py
+++ b/simulation/ai/government_ai.py
@@ -6,6 +6,7 @@ from simulation.ai.action_selector import ActionSelector
 
 logger = logging.getLogger(__name__)
 
+
 class GovernmentAI:
     """
     Intelligent Government AI (Brain Module).
@@ -59,11 +60,13 @@ class GovernmentAI:
         """
         # WO-057-Fix: Use live sensory data. If not available, return neutral state.
         if not self.agent.sensory_data:
-            return (1, 1, 1, 1) # Neutral state
+            return (1, 1, 1, 1)  # Neutral state
 
         # 1. Retrieve Targets from Config
         target_inflation = getattr(self.config_module, "TARGET_INFLATION_RATE", 0.02)
-        target_unemployment = getattr(self.config_module, "TARGET_UNEMPLOYMENT_RATE", 0.04)
+        target_unemployment = getattr(
+            self.config_module, "TARGET_UNEMPLOYMENT_RATE", 0.04
+        )
 
         # 2. Retrieve Current Metrics from Sensory DTO
         inflation = self.agent.sensory_data.inflation_sma
@@ -75,31 +78,43 @@ class GovernmentAI:
         assets = getattr(self.agent, "assets", 0.0)
         debt = max(0.0, -assets)
         debt_ratio = debt / current_gdp if current_gdp > 0 else 0.0
-        debt_gap_val = debt_ratio - 0.60 # Target Debt Ratio 60%
+        debt_gap_val = debt_ratio - 0.60  # Target Debt Ratio 60%
 
         # 3. Discretize
         # Inflation Gap: I - I*
         inf_gap_val = inflation - target_inflation
-        if inf_gap_val < -0.01: s_inf = 0
-        elif inf_gap_val > 0.01: s_inf = 2
-        else: s_inf = 1
+        if inf_gap_val < -0.01:
+            s_inf = 0
+        elif inf_gap_val > 0.01:
+            s_inf = 2
+        else:
+            s_inf = 1
 
         # Unemployment Gap: U - U*
         unemp_gap_val = unemployment - target_unemployment
-        if unemp_gap_val < -0.01: s_unemp = 0
-        elif unemp_gap_val > 0.01: s_unemp = 2
-        else: s_unemp = 1
+        if unemp_gap_val < -0.01:
+            s_unemp = 0
+        elif unemp_gap_val > 0.01:
+            s_unemp = 2
+        else:
+            s_unemp = 1
 
         # GDP Growth (Directly, not as a gap)
         # Thresholds: <0% is bad, >2% is good? Let's use -0.5% and +0.5% for now.
-        if gdp_growth < -0.005: s_gdp = 0 # Low (Recession)
-        elif gdp_growth > 0.005: s_gdp = 2 # High (Overheating)
-        else: s_gdp = 1 # Ideal
+        if gdp_growth < -0.005:
+            s_gdp = 0  # Low (Recession)
+        elif gdp_growth > 0.005:
+            s_gdp = 2  # High (Overheating)
+        else:
+            s_gdp = 1  # Ideal
 
         # Debt Gap: Ratio - 0.6
-        if debt_gap_val < -0.05: s_debt = 0 # Low
-        elif debt_gap_val > 0.05: s_debt = 2 # High
-        else: s_debt = 1 # Ideal
+        if debt_gap_val < -0.05:
+            s_debt = 0  # Low
+        elif debt_gap_val > 0.05:
+            s_debt = 2  # High
+        else:
+            s_debt = 1  # Ideal
 
         return (s_inf, s_unemp, s_gdp, s_debt)
 
@@ -114,7 +129,9 @@ class GovernmentAI:
             return 0.0
 
         target_inflation = getattr(self.config_module, "TARGET_INFLATION_RATE", 0.02)
-        target_unemployment = getattr(self.config_module, "TARGET_UNEMPLOYMENT_RATE", 0.04)
+        target_unemployment = getattr(
+            self.config_module, "TARGET_UNEMPLOYMENT_RATE", 0.04
+        )
 
         # Retrieve metrics from Sensory DTO
         inflation = self.agent.sensory_data.inflation_sma
@@ -132,7 +149,7 @@ class GovernmentAI:
         debt_gap = debt_ratio - 0.60
 
         # Calculate Reward (Loss Function)
-        loss = (0.5 * (inf_gap ** 2)) + (0.4 * (unemp_gap ** 2)) + (0.1 * (debt_gap ** 2))
+        loss = (0.5 * (inf_gap**2)) + (0.4 * (unemp_gap**2)) + (0.1 * (debt_gap**2))
         reward = -loss * 100.0  # Scale for significance
 
         return reward
@@ -147,7 +164,9 @@ class GovernmentAI:
         state = self._get_state()
 
         # Action Selection
-        action_idx = self.action_selector.choose_action(self.q_table, state, self.actions, current_tick=current_tick)
+        action_idx = self.action_selector.choose_action(
+            self.q_table, state, self.actions, current_tick=current_tick
+        )
 
         # Learning happens in update_learning, called separately (or before next decision)
         # We just return the decision here.
@@ -189,9 +208,7 @@ class GovernmentAI:
             next_state=current_state,
             next_actions=self.actions,
             alpha=self.alpha,
-            gamma=self.gamma
+            gamma=self.gamma,
         )
 
-        logger.debug(
-            f"GOV_AI_LEARN | Reward: {real_reward:.5f} | Tick: {current_tick}"
-        )
+        logger.debug(f"GOV_AI_LEARN | Reward: {real_reward:.5f} | Tick: {current_tick}")
diff --git a/simulation/ai/household_ai.py b/simulation/ai/household_ai.py
index 2e6087d..913f404 100644
--- a/simulation/ai/household_ai.py
+++ b/simulation/ai/household_ai.py
@@ -33,10 +33,10 @@ class HouseholdAI(BaseAIEngine):
         super().__init__(agent_id, gamma, epsilon, base_alpha, learning_focus)
         self.ai_decision_engine: AIDecisionEngine | None = None
         self.set_ai_decision_engine(ai_decision_engine)
-        
+
         # New Q-Table Managers
         # One Q-Table per Consumption Category (e.g., 'basic_food', 'luxury')
-        self.q_consumption: Dict[str, QTableManager] = {} 
+        self.q_consumption: Dict[str, QTableManager] = {}
         self.q_work = QTableManager()
         self.q_investment = QTableManager()  # ì£¼ì‹ íˆ¬ì ì ê·¹ì„± Q-í…Œì´ë¸”
 
@@ -51,7 +51,9 @@ class HouseholdAI(BaseAIEngine):
     def set_ai_decision_engine(self, engine: "AIDecisionEngine"):
         self.ai_decision_engine = engine
 
-    def _get_common_state(self, agent_data: Dict[str, Any], market_data: Dict[str, Any]) -> Tuple:
+    def _get_common_state(
+        self, agent_data: Dict[str, Any], market_data: Dict[str, Any]
+    ) -> Tuple:
         """
         Common state: Assets, General Needs, Debt Ratio, Interest Burden
         """
@@ -59,23 +61,27 @@ class HouseholdAI(BaseAIEngine):
         assets = agent_data.get("assets", 0)
         asset_bins = [100.0, 500.0, 2000.0, 10000.0]
         asset_idx = self._discretize(assets, asset_bins)
-        
+
         # 2. Avg Need Level
         needs = agent_data.get("needs", {})
         avg_need = sum(needs.values()) / max(len(needs), 1)
         need_idx = self._discretize(avg_need, [20, 50, 80])
 
         # 3. Debt Metrics (from market_data injection)
-        debt_info = market_data.get("debt_data", {}).get(self.agent_id, {"total_principal": 0.0, "daily_interest_burden": 0.0})
+        debt_info = market_data.get("debt_data", {}).get(
+            self.agent_id, {"total_principal": 0.0, "daily_interest_burden": 0.0}
+        )
         total_debt = debt_info.get("total_principal", 0.0)
         interest_burden = debt_info.get("daily_interest_burden", 0.0)
 
         debt_ratio = total_debt / assets if assets > 0 else 0.0
         debt_idx = self._discretize(debt_ratio, [0.1, 0.3, 0.5, 0.8])
-        
+
         # 4. Interest Burden Ratio (vs Asset or Income Proxy)
         # Using asset as income proxy since income is volatile
-        burden_ratio = interest_burden / (assets * 0.01 + 1e-9) # Assume 1% daily return as baseline
+        burden_ratio = interest_burden / (
+            assets * 0.01 + 1e-9
+        )  # Assume 1% daily return as baseline
         burden_idx = self._discretize(burden_ratio, [0.1, 0.2, 0.5])
 
         return (asset_idx, need_idx, debt_idx, burden_idx)
@@ -84,13 +90,13 @@ class HouseholdAI(BaseAIEngine):
         self,
         agent_data: Dict[str, Any],
         market_data: Dict[str, Any],
-        goods_list: List[str] # List of item_ids to decide consumption for
+        goods_list: List[str],  # List of item_ids to decide consumption for
     ) -> HouseholdActionVector:
         """
         Decide aggressiveness for consumption (per item) and work.
         """
         state = self._get_common_state(agent_data, market_data)
-        
+
         # 1. Consumption Aggressiveness
         consumption_aggressiveness = {}
         self.last_consumption_states = {}
@@ -111,14 +117,11 @@ class HouseholdAI(BaseAIEngine):
 
         for item_id in goods_list:
             if item_id not in self.q_consumption:
-
-
-
                 self.q_consumption[item_id] = QTableManager()
-            
-            item_state = state 
+
+            item_state = state
             self.last_consumption_states[item_id] = item_state
-            
+
             actions = list(range(len(self.AGGRESSIVENESS_LEVELS)))
             action_idx = self.action_selector.choose_action(
                 self.q_consumption[item_id], item_state, actions
@@ -150,10 +153,6 @@ class HouseholdAI(BaseAIEngine):
 
             consumption_aggressiveness[item_id] = agg
 
-
-
-
-
         # 2. Work Aggressiveness
         self.last_work_state = state
         work_actions = list(range(len(self.AGGRESSIVENESS_LEVELS)))
@@ -183,15 +182,11 @@ class HouseholdAI(BaseAIEngine):
             consumption_aggressiveness=consumption_aggressiveness,
             work_aggressiveness=work_agg,
             learning_aggressiveness=0.0,
-            investment_aggressiveness=investment_agg
+            investment_aggressiveness=investment_agg,
         )
 
-
     def decide_reproduction(
-        self,
-        agent_data: Dict[str, Any],
-        market_data: Dict[str, Any],
-        current_time: int
+        self, agent_data: Dict[str, Any], market_data: Dict[str, Any], current_time: int
     ) -> bool:
         """
         Phase 19: Evolutionary Reproduction Decision
@@ -221,7 +216,9 @@ class HouseholdAI(BaseAIEngine):
         child_monthly_cost = getattr(config_module, "CHILD_MONTHLY_COST", 500.0)
         opp_cost_factor = getattr(config_module, "OPPORTUNITY_COST_FACTOR", 0.5)
         raising_years = getattr(config_module, "RAISING_YEARS", 20)
-        child_emotional_value_base = getattr(config_module, "CHILD_EMOTIONAL_VALUE_BASE", 200000.0)
+        child_emotional_value_base = getattr(
+            config_module, "CHILD_EMOTIONAL_VALUE_BASE", 200000.0
+        )
         old_age_support_rate = getattr(config_module, "OLD_AGE_SUPPORT_RATE", 0.1)
         support_years = getattr(config_module, "SUPPORT_YEARS", 20)
 
@@ -279,7 +276,7 @@ class HouseholdAI(BaseAIEngine):
         for item_id, q_manager in self.q_consumption.items():
             last_state = self.last_consumption_states.get(item_id)
             last_action = self.last_consumption_action_idxs.get(item_id)
-            
+
             if last_state is not None and last_action is not None:
                 q_manager.update_q_table(
                     last_state,
@@ -288,7 +285,7 @@ class HouseholdAI(BaseAIEngine):
                     next_state,
                     actions,
                     self.base_alpha,
-                    self.gamma
+                    self.gamma,
                 )
 
         # Update Work Q-Table
@@ -300,11 +297,14 @@ class HouseholdAI(BaseAIEngine):
                 next_state,
                 actions,
                 self.base_alpha,
-                self.gamma
+                self.gamma,
             )
 
         # Update Investment Q-Table
-        if self.last_investment_state is not None and self.last_investment_action_idx is not None:
+        if (
+            self.last_investment_state is not None
+            and self.last_investment_action_idx is not None
+        ):
             self.q_investment.update_q_table(
                 self.last_investment_state,
                 self.last_investment_action_idx,
@@ -312,56 +312,74 @@ class HouseholdAI(BaseAIEngine):
                 next_state,
                 actions,
                 self.base_alpha,
-                self.gamma
+                self.gamma,
             )
 
     # Legacy Methods
-    def _get_strategic_state(self, a, m): pass
-    def _get_tactical_state(self, i, a, m): pass
-    def _get_strategic_actions(self): pass
-    def _get_tactical_actions(self, i): pass
-    def _calculate_reward(self, pre_state_data, post_state_data, agent_data, market_data):
+    def _get_strategic_state(self, a, m):
+        pass
+
+    def _get_tactical_state(self, i, a, m):
+        pass
+
+    def _get_strategic_actions(self):
+        pass
+
+    def _get_tactical_actions(self, i):
+        pass
+
+    def _calculate_reward(
+        self, pre_state_data, post_state_data, agent_data, market_data
+    ):
         """
         ê°€ê³„ ë³´ìƒ: Wealth ì¦ë¶„ + ìš•êµ¬ í•´ì†Œ ë§Œì¡±ë„.
         """
         # 1. Wealth Delta
-        wealth_reward = super()._calculate_reward(pre_state_data, post_state_data, agent_data, market_data)
-        
+        wealth_reward = super()._calculate_reward(
+            pre_state_data, post_state_data, agent_data, market_data
+        )
+
         # 2. Need Satisfaction (ìš•êµ¬ ê°ì†ŒëŸ‰)
         pre_needs = pre_state_data.get("needs", {})
         post_needs = post_state_data.get("needs", {})
-        
+
         need_reduction = sum(pre_needs.values()) - sum(post_needs.values())
-        
+
         # ê°€ì¤‘ì¹˜ ì ìš© (configì—ì„œ ê°€ì ¸ì˜¤ê±°ë‚˜ ê¸°ë³¸ê°’ ì‚¬ìš©)
         # íŒ: ê°€ê³„ì˜ ê²½ìš° ìš•êµ¬ í•´ì†Œê°€ ìì‚° ì¦ì‹ë³´ë‹¤ ë” ê°•ë ¥í•œ ë™ê¸°ì¼ ìˆ˜ ìˆìŒ.
         asset_weight = 1.0
-        growth_weight = 5.0 # ìš•êµ¬ í•´ì†Œì— ë” ë†’ì€ ê°€ì¤‘ì¹˜
-        
+        growth_weight = 5.0  # ìš•êµ¬ í•´ì†Œì— ë” ë†’ì€ ê°€ì¤‘ì¹˜
+
         # 3. Leisure Utility (Phase 5)
         # agent_data is injected with 'leisure_utility' in engine.py
         leisure_utility = agent_data.get("leisure_utility", 0.0)
 
         # Use config LEISURE_WEIGHT if available, else default 0.3
         leisure_weight = 0.3
-        if self.ai_decision_engine and getattr(self.ai_decision_engine, "config_module", None):
-            leisure_weight = getattr(self.ai_decision_engine.config_module, "LEISURE_WEIGHT", 0.3)
+        if self.ai_decision_engine and getattr(
+            self.ai_decision_engine, "config_module", None
+        ):
+            leisure_weight = getattr(
+                self.ai_decision_engine.config_module, "LEISURE_WEIGHT", 0.3
+            )
             if not isinstance(leisure_weight, (int, float)):
                 leisure_weight = 0.3
 
         total_reward = (
-            (wealth_reward * asset_weight) +
-            (need_reduction * growth_weight) +
-            (leisure_utility * leisure_weight)
+            (wealth_reward * asset_weight)
+            + (need_reduction * growth_weight)
+            + (leisure_utility * leisure_weight)
         )
-        
+
         # --- Phase 17-4: Vanity Reward (Relative Deprivation) ---
-        if self.ai_decision_engine and getattr(self.ai_decision_engine, "config_module", None):
+        if self.ai_decision_engine and getattr(
+            self.ai_decision_engine, "config_module", None
+        ):
             config = self.ai_decision_engine.config_module
             # Handle Mock returning Mock for boolean check
             enable_vanity = getattr(config, "ENABLE_VANITY_SYSTEM", False)
             if not isinstance(enable_vanity, bool):
-                 enable_vanity = False
+                enable_vanity = False
 
             if enable_vanity:
                 # Calculate Social Component
@@ -380,21 +398,22 @@ class HouseholdAI(BaseAIEngine):
                 social_component = my_rank - ref_percentile_threshold
 
                 # Conformity Weight
-                conformity = agent_data.get("conformity", 0.5) # Fallback 0.5
+                conformity = agent_data.get("conformity", 0.5)  # Fallback 0.5
                 vanity_weight = getattr(config, "VANITY_WEIGHT", 1.0)
                 if not isinstance(vanity_weight, (int, float)):
                     vanity_weight = 1.0
 
                 vanity_effect = conformity * social_component * vanity_weight
-                total_reward += (vanity_effect * 100.0)
+                total_reward += vanity_effect * 100.0
 
         return total_reward
+
     def decide_time_allocation(
         self,
         agent_data: Dict[str, Any],
         spouse_data: Optional[Dict[str, Any]] = None,
         children_data: List[Dict[str, Any]] = [],
-        config_module: Any = None
+        config_module: Any = None,
     ) -> Dict[str, float]:
         """
         Phase 20 Step 2: Socio-Tech Time Demand Model
@@ -431,7 +450,7 @@ class HouseholdAI(BaseAIEngine):
         home_quality = agent_data.get("home_quality_score", 1.0)
         housework_modifier = 1.0
         if home_quality > 1.2:
-            housework_modifier = 0.5 # 50% reduction!
+            housework_modifier = 0.5  # 50% reduction!
 
         required_housework = base_housework * housework_modifier
 
@@ -442,7 +461,7 @@ class HouseholdAI(BaseAIEngine):
         for child in children_data:
             if child.get("age", 5) <= 2:
                 has_infant = True
-                break # Only count once per day? Or per child? Spec: "0~2ì„¸ ìë…€ ì¡´ì¬ ì‹œ +8ì‹œê°„" (Binary condition effectively)
+                break  # Only count once per day? Or per child? Spec: "0~2ì„¸ ìë…€ ì¡´ì¬ ì‹œ +8ì‹œê°„" (Binary condition effectively)
 
         if has_infant:
             childcare_hours = 8.0
@@ -465,7 +484,7 @@ class HouseholdAI(BaseAIEngine):
 
             # Childcare Sharing
             if has_infant:
-                if tech_level < 0.5: # No Formula
+                if tech_level < 0.5:  # No Formula
                     # Strong Lactation Lock
                     # If Female: Take 100% of childcare (8h)
                     # If Male: Take 0%
@@ -490,5 +509,5 @@ class HouseholdAI(BaseAIEngine):
         return {
             "housework": my_share_housework,
             "childcare": my_share_childcare,
-            "total_obligated": my_share_housework + my_share_childcare
+            "total_obligated": my_share_housework + my_share_childcare,
         }
diff --git a/simulation/ai/household_system2.py b/simulation/ai/household_system2.py
index ad89f2c..a1f7feb 100644
--- a/simulation/ai/household_system2.py
+++ b/simulation/ai/household_system2.py
@@ -4,6 +4,7 @@ import logging
 
 logger = logging.getLogger(__name__)
 
+
 class HousingDecisionInputs(NamedTuple):
     current_wealth: float
     annual_income: float
@@ -12,6 +13,7 @@ class HousingDecisionInputs(NamedTuple):
     risk_free_rate: float
     price_growth_expectation: float
 
+
 class HouseholdSystem2Planner:
     """
     Household System 2 Planner (Specialized for Housing).
@@ -42,10 +44,13 @@ class HouseholdSystem2Planner:
         # Buying Components
         P_initial = inputs.market_price
         U_shelter = inputs.market_rent_monthly
-        Cost_own = (P_initial * 0.01) / 12.0 # 1% annual maintenance
+        Cost_own = (P_initial * 0.01) / 12.0  # 1% annual maintenance
 
         # Price Growth Expectation (Capped at 5%)
-        g_annual = min(inputs.price_growth_expectation, getattr(self.config, "HOUSING_EXPECTATION_CAP", 0.05))
+        g_annual = min(
+            inputs.price_growth_expectation,
+            getattr(self.config, "HOUSING_EXPECTATION_CAP", 0.05),
+        )
         P_future = P_initial * ((1.0 + g_annual) ** T_years)
 
         # Renting Components
@@ -92,8 +97,8 @@ class HouseholdSystem2Planner:
                 "P_future": P_future,
                 "monthly_cost_own": Cost_own,
                 "monthly_cost_rent": Cost_rent,
-                "monthly_income_invest": Income_invest
-            }
+                "monthly_income_invest": Income_invest,
+            },
         }
 
     def decide(self, inputs: HousingDecisionInputs) -> str:
@@ -111,7 +116,9 @@ class HouseholdSystem2Planner:
         dti_threshold = inputs.annual_income * 0.4
 
         if annual_mortgage_cost > dti_threshold:
-            logger.debug(f"SYSTEM2_HOUSING | Force RENT due to DTI. Cost: {annual_mortgage_cost:.2f} > Limit: {dti_threshold:.2f}")
+            logger.debug(
+                f"SYSTEM2_HOUSING | Force RENT due to DTI. Cost: {annual_mortgage_cost:.2f} > Limit: {dti_threshold:.2f}"
+            )
             return "RENT"
 
         # 2. Rational Choice
diff --git a/simulation/ai/learning_tracker.py b/simulation/ai/learning_tracker.py
index e592e25..5cef328 100644
--- a/simulation/ai/learning_tracker.py
+++ b/simulation/ai/learning_tracker.py
@@ -97,7 +97,9 @@ class LearningTracker:
         overall_reward = 0.0
         total_records = 0
 
-        per_agent_stats = defaultdict(lambda: {"total_q_change": 0.0, "total_reward": 0.0, "record_count": 0})
+        per_agent_stats = defaultdict(
+            lambda: {"total_q_change": 0.0, "total_reward": 0.0, "record_count": 0}
+        )
 
         for tick, tick_data in self.history.items():
             for agent_id, records in tick_data.items():
@@ -123,7 +125,9 @@ class LearningTracker:
         # Finalize per-agent stats with averages
         for agent_id, stats in per_agent_stats.items():
             count = stats["record_count"]
-            stats["avg_q_change"] = stats["total_q_change"] / count if count > 0 else 0.0
+            stats["avg_q_change"] = (
+                stats["total_q_change"] / count if count > 0 else 0.0
+            )
             stats["avg_reward"] = stats["total_reward"] / count if count > 0 else 0.0
 
         summary = {
diff --git a/simulation/ai/model_wrapper.py b/simulation/ai/model_wrapper.py
index bd7bcd9..0539c35 100644
--- a/simulation/ai/model_wrapper.py
+++ b/simulation/ai/model_wrapper.py
@@ -7,7 +7,6 @@ from sklearn.feature_extraction import DictVectorizer
 from sklearn.preprocessing import StandardScaler
 
 
-
 logger = logging.getLogger(__name__)
 
 
diff --git a/simulation/ai/service_firm_ai.py b/simulation/ai/service_firm_ai.py
index 2d6c568..b926147 100644
--- a/simulation/ai/service_firm_ai.py
+++ b/simulation/ai/service_firm_ai.py
@@ -9,13 +9,16 @@ if TYPE_CHECKING:
 
 logger = logging.getLogger(__name__)
 
+
 class ServiceFirmAI(FirmAI):
     """
     ì„œë¹„ìŠ¤ ê¸°ì—…ìš© AI ì—”ì§„ (Phase 17-1).
     ì¬ê³  ê¸°ë°˜ ìƒíƒœ ëŒ€ì‹  ê°€ë™ë¥ (Utilization Rate) ê¸°ë°˜ ìƒíƒœë¥¼ ì‚¬ìš©.
     """
 
-    def _get_common_state(self, agent_data: Dict[str, Any], market_data: Dict[str, Any]) -> Tuple:
+    def _get_common_state(
+        self, agent_data: Dict[str, Any], market_data: Dict[str, Any]
+    ) -> Tuple:
         """
         Override standard state with Utilization-based metric.
         """
@@ -33,7 +36,7 @@ class ServiceFirmAI(FirmAI):
 
         # Let's rely on the passed agent_data. I must update ServiceFirm.get_agent_data override.
 
-        capacity = agent_data.get("capacity_this_tick", 1.0) # Avoid div by 0
+        capacity = agent_data.get("capacity_this_tick", 1.0)  # Avoid div by 0
         sales = agent_data.get("sales_volume_this_tick", 0.0)
 
         utilization = sales / capacity if capacity > 0 else 0.0
@@ -55,7 +58,9 @@ class ServiceFirmAI(FirmAI):
         cash_idx = self._discretize(cash, [100, 500, 1000, 5000, 10000])
 
         # 3. Debt Ratio (Same as FirmAI)
-        debt_info = market_data.get("debt_data", {}).get(self.agent_id, {"total_principal": 0.0, "daily_interest_burden": 0.0})
+        debt_info = market_data.get("debt_data", {}).get(
+            self.agent_id, {"total_principal": 0.0, "daily_interest_burden": 0.0}
+        )
         total_debt = debt_info.get("total_principal", 0.0)
         interest_burden = debt_info.get("daily_interest_burden", 0.0)
         debt_ratio = total_debt / cash if cash > 0 else 0.0
@@ -67,7 +72,9 @@ class ServiceFirmAI(FirmAI):
 
         return (util_idx, cash_idx, debt_idx, burden_idx)
 
-    def calculate_reward(self, firm_agent: "Firm", prev_state: Dict, current_state: Dict) -> float:
+    def calculate_reward(
+        self, firm_agent: "Firm", prev_state: Dict, current_state: Dict
+    ) -> float:
         """
         Add Waste Penalty to standard reward.
         """
@@ -79,13 +86,17 @@ class ServiceFirmAI(FirmAI):
         # These should be accessible from firm_agent if it's passed.
         # Yes, firm_agent is passed.
 
-        if hasattr(firm_agent, "waste_this_tick") and hasattr(firm_agent, "capacity_this_tick"):
+        if hasattr(firm_agent, "waste_this_tick") and hasattr(
+            firm_agent, "capacity_this_tick"
+        ):
             waste = firm_agent.waste_this_tick
             capacity = firm_agent.capacity_this_tick
-            expenses = firm_agent.expenses_this_tick # Tracked in Firm
+            expenses = firm_agent.expenses_this_tick  # Tracked in Firm
 
             unit_cost = expenses / capacity if capacity > 0 else 0.0
-            penalty_factor = getattr(firm_agent.config_module, "SERVICE_WASTE_PENALTY_FACTOR", 0.5)
+            penalty_factor = getattr(
+                firm_agent.config_module, "SERVICE_WASTE_PENALTY_FACTOR", 0.5
+            )
 
             penalty = waste * unit_cost * penalty_factor
 
@@ -93,7 +104,7 @@ class ServiceFirmAI(FirmAI):
 
             logger.debug(
                 f"SERVICE_REWARD | Firm {firm_agent.id} | Base: {base_reward:.2f}, Penalty: {penalty:.2f} (Waste: {waste:.1f})",
-                extra={"agent_id": firm_agent.id, "tags": ["ai_reward", "service"]}
+                extra={"agent_id": firm_agent.id, "tags": ["ai_reward", "service"]},
             )
             return total_reward
 
diff --git a/simulation/ai/system2_planner.py b/simulation/ai/system2_planner.py
index 3d7bfe9..c127554 100644
--- a/simulation/ai/system2_planner.py
+++ b/simulation/ai/system2_planner.py
@@ -4,6 +4,7 @@ import logging
 
 logger = logging.getLogger(__name__)
 
+
 class System2Planner:
     """
     The 'System 2' Planner (Slow, Deliberative).
@@ -23,13 +24,18 @@ class System2Planner:
         self.last_calc_tick = -999
         self.cached_projection: Dict[str, Any] = {}
 
-    def project_future(self, current_tick: int, market_data: Dict[str, Any]) -> Dict[str, Any]:
+    def project_future(
+        self, current_tick: int, market_data: Dict[str, Any]
+    ) -> Dict[str, Any]:
         """
         Projects future wealth and survival probability.
         Phase 20 Step 3: Includes Housing Costs (Rent/Mortgage)
         """
         # Optimization: Run only every X ticks
-        if current_tick - self.last_calc_tick < self.calc_interval and self.cached_projection:
+        if (
+            current_tick - self.last_calc_tick < self.calc_interval
+            and self.cached_projection
+        ):
             return self.cached_projection
 
         self.last_calc_tick = current_tick
@@ -41,7 +47,9 @@ class System2Planner:
         # Survival Cost
         goods_market = market_data.get("goods_market", {})
         food_price = goods_market.get("basic_food_current_sell_price", 5.0)
-        daily_consumption = getattr(self.config, "HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK", 2.0)
+        daily_consumption = getattr(
+            self.config, "HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK", 2.0
+        )
         daily_survival_cost = food_price * daily_consumption
 
         # A. Determine Work Hours (Existing)
@@ -53,7 +61,9 @@ class System2Planner:
             spouse_data = {"id": self.agent.spouse_id} if self.agent.spouse_id else None
             c_count = len(self.agent.children_ids)
             dummy_children = [{"age": 1}] if c_count > 0 else []
-            alloc = household_ai.decide_time_allocation(agent_data, spouse_data, dummy_children, self.config)
+            alloc = household_ai.decide_time_allocation(
+                agent_data, spouse_data, dummy_children, self.config
+            )
             time_obligations = alloc["total_obligated"]
 
         available_work_hours = max(0.0, 14.0 - time_obligations)
@@ -83,7 +93,7 @@ class System2Planner:
                 is_homeowner = True
 
         if is_homeowner:
-            housing_costs = daily_interest # Mortgage Interest
+            housing_costs = daily_interest  # Mortgage Interest
         else:
             # Renter or Homeless
             housing_market = market_data.get("housing_market", {})
@@ -94,11 +104,13 @@ class System2Planner:
         extra_expenses = 0.0
         tech_level = getattr(self.config, "FORMULA_TECH_LEVEL", 0.0)
         if len(self.agent.children_ids) > 0:
-            if tech_level > 0.5: 
+            if tech_level > 0.5:
                 extra_expenses += 5.0
 
         daily_income = expected_wage * projected_work_hours
-        daily_net_flow = daily_income - daily_survival_cost - extra_expenses - housing_costs
+        daily_net_flow = (
+            daily_income - daily_survival_cost - extra_expenses - housing_costs
+        )
 
         # 2. Simulation Loop
         npv_wealth = 0.0
@@ -106,7 +118,7 @@ class System2Planner:
         simulated_wealth = current_wealth
 
         for t in range(1, self.horizon + 1):
-            discount_factor = self.discount_rate ** t
+            discount_factor = self.discount_rate**t
             simulated_wealth += daily_net_flow
             if simulated_wealth < 0 and bankruptcy_tick is None:
                 bankruptcy_tick = current_tick + t
@@ -117,7 +129,7 @@ class System2Planner:
         result = {
             "npv_wealth": final_npv,
             "bankruptcy_tick": bankruptcy_tick,
-            "survival_prob": 1.0 # Heuristic calculation here
+            "survival_prob": 1.0,  # Heuristic calculation here
         }
         self.cached_projection = result
         return result
diff --git a/simulation/ai/vectorized_planner.py b/simulation/ai/vectorized_planner.py
index d283579..a2cf254 100644
--- a/simulation/ai/vectorized_planner.py
+++ b/simulation/ai/vectorized_planner.py
@@ -1,6 +1,7 @@
 import numpy as np
 import logging
 
+
 class VectorizedHouseholdPlanner:
     def __init__(self, config):
         self.config = config
@@ -14,7 +15,9 @@ class VectorizedHouseholdPlanner:
         self.fertility_rate = getattr(config, "BIOLOGICAL_FERTILITY_RATE", 0.15)
 
         # Consumption Constants
-        self.survival_threshold = getattr(config, "SURVIVAL_NEED_CONSUMPTION_THRESHOLD", 50.0)
+        self.survival_threshold = getattr(
+            config, "SURVIVAL_NEED_CONSUMPTION_THRESHOLD", 50.0
+        )
         self.food_consumption_qty = getattr(config, "FOOD_CONSUMPTION_QUANTITY", 1.0)
         self.max_purchase_qty = getattr(config, "FOOD_PURCHASE_MAX_PER_TICK", 5.0)
 
@@ -26,7 +29,8 @@ class VectorizedHouseholdPlanner:
         """
         # 1. Extract Data (ë³‘ëª© ì§€ì ì´ë‚˜ Python Loopë³´ë‹¤ ë¹ ë¦„)
         count = len(agents)
-        if count == 0: return []
+        if count == 0:
+            return []
 
         # Step 1: Pre-Modern Check (Biological)
         if not self.tech_enabled:
@@ -34,7 +38,7 @@ class VectorizedHouseholdPlanner:
             # P(reproduction) = fertility_rate
             vals = np.random.random(count)
             decisions = vals < self.fertility_rate
-            return decisions.tolist() # Return list of booleans
+            return decisions.tolist()  # Return list of booleans
 
         # Step 2: Modern Check (NPV)
         # ì†ì„± ì¶”ì¶œ (List Comprehension -> NumPy Array)
@@ -45,10 +49,14 @@ class VectorizedHouseholdPlanner:
         # If agent has 'monthly_income' attribute use it, else calc from wage
         # Assumption: agents are Household objects.
         # Let's extract 'current_wage' and map to monthly.
-        wages = np.array([getattr(a, "current_wage", 0.0) for a in agents], dtype=np.float32)
+        wages = np.array(
+            [getattr(a, "current_wage", 0.0) for a in agents], dtype=np.float32
+        )
         monthly_incomes = wages * 8.0 * 20.0
 
-        children_counts = np.array([len(a.children_ids) for a in agents], dtype=np.float32)
+        children_counts = np.array(
+            [len(a.children_ids) for a in agents], dtype=np.float32
+        )
 
         # 2. Vectorized Computation (í•µì‹¬ ìµœì í™” êµ¬ê°„)
 
@@ -90,19 +98,24 @@ class VectorizedHouseholdPlanner:
         """
         count = len(agents)
         if count == 0:
-            return {'consume': [], 'buy': []}
+            return {"consume": [], "buy": []}
 
         # 1. Extract State
         # Inventory: "basic_food"
-        inventories = np.array([a.inventory.get("basic_food", 0.0) for a in agents], dtype=np.float32)
+        inventories = np.array(
+            [a.inventory.get("basic_food", 0.0) for a in agents], dtype=np.float32
+        )
         assets = np.array([a.assets for a in agents], dtype=np.float32)
-        survival_needs = np.array([a.needs.get("survival", 0.0) for a in agents], dtype=np.float32)
+        survival_needs = np.array(
+            [a.needs.get("survival", 0.0) for a in agents], dtype=np.float32
+        )
 
         # 2. Market Data
         # Get "basic_food" price
         goods_market = market_data.get("goods_market", {})
         food_price = goods_market.get("basic_food_current_sell_price", 5.0)
-        if food_price <= 0: food_price = 5.0 # Fallback
+        if food_price <= 0:
+            food_price = 5.0  # Fallback
 
         # 3. Vectorized Logic
 
@@ -117,7 +130,11 @@ class VectorizedHouseholdPlanner:
         # B. Purchase Decision (Survival Logic)
         # Need > Threshold AND Inventory < 3.0 (Buffer for safety)
         # AND Assets > Price
-        should_buy = (survival_needs > self.survival_threshold) & (inventories < 3.0) & (assets >= food_price)
+        should_buy = (
+            (survival_needs > self.survival_threshold)
+            & (inventories < 3.0)
+            & (assets >= food_price)
+        )
 
         # Buy Amount: Max Purchase Qty (5.0) or afford limit
         # Simple Logic: Buy 5.0 to restock buffer
@@ -131,7 +148,7 @@ class VectorizedHouseholdPlanner:
         # Let's keep it float.
 
         return {
-            'consume': consume_amounts.tolist(),
-            'buy': buy_amounts.tolist(),
-            'price': float(food_price)
+            "consume": consume_amounts.tolist(),
+            "buy": buy_amounts.tolist(),
+            "price": float(food_price),
         }
diff --git a/simulation/bank.py b/simulation/bank.py
index c9c606b..963a49f 100644
--- a/simulation/bank.py
+++ b/simulation/bank.py
@@ -21,11 +21,11 @@ BANK_MARGIN = 0.02
 @dataclass
 class Loan:
     borrower_id: int
-    principal: float       # ì›ê¸ˆ
-    remaining_balance: float # ì”ì•¡
-    annual_interest_rate: float # ì—°ì´ìœ¨
-    term_ticks: int        # ë§Œê¸° (í‹±)
-    start_tick: int        # ëŒ€ì¶œ ì‹¤í–‰ í‹±
+    principal: float  # ì›ê¸ˆ
+    remaining_balance: float  # ì”ì•¡
+    annual_interest_rate: float  # ì—°ì´ìœ¨
+    term_ticks: int  # ë§Œê¸° (í‹±)
+    start_tick: int  # ëŒ€ì¶œ ì‹¤í–‰ í‹±
 
     @property
     def tick_interest_rate(self) -> float:
@@ -35,8 +35,8 @@ class Loan:
 @dataclass
 class Deposit:
     depositor_id: int
-    amount: float          # ì˜ˆì¹˜ê¸ˆ
-    annual_interest_rate: float # ì—°ì´ìœ¨
+    amount: float  # ì˜ˆì¹˜ê¸ˆ
+    annual_interest_rate: float  # ì—°ì´ìœ¨
 
     @property
     def tick_interest_rate(self) -> float:
@@ -49,9 +49,15 @@ class Bank(IFinancialEntity):
     Manages loans, deposits, and monetary policy interaction.
     """
 
-    def __init__(self, id: int, initial_assets: float, config_manager: ConfigManager, settlement_system: Optional["ISettlementSystem"] = None):
+    def __init__(
+        self,
+        id: int,
+        initial_assets: float,
+        config_manager: ConfigManager,
+        settlement_system: Optional["ISettlementSystem"] = None,
+    ):
         self._id = id
-        self._assets = initial_assets # Reserves
+        self._assets = initial_assets  # Reserves
         self.config_manager = config_manager
         self.settlement_system = settlement_system
 
@@ -60,7 +66,9 @@ class Bank(IFinancialEntity):
         self.deposits: Dict[str, Deposit] = {}
 
         # Policy Rates
-        self.base_rate = self._get_config("bank_defaults.initial_base_annual_rate", INITIAL_BASE_ANNUAL_RATE)
+        self.base_rate = self._get_config(
+            "bank_defaults.initial_base_annual_rate", INITIAL_BASE_ANNUAL_RATE
+        )
 
         # Counters
         self.next_loan_id = 0
@@ -112,7 +120,7 @@ class Bank(IFinancialEntity):
         self.base_rate = new_rate
         logger.info(
             f"MONETARY_POLICY | Base Rate updated: {old_rate:.2%} -> {self.base_rate:.2%}",
-            extra={"agent_id": self.id, "tags": ["bank", "policy"]}
+            extra={"agent_id": self.id, "tags": ["bank", "policy"]},
         )
 
     def grant_loan(
@@ -120,7 +128,7 @@ class Bank(IFinancialEntity):
         borrower_id: int,
         amount: float,
         term_ticks: Optional[int] = None,
-        interest_rate: Optional[float] = None
+        interest_rate: Optional[float] = None,
     ) -> Optional[str]:
         """
         Grants a loan to an agent if eligible.
@@ -155,7 +163,10 @@ class Bank(IFinancialEntity):
             if self.assets < amount:
                 logger.warning(
                     f"LOAN_REJECTED | Insufficient reserves (Gold Standard) for {amount:.2f}. Reserves: {self.assets:.2f}",
-                    extra={"agent_id": self.id, "tags": ["bank", "loan", "gold_standard"]}
+                    extra={
+                        "agent_id": self.id,
+                        "tags": ["bank", "loan", "gold_standard"],
+                    },
                 )
                 return None
         else:
@@ -170,7 +181,10 @@ class Bank(IFinancialEntity):
                     f"LOAN_DENIED | Insufficient reserves for fractional lending. "
                     f"Assets: {self.assets:.2f}, Required: {required_reserves:.2f} "
                     f"(Deposits: {total_deposits:.2f}, Loan: {amount:.2f}, Ratio: {reserve_ratio:.2%})",
-                    extra={"agent_id": self.id, "tags": ["bank", "loan", "fractional_reserve"]}
+                    extra={
+                        "agent_id": self.id,
+                        "tags": ["bank", "loan", "fractional_reserve"],
+                    },
                 )
                 return None
 
@@ -178,7 +192,10 @@ class Bank(IFinancialEntity):
             if self.assets < amount:
                 logger.info(
                     f"[CREDIT_CREATION] Bank {self.id} created {amount} credit. Reserves: {self.assets:.2f}",
-                    extra={"agent_id": self.id, "tags": ["bank", "loan", "credit_creation"]}
+                    extra={
+                        "agent_id": self.id,
+                        "tags": ["bank", "loan", "credit_creation"],
+                    },
                 )
 
         # 3. Execution (Update Bank State Only)
@@ -192,14 +209,14 @@ class Bank(IFinancialEntity):
             remaining_balance=amount,
             annual_interest_rate=annual_rate,
             term_ticks=term_ticks,
-            start_tick=0
+            start_tick=0,
         )
         self.loans[loan_id] = new_loan
 
         logger.info(
             f"LOAN_GRANTED | Loan {loan_id} to Agent {borrower_id}. "
             f"Amt: {amount:.2f}, Rate: {annual_rate:.2%}, Term: {term_ticks}",
-            extra={"agent_id": self.id, "tags": ["bank", "loan"]}
+            extra={"agent_id": self.id, "tags": ["bank", "loan"]},
         )
         return loan_id
 
@@ -212,7 +229,12 @@ class Bank(IFinancialEntity):
         Returns deposit ID.
         """
         margin = self._get_config("bank_defaults.bank_margin", 0.02)
-        deposit_rate = max(0.0, self.base_rate + self._get_config("bank_defaults.credit_spread_base", 0.02) - margin)
+        deposit_rate = max(
+            0.0,
+            self.base_rate
+            + self._get_config("bank_defaults.credit_spread_base", 0.02)
+            - margin,
+        )
 
         # self.assets += amount <-- REMOVED: Asset transfer handled by LoanMarket Transaction
 
@@ -220,9 +242,7 @@ class Bank(IFinancialEntity):
         self.next_deposit_id += 1
 
         new_deposit = Deposit(
-            depositor_id=depositor_id,
-            amount=amount,
-            annual_interest_rate=deposit_rate
+            depositor_id=depositor_id, amount=amount, annual_interest_rate=deposit_rate
         )
 
         self.deposits[deposit_id] = new_deposit
@@ -230,7 +250,7 @@ class Bank(IFinancialEntity):
         logger.info(
             f"DEPOSIT_ACCEPTED | Deposit {deposit_id} from Agent {depositor_id}. "
             f"Amt: {amount:.2f}, Rate: {deposit_rate:.2%}",
-            extra={"agent_id": self.id, "tags": ["bank", "deposit"]}
+            extra={"agent_id": self.id, "tags": ["bank", "deposit"]},
         )
         return deposit_id
 
@@ -262,7 +282,7 @@ class Bank(IFinancialEntity):
 
         logger.info(
             f"WITHDRAWAL_PROCESSED | Agent {depositor_id} withdrew {amount:.2f}",
-            extra={"agent_id": self.id, "tags": ["bank", "withdrawal"]}
+            extra={"agent_id": self.id, "tags": ["bank", "withdrawal"]},
         )
         return True
 
@@ -283,23 +303,29 @@ class Bank(IFinancialEntity):
         """
         if amount > 0:
             if self.assets < amount:
-                raise InsufficientFundsError(f"Bank {self.id} has insufficient funds for withdrawal of {amount:.2f}. Available: {self.assets:.2f}")
+                raise InsufficientFundsError(
+                    f"Bank {self.id} has insufficient funds for withdrawal of {amount:.2f}. Available: {self.assets:.2f}"
+                )
             self._assets -= amount
 
     def get_debt_summary(self, agent_id: int) -> Dict[str, float]:
         """Returns debt info for AI state."""
         total_principal = 0.0
         daily_interest_burden = 0.0
-        ticks_per_year = self._get_config("bank_defaults.ticks_per_year", TICKS_PER_YEAR)
+        ticks_per_year = self._get_config(
+            "bank_defaults.ticks_per_year", TICKS_PER_YEAR
+        )
 
         for loan in self.loans.values():
             if loan.borrower_id == agent_id:
                 total_principal += loan.remaining_balance
-                daily_interest_burden += (loan.remaining_balance * loan.annual_interest_rate) / ticks_per_year
+                daily_interest_burden += (
+                    loan.remaining_balance * loan.annual_interest_rate
+                ) / ticks_per_year
 
         return {
             "total_principal": total_principal,
-            "daily_interest_burden": daily_interest_burden
+            "daily_interest_burden": daily_interest_burden,
         }
 
     def get_deposit_balance(self, agent_id: int) -> float:
@@ -310,25 +336,34 @@ class Bank(IFinancialEntity):
                 total_deposit += deposit.amount
         return total_deposit
 
-    def run_tick(self, agents_dict: Dict[int, Any], current_tick: int = 0, reflux_system: Optional[Any] = None) -> List[Transaction]:
+    def run_tick(
+        self,
+        agents_dict: Dict[int, Any],
+        current_tick: int = 0,
+        reflux_system: Optional[Any] = None,
+    ) -> List[Transaction]:
         """
         Process interest payments and distributions.
         Returns a list of transactions to be executed by TransactionProcessor.
         """
         generated_transactions: List[Transaction] = []
-        ticks_per_year = self._get_config("bank_defaults.ticks_per_year", TICKS_PER_YEAR)
+        ticks_per_year = self._get_config(
+            "bank_defaults.ticks_per_year", TICKS_PER_YEAR
+        )
 
         # 1. Collect Interest from Loans
         total_loan_interest = 0.0
 
         for loan_id, loan in self.loans.items():
             agent = agents_dict.get(loan.borrower_id)
-            if not agent or not getattr(agent, 'is_active', True):
+            if not agent or not getattr(agent, "is_active", True):
                 # Default logic or write-off logic here
                 continue
 
             # Calculate Interest Payment
-            interest_payment = (loan.remaining_balance * loan.annual_interest_rate) / ticks_per_year
+            interest_payment = (
+                loan.remaining_balance * loan.annual_interest_rate
+            ) / ticks_per_year
             payment = interest_payment
 
             # Optimistic check (actual verification happens in TransactionProcessor)
@@ -340,14 +375,14 @@ class Bank(IFinancialEntity):
 
             if agent.assets >= payment:
                 tx = Transaction(
-                    buyer_id=agent.id, # Payer
-                    seller_id=self.id, # Payee
+                    buyer_id=agent.id,  # Payer
+                    seller_id=self.id,  # Payee
                     item_id=loan_id,
                     quantity=1.0,
                     price=payment,
                     market_id="financial",
                     transaction_type="loan_interest",
-                    time=current_tick
+                    time=current_tick,
                 )
                 generated_transactions.append(tx)
                 total_loan_interest += payment
@@ -364,7 +399,7 @@ class Bank(IFinancialEntity):
                         price=partial,
                         market_id="financial",
                         transaction_type="loan_default_recovery",
-                        time=current_tick
+                        time=current_tick,
                     )
                     generated_transactions.append(tx)
                     total_loan_interest += partial
@@ -376,29 +411,34 @@ class Bank(IFinancialEntity):
             if not agent:
                 continue
 
-            interest_payout = (deposit.amount * deposit.annual_interest_rate) / ticks_per_year
+            interest_payout = (
+                deposit.amount * deposit.annual_interest_rate
+            ) / ticks_per_year
 
             # Optimistic check
             if self.assets >= interest_payout:
-                 tx = Transaction(
-                    buyer_id=self.id, # Bank pays
-                    seller_id=agent.id, # Depositor receives
+                tx = Transaction(
+                    buyer_id=self.id,  # Bank pays
+                    seller_id=agent.id,  # Depositor receives
                     item_id=dep_id,
                     quantity=1.0,
                     price=interest_payout,
                     market_id="financial",
                     transaction_type="deposit_interest",
-                    time=current_tick
-                 )
-                 generated_transactions.append(tx)
-                 total_deposit_interest += interest_payout
-
-                 # Side effect: Track capital income
-                 from simulation.core_agents import Household
-                 if isinstance(agent, Household) and hasattr(agent, "capital_income_this_tick"):
+                    time=current_tick,
+                )
+                generated_transactions.append(tx)
+                total_deposit_interest += interest_payout
+
+                # Side effect: Track capital income
+                from simulation.core_agents import Household
+
+                if isinstance(agent, Household) and hasattr(
+                    agent, "capital_income_this_tick"
+                ):
                     agent.capital_income_this_tick += interest_payout
             else:
-                 logger.error("BANK_LIQUIDITY_CRISIS | Cannot pay deposit interest!")
+                logger.error("BANK_LIQUIDITY_CRISIS | Cannot pay deposit interest!")
 
         # 3. Bank Profit Capture (Reflux)
         net_profit = total_loan_interest - total_deposit_interest
@@ -406,27 +446,29 @@ class Bank(IFinancialEntity):
         # Find Government for profit transfer
         gov_agent = None
         for a in agents_dict.values():
-             if a.__class__.__name__ == 'Government':
-                 gov_agent = a
-                 break
+            if a.__class__.__name__ == "Government":
+                gov_agent = a
+                break
 
         if net_profit > 0 and gov_agent:
-             tx = Transaction(
-                 buyer_id=self.id, # Bank pays
-                 seller_id=gov_agent.id, # Government receives
-                 item_id="bank_profit",
-                 quantity=1.0,
-                 price=net_profit,
-                 market_id="financial",
-                 transaction_type="reflux_capture",
-                 time=current_tick
-             )
-             generated_transactions.append(tx)
-             logger.info(f"BANK_PROFIT_CAPTURE | Generated transaction of {net_profit:.2f} to Government.")
+            tx = Transaction(
+                buyer_id=self.id,  # Bank pays
+                seller_id=gov_agent.id,  # Government receives
+                item_id="bank_profit",
+                quantity=1.0,
+                price=net_profit,
+                market_id="financial",
+                transaction_type="reflux_capture",
+                time=current_tick,
+            )
+            generated_transactions.append(tx)
+            logger.info(
+                f"BANK_PROFIT_CAPTURE | Generated transaction of {net_profit:.2f} to Government."
+            )
 
         logger.info(
             f"BANK_TICK_SUMMARY | Collected Loan Int: {total_loan_interest:.2f}, Paid Deposit Int: {total_deposit_interest:.2f}, Net Profit: {net_profit:.2f}, Generated Txs: {len(generated_transactions)}",
-            extra={"agent_id": self.id, "tags": ["bank", "tick"]}
+            extra={"agent_id": self.id, "tags": ["bank", "tick"]},
         )
 
         return generated_transactions
@@ -439,20 +481,22 @@ class Bank(IFinancialEntity):
                 "borrower_id": l.borrower_id,
                 "amount": l.remaining_balance,
                 "interest_rate": l.annual_interest_rate,
-                "duration": l.term_ticks
+                "duration": l.term_ticks,
             }
-            for l in self.loans.values() if l.borrower_id == agent_id
+            for l in self.loans.values()
+            if l.borrower_id == agent_id
         ]
+
     def process_repayment(self, loan_id: str, amount: float):
         if loan_id in self.loans:
             # We don't touch assets here, handled by Transaction
             self.loans[loan_id].remaining_balance -= amount
             if self.loans[loan_id].remaining_balance <= 0:
                 # Fully repaid
-                pass # Logic to archive loan?
+                pass  # Logic to archive loan?
             logger.info(
                 f"REPAYMENT_PROCESSED | Loan {loan_id} repaid by {amount}",
-                extra={"agent_id": self.id, "tags": ["bank", "repayment"]}
+                extra={"agent_id": self.id, "tags": ["bank", "repayment"]},
             )
 
     def _borrow_from_central_bank(self, amount: float):
@@ -462,17 +506,19 @@ class Bank(IFinancialEntity):
         """
         self._assets += amount
         if self._get_config("government_id", None) is not None:
-             # If we have a reference to government via simulation later, but here we take config
-             pass
-        
-        logger.warning(f"BANK_BORROWING | Central Bank injected {amount:.2f} into Bank {self.id} reserves.")
+            # If we have a reference to government via simulation later, but here we take config
+            pass
+
+        logger.warning(
+            f"BANK_BORROWING | Central Bank injected {amount:.2f} into Bank {self.id} reserves."
+        )
 
     def check_solvency(self, government: Any):
         """
         Phase 23.5: Ensuring Bank always has positive reserves for TransactionProcessor.
         """
         if self.assets < 0:
-            borrow_amount = abs(self.assets) + 1000.0 # Maintain buffer
+            borrow_amount = abs(self.assets) + 1000.0  # Maintain buffer
 
             # Lender of Last Resort is MONEY CREATION (Minting), not a transfer.
             # Government creates money and injects it into the Bank.
@@ -480,7 +526,9 @@ class Bank(IFinancialEntity):
             self.deposit(borrow_amount)
             government.total_money_issued += borrow_amount
 
-            logger.warning(f"LENDER_OF_LAST_RESORT | Bank {self.id} insolvent! Borrowed {borrow_amount:.2f} from Government (Money Creation).")
+            logger.warning(
+                f"LENDER_OF_LAST_RESORT | Bank {self.id} insolvent! Borrowed {borrow_amount:.2f} from Government (Money Creation)."
+            )
 
     def process_default(self, agent: Any, loan: Loan, current_tick: int):
         """
@@ -491,7 +539,7 @@ class Bank(IFinancialEntity):
         """
         logger.warning(
             f"DEFAULT_EVENT | Agent {agent.id} defaulted on Loan {loan.principal:.2f}",
-            extra={"agent_id": agent.id, "loan_id": getattr(loan, "id", "unknown")}
+            extra={"agent_id": agent.id, "loan_id": getattr(loan, "id", "unknown")},
         )
 
         # 1. Liquidation
@@ -500,7 +548,7 @@ class Bank(IFinancialEntity):
             logger.info(f"LIQUIDATION | Agent {agent.id} shares confiscated.")
 
         # 2. Forgiveness (Write-off)
-        loan.remaining_balance = 0.0 # Effectively forgiven
+        loan.remaining_balance = 0.0  # Effectively forgiven
 
         # 3. Penalty
         # Credit Jail
@@ -511,9 +559,11 @@ class Bank(IFinancialEntity):
         # 4. XP Penalty
         xp_penalty = self._get_config("bankruptcy_xp_penalty", 0.2)
         if hasattr(agent, "education_xp"):
-             agent.education_xp *= (1.0 - xp_penalty)
+            agent.education_xp *= 1.0 - xp_penalty
         if hasattr(agent, "skills"):
-             for skill in agent.skills.values():
-                 skill.value *= (1.0 - xp_penalty)
+            for skill in agent.skills.values():
+                skill.value *= 1.0 - xp_penalty
 
-        logger.info(f"PENALTY_APPLIED | Agent {agent.id} entered Credit Jail and lost XP.")
+        logger.info(
+            f"PENALTY_APPLIED | Agent {agent.id} entered Credit Jail and lost XP."
+        )
diff --git a/simulation/base_agent.py b/simulation/base_agent.py
index 8af5e6d..aa80f4b 100644
--- a/simulation/base_agent.py
+++ b/simulation/base_agent.py
@@ -25,13 +25,13 @@ class BaseAgent(ABC):
         self.is_active: bool = True
         self.logger = logger if logger is not None else logging.getLogger(self.name)
         self._pre_state_data: Dict[str, Any] = {}  # ì´ì „ ìƒíƒœ ì €ì¥ì„ ìœ„í•œ ì†ì„±
-        self.pre_state_snapshot: Dict[str, Any] = {} # Mypy fix: Snapshot for learning
+        self.pre_state_snapshot: Dict[str, Any] = {}  # Mypy fix: Snapshot for learning
         try:
             self.generation: int = 0
         except AttributeError:
             # If generation is a property (e.g. in Household), it cannot be set here.
             pass
-        
+
         # [Cleanup] Standardized Memory Structure
         self.memory: Dict[str, Any] = {}
 
@@ -62,7 +62,9 @@ class BaseAgent(ABC):
         """
         if amount > 0:
             if self.assets < amount:
-                raise InsufficientFundsError(f"Agent {self.id} has insufficient funds for withdrawal of {amount:.2f}. Available: {self.assets:.2f}")
+                raise InsufficientFundsError(
+                    f"Agent {self.id} has insufficient funds for withdrawal of {amount:.2f}. Available: {self.assets:.2f}"
+                )
             self._sub_assets(amount)
 
     def get_agent_data(self) -> Dict[str, Any]:
@@ -83,11 +85,19 @@ class BaseAgent(ABC):
         pass
 
     @abstractmethod
-    def make_decision(self, markets: Dict[str, Any], goods_data: list[Dict[str, Any]], market_data: Dict[str, Any], current_time: int) -> tuple[list[Any], Any]:
+    def make_decision(
+        self,
+        markets: Dict[str, Any],
+        goods_data: list[Dict[str, Any]],
+        market_data: Dict[str, Any],
+        current_time: int,
+    ) -> tuple[list[Any], Any]:
         pass
 
     @abstractmethod
-    def clone(self, new_id: int, initial_assets_from_parent: float, current_tick: int) -> "BaseAgent":
+    def clone(
+        self, new_id: int, initial_assets_from_parent: float, current_tick: int
+    ) -> "BaseAgent":
         """
         í˜„ì¬ ì—ì´ì „íŠ¸ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë³µì œí•˜ì—¬ ìƒˆë¡œìš´ ì—ì´ì „íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
         AI ëª¨ë¸(decision_engine)ì„ í¬í•¨í•˜ì—¬ ê¹Šì€ ë³µì‚¬ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤.
diff --git a/simulation/brands/brand_manager.py b/simulation/brands/brand_manager.py
index 7dd4438..454c753 100644
--- a/simulation/brands/brand_manager.py
+++ b/simulation/brands/brand_manager.py
@@ -2,19 +2,23 @@ from typing import Dict, Any, Optional
 import math
 import logging
 
+
 class BrandManager:
     """
     Manages a firm's intangible assets: Adstock, Brand Awareness, and Perceived Quality.
     Based on Phase 6 Spec.
     """
-    def __init__(self, firm_id: int, config: Any, logger: Optional[logging.Logger] = None):
+
+    def __init__(
+        self, firm_id: int, config: Any, logger: Optional[logging.Logger] = None
+    ):
         self.firm_id = firm_id
         self.config = config
         self.logger = logger or logging.getLogger(__name__)
 
-        self.adstock = 0.0          # Marketing memory
+        self.adstock = 0.0  # Marketing memory
         self.brand_awareness = 0.0  # 0.0 ~ 1.0 (S-curve of adstock)
-        self.perceived_quality = 0.0 # Market perception weighting actual quality
+        self.perceived_quality = 0.0  # Market perception weighting actual quality
 
     def update(self, marketing_spend: float, actual_quality: float) -> None:
         """
@@ -24,7 +28,7 @@ class BrandManager:
         # Decay old adstock, add new spend (converted to adstock units)
         decay_rate = getattr(self.config, "MARKETING_DECAY_RATE", 0.8)
         efficiency = getattr(self.config, "MARKETING_EFFICIENCY", 0.01)
-        
+
         # Adstock = (Previous * Decay) + (Spend * Efficiency)
         self.adstock = (self.adstock * decay_rate) + (marketing_spend * efficiency)
 
@@ -36,17 +40,19 @@ class BrandManager:
         # 3. Perceived Quality Update (EMA)
         # Q_perc_t = (Q_actual * alpha) + (Q_perc_t-1 * (1-alpha))
         alpha = getattr(self.config, "PERCEIVED_QUALITY_ALPHA", 0.2)
-        
+
         # Ensure actual_quality is float
         if actual_quality is None:
             actual_quality = 0.0
 
-        self.perceived_quality = (actual_quality * alpha) + (self.perceived_quality * (1.0 - alpha))
+        self.perceived_quality = (actual_quality * alpha) + (
+            self.perceived_quality * (1.0 - alpha)
+        )
 
         if self.logger:
-             self.logger.debug(
+            self.logger.debug(
                 f"BRAND_UPDATE | Firm {self.firm_id}: Spend={marketing_spend:.1f}, "
                 f"Adstock={self.adstock:.3f}, Awareness={self.brand_awareness:.3f}, "
                 f"ActQ={actual_quality:.2f}, PercQ={self.perceived_quality:.2f}",
-                extra={"agent_id": self.firm_id, "tick": -1, "tags": ["brand"]}
-             )
+                extra={"agent_id": self.firm_id, "tick": -1, "tags": ["brand"]},
+            )
diff --git a/simulation/components/agent_lifecycle.py b/simulation/components/agent_lifecycle.py
index aca97c3..17df165 100644
--- a/simulation/components/agent_lifecycle.py
+++ b/simulation/components/agent_lifecycle.py
@@ -1,16 +1,18 @@
 """
 Implements the AgentLifecycleComponent which manages the daily routine of a Household agent.
 """
+
 from typing import Any, Dict, Protocol
 from simulation.systems.api import IAgentLifecycleComponent, LifecycleContext
 
+
 class AgentLifecycleComponent(IAgentLifecycleComponent):
     """
     Manages the 'run_tick' logic for a Household: Work -> Consume -> Tax -> Psychology.
     """
 
     def __init__(self, owner: Any, config: Any):
-        self.owner = owner # Household
+        self.owner = owner  # Household
         self.config = config
 
     def run_tick(self, context: LifecycleContext) -> None:
diff --git a/simulation/components/api.py b/simulation/components/api.py
index fc0bb6c..34a3dcb 100644
--- a/simulation/components/api.py
+++ b/simulation/components/api.py
@@ -10,11 +10,13 @@ if TYPE_CHECKING:
 # 1. Data Transfer Objects (DTOs)
 # ===================================================================================
 
+
 @dataclass
 class DemographicsDTO:
     """
     A data transfer object for the demographic information of a household.
     """
+
     age: float
     gender: str
     generation: int
@@ -39,6 +41,7 @@ class DemographicsDTO:
 # 2. Component Interfaces (Protocols)
 # ===================================================================================
 
+
 class IDemographicsComponent(Protocol):
     """
     An interface for a component that manages the demographic attributes and lifecycle
@@ -111,14 +114,18 @@ class IDemographicsComponent(Protocol):
         """Adds a child."""
         ...
 
-    def get_generational_similarity(self, talent_learning_rate_1: float, talent_learning_rate_2: float) -> float:
+    def get_generational_similarity(
+        self, talent_learning_rate_1: float, talent_learning_rate_2: float
+    ) -> float:
         """
         Calculates the generational/genetic similarity based on talent learning rates.
         Mainly used for spouse selection.
         """
         ...
 
-    def create_offspring_demographics(self, new_id: int, current_tick: int) -> Dict[str, Any]:
+    def create_offspring_demographics(
+        self, new_id: int, current_tick: int
+    ) -> Dict[str, Any]:
         """
         Creates and returns the initial demographic data for an offspring.
         (Used for creating the offspring Household object)
diff --git a/simulation/components/consumption_behavior.py b/simulation/components/consumption_behavior.py
index 7567475..997520a 100644
--- a/simulation/components/consumption_behavior.py
+++ b/simulation/components/consumption_behavior.py
@@ -7,6 +7,7 @@ if TYPE_CHECKING:
 
 logger = logging.getLogger(__name__)
 
+
 class ConsumptionBehavior:
     """
     Phase 22.5: Household Consumption Component
@@ -17,12 +18,18 @@ class ConsumptionBehavior:
         self.owner = owner
         self.config = config_module
 
-    def decide_and_consume(self, current_time: int, market_data: Optional[Dict[str, Any]] = None) -> Dict[str, float]:
+    def decide_and_consume(
+        self, current_time: int, market_data: Optional[Dict[str, Any]] = None
+    ) -> Dict[str, float]:
         """
         Consumes goods from inventory based on need thresholds.
         """
         consumed_items: Dict[str, float] = {}
-        log_extra = {"tick": current_time, "agent_id": self.owner.id, "tags": ["consumption"]}
+        log_extra = {
+            "tick": current_time,
+            "agent_id": self.owner.id,
+            "tags": ["consumption"],
+        }
 
         # 1. Evaluate items in inventory
         for item_id, inventory_quantity in list(self.owner.inventory.items()):
@@ -40,16 +47,16 @@ class ConsumptionBehavior:
             should_consume = False
             for need_key, effect in utility_effects.items():
                 current_need = self.owner.needs.get(need_key, 0.0)
-                
+
                 # Consumption Threshold
                 threshold = self.config.NEED_MEDIUM_THRESHOLD
                 if need_key == "survival":
                     threshold = self.config.SURVIVAL_NEED_CONSUMPTION_THRESHOLD
-                
+
                 if current_need > threshold:
                     should_consume = True
                     break
-            
+
             if should_consume:
                 is_durable = good_info.get("is_durable", False)
                 if is_durable:
@@ -58,14 +65,20 @@ class ConsumptionBehavior:
                     quantity_to_consume = 1.0
                 else:
                     quantity_to_consume = min(inventory_quantity, 1.0)
-                
+
                 if quantity_to_consume > 0:
                     self.owner.consume(item_id, quantity_to_consume, current_time)
-                    consumed_items[item_id] = consumed_items.get(item_id, 0.0) + quantity_to_consume
-                    
+                    consumed_items[item_id] = (
+                        consumed_items.get(item_id, 0.0) + quantity_to_consume
+                    )
+
                     logger.debug(
                         f"CONSUMPTION | {self.owner.id} consumed {quantity_to_consume:.2f} {item_id}.",
-                        extra={**log_extra, "item_id": item_id, "quantity": quantity_to_consume}
+                        extra={
+                            **log_extra,
+                            "item_id": item_id,
+                            "quantity": quantity_to_consume,
+                        },
                     )
 
         # 2. Update Needs (Natural Decay/Growth handled by PsychologyComponent usually)
diff --git a/simulation/components/demographics_component.py b/simulation/components/demographics_component.py
index c8cbcc0..d06047b 100644
--- a/simulation/components/demographics_component.py
+++ b/simulation/components/demographics_component.py
@@ -10,10 +10,19 @@ if TYPE_CHECKING:
     # from config import YourConfigModule # TBD: ì‹¤ì œ ì„¤ì • ëª¨ë“ˆ ê²½ë¡œë¡œ ë³€ê²½
 import config
 
+
 class DemographicsComponent:
     """Handles the demographic data and lifecycle logic for a Household."""
 
-    def __init__(self, owner: "Household", initial_age: float, gender: str, generation: int = 0, parent_id: Optional[int] = None, config_module: Any = config):
+    def __init__(
+        self,
+        owner: "Household",
+        initial_age: float,
+        gender: str,
+        generation: int = 0,
+        parent_id: Optional[int] = None,
+        config_module: Any = config,
+    ):
         self._owner = owner
         self._age = initial_age
         self._gender = gender
@@ -85,7 +94,9 @@ class DemographicsComponent:
         self._age += 1.0 / ticks_per_year
 
         if self.handle_death(current_tick):
-            self.logger.info(f"DEATH | Household {self.owner.id} has died at age {self._age:.1f}.")
+            self.logger.info(
+                f"DEATH | Household {self.owner.id} has died at age {self._age:.1f}."
+            )
 
     def handle_death(self, current_tick: int) -> bool:
         """
@@ -132,7 +143,9 @@ class DemographicsComponent:
         if child_id not in self._children_ids:
             self._children_ids.append(child_id)
 
-    def get_generational_similarity(self, talent_learning_rate_1: float, talent_learning_rate_2: float) -> float:
+    def get_generational_similarity(
+        self, talent_learning_rate_1: float, talent_learning_rate_2: float
+    ) -> float:
         """Calculates the generational/genetic similarity based on talent learning rates."""
 
         # A simple comparison of talents.
@@ -140,11 +153,13 @@ class DemographicsComponent:
         similarity = max(0.0, 1.0 - talent_diff)
         return similarity
 
-    def create_offspring_demographics(self, new_id: int, current_tick: int) -> Dict[str, Any]:
+    def create_offspring_demographics(
+        self, new_id: int, current_tick: int
+    ) -> Dict[str, Any]:
         """Creates the initial demographic attributes for an offspring."""
         return {
             "generation": self._generation + 1,
             "parent_id": self.owner.id,
             "initial_age": 0.0,
-            "gender": random.choice(["M", "F"])
+            "gender": random.choice(["M", "F"]),
         }
diff --git a/simulation/components/economy_manager.py b/simulation/components/economy_manager.py
index 4da402a..9bdf9eb 100644
--- a/simulation/components/economy_manager.py
+++ b/simulation/components/economy_manager.py
@@ -101,8 +101,7 @@ class EconomyManager:
                         total_utility += satisfaction_gain
                         self._household.needs[need_type] = max(
                             0,
-                            self._household.needs.get(need_type, 0)
-                            - satisfaction_gain,
+                            self._household.needs.get(need_type, 0) - satisfaction_gain,
                         )
             return ConsumptionResult(
                 items_consumed={item_id: quantity}, satisfaction=total_utility
diff --git a/simulation/components/finance_department.py b/simulation/components/finance_department.py
index 96f7738..ad37028 100644
--- a/simulation/components/finance_department.py
+++ b/simulation/components/finance_department.py
@@ -13,11 +13,13 @@ if TYPE_CHECKING:
 
 logger = logging.getLogger(__name__)
 
+
 class FinanceDepartment:
     """
     Manages assets, maintenance fees, corporate taxes, dividend distribution, and tracks financial metrics.
     Centralized Asset Management (WO-103 Phase 1).
     """
+
     def __init__(self, firm: Firm, config_module: Any, initial_capital: float = 0.0):
         self.firm = firm
         self.config_module = config_module
@@ -38,7 +40,9 @@ class FinanceDepartment:
         self.expenses_this_tick: float = 0.0
 
         # History
-        self.profit_history: deque[float] = deque(maxlen=self.config_module.PROFIT_HISTORY_TICKS)
+        self.profit_history: deque[float] = deque(
+            maxlen=self.config_module.PROFIT_HISTORY_TICKS
+        )
         self.last_revenue: float = 0.0
         self.last_marketing_spend: float = 0.0
 
@@ -71,7 +75,9 @@ class FinanceDepartment:
         self.expenses_this_tick += amount
         self.current_profit -= amount
 
-    def generate_holding_cost_transaction(self, government: Government, current_time: int) -> Optional[Transaction]:
+    def generate_holding_cost_transaction(
+        self, government: Government, current_time: int
+    ) -> Optional[Transaction]:
         """Generates inventory holding cost transaction."""
         inventory_value = self.get_inventory_value()
         holding_cost = inventory_value * self.config_module.INVENTORY_HOLDING_COST_RATE
@@ -82,17 +88,19 @@ class FinanceDepartment:
 
             return Transaction(
                 buyer_id=self.firm.id,
-                seller_id=government.id, # Capture to Gov/Reflux
+                seller_id=government.id,  # Capture to Gov/Reflux
                 item_id="holding_cost",
                 quantity=1.0,
                 price=holding_cost,
                 market_id="system",
                 transaction_type="holding_cost",
-                time=current_time
+                time=current_time,
             )
         return None
 
-    def generate_maintenance_transaction(self, government: Government, current_time: int) -> Optional[Transaction]:
+    def generate_maintenance_transaction(
+        self, government: Government, current_time: int
+    ) -> Optional[Transaction]:
         """Generates maintenance fee transaction."""
         fee = getattr(self.config_module, "FIRM_MAINTENANCE_FEE", 50.0)
 
@@ -103,7 +111,11 @@ class FinanceDepartment:
             self.record_expense(payment)
             self.firm.logger.info(
                 f"Generated maintenance fee tx: {payment:.2f}",
-                extra={"tick": current_time, "agent_id": self.firm.id, "tags": ["tax", "maintenance"]}
+                extra={
+                    "tick": current_time,
+                    "agent_id": self.firm.id,
+                    "tags": ["tax", "maintenance"],
+                },
             )
             return Transaction(
                 buyer_id=self.firm.id,
@@ -113,11 +125,13 @@ class FinanceDepartment:
                 price=payment,
                 market_id="system",
                 transaction_type="tax",
-                time=current_time
+                time=current_time,
             )
         return None
 
-    def generate_tax_transaction(self, government: Government, current_time: int) -> Optional[Transaction]:
+    def generate_tax_transaction(
+        self, government: Government, current_time: int
+    ) -> Optional[Transaction]:
         """Generates corporate tax transaction."""
         net_profit = self.revenue_this_turn - self.cost_this_turn
 
@@ -134,7 +148,11 @@ class FinanceDepartment:
 
                 self.firm.logger.info(
                     f"Generated corporate tax tx: {payment:.2f} on profit {net_profit:.2f}.",
-                    extra={"tick": current_time, "agent_id": self.firm.id, "tags": ["tax", "corporate_tax"]}
+                    extra={
+                        "tick": current_time,
+                        "agent_id": self.firm.id,
+                        "tags": ["tax", "corporate_tax"],
+                    },
                 )
 
                 return Transaction(
@@ -145,27 +163,31 @@ class FinanceDepartment:
                     price=payment,
                     market_id="system",
                     transaction_type="tax",
-                    time=current_time
+                    time=current_time,
                 )
         return None
 
-    def generate_marketing_transaction(self, government: Government, current_time: int, amount: float) -> Optional[Transaction]:
+    def generate_marketing_transaction(
+        self, government: Government, current_time: int, amount: float
+    ) -> Optional[Transaction]:
         """Generates marketing spend transaction."""
         if amount > 0:
             self.record_expense(amount)
             return Transaction(
                 buyer_id=self.firm.id,
-                seller_id=government.id, # Reflux/Gov capture
+                seller_id=government.id,  # Reflux/Gov capture
                 item_id="marketing",
                 quantity=1.0,
                 price=amount,
                 market_id="system",
                 transaction_type="marketing",
-                time=current_time
+                time=current_time,
             )
         return None
 
-    def process_profit_distribution(self, households: List[Household], government: Government, current_time: int) -> List[Transaction]:
+    def process_profit_distribution(
+        self, households: List[Household], government: Government, current_time: int
+    ) -> List[Transaction]:
         """
         Public Shareholders Dividend & Bailout Repayment.
         Returns List of Transactions.
@@ -173,8 +195,10 @@ class FinanceDepartment:
         transactions = []
 
         # 1. Bailout Repayment
-        if getattr(self.firm, 'has_bailout_loan', False) and self.current_profit > 0:
-            repayment_ratio = getattr(self.config_module, "BAILOUT_REPAYMENT_RATIO", 0.5)
+        if getattr(self.firm, "has_bailout_loan", False) and self.current_profit > 0:
+            repayment_ratio = getattr(
+                self.config_module, "BAILOUT_REPAYMENT_RATIO", 0.5
+            )
             repayment = self.current_profit * repayment_ratio
 
             # Optimistic update of debt state (assuming tx succeeds)
@@ -182,7 +206,7 @@ class FinanceDepartment:
             # We assume funds exist if current_profit > 0 (implies we made money).
 
             # Ensure total_debt exists
-            if not hasattr(self.firm, 'total_debt'):
+            if not hasattr(self.firm, "total_debt"):
                 self.firm.total_debt = 0.0
 
             transactions.append(
@@ -194,13 +218,15 @@ class FinanceDepartment:
                     price=repayment,
                     market_id="system",
                     transaction_type="repayment",
-                    time=current_time
+                    time=current_time,
                 )
             )
 
             self.firm.total_debt -= repayment
             self.current_profit -= repayment
-            self.firm.logger.info(f"BAILOUT_REPAYMENT | Generated repayment tx {repayment:.2f}.")
+            self.firm.logger.info(
+                f"BAILOUT_REPAYMENT | Generated repayment tx {repayment:.2f}."
+            )
 
             if self.firm.total_debt <= 0:
                 self.firm.total_debt = 0.0
@@ -214,14 +240,16 @@ class FinanceDepartment:
             for household in households:
                 shares = household.shares_owned.get(self.firm.id, 0.0)
                 if shares > 0:
-                    dividend_amount = distributable_profit * (shares / self.firm.total_shares)
+                    dividend_amount = distributable_profit * (
+                        shares / self.firm.total_shares
+                    )
                     transactions.append(
                         Transaction(
-                            seller_id=self.firm.id,
-                            buyer_id=household.id,
+                            buyer_id=self.firm.id,
+                            seller_id=household.id,
                             item_id="dividend",
-                            quantity=1.0, # 1 unit of dividend event
-                            price=dividend_amount, # Cash amount
+                            quantity=1.0,  # 1 unit of dividend event
+                            price=dividend_amount,  # Cash amount
                             market_id="financial",
                             transaction_type="dividend",
                             time=current_time,
@@ -238,7 +266,9 @@ class FinanceDepartment:
 
         return transactions
 
-    def distribute_profit_private(self, agents: Dict[int, Any], government: Government, current_time: int) -> List[Transaction]:
+    def distribute_profit_private(
+        self, agents: Dict[int, Any], government: Government, current_time: int
+    ) -> List[Transaction]:
         """Phase 14-1: Private Owner Dividend Transaction Generation"""
         if self.firm.owner_id is None:
             return []
@@ -274,14 +304,14 @@ class FinanceDepartment:
                     price=dividend_amount,
                     market_id="financial",
                     transaction_type="dividend",
-                    time=current_time
+                    time=current_time,
                 )
             )
 
             # Optimistic state update
-            if hasattr(owner, 'income_capital_cumulative'):
+            if hasattr(owner, "income_capital_cumulative"):
                 owner.income_capital_cumulative += dividend_amount
-            if hasattr(owner, 'capital_income_this_tick'):
+            if hasattr(owner, "capital_income_this_tick"):
                 owner.capital_income_this_tick += dividend_amount
 
             self.retained_earnings -= dividend_amount
@@ -289,7 +319,9 @@ class FinanceDepartment:
 
         return transactions
 
-    def generate_financial_transactions(self, government: Government, households: List[Household], current_time: int) -> List[Transaction]:
+    def generate_financial_transactions(
+        self, government: Government, households: List[Household], current_time: int
+    ) -> List[Transaction]:
         """Consolidates all financial outflow generation logic."""
         transactions = []
 
@@ -309,7 +341,9 @@ class FinanceDepartment:
             transactions.append(tx_tax)
 
         # 4. Profit Distribution (Public)
-        txs_public = self.process_profit_distribution(households, government, current_time)
+        txs_public = self.process_profit_distribution(
+            households, government, current_time
+        )
         transactions.extend(txs_public)
 
         return transactions
@@ -317,7 +351,7 @@ class FinanceDepartment:
     def add_liability(self, amount: float, interest_rate: float):
         """Adds a liability (like a loan) to the firm's balance sheet."""
         self.credit(amount, "Liability Addition")
-        if not hasattr(self.firm, 'total_debt'):
+        if not hasattr(self.firm, "total_debt"):
             self.firm.total_debt = 0.0
         self.firm.total_debt += amount
 
@@ -326,10 +360,14 @@ class FinanceDepartment:
         if total_assets == 0:
             return 0.0
 
-        working_capital = self._cash - getattr(self.firm, 'total_debt', 0.0)
+        working_capital = self._cash - getattr(self.firm, "total_debt", 0.0)
         x1 = working_capital / total_assets
         x2 = self.retained_earnings / total_assets
-        avg_profit = sum(self.profit_history) / len(self.profit_history) if self.profit_history else 0.0
+        avg_profit = (
+            sum(self.profit_history) / len(self.profit_history)
+            if self.profit_history
+            else 0.0
+        )
         x3 = avg_profit / total_assets
 
         z_score = 1.2 * x1 + 1.4 * x2 + 3.3 * x3
@@ -352,7 +390,9 @@ class FinanceDepartment:
         if len(self.profit_history) > 0:
             avg_profit = sum(self.profit_history) / len(self.profit_history)
 
-        profit_premium = max(0.0, avg_profit) * getattr(self.config_module, "VALUATION_PER_MULTIPLIER", 10.0)
+        profit_premium = max(0.0, avg_profit) * getattr(
+            self.config_module, "VALUATION_PER_MULTIPLIER", 10.0
+        )
 
         self.firm.valuation = net_assets + profit_premium
         return self.firm.valuation
@@ -361,18 +401,24 @@ class FinanceDepartment:
         """Calculate market value of current inventory."""
         total_val = 0.0
         for good, qty in self.firm.inventory.items():
-             price = self.firm.last_prices.get(good, 0.0)
-             if price == 0.0:
-                 if self.config_module and hasattr(self.config_module, 'GOODS'):
-                     price = self.config_module.GOODS.get(good, {}).get('initial_price', 10.0)
-                 else:
-                     price = 10.0
-             total_val += qty * price
+            price = self.firm.last_prices.get(good, 0.0)
+            if price == 0.0:
+                if self.config_module and hasattr(self.config_module, "GOODS"):
+                    price = self.config_module.GOODS.get(good, {}).get(
+                        "initial_price", 10.0
+                    )
+                else:
+                    price = 10.0
+            total_val += qty * price
         return total_val
 
     def get_financial_snapshot(self) -> Dict[str, float]:
         # WO-106: Include Capital Stock in Total Assets for correct accounting
-        total_assets = self._cash + self.get_inventory_value() + getattr(self.firm, 'capital_stock', 0.0)
+        total_assets = (
+            self._cash
+            + self.get_inventory_value()
+            + getattr(self.firm, "capital_stock", 0.0)
+        )
 
         current_liabilities = getattr(self.firm, "total_debt", 0.0)
         working_capital = total_assets - current_liabilities
@@ -389,7 +435,7 @@ class FinanceDepartment:
             "working_capital": working_capital,
             "retained_earnings": retained_earnings,
             "average_profit": avg_profit,
-            "total_debt": current_liabilities
+            "total_debt": current_liabilities,
         }
 
     def issue_shares(self, quantity: float, price: float) -> float:
@@ -409,8 +455,8 @@ class FinanceDepartment:
                 "price": price,
                 "raised_capital": raised_capital,
                 "total_shares": self.firm.total_shares,
-                "tags": ["stock", "issue"]
-            }
+                "tags": ["stock", "issue"],
+            },
         )
         return raised_capital
 
@@ -422,10 +468,10 @@ class FinanceDepartment:
 
         liabilities = 0.0
         try:
-            loan_market = getattr(self.firm.decision_engine, 'loan_market', None)
-            if loan_market and hasattr(loan_market, 'bank') and loan_market.bank:
+            loan_market = getattr(self.firm.decision_engine, "loan_market", None)
+            if loan_market and hasattr(loan_market, "bank") and loan_market.bank:
                 debt_summary = loan_market.bank.get_debt_summary(self.firm.id)
-                liabilities = debt_summary.get('total_principal', 0.0)
+                liabilities = debt_summary.get("total_principal", 0.0)
         except Exception:
             pass
 
@@ -467,8 +513,10 @@ class FinanceDepartment:
 
     def pay_severance(self, employee: Household, amount: float) -> bool:
         if self._cash >= amount:
-            if hasattr(self.firm, 'settlement_system') and self.firm.settlement_system:
-                if self.firm.settlement_system.transfer(self.firm, employee, amount, "Severance Pay"):
+            if hasattr(self.firm, "settlement_system") and self.firm.settlement_system:
+                if self.firm.settlement_system.transfer(
+                    self.firm, employee, amount, "Severance Pay"
+                ):
                     self.record_expense(amount)
                     return True
                 return False
@@ -479,7 +527,9 @@ class FinanceDepartment:
                 return True
         return False
 
-    def pay_ad_hoc_tax(self, amount: float, tax_type: str, government: Government, current_time: int) -> bool:
+    def pay_ad_hoc_tax(
+        self, amount: float, tax_type: str, government: Government, current_time: int
+    ) -> bool:
         if self._cash >= amount:
             # Debit handled by Government -> FinanceSystem -> SettlementSystem -> Firm.withdraw
             government.collect_tax(amount, tax_type, self.firm, current_time)
diff --git a/simulation/components/hr_department.py b/simulation/components/hr_department.py
index 5086c15..c46baf9 100644
--- a/simulation/components/hr_department.py
+++ b/simulation/components/hr_department.py
@@ -9,11 +9,13 @@ if TYPE_CHECKING:
 
 logger = logging.getLogger(__name__)
 
+
 class HRDepartment:
     """
     Manages employees, calculates wages (skill + halo), and handles insolvency firing.
     Extracted from Firm class (SoC Refactor).
     """
+
     def __init__(self, firm: Firm):
         self.firm = firm
         self.employees: List[Household] = []
@@ -25,15 +27,22 @@ class HRDepartment:
         Calculates wage based on skill and halo effect.
         """
         # WO-023-B: Skill-based Wage Bonus
-        actual_skill = getattr(employee, 'labor_skill', 1.0)
+        actual_skill = getattr(employee, "labor_skill", 1.0)
 
         # WO-Sociologist: Halo Effect (Credential Premium)
-        education_level = getattr(employee, 'education_level', 0)
-        halo_modifier = 1.0 + (education_level * getattr(self.firm.config_module, "HALO_EFFECT", 0.0))
+        education_level = getattr(employee, "education_level", 0)
+        halo_modifier = 1.0 + (
+            education_level * getattr(self.firm.config_module, "HALO_EFFECT", 0.0)
+        )
 
         return base_wage * actual_skill * halo_modifier
 
-    def process_payroll(self, current_time: int, government: Optional[Any], market_data: Optional[Dict[str, Any]]) -> List[Transaction]:
+    def process_payroll(
+        self,
+        current_time: int,
+        government: Optional[Any],
+        market_data: Optional[Dict[str, Any]],
+    ) -> List[Transaction]:
         """
         Pays wages to employees. Handles insolvency firing if assets are insufficient.
         Returns list of Transactions.
@@ -43,14 +52,16 @@ class HRDepartment:
         generated_transactions: List[Transaction] = []
 
         # Calculate survival cost for tax logic
-        survival_cost = 10.0 # Default fallback
+        survival_cost = 10.0  # Default fallback
         if government and market_data:
             survival_cost = government.get_survival_cost(market_data)
 
         # Iterate over copy to allow modification
         for employee in list(self.employees):
             # Defensive checks
-            if not hasattr(employee, 'employer_id') or not hasattr(employee, 'is_employed'):
+            if not hasattr(employee, "employer_id") or not hasattr(
+                employee, "is_employed"
+            ):
                 self.employees.remove(employee)
                 continue
 
@@ -60,7 +71,9 @@ class HRDepartment:
                     del self.employee_wages[employee.id]
                 continue
 
-            base_wage = self.employee_wages.get(employee.id, self.firm.config_module.LABOR_MARKET_MIN_WAGE)
+            base_wage = self.employee_wages.get(
+                employee.id, self.firm.config_module.LABOR_MARKET_MIN_WAGE
+            )
             wage = self.calculate_wage(employee, base_wage)
 
             # Affordability Check (Optimistic)
@@ -74,28 +87,28 @@ class HRDepartment:
 
                 # Transaction 1: Net Wage (Firm -> Employee)
                 tx_wage = Transaction(
-                    buyer_id=self.firm.id, # Payer
-                    seller_id=employee.id, # Payee
+                    buyer_id=self.firm.id,  # Payer
+                    seller_id=employee.id,  # Payee
                     item_id="labor_wage",
                     quantity=1.0,
                     price=net_wage,
                     market_id="labor",
                     transaction_type="wage",
-                    time=current_time
+                    time=current_time,
                 )
                 generated_transactions.append(tx_wage)
 
                 # Transaction 2: Income Tax (Firm -> Government) [Withholding]
                 if income_tax > 0 and government:
                     tx_tax = Transaction(
-                        buyer_id=self.firm.id, # Payer
-                        seller_id=government.id, # Payee
+                        buyer_id=self.firm.id,  # Payer
+                        seller_id=government.id,  # Payee
                         item_id="income_tax",
                         quantity=1.0,
                         price=income_tax,
                         market_id="system",
                         transaction_type="tax",
-                        time=current_time
+                        time=current_time,
                     )
                     generated_transactions.append(tx_tax)
 
@@ -105,11 +118,19 @@ class HRDepartment:
 
             else:
                 # Insolvency Handling
-                self._handle_insolvency_transactions(employee, wage, current_time, generated_transactions)
+                self._handle_insolvency_transactions(
+                    employee, wage, current_time, generated_transactions
+                )
 
         return generated_transactions
 
-    def _handle_insolvency_transactions(self, employee: Household, wage: float, current_time: int, tx_list: List[Transaction]):
+    def _handle_insolvency_transactions(
+        self,
+        employee: Household,
+        wage: float,
+        current_time: int,
+        tx_list: List[Transaction],
+    ):
         """
         Handles case where firm cannot afford wage.
         Attempts severance pay; if fails, zombie state (unpaid retention).
@@ -129,13 +150,17 @@ class HRDepartment:
                 price=severance_pay,
                 market_id="labor",
                 transaction_type="severance",
-                time=current_time
+                time=current_time,
             )
             tx_list.append(tx)
 
             self.firm.logger.info(
                 f"SEVERANCE | Firm {self.firm.id} paid severance {severance_pay:.2f} to Household {employee.id}. Firing due to insolvency.",
-                extra={"tick": current_time, "agent_id": self.firm.id, "severance_pay": severance_pay}
+                extra={
+                    "tick": current_time,
+                    "agent_id": self.firm.id,
+                    "severance_pay": severance_pay,
+                },
             )
 
             employee.quit()
@@ -144,7 +169,11 @@ class HRDepartment:
             # Zombie Employee
             self.firm.logger.warning(
                 f"ZOMBIE | Firm {self.firm.id} cannot afford wage OR severance for Household {employee.id}. Employment retained (unpaid).",
-                extra={"tick": 0, "agent_id": self.firm.id, "wage_deficit": wage - self.firm.assets}
+                extra={
+                    "tick": 0,
+                    "agent_id": self.firm.id,
+                    "wage_deficit": wage - self.firm.assets,
+                },
             )
 
     def hire(self, employee: Household, wage: float):
@@ -159,7 +188,7 @@ class HRDepartment:
             del self.employee_wages[employee.id]
 
     def get_total_labor_skill(self) -> float:
-        return sum(getattr(emp, 'labor_skill', 1.0) for emp in self.employees)
+        return sum(getattr(emp, "labor_skill", 1.0) for emp in self.employees)
 
     def get_avg_skill(self) -> float:
         if not self.employees:
diff --git a/simulation/components/labor_manager.py b/simulation/components/labor_manager.py
index d6b817e..2e2b039 100644
--- a/simulation/components/labor_manager.py
+++ b/simulation/components/labor_manager.py
@@ -79,4 +79,7 @@ class LaborManager:
         Returns:
             The total income (labor + capital) for the current tick.
         """
-        return self._household.labor_income_this_tick + self._household.capital_income_this_tick
+        return (
+            self._household.labor_income_this_tick
+            + self._household.capital_income_this_tick
+        )
diff --git a/simulation/components/leisure_manager.py b/simulation/components/leisure_manager.py
index 3c46282..e5630bf 100644
--- a/simulation/components/leisure_manager.py
+++ b/simulation/components/leisure_manager.py
@@ -8,6 +8,7 @@ if TYPE_CHECKING:
 
 logger = logging.getLogger(__name__)
 
+
 class LeisureManager:
     """
     Phase 22.5: Household Leisure Component
@@ -17,11 +18,13 @@ class LeisureManager:
     def __init__(self, owner: "Household", config_module: Any):
         self.owner = owner
         self.config = config_module
-        
+
         # State
         self.last_leisure_type = "SELF_DEV"
 
-    def apply_leisure_effect(self, leisure_hours: float, consumed_items: Dict[str, float]) -> LeisureEffectDTO:
+    def apply_leisure_effect(
+        self, leisure_hours: float, consumed_items: Dict[str, float]
+    ) -> LeisureEffectDTO:
         """
         Calculates and applies effects of leisure based on time and consumption.
         """
@@ -43,17 +46,17 @@ class LeisureManager:
             self.owner.labor_skill += prod_gained
             logger.debug(
                 f"LEISURE | {self.owner.id} (SELF_DEV) Labor Skill +{prod_gained:.4f}",
-                extra={"agent_id": self.owner.id, "tags": ["leisure"]}
+                extra={"agent_id": self.owner.id, "tags": ["leisure"]},
             )
         elif leisure_type == "ENTERTAINMENT":
-             # Utility is applied via needs reduction usually or logged
-             pass
+            # Utility is applied via needs reduction usually or logged
+            pass
 
         return LeisureEffectDTO(
             leisure_type=leisure_type,
             leisure_hours=leisure_hours,
             utility_gained=utility_gained,
-            xp_gained=xp_gained
+            xp_gained=xp_gained,
         )
 
     def _determine_leisure_type(self, consumed_items: Dict[str, float]) -> str:
@@ -61,8 +64,8 @@ class LeisureManager:
         has_children = len(self.owner.children_ids) > 0
         has_education = consumed_items.get("education_service", 0.0) > 0
         has_luxury = (
-            consumed_items.get("luxury_food", 0.0) > 0 or
-            consumed_items.get("clothing", 0.0) > 0
+            consumed_items.get("luxury_food", 0.0) > 0
+            or consumed_items.get("clothing", 0.0) > 0
         )
 
         if has_children and has_education:
diff --git a/simulation/components/market_component.py b/simulation/components/market_component.py
index bc3de41..3bea94e 100644
--- a/simulation/components/market_component.py
+++ b/simulation/components/market_component.py
@@ -1,19 +1,23 @@
 """
 Implements the MarketComponent which handles utility-based seller selection.
 """
+
 from typing import Any, Dict, Optional, Tuple
 from simulation.systems.api import IMarketComponent, MarketInteractionContext
 
+
 class MarketComponent(IMarketComponent):
     """
     Handles market interactions for the Household, specifically choosing the best seller.
     """
 
     def __init__(self, owner: Any, config: Any):
-        self.owner = owner # Household
+        self.owner = owner  # Household
         self.config = config
 
-    def choose_best_seller(self, item_id: str, context: MarketInteractionContext) -> Tuple[Optional[int], float]:
+    def choose_best_seller(
+        self, item_id: str, context: MarketInteractionContext
+    ) -> Tuple[Optional[int], float]:
         """
         Selects the best seller based on Utility = (Quality^alpha * (1+Awareness)^beta * Loyalty) / Price.
         """
@@ -23,14 +27,14 @@ class MarketComponent(IMarketComponent):
             return None, 0.0
 
         # Assumes market has get_all_asks method returning list of orders
-        if not hasattr(market, 'get_all_asks'):
+        if not hasattr(market, "get_all_asks"):
             return None, 0.0
 
         asks = market.get_all_asks(item_id)
         if not asks:
             return None, 0.0
 
-        best_u = -float('inf')
+        best_u = -float("inf")
         best_seller = None
         best_price = 0.0
 
@@ -41,15 +45,15 @@ class MarketComponent(IMarketComponent):
             seller_id = ask.agent_id
 
             # Metadata
-            brand_data = getattr(ask, 'brand_info', {}) or {}
+            brand_data = getattr(ask, "brand_info", {}) or {}
             quality = brand_data.get("perceived_quality", 1.0)
             awareness = brand_data.get("brand_awareness", 0.0)
 
             loyalty = self.owner.brand_loyalty.get(seller_id, 1.0)
-            quality_pref = getattr(self.owner, 'quality_preference', 0.5)
+            quality_pref = getattr(self.owner, "quality_preference", 0.5)
 
             # Utility Calculation
-            numerator = (quality ** quality_pref) * ((1.0 + awareness) ** beta)
+            numerator = (quality**quality_pref) * ((1.0 + awareness) ** beta)
             utility = (numerator * loyalty) / max(0.01, price)
 
             if utility > best_u:
diff --git a/simulation/components/production_department.py b/simulation/components/production_department.py
index a3b49c5..84cb649 100644
--- a/simulation/components/production_department.py
+++ b/simulation/components/production_department.py
@@ -8,6 +8,7 @@ if TYPE_CHECKING:
 
 logger = logging.getLogger(__name__)
 
+
 class ProductionDepartment:
     """Handles the production logic for a firm."""
 
@@ -25,15 +26,22 @@ class ProductionDepartment:
             if len(self.firm.hr.employees) == 0:
                 return 0.0
 
-            log_extra = {"tick": current_time, "agent_id": self.firm.id, "tags": ["production"]}
+            log_extra = {
+                "tick": current_time,
+                "agent_id": self.firm.id,
+                "tags": ["production"],
+            }
 
             # 1. ê°ê°€ìƒê° ì²˜ë¦¬
-            depreciation_rate = getattr(self.config_module, "CAPITAL_DEPRECIATION_RATE", 0.05)
-            self.firm.capital_stock *= (1.0 - depreciation_rate)
+            depreciation_rate = getattr(
+                self.config_module, "CAPITAL_DEPRECIATION_RATE", 0.05
+            )
+            self.firm.capital_stock *= 1.0 - depreciation_rate
 
             # Phase 21: Automation Decay
-            self.firm.automation_level *= 0.995 # Slow decay (0.5% per tick)
-            if self.firm.automation_level < 0.001: self.firm.automation_level = 0.0
+            self.firm.automation_level *= 0.995  # Slow decay (0.5% per tick)
+            if self.firm.automation_level < 0.001:
+                self.firm.automation_level = 0.0
 
             # 2. ë…¸ë™ ë° ìë³¸ íˆ¬ì…ëŸ‰ ê³„ì‚°
             # SoC Refactor: Get total labor skill from HR
@@ -41,13 +49,19 @@ class ProductionDepartment:
 
             # 3. Cobb-Douglas Parameters
             base_alpha = getattr(self.config_module, "LABOR_ALPHA", 0.7)
-            automation_reduction = getattr(self.config_module, "AUTOMATION_LABOR_REDUCTION", 0.5)
+            automation_reduction = getattr(
+                self.config_module, "AUTOMATION_LABOR_REDUCTION", 0.5
+            )
 
             # Phase 21: Adjusted Alpha
             # alpha_adjusted = base_alpha * (1 - automation_level * 0.5)
             # If Automation = 1.0, Alpha = 0.7 * 0.5 = 0.35 (Capital dependent)
-            alpha_raw = base_alpha * (1.0 - (self.firm.automation_level * automation_reduction))
-            alpha_adjusted = max(getattr(self.config_module, "LABOR_ELASTICITY_MIN", 0.3), alpha_raw)
+            alpha_raw = base_alpha * (
+                1.0 - (self.firm.automation_level * automation_reduction)
+            )
+            alpha_adjusted = max(
+                getattr(self.config_module, "LABOR_ELASTICITY_MIN", 0.3), alpha_raw
+            )
             beta_adjusted = 1.0 - alpha_adjusted
 
             # Effective Labor & Capital
@@ -64,19 +78,25 @@ class ProductionDepartment:
 
             item_config = self.config_module.GOODS.get(self.firm.specialization, {})
             quality_sensitivity = item_config.get("quality_sensitivity", 0.5)
-            actual_quality = self.firm.base_quality + (math.log1p(avg_skill) * quality_sensitivity)
+            actual_quality = self.firm.base_quality + (
+                math.log1p(avg_skill) * quality_sensitivity
+            )
 
             produced_quantity = 0.0
             if total_labor_skill > 0 and capital > 0:
-                produced_quantity = tfp * (total_labor_skill ** alpha_adjusted) * (capital ** beta_adjusted)
+                produced_quantity = (
+                    tfp * (total_labor_skill**alpha_adjusted) * (capital**beta_adjusted)
+                )
 
             actual_produced = 0.0
             if produced_quantity > 0:
                 # WO-030: Input Constraints Logic
-                input_config = self.config_module.GOODS.get(self.firm.specialization, {}).get("inputs", {})
+                input_config = self.config_module.GOODS.get(
+                    self.firm.specialization, {}
+                ).get("inputs", {})
 
                 if input_config:
-                    max_by_inputs = float('inf')
+                    max_by_inputs = float("inf")
                     for mat, req_per_unit in input_config.items():
                         available = self.firm.input_inventory.get(mat, 0.0)
                         if req_per_unit > 0:
@@ -88,18 +108,24 @@ class ProductionDepartment:
                     # Deduct used inputs
                     for mat, req_per_unit in input_config.items():
                         amount_to_deduct = actual_produced * req_per_unit
-                        self.firm.input_inventory[mat] = max(0.0, self.firm.input_inventory.get(mat, 0.0) - amount_to_deduct)
+                        self.firm.input_inventory[mat] = max(
+                            0.0,
+                            self.firm.input_inventory.get(mat, 0.0) - amount_to_deduct,
+                        )
                 else:
                     actual_produced = produced_quantity
 
                 if actual_produced > 0:
-                    self.firm.add_inventory(self.firm.specialization, actual_produced, actual_quality)
+                    self.firm.add_inventory(
+                        self.firm.specialization, actual_produced, actual_quality
+                    )
 
             return actual_produced
 
         except Exception as e:
             import traceback
-            logger.error(f'FIRM_CRASH_PREVENTED | Firm {self.firm.id}: {e}')
+
+            logger.error(f"FIRM_CRASH_PREVENTED | Firm {self.firm.id}: {e}")
             logger.debug(traceback.format_exc())
             return 0.0
 
diff --git a/simulation/components/psychology_component.py b/simulation/components/psychology_component.py
index 533063a..e99f495 100644
--- a/simulation/components/psychology_component.py
+++ b/simulation/components/psychology_component.py
@@ -8,6 +8,7 @@ if TYPE_CHECKING:
 
 logger = logging.getLogger(__name__)
 
+
 class PsychologyComponent:
     """
     Phase 22.5: Household Psychology Component
@@ -15,15 +16,17 @@ class PsychologyComponent:
     and political sentiment.
     """
 
-    def __init__(self, owner: "Household", personality: "Personality", config_module: Any):
+    def __init__(
+        self, owner: "Household", personality: "Personality", config_module: Any
+    ):
         self.owner = owner
         self.config = config_module
         self.personality = personality
-        
+
         # Desire weights based on personality
         self.desire_weights: Dict[str, float] = {}
         self._initialize_desire_weights(personality)
-        
+
         # State
         self.survival_need_high_turns = 0
 
@@ -32,24 +35,32 @@ class PsychologyComponent:
         Initializes desire growth weights based on legacy Personality Enum.
         """
         from simulation.ai.enums import Personality
-        
+
         # Default
         self.desire_weights = {
             "survival": 1.0,
             "asset": 1.0,
             "social": 1.0,
             "improvement": 1.0,
-            "quality": 1.0
+            "quality": 1.0,
         }
-        
+
         if personality in [Personality.MISER, Personality.CONSERVATIVE]:
-            self.desire_weights.update({"asset": 1.5, "social": 0.5, "improvement": 0.5})
+            self.desire_weights.update(
+                {"asset": 1.5, "social": 0.5, "improvement": 0.5}
+            )
         elif personality in [Personality.STATUS_SEEKER, Personality.IMPULSIVE]:
-            self.desire_weights.update({"asset": 0.5, "social": 1.5, "improvement": 0.5})
+            self.desire_weights.update(
+                {"asset": 0.5, "social": 1.5, "improvement": 0.5}
+            )
         elif personality == Personality.GROWTH_ORIENTED:
-            self.desire_weights.update({"asset": 0.5, "social": 0.5, "improvement": 1.5})
+            self.desire_weights.update(
+                {"asset": 0.5, "social": 0.5, "improvement": 1.5}
+            )
 
-    def update_needs(self, current_tick: int, market_data: Optional[Dict[str, Any]] = None):
+    def update_needs(
+        self, current_tick: int, market_data: Optional[Dict[str, Any]] = None
+    ):
         """
         Updates needs based on personality growth, durable utility, and death conditions.
         """
@@ -68,13 +79,17 @@ class PsychologyComponent:
             for need_type, base_utility in utility_effects.items():
                 effective_utility = base_utility * asset["quality"]
                 if need_type in self.owner.needs:
-                    self.owner.needs[need_type] = max(0.0, self.owner.needs[need_type] - effective_utility)
+                    self.owner.needs[need_type] = max(
+                        0.0, self.owner.needs[need_type] - effective_utility
+                    )
 
         # 2. Natural Growth based on Personality
         base_growth = self.config.BASE_DESIRE_GROWTH
         # Ensure 'survival' key exists
-        self.owner.needs["survival"] = self.owner.needs.get("survival", 0.0) + base_growth
-        
+        self.owner.needs["survival"] = (
+            self.owner.needs.get("survival", 0.0) + base_growth
+        )
+
         for k in ["asset", "social", "improvement", "quality"]:
             weight = 1.0
             if self.desire_weights:
@@ -92,8 +107,11 @@ class PsychologyComponent:
             self.survival_need_high_turns = 0
 
         # Assets Death Check
-        if (self.owner.assets <= self.config.ASSETS_DEATH_THRESHOLD or 
-            self.survival_need_high_turns >= self.config.HOUSEHOLD_DEATH_TURNS_THRESHOLD):
+        if (
+            self.owner.assets <= self.config.ASSETS_DEATH_THRESHOLD
+            or self.survival_need_high_turns
+            >= self.config.HOUSEHOLD_DEATH_TURNS_THRESHOLD
+        ):
             self.owner.is_active = False
             self._log_death(current_tick, market_data)
 
@@ -126,9 +144,9 @@ class PsychologyComponent:
         market_food_price = None
         job_vacancies = 0
         if market_data:
-             goods_market = market_data.get("goods_market", {})
-             market_food_price = goods_market.get("basic_food_current_sell_price")
-             job_vacancies = market_data.get("job_vacancies", 0)
+            goods_market = market_data.get("goods_market", {})
+            market_food_price = goods_market.get("basic_food_current_sell_price")
+            job_vacancies = market_data.get("job_vacancies", 0)
 
         logger.warning(
             f"AGENT_DEATH | ID: {self.owner.id} (Cause: starvation/insolvency)",
@@ -139,6 +157,6 @@ class PsychologyComponent:
                 "assets": self.owner.assets,
                 "market_food_price": market_food_price,
                 "job_vacancies": job_vacancies,
-                "tags": ["death", "autopsy"]
-            }
+                "tags": ["death", "autopsy"],
+            },
         )
diff --git a/simulation/components/sales_department.py b/simulation/components/sales_department.py
index cf032d1..67538db 100644
--- a/simulation/components/sales_department.py
+++ b/simulation/components/sales_department.py
@@ -7,6 +7,7 @@ if TYPE_CHECKING:
 
 from simulation.models import Order
 
+
 class SalesDepartment:
     """Handles the sales and marketing logic for a firm."""
 
@@ -14,7 +15,14 @@ class SalesDepartment:
         self.firm = firm
         self.config_module = config_module
 
-    def post_ask(self, item_id: str, price: float, quantity: float, market: OrderBookMarket, current_tick: int) -> Order:
+    def post_ask(
+        self,
+        item_id: str,
+        price: float,
+        quantity: float,
+        market: OrderBookMarket,
+        current_tick: int,
+    ) -> Order:
         """
         íŒë§¤ ì£¼ë¬¸ì„ ìƒì„±í•˜ê³  ì‹œì¥ì— ì œì¶œí•©ë‹ˆë‹¤.
         Brand Metadataë¥¼ ìë™ìœ¼ë¡œ ì£¼ì…í•©ë‹ˆë‹¤.
@@ -23,7 +31,9 @@ class SalesDepartment:
         brand_snapshot = {
             "brand_awareness": self.firm.brand_manager.brand_awareness,
             "perceived_quality": self.firm.brand_manager.perceived_quality,
-            "quality": self.firm.inventory_quality.get(item_id, 1.0), # Phase 15: Physical Quality
+            "quality": self.firm.inventory_quality.get(
+                item_id, 1.0
+            ),  # Phase 15: Physical Quality
         }
 
         # 2. ì£¼ë¬¸ ìƒì„± (brand_info ìë™ ì£¼ì…)
@@ -34,7 +44,7 @@ class SalesDepartment:
             quantity=quantity,
             price=price,
             market_id=market.id,
-            brand_info=brand_snapshot  # <-- Critical Injection
+            brand_info=brand_snapshot,  # <-- Critical Injection
         )
 
         # 3. ì‹œì¥ì— ì œì¶œ
@@ -42,7 +52,11 @@ class SalesDepartment:
 
         self.firm.logger.debug(
             f"FIRM_POST_ASK | Firm {self.firm.id} posted SELL order for {quantity:.1f} {item_id} @ {price:.2f} with brand_info",
-            extra={"agent_id": self.firm.id, "tick": current_tick, "brand_awareness": brand_snapshot["brand_awareness"]}
+            extra={
+                "agent_id": self.firm.id,
+                "tick": current_tick,
+                "brand_awareness": brand_snapshot["brand_awareness"],
+            },
         )
 
         return order
@@ -59,22 +73,34 @@ class SalesDepartment:
             self.firm.finance.last_marketing_spend = self.firm.marketing_budget
             return
 
-        delta_revenue = self.firm.finance.revenue_this_turn - self.firm.finance.last_revenue
+        delta_revenue = (
+            self.firm.finance.revenue_this_turn - self.firm.finance.last_revenue
+        )
         efficiency = delta_revenue / self.firm.finance.last_marketing_spend
 
         # Decision Rules
-        saturation_level = getattr(self.config_module, "BRAND_AWARENESS_SATURATION", 0.9)
-        high_eff_threshold = getattr(self.config_module, "MARKETING_EFFICIENCY_HIGH_THRESHOLD", 1.5)
-        low_eff_threshold = getattr(self.config_module, "MARKETING_EFFICIENCY_LOW_THRESHOLD", 0.8)
+        saturation_level = getattr(
+            self.config_module, "BRAND_AWARENESS_SATURATION", 0.9
+        )
+        high_eff_threshold = getattr(
+            self.config_module, "MARKETING_EFFICIENCY_HIGH_THRESHOLD", 1.5
+        )
+        low_eff_threshold = getattr(
+            self.config_module, "MARKETING_EFFICIENCY_LOW_THRESHOLD", 0.8
+        )
         min_rate = getattr(self.config_module, "MARKETING_BUDGET_RATE_MIN", 0.01)
         max_rate = getattr(self.config_module, "MARKETING_BUDGET_RATE_MAX", 0.20)
 
         if self.firm.brand_manager.brand_awareness >= saturation_level:
             pass  # Maintain (Saturation)
         elif efficiency > high_eff_threshold:
-            self.firm.marketing_budget_rate = min(max_rate, self.firm.marketing_budget_rate * 1.1)
+            self.firm.marketing_budget_rate = min(
+                max_rate, self.firm.marketing_budget_rate * 1.1
+            )
         elif efficiency < low_eff_threshold:
-            self.firm.marketing_budget_rate = max(min_rate, self.firm.marketing_budget_rate * 0.9)
+            self.firm.marketing_budget_rate = max(
+                min_rate, self.firm.marketing_budget_rate * 0.9
+            )
 
         # Update tracking
         self.firm.finance.last_revenue = self.firm.finance.revenue_this_turn
diff --git a/simulation/core_agents.py b/simulation/core_agents.py
index 34d0aa5..012f5e7 100644
--- a/simulation/core_agents.py
+++ b/simulation/core_agents.py
@@ -14,12 +14,25 @@ from simulation.ai.api import (
     Aggressiveness,
 )
 from simulation.core_markets import Market
-from simulation.dtos import DecisionContext, LeisureEffectDTO, LeisureType, MacroFinancialContext, HouseholdConfigDTO
+from simulation.dtos import (
+    DecisionContext,
+    LeisureEffectDTO,
+    LeisureType,
+    MacroFinancialContext,
+    HouseholdConfigDTO,
+)
 from simulation.portfolio import Portfolio
 
 from simulation.ai.household_ai import HouseholdAI
-from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
-from simulation.systems.api import LifecycleContext, MarketInteractionContext, LearningUpdateContext, ILearningAgent
+from simulation.decisions.ai_driven_household_engine import (
+    AIDrivenHouseholdDecisionEngine,
+)
+from simulation.systems.api import (
+    LifecycleContext,
+    MarketInteractionContext,
+    LearningUpdateContext,
+    ILearningAgent,
+)
 
 # New Components
 from modules.household.bio_component import BioComponent
@@ -33,6 +46,7 @@ if TYPE_CHECKING:
 
 logger = logging.getLogger(__name__)
 
+
 class Household(BaseAgent, ILearningAgent):
     """
     Household Agent (Facade).
@@ -59,7 +73,7 @@ class Household(BaseAgent, ILearningAgent):
         parent_id: Optional[int] = None,
         generation: Optional[int] = None,
     ) -> None:
-        self.id = id # Initialize ID early for components
+        self.id = id  # Initialize ID early for components
         # --- Core Attributes ---
         self.talent = talent
         self.config_module = config_module
@@ -73,7 +87,11 @@ class Household(BaseAgent, ILearningAgent):
         mapping = getattr(config_module, "VALUE_ORIENTATION_MAPPING", {})
         prefs = mapping.get(
             value_orientation,
-            {"preference_asset": 1.0, "preference_social": 1.0, "preference_growth": 1.0}
+            {
+                "preference_asset": 1.0,
+                "preference_social": 1.0,
+                "preference_growth": 1.0,
+            },
         )
         self.preference_asset = prefs["preference_asset"]
         self.preference_social = prefs["preference_social"]
@@ -87,7 +105,9 @@ class Household(BaseAgent, ILearningAgent):
             self, config_module, initial_age, gender, parent_id, generation
         )
         self.econ_component = EconComponent(self, config_module)
-        self.social_component = SocialComponent(self, config_module, personality, initial_assets)
+        self.social_component = SocialComponent(
+            self, config_module, personality, initial_assets
+        )
 
         # --- Legacy & Compatibility Attributes ---
         # Some attributes are kept on Facade if they are deeply intertwined or purely transient
@@ -116,7 +136,7 @@ class Household(BaseAgent, ILearningAgent):
 
         self.logger.debug(
             f"HOUSEHOLD_INIT | Household {self.id} initialized (Refactored).",
-            extra={"tags": ["household_init"]}
+            extra={"tags": ["household_init"]},
         )
 
         super().__init__(
@@ -142,7 +162,11 @@ class Household(BaseAgent, ILearningAgent):
         mapping = getattr(config_module, "VALUE_ORIENTATION_MAPPING", {})
         prefs = mapping.get(
             value_orientation,
-            {"preference_asset": 1.0, "preference_social": 1.0, "preference_growth": 1.0}
+            {
+                "preference_asset": 1.0,
+                "preference_social": 1.0,
+                "preference_growth": 1.0,
+            },
         )
         self.preference_asset = prefs["preference_asset"]
         self.preference_social = prefs["preference_social"]
@@ -153,8 +177,10 @@ class Household(BaseAgent, ILearningAgent):
             self, config_module, initial_age, gender, parent_id, generation
         )
         self.econ_component = EconComponent(self, config_module)
-        self.social_component = SocialComponent(self, config_module, personality, initial_assets)
-        
+        self.social_component = SocialComponent(
+            self, config_module, personality, initial_assets
+        )
+
         # --- Legacy & Compatibility Attributes ---
         # Some attributes are kept on Facade if they are deeply intertwined or purely transient
         self.initial_assets_record = initial_assets
@@ -166,7 +192,7 @@ class Household(BaseAgent, ILearningAgent):
         # WO-054: Aptitude (Hidden Trait) - Kept on Facade as it's intrinsic
         raw_aptitude = random.gauss(0.5, 0.15)
         self.aptitude: float = max(0.0, min(1.0, raw_aptitude))
-        
+
         # Initialize Econ Component Initial State
         self.econ_component._assets = initial_assets
         # Skills & Inventory are managed by Econ Component primarily, but accessed via Facade
@@ -175,17 +201,17 @@ class Household(BaseAgent, ILearningAgent):
         # We will use EconComponent's inventory as the source of truth,
         # but BaseAgent.inventory might be accessed by legacy code.
         # Strategy: Override inventory property on Household to delegate to EconComponent.
-        
+
         # Skills
         self.skills: Dict[str, Skill] = {}
-        
+
         # Setup Decision Engine
         self.decision_engine.loan_market = loan_market
         self.decision_engine.logger = self.logger
 
         self.logger.debug(
             f"HOUSEHOLD_INIT | Household {self.id} initialized (Refactored).",
-            extra={"tags": ["household_init"]}
+            extra={"tags": ["household_init"]},
         )
 
     # --- Property Delegation: BioComponent ---
@@ -637,15 +663,15 @@ class Household(BaseAgent, ILearningAgent):
             preference_social=self.preference_social,
             preference_growth=self.preference_growth,
             personality=self.personality,
-            durable_assets=self.durable_assets, # Should we copy?
-            expected_inflation=self.expected_inflation.copy(), # From Facade (transient)
+            durable_assets=self.durable_assets,  # Should we copy?
+            expected_inflation=self.expected_inflation.copy(),  # From Facade (transient)
             is_employed=self.is_employed,
             current_wage=self.current_wage,
             wage_modifier=self.wage_modifier,
             is_homeless=self.is_homeless,
             residing_property_id=self.residing_property_id,
             owned_properties=list(self.owned_properties),
-            portfolio_holdings=self.portfolio.holdings, # Direct reference to Share objects (dataclasses)
+            portfolio_holdings=self.portfolio.holdings,  # Direct reference to Share objects (dataclasses)
             risk_aversion=self.risk_aversion,
             agent_data=self.get_agent_data(),
             conformity=self.conformity,
@@ -655,7 +681,7 @@ class Household(BaseAgent, ILearningAgent):
             ambition=self.ambition,
             # WO-108: Parity Fields
             perceived_fair_price=self.perceived_avg_prices.copy(),
-            sentiment_index=self.optimism
+            sentiment_index=self.optimism,
         )
 
     @override
@@ -669,7 +695,6 @@ class Household(BaseAgent, ILearningAgent):
         macro_context: Optional[MacroFinancialContext] = None,
         stress_scenario_config: Optional["StressScenarioConfig"] = None,
     ) -> Tuple[List["Order"], Tuple["Tactic", "Aggressiveness"]]:
-
         # 0. Update Social Status (Before Decision)
         self.social_component.calculate_social_status()
 
@@ -684,21 +709,26 @@ class Household(BaseAgent, ILearningAgent):
 
         # 1. Prepare DTOs
         state_dto = self.create_state_dto()
-        
+
         # WO-103: Purity Guard - Prepare Config DTO
         config_dto = HouseholdConfigDTO(
             survival_need_consumption_threshold=self.config_module.SURVIVAL_NEED_CONSUMPTION_THRESHOLD,
-            target_food_buffer_quantity=getattr(self.config_module, "TARGET_FOOD_BUFFER_QUANTITY", 5.0),
+            target_food_buffer_quantity=getattr(
+                self.config_module, "TARGET_FOOD_BUFFER_QUANTITY", 5.0
+            ),
             food_purchase_max_per_tick=self.config_module.FOOD_PURCHASE_MAX_PER_TICK,
             assets_threshold_for_other_actions=self.config_module.ASSETS_THRESHOLD_FOR_OTHER_ACTIONS,
             wage_decay_rate=getattr(self.config_module, "WAGE_DECAY_RATE", 0.02),
-            reservation_wage_floor=getattr(self.config_module, "RESERVATION_WAGE_FLOOR", 0.3),
-            survival_critical_turns=getattr(self.config_module, "SURVIVAL_CRITICAL_TURNS", 5),
+            reservation_wage_floor=getattr(
+                self.config_module, "RESERVATION_WAGE_FLOOR", 0.3
+            ),
+            survival_critical_turns=getattr(
+                self.config_module, "SURVIVAL_CRITICAL_TURNS", 5
+            ),
             labor_market_min_wage=self.config_module.LABOR_MARKET_MIN_WAGE,
             household_low_asset_threshold=self.config_module.HOUSEHOLD_LOW_ASSET_THRESHOLD,
             household_low_asset_wage=self.config_module.HOUSEHOLD_LOW_ASSET_WAGE,
             household_default_wage=self.config_module.HOUSEHOLD_DEFAULT_WAGE,
-            
             # AI Engine requirements
             market_price_fallback=self.config_module.MARKET_PRICE_FALLBACK,
             need_factor_base=self.config_module.NEED_FACTOR_BASE,
@@ -709,9 +739,13 @@ class Household(BaseAgent, ILearningAgent):
             bulk_buy_need_threshold=self.config_module.BULK_BUY_NEED_THRESHOLD,
             bulk_buy_agg_threshold=self.config_module.BULK_BUY_AGG_THRESHOLD,
             bulk_buy_moderate_ratio=self.config_module.BULK_BUY_MODERATE_RATIO,
-            panic_buying_threshold=getattr(self.config_module, "PANIC_BUYING_THRESHOLD", 0.05),
+            panic_buying_threshold=getattr(
+                self.config_module, "PANIC_BUYING_THRESHOLD", 0.05
+            ),
             hoarding_factor=getattr(self.config_module, "HOARDING_FACTOR", 0.5),
-            deflation_wait_threshold=getattr(self.config_module, "DEFLATION_WAIT_THRESHOLD", -0.05),
+            deflation_wait_threshold=getattr(
+                self.config_module, "DEFLATION_WAIT_THRESHOLD", -0.05
+            ),
             delay_factor=getattr(self.config_module, "DELAY_FACTOR", 0.5),
             dsr_critical_threshold=self.config_module.DSR_CRITICAL_THRESHOLD,
             budget_limit_normal_ratio=self.config_module.BUDGET_LIMIT_NORMAL_RATIO,
@@ -721,16 +755,20 @@ class Household(BaseAgent, ILearningAgent):
             job_quit_threshold_base=self.config_module.JOB_QUIT_THRESHOLD_BASE,
             job_quit_prob_base=self.config_module.JOB_QUIT_PROB_BASE,
             job_quit_prob_scale=self.config_module.JOB_QUIT_PROB_SCALE,
-            stock_market_enabled=getattr(self.config_module, "STOCK_MARKET_ENABLED", False),
+            stock_market_enabled=getattr(
+                self.config_module, "STOCK_MARKET_ENABLED", False
+            ),
             household_min_assets_for_investment=self.config_module.HOUSEHOLD_MIN_ASSETS_FOR_INVESTMENT,
             stock_investment_equity_delta_threshold=self.config_module.STOCK_INVESTMENT_EQUITY_DELTA_THRESHOLD,
             stock_investment_diversification_count=self.config_module.STOCK_INVESTMENT_DIVERSIFICATION_COUNT,
-            expected_startup_roi=getattr(self.config_module, "EXPECTED_STARTUP_ROI", 0.15),
+            expected_startup_roi=getattr(
+                self.config_module, "EXPECTED_STARTUP_ROI", 0.15
+            ),
             startup_cost=getattr(self.config_module, "STARTUP_COST", 30000.0),
             debt_repayment_ratio=self.config_module.DEBT_REPAYMENT_RATIO,
             debt_repayment_cap=self.config_module.DEBT_REPAYMENT_CAP,
             debt_liquidity_ratio=self.config_module.DEBT_LIQUIDITY_RATIO,
-            initial_rent_price=self.config_module.INITIAL_RENT_PRICE
+            initial_rent_price=self.config_module.INITIAL_RENT_PRICE,
         )
 
         # Context for Decision Engine (Pure Logic)
@@ -742,15 +780,19 @@ class Household(BaseAgent, ILearningAgent):
             market_data=market_data,
             current_time=current_time,
             government=government,
-            stress_scenario_config=stress_scenario_config
+            stress_scenario_config=stress_scenario_config,
         )
 
         # 2. Call Decision Engine
-        orders, chosen_tactic_tuple = self.decision_engine.make_decisions(context, macro_context)
+        orders, chosen_tactic_tuple = self.decision_engine.make_decisions(
+            context, macro_context
+        )
 
         # 3. Orchestrate/Refine Orders via EconComponent
         econ_context = EconContextDTO(markets, market_data, current_time)
-        refined_orders = self.econ_component.orchestrate_economic_decisions(econ_context, orders, stress_scenario_config)
+        refined_orders = self.econ_component.orchestrate_economic_decisions(
+            econ_context, orders, stress_scenario_config
+        )
 
         return refined_orders, chosen_tactic_tuple
 
@@ -764,26 +806,36 @@ class Household(BaseAgent, ILearningAgent):
 
     def quit(self) -> None:
         if self.is_employed:
-            self.logger.info(f"Household {self.id} is quitting from Firm {self.employer_id}")
+            self.logger.info(
+                f"Household {self.id} is quitting from Firm {self.employer_id}"
+            )
             self.is_employed = False
             self.employer_id = None
             self.current_wage = 0.0
 
-    def decide_and_consume(self, current_time: int, market_data: Optional[Dict[str, Any]] = None) -> Dict[str, float]:
-        consumed_items = self.econ_component.consumption.decide_and_consume(current_time, market_data)
+    def decide_and_consume(
+        self, current_time: int, market_data: Optional[Dict[str, Any]] = None
+    ) -> Dict[str, float]:
+        consumed_items = self.econ_component.consumption.decide_and_consume(
+            current_time, market_data
+        )
         self.update_needs(current_time, market_data)
         return consumed_items
 
-    def consume(self, item_id: str, quantity: float, current_time: int) -> "ConsumptionResult":
+    def consume(
+        self, item_id: str, quantity: float, current_time: int
+    ) -> "ConsumptionResult":
         return self.econ_component.consume(item_id, quantity, current_time)
 
     @override
-    def update_needs(self, current_tick: int, market_data: Optional[Dict[str, Any]] = None):
+    def update_needs(
+        self, current_tick: int, market_data: Optional[Dict[str, Any]] = None
+    ):
         """Delegates lifecycle updates to BioComponent."""
         context: LifecycleContext = {
-            "household": self, # Some lifecycle logic might still need 'self' to access properties
+            "household": self,  # Some lifecycle logic might still need 'self' to access properties
             "market_data": market_data if market_data else {},
-            "time": current_tick
+            "time": current_tick,
         }
         self.bio_component.run_lifecycle(context)
 
@@ -793,21 +845,31 @@ class Household(BaseAgent, ILearningAgent):
     def update_political_opinion(self):
         self.social_component.update_political_opinion()
 
-    def apply_leisure_effect(self, leisure_hours: float, consumed_items: Dict[str, float]) -> LeisureEffectDTO:
+    def apply_leisure_effect(
+        self, leisure_hours: float, consumed_items: Dict[str, float]
+    ) -> LeisureEffectDTO:
         return self.social_component.apply_leisure_effect(leisure_hours, consumed_items)
 
     # --- Inflation & Price Logic (Transient/Facade specific) ---
     @override
-    def update_perceived_prices(self, market_data: Dict[str, Any], stress_scenario_config: Optional["StressScenarioConfig"] = None) -> None:
+    def update_perceived_prices(
+        self,
+        market_data: Dict[str, Any],
+        stress_scenario_config: Optional["StressScenarioConfig"] = None,
+    ) -> None:
         self.econ_component.update_perceived_prices(market_data, stress_scenario_config)
 
     # --- Learning & Cloning ---
     @override
-    def clone(self, new_id: int, initial_assets_from_parent: float, current_tick: int) -> "Household":
+    def clone(
+        self, new_id: int, initial_assets_from_parent: float, current_tick: int
+    ) -> "Household":
         request = CloningRequestDTO(new_id, initial_assets_from_parent, current_tick)
         return self.bio_component.clone(request)
 
-    def _create_new_decision_engine(self, new_id: int) -> AIDrivenHouseholdDecisionEngine:
+    def _create_new_decision_engine(
+        self, new_id: int
+    ) -> AIDrivenHouseholdDecisionEngine:
         # Helper for BioComponent.clone
         shared_ai_engine = self.decision_engine.ai_engine.ai_decision_engine
         new_ai_engine = HouseholdAI(
@@ -816,12 +878,12 @@ class Household(BaseAgent, ILearningAgent):
             gamma=self.decision_engine.ai_engine.gamma,
             epsilon=self.decision_engine.ai_engine.action_selector.epsilon,
             base_alpha=self.decision_engine.ai_engine.base_alpha,
-            learning_focus=self.decision_engine.ai_engine.learning_focus
+            learning_focus=self.decision_engine.ai_engine.learning_focus,
         )
         return AIDrivenHouseholdDecisionEngine(
             ai_engine=new_ai_engine,
             config_module=self.config_module,
-            logger=self.logger
+            logger=self.logger,
         )
 
     def get_generational_similarity(self, other: "Household") -> float:
@@ -883,7 +945,7 @@ class Household(BaseAgent, ILearningAgent):
             child.skills[domain] = Skill(
                 domain=domain,
                 value=skill.value * 0.2,
-                observability=skill.observability
+                observability=skill.observability,
             )
         # Wage inheritance
         child.education_level = min(self.education_level, 1)
diff --git a/simulation/core_markets.py b/simulation/core_markets.py
index 039e110..2dc32c7 100644
--- a/simulation/core_markets.py
+++ b/simulation/core_markets.py
@@ -24,7 +24,9 @@ class Market(ABC):
         self.buy_orders: Dict[str, List[Order]] = {}
         self.sell_orders: Dict[str, List[Order]] = {}
         self.matched_transactions: List[Transaction] = []
-        self.logger = logger if logger is not None else logging.getLogger(f"Market_{market_id}")
+        self.logger = (
+            logger if logger is not None else logging.getLogger(f"Market_{market_id}")
+        )
 
     @abstractmethod
     def place_order(self, order: Order, current_time: int) -> List[Transaction]:
diff --git a/simulation/db/repository.py b/simulation/db/repository.py
index b95d56e..d1f70b3 100644
--- a/simulation/db/repository.py
+++ b/simulation/db/repository.py
@@ -5,6 +5,7 @@ from datetime import datetime
 import json
 
 from simulation.db.database import get_db_connection, close_db_connection
+
 if TYPE_CHECKING:
     from simulation.dtos import (
         TransactionData,
@@ -78,7 +79,9 @@ class SimulationRepository:
                     data.tick,
                     data.agent_id,
                     data.decision_type,
-                    json.dumps(data.decision_details) if data.decision_details else None,
+                    json.dumps(data.decision_details)
+                    if data.decision_details
+                    else None,
                     data.predicted_reward,
                     data.actual_reward,
                 ),
@@ -100,7 +103,7 @@ class SimulationRepository:
             self.cursor.execute("DELETE FROM economic_indicators")
             self.cursor.execute("DELETE FROM ai_decisions_history")
             self.conn.commit()
-            
+
             # Reclaim disk space
             self.cursor.execute("VACUUM")
             logger.info("All simulation data cleared and VACUUMed database.")
@@ -318,7 +321,9 @@ class SimulationRepository:
             self.conn.rollback()
             raise
 
-    def save_economic_indicators_batch(self, indicators_data: List["EconomicIndicatorData"]):
+    def save_economic_indicators_batch(
+        self, indicators_data: List["EconomicIndicatorData"]
+    ):
         """
         ì—¬ëŸ¬ ê²½ì œ ì§€í‘œ ë°ì´í„°ë¥¼ ë°ì´í„°ë² ì´ìŠ¤ì— ì¼ê´„ ì €ì¥í•©ë‹ˆë‹¤.
         """
@@ -415,14 +420,19 @@ class SimulationRepository:
                 data_to_insert,
             )
             self.conn.commit()
-            logger.debug(f"Saved {len(market_history_data)} market history records in batch")
+            logger.debug(
+                f"Saved {len(market_history_data)} market history records in batch"
+            )
         except sqlite3.Error as e:
             logger.error(f"Error saving market history batch: {e}")
             self.conn.rollback()
             raise
 
     def get_economic_indicators(
-        self, start_tick: Optional[int] = None, end_tick: Optional[int] = None, run_id: Optional[int] = None
+        self,
+        start_tick: Optional[int] = None,
+        end_tick: Optional[int] = None,
+        run_id: Optional[int] = None,
     ) -> List[Dict[str, Any]]:
         """
         ê²½ì œ ì§€í‘œ ë°ì´í„°ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
@@ -551,7 +561,9 @@ class SimulationRepository:
         """
         close_db_connection()
 
-    def get_generation_stats(self, tick: int, run_id: Optional[int] = None) -> List[Dict[str, Any]]:
+    def get_generation_stats(
+        self, tick: int, run_id: Optional[int] = None
+    ) -> List[Dict[str, Any]]:
         """
         íŠ¹ì • í‹±ì˜ ì„¸ëŒ€ë³„ ì¸êµ¬ ë° ìì‚° í†µê³„ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
         """
@@ -565,12 +577,14 @@ class SimulationRepository:
             query += " AND run_id = ?"
             params.append(run_id)
         query += " GROUP BY generation"
-        
+
         self.cursor.execute(query, params)
         columns = [description[0] for description in self.cursor.description]
         return [dict(zip(columns, row)) for row in self.cursor.fetchall()]
 
-    def get_attrition_counts(self, start_tick: int, end_tick: int, run_id: Optional[int] = None) -> Dict[str, int]:
+    def get_attrition_counts(
+        self, start_tick: int, end_tick: int, run_id: Optional[int] = None
+    ) -> Dict[str, int]:
         """
         Calculates the number of agents that became inactive (bankruptcy/death) between start_tick and end_tick.
 
@@ -609,7 +623,7 @@ class SimulationRepository:
         if run_id:
             query_suffix = " AND run_id = ?"
             params.append(run_id)
-            params.append(run_id) # For the subquery
+            params.append(run_id)  # For the subquery
 
         # Bankruptcy (Firms)
         firm_query = f"""
diff --git a/simulation/db/schema.py b/simulation/db/schema.py
index 9cb3487..ccb5fe8 100644
--- a/simulation/db/schema.py
+++ b/simulation/db/schema.py
@@ -223,15 +223,22 @@ def create_tables(conn: sqlite3.Connection):
     """)
 
     # Indexes
-    cursor.execute("CREATE INDEX IF NOT EXISTS idx_economic_indicators_time ON economic_indicators(time)")
-    cursor.execute("CREATE INDEX IF NOT EXISTS idx_transactions_time ON transactions(time)")
-    cursor.execute("CREATE INDEX IF NOT EXISTS idx_agent_states_time ON agent_states(time)")
-    cursor.execute("CREATE INDEX IF NOT EXISTS idx_market_history_time ON market_history(time)")
+    cursor.execute(
+        "CREATE INDEX IF NOT EXISTS idx_economic_indicators_time ON economic_indicators(time)"
+    )
+    cursor.execute(
+        "CREATE INDEX IF NOT EXISTS idx_transactions_time ON transactions(time)"
+    )
+    cursor.execute(
+        "CREATE INDEX IF NOT EXISTS idx_agent_states_time ON agent_states(time)"
+    )
+    cursor.execute(
+        "CREATE INDEX IF NOT EXISTS idx_market_history_time ON market_history(time)"
+    )
 
     conn.commit()
 
 
-
 if __name__ == "__main__":
     # í…ŒìŠ¤íŠ¸ìš© ë°ì´í„°ë² ì´ìŠ¤ ìƒì„± ë° í…Œì´ë¸” í™•ì¸
     conn = sqlite3.connect("test_simulation.db")
diff --git a/simulation/decisions/__init__.py b/simulation/decisions/__init__.py
index 22d5aca..471beef 100644
--- a/simulation/decisions/__init__.py
+++ b/simulation/decisions/__init__.py
@@ -1,5 +1,7 @@
 from .base_decision_engine import BaseDecisionEngine
 from .ai_driven_firm_engine import AIDrivenFirmDecisionEngine as FirmDecisionEngine
-from .ai_driven_household_engine import AIDrivenHouseholdDecisionEngine as HouseholdDecisionEngine
+from .ai_driven_household_engine import (
+    AIDrivenHouseholdDecisionEngine as HouseholdDecisionEngine,
+)
 
 __all__ = ["BaseDecisionEngine", "FirmDecisionEngine", "HouseholdDecisionEngine"]
diff --git a/simulation/decisions/action_proposal.py b/simulation/decisions/action_proposal.py
index 113e5cc..c925621 100644
--- a/simulation/decisions/action_proposal.py
+++ b/simulation/decisions/action_proposal.py
@@ -92,7 +92,9 @@ class ActionProposalEngine:
                 # --- Phase 21.6: The Invisible Hand (Track A: Reservation Wage) ---
                 # Legacy Support: Accessing market_data via agent if available
                 should_refuse = False
-                if hasattr(agent, "decision_engine") and hasattr(agent.decision_engine, "context"):
+                if hasattr(agent, "decision_engine") and hasattr(
+                    agent.decision_engine, "context"
+                ):
                     # Only if context is persisted, which is unlikely in V1 proposal logic.
                     # Best effort: Use simple assumption or skip for legacy
                     pass
@@ -121,7 +123,7 @@ class ActionProposalEngine:
                         available_goods = getattr(
                             self.config_module,
                             "HOUSEHOLD_CONSUMABLE_GOODS",
-                            ["basic_food", "luxury_food"]
+                            ["basic_food", "luxury_food"],
                         )
 
                     good_to_trade = random.choice(available_goods)
@@ -178,10 +180,7 @@ class ActionProposalEngine:
             # í–‰ë™ ê²°ì •: ë…¸ë™ë ¥ êµ¬ë§¤ ë˜ëŠ” ìƒí’ˆ íŒë§¤
             if random.random() < 0.5:  # TODO: ë” ì •êµí•œ ë¡œì§ìœ¼ë¡œ ë³€ê²½
                 # ë…¸ë™ ì‹œì¥ì— ë…¸ë™ë ¥ êµ¬ë§¤ ì£¼ë¬¸
-                offer_wage = (
-                    self.config_module.INITIAL_WAGE
-                    * random.uniform(0.9, 1.1)
-                )
+                offer_wage = self.config_module.INITIAL_WAGE * random.uniform(0.9, 1.1)
                 orders.append(
                     Order(agent.id, "BUY", "labor", 1, offer_wage, "labor_market")
                 )
diff --git a/simulation/decisions/ai_driven_firm_engine.py b/simulation/decisions/ai_driven_firm_engine.py
index 19a4bcd..8dce38e 100644
--- a/simulation/decisions/ai_driven_firm_engine.py
+++ b/simulation/decisions/ai_driven_firm_engine.py
@@ -43,7 +43,7 @@ class AIDrivenFirmDecisionEngine(BaseDecisionEngine):
     def make_decisions(
         self,
         context: DecisionContext,
-    ) -> Tuple[List[Order], Any]: # Returns FirmActionVector
+    ) -> Tuple[List[Order], Any]:  # Returns FirmActionVector
         """
         Main Decision Loop.
         1. AI decides Strategy (Vector).
@@ -58,6 +58,8 @@ class AIDrivenFirmDecisionEngine(BaseDecisionEngine):
         )
 
         # 2. Corporate Manager Execution
-        orders = self.corporate_manager.realize_ceo_actions(firm_state, context, action_vector)
+        orders = self.corporate_manager.realize_ceo_actions(
+            firm_state, context, action_vector
+        )
 
         return orders, action_vector
diff --git a/simulation/decisions/ai_driven_household_engine.py b/simulation/decisions/ai_driven_household_engine.py
index 491ed30..10c0d41 100644
--- a/simulation/decisions/ai_driven_household_engine.py
+++ b/simulation/decisions/ai_driven_household_engine.py
@@ -38,7 +38,7 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
         self,
         context: DecisionContext,
         macro_context: Optional[MacroFinancialContext] = None,
-    ) -> Tuple[List[Order], Any]: # Returns HouseholdActionVector
+    ) -> Tuple[List[Order], Any]:  # Returns HouseholdActionVector
         """
         AI ì—”ì§„ì„ ì‚¬ìš©í•˜ì—¬ ìµœì ì˜ ì „ìˆ (Vector)ì„ ê²°ì •í•˜ê³ , ê·¸ì— ë”°ë¥¸ ì£¼ë¬¸ì„ ìƒì„±í•œë‹¤.
         Architecture V2: Continuous Aggressiveness
@@ -49,6 +49,7 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
 
         if household is None:
             from simulation.schemas import HouseholdActionVector
+
             return [], HouseholdActionVector()
 
         markets = context.markets
@@ -58,33 +59,33 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
         agent_data = household.agent_data
 
         goods_list = list(self.config_module.GOODS.keys())
-        
+
         action_vector = self.ai_engine.decide_action_vector(
             agent_data, market_data, goods_list
         )
-        
+
         # --- [Phase 4.5] Organic Monetary Transmission: Utility Competition Model ---
-        
+
         loan_market_data = market_data.get("loan_market", {})
         nominal_rate = loan_market_data.get("interest_rate", 0.05)
-        
+
         # 1. Savings Utility (Saving ROI)
         savings_roi = self._calculate_savings_roi(household, nominal_rate)
         # Apply 3-Pillars Preference (Wealth Pillar)
         savings_roi *= household.preference_asset
-        
+
         # 2. Debt Burden (Income Effect)
         debt_data = market_data.get("debt_data", {}).get(household.id, {})
         daily_interest_burden = debt_data.get("daily_interest_burden", 0.0)
         income_proxy = max(household.current_wage, household.assets * 0.01)
         dsr = daily_interest_burden / (income_proxy + 1e-9)
-        
+
         debt_penalty = 1.0
         if dsr > self.config_module.DSR_CRITICAL_THRESHOLD:
-            debt_penalty = 0.5 # 50% reduction in aggressiveness due to liquidity panic
-            
+            debt_penalty = 0.5  # 50% reduction in aggressiveness due to liquidity panic
+
         # --------------------------------------------------------------------------
-        
+
         orders = []
 
         # 2. Execution: Consumption Logic (Per Item)
@@ -92,26 +93,32 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
             # WO-023: Maslow Constraint (Food Security First)
             if item_id == "consumer_goods":
                 food_inventory = household.inventory.get("basic_food", 0.0)
-                target_buffer = getattr(self.config_module, "TARGET_FOOD_BUFFER_QUANTITY", 5.0)
+                target_buffer = getattr(
+                    self.config_module, "TARGET_FOOD_BUFFER_QUANTITY", 5.0
+                )
                 if food_inventory < target_buffer:
-                    continue # Skip consumer_goods if food insecure
+                    continue  # Skip consumer_goods if food insecure
 
             # Phase 15: Utility Saturation for Durables
-            if hasattr(household, 'durable_assets'):
-                 existing_durables = [a for a in household.durable_assets if a['item_id'] == item_id]
-                 has_inventory = household.inventory.get(item_id, 0.0) >= 1.0
+            if hasattr(household, "durable_assets"):
+                existing_durables = [
+                    a for a in household.durable_assets if a["item_id"] == item_id
+                ]
+                has_inventory = household.inventory.get(item_id, 0.0) >= 1.0
 
-                 if existing_durables or has_inventory:
-                     if random.random() < 0.95: # 95% chance to skip
-                         continue
+                if existing_durables or has_inventory:
+                    if random.random() < 0.95:  # 95% chance to skip
+                        continue
 
             agg_buy = action_vector.consumption_aggressiveness.get(item_id, 0.5)
-            
+
             # --- Organic Substitution Effect: Saving vs Consumption ROI ---
-            avg_price = market_data.get("goods_market", {}).get(f"{item_id}_current_sell_price", config.market_price_fallback)
+            avg_price = market_data.get("goods_market", {}).get(
+                f"{item_id}_current_sell_price", config.market_price_fallback
+            )
             if not avg_price or avg_price <= 0:
                 avg_price = config.market_price_fallback
-            
+
             good_info = self.config_module.GOODS.get(item_id, {})
             is_luxury = good_info.get("is_luxury", False)
 
@@ -122,11 +129,15 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
                 nv = household.needs.get(need_type, 0.0)
                 if nv > max_need_value:
                     max_need_value = nv
-            
+
             # --- 3-Pillars ROI Calculation ---
-            preference_weight = household.preference_social if is_luxury else household.preference_growth
+            preference_weight = (
+                household.preference_social
+                if is_luxury
+                else household.preference_growth
+            )
             consumption_roi = (max_need_value / (avg_price + 1e-9)) * preference_weight
-            
+
             # If Saving is more attractive, attenuate aggressiveness
             if savings_roi > consumption_roi:
                 attenuation = consumption_roi / (savings_roi + 1e-9)
@@ -135,13 +146,13 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
                 else:
                     attenuation = max(0.1, attenuation)
                 agg_buy *= attenuation
-            
+
             if random.random() < 0.05:
                 self.logger.info(
                     f"MONETARY_TRANS | HH {household.id} | {item_id} | Need: {max_need_value:.1f} | "
                     f"ConsROI: {consumption_roi:.2f} vs SavROI: {savings_roi:.4f} | AggBuy: {agg_buy:.2f}"
                 )
-            
+
             agg_buy *= debt_penalty
             agg_buy = max(0.0, agg_buy)
 
@@ -150,102 +161,152 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
                     f"MONETARY_TRANS | Agent {household.id} {item_id}: "
                     f"SavROI: {savings_roi:.4f} vs ConsROI: {consumption_roi:.4f} -> Agg: {agg_buy:.2f}"
                 )
-            
+
             utility_effects = good_info.get("utility_effects", {})
-            
-            avg_price = market_data.get("goods_market", {}).get(f"{item_id}_current_sell_price", self.config_module.MARKET_PRICE_FALLBACK)
+
+            avg_price = market_data.get("goods_market", {}).get(
+                f"{item_id}_current_sell_price",
+                self.config_module.MARKET_PRICE_FALLBACK,
+            )
             if not avg_price or avg_price <= 0:
                 avg_price = self.config_module.MARKET_PRICE_FALLBACK
-                
+
             max_need_value = 0.0
             for need_type in utility_effects.keys():
                 nv = household.needs.get(need_type, 0.0)
                 if nv > max_need_value:
                     max_need_value = nv
-            
-            need_factor = self.config_module.NEED_FACTOR_BASE + (max_need_value / self.config_module.NEED_FACTOR_SCALE)
-            valuation_modifier = self.config_module.VALUATION_MODIFIER_BASE + (agg_buy * self.config_module.VALUATION_MODIFIER_RANGE)
-            
+
+            need_factor = self.config_module.NEED_FACTOR_BASE + (
+                max_need_value / self.config_module.NEED_FACTOR_SCALE
+            )
+            valuation_modifier = self.config_module.VALUATION_MODIFIER_BASE + (
+                agg_buy * self.config_module.VALUATION_MODIFIER_RANGE
+            )
+
             willingness_to_pay = avg_price * need_factor * valuation_modifier
 
             # --- Phase 17-4: Veblen Demand Effect ---
-            if getattr(self.config_module, "ENABLE_VANITY_SYSTEM", False) and good_info.get("is_veblen", False):
+            if getattr(
+                self.config_module, "ENABLE_VANITY_SYSTEM", False
+            ) and good_info.get("is_veblen", False):
                 conformity = getattr(household, "conformity", 0.5)
                 prestige_boost = avg_price * 0.1 * conformity
                 willingness_to_pay += prestige_boost
                 agg_buy = min(1.0, agg_buy * (1.0 + 0.2 * conformity))
-            
+
             # 3. Execution: Multi-unit Purchase Logic (Bulk Buying)
             max_q = self.config_module.HOUSEHOLD_MAX_PURCHASE_QUANTITY
             target_quantity = 1.0
-            
+
             if max_need_value > self.config_module.BULK_BUY_NEED_THRESHOLD:
                 target_quantity = max_q
             elif agg_buy > self.config_module.BULK_BUY_AGG_THRESHOLD:
-                target_quantity = max(1.0, max_q * self.config_module.BULK_BUY_MODERATE_RATIO)
-            
+                target_quantity = max(
+                    1.0, max_q * self.config_module.BULK_BUY_MODERATE_RATIO
+                )
+
             # --- Phase 8: Inflation Psychology (Hoarding & Delay) ---
             expected_inflation = household.expected_inflation.get(item_id, 0.0)
-            
-            if expected_inflation > getattr(self.config_module, "PANIC_BUYING_THRESHOLD", 0.05):
+
+            if expected_inflation > getattr(
+                self.config_module, "PANIC_BUYING_THRESHOLD", 0.05
+            ):
                 hoarding_factor = getattr(self.config_module, "HOARDING_FACTOR", 0.5)
-                target_quantity *= (1.0 + hoarding_factor)
-                willingness_to_pay *= (1.0 + expected_inflation)
-                
-            elif expected_inflation < getattr(self.config_module, "DEFLATION_WAIT_THRESHOLD", -0.05):
+                target_quantity *= 1.0 + hoarding_factor
+                willingness_to_pay *= 1.0 + expected_inflation
+
+            elif expected_inflation < getattr(
+                self.config_module, "DEFLATION_WAIT_THRESHOLD", -0.05
+            ):
                 delay_factor = getattr(self.config_module, "DELAY_FACTOR", 0.5)
-                target_quantity *= (1.0 - delay_factor)
-                willingness_to_pay *= (1.0 + expected_inflation)
+                target_quantity *= 1.0 - delay_factor
+                willingness_to_pay *= 1.0 + expected_inflation
 
             # Phase 28: Stress Scenario - Hoarding
             stress_config = context.stress_scenario_config
-            if stress_config and stress_config.is_active and stress_config.scenario_name == 'hyperinflation':
-                consumables = getattr(self.config_module, "HOUSEHOLD_CONSUMABLE_GOODS", ["basic_food", "luxury_food"])
+            if (
+                stress_config
+                and stress_config.is_active
+                and stress_config.scenario_name == "hyperinflation"
+            ):
+                consumables = getattr(
+                    self.config_module,
+                    "HOUSEHOLD_CONSUMABLE_GOODS",
+                    ["basic_food", "luxury_food"],
+                )
                 if item_id in consumables:
-                     target_quantity *= (1.0 + stress_config.hoarding_propensity_factor)
-                     willingness_to_pay *= (1.0 + stress_config.hoarding_propensity_factor * 0.5)
-                     if random.random() < 0.05:
-                         self.logger.info(f"HOARDING_TRIGGER | Household {household.id} hoarding {item_id} (x{target_quantity:.1f})")
-            
-            budget_limit = household.assets * self.config_module.BUDGET_LIMIT_NORMAL_RATIO
+                    target_quantity *= 1.0 + stress_config.hoarding_propensity_factor
+                    willingness_to_pay *= (
+                        1.0 + stress_config.hoarding_propensity_factor * 0.5
+                    )
+                    if random.random() < 0.05:
+                        self.logger.info(
+                            f"HOARDING_TRIGGER | Household {household.id} hoarding {item_id} (x{target_quantity:.1f})"
+                        )
+
+            budget_limit = (
+                household.assets * self.config_module.BUDGET_LIMIT_NORMAL_RATIO
+            )
             if max_need_value > self.config_module.BUDGET_LIMIT_URGENT_NEED:
-                budget_limit = household.assets * self.config_module.BUDGET_LIMIT_URGENT_RATIO
-            
+                budget_limit = (
+                    household.assets * self.config_module.BUDGET_LIMIT_URGENT_RATIO
+                )
+
             if willingness_to_pay * target_quantity > budget_limit:
                 target_quantity = budget_limit / willingness_to_pay
-            
-            if target_quantity >= self.config_module.MIN_PURCHASE_QUANTITY and willingness_to_pay > 0:
+
+            if (
+                target_quantity >= self.config_module.MIN_PURCHASE_QUANTITY
+                and willingness_to_pay > 0
+            ):
                 final_quantity = target_quantity
                 if good_info.get("is_durable", False):
                     final_quantity = max(1, int(target_quantity))
 
                 orders.append(
-                    Order(household.id, "BUY", item_id, final_quantity, willingness_to_pay, item_id)
+                    Order(
+                        household.id,
+                        "BUY",
+                        item_id,
+                        final_quantity,
+                        willingness_to_pay,
+                        item_id,
+                    )
                 )
 
         # 3. Execution: Labor Logic
         labor_market_info = market_data.get("goods_market", {}).get("labor", {})
-        market_avg_wage = labor_market_info.get("avg_wage", self.config_module.LABOR_MARKET_MIN_WAGE)
+        market_avg_wage = labor_market_info.get(
+            "avg_wage", self.config_module.LABOR_MARKET_MIN_WAGE
+        )
         best_market_offer = labor_market_info.get("best_wage_offer", 0.0)
-             
+
         # Scenario A: Already Employed
         if household.is_employed:
             # Recovery handled by EconComponent/LaborManager, here we just check for quit
             agg_mobility = action_vector.job_mobility_aggressiveness
             quit_threshold = self.config_module.JOB_QUIT_THRESHOLD_BASE - agg_mobility
-            
-            if (market_avg_wage > household.current_wage * quit_threshold or 
-                best_market_offer > household.current_wage * quit_threshold):
-                
-                if random.random() < (self.config_module.JOB_QUIT_PROB_BASE + agg_mobility * self.config_module.JOB_QUIT_PROB_SCALE):
+
+            if (
+                market_avg_wage > household.current_wage * quit_threshold
+                or best_market_offer > household.current_wage * quit_threshold
+            ):
+                if random.random() < (
+                    self.config_module.JOB_QUIT_PROB_BASE
+                    + agg_mobility * self.config_module.JOB_QUIT_PROB_SCALE
+                ):
                     # Signal quit via Order
                     orders.append(Order(household.id, "QUIT", "labor", 0, 0, "labor"))
 
         # Scenario B: Unemployed
         if not household.is_employed:
             food_inventory = household.inventory.get("basic_food", 0.0)
-            food_price = market_data.get("goods_market", {}).get("basic_food_avg_traded_price", 10.0)
-            if food_price <= 0: food_price = 10.0
+            food_price = market_data.get("goods_market", {}).get(
+                "basic_food_avg_traded_price", 10.0
+            )
+            if food_price <= 0:
+                food_price = 10.0
 
             survival_days = food_inventory + (household.assets / food_price)
             critical_turns = getattr(self.config_module, "SURVIVAL_CRITICAL_TURNS", 5)
@@ -256,25 +317,39 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
                 reservation_wage = 0.0
                 self.logger.info(
                     f"PANIC_MODE | Household {household.id} desperate. Survival Days: {survival_days:.1f}. Wage: 0.0",
-                     extra={"tick": current_time, "agent_id": household.id, "tags": ["labor_panic"]}
+                    extra={
+                        "tick": current_time,
+                        "agent_id": household.id,
+                        "tags": ["labor_panic"],
+                    },
                 )
             else:
                 labor_market_info = market_data.get("goods_market", {}).get("labor", {})
-                market_avg_wage = labor_market_info.get("avg_wage", self.config_module.LABOR_MARKET_MIN_WAGE)
+                market_avg_wage = labor_market_info.get(
+                    "avg_wage", self.config_module.LABOR_MARKET_MIN_WAGE
+                )
                 reservation_wage = market_avg_wage * household.wage_modifier
 
             labor_market_info = market_data.get("goods_market", {}).get("labor", {})
-            market_avg_wage = labor_market_info.get("avg_wage", self.config_module.LABOR_MARKET_MIN_WAGE)
+            market_avg_wage = labor_market_info.get(
+                "avg_wage", self.config_module.LABOR_MARKET_MIN_WAGE
+            )
             best_market_offer = labor_market_info.get("best_wage_offer", 0.0)
 
-            effective_offer = best_market_offer if best_market_offer > 0 else market_avg_wage
+            effective_offer = (
+                best_market_offer if best_market_offer > 0 else market_avg_wage
+            )
             wage_floor = reservation_wage
 
             if not is_panic and effective_offer < wage_floor:
                 self.logger.info(
                     f"RESERVATION_WAGE | Household {household.id} refused labor. "
                     f"Offer: {effective_offer:.2f} < Floor: {wage_floor:.2f}",
-                    extra={"tick": current_time, "agent_id": household.id, "tags": ["labor_refusal"]}
+                    extra={
+                        "tick": current_time,
+                        "agent_id": household.id,
+                        "tags": ["labor_refusal"],
+                    },
                 )
             else:
                 orders.append(
@@ -293,9 +368,13 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
         # 5. Liquidity Management
         stress_config = context.stress_scenario_config
         is_debt_aversion_mode = False
-        if stress_config and stress_config.is_active and stress_config.scenario_name == 'deflation':
-             if stress_config.debt_aversion_multiplier > 1.0:
-                 is_debt_aversion_mode = True
+        if (
+            stress_config
+            and stress_config.is_active
+            and stress_config.scenario_name == "deflation"
+        ):
+            if stress_config.debt_aversion_multiplier > 1.0:
+                is_debt_aversion_mode = True
 
         debt_data = market_data.get("debt_data", {}).get(household.id, {})
         principal = debt_data.get("total_principal", 0.0)
@@ -306,83 +385,116 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
             cap_ratio = self.config_module.DEBT_REPAYMENT_CAP
             liquidity_ratio = self.config_module.DEBT_LIQUIDITY_RATIO
 
-            repay_amount = household.assets * base_ratio * stress_config.debt_aversion_multiplier
+            repay_amount = (
+                household.assets * base_ratio * stress_config.debt_aversion_multiplier
+            )
             repay_amount = min(repay_amount, principal * cap_ratio)
             repay_amount = min(repay_amount, household.assets * liquidity_ratio)
 
             if repay_amount > 1.0:
-                 orders.append(Order(household.id, "REPAYMENT", "currency", repay_amount, 1.0, "loan_market"))
-                 self.logger.info(f"DEBT_AVERSION | Household {household.id} prioritizing repayment: {repay_amount:.1f}")
+                orders.append(
+                    Order(
+                        household.id,
+                        "REPAYMENT",
+                        "currency",
+                        repay_amount,
+                        1.0,
+                        "loan_market",
+                    )
+                )
+                self.logger.info(
+                    f"DEBT_AVERSION | Household {household.id} prioritizing repayment: {repay_amount:.1f}"
+                )
 
         if current_time % 30 == 0:
             # Modify DTO locally for simulation
             temp_assets = household.assets
             if is_debt_aversion_mode and repay_amount > 0:
                 household.assets -= repay_amount
-            
+
             try:
-                portfolio_orders = self._manage_portfolio(household, market_data, current_time, macro_context)
+                portfolio_orders = self._manage_portfolio(
+                    household, market_data, current_time, macro_context
+                )
                 orders.extend(portfolio_orders)
             finally:
                 household.assets = temp_assets
         else:
-            emergency_orders = self._check_emergency_liquidity(household, market_data, current_time)
+            emergency_orders = self._check_emergency_liquidity(
+                household, market_data, current_time
+            )
             orders.extend(emergency_orders)
 
         # 6. Real Estate Logic
         if "housing" in markets:
-             housing_market = markets["housing"]
-             from simulation.decisions.housing_manager import HousingManager
-
-             housing_manager = HousingManager(household, self.config_module) # Now passes DTO
-
-             reference_standard = market_data.get("reference_standard", {})
-             mimicry_intent = housing_manager.decide_mimicry_purchase(reference_standard)
-
-             is_owner_occupier = household.residing_property_id in household.owned_properties
-             should_search = (not is_owner_occupier) or (mimicry_intent is not None)
-
-             if should_search:
-                 best_offer = None
-                 min_price = float('inf')
-                 
-                 for item_id, orders_list in housing_market.sell_orders.items():
-                     if not orders_list: continue
-                     cheapest = orders_list[0]
-                     if cheapest.price < min_price:
-                         min_price = cheapest.price
-                         best_offer = cheapest
-                         
-                 if best_offer:
-                     loan_market = markets.get("loan_market")
-                     mortgage_rate = loan_market.interest_rate if loan_market else 0.05
-
-                     should_buy = False
-
-                     if mimicry_intent:
-                         should_buy = True
-                     elif not is_owner_occupier:
-                         should_buy = housing_manager.should_buy(
-                             best_offer.price,
-                             self.config_module.INITIAL_RENT_PRICE,
-                             mortgage_rate
-                         )
-
-                     if should_buy:
-                         buy_order = Order(
-                             household.id, "BUY", best_offer.item_id, 1.0, best_offer.price, "housing"
-                         )
-                         orders.append(buy_order)
-
-                         if mimicry_intent:
-                             self.logger.info(
-                                 f"MIMICRY_BUY | Household {household.id} panic buying housing due to relative deprivation.",
-                                 extra={"tick": current_time, "agent_id": household.id}
-                             )
+            housing_market = markets["housing"]
+            from simulation.decisions.housing_manager import HousingManager
+
+            housing_manager = HousingManager(
+                household, self.config_module
+            )  # Now passes DTO
+
+            reference_standard = market_data.get("reference_standard", {})
+            mimicry_intent = housing_manager.decide_mimicry_purchase(reference_standard)
+
+            is_owner_occupier = (
+                household.residing_property_id in household.owned_properties
+            )
+            should_search = (not is_owner_occupier) or (mimicry_intent is not None)
+
+            if should_search:
+                best_offer = None
+                min_price = float("inf")
+
+                for item_id, orders_list in housing_market.sell_orders.items():
+                    if not orders_list:
+                        continue
+                    cheapest = orders_list[0]
+                    if cheapest.price < min_price:
+                        min_price = cheapest.price
+                        best_offer = cheapest
+
+                if best_offer:
+                    loan_market = markets.get("loan_market")
+                    mortgage_rate = loan_market.interest_rate if loan_market else 0.05
+
+                    should_buy = False
+
+                    if mimicry_intent:
+                        should_buy = True
+                    elif not is_owner_occupier:
+                        should_buy = housing_manager.should_buy(
+                            best_offer.price,
+                            self.config_module.INITIAL_RENT_PRICE,
+                            mortgage_rate,
+                        )
+
+                    if should_buy:
+                        buy_order = Order(
+                            household.id,
+                            "BUY",
+                            best_offer.item_id,
+                            1.0,
+                            best_offer.price,
+                            "housing",
+                        )
+                        orders.append(buy_order)
+
+                        if mimicry_intent:
+                            self.logger.info(
+                                f"MIMICRY_BUY | Household {household.id} panic buying housing due to relative deprivation.",
+                                extra={"tick": current_time, "agent_id": household.id},
+                            )
 
         return orders, action_vector
 
-    def _manage_portfolio(self, household: "HouseholdStateDTO", market_data: Dict[str, Any], current_time: int, macro_context: Optional[MacroFinancialContext] = None) -> List[Order]:
+    def _manage_portfolio(
+        self,
+        household: "HouseholdStateDTO",
+        market_data: Dict[str, Any],
+        current_time: int,
+        macro_context: Optional[MacroFinancialContext] = None,
+    ) -> List[Order]:
         """
         Executes Portfolio Optimization (WO-026).
         """
@@ -401,22 +513,28 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
 
         goods_market = market_data.get("goods_market", {})
         food_price = goods_market.get("basic_food_current_sell_price", 5.0)
-        daily_consumption = getattr(self.config_module, "HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK", 2.0)
+        daily_consumption = getattr(
+            self.config_module, "HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK", 2.0
+        )
         monthly_survival_cost = food_price * daily_consumption * 30.0
 
         if household.expected_inflation:
-            avg_inflation = sum(household.expected_inflation.values()) / len(household.expected_inflation)
+            avg_inflation = sum(household.expected_inflation.values()) / len(
+                household.expected_inflation
+            )
         else:
             avg_inflation = 0.0
 
-        target_cash, target_deposit, target_equity = PortfolioManager.optimize_portfolio(
-            total_liquid_assets=total_liquid,
-            risk_aversion=risk_aversion,
-            risk_free_rate=risk_free_rate,
-            equity_return_proxy=equity_return,
-            survival_cost=monthly_survival_cost,
-            inflation_expectation=avg_inflation,
-            macro_context=macro_context
+        target_cash, target_deposit, target_equity = (
+            PortfolioManager.optimize_portfolio(
+                total_liquid_assets=total_liquid,
+                risk_aversion=risk_aversion,
+                risk_free_rate=risk_free_rate,
+                equity_return_proxy=equity_return,
+                survival_cost=monthly_survival_cost,
+                inflation_expectation=avg_inflation,
+                macro_context=macro_context,
+            )
         )
 
         diff_deposit = target_deposit - deposit_balance
@@ -424,11 +542,29 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
         if diff_deposit > 10.0:
             actual_deposit = min(cash, diff_deposit)
             if actual_deposit > 10.0:
-                orders.append(Order(household.id, "DEPOSIT", "currency", actual_deposit, 1.0, "currency"))
+                orders.append(
+                    Order(
+                        household.id,
+                        "DEPOSIT",
+                        "currency",
+                        actual_deposit,
+                        1.0,
+                        "currency",
+                    )
+                )
 
         elif diff_deposit < -10.0:
             amount_to_withdraw = abs(diff_deposit)
-            orders.append(Order(household.id, "WITHDRAW", "currency", amount_to_withdraw, 1.0, "currency"))
+            orders.append(
+                Order(
+                    household.id,
+                    "WITHDRAW",
+                    "currency",
+                    amount_to_withdraw,
+                    1.0,
+                    "currency",
+                )
+            )
 
         startup_cost = getattr(self.config_module, "STARTUP_COST", 30000.0)
 
@@ -437,11 +573,18 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
             survival_buffer = 2000.0
 
             if projected_cash >= (startup_cost + survival_buffer):
-                orders.append(Order(household.id, "INVEST", "startup", 1.0, startup_cost, "admin"))
+                orders.append(
+                    Order(household.id, "INVEST", "startup", 1.0, startup_cost, "admin")
+                )
 
         return orders
 
-    def _check_emergency_liquidity(self, household: "HouseholdStateDTO", market_data: Dict[str, Any], current_time: int) -> List[Order]:
+    def _check_emergency_liquidity(
+        self,
+        household: "HouseholdStateDTO",
+        market_data: Dict[str, Any],
+        current_time: int,
+    ) -> List[Order]:
         orders = []
         if household.assets < 10.0:
             deposit_data = market_data.get("deposit_data", {})
@@ -449,7 +592,9 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
 
             if deposit_balance > 10.0:
                 amount = min(deposit_balance, 50.0)
-                orders.append(Order(household.id, "WITHDRAW", "currency", amount, 1.0, "currency"))
+                orders.append(
+                    Order(household.id, "WITHDRAW", "currency", amount, 1.0, "currency")
+                )
 
         return orders
 
@@ -463,10 +608,10 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
         macro_context: Optional[MacroFinancialContext] = None,
     ) -> List[StockOrder]:
         stock_orders: List[StockOrder] = []
-        
+
         if not getattr(self.config_module, "STOCK_MARKET_ENABLED", False):
             return stock_orders
-        
+
         stock_market = markets.get("stock_market")
         if stock_market is None:
             return stock_orders
@@ -480,23 +625,32 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
         goods_market = market_data.get("goods_market", {})
         food_price = goods_market.get("basic_food_current_sell_price", 5.0)
         if not food_price or food_price <= 0:
-            food_price = self.config_module.GOODS.get("basic_food", {}).get("initial_price", 5.0)
-        daily_consumption = getattr(self.config_module, "HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK", 2.0)
+            food_price = self.config_module.GOODS.get("basic_food", {}).get(
+                "initial_price", 5.0
+            )
+        daily_consumption = getattr(
+            self.config_module, "HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK", 2.0
+        )
         survival_cost = food_price * daily_consumption * 30.0
 
         risk_aversion = self._get_risk_aversion(household.personality)
 
-        target_cash, target_deposit, target_equity = PortfolioManager.optimize_portfolio(
-            total_liquid_assets=household.assets,
-            risk_aversion=risk_aversion,
-            risk_free_rate=risk_free_rate,
-            equity_return_proxy=avg_dividend_yield,
-            survival_cost=survival_cost,
-            inflation_expectation=market_data.get("inflation", 0.02),
-            macro_context=macro_context
+        target_cash, target_deposit, target_equity = (
+            PortfolioManager.optimize_portfolio(
+                total_liquid_assets=household.assets,
+                risk_aversion=risk_aversion,
+                risk_free_rate=risk_free_rate,
+                equity_return_proxy=avg_dividend_yield,
+                survival_cost=survival_cost,
+                inflation_expectation=market_data.get("inflation", 0.02),
+                macro_context=macro_context,
+            )
         )
 
-        current_prices = {firm_id: stock_market.get_stock_price(firm_id) for firm_id in household.portfolio_holdings.keys()}
+        current_prices = {
+            firm_id: stock_market.get_stock_price(firm_id)
+            for firm_id in household.portfolio_holdings.keys()
+        }
 
         # Calculate valuation manually for DTO
         current_equity_value = 0.0
@@ -507,10 +661,18 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
         equity_delta = target_equity - current_equity_value
 
         if equity_delta > self.config_module.STOCK_INVESTMENT_EQUITY_DELTA_THRESHOLD:
-            stock_orders.extend(self._place_buy_orders(household, equity_delta, stock_market, current_time))
+            stock_orders.extend(
+                self._place_buy_orders(
+                    household, equity_delta, stock_market, current_time
+                )
+            )
         elif equity_delta < -self.config_module.STOCK_INVESTMENT_EQUITY_DELTA_THRESHOLD:
-            stock_orders.extend(self._place_sell_orders(household, -equity_delta, stock_market, current_time))
-        
+            stock_orders.extend(
+                self._place_sell_orders(
+                    household, -equity_delta, stock_market, current_time
+                )
+            )
+
         return stock_orders
 
     def _get_risk_aversion(self, personality_type: Personality) -> float:
@@ -520,13 +682,25 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
             return 5.0
         return 2.0
 
-    def _place_buy_orders(self, household: "HouseholdStateDTO", amount_to_invest: float, stock_market: Any, tick: int) -> List[StockOrder]:
+    def _place_buy_orders(
+        self,
+        household: "HouseholdStateDTO",
+        amount_to_invest: float,
+        stock_market: Any,
+        tick: int,
+    ) -> List[StockOrder]:
         orders = []
-        available_stocks = [fid for fid in stock_market.reference_prices.keys() if stock_market.get_stock_price(fid) > 0]
+        available_stocks = [
+            fid
+            for fid in stock_market.reference_prices.keys()
+            if stock_market.get_stock_price(fid) > 0
+        ]
         if not available_stocks:
             return orders
 
-        diversification_count = self.config_module.STOCK_INVESTMENT_DIVERSIFICATION_COUNT
+        diversification_count = (
+            self.config_module.STOCK_INVESTMENT_DIVERSIFICATION_COUNT
+        )
         investment_per_stock = amount_to_invest / diversification_count
         for _ in range(diversification_count):
             firm_id = random.choice(available_stocks)
@@ -534,16 +708,29 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
             if price > 0:
                 quantity = investment_per_stock / price
                 if quantity >= 1.0:
-                    order = StockOrder(household.id, order_type="BUY", firm_id=firm_id, quantity=quantity, price=price * 1.05)
+                    order = StockOrder(
+                        household.id,
+                        order_type="BUY",
+                        firm_id=firm_id,
+                        quantity=quantity,
+                        price=price * 1.05,
+                    )
                     orders.append(order)
         return orders
 
-    def _place_sell_orders(self, household: "HouseholdStateDTO", amount_to_sell: float, stock_market: Any, tick: int) -> List[StockOrder]:
+    def _place_sell_orders(
+        self,
+        household: "HouseholdStateDTO",
+        amount_to_sell: float,
+        stock_market: Any,
+        tick: int,
+    ) -> List[StockOrder]:
         orders = []
         sorted_holdings = sorted(
             household.portfolio_holdings.items(),
-            key=lambda item: item[1].quantity * stock_market.get_stock_price(item[0]), # Access .quantity
-            reverse=True
+            key=lambda item: item[1].quantity
+            * stock_market.get_stock_price(item[0]),  # Access .quantity
+            reverse=True,
         )
 
         for firm_id, share in sorted_holdings:
@@ -556,39 +743,58 @@ class AIDrivenHouseholdDecisionEngine(BaseDecisionEngine):
                 sell_value = min(amount_to_sell, value_of_holding)
                 sell_quantity = sell_value / price
                 if sell_quantity >= 1.0:
-                    order = StockOrder(household.id, order_type="SELL", firm_id=firm_id, quantity=sell_quantity, price=price * 0.95)
+                    order = StockOrder(
+                        household.id,
+                        order_type="SELL",
+                        firm_id=firm_id,
+                        quantity=sell_quantity,
+                        price=price * 0.95,
+                    )
                     orders.append(order)
                     amount_to_sell -= sell_value
         return orders
 
-    def _calculate_savings_roi(self, household: "HouseholdStateDTO", nominal_rate: float) -> float:
+    def _calculate_savings_roi(
+        self, household: "HouseholdStateDTO", nominal_rate: float
+    ) -> float:
         """ê°€ê³„ì˜ ì €ì¶• ROI(ë¯¸ë˜ íš¨ìš©)ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤."""
         if household.expected_inflation:
-            avg_expected_inflation = sum(household.expected_inflation.values()) / len(household.expected_inflation)
+            avg_expected_inflation = sum(household.expected_inflation.values()) / len(
+                household.expected_inflation
+            )
         else:
             avg_expected_inflation = 0.0
-            
+
         real_rate = nominal_rate - avg_expected_inflation
-        
+
         beta = 1.0
         if household.personality in [Personality.MISER, Personality.CONSERVATIVE]:
             beta = 1.2
-        elif household.personality in [Personality.STATUS_SEEKER, Personality.IMPULSIVE]:
+        elif household.personality in [
+            Personality.STATUS_SEEKER,
+            Personality.IMPULSIVE,
+        ]:
             beta = 0.8
-            
+
         return (1.0 + real_rate) * beta
 
-    def _execute_tactic(self, *args): return []
-    def _handle_specific_purchase(self, *args): return []
+    def _execute_tactic(self, *args):
+        return []
+
+    def _handle_specific_purchase(self, *args):
+        return []
 
     def decide_reproduction(self, context: DecisionContext) -> bool:
         """
         Calls AI engine to decide reproduction.
         """
         household = context.state
-        if not household: return False
+        if not household:
+            return False
 
         agent_data = household.agent_data
         market_data = context.market_data
 
-        return self.ai_engine.decide_reproduction(agent_data, market_data, context.current_time)
+        return self.ai_engine.decide_reproduction(
+            agent_data, market_data, context.current_time
+        )
diff --git a/simulation/decisions/base_decision_engine.py b/simulation/decisions/base_decision_engine.py
index 859cb8e..b1e5b5f 100644
--- a/simulation/decisions/base_decision_engine.py
+++ b/simulation/decisions/base_decision_engine.py
@@ -20,12 +20,16 @@ class BaseDecisionEngine:
         ğŸš¨ DTO PURITY GATE ğŸš¨: ì§ì ‘ì ì¸ ì—ì´ì „íŠ¸ ì¸ìŠ¤í„´ìŠ¤ ì ‘ê·¼ì„ ì°¨ë‹¨í•©ë‹ˆë‹¤.
         """
         # ğŸš¨ DTO PURITY GATE ğŸš¨
-        assert hasattr(context, 'state') and context.state is not None, "Purity Error: context.state DTO is missing."
-        assert hasattr(context, 'config') and context.config is not None, "Purity Error: context.config DTO is missing."
-        
+        assert hasattr(context, "state") and context.state is not None, (
+            "Purity Error: context.state DTO is missing."
+        )
+        assert hasattr(context, "config") and context.config is not None, (
+            "Purity Error: context.config DTO is missing."
+        )
+
         # We allow .household and .firm for now but they should be ignored by new engines.
         # Once migration is complete, we will explicitly forbid them.
-        
+
         return self._make_decisions_internal(context, macro_context)
 
     def _make_decisions_internal(
diff --git a/simulation/decisions/corporate_manager.py b/simulation/decisions/corporate_manager.py
index 6c2a6c6..34d2191 100644
--- a/simulation/decisions/corporate_manager.py
+++ b/simulation/decisions/corporate_manager.py
@@ -11,6 +11,7 @@ from simulation.markets.stock_market import StockMarket
 
 logger = logging.getLogger(__name__)
 
+
 class CorporateManager:
     """
     CEO Module (WO-027).
@@ -28,7 +29,7 @@ class CorporateManager:
         self,
         firm: FirmStateDTO,
         context: DecisionContext,
-        action_vector: FirmActionVector
+        action_vector: FirmActionVector,
     ) -> List[Order]:
         """
         Main entry point. Orchestrates all channel executions using pure DTOs.
@@ -38,9 +39,11 @@ class CorporateManager:
 
         # Phase 21: System 2 Strategic Guidance
         if self.system2_planner is None:
-             self.system2_planner = FirmSystem2Planner(None, self.config_module)
+            self.system2_planner = FirmSystem2Planner(None, self.config_module)
 
-        guidance = self.system2_planner.project_future(context.current_time, context.market_data, firm)
+        guidance = self.system2_planner.project_future(
+            context.current_time, context.market_data, firm
+        )
 
         # 0. Production Target Adjustment (Restored Logic)
         target_order = self._manage_production_target(firm)
@@ -48,17 +51,21 @@ class CorporateManager:
             orders.append(target_order)
 
         # 0. Procurement Channel (Raw Materials) - WO-030
-        procurement_orders = self._manage_procurement(firm, context.market_data, context.markets)
+        procurement_orders = self._manage_procurement(
+            firm, context.market_data, context.markets
+        )
         orders.extend(procurement_orders)
 
         # Phase 21: Automation Channel
-        auto_orders = self._manage_automation(firm, action_vector.capital_aggressiveness, guidance, context.current_time)
+        auto_orders = self._manage_automation(
+            firm, action_vector.capital_aggressiveness, guidance, context.current_time
+        )
         orders.extend(auto_orders)
 
         # 1. R&D Channel (Innovation)
         rd_agg = action_vector.rd_aggressiveness
         if guidance.get("rd_intensity", 0.0) > 0.1:
-             rd_agg = max(rd_agg, 0.5)
+            rd_agg = max(rd_agg, 0.5)
 
         rd_order = self._manage_r_and_d(firm, rd_agg, context.current_time)
         if rd_order:
@@ -76,15 +83,25 @@ class CorporateManager:
             orders.append(div_order)
 
         # 4. Debt Channel (Leverage)
-        debt_orders = self._manage_debt(firm, action_vector.debt_aggressiveness, context.market_data)
+        debt_orders = self._manage_debt(
+            firm, action_vector.debt_aggressiveness, context.market_data
+        )
         orders.extend(debt_orders)
 
         # 5. Pricing Channel (Sales)
-        pricing_orders = self._manage_pricing(firm, action_vector.sales_aggressiveness, context.market_data, context.markets, context.current_time)
+        pricing_orders = self._manage_pricing(
+            firm,
+            action_vector.sales_aggressiveness,
+            context.market_data,
+            context.markets,
+            context.current_time,
+        )
         orders.extend(pricing_orders)
 
         # 6. Hiring Channel (Employment)
-        hiring_orders = self._manage_hiring(firm, action_vector.hiring_aggressiveness, context.market_data)
+        hiring_orders = self._manage_hiring(
+            firm, action_vector.hiring_aggressiveness, context.market_data
+        )
         orders.extend(hiring_orders)
 
         # 7. Secondary Offering (SEO)
@@ -94,7 +111,9 @@ class CorporateManager:
 
         return orders
 
-    def _attempt_secondary_offering(self, firm: FirmStateDTO, context: DecisionContext) -> Optional[StockOrder]:
+    def _attempt_secondary_offering(
+        self, firm: FirmStateDTO, context: DecisionContext
+    ) -> Optional[StockOrder]:
         """Sell treasury shares to raise capital when cash is low."""
         startup_cost = getattr(self.config_module, "STARTUP_COST", 30000.0)
         trigger_ratio = getattr(self.config_module, "SEO_TRIGGER_RATIO", 0.5)
@@ -123,7 +142,7 @@ class CorporateManager:
         # But stock_market logic below uses get_stock_price method.
         # Assuming context.markets["stock_market"] is available.
         if stock_market and hasattr(stock_market, "get_stock_price"):
-             price = stock_market.get_stock_price(firm.id)
+            price = stock_market.get_stock_price(firm.id)
 
         if price is None or price <= 0:
             # Fallback to Book Value
@@ -141,17 +160,23 @@ class CorporateManager:
             order_type="SELL",
             quantity=sell_qty,
             price=price,
-            market_id="stock_market"
+            market_id="stock_market",
+        )
+        self.logger.info(
+            f"SEO | Firm {firm.id} offering {sell_qty:.1f} shares at {price:.2f}"
         )
-        self.logger.info(f"SEO | Firm {firm.id} offering {sell_qty:.1f} shares at {price:.2f}")
         return order
 
-    def _manage_procurement(self, firm: FirmStateDTO, market_data: Dict[str, Any], markets: Dict[str, Any]) -> List[Order]:
+    def _manage_procurement(
+        self, firm: FirmStateDTO, market_data: Dict[str, Any], markets: Dict[str, Any]
+    ) -> List[Order]:
         """
         WO-030: Manage Raw Material Procurement.
         """
         orders = []
-        input_config = self.config_module.GOODS.get(firm.specialization, {}).get("inputs", {})
+        input_config = self.config_module.GOODS.get(firm.specialization, {}).get(
+            "inputs", {}
+        )
 
         if not input_config:
             return orders
@@ -170,16 +195,24 @@ class CorporateManager:
 
                 last_price = mat_market_data.get(last_price_key, 0.0)
                 if last_price <= 0:
-                     last_price = mat_market_data.get(fallback_price_key, 0.0)
+                    last_price = mat_market_data.get(fallback_price_key, 0.0)
                 if last_price <= 0:
-                     last_price = self.config_module.GOODS.get(mat, {}).get("initial_price", 10.0)
+                    last_price = self.config_module.GOODS.get(mat, {}).get(
+                        "initial_price", 10.0
+                    )
 
                 bid_price = last_price * 1.05
                 orders.append(Order(firm.id, "BUY", mat, deficit, bid_price, mat))
 
         return orders
 
-    def _manage_automation(self, firm: FirmStateDTO, aggressiveness: float, guidance: Dict[str, Any], current_time: int) -> List[Order]:
+    def _manage_automation(
+        self,
+        firm: FirmStateDTO,
+        aggressiveness: float,
+        guidance: Dict[str, Any],
+        current_time: int,
+    ) -> List[Order]:
         """
         Phase 21: Automation Investment.
         """
@@ -204,18 +237,26 @@ class CorporateManager:
             return orders
 
         # Generate Internal Order
-        orders.append(Order(firm.id, "INVEST_AUTOMATION", "internal", actual_spend, 0.0, "internal"))
+        orders.append(
+            Order(
+                firm.id, "INVEST_AUTOMATION", "internal", actual_spend, 0.0, "internal"
+            )
+        )
 
         # WO-044-Track-B: Automation Tax
         automation_tax_rate = getattr(self.config_module, "AUTOMATION_TAX_RATE", 0.05)
         tax_amount = actual_spend * automation_tax_rate
 
         if tax_amount > 0:
-            orders.append(Order(firm.id, "PAY_TAX", "automation_tax", tax_amount, 0.0, "internal"))
+            orders.append(
+                Order(firm.id, "PAY_TAX", "automation_tax", tax_amount, 0.0, "internal")
+            )
 
         return orders
 
-    def _manage_r_and_d(self, firm: FirmStateDTO, aggressiveness: float, current_time: int) -> Optional[Order]:
+    def _manage_r_and_d(
+        self, firm: FirmStateDTO, aggressiveness: float, current_time: int
+    ) -> Optional[Order]:
         """
         Innovation Physics.
         """
@@ -237,7 +278,9 @@ class CorporateManager:
 
         return Order(firm.id, "INVEST_RD", "internal", budget, 0.0, "internal")
 
-    def _manage_capex(self, firm: FirmStateDTO, aggressiveness: float, current_time: int) -> Optional[Order]:
+    def _manage_capex(
+        self, firm: FirmStateDTO, aggressiveness: float, current_time: int
+    ) -> Optional[Order]:
         """
         Capacity Expansion.
         """
@@ -254,15 +297,21 @@ class CorporateManager:
 
         return Order(firm.id, "INVEST_CAPEX", "internal", budget, 0.0, "internal")
 
-    def _manage_dividends(self, firm: FirmStateDTO, aggressiveness: float) -> Optional[Order]:
+    def _manage_dividends(
+        self, firm: FirmStateDTO, aggressiveness: float
+    ) -> Optional[Order]:
         """
         Set Dividend Rate.
         """
         z_score = firm.altman_z_score
-        z_score_threshold = getattr(self.config_module, "ALTMAN_Z_SCORE_THRESHOLD", 1.81)
+        z_score_threshold = getattr(
+            self.config_module, "ALTMAN_Z_SCORE_THRESHOLD", 1.81
+        )
         loss_limit = getattr(self.config_module, "DIVIDEND_SUSPENSION_LOSS_TICKS", 3)
 
-        is_distressed = (z_score < z_score_threshold) or (firm.consecutive_loss_turns >= loss_limit)
+        is_distressed = (z_score < z_score_threshold) or (
+            firm.consecutive_loss_turns >= loss_limit
+        )
 
         if is_distressed:
             return Order(firm.id, "SET_DIVIDEND", "internal", 0.0, 0.0, "internal")
@@ -273,7 +322,9 @@ class CorporateManager:
 
         return Order(firm.id, "SET_DIVIDEND", "internal", new_rate, 0.0, "internal")
 
-    def _manage_debt(self, firm: FirmStateDTO, aggressiveness: float, market_data: Dict) -> List[Order]:
+    def _manage_debt(
+        self, firm: FirmStateDTO, aggressiveness: float, market_data: Dict
+    ) -> List[Order]:
         """
         Leverage Management.
         """
@@ -303,13 +354,20 @@ class CorporateManager:
             repay_amount = min(excess_debt, firm.assets * 0.5)
 
             if repay_amount > 10.0 and current_debt > 0:
-                 orders.append(
+                orders.append(
                     Order(firm.id, "REPAYMENT", "loan", repay_amount, 1.0, "loan")
                 )
 
         return orders
 
-    def _manage_pricing(self, firm: FirmStateDTO, aggressiveness: float, market_data: Dict, markets: Dict, current_time: int) -> List[Order]:
+    def _manage_pricing(
+        self,
+        firm: FirmStateDTO,
+        aggressiveness: float,
+        market_data: Dict,
+        markets: Dict,
+        current_time: int,
+    ) -> List[Order]:
         """
         Sales Channel.
         """
@@ -322,11 +380,13 @@ class CorporateManager:
 
         market_price = 0.0
         if item_id in market_data:
-             market_price = market_data[item_id].get('avg_price', 0)
+            market_price = market_data[item_id].get("avg_price", 0)
         if market_price <= 0:
-             market_price = firm.price_history.get(item_id, 0)
+            market_price = firm.price_history.get(item_id, 0)
         if market_price <= 0:
-             market_price = self.config_module.GOODS.get(item_id, {}).get("production_cost", 10.0)
+            market_price = self.config_module.GOODS.get(item_id, {}).get(
+                "production_cost", 10.0
+            )
 
         adjustment = (0.5 - aggressiveness) * 0.4
         target_price = market_price * (1.0 + adjustment)
@@ -343,7 +403,9 @@ class CorporateManager:
         target_price = max(target_price, 0.1)
 
         # 1. Internal Order to update price state
-        orders.append(Order(firm.id, "SET_PRICE", item_id, target_price, 0.0, "internal"))
+        orders.append(
+            Order(firm.id, "SET_PRICE", item_id, target_price, 0.0, "internal")
+        )
 
         # 2. Market Order to sell
         qty = min(current_inventory, self.config_module.MAX_SELL_QUANTITY)
@@ -354,18 +416,22 @@ class CorporateManager:
 
         target_market = markets.get(item_id)
         if target_market:
-             orders.append(Order(
-                 agent_id=firm.id,
-                 order_type="SELL",
-                 item_id=item_id,
-                 quantity=qty,
-                 price=target_price,
-                 market_id=item_id # Assumes market_id == item_id
-             ))
+            orders.append(
+                Order(
+                    agent_id=firm.id,
+                    order_type="SELL",
+                    item_id=item_id,
+                    quantity=qty,
+                    price=target_price,
+                    market_id=item_id,  # Assumes market_id == item_id
+                )
+            )
 
         return orders
 
-    def _manage_hiring(self, firm: FirmStateDTO, aggressiveness: float, market_data: Dict) -> List[Order]:
+    def _manage_hiring(
+        self, firm: FirmStateDTO, aggressiveness: float, market_data: Dict
+    ) -> List[Order]:
         """
         Hiring Channel.
         """
@@ -375,22 +441,27 @@ class CorporateManager:
         inventory_gap = target_inventory - current_inventory
 
         base_alpha = getattr(self.config_module, "LABOR_ALPHA", 0.7)
-        automation_reduction = getattr(self.config_module, "AUTOMATION_LABOR_REDUCTION", 0.5)
-        alpha_adjusted = base_alpha * (1.0 - (firm.automation_level * automation_reduction))
+        automation_reduction = getattr(
+            self.config_module, "AUTOMATION_LABOR_REDUCTION", 0.5
+        )
+        alpha_adjusted = base_alpha * (
+            1.0 - (firm.automation_level * automation_reduction)
+        )
         beta_adjusted = 1.0 - alpha_adjusted
 
         capital = max(firm.capital_stock, 1.0)
         tfp = firm.productivity_factor
 
-        if tfp <= 0: tfp = 1.0
+        if tfp <= 0:
+            tfp = 1.0
 
         needed_labor_calc = 0.0
         if inventory_gap > 0:
             try:
-                 term = inventory_gap / (tfp * (capital ** beta_adjusted))
-                 needed_labor_calc = term ** (1.0 / alpha_adjusted)
+                term = inventory_gap / (tfp * (capital**beta_adjusted))
+                needed_labor_calc = term ** (1.0 / alpha_adjusted)
             except Exception:
-                 needed_labor_calc = 1.0
+                needed_labor_calc = 1.0
         else:
             needed_labor_calc = 0.0
 
@@ -411,29 +482,33 @@ class CorporateManager:
                 for emp_id in candidates:
                     # Get wage and skill from DTO
                     emp_data = firm.employees_data.get(emp_id, {})
-                    wage = emp_data.get("wage", self.config_module.LABOR_MARKET_MIN_WAGE)
+                    wage = emp_data.get(
+                        "wage", self.config_module.LABOR_MARKET_MIN_WAGE
+                    )
                     skill = emp_data.get("skill", 1.0)
 
                     adjusted_wage = wage * skill
                     severance_pay = adjusted_wage * severance_weeks
 
                     # Generate FIRE order
-                    orders.append(Order(
-                        firm.id,
-                        "FIRE",
-                        "internal",
-                        1,
-                        severance_pay,
-                        "internal",
-                        target_agent_id=emp_id
-                    ))
+                    orders.append(
+                        Order(
+                            firm.id,
+                            "FIRE",
+                            "internal",
+                            1,
+                            severance_pay,
+                            "internal",
+                            target_agent_id=emp_id,
+                        )
+                    )
 
                 return orders
 
         # B. Hiring Logic
         market_wage = self.config_module.LABOR_MARKET_MIN_WAGE
         if "labor" in market_data and "avg_wage" in market_data["labor"]:
-             market_wage = market_data["labor"]["avg_wage"]
+            market_wage = market_data["labor"]["avg_wage"]
 
         adjustment = -0.2 + (aggressiveness * 0.5)
         offer_wage = market_wage * (1.0 + adjustment)
@@ -441,24 +516,30 @@ class CorporateManager:
 
         # Competitive Bidding Logic (Simplified from original due to DTO access limits or replicate it?)
         # We can replicate `_adjust_wage_for_vacancies` using DTO data.
-        offer_wage = self._adjust_wage_for_vacancies(firm, offer_wage, needed_labor, market_data)
+        offer_wage = self._adjust_wage_for_vacancies(
+            firm, offer_wage, needed_labor, market_data
+        )
 
         to_hire = needed_labor - current_employees
         if to_hire > 0:
             for _ in range(to_hire):
-                 orders.append(
-                     Order(firm.id, "BUY", "labor", 1, offer_wage, "labor")
-                 )
+                orders.append(Order(firm.id, "BUY", "labor", 1, offer_wage, "labor"))
 
         return orders
 
-    def _adjust_wage_for_vacancies(self, firm: FirmStateDTO, base_offer_wage: float, needed_labor: int, market_data: Dict) -> float:
+    def _adjust_wage_for_vacancies(
+        self,
+        firm: FirmStateDTO,
+        base_offer_wage: float,
+        needed_labor: int,
+        market_data: Dict,
+    ) -> float:
         """
         WO-047-B: Competitive Bidding Logic (DTO version).
         """
         current_employees = len(firm.employees)
         vacancies = max(0, needed_labor - current_employees)
-        
+
         if vacancies <= 0:
             return base_offer_wage
 
@@ -474,14 +555,14 @@ class CorporateManager:
             solvency_ratio = firm.assets / total_liabilities
             if solvency_ratio < 1.5:
                 return base_offer_wage
-        
+
         # 2. Wage Bill Cap
         wage_bill = 0.0
         if firm.employees_data:
-            wage_bill = sum(e['wage'] for e in firm.employees_data.values())
+            wage_bill = sum(e["wage"] for e in firm.employees_data.values())
 
-        if wage_bill > 0 and firm.assets < wage_bill * 2: 
-             return base_offer_wage
+        if wage_bill > 0 and firm.assets < wage_bill * 2:
+            return base_offer_wage
 
         # 3. Calculate Increase
         increase_rate = min(0.05, 0.01 * vacancies)
diff --git a/simulation/decisions/housing_manager.py b/simulation/decisions/housing_manager.py
index e0c2111..ef2fe12 100644
--- a/simulation/decisions/housing_manager.py
+++ b/simulation/decisions/housing_manager.py
@@ -6,13 +6,16 @@ from simulation.models import Order
 if TYPE_CHECKING:
     from modules.household.dtos import HouseholdStateDTO
 
+
 class PurchaseIntent:
     """DTO for Mimicry Purchase decision"""
+
     def __init__(self, target="housing", max_ltv=0.8, priority="NORMAL"):
         self.target = target
         self.max_ltv = max_ltv
         self.priority = priority
 
+
 class HousingManager:
     """
     Phase 17-3B: Housing Manager
@@ -31,9 +34,11 @@ class HousingManager:
         """
         if agent.is_homeless or agent.residing_property_id is None:
             return 0.0
-        return 1.0 # Default Tier 1
+        return 1.0  # Default Tier 1
 
-    def decide_mimicry_purchase(self, reference_standard: Dict[str, float]) -> Optional[PurchaseIntent]:
+    def decide_mimicry_purchase(
+        self, reference_standard: Dict[str, float]
+    ) -> Optional[PurchaseIntent]:
         """
         Phase 17-4: Mimicry Consumption Logic.
         """
@@ -56,14 +61,16 @@ class HousingManager:
 
         # 3. Trigger Condition
         if urgency > 0.5:
-             return PurchaseIntent(
-                 target="housing",
-                 max_ltv=0.95, # Panic Buy: Max Leverage
-                 priority="URGENT"
-             )
+            return PurchaseIntent(
+                target="housing",
+                max_ltv=0.95,  # Panic Buy: Max Leverage
+                priority="URGENT",
+            )
         return None
 
-    def should_buy(self, property_value: float, rent_price: float, interest_rate: float = 0.05) -> bool:
+    def should_buy(
+        self, property_value: float, rent_price: float, interest_rate: float = 0.05
+    ) -> bool:
         """
         Determines whether to buy a property based on NPV calculation biased by personality.
         """
@@ -71,43 +78,49 @@ class HousingManager:
         horizon = 120
         discount_rate = 0.005
         maintenance_rate = self.config.MAINTENANCE_RATE_PER_TICK
-        
+
         # 2. Personality-Biased Parameters
-        
+
         # Optimism Bias
         base_appreciation = 0.002
-        perceived_appreciation_rate = base_appreciation * (0.5 + getattr(self.agent, 'optimism', 0.5))
-        
+        perceived_appreciation_rate = base_appreciation * (
+            0.5 + getattr(self.agent, "optimism", 0.5)
+        )
+
         # Ambition Bias
         prestige_bonus = 0.0
-        ambition = getattr(self.agent, 'ambition', 0.5)
+        ambition = getattr(self.agent, "ambition", 0.5)
         prestige_bonus = property_value * 0.1 * ambition
 
         # 3. NPV Calculation
         rent_npv = 0.0
         for t in range(horizon):
             rent_npv += rent_price / ((1 + discount_rate) ** t)
-            
+
         ltv = 0.8
         down_payment = property_value * (1 - ltv)
         loan_principal = property_value * ltv
-        
+
         monthly_rate = interest_rate / 12
         if monthly_rate > 0:
-            monthly_payment = loan_principal * (monthly_rate * (1 + monthly_rate) ** 360) / ((1 + monthly_rate) ** 360 - 1)
+            monthly_payment = (
+                loan_principal
+                * (monthly_rate * (1 + monthly_rate) ** 360)
+                / ((1 + monthly_rate) ** 360 - 1)
+            )
         else:
             monthly_payment = loan_principal / 360
-            
+
         buy_outflow_npv = down_payment
         for t in range(horizon):
             maintenance_cost = property_value * maintenance_rate
             total_monthly_cost = monthly_payment + maintenance_cost
             buy_outflow_npv += total_monthly_cost / ((1 + discount_rate) ** t)
-            
+
         future_value = property_value * ((1 + perceived_appreciation_rate) ** horizon)
         future_value_npv = future_value / ((1 + discount_rate) ** horizon)
-        
+
         # Net Cost of Buying (Cost - Asset Value - Prestige)
         net_buy_cost = buy_outflow_npv - future_value_npv - prestige_bonus
-        
+
         return net_buy_cost < rent_npv
diff --git a/simulation/decisions/portfolio_manager.py b/simulation/decisions/portfolio_manager.py
index 3dda426..672235c 100644
--- a/simulation/decisions/portfolio_manager.py
+++ b/simulation/decisions/portfolio_manager.py
@@ -2,6 +2,7 @@ from typing import Tuple, Dict
 import math
 from simulation.dtos import MacroFinancialContext
 
+
 class PortfolioManager:
     """
     Implements the Rational Investor brain (WO-026).
@@ -16,27 +17,43 @@ class PortfolioManager:
     TOTAL_STRESS_MULTIPLIER_CAP = 3.0
 
     @staticmethod
-    def calculate_effective_risk_aversion(base_lambda: float, context: MacroFinancialContext) -> float:
+    def calculate_effective_risk_aversion(
+        base_lambda: float, context: MacroFinancialContext
+    ) -> float:
         """
         Calculates an adjusted risk aversion based on the provided macroeconomic context.
         This logic is central to the WO-062 feature and now fully visible for review.
         """
         # 1. Inflation Stress (Fear increases when inflation exceeds the 2% target)
-        inflation_excess = max(0.0, context.inflation_rate - PortfolioManager.CONST_INFLATION_TARGET)
-        stress_inflation = inflation_excess * PortfolioManager.INFLATION_STRESS_MULTIPLIER
+        inflation_excess = max(
+            0.0, context.inflation_rate - PortfolioManager.CONST_INFLATION_TARGET
+        )
+        stress_inflation = (
+            inflation_excess * PortfolioManager.INFLATION_STRESS_MULTIPLIER
+        )
 
         # 2. Recession Stress (Fear increases sharply during negative growth)
         stress_recession = 0.0
         if context.gdp_growth_rate < 0.0:
-            stress_recession = abs(context.gdp_growth_rate) * PortfolioManager.RECESSION_STRESS_MULTIPLIER
+            stress_recession = (
+                abs(context.gdp_growth_rate)
+                * PortfolioManager.RECESSION_STRESS_MULTIPLIER
+            )
 
         # 3. Interest Rate Volatility (Optional)
-        stress_rate = max(0.0, context.interest_rate_trend) * PortfolioManager.INTEREST_RATE_STRESS_MULTIPLIER
+        stress_rate = (
+            max(0.0, context.interest_rate_trend)
+            * PortfolioManager.INTEREST_RATE_STRESS_MULTIPLIER
+        )
 
-        total_stress_multiplier = 1.0 + stress_inflation + stress_recession + stress_rate
+        total_stress_multiplier = (
+            1.0 + stress_inflation + stress_recession + stress_rate
+        )
 
         # Apply a cap to prevent overly extreme aversion
-        total_stress_multiplier = min(PortfolioManager.TOTAL_STRESS_MULTIPLIER_CAP, total_stress_multiplier)
+        total_stress_multiplier = min(
+            PortfolioManager.TOTAL_STRESS_MULTIPLIER_CAP, total_stress_multiplier
+        )
 
         return base_lambda * total_stress_multiplier
 
@@ -48,7 +65,7 @@ class PortfolioManager:
         equity_return_proxy: float,
         survival_cost: float,
         inflation_expectation: float,
-        macro_context: MacroFinancialContext = None
+        macro_context: MacroFinancialContext = None,
     ) -> Tuple[float, float, float]:
         """
         Calculates optimal allocation between Consumption(Cash), Risk-Free(Deposit), and Risky(Equity/Startup).
@@ -67,7 +84,11 @@ class PortfolioManager:
         """
         effective_risk_aversion = risk_aversion
         if macro_context:
-            effective_risk_aversion = PortfolioManager.calculate_effective_risk_aversion(risk_aversion, macro_context)
+            effective_risk_aversion = (
+                PortfolioManager.calculate_effective_risk_aversion(
+                    risk_aversion, macro_context
+                )
+            )
 
         # 1. Safety Margin Logic (Cash/Risk-Free)
         # "Safety Margin: 3 months of survival cost... MUST be kept in Cash/Risk-Free Deposit"
@@ -110,10 +131,10 @@ class PortfolioManager:
         # We need Assumptions for Risk (Variance):
         # Sigma_Deposit ~= 0.0 (Risk Free)
         # Sigma_Equity ~= 0.2 (20% Volatility - assumption)
-        sigma_equity_sq = 0.2 ** 2  # 0.04
+        sigma_equity_sq = 0.2**2  # 0.04
 
         # Expected Utility of Deposit
-        u_deposit = risk_free_rate # Variance is 0
+        u_deposit = risk_free_rate  # Variance is 0
 
         # Expected Utility of Equity
         # U_e = R_e - lambda * sigma^2
diff --git a/simulation/decisions/rule_based_firm_engine.py b/simulation/decisions/rule_based_firm_engine.py
index c0a6706..b5fe28d 100644
--- a/simulation/decisions/rule_based_firm_engine.py
+++ b/simulation/decisions/rule_based_firm_engine.py
@@ -36,7 +36,11 @@ class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
         )
 
     def _execute_tactic(
-        self, tactic: Tactic, firm: FirmStateDTO, current_tick: int, market_data: Dict[str, Any]
+        self,
+        tactic: Tactic,
+        firm: FirmStateDTO,
+        current_tick: int,
+        market_data: Dict[str, Any],
     ) -> List[Order]:
         """
         ì„ íƒëœ ì „ìˆ ì— ë”°ë¼ ì‹¤ì œ í–‰ë™(ì£¼ë¬¸ ìƒì„±)ì„ ìˆ˜í–‰í•œë‹¤.
@@ -100,7 +104,9 @@ class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
             )
 
         if new_target != target_quantity:
-            return [Order(firm.id, "SET_TARGET", "internal", new_target, 0.0, "internal")]
+            return [
+                Order(firm.id, "SET_TARGET", "internal", new_target, 0.0, "internal")
+            ]
 
         return []
 
@@ -154,7 +160,7 @@ class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
         current_inventory = firm.inventory.get(item_id, 0)
         needed_production = max(0, target_quantity - current_inventory)
         if firm.productivity_factor <= 0:
-            return 999999.0 # Impossible to produce without productivity
+            return 999999.0  # Impossible to produce without productivity
 
         needed_labor = needed_production / firm.productivity_factor
         return needed_labor
@@ -176,7 +182,9 @@ class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
 
         return self.config_module.BASE_WAGE * (1 + wage_premium)
 
-    def _fire_excess_labor(self, firm: FirmStateDTO, needed_labor: float) -> List[Order]:
+    def _fire_excess_labor(
+        self, firm: FirmStateDTO, needed_labor: float
+    ) -> List[Order]:
         """
         WO-110: Firing logic for Rule-Based Firms.
         Fires excess employees if current workforce exceeds needed labor (with tolerance).
@@ -214,19 +222,21 @@ class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
             severance_pay = wage * skill * severance_weeks
 
             # Create FIRE Order
-            orders.append(Order(
-                firm.id,
-                "FIRE",
-                "internal",
-                1,
-                severance_pay,
-                "internal",
-                target_agent_id=emp_id
-            ))
+            orders.append(
+                Order(
+                    firm.id,
+                    "FIRE",
+                    "internal",
+                    1,
+                    severance_pay,
+                    "internal",
+                    target_agent_id=emp_id,
+                )
+            )
 
             self.logger.info(
                 f"RuleBased Firing: Firm {firm.id} planning to fire Agent {emp_id}. Severance: {severance_pay:.2f}",
-                extra={"tick": 0, "agent_id": firm.id, "tags": ["firing"]}
+                extra={"tick": 0, "agent_id": firm.id, "tags": ["firing"]},
             )
 
         return orders
diff --git a/simulation/decisions/rule_based_household_engine.py b/simulation/decisions/rule_based_household_engine.py
index d7c987b..9a93cfe 100644
--- a/simulation/decisions/rule_based_household_engine.py
+++ b/simulation/decisions/rule_based_household_engine.py
@@ -42,7 +42,7 @@ class RuleBasedHouseholdDecisionEngine(BaseDecisionEngine):
         """
         state: HouseholdStateDTO = context.state
         config: HouseholdConfigDTO = context.config
-        
+
         markets = context.markets
         market_data = context.market_data
         current_time = context.current_time
@@ -54,31 +54,34 @@ class RuleBasedHouseholdDecisionEngine(BaseDecisionEngine):
         # Note: Wage modifier evolution (recovery/decay) moved to Household.make_decision
 
         # 1. ìƒì¡´ ìš•êµ¬ ì¶©ì¡± (ìŒì‹ êµ¬ë§¤)
-        if (
-            state.needs["survival"]
-            >= config.survival_need_consumption_threshold
-        ):
+        if state.needs["survival"] >= config.survival_need_consumption_threshold:
             food_item_id = "basic_food"
             food_in_inventory = state.inventory.get(food_item_id, 0.0)
             target_buffer = config.target_food_buffer_quantity
 
             if food_in_inventory < target_buffer:
                 chosen_tactic = Tactic.BUY_BASIC_FOOD
-                chosen_aggressiveness = Aggressiveness.AGGRESSIVE 
+                chosen_aggressiveness = Aggressiveness.AGGRESSIVE
 
                 needed_quantity = target_buffer - food_in_inventory
-                market_id = food_item_id 
+                market_id = food_item_id
                 market = markets.get(market_id)
 
                 best_ask = market.get_best_ask(item_id=food_item_id) if market else None
 
                 if best_ask is None or best_ask == 0:
-                    best_ask = getattr(self.config_module, "DEFAULT_FALLBACK_PRICE", 5.0)
+                    best_ask = getattr(
+                        self.config_module, "DEFAULT_FALLBACK_PRICE", 5.0
+                    )
 
                 if best_ask > 0:
                     affordable_quantity = state.assets / best_ask
-                    quantity_to_buy = min(needed_quantity, affordable_quantity, config.food_purchase_max_per_tick)
-                    
+                    quantity_to_buy = min(
+                        needed_quantity,
+                        affordable_quantity,
+                        config.food_purchase_max_per_tick,
+                    )
+
                     if quantity_to_buy > 0.1:
                         orders.append(
                             Order(
@@ -92,19 +95,29 @@ class RuleBasedHouseholdDecisionEngine(BaseDecisionEngine):
                         )
                         self.logger.info(
                             f"Household {state.id} buying {quantity_to_buy:.2f} {food_item_id} for survival at {best_ask:.2f}",
-                            extra={"tick": current_time, "agent_id": state.id, "tactic": chosen_tactic.name}
+                            extra={
+                                "tick": current_time,
+                                "agent_id": state.id,
+                                "tactic": chosen_tactic.name,
+                            },
                         )
 
         # 2. ë…¸ë™ ì‹œì¥ ì°¸ì—¬ (ì‹¤ì—… ìƒíƒœì¼ ê²½ìš°)
-        if not state.is_employed and state.assets < config.assets_threshold_for_other_actions:
+        if (
+            not state.is_employed
+            and state.assets < config.assets_threshold_for_other_actions
+        ):
             if chosen_tactic == Tactic.NO_ACTION:
                 chosen_tactic = Tactic.PARTICIPATE_LABOR_MARKET
                 chosen_aggressiveness = Aggressiveness.NEUTRAL
 
             # 2. Survival Trigger (Panic Mode)
             food_inventory = state.inventory.get("basic_food", 0.0)
-            food_price = market_data.get("goods_market", {}).get("basic_food_avg_traded_price", 10.0)
-            if food_price <= 0: food_price = 10.0
+            food_price = market_data.get("goods_market", {}).get(
+                "basic_food_avg_traded_price", 10.0
+            )
+            if food_price <= 0:
+                food_price = 10.0
 
             survival_days = food_inventory + (state.assets / food_price)
             critical_turns = config.survival_critical_turns
@@ -117,25 +130,39 @@ class RuleBasedHouseholdDecisionEngine(BaseDecisionEngine):
                 desired_wage = 0.0
                 self.logger.info(
                     f"PANIC_MODE_PURE | Household {state.id} desperate. Survival Days: {survival_days:.1f}. Wage: 0.0",
-                    extra={"tick": current_time, "agent_id": state.id, "tags": ["labor_panic"]}
+                    extra={
+                        "tick": current_time,
+                        "agent_id": state.id,
+                        "tags": ["labor_panic"],
+                    },
                 )
             else:
                 labor_market_info = market_data.get("goods_market", {}).get("labor", {})
-                market_avg_wage = labor_market_info.get("avg_wage", config.labor_market_min_wage)
+                market_avg_wage = labor_market_info.get(
+                    "avg_wage", config.labor_market_min_wage
+                )
                 desired_wage = market_avg_wage * state.wage_modifier
 
             labor_market_info = market_data.get("goods_market", {}).get("labor", {})
-            market_avg_wage = labor_market_info.get("avg_wage", config.labor_market_min_wage)
+            market_avg_wage = labor_market_info.get(
+                "avg_wage", config.labor_market_min_wage
+            )
             best_market_offer = labor_market_info.get("best_wage_offer", 0.0)
 
-            effective_offer = best_market_offer if best_market_offer > 0 else market_avg_wage
+            effective_offer = (
+                best_market_offer if best_market_offer > 0 else market_avg_wage
+            )
             wage_floor = desired_wage
 
             if not is_panic and effective_offer < wage_floor:
                 self.logger.info(
                     f"RESERVATION_WAGE_PURE | Household {state.id} refused labor. "
                     f"Offer: {effective_offer:.2f} < Floor: {wage_floor:.2f}",
-                    extra={"tick": current_time, "agent_id": state.id, "tags": ["labor_refusal"]}
+                    extra={
+                        "tick": current_time,
+                        "agent_id": state.id,
+                        "tags": ["labor_refusal"],
+                    },
                 )
             else:
                 orders.append(
@@ -150,7 +177,11 @@ class RuleBasedHouseholdDecisionEngine(BaseDecisionEngine):
                 )
                 self.logger.info(
                     f"Household {state.id} offers labor at wage {desired_wage:.2f}",
-                    extra={"tick": current_time, "agent_id": state.id, "tactic": chosen_tactic.name}
+                    extra={
+                        "tick": current_time,
+                        "agent_id": state.id,
+                        "tactic": chosen_tactic.name,
+                    },
                 )
 
         return orders, (chosen_tactic, chosen_aggressiveness)
diff --git a/simulation/decisions/standalone_rule_based_firm_engine.py b/simulation/decisions/standalone_rule_based_firm_engine.py
index f4ceb61..6bd356e 100644
--- a/simulation/decisions/standalone_rule_based_firm_engine.py
+++ b/simulation/decisions/standalone_rule_based_firm_engine.py
@@ -29,7 +29,9 @@ class StandaloneRuleBasedFirmDecisionEngine(BaseDecisionEngine):
     ) -> None:
         self.config_module = config_module
         self.logger = logger if logger else logging.getLogger(__name__)
-        self.rule_based_executor = RuleBasedFirmDecisionEngine(config_module, self.logger)
+        self.rule_based_executor = RuleBasedFirmDecisionEngine(
+            config_module, self.logger
+        )
         self.logger.info(
             "StandaloneRuleBasedFirmDecisionEngine initialized.",
             extra={"tick": 0, "tags": ["init"]},
@@ -43,7 +45,7 @@ class StandaloneRuleBasedFirmDecisionEngine(BaseDecisionEngine):
         ê·œì¹™ ê¸°ë°˜ ë¡œì§ì„ ì‚¬ìš©í•˜ì—¬ ê¸°ì—…ì˜ ì˜ì‚¬ê²°ì •ì„ ìˆ˜í–‰í•œë‹¤.
         ìƒì‚° ì¡°ì •, ì„ê¸ˆ ì¡°ì •, ê°€ê²© ì¡°ì •ì— ì§‘ì¤‘í•œë‹¤.
         """
-        firm = context.state # FirmStateDTO
+        firm = context.state  # FirmStateDTO
         markets = context.markets
         goods_data = context.goods_data
         market_data = context.market_data
@@ -59,7 +61,9 @@ class StandaloneRuleBasedFirmDecisionEngine(BaseDecisionEngine):
 
         orders: List[Order] = []
         chosen_tactic: Tactic = Tactic.NO_ACTION
-        chosen_aggressiveness: Aggressiveness = Aggressiveness.NEUTRAL # ê·œì¹™ ê¸°ë°˜ì€ ì¤‘ë¦½ìœ¼ë¡œ ì„¤ì •
+        chosen_aggressiveness: Aggressiveness = (
+            Aggressiveness.NEUTRAL
+        )  # ê·œì¹™ ê¸°ë°˜ì€ ì¤‘ë¦½ìœ¼ë¡œ ì„¤ì •
 
         item_id = firm.specialization
         current_inventory = firm.inventory.get(item_id, 0)
@@ -68,68 +72,113 @@ class StandaloneRuleBasedFirmDecisionEngine(BaseDecisionEngine):
         # 1. ìƒì‚° ì¡°ì • ê²°ì • (Planning)
         if current_inventory > target_quantity * self.config_module.OVERSTOCK_THRESHOLD:
             chosen_tactic = Tactic.ADJUST_PRODUCTION
-            prod_orders = self.rule_based_executor._adjust_production(firm, current_time)
+            prod_orders = self.rule_based_executor._adjust_production(
+                firm, current_time
+            )
             orders.extend(prod_orders)
             self.logger.info(
                 f"Firm {firm.id} RuleBased: Overstocked, adjusting production.",
-                extra={"tick": current_time, "agent_id": firm.id, "tactic": Tactic.ADJUST_PRODUCTION.name}
+                extra={
+                    "tick": current_time,
+                    "agent_id": firm.id,
+                    "tactic": Tactic.ADJUST_PRODUCTION.name,
+                },
             )
-        elif current_inventory < target_quantity * self.config_module.UNDERSTOCK_THRESHOLD:
+        elif (
+            current_inventory
+            < target_quantity * self.config_module.UNDERSTOCK_THRESHOLD
+        ):
             chosen_tactic = Tactic.ADJUST_PRODUCTION
-            prod_orders = self.rule_based_executor._adjust_production(firm, current_time)
+            prod_orders = self.rule_based_executor._adjust_production(
+                firm, current_time
+            )
             orders.extend(prod_orders)
             self.logger.info(
                 f"Firm {firm.id} RuleBased: Understocked, adjusting production.",
-                extra={"tick": current_time, "agent_id": firm.id, "tactic": Tactic.ADJUST_PRODUCTION.name}
+                extra={
+                    "tick": current_time,
+                    "agent_id": firm.id,
+                    "tactic": Tactic.ADJUST_PRODUCTION.name,
+                },
             )
 
         # 2. ì„ê¸ˆ ì¡°ì • ë° ê³ ìš© ê²°ì • (Operation)
         # WO-110: Sequential execution - Check labor needs even if production was adjusted
-        needed_labor_for_production = self.rule_based_executor._calculate_needed_labor(firm)
+        needed_labor_for_production = self.rule_based_executor._calculate_needed_labor(
+            firm
+        )
         current_employees = len(firm.employees)
 
         # Hiring Logic
-        if current_employees < needed_labor_for_production * self.config_module.FIRM_LABOR_REQUIREMENT_RATIO or \
-           current_employees < self.config_module.FIRM_MIN_EMPLOYEES:
-
+        if (
+            current_employees
+            < needed_labor_for_production
+            * self.config_module.FIRM_LABOR_REQUIREMENT_RATIO
+            or current_employees < self.config_module.FIRM_MIN_EMPLOYEES
+        ):
             if chosen_tactic == Tactic.NO_ACTION:
                 chosen_tactic = Tactic.ADJUST_WAGES
 
-            hiring_orders = self.rule_based_executor._adjust_wages(firm, current_time, market_data)
+            hiring_orders = self.rule_based_executor._adjust_wages(
+                firm, current_time, market_data
+            )
             orders.extend(hiring_orders)
             self.logger.info(
                 f"Firm {firm.id} RuleBased: Need more labor, adjusting wages/hiring.",
-                extra={"tick": current_time, "agent_id": firm.id, "tactic": Tactic.ADJUST_WAGES.name}
+                extra={
+                    "tick": current_time,
+                    "agent_id": firm.id,
+                    "tactic": Tactic.ADJUST_WAGES.name,
+                },
             )
 
         # Firing Logic (WO-110)
-        firing_buffer_ratio = getattr(self.config_module, "LABOR_FIRING_BUFFER_RATIO", 1.05)
+        firing_buffer_ratio = getattr(
+            self.config_module, "LABOR_FIRING_BUFFER_RATIO", 1.05
+        )
         if current_employees > needed_labor_for_production * firing_buffer_ratio:
-             loss_threshold = getattr(self.config_module, "LABOR_HOARDING_LOSS_THRESHOLD", 5)
-             is_bleeding = firm.consecutive_loss_turns > loss_threshold
-
-             startup_cost = getattr(self.config_module, "STARTUP_COST", 30000.0)
-             asset_ratio_threshold = getattr(self.config_module, "LABOR_HOARDING_ASSET_RATIO", 0.5)
-             is_poor = firm.assets < startup_cost * asset_ratio_threshold
-
-             if is_bleeding or is_poor:
-                 # Fire excess
-                 firing_orders = self.rule_based_executor._fire_excess_labor(firm, needed_labor_for_production)
-                 orders.extend(firing_orders)
-                 self.logger.info(
+            loss_threshold = getattr(
+                self.config_module, "LABOR_HOARDING_LOSS_THRESHOLD", 5
+            )
+            is_bleeding = firm.consecutive_loss_turns > loss_threshold
+
+            startup_cost = getattr(self.config_module, "STARTUP_COST", 30000.0)
+            asset_ratio_threshold = getattr(
+                self.config_module, "LABOR_HOARDING_ASSET_RATIO", 0.5
+            )
+            is_poor = firm.assets < startup_cost * asset_ratio_threshold
+
+            if is_bleeding or is_poor:
+                # Fire excess
+                firing_orders = self.rule_based_executor._fire_excess_labor(
+                    firm, needed_labor_for_production
+                )
+                orders.extend(firing_orders)
+                self.logger.info(
                     f"Firm {firm.id} RuleBased: Excess labor ({current_employees} > {needed_labor_for_production:.1f}), firing due to financial pressure.",
-                    extra={"tick": current_time, "agent_id": firm.id, "tactic": "FIRING"}
+                    extra={
+                        "tick": current_time,
+                        "agent_id": firm.id,
+                        "tactic": "FIRING",
+                    },
                 )
-             else:
-                 self.logger.info(
+            else:
+                self.logger.info(
                     f"Firm {firm.id} RuleBased: Excess labor ({current_employees} > {needed_labor_for_production:.1f}), but hoarding labor.",
-                    extra={"tick": current_time, "agent_id": firm.id, "tactic": "HOARDING"}
+                    extra={
+                        "tick": current_time,
+                        "agent_id": firm.id,
+                        "tactic": "HOARDING",
+                    },
                 )
 
         # 3. ê°€ê²© ì¡°ì • ë° íŒë§¤ (Commerce)
         if current_inventory > 0:
             if chosen_tactic == Tactic.NO_ACTION:
-                if current_inventory > firm.production_target * self.config_module.OVERSTOCK_THRESHOLD:
+                if (
+                    current_inventory
+                    > firm.production_target * self.config_module.OVERSTOCK_THRESHOLD
+                ):
                     chosen_tactic = Tactic.PRICE_DECREASE_SMALL
                 else:
                     chosen_tactic = Tactic.PRICE_HOLD
@@ -138,12 +187,18 @@ class StandaloneRuleBasedFirmDecisionEngine(BaseDecisionEngine):
             orders.extend(pricing_orders)
             self.logger.info(
                 f"Firm {firm.id} RuleBased: Adjusting price and selling.",
-                extra={"tick": current_time, "agent_id": firm.id, "tactic": Tactic.ADJUST_PRICE.name}
+                extra={
+                    "tick": current_time,
+                    "agent_id": firm.id,
+                    "tactic": Tactic.ADJUST_PRICE.name,
+                },
             )
 
         return orders, (chosen_tactic, chosen_aggressiveness)
-    
-    def _adjust_price_based_on_inventory(self, firm: FirmStateDTO, current_tick: int) -> List[Order]:
+
+    def _adjust_price_based_on_inventory(
+        self, firm: FirmStateDTO, current_tick: int
+    ) -> List[Order]:
         """
         ì¬ê³  ìˆ˜ì¤€ì— ë”°ë¼ íŒë§¤ ê°€ê²©ì„ ì¡°ì •í•˜ê³  íŒë§¤ ì£¼ë¬¸ì„ ìƒì„±í•œë‹¤.
         """
@@ -165,24 +220,34 @@ class StandaloneRuleBasedFirmDecisionEngine(BaseDecisionEngine):
 
             adjusted_price = base_price
             if target_inventory > 0:
-                diff_ratio = (
-                    current_inventory - target_inventory
-                ) / target_inventory
-                
-                price_multiplier = getattr(self.config_module, "GENESIS_PRICE_ADJUSTMENT_MULTIPLIER", 1.0)
-                
-                if current_inventory > 2 * target_inventory * self.config_module.OVERSTOCK_THRESHOLD:
-                    adjusted_price = min(base_price * 0.5, self.config_module.GOODS[item_id]["production_cost"] * 0.5)
+                diff_ratio = (current_inventory - target_inventory) / target_inventory
+
+                price_multiplier = getattr(
+                    self.config_module, "GENESIS_PRICE_ADJUSTMENT_MULTIPLIER", 1.0
+                )
+
+                if (
+                    current_inventory
+                    > 2 * target_inventory * self.config_module.OVERSTOCK_THRESHOLD
+                ):
+                    adjusted_price = min(
+                        base_price * 0.5,
+                        self.config_module.GOODS[item_id]["production_cost"] * 0.5,
+                    )
                     self.logger.warning(
                         f"EMERGENCY_FIRE_SALE | Firm {firm.id} is severely overstocked ({current_inventory:.1f}). Force-cutting price to {adjusted_price:.2f}",
-                        extra={"tick": current_tick, "agent_id": firm.id}
+                        extra={"tick": current_tick, "agent_id": firm.id},
                     )
                 else:
                     signed_power = (
                         abs(diff_ratio) ** self.config_module.PRICE_ADJUSTMENT_EXPONENT
                     )
-                    adjustment = signed_power * self.config_module.PRICE_ADJUSTMENT_FACTOR * price_multiplier
-                    
+                    adjustment = (
+                        signed_power
+                        * self.config_module.PRICE_ADJUSTMENT_FACTOR
+                        * price_multiplier
+                    )
+
                     if diff_ratio < 0:
                         adjusted_price = base_price * (1 + adjustment)
                     else:
@@ -194,7 +259,9 @@ class StandaloneRuleBasedFirmDecisionEngine(BaseDecisionEngine):
             )
 
             # 1. Update Internal Price
-            orders.append(Order(firm.id, "SET_PRICE", item_id, final_price, 0.0, "internal"))
+            orders.append(
+                Order(firm.id, "SET_PRICE", item_id, final_price, 0.0, "internal")
+            )
 
             # 2. Sell Order
             quantity_to_sell = min(
diff --git a/simulation/dtos/api.py b/simulation/dtos/api.py
index 3c36bfe..9661c67 100644
--- a/simulation/dtos/api.py
+++ b/simulation/dtos/api.py
@@ -9,6 +9,7 @@ if TYPE_CHECKING:
     from simulation.dtos.scenario import StressScenarioConfig
     from modules.household.dtos import HouseholdStateDTO
 
+
 @dataclass
 class TransactionData:
     run_id: int
@@ -21,6 +22,7 @@ class TransactionData:
     market_id: str
     transaction_type: str
 
+
 @dataclass
 class AgentStateData:
     run_id: int
@@ -42,6 +44,7 @@ class AgentStateData:
     time_worked: Optional[float] = None
     time_leisure: Optional[float] = None
 
+
 @dataclass
 class EconomicIndicatorData:
     run_id: int
@@ -66,6 +69,7 @@ class EconomicIndicatorData:
     education_coverage: Optional[float] = None
     brain_waste_count: Optional[int] = None
 
+
 @dataclass
 class MarketHistoryData:
     time: int
@@ -80,6 +84,7 @@ class MarketHistoryData:
     worst_ask: Optional[float] = None
     worst_bid: Optional[float] = None
 
+
 @dataclass
 class AIDecisionData:
     run_id: int
@@ -90,9 +95,11 @@ class AIDecisionData:
     predicted_reward: Optional[float] = None
     actual_reward: Optional[float] = None
 
+
 @dataclass
 class HouseholdConfigDTO:
     """Static configuration values relevant to household decisions."""
+
     survival_need_consumption_threshold: float
     target_food_buffer_quantity: float
     food_purchase_max_per_tick: float
@@ -105,7 +112,7 @@ class HouseholdConfigDTO:
     household_low_asset_threshold: float
     household_low_asset_wage: float
     household_default_wage: float
-    
+
     # AI Engine requirements
     market_price_fallback: float
     need_factor_base: float
@@ -140,32 +147,36 @@ class HouseholdConfigDTO:
     # Added for parity
     initial_rent_price: float
 
+
 @dataclass
 class FirmConfigDTO:
     """Static configuration values relevant to firm decisions."""
+
     firm_min_production_target: float
     # Add other firm config values as needed for engines
 
+
 @dataclass
 class DecisionContext:
     """
     A pure data container for decision-making.
     Direct agent instance access is strictly forbidden (Enforced by Purity Gate).
     """
+
     markets: Dict[str, Any]
     goods_data: List[Dict[str, Any]]
     market_data: Dict[str, Any]
     current_time: int
-    
+
     # State DTO representing the agent's current condition
     state: Union[HouseholdStateDTO, FirmStateDTO]
-    
+
     # Static configuration values relevant to the agent type
     config: Union[HouseholdConfigDTO, FirmConfigDTO]
 
     government: Optional[Any] = None
-    reflux_system: Optional[Any] = None # Phase 8-B: Reflux System
-    stress_scenario_config: Optional[StressScenarioConfig] = None # Phase 28
+    reflux_system: Optional[Any] = None  # Phase 8-B: Reflux System
+    stress_scenario_config: Optional[StressScenarioConfig] = None  # Phase 28
 
 
 @dataclass
@@ -174,28 +185,29 @@ class SimulationState:
     WO-103: Simulation State DTO to reduce coupling.
     Passes all necessary data from the Simulation object to system services.
     """
+
     time: int
     households: List[Household]
     firms: List[Firm]
     agents: Dict[int, Any]
     markets: Dict[str, Any]
     government: Any  # Government
-    bank: Any        # Bank
-    central_bank: Any # CentralBank
-    stock_market: Optional[Any] # StockMarket
+    bank: Any  # Bank
+    central_bank: Any  # CentralBank
+    stock_market: Optional[Any]  # StockMarket
     goods_data: Dict[str, Any]
-    market_data: Dict[str, Any] # Added for WO-103
+    market_data: Dict[str, Any]  # Added for WO-103
     config_module: Any
     tracker: Any
-    logger: Any # logging.Logger
+    logger: Any  # logging.Logger
     reflux_system: Any
     ai_training_manager: Optional[Any]
-    ai_trainer: Optional[Any] # Added for WO-103
-    settlement_system: Optional[Any] = None # WO-112: Settlement System
-    next_agent_id: int = 0 # Added for WO-103
-    real_estate_units: List[Any] = field(default_factory=list) # Added for WO-103
+    ai_trainer: Optional[Any]  # Added for WO-103
+    settlement_system: Optional[Any] = None  # WO-112: Settlement System
+    next_agent_id: int = 0  # Added for WO-103
+    real_estate_units: List[Any] = field(default_factory=list)  # Added for WO-103
     # Mutable state for the tick
-    transactions: List[Any] = None # List[Transaction]
+    transactions: List[Any] = None  # List[Transaction]
 
     def __post_init__(self):
         if self.transactions is None:
@@ -206,129 +218,137 @@ class SimulationState:
 # ì£¼ì‹ ì‹œì¥ ë° ê²½ì œ ë¶„ì„ DTO
 # ------------------------------------------------------------------------------
 
+
 @dataclass
 class StockMarketHistoryData:
     """ì£¼ì‹ ì‹œì¥ í‹±ë³„ ì´ë ¥ (ê¸°ì—…ë³„)"""
+
     run_id: int
     time: int
     firm_id: int
-    
+
     # ì£¼ê°€ ê´€ë ¨
-    stock_price: float              # í˜„ì¬ ì£¼ê°€ (ê±°ë˜ê°€ ë˜ëŠ” ê¸°ì¤€ê°€)
-    book_value_per_share: float     # ì£¼ë‹¹ ìˆœìì‚°ê°€ì¹˜ (BPS)
-    price_to_book_ratio: float      # PBR (ì£¼ê°€/BPS)
-    
+    stock_price: float  # í˜„ì¬ ì£¼ê°€ (ê±°ë˜ê°€ ë˜ëŠ” ê¸°ì¤€ê°€)
+    book_value_per_share: float  # ì£¼ë‹¹ ìˆœìì‚°ê°€ì¹˜ (BPS)
+    price_to_book_ratio: float  # PBR (ì£¼ê°€/BPS)
+
     # ê±°ë˜ ê´€ë ¨
-    trade_volume: float             # ê±°ë˜ëŸ‰
-    buy_order_count: int            # ë§¤ìˆ˜ ì£¼ë¬¸ ìˆ˜
-    sell_order_count: int           # ë§¤ë„ ì£¼ë¬¸ ìˆ˜
-    
+    trade_volume: float  # ê±°ë˜ëŸ‰
+    buy_order_count: int  # ë§¤ìˆ˜ ì£¼ë¬¸ ìˆ˜
+    sell_order_count: int  # ë§¤ë„ ì£¼ë¬¸ ìˆ˜
+
     # ê¸°ì—… ì‹¤ì  ì—°ê³„
-    firm_assets: float              # ê¸°ì—… ì´ìì‚°
-    firm_profit: float              # ê¸°ì—… ì´ìµ (ë‹¹ê¸°)
-    dividend_paid: float            # ë°°ë‹¹ê¸ˆ ì§€ê¸‰ì•¡
-    market_cap: float               # ì‹œê°€ì´ì•¡
+    firm_assets: float  # ê¸°ì—… ì´ìì‚°
+    firm_profit: float  # ê¸°ì—… ì´ìµ (ë‹¹ê¸°)
+    dividend_paid: float  # ë°°ë‹¹ê¸ˆ ì§€ê¸‰ì•¡
+    market_cap: float  # ì‹œê°€ì´ì•¡
 
 
 @dataclass
 class WealthDistributionData:
     """ë¶€ì˜ ë¶„ë°° ì§€í‘œ (í‹±ë³„)"""
+
     run_id: int
     time: int
-    
+
     # ìì‚° ë¶„ë°° (ì§€ë‹ˆê³„ìˆ˜)
-    gini_total_assets: float        # ì´ìì‚° ì§€ë‹ˆê³„ìˆ˜
-    gini_financial_assets: float    # ê¸ˆìœµìì‚° ì§€ë‹ˆê³„ìˆ˜ (í˜„ê¸ˆ + ì£¼ì‹)
-    gini_stock_holdings: float      # ì£¼ì‹ ë³´ìœ  ì§€ë‹ˆê³„ìˆ˜
-    
+    gini_total_assets: float  # ì´ìì‚° ì§€ë‹ˆê³„ìˆ˜
+    gini_financial_assets: float  # ê¸ˆìœµìì‚° ì§€ë‹ˆê³„ìˆ˜ (í˜„ê¸ˆ + ì£¼ì‹)
+    gini_stock_holdings: float  # ì£¼ì‹ ë³´ìœ  ì§€ë‹ˆê³„ìˆ˜
+
     # ì†Œë“ ë¶„ë°°
-    labor_income_share: float       # ë…¸ë™ì†Œë“ ë¹„ìœ¨ (ë…¸ë™ì†Œë“ / ì´ì†Œë“)
-    capital_income_share: float     # ìë³¸ì†Œë“ ë¹„ìœ¨ (ë°°ë‹¹ + ì£¼ì‹ì°¨ìµ / ì´ì†Œë“)
-    
+    labor_income_share: float  # ë…¸ë™ì†Œë“ ë¹„ìœ¨ (ë…¸ë™ì†Œë“ / ì´ì†Œë“)
+    capital_income_share: float  # ìë³¸ì†Œë“ ë¹„ìœ¨ (ë°°ë‹¹ + ì£¼ì‹ì°¨ìµ / ì´ì†Œë“)
+
     # ë¶„ìœ„ë³„ ìì‚°
     top_10_pct_wealth_share: float  # ìƒìœ„ 10% ìì‚° ì ìœ ìœ¨
-    bottom_50_pct_wealth_share: float # í•˜ìœ„ 50% ìì‚° ì ìœ ìœ¨
-    
+    bottom_50_pct_wealth_share: float  # í•˜ìœ„ 50% ìì‚° ì ìœ ìœ¨
+
     # í‰ê· /ì¤‘ìœ„ ë¹„êµ
     mean_household_assets: float
     median_household_assets: float
-    mean_to_median_ratio: float     # ë¶ˆí‰ë“± ì§€í‘œ (>1ì´ë©´ ë¶ˆí‰ë“±)
+    mean_to_median_ratio: float  # ë¶ˆí‰ë“± ì§€í‘œ (>1ì´ë©´ ë¶ˆí‰ë“±)
 
 
 @dataclass
 class HouseholdIncomeData:
     """ê°€ê³„ë³„ ì†Œë“ ì›ì²œ ì¶”ì """
+
     run_id: int
     time: int
     household_id: int
-    
-    labor_income: float             # ë…¸ë™ ì†Œë“ (ì„ê¸ˆ)
-    dividend_income: float          # ë°°ë‹¹ ì†Œë“
-    capital_gains: float            # ì£¼ì‹ ë§¤ë§¤ ì°¨ìµ
-    total_income: float             # ì´ ì†Œë“
-    
-    portfolio_value: float          # í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜
-    portfolio_return_rate: float    # íˆ¬ì ìˆ˜ìµë¥ 
+
+    labor_income: float  # ë…¸ë™ ì†Œë“ (ì„ê¸ˆ)
+    dividend_income: float  # ë°°ë‹¹ ì†Œë“
+    capital_gains: float  # ì£¼ì‹ ë§¤ë§¤ ì°¨ìµ
+    total_income: float  # ì´ ì†Œë“
+
+    portfolio_value: float  # í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜
+    portfolio_return_rate: float  # íˆ¬ì ìˆ˜ìµë¥ 
 
 
 @dataclass
 class SocialMobilityData:
     """ê³„ì¸µ ì´ë™ ì§€í‘œ (í‹±ë³„)"""
+
     run_id: int
     time: int
-    
+
     # ê³„ì¸µ êµ¬ë¶„ (ìì‚° ê¸°ì¤€ 5ë¶„ìœ„)
-    quintile_1_count: int           # 1ë¶„ìœ„ (í•˜ìœ„ 20%) ê°€ê³„ ìˆ˜
-    quintile_2_count: int           # 2ë¶„ìœ„ ê°€ê³„ ìˆ˜
-    quintile_3_count: int           # 3ë¶„ìœ„ ê°€ê³„ ìˆ˜
-    quintile_4_count: int           # 4ë¶„ìœ„ ê°€ê³„ ìˆ˜
-    quintile_5_count: int           # 5ë¶„ìœ„ (ìƒìœ„ 20%) ê°€ê³„ ìˆ˜
-    
+    quintile_1_count: int  # 1ë¶„ìœ„ (í•˜ìœ„ 20%) ê°€ê³„ ìˆ˜
+    quintile_2_count: int  # 2ë¶„ìœ„ ê°€ê³„ ìˆ˜
+    quintile_3_count: int  # 3ë¶„ìœ„ ê°€ê³„ ìˆ˜
+    quintile_4_count: int  # 4ë¶„ìœ„ ê°€ê³„ ìˆ˜
+    quintile_5_count: int  # 5ë¶„ìœ„ (ìƒìœ„ 20%) ê°€ê³„ ìˆ˜
+
     # ê³„ì¸µ ì´ë™ (ì´ì „ í‹± ëŒ€ë¹„)
-    upward_mobility_count: int      # ìƒí–¥ ì´ë™ ê°€ê³„ ìˆ˜
-    downward_mobility_count: int    # í•˜í–¥ ì´ë™ ê°€ê³„ ìˆ˜
-    stable_count: int               # ìœ ì§€ ê°€ê³„ ìˆ˜
-    
+    upward_mobility_count: int  # ìƒí–¥ ì´ë™ ê°€ê³„ ìˆ˜
+    downward_mobility_count: int  # í•˜í–¥ ì´ë™ ê°€ê³„ ìˆ˜
+    stable_count: int  # ìœ ì§€ ê°€ê³„ ìˆ˜
+
     # ë¶„ìœ„ë³„ í‰ê·  ìì‚°
     quintile_1_avg_assets: float
     quintile_2_avg_assets: float
     quintile_3_avg_assets: float
     quintile_4_avg_assets: float
     quintile_5_avg_assets: float
-    
+
     # ê³„ì¸µ ê³ ì°©ë„ (ë™ì¼ ë¶„ìœ„ ìœ ì§€ ë¹„ìœ¨)
-    mobility_index: float           # ì´ë™ì„± ì§€ìˆ˜ (0~1, ë†’ì„ìˆ˜ë¡ ìœ ë™ì )
+    mobility_index: float  # ì´ë™ì„± ì§€ìˆ˜ (0~1, ë†’ì„ìˆ˜ë¡ ìœ ë™ì )
 
 
 @dataclass
 class PersonalityStatisticsData:
     """ì„±í–¥ë³„ í†µê³„ (í‹±ë³„)"""
+
     run_id: int
     time: int
-    personality_type: str           # "MISER", "STATUS_SEEKER", "GROWTH_ORIENTED"
-    
+    personality_type: str  # "MISER", "STATUS_SEEKER", "GROWTH_ORIENTED"
+
     # ê¸°ë³¸ í†µê³„
-    count: int                      # í•´ë‹¹ ì„±í–¥ ê°€ê³„ ìˆ˜
-    avg_assets: float               # í‰ê·  ìì‚°
-    median_assets: float            # ì¤‘ìœ„ ìì‚°
-    
+    count: int  # í•´ë‹¹ ì„±í–¥ ê°€ê³„ ìˆ˜
+    avg_assets: float  # í‰ê·  ìì‚°
+    median_assets: float  # ì¤‘ìœ„ ìì‚°
+
     # ì†Œë“ êµ¬ì¡°
-    avg_labor_income: float         # í‰ê·  ë…¸ë™ ì†Œë“
-    avg_capital_income: float       # í‰ê·  ìë³¸ ì†Œë“ (ë°°ë‹¹ + ì°¨ìµ)
-    labor_income_ratio: float       # ë…¸ë™ì†Œë“ ë¹„ìœ¨
-    
+    avg_labor_income: float  # í‰ê·  ë…¸ë™ ì†Œë“
+    avg_capital_income: float  # í‰ê·  ìë³¸ ì†Œë“ (ë°°ë‹¹ + ì°¨ìµ)
+    labor_income_ratio: float  # ë…¸ë™ì†Œë“ ë¹„ìœ¨
+
     # ê³ ìš© ë° íˆ¬ì
-    employment_rate: float          # ê³ ìš©ë¥ 
-    avg_portfolio_value: float      # í‰ê·  í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜
-    avg_stock_holdings: float       # í‰ê·  ì£¼ì‹ ë³´ìœ ëŸ‰
-    
+    employment_rate: float  # ê³ ìš©ë¥ 
+    avg_portfolio_value: float  # í‰ê·  í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜
+    avg_stock_holdings: float  # í‰ê·  ì£¼ì‹ ë³´ìœ ëŸ‰
+
     # ìš•êµ¬ ì¶©ì¡±
-    avg_survival_need: float        # í‰ê·  ìƒì¡´ ìš•êµ¬
-    avg_social_need: float          # í‰ê·  ì‚¬íšŒì  ìš•êµ¬
-    avg_improvement_need: float     # í‰ê·  ì„±ì¥ ìš•êµ¬
-    
+    avg_survival_need: float  # í‰ê·  ìƒì¡´ ìš•êµ¬
+    avg_social_need: float  # í‰ê·  ì‚¬íšŒì  ìš•êµ¬
+    avg_improvement_need: float  # í‰ê·  ì„±ì¥ ìš•êµ¬
+
     # ì„±ê³¼ ì§€í‘œ
-    avg_wealth_growth_rate: float   # í‰ê·  ìì‚° ì¦ê°€ìœ¨
+    avg_wealth_growth_rate: float  # í‰ê·  ìì‚° ì¦ê°€ìœ¨
+
+
 @dataclass
 class DashboardGlobalIndicatorsDTO:
     death_rate: float
@@ -342,36 +362,40 @@ class DashboardGlobalIndicatorsDTO:
     avg_leisure_hours: float
     parenting_rate: float
 
+
 @dataclass
 class GenerationStatDTO:
     gen: int
     count: int
     avg_assets: float
 
+
 @dataclass
 class SocietyTabDataDTO:
     generations: List[GenerationStatDTO]
     mitosis_cost: float
-    unemployment_pie: Dict[str, int] # e.g., {"struggling": 80, "voluntary": 20}
+    unemployment_pie: Dict[str, int]  # e.g., {"struggling": 80, "voluntary": 20}
     # Phase 5 Additions
-    time_allocation: Dict[str, float] # e.g., {"WORK": 100, "PARENTING": 20}
+    time_allocation: Dict[str, float]  # e.g., {"WORK": 100, "PARENTING": 20}
     avg_leisure_hours: float
     # Phase 23: Opportunity Index
     avg_education_level: float
     brain_waste_count: int
 
+
 @dataclass
 class GovernmentTabDataDTO:
-    tax_revenue: Dict[str, float] # Cumulative total
+    tax_revenue: Dict[str, float]  # Cumulative total
     fiscal_balance: Dict[str, float]
     # Phase 5 Additions
-    tax_revenue_history: List[Dict[str, Any]] # Last 50 ticks breakdown
+    tax_revenue_history: List[Dict[str, Any]]  # Last 50 ticks breakdown
     welfare_spending: float
     current_avg_tax_rate: float
-    welfare_history: List[Dict[str, float]] # Last 50 ticks spending
+    welfare_history: List[Dict[str, float]]  # Last 50 ticks spending
     # Phase 23: Education Spending
     education_spending: float
-    education_history: List[Dict[str, float]] # Last 50 ticks spending
+    education_history: List[Dict[str, float]]  # Last 50 ticks spending
+
 
 @dataclass
 class MarketTabDataDTO:
@@ -379,6 +403,7 @@ class MarketTabDataDTO:
     cpi: List[float]
     maslow_fulfillment: List[float]
 
+
 @dataclass
 class FinanceTabDataDTO:
     market_cap: float
@@ -386,11 +411,12 @@ class FinanceTabDataDTO:
     turnover: float
     dividend_yield: float
 
+
 @dataclass
 class DashboardSnapshotDTO:
     tick: int
     global_indicators: DashboardGlobalIndicatorsDTO
-    tabs: Dict[str, Any] # Or specific classes for each tab
+    tabs: Dict[str, Any]  # Or specific classes for each tab
 
 
 # ==============================================================================
@@ -400,9 +426,11 @@ from typing import Literal
 
 LeisureType = Literal["PARENTING", "SELF_DEV", "ENTERTAINMENT", "IDLE"]
 
+
 @dataclass
 class TimeBudgetDTO:
     """í•œ í‹±(24ì‹œê°„) ë™ì•ˆì˜ ì‹œê°„ ë°°ë¶„ ê²°ê³¼"""
+
     total_hours: float = 24.0
     work_hours: float = 0.0
     leisure_hours: float = 0.0
@@ -413,6 +441,7 @@ class TimeBudgetDTO:
 @dataclass
 class FamilyInfoDTO:
     """ê°€ê³„ì˜ ê°€ì¡± ê´€ê³„ ì •ë³´ (AI ì˜ì‚¬ê²°ì •ìš© ì…ë ¥)"""
+
     agent_id: int
     generation: int
     parent_id: Optional[int]
@@ -423,10 +452,12 @@ class FamilyInfoDTO:
 @dataclass
 class LeisureEffectDTO:
     """ì—¬ê°€ í™œë™ì˜ ê²°ê³¼"""
+
     leisure_type: LeisureType
     leisure_hours: float
-    utility_gained: float       # ì‚¬íšŒì  ë§Œì¡±
-    xp_gained: float           # ìë…€ XP ì¦ê°€ (Parenting) ë˜ëŠ” ë³¸ì¸ ìƒì‚°ì„± (Self-Dev)
+    utility_gained: float  # ì‚¬íšŒì  ë§Œì¡±
+    xp_gained: float  # ìë…€ XP ì¦ê°€ (Parenting) ë˜ëŠ” ë³¸ì¸ ìƒì‚°ì„± (Self-Dev)
+
 
 @dataclass
 class GovernmentStateDTO:
@@ -434,6 +465,7 @@ class GovernmentStateDTO:
     WO-057-B: Sensory Module DTO.
     Transfers 10-tick SMA macro data to the Government Agent.
     """
+
     tick: int
     inflation_sma: float
     unemployment_sma: float
@@ -442,6 +474,7 @@ class GovernmentStateDTO:
     approval_sma: float
     current_gdp: float
 
+
 @dataclass
 class MacroFinancialContext:
     """
@@ -449,6 +482,7 @@ class MacroFinancialContext:
     Transfers macro financial data to portfolio decision modules.
     This DTO is activated by the MACRO_PORTFOLIO_ADJUSTMENT_ENABLED flag.
     """
+
     inflation_rate: float
     gdp_growth_rate: float
     market_volatility: float
@@ -458,6 +492,7 @@ class MacroFinancialContext:
 @dataclass
 class LaborResult:
     """Represents the result of a household's labor activities for a tick."""
+
     hours_worked: float
     income_earned: float
 
@@ -465,5 +500,6 @@ class LaborResult:
 @dataclass
 class ConsumptionResult:
     """Represents the result of a household's consumption activities for a tick."""
+
     items_consumed: Dict[str, float]
     satisfaction: float
diff --git a/simulation/dtos/firm_state_dto.py b/simulation/dtos/firm_state_dto.py
index dca6aec..5b418a8 100644
--- a/simulation/dtos/firm_state_dto.py
+++ b/simulation/dtos/firm_state_dto.py
@@ -1,12 +1,14 @@
 from dataclasses import dataclass, field
 from typing import Dict, List, Optional, Any
 
+
 @dataclass
 class FirmStateDTO:
     """
     A read-only DTO containing the state of a Firm agent.
     Used by DecisionEngines to make decisions without direct dependency on the Firm class.
     """
+
     id: int
     assets: float
     is_active: bool
@@ -33,7 +35,7 @@ class FirmStateDTO:
     expenses_this_tick: float
     consecutive_loss_turns: int
     altman_z_score: float
-    price_history: Dict[str, float] # last_prices
+    price_history: Dict[str, float]  # last_prices
     profit_history: List[float]
 
     # Brand & Sales
@@ -42,8 +44,8 @@ class FirmStateDTO:
     marketing_budget: float
 
     # HR
-    employees: List[int] # List of employee IDs
-    employees_data: Dict[int, Dict[str, Any]] # Detailed employee info
+    employees: List[int]  # List of employee IDs
+    employees_data: Dict[int, Dict[str, Any]]  # Detailed employee info
 
     # AI/Agent Data
     agent_data: Dict[str, Any]
@@ -60,37 +62,41 @@ class FirmStateDTO:
         # Extract employee IDs safely
         employee_ids = []
         employees_data = {}
-        if hasattr(firm, 'hr') and hasattr(firm.hr, 'employees'):
+        if hasattr(firm, "hr") and hasattr(firm.hr, "employees"):
             employee_ids = [e.id for e in firm.hr.employees]
 
             # Populate employees_data for CorporateManager
-            wages_map = getattr(firm.hr, 'employee_wages', {})
+            wages_map = getattr(firm.hr, "employee_wages", {})
             for e in firm.hr.employees:
                 employees_data[e.id] = {
                     "id": e.id,
                     "wage": wages_map.get(e.id, 0.0),
-                    "skill": getattr(e, 'labor_skill', 1.0),
-                    "age": getattr(e, 'age', 0),
-                    "education_level": getattr(e, 'education_level', 0)
+                    "skill": getattr(e, "labor_skill", 1.0),
+                    "age": getattr(e, "age", 0),
+                    "education_level": getattr(e, "education_level", 0),
                 }
 
         # Extract financial data safely (using properties or direct access)
-        finance = getattr(firm, 'finance', None)
+        finance = getattr(firm, "finance", None)
         revenue = firm.revenue_this_turn if finance else 0.0
         expenses = firm.expenses_this_tick if finance else 0.0
 
         profit_history = []
-        if finance and hasattr(finance, 'profit_history'):
-             profit_history = list(finance.profit_history)
+        if finance and hasattr(finance, "profit_history"):
+            profit_history = list(finance.profit_history)
 
-        consecutive_loss_turns = firm.consecutive_loss_turns if hasattr(firm, 'consecutive_loss_turns') else 0
-        if finance and hasattr(finance, 'consecutive_loss_turns'):
-             consecutive_loss_turns = finance.consecutive_loss_turns
+        consecutive_loss_turns = (
+            firm.consecutive_loss_turns
+            if hasattr(firm, "consecutive_loss_turns")
+            else 0
+        )
+        if finance and hasattr(finance, "consecutive_loss_turns"):
+            consecutive_loss_turns = finance.consecutive_loss_turns
 
         altman_z = 0.0
-        if finance and hasattr(finance, 'get_altman_z_score'):
+        if finance and hasattr(finance, "get_altman_z_score"):
             altman_z = finance.get_altman_z_score()
-        elif hasattr(firm, 'altman_z_score'):
+        elif hasattr(firm, "altman_z_score"):
             altman_z = firm.altman_z_score
 
         # Determine sentiment_index
@@ -104,7 +110,9 @@ class FirmStateDTO:
             is_active=firm.is_active,
             inventory=firm.inventory.copy(),
             inventory_quality=firm.inventory_quality.copy(),
-            input_inventory=firm.input_inventory.copy() if hasattr(firm, 'input_inventory') else {},
+            input_inventory=firm.input_inventory.copy()
+            if hasattr(firm, "input_inventory")
+            else {},
             current_production=firm.current_production,
             productivity_factor=firm.productivity_factor,
             production_target=firm.production_target,
@@ -129,6 +137,6 @@ class FirmStateDTO:
             employees=employee_ids,
             employees_data=employees_data,
             agent_data=firm.get_agent_data(),
-            system2_guidance={}, # Placeholder
-            sentiment_index=sentiment
+            system2_guidance={},  # Placeholder
+            sentiment_index=sentiment,
         )
diff --git a/simulation/dtos/scenario.py b/simulation/dtos/scenario.py
index 9c497c2..4140876 100644
--- a/simulation/dtos/scenario.py
+++ b/simulation/dtos/scenario.py
@@ -2,12 +2,14 @@ from __future__ import annotations
 from dataclasses import dataclass, field
 from typing import Optional, Dict
 
+
 @dataclass
 class StressScenarioConfig:
     """
     Data Transfer Object for configuring and passing stress scenario parameters through the simulation.
     This centralized DTO prevents pollution of the global config module and ensures explicit data flow.
     """
+
     # General Scenario Flags
     is_active: bool = False
     scenario_name: Optional[str] = None
@@ -23,7 +25,6 @@ class StressScenarioConfig:
     # One-time cash injection as a percentage of current assets (e.g., 0.5 = 50% increase).
     demand_shock_cash_injection: float = 0.0
 
-
     # --- Scenario 2: Deflationary Spiral Parameters ---
     # Enables asset fire-sales by agents if their financial situation is dire.
     panic_selling_enabled: bool = False
@@ -37,7 +38,6 @@ class StressScenarioConfig:
     # One-time asset reduction as a percentage (e.g., 0.5 = 50% reduction).
     asset_shock_reduction: float = 0.0
 
-
     # --- Scenario 3: Supply Shock Parameters ---
     # Dictionary mapping firm types or specific goods to a productivity multiplier (e.g., {"Farm": 0.5}).
     exogenous_productivity_shock: Dict[str, float] = field(default_factory=dict)
diff --git a/simulation/engine.py b/simulation/engine.py
index 397b275..e1fac9b 100644
--- a/simulation/engine.py
+++ b/simulation/engine.py
@@ -23,7 +23,7 @@ class Simulation:
         config_manager: ConfigManager,
         config_module: Any,
         logger: logging.Logger,
-        repository: SimulationRepository
+        repository: SimulationRepository,
     ) -> None:
         """
         ì´ˆê¸°í™”ëœ êµ¬ì„± ìš”ì†Œë“¤ì„ í• ë‹¹ë°›ìŠµë‹ˆë‹¤.
@@ -33,7 +33,7 @@ class Simulation:
             config_manager=config_manager,
             config_module=config_module,
             logger=logger,
-            repository=repository
+            repository=repository,
         )
         self.action_processor = ActionProcessor(self.world_state)
         self.tick_scheduler = TickScheduler(self.world_state, self.action_processor)
@@ -49,20 +49,26 @@ class Simulation:
 
         # Delegate to world_state if it has the attribute or if we are setting it dynamically
         if hasattr(self, "world_state"):
-             setattr(self.world_state, name, value)
+            setattr(self.world_state, name, value)
         else:
-             super().__setattr__(name, value)
+            super().__setattr__(name, value)
 
     def finalize_simulation(self):
         """ì‹œë®¬ë ˆì´ì…˜ ì¢…ë£Œ ì‹œ Repository ì—°ê²°ì„ ë‹«ê³ , ì‹œë®¬ë ˆì´ì…˜ ì¢…ë£Œ ì‹œê°„ì„ ê¸°ë¡í•©ë‹ˆë‹¤."""
         if self.world_state.persistence_manager:
             self.world_state.persistence_manager.flush_buffers(self.world_state.time)
-        
-        self.world_state.repository.update_simulation_run_end_time(self.world_state.run_id)
+
+        self.world_state.repository.update_simulation_run_end_time(
+            self.world_state.run_id
+        )
         self.world_state.repository.close()
-        self.world_state.logger.info("Simulation finalized and Repository connection closed.")
+        self.world_state.logger.info(
+            "Simulation finalized and Repository connection closed."
+        )
 
-    def run_tick(self, injectable_sensory_dto: Optional[GovernmentStateDTO] = None) -> None:
+    def run_tick(
+        self, injectable_sensory_dto: Optional[GovernmentStateDTO] = None
+    ) -> None:
         self.tick_scheduler.run_tick(injectable_sensory_dto)
 
     def get_all_agents(self) -> List[Any]:
@@ -83,7 +89,9 @@ class Simulation:
         """Legacy wrapper for ActionProcessor.process_transactions"""
         # We need to reconstruct the callback.
         # Note: self.tracker comes from world_state via __getattr__
-        market_data_cb = lambda: self._prepare_market_data(self.tracker).get("goods_market", {})
+        market_data_cb = lambda: self._prepare_market_data(self.tracker).get(
+            "goods_market", {}
+        )
         self.action_processor.process_transactions(transactions, market_data_cb)
 
     def _process_stock_transactions(self, transactions: List[Transaction]) -> None:
diff --git a/simulation/finance/api.py b/simulation/finance/api.py
index 43b0474..9238e54 100644
--- a/simulation/finance/api.py
+++ b/simulation/finance/api.py
@@ -1,6 +1,7 @@
 from typing import Protocol, runtime_checkable, Optional, Dict, Any
 from abc import ABC, abstractmethod
 
+
 @runtime_checkable
 class IFinancialEntity(Protocol):
     """
@@ -8,6 +9,7 @@ class IFinancialEntity(Protocol):
     Assets are read-only to the public; state changes must occur via the SettlementSystem
     calling the protected _add_assets / _sub_assets methods (or equivalent internal logic).
     """
+
     id: int
 
     @property
@@ -44,7 +46,7 @@ class ISettlementSystem(ABC):
         amount: float,
         memo: str,
         debit_context: Optional[Dict[str, Any]] = None,
-        credit_context: Optional[Dict[str, Any]] = None
+        credit_context: Optional[Dict[str, Any]] = None,
     ) -> bool:
         """
         Executes an atomic transfer from debit_agent to credit_agent.
diff --git a/simulation/firms.py b/simulation/firms.py
index 805b5e3..d5b0b55 100644
--- a/simulation/firms.py
+++ b/simulation/firms.py
@@ -35,6 +35,7 @@ if TYPE_CHECKING:
 
 logger = logging.getLogger(__name__)
 
+
 class Firm(BaseAgent, ILearningAgent):
     """ê¸°ì—… ì£¼ì²´. ìƒì‚°ê³¼ ê³ ìš©ì˜ ì£¼ì²´."""
 
@@ -52,7 +53,7 @@ class Firm(BaseAgent, ILearningAgent):
         loan_market: Optional[LoanMarket] = None,
         logger: Optional[logging.Logger] = None,
         # Phase 14-2: Innovation
-        sector: str = "FOOD", 
+        sector: str = "FOOD",
         is_visionary: bool = False,
         # Phase 16-B: Personality
         personality: Optional[Personality] = None,
@@ -74,38 +75,44 @@ class Firm(BaseAgent, ILearningAgent):
         if initial_inventory is not None:
             self.inventory.update(initial_inventory)
         self.specialization = specialization
-        self.inventory_quality: Dict[str, float] = {}  # Phase 15: Weighted Average Quality
-        self.input_inventory: Dict[str, float] = {} # WO-030: Raw Materials
-        
+        self.inventory_quality: Dict[
+            str, float
+        ] = {}  # Phase 15: Weighted Average Quality
+        self.input_inventory: Dict[str, float] = {}  # WO-030: Raw Materials
+
         # Phase 14-2 attributes
         self.sector = sector
         self.is_visionary = is_visionary
-        self.owner_id: Optional[int] = None # Phase 14-1: Shareholder System
-        
+        self.owner_id: Optional[int] = None  # Phase 14-1: Shareholder System
+
         # Phase 16-B: Personality & Innovation Attributes
         self.personality = personality or Personality.BALANCED
         self.base_quality: float = 1.0
         self.research_history: Dict[str, Any] = {
             "total_spent": 0.0,
             "success_count": 0,
-            "last_success_tick": -1
+            "last_success_tick": -1,
         }
 
         # SoC Refactor: HR and Finance Components
         self.hr = HRDepartment(self)
         # WO-103 Phase 1: Initialize Finance with buffered assets
         # Fix: Use initial_capital passed to constructor, or self._assets from BaseAgent
-        self.finance = FinanceDepartment(self, config_module, initial_capital=initial_capital)
+        self.finance = FinanceDepartment(
+            self, config_module, initial_capital=initial_capital
+        )
 
         self.production = ProductionDepartment(self, config_module)
         self.sales = SalesDepartment(self, config_module)
 
         # Set bankruptcy threshold based on visionary status
-        base_threshold = getattr(config_module, "BANKRUPTCY_CONSECUTIVE_LOSS_THRESHOLD", 5)
+        base_threshold = getattr(
+            config_module, "BANKRUPTCY_CONSECUTIVE_LOSS_THRESHOLD", 5
+        )
         if self.is_visionary:
             self.consecutive_loss_ticks_for_bankruptcy_threshold = base_threshold * 2
         else:
-             self.consecutive_loss_ticks_for_bankruptcy_threshold = base_threshold
+            self.consecutive_loss_ticks_for_bankruptcy_threshold = base_threshold
 
         self.production_target: float = (
             config_module.FIRM_MIN_PRODUCTION_TARGET
@@ -115,28 +122,30 @@ class Firm(BaseAgent, ILearningAgent):
         self.productivity_factor: float = productivity_factor
         self.total_shares: float = getattr(config_module, "IPO_INITIAL_SHARES", 1000.0)
         self.last_prices: Dict[str, float] = {}
-        self.hires_last_tick: int = 0 # Handled in HR but maybe exposed here?
-        
+        self.hires_last_tick: int = 0  # Handled in HR but maybe exposed here?
+
         # --- Phase 9: M&A Attributes ---
         self.is_bankrupt: bool = False
         self.valuation: float = 0.0
-        self.consecutive_loss_ticks_for_bankruptcy: int = 0 # Track separately strictly for rule
-        
+        self.consecutive_loss_ticks_for_bankruptcy: int = (
+            0  # Track separately strictly for rule
+        )
+
         # --- Phase 6: Brand Engine ---
         self.brand_manager = BrandManager(self.id, config_module, logger)
-        self.marketing_budget: float = 0.0 # Decision variable
+        self.marketing_budget: float = 0.0  # Decision variable
         self.prev_awareness: float = 0.0  # For AI Reward Calculation
         # ROI Optimization
         self.marketing_budget_rate: float = 0.05  # Initial 5%
 
         # --- ì£¼ì‹ ì‹œì¥ ê´€ë ¨ ì†ì„± ---
         self.founder_id: Optional[int] = None  # ì°½ì—…ì ê°€ê³„ ID
-        self.is_publicly_traded: bool = True   # ìƒì¥ ì—¬ë¶€
+        self.is_publicly_traded: bool = True  # ìƒì¥ ì—¬ë¶€
         self.dividend_rate: float = getattr(
             config_module, "DIVIDEND_RATE", 0.3
         )  # ê¸°ì—…ë³„ ë°°ë‹¹ë¥  (ê¸°ë³¸ê°’: config)
         self.treasury_shares: float = self.total_shares  # ìì‚¬ì£¼ ë³´ìœ ëŸ‰
-        self.capital_stock: float = 100.0   # ì‹¤ë¬¼ ìë³¸ì¬ (ì´ˆê¸°ê°’: 100)
+        self.capital_stock: float = 100.0  # ì‹¤ë¬¼ ìë³¸ì¬ (ì´ˆê¸°ê°’: 100)
 
         # Phase 16-B: Rewards Tracking (Delta storage)
         self.prev_market_share: float = 0.0
@@ -144,8 +153,8 @@ class Firm(BaseAgent, ILearningAgent):
         self.prev_avg_quality: float = 1.0
 
         # Phase 21: Automation
-        self.automation_level: float = 0.0 # 0.0 to 1.0
-        self.system2_planner: Optional[FirmSystem2Planner] = None # Initialized later
+        self.automation_level: float = 0.0  # 0.0 to 1.0
+        self.system2_planner: Optional[FirmSystem2Planner] = None  # Initialized later
 
         self.age = 0
         # WO-103 Phase 1: Removed self.cash_reserve redundancy. Using FinanceDepartment.
@@ -155,20 +164,20 @@ class Firm(BaseAgent, ILearningAgent):
     # WO-103 Phase 1: Assets Property to delegate to FinanceDepartment
     @property
     def assets(self) -> float:
-        if hasattr(self, 'finance'):
+        if hasattr(self, "finance"):
             return self.finance.balance
         return self._assets_buffer
 
     def _add_assets(self, amount: float) -> None:
         """[PROTECTED] Delegate to FinanceDepartment."""
-        if hasattr(self, 'finance'):
+        if hasattr(self, "finance"):
             self.finance.credit(amount, "Settlement Transfer")
         else:
             self._assets_buffer += amount
 
     def _sub_assets(self, amount: float) -> None:
         """[PROTECTED] Delegate to FinanceDepartment."""
-        if hasattr(self, 'finance'):
+        if hasattr(self, "finance"):
             self.finance.debit(amount, "Settlement Transfer")
         else:
             self._assets_buffer -= amount
@@ -179,7 +188,7 @@ class Firm(BaseAgent, ILearningAgent):
         stock_market.update_shareholder(self.id, self.id, self.treasury_shares)
         self.logger.info(
             f"IPO | Firm {self.id} initialized IPO with {self.total_shares} shares. Par value: {par_value:.2f}",
-            extra={"agent_id": self.id, "tags": ["ipo", "stock_market"]}
+            extra={"agent_id": self.id, "tags": ["ipo", "stock_market"]},
         )
 
     def liquidate_assets(self) -> float:
@@ -191,10 +200,10 @@ class Firm(BaseAgent, ILearningAgent):
         """
         # 1. Write off Inventory
         self.inventory.clear()
-        
+
         # 2. Write off Capital Stock
         self.capital_stock = 0.0
-        
+
         # 3. Write off Automation
         self.automation_level = 0.0
 
@@ -208,12 +217,21 @@ class Firm(BaseAgent, ILearningAgent):
 
         total_qty = current_inventory + quantity
         if total_qty > 0:
-            new_avg_quality = ((current_inventory * current_quality) + (quantity * quality)) / total_qty
+            new_avg_quality = (
+                (current_inventory * current_quality) + (quantity * quality)
+            ) / total_qty
             self.inventory_quality[item_id] = new_avg_quality
 
         self.inventory[item_id] = total_qty
 
-    def post_ask(self, item_id: str, price: float, quantity: float, market: OrderBookMarket, current_tick: int) -> Order:
+    def post_ask(
+        self,
+        item_id: str,
+        price: float,
+        quantity: float,
+        market: OrderBookMarket,
+        current_tick: int,
+    ) -> Order:
         return self.sales.post_ask(item_id, price, quantity, market, current_tick)
 
     def calculate_brand_premium(self, market_data: Dict[str, Any]) -> float:
@@ -238,11 +256,17 @@ class Firm(BaseAgent, ILearningAgent):
     def _adjust_marketing_budget(self) -> None:
         self.sales.adjust_marketing_budget()
 
-    def produce(self, current_time: int, technology_manager: Optional[Any] = None) -> None:
-        self.current_production = self.production.produce(current_time, technology_manager)
+    def produce(
+        self, current_time: int, technology_manager: Optional[Any] = None
+    ) -> None:
+        self.current_production = self.production.produce(
+            current_time, technology_manager
+        )
 
     @override
-    def clone(self, new_id: int, initial_assets_from_parent: float, current_tick: int) -> "Firm":
+    def clone(
+        self, new_id: int, initial_assets_from_parent: float, current_tick: int
+    ) -> "Firm":
         """
         í˜„ì¬ ê¸°ì—… ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë³µì œí•˜ì—¬ ìƒˆë¡œìš´ ê¸°ì—…ì„ ìƒì„±í•©ë‹ˆë‹¤.
         AI ëª¨ë¸(decision_engine)ì„ í¬í•¨í•˜ì—¬ ê¹Šì€ ë³µì‚¬ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤.
@@ -261,7 +285,7 @@ class Firm(BaseAgent, ILearningAgent):
             initial_inventory=copy.deepcopy(self.inventory),
             loan_market=self.decision_engine.loan_market,  # loan_marketì€ ê³µìœ 
             logger=self.logger,
-            personality=self.personality # Propagate personality
+            personality=self.personality,  # Propagate personality
         )
         new_firm.logger.info(
             f"Firm {self.id} was cloned to new Firm {new_id}",
@@ -280,9 +304,11 @@ class Firm(BaseAgent, ILearningAgent):
             "assets": self.assets,
             "needs": self.needs.copy(),
             "inventory": self.inventory.copy(),
-            "input_inventory": self.input_inventory.copy(), # WO-030
+            "input_inventory": self.input_inventory.copy(),  # WO-030
             # SoC Refactor
-            "employees": [emp.id for emp in self.hr.employees],  # Only pass employee IDs
+            "employees": [
+                emp.id for emp in self.hr.employees
+            ],  # Only pass employee IDs
             "is_active": self.is_active,
             "current_production": self.current_production,
             "productivity_factor": self.productivity_factor,
@@ -295,9 +321,9 @@ class Firm(BaseAgent, ILearningAgent):
             "treasury_shares": self.treasury_shares,
             "dividend_rate": self.dividend_rate,
             "capital_stock": self.capital_stock,
-            "base_quality": self.base_quality, # AI needs to know this
+            "base_quality": self.base_quality,  # AI needs to know this
             "inventory_quality": self.inventory_quality.copy(),
-            "automation_level": self.automation_level, # Phase 21
+            "automation_level": self.automation_level,  # Phase 21
         }
 
     def get_state_dto(self) -> FirmStateDTO:
@@ -311,10 +337,16 @@ class Firm(BaseAgent, ILearningAgent):
         """AI í•™ìŠµì„ ìœ„í•œ ì´ì „ ìƒíƒœ ë°ì´í„°ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."""
         return getattr(self, "pre_state_snapshot", self.get_agent_data())
 
-
     @override
     def make_decision(
-        self, markets: Dict[str, Any], goods_data: list[Dict[str, Any]], market_data: Dict[str, Any], current_time: int, government: Optional[Any] = None, reflux_system: Optional[Any] = None, stress_scenario_config: Optional["StressScenarioConfig"] = None
+        self,
+        markets: Dict[str, Any],
+        goods_data: list[Dict[str, Any]],
+        market_data: Dict[str, Any],
+        current_time: int,
+        government: Optional[Any] = None,
+        reflux_system: Optional[Any] = None,
+        stress_scenario_config: Optional["StressScenarioConfig"] = None,
     ) -> tuple[list[Order], Any]:
         log_extra = {"tick": current_time, "agent_id": self.id, "tags": ["firm_action"]}
         # SoC Refactor
@@ -369,20 +401,30 @@ class Firm(BaseAgent, ILearningAgent):
         )
         return external_orders, tactic
 
-    def _execute_internal_order(self, order: Order, government: Optional[Any], current_time: int) -> None:
+    def _execute_internal_order(
+        self, order: Order, government: Optional[Any], current_time: int
+    ) -> None:
         """Executes internal orders (state modifications) received from the Decision Engine."""
         if order.order_type == "SET_TARGET":
             self.production_target = order.quantity
-            self.logger.info(f"INTERNAL_EXEC | Firm {self.id} set production target to {self.production_target:.1f}")
+            self.logger.info(
+                f"INTERNAL_EXEC | Firm {self.id} set production target to {self.production_target:.1f}"
+            )
 
         elif order.order_type == "INVEST_AUTOMATION":
             spend = order.quantity
             if self.finance.invest_in_automation(spend):
-                cost_per_pct = getattr(self.config_module, "AUTOMATION_COST_PER_PCT", 1000.0)
+                cost_per_pct = getattr(
+                    self.config_module, "AUTOMATION_COST_PER_PCT", 1000.0
+                )
                 if cost_per_pct > 0:
                     gained_a = (spend / cost_per_pct) / 100.0
-                    self.production.set_automation_level(self.automation_level + gained_a)
-                    self.logger.info(f"INTERNAL_EXEC | Firm {self.id} invested {spend:.1f} in automation.")
+                    self.production.set_automation_level(
+                        self.automation_level + gained_a
+                    )
+                    self.logger.info(
+                        f"INTERNAL_EXEC | Firm {self.id} invested {spend:.1f} in automation."
+                    )
 
         elif order.order_type == "PAY_TAX":
             amount = order.quantity
@@ -398,10 +440,14 @@ class Firm(BaseAgent, ILearningAgent):
         elif order.order_type == "INVEST_CAPEX":
             budget = order.quantity
             if self.finance.invest_in_capex(budget):
-                efficiency = 1.0 / getattr(self.config_module, "CAPITAL_TO_OUTPUT_RATIO", 2.0)
+                efficiency = 1.0 / getattr(
+                    self.config_module, "CAPITAL_TO_OUTPUT_RATIO", 2.0
+                )
                 added_capital = budget * efficiency
                 self.production.add_capital(added_capital)
-                self.logger.info(f"INTERNAL_EXEC | Firm {self.id} invested {budget:.1f} in CAPEX.")
+                self.logger.info(
+                    f"INTERNAL_EXEC | Firm {self.id} invested {budget:.1f} in CAPEX."
+                )
 
         elif order.order_type == "SET_DIVIDEND":
             self.finance.set_dividend_rate(order.quantity)
@@ -419,9 +465,13 @@ class Firm(BaseAgent, ILearningAgent):
                 if self.finance.pay_severance(employee, severance_pay):
                     employee.quit()
                     self.hr.remove_employee(employee)
-                    self.logger.info(f"INTERNAL_EXEC | Firm {self.id} fired employee {emp_id}.")
+                    self.logger.info(
+                        f"INTERNAL_EXEC | Firm {self.id} fired employee {emp_id}."
+                    )
                 else:
-                    self.logger.warning(f"INTERNAL_EXEC | Firm {self.id} failed to fire {emp_id} (insufficient funds).")
+                    self.logger.warning(
+                        f"INTERNAL_EXEC | Firm {self.id} failed to fire {emp_id} (insufficient funds)."
+                    )
 
     def _execute_rd_outcome(self, budget: float, current_time: int) -> None:
         """Executes the probabilistic outcome of R&D investment."""
@@ -432,26 +482,33 @@ class Firm(BaseAgent, ILearningAgent):
 
         avg_skill = 1.0
         if self.hr.employees:
-            avg_skill = sum(getattr(e, 'labor_skill', 1.0) for e in self.hr.employees) / len(self.hr.employees)
+            avg_skill = sum(
+                getattr(e, "labor_skill", 1.0) for e in self.hr.employees
+            ) / len(self.hr.employees)
 
         success_chance = base_chance * avg_skill
 
         import random
+
         if random.random() < success_chance:
             self.research_history["success_count"] += 1
             self.research_history["last_success_tick"] = current_time
             self.base_quality += 0.05
             self.productivity_factor *= 1.05
-            self.logger.info(f"INTERNAL_EXEC | Firm {self.id} R&D SUCCESS (Budget: {budget:.1f})")
+            self.logger.info(
+                f"INTERNAL_EXEC | Firm {self.id} R&D SUCCESS (Budget: {budget:.1f})"
+            )
 
-    def _calculate_invisible_hand_price(self, markets: Dict[str, Any], current_tick: int) -> None:
+    def _calculate_invisible_hand_price(
+        self, markets: Dict[str, Any], current_tick: int
+    ) -> None:
         """
         WO-056: Stage 1 Shadow Mode (Price Discovery 2.0).
         Calculates and logs the shadow price based on Excess Demand.
         """
         market = markets.get(self.specialization)
         # Check if market supports order book inspection
-        if not market or not hasattr(market, 'get_all_bids'):
+        if not market or not hasattr(market, "get_all_bids"):
             return
 
         # 1. Get Demand and Supply (Market-wide for this good)
@@ -490,10 +547,16 @@ class Firm(BaseAgent, ILearningAgent):
             metric="shadow_price",
             current_value=current_price,
             shadow_value=shadow_price,
-            details=f"Item={self.specialization}, D={demand:.1f}, S={supply:.1f}, Ratio={excess_demand_ratio:.2f}"
+            details=f"Item={self.specialization}, D={demand:.1f}, S={supply:.1f}, Ratio={excess_demand_ratio:.2f}",
         )
 
-    def generate_transactions(self, government: Optional[Government], market_data: Dict[str, Any], all_households: List[Household], current_time: int) -> List[Transaction]:
+    def generate_transactions(
+        self,
+        government: Optional[Government],
+        market_data: Dict[str, Any],
+        all_households: List[Household],
+        current_time: int,
+    ) -> List[Transaction]:
         """
         Generates all financial transactions for the tick (Wages, Taxes, Dividends, etc.).
         Phase 3 Architecture.
@@ -505,20 +568,26 @@ class Firm(BaseAgent, ILearningAgent):
         transactions.extend(tx_payroll)
 
         # 2. Finance Transactions (Holding, Maint, Corp Tax, Dividends, Bailout Repayment)
-        tx_finance = self.finance.generate_financial_transactions(government, all_households, current_time)
+        tx_finance = self.finance.generate_financial_transactions(
+            government, all_households, current_time
+        )
         transactions.extend(tx_finance)
 
         # 3. Marketing (Direct Calculation here as per old update_needs)
         if self.assets > 100.0:
-            marketing_spend = max(10.0, self.finance.revenue_this_turn * self.marketing_budget_rate)
+            marketing_spend = max(
+                10.0, self.finance.revenue_this_turn * self.marketing_budget_rate
+            )
         else:
             marketing_spend = 0.0
 
         if self.assets < marketing_spend:
-             marketing_spend = 0.0
+            marketing_spend = 0.0
 
         if marketing_spend > 0:
-            tx_marketing = self.finance.generate_marketing_transaction(government, current_time, marketing_spend)
+            tx_marketing = self.finance.generate_marketing_transaction(
+                government, current_time, marketing_spend
+            )
             if tx_marketing:
                 transactions.append(tx_marketing)
 
@@ -531,7 +600,14 @@ class Firm(BaseAgent, ILearningAgent):
         return transactions
 
     @override
-    def update_needs(self, current_time: int, government: Optional[Any] = None, market_data: Optional[Dict[str, Any]] = None, reflux_system: Optional[Any] = None, technology_manager: Optional[Any] = None) -> None:
+    def update_needs(
+        self,
+        current_time: int,
+        government: Optional[Any] = None,
+        market_data: Optional[Dict[str, Any]] = None,
+        reflux_system: Optional[Any] = None,
+        technology_manager: Optional[Any] = None,
+    ) -> None:
         """
         Lifecycle updates (Age, Bankruptcy Check).
         Financial transactions are now in generate_transactions.
@@ -540,11 +616,19 @@ class Firm(BaseAgent, ILearningAgent):
         self.age += 1
 
         # --- Final State Updates & Checks ---
-        self.needs["liquidity_need"] = min(100.0, self.needs["liquidity_need"] + self.config_module.LIQUIDITY_NEED_INCREASE_RATE)
+        self.needs["liquidity_need"] = min(
+            100.0,
+            self.needs["liquidity_need"]
+            + self.config_module.LIQUIDITY_NEED_INCREASE_RATE,
+        )
         self.finance.check_bankruptcy()
 
         # SoC Refactor
-        if self.assets <= self.config_module.ASSETS_CLOSURE_THRESHOLD or self.finance.consecutive_loss_turns >= self.config_module.FIRM_CLOSURE_TURNS_THRESHOLD:
+        if (
+            self.assets <= self.config_module.ASSETS_CLOSURE_THRESHOLD
+            or self.finance.consecutive_loss_turns
+            >= self.config_module.FIRM_CLOSURE_TURNS_THRESHOLD
+        ):
             self.is_active = False
             self.logger.warning(
                 f"FIRM_INACTIVE | Firm {self.id} closed down. Assets: {self.assets:.2f}, Consecutive Loss Turns: {self.finance.consecutive_loss_turns}",
@@ -579,7 +663,9 @@ class Firm(BaseAgent, ILearningAgent):
         """Withdraws a given amount from the firm's cash reserves."""
         if amount > 0:
             if self.finance.balance < amount:
-                raise InsufficientFundsError(f"Firm {self.id} has insufficient funds for withdrawal of {amount:.2f}. Available: {self.finance.balance:.2f}")
+                raise InsufficientFundsError(
+                    f"Firm {self.id} has insufficient funds for withdrawal of {amount:.2f}. Available: {self.finance.balance:.2f}"
+                )
             self.finance.debit(amount, "Withdrawal")
 
     # --- Delegated Methods (Facade Pattern) ---
@@ -650,7 +736,7 @@ class Firm(BaseAgent, ILearningAgent):
         next_market_data = context["next_market_data"]
 
         # ì—”ì§„ì€ ë” ì´ìƒ firm.decision_engine.ai_engineì— ì§ì ‘ ì ‘ê·¼í•˜ì§€ ì•Šê³  ì´ ë©”ì„œë“œë¥¼ í†µí•´ ìš”ì²­í•©ë‹ˆë‹¤.
-        if hasattr(self.decision_engine, 'ai_engine'):
+        if hasattr(self.decision_engine, "ai_engine"):
             self.decision_engine.ai_engine.update_learning_v2(
                 reward=reward,
                 next_agent_data=next_agent_data,
diff --git a/simulation/initialization/api.py b/simulation/initialization/api.py
index fc6b0f2..61a7c88 100644
--- a/simulation/initialization/api.py
+++ b/simulation/initialization/api.py
@@ -2,10 +2,12 @@ from __future__ import annotations
 from typing import List, Dict, Any
 import logging
 
+
 # Forward declaration to avoid circular import
 class Simulation:
     pass
 
+
 class SimulationInitializerInterface:
     """Simulation ì¸ìŠ¤í„´ìŠ¤ ìƒì„±ì„ ì±…ì„ì§€ëŠ” ì¸í„°í˜ì´ìŠ¤"""
 
diff --git a/simulation/initialization/initializer.py b/simulation/initialization/initializer.py
index 279f156..b382779 100644
--- a/simulation/initialization/initializer.py
+++ b/simulation/initialization/initializer.py
@@ -26,7 +26,10 @@ from simulation.markets.order_book_market import OrderBookMarket
 from simulation.markets.stock_market import StockMarket
 from simulation.metrics.economic_tracker import EconomicIndicatorTracker
 from simulation.metrics.inequality_tracker import InequalityTracker
-from simulation.metrics.stock_tracker import StockMarketTracker, PersonalityStatisticsTracker
+from simulation.metrics.stock_tracker import (
+    StockMarketTracker,
+    PersonalityStatisticsTracker,
+)
 from simulation.ai_model import AIEngineRegistry
 from simulation.ai.ai_training_manager import AITrainingManager
 from simulation.systems.ma_manager import MAManager
@@ -60,15 +63,17 @@ from modules.analysis.crisis_monitor import CrisisMonitor
 class SimulationInitializer(SimulationInitializerInterface):
     """Simulation ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ë° ëª¨ë“  êµ¬ì„± ìš”ì†Œì˜ ì´ˆê¸°í™”ë¥¼ ì „ë‹´í•©ë‹ˆë‹¤."""
 
-    def __init__(self,
-                 config_manager: ConfigManager,
-                 config_module: Any,
-                 goods_data: List[Dict[str, Any]],
-                 repository: SimulationRepository,
-                 logger: logging.Logger,
-                 households: List[Household],
-                 firms: List[Firm],
-                 ai_trainer: AIEngineRegistry):
+    def __init__(
+        self,
+        config_manager: ConfigManager,
+        config_module: Any,
+        goods_data: List[Dict[str, Any]],
+        repository: SimulationRepository,
+        logger: logging.Logger,
+        households: List[Household],
+        firms: List[Firm],
+        ai_trainer: AIEngineRegistry,
+    ):
         self.config_manager = config_manager
         self.config = config_module
         self.goods_data = goods_data
@@ -88,7 +93,7 @@ class SimulationInitializer(SimulationInitializerInterface):
             config_manager=self.config_manager,
             config_module=self.config,
             logger=self.logger,
-            repository=self.repository
+            repository=self.repository,
         )
 
         # 2. Populate the shell with all its components
@@ -113,16 +118,14 @@ class SimulationInitializer(SimulationInitializerInterface):
             id=sim.next_agent_id,
             initial_assets=self.config.INITIAL_BANK_ASSETS,
             config_manager=self.config_manager,
-            settlement_system=sim.settlement_system
+            settlement_system=sim.settlement_system,
         )
         sim.bank.settlement_system = sim.settlement_system
         sim.agents[sim.bank.id] = sim.bank
         sim.next_agent_id += 1
 
         sim.government = Government(
-            id=sim.next_agent_id,
-            initial_assets=0.0,
-            config_module=self.config
+            id=sim.next_agent_id, initial_assets=0.0, config_module=self.config
         )
         sim.government.settlement_system = sim.settlement_system
         sim.agents[sim.government.id] = sim.government
@@ -130,28 +133,30 @@ class SimulationInitializer(SimulationInitializerInterface):
 
         sim.tracker = EconomicIndicatorTracker(config_module=self.config)
 
-        sim.central_bank = CentralBank(
-            tracker=sim.tracker,
-            config_module=self.config
-        )
+        sim.central_bank = CentralBank(tracker=sim.tracker, config_module=self.config)
 
         sim.finance_system = FinanceSystem(
             government=sim.government,
             central_bank=sim.central_bank,
             bank=sim.bank,
             config_module=self.config_manager,
-            settlement_system=sim.settlement_system
+            settlement_system=sim.settlement_system,
         )
         sim.government.finance_system = sim.finance_system
 
         sim.real_estate_units: List[RealEstateUnit] = [
-            RealEstateUnit(id=i, estimated_value=self.config.INITIAL_PROPERTY_VALUE,
-                           rent_price=self.config.INITIAL_RENT_PRICE)
+            RealEstateUnit(
+                id=i,
+                estimated_value=self.config.INITIAL_PROPERTY_VALUE,
+                rent_price=self.config.INITIAL_RENT_PRICE,
+            )
             for i in range(self.config.NUM_HOUSING_UNITS)
         ]
 
         top_20_count = len(sim.households) // 5
-        top_households = sorted(sim.households, key=lambda h: h.assets, reverse=True)[:top_20_count]
+        top_households = sorted(sim.households, key=lambda h: h.assets, reverse=True)[
+            :top_20_count
+        ]
 
         for i, hh in enumerate(top_households):
             if i < len(sim.real_estate_units):
@@ -173,7 +178,9 @@ class SimulationInitializer(SimulationInitializerInterface):
         sim.markets["loan_market"].agents_ref = sim.agents
 
         if getattr(self.config, "STOCK_MARKET_ENABLED", False):
-            sim.stock_market = StockMarket(config_module=self.config, logger=self.logger)
+            sim.stock_market = StockMarket(
+                config_module=self.config, logger=self.logger
+            )
             sim.stock_tracker = StockMarketTracker(config_module=self.config)
             sim.markets["stock_market"] = sim.stock_market
             for firm in sim.firms:
@@ -193,7 +200,7 @@ class SimulationInitializer(SimulationInitializerInterface):
                     price=unit.estimated_value,
                     quantity=1.0,
                     market_id="housing",
-                    order_type="SELL"
+                    order_type="SELL",
                 )
                 if "housing" in sim.markets:
                     sim.markets["housing"].place_order(sell_order, sim.time)
@@ -206,10 +213,14 @@ class SimulationInitializer(SimulationInitializerInterface):
                 agent.config_module = self.config
 
         sim.inequality_tracker = InequalityTracker(config_module=self.config)
-        sim.personality_tracker = PersonalityStatisticsTracker(config_module=self.config)
+        sim.personality_tracker = PersonalityStatisticsTracker(
+            config_module=self.config
+        )
         # Initialize with a combined list copy to prevent aliasing sim.households
         # Note: New agents must be explicitly added to this list by lifecycle managers.
-        sim.ai_training_manager = AITrainingManager(sim.households + sim.firms, self.config)
+        sim.ai_training_manager = AITrainingManager(
+            sim.households + sim.firms, self.config
+        )
         sim.ma_manager = MAManager(sim, self.config)
         sim.reflux_system = EconomicRefluxSystem()
         sim.demographic_manager = DemographicManager(config_module=self.config)
@@ -217,17 +228,19 @@ class SimulationInitializer(SimulationInitializerInterface):
         sim.inheritance_manager = InheritanceManager(config_module=self.config)
         sim.housing_system = HousingSystem(config_module=self.config)
         sim.persistence_manager = PersistenceManager(
-            run_id=0,
-            config_module=self.config,
-            repository=self.repository
+            run_id=0, config_module=self.config, repository=self.repository
         )
         sim.firm_system = FirmSystem(config_module=self.config)
-        sim.technology_manager = TechnologyManager(config_module=self.config, logger=self.logger)
+        sim.technology_manager = TechnologyManager(
+            config_module=self.config, logger=self.logger
+        )
 
         Bootstrapper.inject_initial_liquidity(sim.firms, self.config)
         Bootstrapper.force_assign_workers(sim.firms, sim.households)
 
-        sim.generational_wealth_audit = GenerationalWealthAudit(config_module=self.config)
+        sim.generational_wealth_audit = GenerationalWealthAudit(
+            config_module=self.config
+        )
         sim.breeding_planner = VectorizedHouseholdPlanner(self.config)
         sim.transaction_processor = TransactionProcessor(self.config)
 
@@ -237,7 +250,7 @@ class SimulationInitializer(SimulationInitializerInterface):
             demographic_manager=sim.demographic_manager,
             inheritance_manager=sim.inheritance_manager,
             firm_system=sim.firm_system,
-            logger=self.logger
+            logger=self.logger,
         )
 
         # Initialize New Systems (Social, Event, Sensory, Commerce, Labor)
@@ -253,6 +266,7 @@ class SimulationInitializer(SimulationInitializerInterface):
 
         # Phase 28: Initialize Stress Scenario Config
         from simulation.dtos.scenario import StressScenarioConfig
+
         sim.stress_scenario_config = StressScenarioConfig()
 
         # Load Scenario from JSON if directed by config
@@ -260,26 +274,48 @@ class SimulationInitializer(SimulationInitializerInterface):
         if active_scenario_name:
             scenario_path = f"config/scenarios/{active_scenario_name}.json"
             if os.path.exists(scenario_path):
-                 try:
-                     with open(scenario_path, 'r') as f:
-                         scenario_data = json.load(f)
-
-                     sim.stress_scenario_config.is_active = scenario_data.get("is_active", False)
-                     sim.stress_scenario_config.scenario_name = scenario_data.get("scenario_name", active_scenario_name)
-                     sim.stress_scenario_config.start_tick = scenario_data.get("start_tick", 50)
-
-                     params = scenario_data.get("parameters", {})
-                     sim.stress_scenario_config.monetary_shock_target_rate = params.get("MONETARY_SHOCK_TARGET_RATE")
-                     sim.stress_scenario_config.fiscal_shock_tax_rate = params.get("FISCAL_SHOCK_TAX_RATE")
-                     sim.stress_scenario_config.base_interest_rate_multiplier = params.get("base_interest_rate_multiplier")
-                     sim.stress_scenario_config.corporate_tax_rate_delta = params.get("corporate_tax_rate_delta")
-                     sim.stress_scenario_config.demand_shock_multiplier = params.get("demand_shock_multiplier")
-
-                     self.logger.info(f"Loaded Stress Scenario: {sim.stress_scenario_config.scenario_name} (Active: {sim.stress_scenario_config.is_active})")
-                 except Exception as e:
-                     self.logger.error(f"Failed to load scenario file '{scenario_path}': {e}")
+                try:
+                    with open(scenario_path, "r") as f:
+                        scenario_data = json.load(f)
+
+                    sim.stress_scenario_config.is_active = scenario_data.get(
+                        "is_active", False
+                    )
+                    sim.stress_scenario_config.scenario_name = scenario_data.get(
+                        "scenario_name", active_scenario_name
+                    )
+                    sim.stress_scenario_config.start_tick = scenario_data.get(
+                        "start_tick", 50
+                    )
+
+                    params = scenario_data.get("parameters", {})
+                    sim.stress_scenario_config.monetary_shock_target_rate = params.get(
+                        "MONETARY_SHOCK_TARGET_RATE"
+                    )
+                    sim.stress_scenario_config.fiscal_shock_tax_rate = params.get(
+                        "FISCAL_SHOCK_TAX_RATE"
+                    )
+                    sim.stress_scenario_config.base_interest_rate_multiplier = (
+                        params.get("base_interest_rate_multiplier")
+                    )
+                    sim.stress_scenario_config.corporate_tax_rate_delta = params.get(
+                        "corporate_tax_rate_delta"
+                    )
+                    sim.stress_scenario_config.demand_shock_multiplier = params.get(
+                        "demand_shock_multiplier"
+                    )
+
+                    self.logger.info(
+                        f"Loaded Stress Scenario: {sim.stress_scenario_config.scenario_name} (Active: {sim.stress_scenario_config.is_active})"
+                    )
+                except Exception as e:
+                    self.logger.error(
+                        f"Failed to load scenario file '{scenario_path}': {e}"
+                    )
             else:
-                self.logger.warning(f"Active scenario '{active_scenario_name}' requested but {scenario_path} not found.")
+                self.logger.warning(
+                    f"Active scenario '{active_scenario_name}' requested but {scenario_path} not found."
+                )
 
         sim.household_time_allocation: Dict[int, float] = {}
         sim.inflation_buffer = deque(maxlen=10)
diff --git a/simulation/interface/dashboard_connector.py b/simulation/interface/dashboard_connector.py
index fbb0c69..9935147 100644
--- a/simulation/interface/dashboard_connector.py
+++ b/simulation/interface/dashboard_connector.py
@@ -6,6 +6,7 @@ import config
 
 logger = logging.getLogger("dashboard_connector")
 
+
 def get_engine_instance() -> Simulation:
     """
     Factory function to create and initialize the Simulation object
@@ -17,6 +18,7 @@ def get_engine_instance() -> Simulation:
     simulation = simulation_main.create_simulation()
     return simulation
 
+
 def run_tick(simulation: Simulation) -> int:
     """
     Advances the simulation by one tick.
@@ -25,6 +27,7 @@ def run_tick(simulation: Simulation) -> int:
     simulation.run_tick()
     return simulation.time
 
+
 def get_metrics(simulation: Simulation) -> Dict[str, Any]:
     """
     Extracts key economic metrics from the simulation state.
@@ -90,9 +93,10 @@ def get_metrics(simulation: Simulation) -> Dict[str, Any]:
         "total_labor_income": total_labor_income,
         "labor_share": labor_share,
         "velocity_of_money": velocity_of_money,
-        "inventory_turnover": inventory_turnover
+        "inventory_turnover": inventory_turnover,
     }
 
+
 def update_params(simulation: Simulation, new_params: Dict[str, Any]) -> None:
     """
     Updates simulation configuration at runtime.
@@ -104,6 +108,7 @@ def update_params(simulation: Simulation, new_params: Dict[str, Any]) -> None:
         else:
             logger.warning(f"[Dashboard] Unknown config key: {key}")
 
+
 def get_agent_details(simulation: Simulation, agent_id: int) -> Dict[str, Any]:
     """
     Returns detailed info for a specific agent.
@@ -115,7 +120,7 @@ def get_agent_details(simulation: Simulation, agent_id: int) -> Dict[str, Any]:
 
     # Extract System 2 projection if available
     # System2Planner is usually initialized on Household
-    system2 = getattr(agent, 'system2_planner', None)
+    system2 = getattr(agent, "system2_planner", None)
     projection = system2.cached_projection if system2 else {}
 
     details = {
diff --git a/simulation/interfaces/policy_interface.py b/simulation/interfaces/policy_interface.py
index 5b2b344..9cb667e 100644
--- a/simulation/interfaces/policy_interface.py
+++ b/simulation/interfaces/policy_interface.py
@@ -1,17 +1,20 @@
 from abc import ABC, abstractmethod
 from typing import Dict, Any
 
+
 class IGovernmentPolicy(ABC):
     """
     ì •ë¶€ ì •ì±… ê²°ì •ì„ ìœ„í•œ ì¸í„°í˜ì´ìŠ¤.
     ì¶”í›„ í…Œì¼ëŸ¬ ì¤€ì¹™(Rule-based)ê³¼ AI(Adaptive) ì •ì±…ì„ êµì²´í•  ìˆ˜ ìˆê²Œ í•©ë‹ˆë‹¤.
     """
-    
+
     @abstractmethod
-    def decide(self, government: Any, market_data: Dict[str, Any], current_tick: int) -> Dict[str, Any]:
+    def decide(
+        self, government: Any, market_data: Dict[str, Any], current_tick: int
+    ) -> Dict[str, Any]:
         """
         ê²½ì œ ìƒí™©ì„ ë¶„ì„í•˜ì—¬ ì •ì±…(ê¸ˆë¦¬, ì„¸ìœ¨, ì˜ˆì‚° ë°°ë¶„ ë“±)ì„ ê²°ì •í•©ë‹ˆë‹¤.
-        
+
         Returns:
             Dict[str, Any]: ê²°ì •ëœ ì •ì±… ë³€ìˆ˜ë“¤ (e.g., {"base_rate": 0.05, "income_tax": 0.1, ...})
         """
diff --git a/simulation/loan_market.py b/simulation/loan_market.py
index dc93d73..3259c4f 100644
--- a/simulation/loan_market.py
+++ b/simulation/loan_market.py
@@ -3,7 +3,7 @@ import logging
 
 from simulation.models import Order, Transaction
 from simulation.bank import Bank  # Bank í´ë˜ìŠ¤ ì„í¬íŠ¸
-from simulation.core_markets import Market # Import Market
+from simulation.core_markets import Market  # Import Market
 
 logger = logging.getLogger(__name__)
 
@@ -125,13 +125,11 @@ class LoanMarket(Market):
             # `self.markets["loan_market"].set_agents_ref(self.agents)`?
             # This is cleaner.
 
-            pass # Placeholder for diff, actual logic below
+            pass  # Placeholder for diff, actual logic below
 
             loan_amount = order.quantity
             interest_rate = order.price
-            duration = (
-                self.config_module.DEFAULT_LOAN_DURATION
-            )
+            duration = self.config_module.DEFAULT_LOAN_DURATION
 
             # Credit Jail Check via Agent Lookup (Assuming we have agent ref, see set_agents_ref)
             borrower_id = order.agent_id
@@ -155,9 +153,7 @@ class LoanMarket(Market):
                 # Bank calculates rate internally based on base rate + spread
                 # We ignore order.price (interest_rate) as the bank sets the rate
                 loan_id = self.bank.grant_loan(
-                    borrower_id=order.agent_id,
-                    amount=loan_amount,
-                    term_ticks=duration
+                    borrower_id=order.agent_id, amount=loan_amount, term_ticks=duration
                 )
             # Fetch details if needed or assume success if ID returned
             # Legacy expected loan_details but we only got ID.
@@ -191,7 +187,7 @@ class LoanMarket(Market):
 
             # Update Bank State (Principal Reduction)
             if hasattr(self.bank, "process_repayment"):
-                 self.bank.process_repayment(loan_id, repay_amount)
+                self.bank.process_repayment(loan_id, repay_amount)
 
             # Transaction: Money from Borrower (Buyer) to Bank (Seller)
             # Transaction: Money from Borrower (Buyer) to Bank (Seller)
@@ -201,7 +197,7 @@ class LoanMarket(Market):
                     item_id="loan_repaid",
                     quantity=repay_amount,
                     price=1.0,
-                    buyer_id=order.agent_id, # Agent pays money (Assets decrease)
+                    buyer_id=order.agent_id,  # Agent pays money (Assets decrease)
                     seller_id=self.bank.id,  # Bank gets money (Assets increase)
                     transaction_type="loan",
                     time=current_tick,
@@ -225,8 +221,8 @@ class LoanMarket(Market):
                         item_id="deposit",
                         quantity=amount,
                         price=1.0,
-                        buyer_id=order.agent_id,   # Agent pays
-                        seller_id=self.bank.id,    # Bank receives
+                        buyer_id=order.agent_id,  # Agent pays
+                        seller_id=self.bank.id,  # Bank receives
                         transaction_type="deposit",
                         time=current_tick,
                         market_id=self.id,
@@ -251,7 +247,7 @@ class LoanMarket(Market):
                         item_id="withdrawal",
                         quantity=amount,
                         price=1.0,
-                        buyer_id=self.bank.id,     # Bank pays
+                        buyer_id=self.bank.id,  # Bank pays
                         seller_id=order.agent_id,  # Agent receives
                         transaction_type="withdrawal",
                         time=current_tick,
@@ -263,7 +259,9 @@ class LoanMarket(Market):
                     extra=log_extra,
                 )
             else:
-                logger.warning(f"Withdrawal failed for {order.agent_id}", extra=log_extra)
+                logger.warning(
+                    f"Withdrawal failed for {order.agent_id}", extra=log_extra
+                )
 
         else:  # Handle unknown order types
             logger.warning(f"Unknown order type: {order.order_type}", extra=log_extra)
@@ -340,4 +338,3 @@ class LoanMarket(Market):
     def clear_orders(self) -> None:
         """LoanMarketì€ ë§¤ í‹± ì´ˆê¸°í™”í•  ë‚´ë¶€ ìƒíƒœê°€ ì—†ìŠµë‹ˆë‹¤."""
         self.matched_transactions = []
-
diff --git a/simulation/markets/order_book_market.py b/simulation/markets/order_book_market.py
index 353eb6a..e2f9cae 100644
--- a/simulation/markets/order_book_market.py
+++ b/simulation/markets/order_book_market.py
@@ -20,33 +20,38 @@ class OrderBookMarket(Market):
             market_id (str): ì‹œì¥ì˜ ê³ ìœ  ID (ì˜ˆ: 'goods_market', 'labor_market').
             logger (logging.Logger, optional): ë¡œê¹…ì„ ìœ„í•œ Logger ì¸ìŠ¤í„´ìŠ¤. ê¸°ë³¸ê°’ì€ None.
         """
-        super().__init__(market_id=market_id, logger=logger) # Call parent constructor to set self.id and logger
+        super().__init__(
+            market_id=market_id, logger=logger
+        )  # Call parent constructor to set self.id and logger
         self.id = market_id
         self.buy_orders: Dict[str, List[Order]] = {}
         self.sell_orders: Dict[str, List[Order]] = {}
         self.daily_avg_price: Dict[str, float] = {}
         self.daily_total_volume: Dict[str, float] = {}
         self.last_traded_prices: Dict[str, float] = {}
-        
+
         # --- GEMINI_ADDITION: Persist signals across ticks ---
         self.cached_best_bid: Dict[str, float] = {}
         self.cached_best_ask: Dict[str, float] = {}
-        
+
         self.logger.info(
             f"OrderBookMarket {self.id} initialized.",
             extra={"tick": 0, "market_id": self.id, "tags": ["init", "market"]},
         )
 
-
     def clear_orders(self) -> None:
         """í˜„ì¬ í‹±ì˜ ëª¨ë“  ì£¼ë¬¸ì„ ì´ˆê¸°í™”í•©ë‹ˆë‹¤. ì´ˆê¸°í™” ì „ Best Bid/Askë¥¼ ìºì‹±í•©ë‹ˆë‹¤."""
         # Cache best prices for signal persistence
-        for item_id in set(list(self.buy_orders.keys()) + list(self.sell_orders.keys())):
+        for item_id in set(
+            list(self.buy_orders.keys()) + list(self.sell_orders.keys())
+        ):
             bid = self.get_best_bid(item_id)
-            if bid is not None: self.cached_best_bid[item_id] = bid
-            
+            if bid is not None:
+                self.cached_best_bid[item_id] = bid
+
             ask = self.get_best_ask(item_id)
-            if ask is not None: self.cached_best_ask[item_id] = ask
+            if ask is not None:
+                self.cached_best_ask[item_id] = ask
 
         self.buy_orders.clear()
         self.sell_orders.clear()
@@ -166,72 +171,83 @@ class OrderBookMarket(Market):
                 targeted_buys.append(order)
             else:
                 general_buys.append(order)
-        
+
         # 2. Process Targeted Buys
         # Targeted buys ignore price sorting? No, usually handled FIFO or by price within target.
         # But here we just iterate list. Detailed sorting within target isn't critical for V1.
-        
+
         # Create a map of Sell orders for fast lookup by AgentID
         # Dictionary of AgentID -> List[Order]
         sell_map: Dict[int, List[Order]] = {}
         for s_order in sell_orders_list:
-             if s_order.agent_id not in sell_map:
-                 sell_map[s_order.agent_id] = []
-             sell_map[s_order.agent_id].append(s_order)
-             
+            if s_order.agent_id not in sell_map:
+                sell_map[s_order.agent_id] = []
+            sell_map[s_order.agent_id].append(s_order)
+
         remaining_targeted_buys = []
-        
+
         for b_order in targeted_buys:
-             target_id = b_order.target_agent_id
-             # Check if target seller has stock
-             target_asks = sell_map.get(target_id)
-             
-             if target_asks and target_asks[0].quantity > 0:
-                 s_order = target_asks[0] # Pick best price ask from this seller (assuming sorted)
-                 
-                 # Price Check: Does buyer accept seller's price?
-                 if b_order.price >= s_order.price:
-                     trade_price = s_order.price # Brand Loyalty -> Pay Ask Price
-                     trade_quantity = min(b_order.quantity, s_order.quantity)
-                     
-                     transaction = Transaction(
-                         item_id=item_id,
-                         quantity=trade_quantity,
-                         price=trade_price,
-                         buyer_id=b_order.agent_id,
-                         seller_id=s_order.agent_id,
-                         market_id=self.id,
-                         transaction_type="labor" if "labor" in self.id else ("housing" if "housing" in self.id else "goods"),
-                         time=current_tick,
-                         quality=s_order.brand_info.get("quality", 1.0) if s_order.brand_info else 1.0
-                     )
-                     self.last_traded_prices[item_id] = trade_price
-                     transactions.append(transaction)
-                     
-                     self.logger.info(
-                         f"MATCHED_TARGETED | {trade_quantity:.2f} of {item_id} at {trade_price:.2f}. "
-                         f"Buyer {b_order.agent_id} -> Seller {s_order.agent_id} (Targeted)",
-                         extra={**log_extra, "buyer_id":b_order.agent_id, "seller_id":s_order.agent_id, "match_type": "targeted"}
-                     )
-                     
-                     b_order.quantity -= trade_quantity
-                     s_order.quantity -= trade_quantity
-                     
-                     if s_order.quantity <= 0.001:
-                         target_asks.pop(0) # Remove exhausted ask
-                         
-                 else:
-                     # Price mismatch (Buyer willing to pay X, Seller wants Y, X < Y)
-                     # Transaction fails. Buyer waits or enters general pool?
-                     # Spec says "Strict Targeting -> Fails".
-                     pass
-             else:
-                 # Target sold out or not present
-                 pass
-             
-             if b_order.quantity > 0.001:
-                 # Failed to fill completely
-                 remaining_targeted_buys.append(b_order)
+            target_id = b_order.target_agent_id
+            # Check if target seller has stock
+            target_asks = sell_map.get(target_id)
+
+            if target_asks and target_asks[0].quantity > 0:
+                s_order = target_asks[
+                    0
+                ]  # Pick best price ask from this seller (assuming sorted)
+
+                # Price Check: Does buyer accept seller's price?
+                if b_order.price >= s_order.price:
+                    trade_price = s_order.price  # Brand Loyalty -> Pay Ask Price
+                    trade_quantity = min(b_order.quantity, s_order.quantity)
+
+                    transaction = Transaction(
+                        item_id=item_id,
+                        quantity=trade_quantity,
+                        price=trade_price,
+                        buyer_id=b_order.agent_id,
+                        seller_id=s_order.agent_id,
+                        market_id=self.id,
+                        transaction_type="labor"
+                        if "labor" in self.id
+                        else ("housing" if "housing" in self.id else "goods"),
+                        time=current_tick,
+                        quality=s_order.brand_info.get("quality", 1.0)
+                        if s_order.brand_info
+                        else 1.0,
+                    )
+                    self.last_traded_prices[item_id] = trade_price
+                    transactions.append(transaction)
+
+                    self.logger.info(
+                        f"MATCHED_TARGETED | {trade_quantity:.2f} of {item_id} at {trade_price:.2f}. "
+                        f"Buyer {b_order.agent_id} -> Seller {s_order.agent_id} (Targeted)",
+                        extra={
+                            **log_extra,
+                            "buyer_id": b_order.agent_id,
+                            "seller_id": s_order.agent_id,
+                            "match_type": "targeted",
+                        },
+                    )
+
+                    b_order.quantity -= trade_quantity
+                    s_order.quantity -= trade_quantity
+
+                    if s_order.quantity <= 0.001:
+                        target_asks.pop(0)  # Remove exhausted ask
+
+                else:
+                    # Price mismatch (Buyer willing to pay X, Seller wants Y, X < Y)
+                    # Transaction fails. Buyer waits or enters general pool?
+                    # Spec says "Strict Targeting -> Fails".
+                    pass
+            else:
+                # Target sold out or not present
+                pass
+
+            if b_order.quantity > 0.001:
+                # Failed to fill completely
+                remaining_targeted_buys.append(b_order)
 
         # Fallback: Add remaining targeted buys to general pool
         # This fixes "Starvation by Brand Loyalty" where buyers wouldn't buy from others if target failed.
@@ -246,31 +262,31 @@ class OrderBookMarket(Market):
             remaining_sells.extend(s_list)
         # Sort by price (asc) for general matching
         remaining_sells.sort(key=lambda o: o.price)
-        
+
         # General Matching Loop
         idx_b = 0
         idx_s = 0
-        
+
         while idx_b < len(general_buys) and idx_s < len(remaining_sells):
             b_order = general_buys[idx_b]
             s_order = remaining_sells[idx_s]
-            
+
             if b_order.quantity <= 0.001:
                 idx_b += 1
                 continue
             if s_order.quantity <= 0.001:
                 idx_s += 1
                 continue
-                
+
             if b_order.price >= s_order.price:
                 # Labor Market Logic
                 if self.id == "labor" or self.id == "research_labor":
                     trade_price = b_order.price
                 else:
                     trade_price = (b_order.price + s_order.price) / 2
-                
+
                 trade_quantity = min(b_order.quantity, s_order.quantity)
-                
+
                 transaction = Transaction(
                     item_id=item_id,
                     quantity=trade_quantity,
@@ -278,36 +294,49 @@ class OrderBookMarket(Market):
                     buyer_id=b_order.agent_id,
                     seller_id=s_order.agent_id,
                     market_id=self.id,
-                    transaction_type="labor" if "labor" in self.id else ("housing" if "housing" in self.id else "goods"),
+                    transaction_type="labor"
+                    if "labor" in self.id
+                    else ("housing" if "housing" in self.id else "goods"),
                     time=current_tick,
-                    quality=s_order.brand_info.get("quality", 1.0) if s_order.brand_info else 1.0
+                    quality=s_order.brand_info.get("quality", 1.0)
+                    if s_order.brand_info
+                    else 1.0,
                 )
                 self.last_traded_prices[item_id] = trade_price
                 transactions.append(transaction)
-                
+
                 self.logger.info(
                     f"MATCHED_GENERAL | {trade_quantity:.2f} of {item_id} at {trade_price:.2f}. "
                     f"Buyer {b_order.agent_id} -> Seller {s_order.agent_id}",
-                    extra={**log_extra, "buyer_id":b_order.agent_id, "seller_id":s_order.agent_id, "match_type": "general"}
+                    extra={
+                        **log_extra,
+                        "buyer_id": b_order.agent_id,
+                        "seller_id": s_order.agent_id,
+                        "match_type": "general",
+                    },
                 )
-                
+
                 b_order.quantity -= trade_quantity
                 s_order.quantity -= trade_quantity
             else:
-                 # Prices don't cross anymore (lists are sorted)
-                 break
-        
+                # Prices don't cross anymore (lists are sorted)
+                break
+
         # Re-save lists to cleanup empty orders
         # (Actually the main lists hold references, but we need to ensure self.buy_orders refers to the updated state)
         # Simplification: Just keep non-empty orders in the main list.
         # We need to combine remaining_targeted and remaining_general
-        
-        new_buy_list = [o for o in (remaining_targeted_buys + general_buys) if o.quantity > 0.001]
-        new_buy_list.sort(key=lambda o: o.price, reverse=True) # Maintain sorted invariant
-        
+
+        new_buy_list = [
+            o for o in (remaining_targeted_buys + general_buys) if o.quantity > 0.001
+        ]
+        new_buy_list.sort(
+            key=lambda o: o.price, reverse=True
+        )  # Maintain sorted invariant
+
         new_sell_list = [o for o in remaining_sells if o.quantity > 0.001]
         new_sell_list.sort(key=lambda o: o.price)
-        
+
         self.buy_orders[item_id] = new_buy_list
         self.sell_orders[item_id] = new_sell_list
 
diff --git a/simulation/markets/stock_market.py b/simulation/markets/stock_market.py
index 44762ac..11ac46a 100644
--- a/simulation/markets/stock_market.py
+++ b/simulation/markets/stock_market.py
@@ -21,7 +21,7 @@ logger = logging.getLogger(__name__)
 class StockMarket(Market):
     """
     ì£¼ì‹ ì‹œì¥ í´ë˜ìŠ¤.
-    
+
     ê¸°ì—… ì£¼ì‹ì˜ ë§¤ìˆ˜/ë§¤ë„ ì£¼ë¬¸ì„ ê´€ë¦¬í•˜ê³ , ê±°ë˜ë¥¼ ë§¤ì¹­í•©ë‹ˆë‹¤.
     ì£¼ê°€ëŠ” ê¸°ì—… ìˆœìì‚°ê°€ì¹˜(Book Value) ê¸°ë°˜ìœ¼ë¡œ ê¸°ì¤€ê°€ë¥¼ ì„¤ì •í•˜ê³ ,
     ì‹¤ì œ ê±°ë˜ëŠ” í˜¸ê°€ ë§¤ì¹­ìœ¼ë¡œ ì´ë£¨ì–´ì§‘ë‹ˆë‹¤.
@@ -35,24 +35,26 @@ class StockMarket(Market):
         self.id = "stock_market"
         self.config_module = config_module
         self.logger = logger or logging.getLogger(__name__)
-        
+
         # ê¸°ì—…ë³„ ì£¼ë¬¸ì„œ (firm_id -> List[StockOrder])
-        self.buy_orders: Dict[int, List[StockOrder]] = defaultdict(list) # type: ignore
-        self.sell_orders: Dict[int, List[StockOrder]] = defaultdict(list) # type: ignore
-        
+        self.buy_orders: Dict[int, List[StockOrder]] = defaultdict(list)  # type: ignore
+        self.sell_orders: Dict[int, List[StockOrder]] = defaultdict(list)  # type: ignore
+
         # ê°€ê²© ë° ê±°ë˜ëŸ‰ ì¶”ì 
-        self.last_prices: Dict[int, float] = {}      # ìµœê·¼ ê±°ë˜ê°€
-        self.reference_prices: Dict[int, float] = {} # ê¸°ì¤€ê°€ (ìˆœìì‚°ê°€ì¹˜ ê¸°ë°˜)
-        self.daily_volumes: Dict[int, float] = {}    # ì¼ì¼ ê±°ë˜ëŸ‰
-        self.daily_high: Dict[int, float] = {}       # ì¼ì¼ ìµœê³ ê°€
-        self.daily_low: Dict[int, float] = {}        # ì¼ì¼ ìµœì €ê°€
-        
+        self.last_prices: Dict[int, float] = {}  # ìµœê·¼ ê±°ë˜ê°€
+        self.reference_prices: Dict[int, float] = {}  # ê¸°ì¤€ê°€ (ìˆœìì‚°ê°€ì¹˜ ê¸°ë°˜)
+        self.daily_volumes: Dict[int, float] = {}  # ì¼ì¼ ê±°ë˜ëŸ‰
+        self.daily_high: Dict[int, float] = {}  # ì¼ì¼ ìµœê³ ê°€
+        self.daily_low: Dict[int, float] = {}  # ì¼ì¼ ìµœì €ê°€
+
         # ì£¼ë¬¸ ìƒì„± í‹± ì¶”ì  (ë§Œë£Œ ê´€ë¦¬ìš©)
         self.order_ticks: Dict[str, int] = {}  # order_id -> created_tick
 
         # ì£¼ì£¼ ëª…ë¶€ (firm_id -> agent_id -> quantity)
         # Conservation of Mass ê²€ì¦ ë° ë°°ë‹¹ ì§€ê¸‰ ë“±ì„ ìœ„í•œ ì¤‘ì•™ ë ˆì§€ìŠ¤íŠ¸ë¦¬
-        self.shareholders: Dict[int, Dict[int, float]] = defaultdict(lambda: defaultdict(float))
+        self.shareholders: Dict[int, Dict[int, float]] = defaultdict(
+            lambda: defaultdict(float)
+        )
 
     def update_shareholder(self, agent_id: int, firm_id: int, quantity: float) -> None:
         """
@@ -69,16 +71,16 @@ class StockMarket(Market):
     def update_reference_prices(self, firms: Dict[int, "Firm"]) -> None:
         """
         ê¸°ì—…ë“¤ì˜ ìˆœìì‚°ê°€ì¹˜ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ê¸°ì¤€ ì£¼ê°€ë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
-        
+
         Args:
             firms: ê¸°ì—… ID -> Firm ê°ì²´ ë§µ
         """
         multiplier = getattr(self.config_module, "STOCK_BOOK_VALUE_MULTIPLIER", 1.0)
-        
+
         for firm_id, firm in firms.items():
             if not getattr(firm, "is_active", True):
                 continue
-                
+
             book_value = self._calculate_book_value_per_share(firm)
             self.reference_prices[firm_id] = max(0.01, book_value * multiplier)
 
@@ -127,7 +129,9 @@ class StockMarket(Market):
             return None
         return min(order.price for order in orders)
 
-    def place_order(self, order: Union[Order, StockOrder], tick: int) -> List[Transaction]:
+    def place_order(
+        self, order: Union[Order, StockOrder], tick: int
+    ) -> List[Transaction]:
         """
         ì£¼ì‹ ì£¼ë¬¸ì„ ì œì¶œí•©ë‹ˆë‹¤.
         """
@@ -137,19 +141,23 @@ class StockMarket(Market):
         # ê°€ê²© ì œí•œ í™•ì¸ (ìƒí•˜í•œê°€)
         limit_rate = getattr(self.config_module, "STOCK_PRICE_LIMIT_RATE", 0.10)
         ref_price = self.reference_prices.get(order.firm_id, order.price)
-        
+
         min_price = ref_price * (1 - limit_rate)
         max_price = ref_price * (1 + limit_rate)
-        
+
         if order.price < min_price or order.price > max_price:
             self.logger.warning(
                 f"Stock order price {order.price:.2f} out of limit range "
                 f"[{min_price:.2f}, {max_price:.2f}] for firm {order.firm_id}",
-                extra={"tick": tick, "agent_id": order.agent_id, "firm_id": order.firm_id}
+                extra={
+                    "tick": tick,
+                    "agent_id": order.agent_id,
+                    "firm_id": order.firm_id,
+                },
             )
             # ê°€ê²©ì„ ì œí•œ ë²”ìœ„ ë‚´ë¡œ ì¡°ì •
             order.price = max(min_price, min(max_price, order.price))
-        
+
         # ì£¼ë¬¸ ì¶”ê°€
         if order.order_type == "BUY":
             self.buy_orders[order.firm_id].append(order)
@@ -162,13 +170,13 @@ class StockMarket(Market):
         else:
             self.logger.warning(
                 f"Unknown stock order type: {order.order_type}",
-                extra={"tick": tick, "agent_id": order.agent_id}
+                extra={"tick": tick, "agent_id": order.agent_id},
             )
             return []
-        
+
         # ì£¼ë¬¸ ìƒì„± í‹± ê¸°ë¡
         self.order_ticks[order.id] = tick
-        
+
         self.logger.info(
             f"Stock {order.order_type} order placed: {order.quantity:.1f} shares "
             f"of firm {order.firm_id} at {order.price:.2f}",
@@ -179,49 +187,49 @@ class StockMarket(Market):
                 "order_type": order.order_type,
                 "quantity": order.quantity,
                 "price": order.price,
-                "tags": ["stock", "order"]
-            }
+                "tags": ["stock", "order"],
+            },
         )
         return []
 
     def match_orders(self, tick: int) -> List[Transaction]:
         """
         ëª¨ë“  ê¸°ì—…ì˜ ì£¼ì‹ ì£¼ë¬¸ì„ ë§¤ì¹­í•˜ì—¬ ê±°ë˜ë¥¼ ì„±ì‚¬ì‹œí‚µë‹ˆë‹¤.
-        
+
         Args:
             tick: í˜„ì¬ ì‹œë®¬ë ˆì´ì…˜ í‹±
-            
+
         Returns:
             ì„±ì‚¬ëœ ì£¼ì‹ ê±°ë˜ ëª©ë¡
         """
         all_transactions: List[Transaction] = []
-        
+
         # ëª¨ë“  ê¸°ì—…ì— ëŒ€í•´ ë§¤ì¹­ ìˆ˜í–‰
         all_firm_ids = set(self.buy_orders.keys()) | set(self.sell_orders.keys())
-        
+
         for firm_id in all_firm_ids:
             transactions = self._match_orders_for_firm(firm_id, tick)
             all_transactions.extend(transactions)
-        
+
         return all_transactions
 
     def _match_orders_for_firm(self, firm_id: int, tick: int) -> List[Transaction]:
         """íŠ¹ì • ê¸°ì—…ì˜ ì£¼ì‹ ì£¼ë¬¸ì„ ë§¤ì¹­í•©ë‹ˆë‹¤."""
         transactions: List[Transaction] = []
-        
+
         buy_orders = self.buy_orders.get(firm_id, [])
         sell_orders = self.sell_orders.get(firm_id, [])
-        
+
         while buy_orders and sell_orders:
             best_buy = buy_orders[0]
             best_sell = sell_orders[0]
-            
+
             # ë§¤ìˆ˜ê°€ >= ë§¤ë„ê°€ ì´ë©´ ê±°ë˜ ì„±ë¦½
             if best_buy.price >= best_sell.price:
                 # ê±°ë˜ ê°€ê²©: ë‘ í˜¸ê°€ì˜ í‰ê· 
                 trade_price = (best_buy.price + best_sell.price) / 2
                 trade_quantity = min(best_buy.quantity, best_sell.quantity)
-                
+
                 # ê±°ë˜ ìƒì„±
                 transaction = Transaction(
                     buyer_id=best_buy.agent_id,
@@ -234,17 +242,25 @@ class StockMarket(Market):
                     time=tick,
                 )
                 transactions.append(transaction)
-                
+
                 # ê°€ê²© ë° ê±°ë˜ëŸ‰ ì—…ë°ì´íŠ¸
                 self.last_prices[firm_id] = trade_price
-                self.daily_volumes[firm_id] = self.daily_volumes.get(firm_id, 0) + trade_quantity
-                
+                self.daily_volumes[firm_id] = (
+                    self.daily_volumes.get(firm_id, 0) + trade_quantity
+                )
+
                 # ì¼ì¼ ê³ ì €ê°€ ì—…ë°ì´íŠ¸
-                if firm_id not in self.daily_high or trade_price > self.daily_high[firm_id]:
+                if (
+                    firm_id not in self.daily_high
+                    or trade_price > self.daily_high[firm_id]
+                ):
                     self.daily_high[firm_id] = trade_price
-                if firm_id not in self.daily_low or trade_price < self.daily_low[firm_id]:
+                if (
+                    firm_id not in self.daily_low
+                    or trade_price < self.daily_low[firm_id]
+                ):
                     self.daily_low[firm_id] = trade_price
-                
+
                 self.logger.info(
                     f"Stock trade: {trade_quantity:.1f} shares of firm {firm_id} "
                     f"at {trade_price:.2f} (buyer: {best_buy.agent_id}, seller: {best_sell.agent_id})",
@@ -255,14 +271,14 @@ class StockMarket(Market):
                         "price": trade_price,
                         "buyer_id": best_buy.agent_id,
                         "seller_id": best_sell.agent_id,
-                        "tags": ["stock", "trade"]
-                    }
+                        "tags": ["stock", "trade"],
+                    },
                 )
-                
+
                 # ì£¼ë¬¸ ìˆ˜ëŸ‰ ì¡°ì •
                 best_buy.quantity -= trade_quantity
                 best_sell.quantity -= trade_quantity
-                
+
                 # ì™„ë£Œëœ ì£¼ë¬¸ ì œê±°
                 if best_buy.quantity <= 0:
                     buy_orders.pop(0)
@@ -273,46 +289,50 @@ class StockMarket(Market):
             else:
                 # ë” ì´ìƒ ë§¤ì¹­ ê°€ëŠ¥í•œ ì£¼ë¬¸ ì—†ìŒ
                 break
-        
+
         return transactions
 
     def clear_expired_orders(self, current_tick: int) -> int:
         """
         ë§Œë£Œëœ ì£¼ë¬¸ì„ ì œê±°í•©ë‹ˆë‹¤.
-        
+
         Args:
             current_tick: í˜„ì¬ ì‹œë®¬ë ˆì´ì…˜ í‹±
-            
+
         Returns:
             ì œê±°ëœ ì£¼ë¬¸ ìˆ˜
         """
         expiry_ticks = getattr(self.config_module, "STOCK_ORDER_EXPIRY_TICKS", 5)
         removed_count = 0
-        
+
         for firm_id in list(self.buy_orders.keys()):
             original_count = len(self.buy_orders[firm_id])
             self.buy_orders[firm_id] = [
-                order for order in self.buy_orders[firm_id]
-                if current_tick - self.order_ticks.get(order.id, current_tick) < expiry_ticks
+                order
+                for order in self.buy_orders[firm_id]
+                if current_tick - self.order_ticks.get(order.id, current_tick)
+                < expiry_ticks
             ]
             removed = original_count - len(self.buy_orders[firm_id])
             removed_count += removed
-        
+
         for firm_id in list(self.sell_orders.keys()):
             original_count = len(self.sell_orders[firm_id])
             self.sell_orders[firm_id] = [
-                order for order in self.sell_orders[firm_id]
-                if current_tick - self.order_ticks.get(order.id, current_tick) < expiry_ticks
+                order
+                for order in self.sell_orders[firm_id]
+                if current_tick - self.order_ticks.get(order.id, current_tick)
+                < expiry_ticks
             ]
             removed = original_count - len(self.sell_orders[firm_id])
             removed_count += removed
-        
+
         if removed_count > 0:
             self.logger.debug(
                 f"Cleared {removed_count} expired stock orders",
-                extra={"tick": current_tick, "tags": ["stock", "cleanup"]}
+                extra={"tick": current_tick, "tags": ["stock", "cleanup"]},
             )
-        
+
         return removed_count
 
     def reset_daily_stats(self) -> None:
diff --git a/simulation/metrics/economic_tracker.py b/simulation/metrics/economic_tracker.py
index 36a5b2d..39b5c1b 100644
--- a/simulation/metrics/economic_tracker.py
+++ b/simulation/metrics/economic_tracker.py
@@ -76,8 +76,10 @@ class EconomicIndicatorTracker:
         # Use get_financial_snapshot to include Capital Stock and Inventory in Total Assets
         total_firm_assets = sum(
             f.get_financial_snapshot().get("total_assets", f.assets)
-            if hasattr(f, "get_financial_snapshot") else f.assets
-            for f in firms if getattr(f, "is_active", False)
+            if hasattr(f, "get_financial_snapshot")
+            else f.assets
+            for f in firms
+            if getattr(f, "is_active", False)
         )
         record["total_household_assets"] = total_household_assets
         record["total_firm_assets"] = total_firm_assets
@@ -86,8 +88,10 @@ class EconomicIndicatorTracker:
         unemployed_households = 0
         for h in households:
             if getattr(h, "is_active", True):
-                if not hasattr(h, 'is_employed'):
-                    self.logger.error(f"TRACKER ERROR: Agent {h.id} in households list is not a Household! Type: {type(h)}")
+                if not hasattr(h, "is_employed"):
+                    self.logger.error(
+                        f"TRACKER ERROR: Agent {h.id} in households list is not a Household! Type: {type(h)}"
+                    )
                     continue
                 if not h.is_employed:
                     unemployed_households += 1
@@ -110,7 +114,11 @@ class EconomicIndicatorTracker:
         primary_food_key = "basic_food"
 
         for market_id, market in markets.items():
-            if market_id == "labor" or market_id == "loan_market" or market_id == "stock_market":
+            if (
+                market_id == "labor"
+                or market_id == "loan_market"
+                or market_id == "stock_market"
+            ):
                 continue
 
             if hasattr(market, "get_daily_avg_price"):
@@ -124,12 +132,12 @@ class EconomicIndicatorTracker:
                 # Check if this is a food item
                 if "food" in market_id:
                     if volume > 0:
-                         food_price_sum += avg_price * volume
-                         food_volume_sum += volume
+                        food_price_sum += avg_price * volume
+                        food_volume_sum += volume
                     elif avg_price > 0:
-                         # If no volume but has price (e.g. from asks), just track price?
-                         # For weighted avg, we need volume. If 0 volume, we can't weight it.
-                         pass
+                        # If no volume but has price (e.g. from asks), just track price?
+                        # For weighted avg, we need volume. If 0 volume, we can't weight it.
+                        pass
 
         if food_volume_sum > 0:
             record["food_avg_price"] = food_price_sum / food_volume_sum
@@ -138,9 +146,9 @@ class EconomicIndicatorTracker:
             # For simplicity, just use 0.0 or try to get from specific market
             f_market = markets.get(primary_food_key)
             if f_market and hasattr(f_market, "get_daily_avg_price"):
-                 record["food_avg_price"] = f_market.get_daily_avg_price() or 0.0
+                record["food_avg_price"] = f_market.get_daily_avg_price() or 0.0
             else:
-                 record["food_avg_price"] = 0.0
+                record["food_avg_price"] = 0.0
 
         record["food_trade_volume"] = food_volume_sum
 
@@ -156,7 +164,7 @@ class EconomicIndicatorTracker:
                 price = getattr(market, "current_price", None)
                 if price is None or price <= 0:
                     price = getattr(market, "avg_price", 0.0)
-                
+
                 if price > 0:
                     fallback_prices.append(price)
 
@@ -167,9 +175,7 @@ class EconomicIndicatorTracker:
 
         # ... other metric calculations ...
         total_production = sum(
-            f.current_production
-            for f in firms
-            if getattr(f, "is_active", False)
+            f.current_production for f in firms if getattr(f, "is_active", False)
         )
         record["total_production"] = total_production
 
@@ -200,7 +206,8 @@ class EconomicIndicatorTracker:
 
         record["avg_survival_need"] = (
             total_survival_need / active_households_count
-            if active_households_count > 0 else 0.0
+            if active_households_count > 0
+            else 0.0
         )
 
         # --- WO-043: Comprehensive Metrics ---
@@ -244,24 +251,30 @@ class EconomicIndicatorTracker:
 
         # --- Phase 23: Opportunity Index & Education Metrics ---
         # 1. Average Education Level
-        total_edu = sum(getattr(h, "education_level", 0.0) for h in households if getattr(h, "is_active", True))
-        record["avg_education_level"] = total_edu / total_households if total_households > 0 else 0.0
+        total_edu = sum(
+            getattr(h, "education_level", 0.0)
+            for h in households
+            if getattr(h, "is_active", True)
+        )
+        record["avg_education_level"] = (
+            total_edu / total_households if total_households > 0 else 0.0
+        )
 
         # 2. Brain Waste Count (Aptitude >= 0.8 but Education < Level 2)
         brain_waste = [
-            h for h in households 
-            if getattr(h, "is_active", True) 
-            and getattr(h, "aptitude", 0.0) >= 0.8 
+            h
+            for h in households
+            if getattr(h, "is_active", True)
+            and getattr(h, "aptitude", 0.0) >= 0.8
             and getattr(h, "education_level", 0.0) < 2.0
         ]
         record["brain_waste_count"] = len(brain_waste)
 
         # 3. Government Education Spending (from direct state)
         # Note: This relies on Simulation passing the spent amount or Government state being visible.
-        # However, track() doesn't receive Government instance directly. 
+        # However, track() doesn't receive Government instance directly.
         # But we can assume it will be added to record via engine integration or by passing govt.
 
-
         for field in self.all_fieldnames:
             record.setdefault(field, 0.0)
 
diff --git a/simulation/metrics/inequality_tracker.py b/simulation/metrics/inequality_tracker.py
index ae9de23..84030ad 100644
--- a/simulation/metrics/inequality_tracker.py
+++ b/simulation/metrics/inequality_tracker.py
@@ -21,62 +21,62 @@ class InequalityTracker:
 
     def __init__(self, config_module: Any):
         self.config_module = config_module
-        
+
         # ì´ì „ í‹±ì˜ ë¶„ìœ„ ì •ë³´ (í‹± ê°„ ì´ë™ ì¶”ì ìš©)
         self.previous_quintiles: Dict[int, int] = {}  # household_id -> quintile (1-5)
-        
+
         # ì´ˆê¸° ë¶„ìœ„ ì •ë³´ (ì½”í˜¸íŠ¸ ì¶”ì ìš© - ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘ ì‹œì )
-        self.initial_quintiles: Dict[int, int] = {}   # household_id -> initial quintile
+        self.initial_quintiles: Dict[int, int] = {}  # household_id -> initial quintile
         self.cohort_initialized: bool = False
-        
+
         # ì „ì´ í–‰ë ¬ (initial_quintile -> current_quintile -> count)
         self.transition_matrix: Dict[int, Dict[int, int]] = {
             i: {j: 0 for j in range(1, 6)} for i in range(1, 6)
         }
-        
+
     def calculate_gini_coefficient(self, values: List[float]) -> float:
         """
         ì§€ë‹ˆê³„ìˆ˜ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
-        
+
         Args:
             values: ìì‚°/ì†Œë“ ê°’ ë¦¬ìŠ¤íŠ¸
-            
+
         Returns:
             ì§€ë‹ˆê³„ìˆ˜ (0~1, ë†’ì„ìˆ˜ë¡ ë¶ˆí‰ë“±)
         """
         if not values or len(values) < 2:
             return 0.0
-        
+
         n = len(values)
         sorted_values = sorted(values)
-        
+
         # ëª¨ë“  ê°’ì´ 0ì¸ ê²½ìš°
         if sum(sorted_values) == 0:
             return 0.0
-        
+
         # ì§€ë‹ˆê³„ìˆ˜ ê³µì‹: G = (2 * sum(i * x_i) - (n+1) * sum(x_i)) / (n * sum(x_i))
         cumsum = sum((i + 1) * x for i, x in enumerate(sorted_values))
         total = sum(sorted_values)
-        
+
         gini = (2 * cumsum - (n + 1) * total) / (n * total)
         return max(0.0, min(1.0, gini))
-    
+
     def _assign_quintiles(self, households: List["Household"]) -> Dict[int, int]:
         """ê°€ê³„ë“¤ì— ë¶„ìœ„ë¥¼ í• ë‹¹í•©ë‹ˆë‹¤."""
         if not households:
             return {}
-        
+
         sorted_households = sorted(households, key=lambda h: h.assets)
         n = len(sorted_households)
         quintile_size = n // 5 if n >= 5 else 1
-        
+
         quintiles: Dict[int, int] = {}
         for i, h in enumerate(sorted_households):
             quintile = min(5, i // quintile_size + 1) if quintile_size > 0 else 1
             quintiles[h.id] = quintile
-        
+
         return quintiles
-    
+
     def initialize_cohort(self, households: List["Household"]) -> None:
         """
         ì½”í˜¸íŠ¸ ì¶”ì ì„ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
@@ -84,46 +84,44 @@ class InequalityTracker:
         """
         self.initial_quintiles = self._assign_quintiles(households)
         self.cohort_initialized = True
-        self.transition_matrix = {
-            i: {j: 0 for j in range(1, 6)} for i in range(1, 6)
-        }
-        
+        self.transition_matrix = {i: {j: 0 for j in range(1, 6)} for i in range(1, 6)}
+
         logger.info(
             f"Cohort initialized with {len(households)} households",
-            extra={"tags": ["inequality", "cohort"]}
+            extra={"tags": ["inequality", "cohort"]},
         )
-    
+
     def calculate_quintile_distribution(
         self, households: List["Household"]
     ) -> Dict[str, Any]:
         """
         ìì‚° ê¸°ì¤€ 5ë¶„ìœ„ ë¶„í¬ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
-        
+
         Returns:
             ë¶„ìœ„ë³„ ê°€ê³„ ìˆ˜, í‰ê·  ìì‚°, ì ìœ ìœ¨
         """
         if not households:
             return {}
-        
+
         # ìì‚° ìˆœìœ¼ë¡œ ì •ë ¬
         sorted_households = sorted(households, key=lambda h: h.assets)
         n = len(sorted_households)
         quintile_size = n // 5
-        
+
         quintiles: Dict[int, List["Household"]] = {i: [] for i in range(1, 6)}
-        
+
         for i, h in enumerate(sorted_households):
             quintile = min(5, i // quintile_size + 1) if quintile_size > 0 else 1
             quintiles[quintile].append(h)
-        
+
         # ë¶„ìœ„ë³„ í†µê³„ ê³„ì‚°
         total_assets = sum(h.assets for h in households)
         result: Dict[str, Any] = {}
-        
+
         for q in range(1, 6):
             q_households = quintiles[q]
             q_assets = sum(h.assets for h in q_households)
-            
+
             result[f"quintile_{q}_count"] = len(q_households)
             result[f"quintile_{q}_avg_assets"] = (
                 q_assets / len(q_households) if q_households else 0.0
@@ -131,15 +129,15 @@ class InequalityTracker:
             result[f"quintile_{q}_wealth_share"] = (
                 q_assets / total_assets if total_assets > 0 else 0.0
             )
-        
+
         return result
-    
+
     def calculate_social_mobility(
         self, households: List["Household"]
     ) -> Dict[str, Any]:
         """
         ê³„ì¸µ ì´ë™ ì§€í‘œë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤ (í‹± ê°„ ë‹¨ê¸° ì´ë™).
-        
+
         Returns:
             ìƒí–¥/í•˜í–¥/ìœ ì§€ ì´ë™ ìˆ˜, ì´ë™ì„± ì§€ìˆ˜
         """
@@ -150,17 +148,17 @@ class InequalityTracker:
                 "stable_count": 0,
                 "mobility_index": 0.0,
             }
-        
+
         current_quintiles = self._assign_quintiles(households)
-        
+
         # ì´ë™ ê³„ì‚°
         upward = 0
         downward = 0
         stable = 0
-        
+
         for h_id, current_q in current_quintiles.items():
             prev_q = self.previous_quintiles.get(h_id)
-            
+
             if prev_q is None:
                 stable += 1  # ì²« í‹±
             elif current_q > prev_q:
@@ -169,28 +167,28 @@ class InequalityTracker:
                 downward += 1
             else:
                 stable += 1
-        
+
         # ì´ë™ì„± ì§€ìˆ˜: (ìƒí–¥ + í•˜í–¥) / ì´ ê°€ê³„ ìˆ˜
         total = len(households)
         mobility_index = (upward + downward) / total if total > 0 else 0.0
-        
+
         # í˜„ì¬ ë¶„ìœ„ ì €ì¥ (ë‹¤ìŒ í‹± ë¹„êµìš©)
         self.previous_quintiles = current_quintiles.copy()
-        
+
         return {
             "upward_mobility_count": upward,
             "downward_mobility_count": downward,
             "stable_count": stable,
             "mobility_index": mobility_index,
         }
-    
+
     def calculate_longitudinal_mobility(
         self, households: List["Household"]
     ) -> Dict[str, Any]:
         """
         ì½”í˜¸íŠ¸ ê¸°ë°˜ ì¢…ë‹¨ ê³„ì¸µ ì´ë™ì„ ê³„ì‚°í•©ë‹ˆë‹¤.
         ì´ˆê¸° ë¶„ìœ„ì—ì„œ í˜„ì¬ ë¶„ìœ„ë¡œì˜ ì´ë™ì„ ì¶”ì í•©ë‹ˆë‹¤.
-        
+
         Returns:
             - ì´ˆê¸° í•˜ìœ„ì¸µ(1-2ë¶„ìœ„) â†’ í˜„ì¬ ìƒìœ„ì¸µ(4-5ë¶„ìœ„) ìƒìŠ¹ ìˆ˜
             - ì´ˆê¸° ìƒìœ„ì¸µ(4-5ë¶„ìœ„) â†’ í˜„ì¬ í•˜ìœ„ì¸µ(1-2ë¶„ìœ„) í•˜ë½ ìˆ˜
@@ -204,52 +202,48 @@ class InequalityTracker:
                 "top_to_bottom_rate": 0.0,
                 "transition_matrix": {},
             }
-        
+
         current_quintiles = self._assign_quintiles(households)
-        
+
         # ì „ì´ í–‰ë ¬ ì´ˆê¸°í™”
-        self.transition_matrix = {
-            i: {j: 0 for j in range(1, 6)} for i in range(1, 6)
-        }
-        
+        self.transition_matrix = {i: {j: 0 for j in range(1, 6)} for i in range(1, 6)}
+
         # ì¢…ë‹¨ ì´ë™ ê³„ì‚°
         bottom_to_top = 0  # ì´ˆê¸° 1-2ë¶„ìœ„ â†’ í˜„ì¬ 4-5ë¶„ìœ„
         top_to_bottom = 0  # ì´ˆê¸° 4-5ë¶„ìœ„ â†’ í˜„ì¬ 1-2ë¶„ìœ„
-        
+
         initial_bottom_count = 0  # ì´ˆê¸° í•˜ìœ„ì¸µ ì´ ìˆ˜
-        initial_top_count = 0      # ì´ˆê¸° ìƒìœ„ì¸µ ì´ ìˆ˜
-        
+        initial_top_count = 0  # ì´ˆê¸° ìƒìœ„ì¸µ ì´ ìˆ˜
+
         for h_id, current_q in current_quintiles.items():
             initial_q = self.initial_quintiles.get(h_id)
-            
+
             if initial_q is None:
                 continue  # ì‹œë®¬ë ˆì´ì…˜ ì¤‘ê°„ì— ì¶”ê°€ëœ ê°€ê³„
-            
+
             # ì „ì´ í–‰ë ¬ ì—…ë°ì´íŠ¸
             self.transition_matrix[initial_q][current_q] += 1
-            
+
             # í•˜ìœ„ì¸µ â†’ ìƒìœ„ì¸µ
             if initial_q <= 2:
                 initial_bottom_count += 1
                 if current_q >= 4:
                     bottom_to_top += 1
-            
+
             # ìƒìœ„ì¸µ â†’ í•˜ìœ„ì¸µ
             if initial_q >= 4:
                 initial_top_count += 1
                 if current_q <= 2:
                     top_to_bottom += 1
-        
+
         # ë¹„ìœ¨ ê³„ì‚°
         bottom_to_top_rate = (
-            bottom_to_top / initial_bottom_count 
-            if initial_bottom_count > 0 else 0.0
+            bottom_to_top / initial_bottom_count if initial_bottom_count > 0 else 0.0
         )
         top_to_bottom_rate = (
-            top_to_bottom / initial_top_count 
-            if initial_top_count > 0 else 0.0
+            top_to_bottom / initial_top_count if initial_top_count > 0 else 0.0
         )
-        
+
         return {
             "bottom_to_top_count": bottom_to_top,
             "top_to_bottom_count": top_to_bottom,
@@ -259,27 +253,27 @@ class InequalityTracker:
             "initial_top_count": initial_top_count,
             "transition_matrix": self.transition_matrix,
         }
-    
+
     def get_transition_probability_matrix(self) -> Dict[int, Dict[int, float]]:
         """
         ì „ì´ í™•ë¥  í–‰ë ¬ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
         ê° ì´ˆê¸° ë¶„ìœ„ì—ì„œ ë‹¤ë¥¸ ë¶„ìœ„ë¡œ ì´ë™í•  í™•ë¥ ì„ ê³„ì‚°í•©ë‹ˆë‹¤.
         """
         prob_matrix: Dict[int, Dict[int, float]] = {}
-        
+
         for initial_q in range(1, 6):
             row = self.transition_matrix.get(initial_q, {})
             row_total = sum(row.values())
-            
+
             prob_matrix[initial_q] = {}
             for current_q in range(1, 6):
                 count = row.get(current_q, 0)
                 prob_matrix[initial_q][current_q] = (
                     count / row_total if row_total > 0 else 0.0
                 )
-        
+
         return prob_matrix
-    
+
     def calculate_wealth_distribution(
         self,
         households: List["Household"],
@@ -290,83 +284,88 @@ class InequalityTracker:
         """
         if not households:
             return {}
-        
+
         # ì½”í˜¸íŠ¸ ì´ˆê¸°í™” (ì²« í˜¸ì¶œ ì‹œ)
         if not self.cohort_initialized:
             self.initialize_cohort(households)
-        
+
         # ìì‚° ë°ì´í„° ìˆ˜ì§‘
         total_assets = [h.assets for h in households]
-        
+
         # ê¸ˆìœµìì‚° (í˜„ê¸ˆ + ì£¼ì‹ í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜)
         financial_assets = []
         stock_holdings = []
-        
+
         for h in households:
             portfolio_value = 0.0
             total_shares = 0.0
-            
+
             if stock_market is not None:
                 for firm_id, shares in h.shares_owned.items():
                     price = stock_market.get_stock_price(firm_id) or 0.0
                     portfolio_value += shares * price
                     total_shares += shares
-            
+
             financial_assets.append(h.assets + portfolio_value)
             stock_holdings.append(portfolio_value)
-        
+
         # ë¶„ìœ„ ê³„ì‚°
         quintile_data = self.calculate_quintile_distribution(households)
         mobility_data = self.calculate_social_mobility(households)
         longitudinal_data = self.calculate_longitudinal_mobility(households)
-        
+
         # í‰ê· /ì¤‘ìœ„ ê³„ì‚°
         mean_assets = sum(total_assets) / len(total_assets)
         median_assets = median(total_assets)
-        
+
         return {
             "gini_total_assets": self.calculate_gini_coefficient(total_assets),
             "gini_financial_assets": self.calculate_gini_coefficient(financial_assets),
             "gini_stock_holdings": self.calculate_gini_coefficient(stock_holdings),
-            "top_10_pct_wealth_share": self._calculate_top_percentile_share(total_assets, 0.1),
-            "bottom_50_pct_wealth_share": self._calculate_bottom_percentile_share(total_assets, 0.5),
+            "top_10_pct_wealth_share": self._calculate_top_percentile_share(
+                total_assets, 0.1
+            ),
+            "bottom_50_pct_wealth_share": self._calculate_bottom_percentile_share(
+                total_assets, 0.5
+            ),
             "mean_household_assets": mean_assets,
             "median_household_assets": median_assets,
-            "mean_to_median_ratio": mean_assets / median_assets if median_assets > 0 else 1.0,
+            "mean_to_median_ratio": mean_assets / median_assets
+            if median_assets > 0
+            else 1.0,
             **quintile_data,
             **mobility_data,
             **longitudinal_data,
         }
-    
+
     def _calculate_top_percentile_share(
         self, values: List[float], percentile: float
     ) -> float:
         """ìƒìœ„ X%ì˜ ìì‚° ì ìœ ìœ¨ì„ ê³„ì‚°í•©ë‹ˆë‹¤."""
         if not values:
             return 0.0
-        
+
         sorted_values = sorted(values, reverse=True)
         n = len(sorted_values)
         top_n = max(1, int(n * percentile))
-        
+
         top_sum = sum(sorted_values[:top_n])
         total_sum = sum(values)
-        
+
         return top_sum / total_sum if total_sum > 0 else 0.0
-    
+
     def _calculate_bottom_percentile_share(
         self, values: List[float], percentile: float
     ) -> float:
         """í•˜ìœ„ X%ì˜ ìì‚° ì ìœ ìœ¨ì„ ê³„ì‚°í•©ë‹ˆë‹¤."""
         if not values:
             return 0.0
-        
+
         sorted_values = sorted(values)
         n = len(sorted_values)
         bottom_n = max(1, int(n * percentile))
-        
+
         bottom_sum = sum(sorted_values[:bottom_n])
         total_sum = sum(values)
-        
-        return bottom_sum / total_sum if total_sum > 0 else 0.0
 
+        return bottom_sum / total_sum if total_sum > 0 else 0.0
diff --git a/simulation/metrics/stock_tracker.py b/simulation/metrics/stock_tracker.py
index 9525d32..de08b49 100644
--- a/simulation/metrics/stock_tracker.py
+++ b/simulation/metrics/stock_tracker.py
@@ -23,11 +23,11 @@ class StockMarketTracker:
 
     def __init__(self, config_module: Any):
         self.config_module = config_module
-        
+
         # ì´ì „ í‹±ì˜ ê¸°ì—… ë°ì´í„° (ìˆ˜ìµë¥  ê³„ì‚°ìš©)
         self.previous_firm_data: Dict[int, Dict[str, float]] = {}
         self.market_price_history = deque(maxlen=30)
-        
+
     def get_market_volatility(self) -> float:
         """
         Calculates the annualized market volatility (VIX proxy).
@@ -40,7 +40,9 @@ class StockMarketTracker:
         daily_volatility = np.std(log_returns)
 
         # Annualize
-        annualized_volatility = daily_volatility * np.sqrt(self.config_module.TICKS_PER_YEAR)
+        annualized_volatility = daily_volatility * np.sqrt(
+            self.config_module.TICKS_PER_YEAR
+        )
         return annualized_volatility
 
     def track_firm_stock_data(
@@ -52,24 +54,24 @@ class StockMarketTracker:
         ê°œë³„ ê¸°ì—…ì˜ ì£¼ì‹ ì‹œì¥ ë°ì´í„°ë¥¼ ìˆ˜ì§‘í•©ë‹ˆë‹¤.
         """
         firm_id = firm.id
-        
+
         # ì£¼ê°€ ì •ë³´
         stock_price = stock_market.get_stock_price(firm_id) or 0.0
         bps = firm.get_book_value_per_share()
         pbr = stock_price / bps if bps > 0 else 0.0
-        
+
         # ê±°ë˜ëŸ‰ ë° ì£¼ë¬¸ ì •ë³´
         summary = stock_market.get_market_summary(firm_id)
         trade_volume = summary.get("daily_volume", 0.0)
         buy_order_count = summary.get("buy_order_count", 0)
         sell_order_count = summary.get("sell_order_count", 0)
-        
+
         # ê¸°ì—… ì‹¤ì 
         firm_assets = firm.assets
         firm_profit = getattr(firm, "current_profit", 0.0)
         dividend_paid = getattr(firm, "last_dividend_paid", 0.0)
         market_cap = firm.get_market_cap(stock_price)
-        
+
         return {
             "firm_id": firm_id,
             "stock_price": stock_price,
@@ -83,7 +85,7 @@ class StockMarketTracker:
             "dividend_paid": dividend_paid,
             "market_cap": market_cap,
         }
-    
+
     def track_all_firms(
         self,
         firms: List["Firm"],
@@ -98,14 +100,14 @@ class StockMarketTracker:
             if firm.is_active:
                 data = self.track_firm_stock_data(firm, stock_market)
                 results.append(data)
-                prices.append(data['stock_price'])
+                prices.append(data["stock_price"])
 
         if prices:
             avg_price = sum(prices) / len(prices)
             self.market_price_history.append(avg_price)
 
         return results
-    
+
     def calculate_aggregate_metrics(
         self,
         firms: List["Firm"],
@@ -116,25 +118,25 @@ class StockMarketTracker:
         """
         if not firms:
             return {}
-        
+
         active_firms = [f for f in firms if f.is_active]
-        
+
         total_market_cap = 0.0
         total_volume = 0.0
         prices = []
-        
+
         for firm in active_firms:
             price = stock_market.get_stock_price(firm.id) or 0.0
             market_cap = firm.get_market_cap(price)
             volume = stock_market.daily_volumes.get(firm.id, 0.0)
-            
+
             total_market_cap += market_cap
             total_volume += volume
             if price > 0:
                 prices.append(price)
-        
+
         avg_price = sum(prices) / len(prices) if prices else 0.0
-        
+
         return {
             "stock_market_total_market_cap": total_market_cap,
             "stock_market_total_volume": total_volume,
@@ -148,10 +150,10 @@ class PersonalityStatisticsTracker:
 
     def __init__(self, config_module: Any):
         self.config_module = config_module
-        
+
         # ì´ì „ í‹±ì˜ ê°€ê³„ ìì‚° (ì¦ê°€ìœ¨ ê³„ì‚°ìš©)
         self.previous_assets: Dict[int, float] = {}
-    
+
     def calculate_personality_statistics(
         self,
         households: List["Household"],
@@ -161,33 +163,33 @@ class PersonalityStatisticsTracker:
         ì„±í–¥ë³„ í†µê³„ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
         """
         from simulation.ai.enums import Personality
-        
+
         # ì„±í–¥ë³„ ê·¸ë£¹í™”
         groups: Dict[str, List["Household"]] = {
             "MISER": [],
             "STATUS_SEEKER": [],
             "GROWTH_ORIENTED": [],
         }
-        
+
         for h in households:
             if hasattr(h, "personality") and h.is_active:
                 personality_name = h.personality.name
                 if personality_name in groups:
                     groups[personality_name].append(h)
-        
+
         results = []
-        
+
         for personality_type, members in groups.items():
             if not members:
                 continue
-            
+
             stats = self._calculate_group_statistics(
                 personality_type, members, stock_market
             )
             results.append(stats)
-        
+
         return results
-    
+
     def _calculate_group_statistics(
         self,
         personality_type: str,
@@ -196,38 +198,38 @@ class PersonalityStatisticsTracker:
     ) -> Dict[str, Any]:
         """ê°œë³„ ì„±í–¥ ê·¸ë£¹ì˜ í†µê³„ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤."""
         n = len(members)
-        
+
         # ê¸°ë³¸ ìì‚° í†µê³„
         assets = [h.assets for h in members]
         avg_assets = sum(assets) / n
         median_assets = median(assets)
-        
+
         # ê³ ìš© í†µê³„
         employed_count = sum(1 for h in members if h.is_employed)
         employment_rate = employed_count / n
-        
+
         # í¬íŠ¸í´ë¦¬ì˜¤ í†µê³„
         portfolio_values = []
         stock_holdings = []
-        
+
         for h in members:
             portfolio_value = 0.0
             total_shares = 0.0
-            
+
             if stock_market is not None:
                 for firm_id, shares in h.shares_owned.items():
                     price = stock_market.get_stock_price(firm_id) or 0.0
                     portfolio_value += shares * price
                     total_shares += shares
-            
+
             portfolio_values.append(portfolio_value)
             stock_holdings.append(total_shares)
-        
+
         # ìš•êµ¬ í†µê³„
         survival_needs = [h.needs.get("survival", 0.0) for h in members]
         social_needs = [h.needs.get("social", 0.0) for h in members]
         improvement_needs = [h.needs.get("improvement", 0.0) for h in members]
-        
+
         # ìì‚° ì¦ê°€ìœ¨
         growth_rates = []
         for h in members:
@@ -236,9 +238,9 @@ class PersonalityStatisticsTracker:
                 growth_rate = (h.assets - prev_assets) / prev_assets
                 growth_rates.append(growth_rate)
             self.previous_assets[h.id] = h.assets
-        
+
         avg_growth_rate = sum(growth_rates) / len(growth_rates) if growth_rates else 0.0
-        
+
         # ì†Œë“ í†µê³„ (labor_income_this_tick, capital_income_this_tick ì‚¬ìš©)
         labor_incomes = [getattr(h, "labor_income_this_tick", 0.0) for h in members]
         capital_incomes = [getattr(h, "capital_income_this_tick", 0.0) for h in members]
@@ -247,7 +249,9 @@ class PersonalityStatisticsTracker:
         avg_capital_income = sum(capital_incomes) / n
 
         total_income = avg_labor_income + avg_capital_income
-        labor_income_ratio = avg_labor_income / total_income if total_income > 0 else 0.0
+        labor_income_ratio = (
+            avg_labor_income / total_income if total_income > 0 else 0.0
+        )
 
         return {
             "personality_type": personality_type,
diff --git a/simulation/models.py b/simulation/models.py
index 9bbbac2..2bada01 100644
--- a/simulation/models.py
+++ b/simulation/models.py
@@ -14,7 +14,9 @@ class Order:
     price: float
     market_id: str
     target_agent_id: Optional[int] = None  # Phase 6: Targeted Orders (Brand Loyalty)
-    brand_info: Optional[Dict[str, Any]] = None # Phase 6: Brand Metadata (awareness, quality)
+    brand_info: Optional[Dict[str, Any]] = (
+        None  # Phase 6: Brand Metadata (awareness, quality)
+    )
     id: str = field(default_factory=lambda: str(uuid.uuid4()), init=False)
 
 
@@ -37,11 +39,11 @@ class Transaction:
 class StockOrder:
     """ì£¼ì‹ ì‹œì¥ì— ì œì¶œë˜ëŠ” ì£¼ë¬¸ì„ ë‚˜íƒ€ë‚´ëŠ” ë°ì´í„° í´ë˜ìŠ¤"""
 
-    agent_id: int          # ì£¼ë¬¸ ì œì¶œì ID
-    order_type: str        # "BUY" or "SELL"
-    firm_id: int           # ëŒ€ìƒ ê¸°ì—… ID
-    quantity: float        # ì£¼ë¬¸ ìˆ˜ëŸ‰
-    price: float           # í˜¸ê°€ (ì£¼ë‹¹ ê°€ê²©)
+    agent_id: int  # ì£¼ë¬¸ ì œì¶œì ID
+    order_type: str  # "BUY" or "SELL"
+    firm_id: int  # ëŒ€ìƒ ê¸°ì—… ID
+    quantity: float  # ì£¼ë¬¸ ìˆ˜ëŸ‰
+    price: float  # í˜¸ê°€ (ì£¼ë‹¹ ê°€ê²©)
     market_id: str = "stock_market"
     id: str = field(default_factory=lambda: str(uuid.uuid4()), init=False)
 
@@ -49,16 +51,17 @@ class StockOrder:
 @dataclass
 class Share:
     """ì£¼ì‹ ë³´ìœ  ì •ë³´ë¥¼ ë‹´ëŠ” ë°ì´í„° í´ë˜ìŠ¤"""
-    
-    firm_id: int               # ë°œí–‰ ê¸°ì—… ID
-    holder_id: int             # ë³´ìœ ì ID (ê°€ê³„ ë˜ëŠ” ê¸°ì—…)
-    quantity: float            # ë³´ìœ  ìˆ˜ëŸ‰
-    acquisition_price: float   # í‰ê·  ë§¤ì… ê°€ê²©
+
+    firm_id: int  # ë°œí–‰ ê¸°ì—… ID
+    holder_id: int  # ë³´ìœ ì ID (ê°€ê³„ ë˜ëŠ” ê¸°ì—…)
+    quantity: float  # ë³´ìœ  ìˆ˜ëŸ‰
+    acquisition_price: float  # í‰ê·  ë§¤ì… ê°€ê²©
 
 
 @dataclass
 class RealEstateUnit:
     """ë¶€ë™ì‚° ìì‚° ë‹¨ìœ„ (Phase 17-3A)"""
+
     id: int
     owner_id: Optional[int] = None  # None = Government
     occupant_id: Optional[int] = None  # Tenant
@@ -67,16 +70,20 @@ class RealEstateUnit:
     rent_price: float = 100.0
     mortgage_id: Optional[int] = None
 
+
 @dataclass
 class Talent:
     """ê°€ê³„ì˜ ì„ ì²œì  ì¬ëŠ¥ì„ ë‚˜íƒ€ë‚´ëŠ” í´ë˜ìŠ¤ì…ë‹ˆë‹¤."""
+
     base_learning_rate: float
     max_potential: Dict[str, float]
     related_domains: Dict[str, List[str]] = field(default_factory=dict)
 
+
 @dataclass
 class Skill:
     """ê°€ê³„ì˜ í›„ì²œì  ì—­ëŸ‰ì„ ë‚˜íƒ€ë‚´ëŠ” í´ë˜ìŠ¤ì…ë‹ˆë‹¤."""
+
     domain: str
     value: float = 0.0
     observability: float = 0.5
diff --git a/simulation/policies/smart_leviathan_policy.py b/simulation/policies/smart_leviathan_policy.py
index 7ccbef3..dd8f8f2 100644
--- a/simulation/policies/smart_leviathan_policy.py
+++ b/simulation/policies/smart_leviathan_policy.py
@@ -5,26 +5,34 @@ import logging
 
 logger = logging.getLogger(__name__)
 
+
 class SmartLeviathanPolicy(IGovernmentPolicy):
     """
     WO-057: Intelligent Policy Actuator (The Moving Hand).
     Translates Brain(Alpha) decisions into physical economic policy actions
     with safety bounds, baby steps, and party-specific implementation.
     """
-    
+
     def __init__(self, government: Any, config_module: Any):
         self.config = config_module
         from simulation.ai.government_ai import GovernmentAI
+
         self.ai = GovernmentAI(government, config_module)
         self.last_action_tick = -999
 
-    def decide(self, government: Any, sensory_data: "GovernmentStateDTO", current_tick: int, central_bank: "CentralBank") -> Dict[str, Any]:
+    def decide(
+        self,
+        government: Any,
+        sensory_data: "GovernmentStateDTO",
+        current_tick: int,
+        central_bank: "CentralBank",
+    ) -> Dict[str, Any]:
         """
         Policy Decision Cycle.
         Enforces 30-tick (1 month) silent interval as per Architect Prime's Directive.
         """
         action_interval = getattr(self.config, "GOV_ACTION_INTERVAL", 30)
-        
+
         # 30-tick Interval Enforcement
         if current_tick > 0 and current_tick % action_interval != 0:
             return {"policy_type": "AI_ADAPTIVE", "status": "COOLDOWN"}
@@ -46,7 +54,7 @@ class SmartLeviathanPolicy(IGovernmentPolicy):
                 logger.warning(
                     f"REFLEX_OVERRIDE | High inflation detected (State={inflation_state}). "
                     f"Overriding AI action {action} with HAWKISH ({self.ai.ACTION_HAWKISH}).",
-                    extra={"tick": current_tick}
+                    extra={"tick": current_tick},
                 )
                 action = self.ai.ACTION_HAWKISH
         # --- [END REFLEX OVERRIDE] ---
@@ -57,25 +65,25 @@ class SmartLeviathanPolicy(IGovernmentPolicy):
             "income_tax": government.income_tax_rate,
             "corp_tax": government.corporate_tax_rate,
             "welfare": government.welfare_budget_multiplier,
-            "subsidy": government.firm_subsidy_budget_multiplier
+            "subsidy": government.firm_subsidy_budget_multiplier,
         }
-        
+
         old_rate = central_bank.base_rate if central_bank else 0.0
 
         # Constants from Architect Directive
-        TAX_STEP = 0.01          # +-1.0%p
-        RATE_STEP = 0.0025       # +-0.25%p
-        BUDGET_STEP = 0.1        # +-10%
-        
+        TAX_STEP = 0.01  # +-1.0%p
+        RATE_STEP = 0.0025  # +-0.25%p
+        BUDGET_STEP = 0.1  # +-10%
+
         # 3. Translation Logic (Mapping Action -> Physical Change)
         if action == self.ai.ACTION_DOVISH:
             if central_bank:
                 central_bank.base_rate -= RATE_STEP
-        
+
         elif action == self.ai.ACTION_HAWKISH:
             if central_bank:
                 central_bank.base_rate += RATE_STEP
-        
+
         elif action == self.ai.ACTION_FISCAL_EASE:
             if government.ruling_party == PoliticalParty.BLUE:
                 # Blue Expansion: Stimulate Firms
@@ -85,7 +93,7 @@ class SmartLeviathanPolicy(IGovernmentPolicy):
                 # Red Expansion: Stimulate Households
                 government.income_tax_rate -= TAX_STEP
                 government.welfare_budget_multiplier += BUDGET_STEP
-                
+
         elif action == self.ai.ACTION_FISCAL_TIGHT:
             if government.ruling_party == PoliticalParty.BLUE:
                 # Blue Contraction: Shift burden to consumers
@@ -95,33 +103,47 @@ class SmartLeviathanPolicy(IGovernmentPolicy):
                 # Red Contraction: Shift burden to capital
                 government.corporate_tax_rate += TAX_STEP
                 government.firm_subsidy_budget_multiplier -= BUDGET_STEP
-        
+
         # 4. The Safety Valve (Clipping & Bounds)
         # Interest Rate [0% ~ 20%]
         if central_bank:
             central_bank.base_rate = max(0.0, min(0.20, central_bank.base_rate))
-        
+
         # Tax Rate [5% ~ 50%]
         tax_min, tax_max = 0.05, 0.50
-        government.income_tax_rate = max(tax_min, min(tax_max, government.income_tax_rate))
-        government.corporate_tax_rate = max(tax_min, min(tax_max, government.corporate_tax_rate))
-        
+        government.income_tax_rate = max(
+            tax_min, min(tax_max, government.income_tax_rate)
+        )
+        government.corporate_tax_rate = max(
+            tax_min, min(tax_max, government.corporate_tax_rate)
+        )
+
         # Budget Allocation [10% ~ 100% or 200% in emergency]
         budget_min = getattr(self.config, "BUDGET_ALLOCATION_MIN", 0.1)
 
         # WO-057-Active: Emergency AI Levers
         budget_max = getattr(self.config, "NORMAL_BUDGET_MULTIPLIER_CAP", 1.0)
         if government.sensory_data:
-            is_crisis = (government.sensory_data.gdp_growth_sma < -0.05 or
-                         government.sensory_data.unemployment_sma > 0.10)
+            is_crisis = (
+                government.sensory_data.gdp_growth_sma < -0.05
+                or government.sensory_data.unemployment_sma > 0.10
+            )
             if is_crisis:
-                budget_max = getattr(self.config, "EMERGENCY_BUDGET_MULTIPLIER_CAP", 2.0)
+                budget_max = getattr(
+                    self.config, "EMERGENCY_BUDGET_MULTIPLIER_CAP", 2.0
+                )
 
-        government.welfare_budget_multiplier = max(budget_min, min(budget_max, government.welfare_budget_multiplier))
-        government.firm_subsidy_budget_multiplier = max(budget_min, min(budget_max, government.firm_subsidy_budget_multiplier))
+        government.welfare_budget_multiplier = max(
+            budget_min, min(budget_max, government.welfare_budget_multiplier)
+        )
+        government.firm_subsidy_budget_multiplier = max(
+            budget_min, min(budget_max, government.firm_subsidy_budget_multiplier)
+        )
 
         # 5. Logging Baby Steps
-        self._log_changes(government, old_values, central_bank, old_rate, action, current_tick)
+        self._log_changes(
+            government, old_values, central_bank, old_rate, action, current_tick
+        )
 
         # 6. Reward & Learning
         # The real reward calculation now happens inside the AI module using the sensory data.
@@ -131,26 +153,43 @@ class SmartLeviathanPolicy(IGovernmentPolicy):
         return {
             "policy_type": "AI_ADAPTIVE",
             "action_taken": action,
-            "status": "EXECUTED" if action != self.ai.ACTION_NEUTRAL else "HOLD"
+            "status": "EXECUTED" if action != self.ai.ACTION_NEUTRAL else "HOLD",
         }
 
     def _log_changes(self, gov, old_val, cb, old_rate, action, tick):
-        if action == 1: # Neutral
+        if action == 1:  # Neutral
             return
 
-        log_tag = {"extra": {"tick": tick, "agent_id": gov.id, "tags": ["policy", "babystep"]}}
-        
+        log_tag = {
+            "extra": {"tick": tick, "agent_id": gov.id, "tags": ["policy", "babystep"]}
+        }
+
         if cb and abs(old_rate - cb.base_rate) > 1e-9:
-            logger.info(f"BABY_STEP | Interest Rate: {old_rate:.4f} -> {cb.base_rate:.4f}", **log_tag)
-        
+            logger.info(
+                f"BABY_STEP | Interest Rate: {old_rate:.4f} -> {cb.base_rate:.4f}",
+                **log_tag,
+            )
+
         if abs(old_val["income_tax"] - gov.income_tax_rate) > 1e-9:
-            logger.info(f"BABY_STEP | Income Tax: {old_val['income_tax']:.4f} -> {gov.income_tax_rate:.4f}", **log_tag)
-            
+            logger.info(
+                f"BABY_STEP | Income Tax: {old_val['income_tax']:.4f} -> {gov.income_tax_rate:.4f}",
+                **log_tag,
+            )
+
         if abs(old_val["corp_tax"] - gov.corporate_tax_rate) > 1e-9:
-            logger.info(f"BABY_STEP | Corp Tax: {old_val['corp_tax']:.4f} -> {gov.corporate_tax_rate:.4f}", **log_tag)
-            
+            logger.info(
+                f"BABY_STEP | Corp Tax: {old_val['corp_tax']:.4f} -> {gov.corporate_tax_rate:.4f}",
+                **log_tag,
+            )
+
         if abs(old_val["welfare"] - gov.welfare_budget_multiplier) > 1e-9:
-            logger.info(f"BABY_STEP | Welfare Budget: {old_val['welfare']:.2f} -> {gov.welfare_budget_multiplier:.2f}", **log_tag)
-            
+            logger.info(
+                f"BABY_STEP | Welfare Budget: {old_val['welfare']:.2f} -> {gov.welfare_budget_multiplier:.2f}",
+                **log_tag,
+            )
+
         if abs(old_val["subsidy"] - gov.firm_subsidy_budget_multiplier) > 1e-9:
-            logger.info(f"BABY_STEP | Firm Subsidy: {old_val['subsidy']:.2f} -> {gov.firm_subsidy_budget_multiplier:.2f}", **log_tag)
+            logger.info(
+                f"BABY_STEP | Firm Subsidy: {old_val['subsidy']:.2f} -> {gov.firm_subsidy_budget_multiplier:.2f}",
+                **log_tag,
+            )
diff --git a/simulation/policies/taylor_rule_policy.py b/simulation/policies/taylor_rule_policy.py
index 0d108c4..de705af 100644
--- a/simulation/policies/taylor_rule_policy.py
+++ b/simulation/policies/taylor_rule_policy.py
@@ -6,19 +6,26 @@ from simulation.utils.shadow_logger import log_shadow
 if TYPE_CHECKING:
     from simulation.dtos import GovernmentStateDTO
 
+
 class TaylorRulePolicy(IGovernmentPolicy):
     """
     WO-056: í…Œì¼ëŸ¬ ì¤€ì¹™ ê¸°ë°˜ì˜ ì •ì±… ì—”ì§„.
     ê¸°ì¡´ì˜ ìˆ˜ì‹ ê¸°ë°˜ ê²°ì •ì„ ë‹´ë‹¹í•˜ë©°, ì„€ë„ìš° ëª¨ë“œ ë¡œê¹…ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.
     """
-    
+
     def __init__(self, config_module: Any):
         self.config = config_module
         ticks_per_year = int(getattr(config_module, "TICKS_PER_YEAR", 100))
         self.price_history_shadow: Deque[float] = deque(maxlen=ticks_per_year)
         self.potential_gdp = 0.0
 
-    def decide(self, government: Any, sensory_data: "GovernmentStateDTO", current_tick: int, central_bank: Any) -> Dict[str, Any]:
+    def decide(
+        self,
+        government: Any,
+        sensory_data: "GovernmentStateDTO",
+        current_tick: int,
+        central_bank: Any,
+    ) -> Dict[str, Any]:
         # Refactored to use sensory DTO instead of raw market_data
         if not sensory_data:
             return {"status": "NO_DATA"}
@@ -33,12 +40,16 @@ class TaylorRulePolicy(IGovernmentPolicy):
 
         gdp_gap = 0.0
         if government.potential_gdp > 0:
-            gdp_gap = (current_gdp - government.potential_gdp) / government.potential_gdp
+            gdp_gap = (
+                current_gdp - government.potential_gdp
+            ) / government.potential_gdp
 
         # EMA Update for Potential
         if government.potential_gdp != 0.0:
             alpha = 0.01
-            government.potential_gdp = (alpha * current_gdp) + ((1-alpha) * government.potential_gdp)
+            government.potential_gdp = (alpha * current_gdp) + (
+                (1 - alpha) * government.potential_gdp
+            )
 
         # 4. Update Fiscal Stance and Tax Rate
         if getattr(self.config, "AUTO_COUNTER_CYCLICAL_ENABLED", False):
@@ -49,11 +60,15 @@ class TaylorRulePolicy(IGovernmentPolicy):
             new_tax_rate = base_tax_rate * (1 - government.fiscal_stance)
             government.income_tax_rate = new_tax_rate
 
-
         # 5. Taylor Rule (Shadow Logging)
         target_inflation = getattr(self.config, "CB_INFLATION_TARGET", 0.02)
-        neutral_rate = 0.02 
-        target_rate = neutral_rate + inflation + 0.5 * (inflation - target_inflation) + 0.5 * gdp_gap
+        neutral_rate = 0.02
+        target_rate = (
+            neutral_rate
+            + inflation
+            + 0.5 * (inflation - target_inflation)
+            + 0.5 * gdp_gap
+        )
         current_base_rate = central_bank.get_base_rate()
         log_shadow(
             tick=current_tick,
@@ -62,12 +77,12 @@ class TaylorRulePolicy(IGovernmentPolicy):
             metric="taylor_rule_rate",
             current_value=current_base_rate,
             shadow_value=target_rate,
-            details=f"Inf={inflation:.2%}, Gap={gdp_gap:.2%}"
+            details=f"Inf={inflation:.2%}, Gap={gdp_gap:.2%}",
         )
 
         return {
             "interest_rate_target": target_rate,
             "policy_type": "TAYLOR_RULE",
             "status": "EXECUTED",
-            "action_taken": "Updated tax rate based on Taylor Rule fiscal stance."
+            "action_taken": "Updated tax rate based on Taylor Rule fiscal stance.",
         }
diff --git a/simulation/portfolio.py b/simulation/portfolio.py
index 1125916..2e1cee9 100644
--- a/simulation/portfolio.py
+++ b/simulation/portfolio.py
@@ -2,11 +2,13 @@ from typing import Dict, Optional, List
 from simulation.models import Share
 import copy
 
+
 class Portfolio:
     """
     Manages a collection of Shares with Average Cost Basis logic.
     Supports atomic merge and synchronization with legacy dictionaries.
     """
+
     def __init__(self, owner_id: int):
         self.owner_id = owner_id
         self.holdings: Dict[int, Share] = {}  # firm_id -> Share
@@ -30,7 +32,7 @@ class Portfolio:
                 firm_id=firm_id,
                 holder_id=self.owner_id,
                 quantity=quantity,
-                acquisition_price=price
+                acquisition_price=price,
             )
 
     def remove(self, firm_id: int, quantity: float):
@@ -47,7 +49,7 @@ class Portfolio:
         else:
             share.quantity -= quantity
 
-    def merge(self, other_portfolio: 'Portfolio', fraction: float = 1.0):
+    def merge(self, other_portfolio: "Portfolio", fraction: float = 1.0):
         """
         Merges a fraction of another portfolio into this one.
         Recalculates WAC for incoming shares.
@@ -73,7 +75,9 @@ class Portfolio:
         """
         return {fid: share.quantity for fid, share in self.holdings.items()}
 
-    def sync_from_legacy(self, legacy_dict: Dict[int, float], default_price: float = 1.0):
+    def sync_from_legacy(
+        self, legacy_dict: Dict[int, float], default_price: float = 1.0
+    ):
         """
         One-time sync from legacy dict (lossy: assumes default price if missing).
         """
diff --git a/simulation/schemas.py b/simulation/schemas.py
index 718a770..c47eac7 100644
--- a/simulation/schemas.py
+++ b/simulation/schemas.py
@@ -1,22 +1,24 @@
 from dataclasses import dataclass, field
 from typing import Dict, List, Optional
 
+
 @dataclass
 class FirmActionVector:
     """
     ê¸°ì—…ì˜ í•œ í‹± í–‰ë™ì„ ì •ì˜í•˜ëŠ” ì—°ì†ì  ì ê·¹ì„± ë²¡í„°.
     Values ideally range from 0.0 to 1.0.
     """
+
     # 1. íŒë§¤ ì ê·¹ì„± (Pricing)
     # 0.0: High Margin (High Price)
     # 1.0: High Volume (Low Price)
-    sales_aggressiveness: float = 0.5 
+    sales_aggressiveness: float = 0.5
 
     # 2. ê³ ìš© ì ê·¹ì„± (Employment)
     # 0.0: Low Wage / Fire
     # 1.0: High Wage / Hire
     hiring_aggressiveness: float = 0.5
-    
+
     # 3. R&D ì ê·¹ì„± (Innovation)
     # 0.0: No R&D
     # 1.0: Maximize R&D Spending (% of Revenue)
@@ -43,13 +45,14 @@ class HouseholdActionVector:
     """
     ê°€ê³„ì˜ í•œ í‹± í–‰ë™ì„ ì •ì˜í•˜ëŠ” ì—°ì†ì  ì ê·¹ì„± ë²¡í„°.
     """
+
     # 1. ì†Œë¹„ ì ê·¹ì„± (ì¹´í…Œê³ ë¦¬ë³„ ë§¤í•‘)
     # Key: 'basic_food', 'luxury', etc.
     # Value: 0.0~1.0
     # 0.0: Save Money (Buy only if super cheap)
     # 1.0: Panic Buy (Buy at any price)
     consumption_aggressiveness: Dict[str, float] = field(default_factory=dict)
-    
+
     # 2. ë…¸ë™ ê³µê¸‰ ì ê·¹ì„±
     # 0.0: High Reservation Wage (Don't work unless paid well)
     # 1.0: Low Reservation Wage (Work for anything)
diff --git a/simulation/service_firms.py b/simulation/service_firms.py
index 9678809..c664054 100644
--- a/simulation/service_firms.py
+++ b/simulation/service_firms.py
@@ -9,6 +9,7 @@ from simulation.markets.order_book_market import OrderBookMarket
 
 logger = logging.getLogger(__name__)
 
+
 class ServiceFirm(Firm):
     """
     ì„œë¹„ìŠ¤ ê¸°ì—… í´ë˜ìŠ¤ (Phase 17-1).
@@ -59,14 +60,24 @@ class ServiceFirm(Firm):
         2. ì´ì „ í‹±ì˜ ì”ì—¬ ì¬ê³ ë¥¼ íê¸°(Void).
         3. ìƒˆ ìš©ëŸ‰ì„ ì¬ê³ ë¡œ ì„¤ì •.
         """
-        log_extra = {"tick": current_time, "agent_id": self.id, "tags": ["production", "service"]}
+        log_extra = {
+            "tick": current_time,
+            "agent_id": self.id,
+            "tags": ["production", "service"],
+        }
 
         # 1. ê°ê°€ìƒê° (Goodsì™€ ë™ì¼)
-        depreciation_rate = getattr(self.config_module, "CAPITAL_DEPRECIATION_RATE", 0.05)
-        self.capital_stock *= (1.0 - depreciation_rate)
+        depreciation_rate = getattr(
+            self.config_module, "CAPITAL_DEPRECIATION_RATE", 0.05
+        )
+        self.capital_stock *= 1.0 - depreciation_rate
 
         # 2. ìƒì‚° ìš©ëŸ‰ ê³„ì‚° (Cobb-Douglas)
-        total_labor_skill = sum(getattr(emp, 'labor_skill', 1.0) for emp in self.employees if hasattr(emp, 'labor_skill'))
+        total_labor_skill = sum(
+            getattr(emp, "labor_skill", 1.0)
+            for emp in self.employees
+            if hasattr(emp, "labor_skill")
+        )
         if not self.employees:
             total_labor_skill = 1.0
         capital = max(self.capital_stock, 0.01)
@@ -75,19 +86,25 @@ class ServiceFirm(Firm):
         tfp = self.productivity_factor
 
         if total_labor_skill > 0 and capital > 0:
-            capacity = tfp * (total_labor_skill ** alpha) * (capital ** (1 - alpha))
+            capacity = tfp * (total_labor_skill**alpha) * (capital ** (1 - alpha))
         else:
             capacity = 0.0
 
         # Phase 15: Quality Calculation (Same as Goods)
         avg_skill = 0.0
         if self.employees:
-            total_skill = sum(getattr(emp, 'labor_skill', 1.0) for emp in self.employees if hasattr(emp, 'labor_skill'))
+            total_skill = sum(
+                getattr(emp, "labor_skill", 1.0)
+                for emp in self.employees
+                if hasattr(emp, "labor_skill")
+            )
             avg_skill = total_skill / len(self.employees)
 
         item_config = self.config_module.GOODS.get(self.specialization, {})
         quality_sensitivity = item_config.get("quality_sensitivity", 0.5)
-        actual_quality = self.base_quality + (math.log1p(avg_skill) * quality_sensitivity)
+        actual_quality = self.base_quality + (
+            math.log1p(avg_skill) * quality_sensitivity
+        )
 
         # 3. Void Logic (Unsold Inventory from previous tick is WASTE)
         item_id = self.specialization
@@ -97,24 +114,30 @@ class ServiceFirm(Firm):
         if unsold_inventory > 0:
             self.logger.debug(
                 f"SERVICE_VOID | Firm {self.id} voided {unsold_inventory:.2f} unsold capacity.",
-                extra={**log_extra, "waste": unsold_inventory}
+                extra={**log_extra, "waste": unsold_inventory},
             )
 
         # 4. Refill Logic (Set Inventory to New Capacity)
         # Service inventory doesn't accumulate; it resets.
         self.inventory[item_id] = capacity
         self.capacity_this_tick = capacity
-        self.current_production = capacity # For compatibility
+        self.current_production = capacity  # For compatibility
 
         # Update Quality (Weighted Avg doesn't apply to reset, just set new quality)
         self.inventory_quality[item_id] = actual_quality
 
         self.logger.debug(
             f"SERVICE_PRODUCE | Firm {self.id} produced capacity {capacity:.2f} (Quality: {actual_quality:.2f})",
-            extra={**log_extra, "capacity": capacity}
+            extra={**log_extra, "capacity": capacity},
         )
 
-    def update_needs(self, current_time: int, government: Optional[Any] = None, market_data: Optional[Dict[str, Any]] = None, reflux_system: Optional[Any] = None) -> None:
+    def update_needs(
+        self,
+        current_time: int,
+        government: Optional[Any] = None,
+        market_data: Optional[Dict[str, Any]] = None,
+        reflux_system: Optional[Any] = None,
+    ) -> None:
         """
         ì„œë¹„ìŠ¤ ê¸°ì—… ë¹„ìš© ì²˜ë¦¬.
         Holding Cost(ë³´ê´€ë¹„)ëŠ” 0ìœ¼ë¡œ ì²˜ë¦¬ (ì„œë¹„ìŠ¤ëŠ” ì¬ê³ ê°€ ì—†ìœ¼ë¯€ë¡œ).
diff --git a/simulation/systems/api.py b/simulation/systems/api.py
index b8398ee..de78e22 100644
--- a/simulation/systems/api.py
+++ b/simulation/systems/api.py
@@ -3,6 +3,7 @@ God Class ë¦¬íŒ©í† ë§ì„ ìœ„í•œ ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ë° ì»´í¬ë„ŒíŠ¸ì˜ ê³„ì•½
 
 ì´ íŒŒì¼ì€ ìƒˆë¡œìš´ ì•„í‚¤í…ì²˜ ìš”ì†Œì˜ ê³µê°œ APIë¥¼ ì„¤ì •í•˜ì—¬ ëª…í™•í•œ ê²½ê³„ì™€ íƒ€ì… ì•ˆì „ì„±ì„ ë³´ì¥í•©ë‹ˆë‹¤.
 """
+
 from __future__ import annotations
 from typing import List, Dict, Any, Optional, Protocol, TypedDict, Deque, Tuple
 from abc import ABC, abstractmethod
@@ -28,82 +29,105 @@ if TYPE_CHECKING:
 # 1. ì‹œìŠ¤í…œ ê°„ í†µì‹ ì„ ìœ„í•œ DTO (Data Transfer Objects)
 # ===================================================================
 
+
 class SocialMobilityContext(TypedDict):
     """ì‚¬íšŒì  ì´ë™ì„± ê³„ì‚°ì— í•„ìš”í•œ ë°ì´í„°ì…ë‹ˆë‹¤."""
-    households: List['Household']
+
+    households: List["Household"]
     # housing_manager: Any # API ë‹¨ìˆœí™”ë¥¼ ìœ„í•´ Any, ì‹¤ì œë¡œëŠ” HousingManager ì¸ìŠ¤í„´ìŠ¤
 
+
 class EventContext(TypedDict):
     """ì´ë²¤íŠ¸ ì²˜ë¦¬ì— í•„ìš”í•œ ë°ì´í„°ì…ë‹ˆë‹¤."""
-    households: List['Household']
-    firms: List['Firm']
-    markets: Dict[str, 'Market']
-    government: Optional['Government']
-    central_bank: Optional['Any'] # CentralBank
-    bank: Optional['Any'] # Bank
+
+    households: List["Household"]
+    firms: List["Firm"]
+    markets: Dict[str, "Market"]
+    government: Optional["Government"]
+    central_bank: Optional["Any"]  # CentralBank
+    bank: Optional["Any"]  # Bank
+
 
 class SensoryContext(TypedDict):
     """ê°ê° ì‹œìŠ¤í…œ ì²˜ë¦¬ì— í•„ìš”í•œ ë°ì´í„°ì…ë‹ˆë‹¤."""
-    tracker: 'EconomicIndicatorTracker'
-    government: 'Government'
+
+    tracker: "EconomicIndicatorTracker"
+    government: "Government"
     time: int
 
+
 class CommerceContext(TypedDict):
     """ìƒê±°ë˜ ì‹œìŠ¤í…œì´ ì†Œë¹„ë¥¼ ì‹¤í–‰í•˜ëŠ” ë° í•„ìš”í•œ ë°ì´í„°ì…ë‹ˆë‹¤."""
-    households: List['Household']
-    agents: Dict[int, Any] # For O(1) lookup
-    breeding_planner: 'VectorizedHouseholdPlanner'
+
+    households: List["Household"]
+    agents: Dict[int, Any]  # For O(1) lookup
+    breeding_planner: "VectorizedHouseholdPlanner"
     household_time_allocation: Dict[int, float]
-    reflux_system: 'EconomicRefluxSystem'
+    reflux_system: "EconomicRefluxSystem"
     market_data: Dict[str, Any]
     config: Any
     time: int
 
+
 class LifecycleContext(TypedDict):
     """ì—ì´ì „íŠ¸ ìƒëª…ì£¼ê¸° ê´€ë¦¬ì— í•„ìš”í•œ ë°ì´í„°ì…ë‹ˆë‹¤."""
-    household: 'Household' # ê°œë³„ ê°€ê³„ë¥¼ ëŒ€ìƒìœ¼ë¡œ ì‹¤í–‰
+
+    household: "Household"  # ê°œë³„ ê°€ê³„ë¥¼ ëŒ€ìƒìœ¼ë¡œ ì‹¤í–‰
     market_data: Dict[str, Any]
     time: int
 
+
 class MarketInteractionContext(TypedDict):
     """ì‹œì¥ ìƒí˜¸ì‘ìš© ì»´í¬ë„ŒíŠ¸ì— í•„ìš”í•œ ë°ì´í„°ì…ë‹ˆë‹¤."""
-    markets: Dict[str, 'Market']
+
+    markets: Dict[str, "Market"]
+
 
 class LearningUpdateContext(TypedDict):
     """ì—ì´ì „íŠ¸ì˜ AI í•™ìŠµ ì—…ë°ì´íŠ¸ì— í•„ìš”í•œ ë°ì´í„°ì…ë‹ˆë‹¤."""
+
     reward: float
     next_agent_data: Dict[str, Any]
     next_market_data: Dict[str, Any]
 
+
 # ===================================================================
 # 2. ì‹œìŠ¤í…œ ë ˆë²¨ ì¸í„°í˜ì´ìŠ¤ (Simulation í´ë˜ìŠ¤ì—ì„œ ì¶”ì¶œ)
 # ===================================================================
 
+
 class SystemInterface(Protocol):
     """
     WO-103: Common interface for system services to enforce the sacred sequence.
     """
-    def execute(self, state: SimulationState) -> None:
-        ...
+
+    def execute(self, state: SimulationState) -> None: ...
+
 
 class ISocialSystem(Protocol):
     """ì‚¬íšŒì  ìˆœìœ„ ë° ì§€ìœ„ì™€ ê°™ì€ ë™ì  ìš”ì†Œë¥¼ ê´€ë¦¬í•˜ëŠ” ì‹œìŠ¤í…œì˜ ì¸í„°í˜ì´ìŠ¤ì…ë‹ˆë‹¤."""
+
     def __init__(self, config: Any): ...
 
     def update_social_ranks(self, context: SocialMobilityContext) -> None:
         """ëª¨ë“  ê°€ê³„ì˜ ì‚¬íšŒì  ìˆœìœ„ ë°±ë¶„ìœ„ë¥¼ ê³„ì‚°í•˜ê³  í• ë‹¹í•©ë‹ˆë‹¤."""
         ...
 
-    def calculate_reference_standard(self, context: SocialMobilityContext) -> Dict[str, float]:
+    def calculate_reference_standard(
+        self, context: SocialMobilityContext
+    ) -> Dict[str, float]:
         """ìµœìƒìœ„ ì‚¬íšŒ ê³„ì¸µì˜ í‰ê·  ì†Œë¹„ ë° ì£¼ê±° ìˆ˜ì¤€ì„ ê³„ì‚°í•©ë‹ˆë‹¤."""
         ...
 
 
 class IEventSystem(Protocol):
     """ì˜ˆì•½ë˜ê±°ë‚˜ íŠ¸ë¦¬ê±°ëœ ì‹œë®¬ë ˆì´ì…˜ ì „ë°˜ì˜ ì´ë²¤íŠ¸ë¥¼ ê´€ë¦¬í•˜ëŠ” ì‹œìŠ¤í…œì˜ ì¸í„°í˜ì´ìŠ¤ì…ë‹ˆë‹¤."""
+
     def __init__(self, config: Any): ...
 
-    def execute_scheduled_events(self, time: int, context: EventContext, config: StressScenarioConfig) -> None:
+    def execute_scheduled_events(
+        self, time: int, context: EventContext, config: StressScenarioConfig
+    ) -> None:
         """í˜„ì¬ í‹±ì— ì˜ˆì•½ëœ ì¹´ì˜¤ìŠ¤ ì´ë²¤íŠ¸ë‚˜ ë‹¤ë¥¸ ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤."""
         ...
 
@@ -113,6 +137,7 @@ class ISensorySystem(Protocol):
     ì›ì‹œ ë°ì´í„°ë¥¼ ì •ë¶€ AIì™€ ê°™ì€ ì—ì´ì „íŠ¸ì˜ ì˜ì‚¬ê²°ì •ì„ ìœ„í•´ í‰í™œí™”ë˜ê±°ë‚˜ ì§‘ê³„ëœ ì§€í‘œë¡œ
     ì²˜ë¦¬í•˜ëŠ” ì‹œìŠ¤í…œì˜ ì¸í„°í˜ì´ìŠ¤ì…ë‹ˆë‹¤.
     """
+
     # ìƒíƒœ(State)ëŠ” ë°˜ë“œì‹œ ì´ ì‹œìŠ¤í…œìœ¼ë¡œ ì´ì „ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
     inflation_buffer: Deque[float]
     unemployment_buffer: Deque[float]
@@ -124,16 +149,23 @@ class ISensorySystem(Protocol):
 
     def __init__(self, config: Any): ...
 
-    def generate_government_sensory_dto(self, context: SensoryContext) -> 'GovernmentStateDTO':
+    def generate_government_sensory_dto(
+        self, context: SensoryContext
+    ) -> "GovernmentStateDTO":
         """ì£¼ìš” ì§€í‘œì˜ SMAë¥¼ ê³„ì‚°í•˜ê³  DTOë¡œ íŒ¨í‚¤ì§•í•©ë‹ˆë‹¤."""
         ...
 
 
 class ICommerceSystem(Protocol):
     """í‹±ì˜ ì†Œë¹„ ë° ì—¬ê°€ ë¶€ë¶„ì„ ê´€ë¦¬í•˜ëŠ” ì‹œìŠ¤í…œì˜ ì¸í„°í˜ì´ìŠ¤ì…ë‹ˆë‹¤."""
-    def __init__(self, config: Any, reflux_system: 'EconomicRefluxSystem'): ...
 
-    def execute_consumption_and_leisure(self, context: CommerceContext, scenario_config: Optional[StressScenarioConfig] = None) -> Dict[int, float]:
+    def __init__(self, config: Any, reflux_system: "EconomicRefluxSystem"): ...
+
+    def execute_consumption_and_leisure(
+        self,
+        context: CommerceContext,
+        scenario_config: Optional[StressScenarioConfig] = None,
+    ) -> Dict[int, float]:
         """
         ê°€ê³„ ì†Œë¹„, ê¸´ê¸‰ êµ¬ë§¤(fast-track purchases), ì—¬ê°€ íš¨ê³¼ë¥¼ ì¡°ìœ¨í•©ë‹ˆë‹¤.
         Returns:
@@ -141,16 +173,19 @@ class ICommerceSystem(Protocol):
         """
         ...
 
+
 # ===================================================================
 # 3. ì—ì´ì „íŠ¸ ì»´í¬ë„ŒíŠ¸ ì¸í„°í˜ì´ìŠ¤ (Household í´ë˜ìŠ¤ì—ì„œ ì¶”ì¶œ)
 # ===================================================================
 
+
 class IAgentLifecycleComponent(Protocol):
     """
     ì—ì´ì „íŠ¸ì˜ í‹±ë‹¹ ìƒëª…ì£¼ê¸°ë¥¼ ì¡°ìœ¨í•˜ëŠ” ì»´í¬ë„ŒíŠ¸ ì¸í„°í˜ì´ìŠ¤ì…ë‹ˆë‹¤.
     í˜¼ë€ìŠ¤ëŸ¬ì› ë˜ `update_needs` ë©”ì„œë“œë¥¼ ëŒ€ì²´í•©ë‹ˆë‹¤.
     """
-    def __init__(self, owner: 'Household', config: Any): ...
+
+    def __init__(self, owner: "Household", config: Any): ...
 
     def run_tick(self, context: LifecycleContext) -> None:
         """
@@ -161,25 +196,32 @@ class IAgentLifecycleComponent(Protocol):
 
 class IMarketComponent(Protocol):
     """íŒë§¤ì ì„ íƒê³¼ ê°™ì€ ì‹œì¥ ìƒí˜¸ì‘ìš©ì„ ì±…ì„ì§€ëŠ” ì»´í¬ë„ŒíŠ¸ ì¸í„°í˜ì´ìŠ¤ì…ë‹ˆë‹¤."""
-    def __init__(self, owner: 'Household', config: Any): ...
 
-    def choose_best_seller(self, item_id: str, context: MarketInteractionContext) -> Tuple[Optional[int], float]:
+    def __init__(self, owner: "Household", config: Any): ...
+
+    def choose_best_seller(
+        self, item_id: str, context: MarketInteractionContext
+    ) -> Tuple[Optional[int], float]:
         """
         ê°€ê²©, í’ˆì§ˆ, ë¸Œëœë“œ ì¸ì§€ë„, ì¶©ì„±ë„ë¥¼ í¬í•¨í•˜ëŠ” íš¨ìš©ì— ê¸°ë°˜í•˜ì—¬
         ì£¼ì–´ì§„ ì•„ì´í…œì— ëŒ€í•œ ìµœì ì˜ íŒë§¤ìë¥¼ ì„ íƒí•©ë‹ˆë‹¤.
         """
         ...
 
+
 class ILaborMarketAnalyzer(Protocol):
     """
     ë…¸ë™ ì‹œì¥ì˜ ì‹œìŠ¤í…œ ë ˆë²¨ ë¶„ì„ê¸° ì¸í„°í˜ì´ìŠ¤ì…ë‹ˆë‹¤.
     ì´ ë¡œì§ì€ ê°œë³„ ì—ì´ì „íŠ¸ì— ì†í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
     """
+
     market_wage_history: Deque[float]
 
     def __init__(self, config: Any): ...
 
-    def calculate_shadow_reservation_wage(self, agent: 'Household', market_data: Dict[str, Any]) -> float:
+    def calculate_shadow_reservation_wage(
+        self, agent: "Household", market_data: Dict[str, Any]
+    ) -> float:
         """ê°€ê³„ì˜ ê³ ì •ì ì¸ ìœ ë³´ ì„ê¸ˆì„ ê³„ì‚°í•©ë‹ˆë‹¤."""
         ...
 
@@ -192,8 +234,10 @@ class ILaborMarketAnalyzer(Protocol):
 # 4. ì—ì´ì „íŠ¸ í•™ìŠµ ê³„ì•½ (Firm ë° Householdìš©)
 # ===================================================================
 
+
 class ILearningAgent(Protocol):
     """Firm ë° Householdì™€ ê°™ì€ ì—ì´ì „íŠ¸ì˜ ê³µí†µ ë©”ì„œë“œë¥¼ ë‚˜íƒ€ë‚´ëŠ” í”„ë¡œí† ì½œì…ë‹ˆë‹¤."""
+
     id: int
     is_active: bool
 
@@ -207,8 +251,10 @@ class ILearningAgent(Protocol):
         """
         ...
 
+
 class AgentLifecycleManagerInterface(SystemInterface, Protocol):
     """
     Interface for AgentLifecycleManager to ensure contract compliance.
     """
+
     pass
diff --git a/simulation/systems/bootstrapper.py b/simulation/systems/bootstrapper.py
index 0ffbd57..0acab54 100644
--- a/simulation/systems/bootstrapper.py
+++ b/simulation/systems/bootstrapper.py
@@ -7,6 +7,7 @@ if TYPE_CHECKING:
 
 logger = logging.getLogger(__name__)
 
+
 class Bootstrapper:
     """
     System responsible for initializing agents with necessary resources
@@ -14,11 +15,12 @@ class Bootstrapper:
 
     Ref: WO-058 Economic CPR
     """
+
     MIN_CAPITAL = 100_000.0  # Increased from 2000
     INITIAL_INVENTORY = 50.0  # New constant
 
     @staticmethod
-    def force_assign_workers(firms: List['Firm'], households: List['Household']) -> int:
+    def force_assign_workers(firms: List["Firm"], households: List["Household"]) -> int:
         MAX_FORCED_WORKERS = 5
         DEFAULT_WAGE = 50.0
         assigned_count = 0
@@ -37,13 +39,15 @@ class Bootstrapper:
                     worker.wage = DEFAULT_WAGE
                     firm.hr.hire(worker, DEFAULT_WAGE)
                     assigned_count += 1
-                logger.info(f'BOOTSTRAPPER | Force-assigned {workers_needed} workers to Firm {firm.id}')
+                logger.info(
+                    f"BOOTSTRAPPER | Force-assigned {workers_needed} workers to Firm {firm.id}"
+                )
 
-        logger.info(f'BOOTSTRAPPER | Total force-assigned workers: {assigned_count}')
+        logger.info(f"BOOTSTRAPPER | Total force-assigned workers: {assigned_count}")
         return assigned_count
 
     @staticmethod
-    def inject_initial_liquidity(firms: List['Firm'], config: Any) -> None:
+    def inject_initial_liquidity(firms: List["Firm"], config: Any) -> None:
         """
         Injects a 30-tick buffer of raw materials and minimum capital.
 
@@ -61,8 +65,8 @@ class Bootstrapper:
                 item_config = config.GOODS[firm.specialization]
 
                 # Check if this good requires inputs
-                if 'inputs' in item_config and item_config['inputs']:
-                    for mat, qty_per_unit in item_config['inputs'].items():
+                if "inputs" in item_config and item_config["inputs"]:
+                    for mat, qty_per_unit in item_config["inputs"].items():
                         # Calculate needed amount: Qty * Target * Days
                         needed = qty_per_unit * firm.production_target * BUFFER_DAYS
 
@@ -76,8 +80,9 @@ class Bootstrapper:
                 current_inv = firm.inventory.get(firm.specialization, 0.0)
                 if current_inv < Bootstrapper.INITIAL_INVENTORY:
                     firm.inventory[firm.specialization] = Bootstrapper.INITIAL_INVENTORY
-                    logger.info(f'BOOTSTRAPPER | Injected {Bootstrapper.INITIAL_INVENTORY} units to Firm {firm.id}')
-
+                    logger.info(
+                        f"BOOTSTRAPPER | Injected {Bootstrapper.INITIAL_INVENTORY} units to Firm {firm.id}"
+                    )
 
             # 2. Capital Injection (Demand Side)
             if firm.assets < Bootstrapper.MIN_CAPITAL:
diff --git a/simulation/systems/commerce_system.py b/simulation/systems/commerce_system.py
index c87fcf3..d6d690e 100644
--- a/simulation/systems/commerce_system.py
+++ b/simulation/systems/commerce_system.py
@@ -1,6 +1,7 @@
 """
 Implements the CommerceSystem which orchestrates consumption, purchases, and leisure.
 """
+
 from typing import Any, Dict, List, Optional
 import logging
 from simulation.systems.api import ICommerceSystem, CommerceContext
@@ -8,6 +9,7 @@ from simulation.systems.reflux_system import EconomicRefluxSystem
 
 logger = logging.getLogger(__name__)
 
+
 class CommerceSystem(ICommerceSystem):
     """
     Orchestrates the consumption and leisure phase of the tick.
@@ -17,7 +19,11 @@ class CommerceSystem(ICommerceSystem):
         self.config = config
         self.reflux_system = reflux_system
 
-    def execute_consumption_and_leisure(self, context: CommerceContext, scenario_config: Optional["StressScenarioConfig"] = None) -> Dict[int, float]:
+    def execute_consumption_and_leisure(
+        self,
+        context: CommerceContext,
+        scenario_config: Optional["StressScenarioConfig"] = None,
+    ) -> Dict[int, float]:
         """
         Executes vectorized consumption, applies fast-track purchases,
         and calculates leisure effects. Incorporates stress scenario behavioral changes.
@@ -34,11 +40,13 @@ class CommerceSystem(ICommerceSystem):
         household_leisure_effects: Dict[int, float] = {}
 
         # 1. Vectorized Decision Making
-        batch_decisions = breeding_planner.decide_consumption_batch(households, market_data)
+        batch_decisions = breeding_planner.decide_consumption_batch(
+            households, market_data
+        )
 
-        consume_list = batch_decisions.get('consume', [0] * len(households))
-        buy_list = batch_decisions.get('buy', [0] * len(households))
-        food_price = batch_decisions.get('price', 5.0)
+        consume_list = batch_decisions.get("consume", [0] * len(households))
+        buy_list = batch_decisions.get("buy", [0] * len(households))
+        food_price = batch_decisions.get("price", 5.0)
 
         for i, household in enumerate(households):
             if not household.is_active:
@@ -51,11 +59,20 @@ class CommerceSystem(ICommerceSystem):
                 c_amt = consume_list[i]
 
                 # Phase 28: Deflationary Spiral - Consumption Collapse
-                if scenario_config and scenario_config.is_active and scenario_config.scenario_name == 'deflation':
-                    if not household.is_employed and scenario_config.consumption_pessimism_factor > 0:
+                if (
+                    scenario_config
+                    and scenario_config.is_active
+                    and scenario_config.scenario_name == "deflation"
+                ):
+                    if (
+                        not household.is_employed
+                        and scenario_config.consumption_pessimism_factor > 0
+                    ):
                         original_amt = c_amt
-                        c_amt *= (1 - scenario_config.consumption_pessimism_factor)
-                        logger.debug(f"PESSIMISM_IMPACT | Household {household.id} consumption reduced from {original_amt:.2f} to {c_amt:.2f}")
+                        c_amt *= 1 - scenario_config.consumption_pessimism_factor
+                        logger.debug(
+                            f"PESSIMISM_IMPACT | Household {household.id} consumption reduced from {original_amt:.2f} to {c_amt:.2f}"
+                        )
 
                 if c_amt > 0:
                     household.consume("basic_food", c_amt, current_time)
@@ -68,19 +85,31 @@ class CommerceSystem(ICommerceSystem):
                     cost = b_amt * food_price
                     if household.assets >= cost:
                         household.withdraw(cost)
-                        household.inventory["basic_food"] = household.inventory.get("basic_food", 0) + b_amt
+                        household.inventory["basic_food"] = (
+                            household.inventory.get("basic_food", 0) + b_amt
+                        )
 
                         # Capture money sink
-                        self.reflux_system.capture(cost, source=f"Household_{household.id}", category="emergency_food")
+                        self.reflux_system.capture(
+                            cost,
+                            source=f"Household_{household.id}",
+                            category="emergency_food",
+                        )
 
                         logger.debug(
                             f"VECTOR_BUY | Household {household.id} bought {b_amt:.1f} food (Fast Track)",
-                            extra={"agent_id": household.id, "tags": ["consumption", "vector_buy"]}
+                            extra={
+                                "agent_id": household.id,
+                                "tags": ["consumption", "vector_buy"],
+                            },
                         )
 
                         # Immediate consumption if needed
                         if c_amt == 0:
-                            consume_now = min(b_amt, getattr(self.config, "FOOD_CONSUMPTION_QUANTITY", 1.0))
+                            consume_now = min(
+                                b_amt,
+                                getattr(self.config, "FOOD_CONSUMPTION_QUANTITY", 1.0),
+                            )
                             household.consume("basic_food", consume_now, current_time)
                             consumed_items["basic_food"] = consume_now
 
diff --git a/simulation/systems/demographic_manager.py b/simulation/systems/demographic_manager.py
index 60174be..c2fe31b 100644
--- a/simulation/systems/demographic_manager.py
+++ b/simulation/systems/demographic_manager.py
@@ -6,12 +6,14 @@ from simulation.core_agents import Household
 
 logger = logging.getLogger(__name__)
 
+
 class DemographicManager:
     """
     Phase 19: Demographic Manager
     - Handles lifecycle events: Aging, Birth, Death, Inheritance.
     - Implements evolutionary population dynamics.
     """
+
     _instance = None
 
     def __new__(cls, *args, **kwargs):
@@ -41,7 +43,7 @@ class DemographicManager:
                 continue
 
             # Increment Age for households
-            agent.age += (1.0 / ticks_per_year)
+            agent.age += 1.0 / ticks_per_year
 
             # Check Natural Death (Gompertz-Makeham law simplified)
             if agent.age > 80:
@@ -60,13 +62,11 @@ class DemographicManager:
         agent.is_active = False
         self.logger.info(
             f"NATURAL_DEATH | Household {agent.id} died of old age at {agent.age:.1f}.",
-            extra={"agent_id": agent.id, "age": agent.age, "tick": current_tick}
+            extra={"agent_id": agent.id, "age": agent.age, "tick": current_tick},
         )
 
     def process_births(
-        self,
-        simulation: Any,
-        birth_requests: List[Household]
+        self, simulation: Any, birth_requests: List[Household]
     ) -> List[Household]:
         """
         Executes birth requests.
@@ -76,7 +76,11 @@ class DemographicManager:
 
         for parent in birth_requests:
             # Re-verify biological capability (sanity check)
-            if not (self.config_module.REPRODUCTION_AGE_START <= parent.age <= self.config_module.REPRODUCTION_AGE_END):
+            if not (
+                self.config_module.REPRODUCTION_AGE_START
+                <= parent.age
+                <= self.config_module.REPRODUCTION_AGE_END
+            ):
                 continue
 
             # Create Child
@@ -111,14 +115,16 @@ class DemographicManager:
             ai_trainer = simulation.ai_trainer
 
             # Value Orientation Inheritance (with mutation?)
-            value_orientation = parent.value_orientation # Strict inheritance for now
+            value_orientation = parent.value_orientation  # Strict inheritance for now
 
             # Get base engine
             base_ai_engine = ai_trainer.get_engine(value_orientation)
 
             # Create HouseholdAI wrapper
             from simulation.ai.household_ai import HouseholdAI
-            from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
+            from simulation.decisions.ai_driven_household_engine import (
+                AIDrivenHouseholdDecisionEngine,
+            )
 
             # Inherit Personality (with mutation)
             child_personality = self._inherit_personality(parent.personality)
@@ -131,19 +137,23 @@ class DemographicManager:
 
             # Create Decision Engine
             # WO-110: Allow selecting engine type for newborns (AIDriven vs RuleBased)
-            newborn_engine_type = getattr(self.config_module, "NEWBORN_ENGINE_TYPE", "AIDriven")
+            newborn_engine_type = getattr(
+                self.config_module, "NEWBORN_ENGINE_TYPE", "AIDriven"
+            )
 
             if newborn_engine_type == "RuleBased":
-                from simulation.decisions.rule_based_household_engine import RuleBasedHouseholdDecisionEngine
+                from simulation.decisions.rule_based_household_engine import (
+                    RuleBasedHouseholdDecisionEngine,
+                )
+
                 new_decision_engine = RuleBasedHouseholdDecisionEngine(
-                    config_module=self.config_module,
-                    logger=simulation.logger
+                    config_module=self.config_module, logger=simulation.logger
                 )
             else:
                 new_decision_engine = AIDrivenHouseholdDecisionEngine(
                     ai_engine=new_ai,
                     config_module=self.config_module,
-                    logger=simulation.logger
+                    logger=simulation.logger,
                 )
                 new_decision_engine.loan_market = simulation.markets.get("loan_market")
 
@@ -152,19 +162,19 @@ class DemographicManager:
                 talent=child_talent,
                 goods_data=simulation.goods_data,
                 initial_assets=initial_gift,
-                initial_needs={}, # Default reset
+                initial_needs={},  # Default reset
                 decision_engine=new_decision_engine,
                 value_orientation=value_orientation,
                 personality=child_personality,
                 config_module=self.config_module,
                 loan_market=simulation.markets.get("loan_market"),
-                risk_aversion=parent.risk_aversion, # Inherit risk aversion
-                logger=simulation.logger
+                risk_aversion=parent.risk_aversion,  # Inherit risk aversion
+                logger=simulation.logger,
             )
 
             # Initialize Phase 19 Attributes
-            child.age = 0.0 # Newborn
-            child.education_level = 0 # Start at 0
+            child.age = 0.0  # Newborn
+            child.education_level = 0  # Start at 0
             child.expected_wage = self._calculate_expected_wage(child.education_level)
             child.parent_id = parent.id
             child.generation = parent.generation + 1
@@ -177,14 +187,20 @@ class DemographicManager:
                 simulation.ai_training_manager.inherit_brain(parent, child)
             else:
                 # Fallback if manager not found (e.g. mocked simulation)
-                self.logger.warning("AITrainingManager not found for brain inheritance.")
+                self.logger.warning(
+                    "AITrainingManager not found for brain inheritance."
+                )
 
             new_children.append(child)
 
             self.logger.info(
                 f"BIRTH | Parent {parent.id} ({parent.age:.1f}y) -> Child {child.id}. "
                 f"Assets: {initial_gift:.2f}",
-                extra={"parent_id": parent.id, "child_id": child.id, "tick": simulation.time}
+                extra={
+                    "parent_id": parent.id,
+                    "child_id": child.id,
+                    "tick": simulation.time,
+                },
             )
 
         return new_children
@@ -202,7 +218,9 @@ class DemographicManager:
 
         # Mutation
         mutation_range = 0.1
-        new_talent.base_learning_rate *= random.uniform(1.0 - mutation_range, 1.0 + mutation_range)
+        new_talent.base_learning_rate *= random.uniform(
+            1.0 - mutation_range, 1.0 + mutation_range
+        )
 
         return new_talent
 
@@ -211,8 +229,11 @@ class DemographicManager:
         Inherit personality with potential mutation.
         """
         # Mutation Probability
-        if random.random() < getattr(self.config_module, "MITOSIS_MUTATION_PROBABILITY", 0.1):
+        if random.random() < getattr(
+            self.config_module, "MITOSIS_MUTATION_PROBABILITY", 0.1
+        ):
             from simulation.ai.enums import Personality
+
             available = list(Personality)
             return random.choice(available)
         return parent_personality
@@ -229,13 +250,17 @@ class DemographicManager:
         """
         if not deceased_agent.children_ids:
             # No heirs -> State (Tax)
-            return # Already handled by existing liquidation logic (Government collection)
+            return  # Already handled by existing liquidation logic (Government collection)
 
         # Find living heirs
-        heirs = [simulation.agents[cid] for cid in deceased_agent.children_ids if cid in simulation.agents and simulation.agents[cid].is_active]
+        heirs = [
+            simulation.agents[cid]
+            for cid in deceased_agent.children_ids
+            if cid in simulation.agents and simulation.agents[cid].is_active
+        ]
 
         if not heirs:
-            return # No living heirs
+            return  # No living heirs
 
         # Distribute Assets
         # Existing logic in engine._handle_agent_lifecycle wipes assets via tax?
@@ -244,7 +269,8 @@ class DemographicManager:
         # Inheritance logic might need to run before standard liquidation.
 
         amount = deceased_agent.assets
-        if amount <= 0: return
+        if amount <= 0:
+            return
 
         # Tax
         tax_rate = getattr(self.config_module, "INHERITANCE_TAX_RATE", 0.0)
@@ -252,7 +278,9 @@ class DemographicManager:
         net_amount = amount - tax
 
         # Send Tax
-        simulation.government.collect_tax(tax, "inheritance_tax", deceased_agent.id, simulation.time)
+        simulation.government.collect_tax(
+            tax, "inheritance_tax", deceased_agent.id, simulation.time
+        )
 
         # Distribute
         share = net_amount / len(heirs)
@@ -260,7 +288,7 @@ class DemographicManager:
             heir._add_assets(share)
             self.logger.info(
                 f"INHERITANCE | Heir {heir.id} received {share:.2f} from {deceased_agent.id}.",
-                extra={"heir_id": heir.id, "deceased_id": deceased_agent.id}
+                extra={"heir_id": heir.id, "deceased_id": deceased_agent.id},
             )
 
         # Clear deceased assets so engine doesn't double count or tax again
diff --git a/simulation/systems/event_system.py b/simulation/systems/event_system.py
index 76d7477..f46dedd 100644
--- a/simulation/systems/event_system.py
+++ b/simulation/systems/event_system.py
@@ -1,6 +1,7 @@
 """
 Implements the EventSystem which handles scheduled chaos events.
 """
+
 from typing import Dict, Any, List, Optional, TYPE_CHECKING
 import logging
 from simulation.systems.api import IEventSystem, EventContext
@@ -12,6 +13,7 @@ if TYPE_CHECKING:
 
 logger = logging.getLogger(__name__)
 
+
 class EventSystem(IEventSystem):
     """
     Manages scheduled events like Inflation Shock and Recession Shock.
@@ -20,14 +22,18 @@ class EventSystem(IEventSystem):
     def __init__(self, config: Any):
         self.config = config
 
-    def execute_scheduled_events(self, time: int, context: EventContext, config: "StressScenarioConfig") -> None:
+    def execute_scheduled_events(
+        self, time: int, context: EventContext, config: "StressScenarioConfig"
+    ) -> None:
         """
         Executes stress scenario triggers based on the provided configuration.
         """
         if not config or not config.is_active or time != config.start_tick:
             return
 
-        logger.warning(f"ğŸ”¥ STRESS_TEST: Activating '{config.scenario_name}' at Tick {time}!")
+        logger.warning(
+            f"ğŸ”¥ STRESS_TEST: Activating '{config.scenario_name}' at Tick {time}!"
+        )
         households = context["households"]
         firms = context["firms"]
         # context might need expansion to include Government and CentralBank if not present
@@ -40,28 +46,40 @@ class EventSystem(IEventSystem):
         # Or we can access them if they are in `context` (if TypedDict allows extra keys or if we update it).
 
         # Scenario 1: Hyperinflation (Demand-Pull Shock)
-        if config.scenario_name == 'hyperinflation' and config.demand_shock_cash_injection > 0:
+        if (
+            config.scenario_name == "hyperinflation"
+            and config.demand_shock_cash_injection > 0
+        ):
             for h in households:
-                h.assets *= (1 + config.demand_shock_cash_injection)
-            logger.info(f"  -> Injected {config.demand_shock_cash_injection:.0%} cash into all households.")
+                h.assets *= 1 + config.demand_shock_cash_injection
+            logger.info(
+                f"  -> Injected {config.demand_shock_cash_injection:.0%} cash into all households."
+            )
 
         # Scenario 2: Deflationary Spiral (Asset Shock)
-        if config.scenario_name == 'deflation' and config.asset_shock_reduction > 0:
+        if config.scenario_name == "deflation" and config.asset_shock_reduction > 0:
             for agent in households + firms:
-                agent.assets *= (1 - config.asset_shock_reduction)
-            logger.info(f"  -> Reduced all agent assets by {config.asset_shock_reduction:.0%}.")
+                agent.assets *= 1 - config.asset_shock_reduction
+            logger.info(
+                f"  -> Reduced all agent assets by {config.asset_shock_reduction:.0%}."
+            )
 
         # Scenario 3: Supply Shock (Productivity Collapse)
-        if config.scenario_name == 'supply_shock' and config.exogenous_productivity_shock:
+        if (
+            config.scenario_name == "supply_shock"
+            and config.exogenous_productivity_shock
+        ):
             for firm in firms:
                 # Check if firm type is in the shock dictionary
                 if firm.type in config.exogenous_productivity_shock:
                     shock_multiplier = config.exogenous_productivity_shock[firm.type]
                     firm.productivity_factor *= shock_multiplier
-                    logger.info(f"  -> Applied productivity shock ({shock_multiplier}) to Firm {firm.id} (Type: {firm.type}).")
+                    logger.info(
+                        f"  -> Applied productivity shock ({shock_multiplier}) to Firm {firm.id} (Type: {firm.type})."
+                    )
 
         # Scenario 4: Great Depression (Liquidity Crisis)
-        if config.scenario_name == 'phase29_depression':
+        if config.scenario_name == "phase29_depression":
             logger.info("  -> Triggering Great Depression Scenario!")
 
             # Access Government and Central Bank
@@ -97,30 +115,46 @@ class EventSystem(IEventSystem):
 
                 # Force Bank Rate directly
                 bank.update_base_rate(config.monetary_shock_target_rate)
-                logger.info(f"  -> MONETARY SHOCK: Forced Bank Base Rate to {config.monetary_shock_target_rate}")
+                logger.info(
+                    f"  -> MONETARY SHOCK: Forced Bank Base Rate to {config.monetary_shock_target_rate}"
+                )
 
             if config.fiscal_shock_tax_rate is not None and government:
                 # Apply Fiscal Shock: Increase Corporate Tax Rate
                 # Check if government has `corporate_tax_rate` attribute.
                 if hasattr(government, "corporate_tax_rate"):
                     government.corporate_tax_rate = config.fiscal_shock_tax_rate
-                    logger.info(f"  -> FISCAL SHOCK: Forced Corporate Tax Rate to {config.fiscal_shock_tax_rate}")
+                    logger.info(
+                        f"  -> FISCAL SHOCK: Forced Corporate Tax Rate to {config.fiscal_shock_tax_rate}"
+                    )
                 # Also check `tax_rate` for general tax if applicable
 
             # Phase 29: Dynamic Shock Parameters
-            if config.base_interest_rate_multiplier is not None and central_bank and bank:
+            if (
+                config.base_interest_rate_multiplier is not None
+                and central_bank
+                and bank
+            ):
                 # Apply Multiplier to existing rate
-                current_rate = central_bank.base_rate if hasattr(central_bank, "base_rate") else bank.base_rate
+                current_rate = (
+                    central_bank.base_rate
+                    if hasattr(central_bank, "base_rate")
+                    else bank.base_rate
+                )
                 new_rate = current_rate * config.base_interest_rate_multiplier
 
                 if hasattr(central_bank, "base_rate"):
                     central_bank.base_rate = new_rate
                 bank.update_base_rate(new_rate)
-                logger.info(f"  -> MONETARY SHOCK: Multiplied Base Rate by {config.base_interest_rate_multiplier} to {new_rate:.4f}")
+                logger.info(
+                    f"  -> MONETARY SHOCK: Multiplied Base Rate by {config.base_interest_rate_multiplier} to {new_rate:.4f}"
+                )
 
             if config.corporate_tax_rate_delta is not None and government:
                 # Apply Delta to Corporate Tax Rate
                 if hasattr(government, "corporate_tax_rate"):
                     old_rate = government.corporate_tax_rate
                     government.corporate_tax_rate += config.corporate_tax_rate_delta
-                    logger.info(f"  -> FISCAL SHOCK: Increased Corporate Tax Rate by {config.corporate_tax_rate_delta} (From {old_rate} to {government.corporate_tax_rate})")
+                    logger.info(
+                        f"  -> FISCAL SHOCK: Increased Corporate Tax Rate by {config.corporate_tax_rate_delta} (From {old_rate} to {government.corporate_tax_rate})"
+                    )
diff --git a/simulation/systems/firm_management.py b/simulation/systems/firm_management.py
index d5ab7cb..4ffe3ea 100644
--- a/simulation/systems/firm_management.py
+++ b/simulation/systems/firm_management.py
@@ -10,6 +10,7 @@ if TYPE_CHECKING:
 
 logger = logging.getLogger(__name__)
 
+
 class FirmSystem:
     """
     Phase 22.5: Firm Management System
@@ -19,7 +20,9 @@ class FirmSystem:
     def __init__(self, config_module: Any):
         self.config = config_module
 
-    def spawn_firm(self, simulation: "Simulation", founder_household: "Household") -> Optional["Firm"]:
+    def spawn_firm(
+        self, simulation: "Simulation", founder_household: "Household"
+    ) -> Optional["Firm"]:
         """
         Wealthy households found new firms.
         """
@@ -37,57 +40,71 @@ class FirmSystem:
         # 3. Choose Specialization (Blue Ocean Strategy)
         specializations = list(self.config.GOODS.keys())
         is_visionary = False
-        
+
         mutation_rate = getattr(self.config, "VISIONARY_MUTATION_RATE", 0.05)
         if random.random() < mutation_rate:
             is_visionary = True
-            
+
         if is_visionary:
             active_specs = {f.specialization for f in simulation.firms if f.is_active}
-            potential_blue_oceans = [s for s in specializations if s not in active_specs]
-            
+            potential_blue_oceans = [
+                s for s in specializations if s not in active_specs
+            ]
+
             if potential_blue_oceans:
                 specialization = random.choice(potential_blue_oceans)
             else:
                 specialization = random.choice(specializations)
         else:
             specialization = random.choice(specializations)
-            
+
         goods_config = self.config.GOODS.get(specialization, {})
         sector = goods_config.get("sector", "OTHER")
 
         has_inputs = bool(goods_config.get("inputs"))
         if has_inputs:
-             startup_cost *= 1.5
+            startup_cost *= 1.5
 
         # 4. AI Setup
         from simulation.ai.firm_ai import FirmAI
         from simulation.ai.service_firm_ai import ServiceFirmAI
-        from simulation.decisions.ai_driven_firm_engine import AIDrivenFirmDecisionEngine
+        from simulation.decisions.ai_driven_firm_engine import (
+            AIDrivenFirmDecisionEngine,
+        )
         from simulation.firms import Firm
         from simulation.service_firms import ServiceFirm
 
-        value_orientation = random.choice([
-            self.config.VALUE_ORIENTATION_WEALTH_AND_NEEDS,
-            self.config.VALUE_ORIENTATION_NEEDS_AND_GROWTH,
-        ])
+        value_orientation = random.choice(
+            [
+                self.config.VALUE_ORIENTATION_WEALTH_AND_NEEDS,
+                self.config.VALUE_ORIENTATION_NEEDS_AND_GROWTH,
+            ]
+        )
         ai_decision_engine = simulation.ai_trainer.get_engine(value_orientation)
 
         is_service = specialization in getattr(self.config, "SERVICE_SECTORS", [])
 
         if is_service:
-            firm_ai = ServiceFirmAI(agent_id=str(new_firm_id), ai_decision_engine=ai_decision_engine)
+            firm_ai = ServiceFirmAI(
+                agent_id=str(new_firm_id), ai_decision_engine=ai_decision_engine
+            )
         else:
-            firm_ai = FirmAI(agent_id=str(new_firm_id), ai_decision_engine=ai_decision_engine)
+            firm_ai = FirmAI(
+                agent_id=str(new_firm_id), ai_decision_engine=ai_decision_engine
+            )
 
-        firm_decision_engine = AIDrivenFirmDecisionEngine(firm_ai, self.config, simulation.logger)
+        firm_decision_engine = AIDrivenFirmDecisionEngine(
+            firm_ai, self.config, simulation.logger
+        )
 
         # 5. Create Firm
         instance_class = ServiceFirm if is_service else Firm
         new_firm = instance_class(
             id=new_firm_id,
             initial_capital=startup_cost,
-            initial_liquidity_need=getattr(self.config, "INITIAL_FIRM_LIQUIDITY_NEED_MEAN", 50.0),
+            initial_liquidity_need=getattr(
+                self.config, "INITIAL_FIRM_LIQUIDITY_NEED_MEAN", 50.0
+            ),
             specialization=specialization,
             productivity_factor=random.uniform(8.0, 12.0),
             decision_engine=firm_decision_engine,
@@ -97,7 +114,7 @@ class FirmSystem:
             sector=sector,
             is_visionary=is_visionary,
         )
-        
+
         new_firm.founder_id = founder_household.id
         if "loan_market" in simulation.markets:
             new_firm.decision_engine.loan_market = simulation.markets["loan_market"]
@@ -129,7 +146,7 @@ class FirmSystem:
         max_firms = max(5, int(len(simulation.households) / 15))
 
         if active_firms_count >= max_firms:
-            return # Prevent over-creation of firms (Labor Dilution)
+            return  # Prevent over-creation of firms (Labor Dilution)
 
         if active_firms_count < min_firms:
             trigger_probability = 0.5
@@ -137,7 +154,8 @@ class FirmSystem:
             trigger_probability = spirit
 
         wealthy_households = [
-            h for h in simulation.households
+            h
+            for h in simulation.households
             if h.is_active and h.assets > startup_cost * capital_multiplier
         ]
 
diff --git a/simulation/systems/generational_wealth_audit.py b/simulation/systems/generational_wealth_audit.py
index b1ec26a..4249f51 100644
--- a/simulation/systems/generational_wealth_audit.py
+++ b/simulation/systems/generational_wealth_audit.py
@@ -5,11 +5,13 @@ from simulation.core_agents import Household
 
 logger = logging.getLogger(__name__)
 
+
 class GenerationalWealthAudit:
     """
     WO-058: Generational Wealth Audit
     Calculates and logs the distribution of wealth across generations.
     """
+
     def __init__(self, config_module: Any):
         self.config_module = config_module
         self.logger = logging.getLogger("simulation.systems.generational_wealth_audit")
@@ -29,14 +31,19 @@ class GenerationalWealthAudit:
             if not agent.is_active:
                 continue
 
-            generation = getattr(agent, 'generation', 1)
+            generation = getattr(agent, "generation", 1)
             wealth = agent.assets
 
-            wealth_by_generation[generation] = wealth_by_generation.get(generation, 0.0) + wealth
+            wealth_by_generation[generation] = (
+                wealth_by_generation.get(generation, 0.0) + wealth
+            )
             count_by_generation[generation] = count_by_generation.get(generation, 0) + 1
 
         if not wealth_by_generation:
-            self.logger.info("GENERATIONAL_WEALTH_AUDIT | No active agents to audit.", extra={"tick": current_tick})
+            self.logger.info(
+                "GENERATIONAL_WEALTH_AUDIT | No active agents to audit.",
+                extra={"tick": current_tick},
+            )
             return
 
         total_wealth = sum(wealth_by_generation.values())
@@ -49,4 +56,6 @@ class GenerationalWealthAudit:
             wealth_share = (wealth / total_wealth) * 100 if total_wealth > 0 else 0
             log_message += f"  - Gen {gen}: {count} agents, Total Wealth: {wealth:.2f} ({wealth_share:.2f}%), Avg Wealth: {avg_wealth:.2f}\n"
 
-        self.logger.info(log_message.strip(), extra={"tick": current_tick, "tags": ["wealth_audit"]})
+        self.logger.info(
+            log_message.strip(), extra={"tick": current_tick, "tags": ["wealth_audit"]}
+        )
diff --git a/simulation/systems/housing_system.py b/simulation/systems/housing_system.py
index 17c1d94..679b7f1 100644
--- a/simulation/systems/housing_system.py
+++ b/simulation/systems/housing_system.py
@@ -11,6 +11,7 @@ if TYPE_CHECKING:
 
 logger = logging.getLogger(__name__)
 
+
 class HousingSystem:
     """
     Phase 22.5: Housing Market System
@@ -35,20 +36,22 @@ class HousingSystem:
                         old_owner_id = unit.owner_id
                         unit.owner_id = -1  # -1 is Bank/Govt
                         unit.mortgage_id = None
-                        
+
                         # Evict Occupant (if owner was occupying)
                         if unit.occupant_id == old_owner_id:
                             unit.occupant_id = None
                             old_owner_agent = simulation.agents.get(old_owner_id)
-                            if old_owner_agent and hasattr(old_owner_agent, "owned_properties"):
+                            if old_owner_agent and hasattr(
+                                old_owner_agent, "owned_properties"
+                            ):
                                 if unit.id in old_owner_agent.owned_properties:
                                     old_owner_agent.owned_properties.remove(unit.id)
                                 if hasattr(old_owner_agent, "residing_property_id"):
                                     old_owner_agent.residing_property_id = None
                                     old_owner_agent.is_homeless = True
-                                    
+
                         simulation.bank.terminate_loan(loan.id)
-                        
+
                         fire_sale_price = unit.estimated_value * 0.8
                         sell_order = Order(
                             agent_id=-1,
@@ -56,10 +59,12 @@ class HousingSystem:
                             price=fire_sale_price,
                             quantity=1.0,
                             market_id="housing",
-                            order_type="SELL"
+                            order_type="SELL",
                         )
                         if "housing" in simulation.markets:
-                            simulation.markets["housing"].place_order(sell_order, simulation.time)
+                            simulation.markets["housing"].place_order(
+                                sell_order, simulation.time
+                            )
 
         # 2. Rent & Maintenance
         for unit in simulation.real_estate_units:
@@ -71,12 +76,16 @@ class HousingSystem:
                     if owner.assets >= cost:
                         owner._sub_assets(cost)
                         if simulation.reflux_system:
-                            simulation.reflux_system.capture(cost, f"{owner.id}", "housing_maintenance")
+                            simulation.reflux_system.capture(
+                                cost, f"{owner.id}", "housing_maintenance"
+                            )
                     else:
                         taken = owner.assets
                         owner._sub_assets(taken)
                         if simulation.reflux_system:
-                            simulation.reflux_system.capture(taken, f"{owner.id}", "housing_maintenance")
+                            simulation.reflux_system.capture(
+                                taken, f"{owner.id}", "housing_maintenance"
+                            )
 
             # B. Rent Collection (Tenant pays Owner)
             if unit.occupant_id is not None and unit.owner_id is not None:
@@ -95,7 +104,7 @@ class HousingSystem:
                         # Eviction due to rent non-payment
                         logger.info(
                             f"EVICTION | Household {tenant.id} evicted from Unit {unit.id} due to non-payment.",
-                            extra={"agent_id": tenant.id, "unit_id": unit.id}
+                            extra={"agent_id": tenant.id, "unit_id": unit.id},
                         )
                         unit.occupant_id = None
                         if hasattr(tenant, "residing_property_id"):
@@ -117,7 +126,7 @@ class HousingSystem:
                     hh.needs["survival"] += self.config.HOMELESS_PENALTY_PER_TICK
                     logger.debug(
                         f"HOMELESS_PENALTY | Household {hh.id} survival need increased.",
-                        extra={"agent_id": hh.id}
+                        extra={"agent_id": hh.id},
                     )
 
     def process_transaction(self, tx: Transaction, simulation: "Simulation"):
@@ -127,8 +136,10 @@ class HousingSystem:
         """
         try:
             unit_id = int(tx.item_id.split("_")[1])
-            unit = next((u for u in simulation.real_estate_units if u.id == unit_id), None)
-            
+            unit = next(
+                (u for u in simulation.real_estate_units if u.id == unit_id), None
+            )
+
             if not unit:
                 logger.warning(f"HOUSING | Unit {tx.item_id} not found.")
                 return
@@ -143,18 +154,18 @@ class HousingSystem:
             ltv_ratio = getattr(self.config, "MORTGAGE_LTV_RATIO", 0.8)
             mortgage_term = getattr(self.config, "MORTGAGE_TERM_TICKS", 300)
             mortgage_rate = getattr(self.config, "MORTGAGE_INTEREST_RATE", 0.05)
-            
+
             trade_value = tx.price * tx.quantity
 
-            if hasattr(buyer, "owned_properties"): # Household check
+            if hasattr(buyer, "owned_properties"):  # Household check
                 loan_amount = trade_value * ltv_ratio
                 loan_id = simulation.bank.grant_loan(
                     buyer.id,
                     loan_amount,
                     term_ticks=mortgage_term,
-                    interest_rate=mortgage_rate
+                    interest_rate=mortgage_rate,
                 )
-                
+
                 if loan_id:
                     simulation.bank._sub_assets(loan_amount)
                     buyer._add_assets(loan_amount)
@@ -163,7 +174,7 @@ class HousingSystem:
                     unit.mortgage_id = None
             else:
                 unit.mortgage_id = None
-                
+
             # 2. Process Funds Transfer
             buyer._sub_assets(trade_value)
 
@@ -180,12 +191,12 @@ class HousingSystem:
 
             # 3. Transfer Title
             unit.owner_id = buyer.id
-            
+
             # 4. Update Agent Property Lists
             if hasattr(seller, "owned_properties"):
                 if unit.id in seller.owned_properties:
                     seller.owned_properties.remove(unit.id)
-            
+
             if hasattr(buyer, "owned_properties"):
                 if unit.id not in buyer.owned_properties:
                     buyer.owned_properties.append(unit.id)
@@ -193,10 +204,10 @@ class HousingSystem:
                     unit.occupant_id = buyer.id
                     buyer.residing_property_id = unit.id
                     buyer.is_homeless = False
-            
+
             logger.info(
                 f"REAL_ESTATE | Sold Unit {unit.id} to {buyer.id}. Price: {trade_value:.2f}",
-                extra={"tick": simulation.time, "tags": ["real_estate"]}
+                extra={"tick": simulation.time, "tags": ["real_estate"]},
             )
 
         except Exception as e:
diff --git a/simulation/systems/immigration_manager.py b/simulation/systems/immigration_manager.py
index 6275b15..d78a99c 100644
--- a/simulation/systems/immigration_manager.py
+++ b/simulation/systems/immigration_manager.py
@@ -4,11 +4,14 @@ from typing import List, Any
 from simulation.core_agents import Household, Talent
 from simulation.ai.api import Personality
 from simulation.ai.household_ai import HouseholdAI
-from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
+from simulation.decisions.ai_driven_household_engine import (
+    AIDrivenHouseholdDecisionEngine,
+)
 from simulation.ai_model import AIEngineRegistry
 
 logger = logging.getLogger(__name__)
 
+
 class ImmigrationManager:
     """
     Phase 20 Step 3: Immigration Manager
@@ -48,7 +51,7 @@ class ImmigrationManager:
             batch_size = getattr(self.config, "IMMIGRATION_BATCH_SIZE", 5)
             logger.info(
                 f"IMMIGRATION_TRIGGERED | Pop: {total_population}, Unemp: {unemployment_rate:.2%}, Vacancies: {job_vacancies}. Influx: {batch_size}",
-                extra={"tick": engine.time, "tags": ["immigration"]}
+                extra={"tick": engine.time, "tags": ["immigration"]},
             )
 
             new_immigrants = self._create_immigrants(engine, batch_size)
@@ -67,7 +70,7 @@ class ImmigrationManager:
             "needs_and_social_status",
         ]
 
-        goods_data = engine.goods_data # Reuse from engine
+        goods_data = engine.goods_data  # Reuse from engine
 
         for _ in range(count):
             agent_id = engine.next_agent_id
@@ -86,9 +89,12 @@ class ImmigrationManager:
                     # If government funds are insufficient, immigration is restricted.
                     logger.warning(
                         f"IMMIGRATION_RESTRICTED | Government lacks funds for immigrant grant {initial_assets:.2f}",
-                        extra={"tick": engine.time, "tags": ["immigration", "funding_fail"]}
+                        extra={
+                            "tick": engine.time,
+                            "tags": ["immigration", "funding_fail"],
+                        },
                     )
-                    break # Stop creating immigrants in this batch
+                    break  # Stop creating immigrants in this batch
 
             personality = random.choice(list(Personality))
             value_orientation = random.choice(all_value_orientations)
@@ -99,8 +105,12 @@ class ImmigrationManager:
 
             # Setup AI Engine
             # Note: We need the ai_trainer from engine to get the shared engine instance
-            ai_decision_engine_instance = engine.ai_trainer.get_engine(value_orientation)
-            household_ai_instance = HouseholdAI(agent_id=agent_id, ai_decision_engine=ai_decision_engine_instance)
+            ai_decision_engine_instance = engine.ai_trainer.get_engine(
+                value_orientation
+            )
+            household_ai_instance = HouseholdAI(
+                agent_id=agent_id, ai_decision_engine=ai_decision_engine_instance
+            )
 
             household_decision_engine = AIDrivenHouseholdDecisionEngine(
                 ai_engine=household_ai_instance, config_module=self.config
@@ -114,7 +124,7 @@ class ImmigrationManager:
                 "asset": 10.0,
                 "imitation_need": 15.0,
                 "labor_need": 0.0,
-                "liquidity_need": 50.0
+                "liquidity_need": 50.0,
             }
 
             # Create Household
@@ -132,13 +142,13 @@ class ImmigrationManager:
                 personality=personality,
                 config_module=self.config,
                 risk_aversion=risk_aversion,
-                logger=logger
+                logger=logger,
             )
 
             # Set specific immigrant traits
             household.education_level = education_level
             household.gender = random.choice(["M", "F"])
-            household.age = random.randint(20, 35) # Young workforce
+            household.age = random.randint(20, 35)  # Young workforce
 
             # Initial Inventory (Survival Kit)
             household.inventory["basic_food"] = 5.0
diff --git a/simulation/systems/inheritance_manager.py b/simulation/systems/inheritance_manager.py
index 5f7c78e..116c02f 100644
--- a/simulation/systems/inheritance_manager.py
+++ b/simulation/systems/inheritance_manager.py
@@ -7,17 +7,21 @@ from simulation.portfolio import Portfolio
 
 logger = logging.getLogger(__name__)
 
+
 class InheritanceManager:
     """
     Phase 22 (WO-049): Legacy Protocol
     Handles Death, Valuation, Taxation (Liquidation), and Transfer.
     Ensures 'Zero Leak' and atomic settlement.
     """
+
     def __init__(self, config_module: Any):
         self.config_module = config_module
         self.logger = logging.getLogger("simulation.systems.inheritance_manager")
 
-    def process_death(self, deceased: Household, government: Government, simulation: Any) -> None:
+    def process_death(
+        self, deceased: Household, government: Government, simulation: Any
+    ) -> None:
         """
         Executes the inheritance pipeline.
 
@@ -27,17 +31,17 @@ class InheritanceManager:
             simulation: Access to markets/registry for liquidation and transfer.
         """
         # Access SettlementSystem via standard Simulation facade or WorldState DTO
-        settlement = getattr(simulation, 'settlement_system', None)
-        if not settlement and hasattr(simulation, 'world_state'):
-             settlement = getattr(simulation.world_state, 'settlement_system', None)
+        settlement = getattr(simulation, "settlement_system", None)
+        if not settlement and hasattr(simulation, "world_state"):
+            settlement = getattr(simulation.world_state, "settlement_system", None)
 
         # If simulation is WorldState DTO itself (legacy compatibility)
-        if not settlement and hasattr(simulation, 'time'): # Weak check for DTO
-             settlement = getattr(simulation, 'settlement_system', None)
+        if not settlement and hasattr(simulation, "time"):  # Weak check for DTO
+            settlement = getattr(simulation, "settlement_system", None)
 
         self.logger.info(
             f"INHERITANCE_START | Processing death for Household {deceased.id}. Assets: {deceased.assets:.2f}",
-            extra={"agent_id": deceased.id, "tags": ["inheritance", "death"]}
+            extra={"agent_id": deceased.id, "tags": ["inheritance", "death"]},
         )
 
         # 1. Valuation
@@ -47,7 +51,9 @@ class InheritanceManager:
         # Real Estate Valuation
         real_estate_value = 0.0
         # Access real estate units from simulation (assuming simulation has list)
-        deceased_units = [u for u in simulation.real_estate_units if u.owner_id == deceased.id]
+        deceased_units = [
+            u for u in simulation.real_estate_units if u.owner_id == deceased.id
+        ]
 
         # We need current market value. Unit.estimated_value should be up to date or we fetch from market?
         # Simulation._process_housing might update estimated_value?
@@ -63,7 +69,7 @@ class InheritanceManager:
             for firm_id, share in deceased.portfolio.holdings.items():
                 price = simulation.stock_market.get_daily_avg_price(firm_id)
                 if price <= 0:
-                    price = share.acquisition_price # Fallback to book cost
+                    price = share.acquisition_price  # Fallback to book cost
                 current_prices[firm_id] = price
                 stock_value += share.quantity * price
 
@@ -79,7 +85,11 @@ class InheritanceManager:
 
         self.logger.info(
             f"ESTATE_VALUATION | Agent {deceased.id}: Cash={cash:.0f}, RE={real_estate_value:.0f}, Stock={stock_value:.0f} -> Total={total_wealth:.0f}. Tax={tax_amount:.0f}",
-            extra={"agent_id": deceased.id, "total_wealth": total_wealth, "tax_amount": tax_amount}
+            extra={
+                "agent_id": deceased.id,
+                "total_wealth": total_wealth,
+                "tax_amount": tax_amount,
+            },
         )
 
         # 3. Liquidation Logic (Atomic)
@@ -110,14 +120,22 @@ class InheritanceManager:
 
                 # Transfer: Deceased -> Cash, Government -> Stock (or burn?)
                 if settlement:
-                    settlement.transfer(government, deceased, proceeds, f"liquidation_stock:{firm_id}")
+                    settlement.transfer(
+                        government, deceased, proceeds, f"liquidation_stock:{firm_id}"
+                    )
                 else:
-                    if hasattr(government, '_sub_assets'): government._sub_assets(proceeds)
-                    else: government.assets -= proceeds
-                    if hasattr(deceased, '_add_assets'): deceased._add_assets(proceeds)
-                    else: deceased.assets += proceeds
-
-                simulation.government.total_money_issued += proceeds # Injection (Bank/Gov Buyout)
+                    if hasattr(government, "_sub_assets"):
+                        government._sub_assets(proceeds)
+                    else:
+                        government.assets -= proceeds
+                    if hasattr(deceased, "_add_assets"):
+                        deceased._add_assets(proceeds)
+                    else:
+                        deceased.assets += proceeds
+
+                simulation.government.total_money_issued += (
+                    proceeds  # Injection (Bank/Gov Buyout)
+                )
 
                 liquidation_proceeds += proceeds
 
@@ -141,7 +159,7 @@ class InheritanceManager:
 
             self.logger.info(
                 f"LIQUIDATION_STOCK | Sold stocks for {liquidation_proceeds:.2f} to cover tax.",
-                 extra={"agent_id": deceased.id}
+                extra={"agent_id": deceased.id},
             )
 
         # B. Real Estate Liquidation (Fire Sale)
@@ -152,23 +170,29 @@ class InheritanceManager:
 
             for unit in deceased_units:
                 if deceased.assets >= tax_amount:
-                    break # Stop if we have enough cash
+                    break  # Stop if we have enough cash
 
                 sale_price = unit.estimated_value * fire_sale_ratio
 
                 # Govt buys unit
                 if settlement:
-                    settlement.transfer(government, deceased, sale_price, f"liquidation_re:{unit.id}")
+                    settlement.transfer(
+                        government, deceased, sale_price, f"liquidation_re:{unit.id}"
+                    )
                 else:
-                    if hasattr(government, '_sub_assets'): government._sub_assets(sale_price)
-                    else: government.assets -= sale_price
-                    if hasattr(deceased, '_add_assets'): deceased._add_assets(sale_price)
-                    else: deceased.assets += sale_price
+                    if hasattr(government, "_sub_assets"):
+                        government._sub_assets(sale_price)
+                    else:
+                        government.assets -= sale_price
+                    if hasattr(deceased, "_add_assets"):
+                        deceased._add_assets(sale_price)
+                    else:
+                        deceased.assets += sale_price
 
-                simulation.government.total_money_issued += sale_price # Injection
+                simulation.government.total_money_issued += sale_price  # Injection
 
                 # Transfer Title
-                unit.owner_id = None # Government/Public
+                unit.owner_id = None  # Government/Public
                 # Or set to Government ID?
                 # Simulation uses None for Government owned.
 
@@ -177,7 +201,7 @@ class InheritanceManager:
 
                 self.logger.info(
                     f"LIQUIDATION_RE | Sold Unit {unit.id} for {sale_price:.2f} (Fire Sale).",
-                    extra={"agent_id": deceased.id, "unit_id": unit.id}
+                    extra={"agent_id": deceased.id, "unit_id": unit.id},
                 )
 
         # 4. Tax Payment
@@ -186,12 +210,17 @@ class InheritanceManager:
         actual_tax_paid = min(deceased.assets, tax_amount)
         if actual_tax_paid > 0:
             if settlement:
-                settlement.transfer(deceased, government, actual_tax_paid, "inheritance_tax")
+                settlement.transfer(
+                    deceased, government, actual_tax_paid, "inheritance_tax"
+                )
             else:
                 deceased.withdraw(actual_tax_paid)
                 government.deposit(actual_tax_paid)
 
-            simulation.government.collect_tax(actual_tax_paid, "inheritance_tax", deceased, simulation.time)
+            # WO-116: Use record_revenue to avoid Double-Charge via FinanceSystem
+            simulation.government.record_revenue(
+                actual_tax_paid, "inheritance_tax", deceased.id, simulation.time
+            )
 
         # 5. Distribution (Transfer)
         # ------------------------------------------------------------------
@@ -207,43 +236,54 @@ class InheritanceManager:
             surplus = deceased.assets
             if surplus > 0:
                 if settlement:
-                    settlement.transfer(deceased, government, surplus, "escheatment_no_heirs")
+                    settlement.transfer(
+                        deceased, government, surplus, "escheatment_no_heirs"
+                    )
                 else:
                     deceased.withdraw(surplus)
                     government.deposit(surplus)
 
-                simulation.government.collect_tax(surplus, "escheatment", deceased, simulation.time)
+                # WO-116: Use record_revenue
+                simulation.government.record_revenue(
+                    surplus, "escheatment", deceased.id, simulation.time
+                )
                 self.logger.info(
                     f"NO_HEIRS | Confiscated cash {surplus:.2f} to Government.",
-                    extra={"agent_id": deceased.id}
+                    extra={"agent_id": deceased.id},
                 )
 
             # 2. State Confiscation (Stocks)
             # Transfer all remaining shares to Government
             for firm_id, share in list(deceased.portfolio.holdings.items()):
-                 qty = share.quantity
-                 if qty > 0:
-                     # Update Shareholder Registry: Deceased -> 0, Govt -> +qty
-                     if simulation.stock_market:
-                         simulation.stock_market.update_shareholder(deceased.id, firm_id, 0)
-                         simulation.stock_market.update_shareholder(simulation.government.id, firm_id, qty)
-            
+                qty = share.quantity
+                if qty > 0:
+                    # Update Shareholder Registry: Deceased -> 0, Govt -> +qty
+                    if simulation.stock_market:
+                        simulation.stock_market.update_shareholder(
+                            deceased.id, firm_id, 0
+                        )
+                        simulation.stock_market.update_shareholder(
+                            simulation.government.id, firm_id, qty
+                        )
+
             # Clear Deceased Portfolio
             deceased.portfolio.holdings.clear()
             deceased.shares_owned.clear()
 
             # 3. State Confiscation (Real Estate)
             # Transfer all remaining properties to Government
-            remaining_units = [u for u in simulation.real_estate_units if u.owner_id == deceased.id]
+            remaining_units = [
+                u for u in simulation.real_estate_units if u.owner_id == deceased.id
+            ]
             for unit in remaining_units:
                 unit.owner_id = simulation.government.id
                 # Note: deceased.owned_properties will be cleared below
-            
+
             deceased.owned_properties.clear()
-            
+
             self.logger.info(
-                 f"NO_HEIRS_ASSETS | Confiscated {len(remaining_units)} properties and portfolio to Government.",
-                 extra={"agent_id": deceased.id}
+                f"NO_HEIRS_ASSETS | Confiscated {len(remaining_units)} properties and portfolio to Government.",
+                extra={"agent_id": deceased.id},
             )
 
             return
@@ -258,7 +298,9 @@ class InheritanceManager:
 
         for heir in heirs:
             if settlement:
-                settlement.transfer(deceased, heir, cash_share, f"inheritance_share:{deceased.id}")
+                settlement.transfer(
+                    deceased, heir, cash_share, f"inheritance_share:{deceased.id}"
+                )
             else:
                 deceased._sub_assets(cash_share)
                 heir._add_assets(cash_share)
@@ -274,14 +316,21 @@ class InheritanceManager:
 
         remainder = deceased.assets
         if remainder > 0:
-             if settlement:
-                 settlement.transfer(deceased, government, remainder, "inheritance_residual")
-             else:
-                 deceased.withdraw(remainder)
-                 government.deposit(remainder)
+            if settlement:
+                settlement.transfer(
+                    deceased, government, remainder, "inheritance_residual"
+                )
+            else:
+                deceased.withdraw(remainder)
+                government.deposit(remainder)
 
-             simulation.government.collect_tax(remainder, "inheritance_residual", deceased, simulation.time)
-             self.logger.info(f"RESIDUAL_CAPTURED | Transferred {remainder:.4f} residual dust to Government.")
+            # WO-116: Use record_revenue
+            simulation.government.record_revenue(
+                remainder, "inheritance_residual", deceased.id, simulation.time
+            )
+            self.logger.info(
+                f"RESIDUAL_CAPTURED | Transferred {remainder:.4f} residual dust to Government."
+            )
 
         # deceased.assets should be 0.0 now.
 
@@ -297,7 +346,9 @@ class InheritanceManager:
                     heir.shares_owned[firm_id] = current_legacy + qty_per_heir
 
                     if simulation.stock_market:
-                         simulation.stock_market.update_shareholder(heir.id, firm_id, heir.shares_owned[firm_id])
+                        simulation.stock_market.update_shareholder(
+                            heir.id, firm_id, heir.shares_owned[firm_id]
+                        )
 
             # Clear deceased
             if simulation.stock_market:
@@ -311,13 +362,15 @@ class InheritanceManager:
         # Logic: Assign units round-robin to heirs? Or sell and split cash?
         # WO says "RealEstate: Update Registry Owner ID." implying transfer.
         # Simple Round Robin.
-        remaining_units = [u for u in simulation.real_estate_units if u.owner_id == deceased.id]
+        remaining_units = [
+            u for u in simulation.real_estate_units if u.owner_id == deceased.id
+        ]
 
         for i, unit in enumerate(remaining_units):
             target_heir = heirs[i % num_heirs]
 
             unit.owner_id = target_heir.id
-            if hasattr(target_heir, 'owned_properties'):
+            if hasattr(target_heir, "owned_properties"):
                 target_heir.owned_properties.append(unit.id)
             # Deceased removed locally from list (we iterate copy or access simulation list)
             # deceased.owned_properties already handled? No.
@@ -327,5 +380,5 @@ class InheritanceManager:
 
         self.logger.info(
             f"INHERITANCE_COMPLETE | Transferred assets to {num_heirs} heirs.",
-            extra={"agent_id": deceased.id, "heirs_count": num_heirs}
+            extra={"agent_id": deceased.id, "heirs_count": num_heirs},
         )
diff --git a/simulation/systems/labor_market_analyzer.py b/simulation/systems/labor_market_analyzer.py
index 096771b..8743caa 100644
--- a/simulation/systems/labor_market_analyzer.py
+++ b/simulation/systems/labor_market_analyzer.py
@@ -1,10 +1,12 @@
 """
 Implements the LaborMarketAnalyzer which tracks market-wide wage history.
 """
+
 from collections import deque
 from typing import Any, Dict, Deque
 from simulation.systems.api import ILaborMarketAnalyzer
 
+
 class LaborMarketAnalyzer(ILaborMarketAnalyzer):
     """
     Analyzes labor market trends and calculates shadow reservation wages.
@@ -20,12 +22,14 @@ class LaborMarketAnalyzer(ILaborMarketAnalyzer):
         """
         avg_market_wage = 0.0
         if market_data and "labor" in market_data:
-             avg_market_wage = market_data["labor"].get("avg_wage", 0.0)
+            avg_market_wage = market_data["labor"].get("avg_wage", 0.0)
 
         if avg_market_wage > 0:
             self.market_wage_history.append(avg_market_wage)
 
-    def calculate_shadow_reservation_wage(self, agent: Any, market_data: Dict[str, Any]) -> float:
+    def calculate_shadow_reservation_wage(
+        self, agent: Any, market_data: Dict[str, Any]
+    ) -> float:
         """
         Calculates the shadow reservation wage for an agent based on their status and market history.
         """
@@ -42,7 +46,9 @@ class LaborMarketAnalyzer(ILaborMarketAnalyzer):
 
         # Initialize if zero
         if current_shadow <= 0.0:
-            current_shadow = agent.current_wage if agent.is_employed else agent.expected_wage
+            current_shadow = (
+                agent.current_wage if agent.is_employed else agent.expected_wage
+            )
 
         if agent.is_employed:
             target = max(agent.current_wage, current_shadow)
diff --git a/simulation/systems/lifecycle_manager.py b/simulation/systems/lifecycle_manager.py
index 2007946..c164949 100644
--- a/simulation/systems/lifecycle_manager.py
+++ b/simulation/systems/lifecycle_manager.py
@@ -15,13 +15,20 @@ from simulation.systems.inheritance_manager import InheritanceManager
 from simulation.systems.firm_management import FirmSystem
 from simulation.ai.vectorized_planner import VectorizedHouseholdPlanner
 
+
 class AgentLifecycleManager(AgentLifecycleManagerInterface):
     """ì—ì´ì „íŠ¸ì˜ ìƒì„±, ë…¸í™”, ì‚¬ë§, ì²­ì‚°ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.
-       WO-103: Implements SystemInterface.
+    WO-103: Implements SystemInterface.
     """
 
-    def __init__(self, config_module: Any, demographic_manager: DemographicManager,
-                 inheritance_manager: InheritanceManager, firm_system: FirmSystem, logger: logging.Logger):
+    def __init__(
+        self,
+        config_module: Any,
+        demographic_manager: DemographicManager,
+        inheritance_manager: InheritanceManager,
+        firm_system: FirmSystem,
+        logger: logging.Logger,
+    ):
         self.config = config_module
         self.demographic_manager = demographic_manager
         self.inheritance_manager = inheritance_manager
@@ -84,7 +91,9 @@ class AgentLifecycleManager(AgentLifecycleManagerInterface):
     def _calculate_inventory_value(self, inventory: dict, markets: dict) -> float:
         total_value = 0.0
         # PR Review: Use configured default price instead of hardcoded 10.0
-        default_price = getattr(self.config, "GOODS_INITIAL_PRICE", {}).get("default", 10.0)
+        default_price = getattr(self.config, "GOODS_INITIAL_PRICE", {}).get(
+            "default", 10.0
+        )
 
         for item_id, qty in inventory.items():
             price = default_price
@@ -101,25 +110,32 @@ class AgentLifecycleManager(AgentLifecycleManagerInterface):
 
     def _handle_agent_liquidation(self, state: SimulationState):
         """(ê¸°ì¡´ `_handle_agent_lifecycle` ë¡œì§ ì „ì²´ë¥¼ ì´ ê³³ìœ¼ë¡œ ì´ë™)"""
+        settlement = getattr(state, "settlement_system", None)
 
         inactive_firms = [f for f in state.firms if not f.is_active]
         for firm in inactive_firms:
             self.logger.info(
                 f"FIRM_LIQUIDATION | Starting liquidation for Firm {firm.id}. "
                 f"Assets: {firm.assets:.2f}, Inventory: {sum(firm.inventory.values()):.2f}",
-                extra={"agent_id": firm.id, "tags": ["liquidation"]}
+                extra={"agent_id": firm.id, "tags": ["liquidation"]},
             )
 
             # WO-106: Reflux Capture (Inventory & Capital)
             if state.reflux_system:
                 # 1. Inventory Value
-                inv_value = self._calculate_inventory_value(firm.inventory, state.markets)
+                inv_value = self._calculate_inventory_value(
+                    firm.inventory, state.markets
+                )
                 if inv_value > 0:
-                    state.reflux_system.capture(inv_value, str(firm.id), "liquidation_inventory")
+                    state.reflux_system.capture(
+                        inv_value, str(firm.id), "liquidation_inventory"
+                    )
 
                 # 2. Capital Stock (Scrap Value)
                 if firm.capital_stock > 0:
-                    state.reflux_system.capture(firm.capital_stock, str(firm.id), "liquidation_capital")
+                    state.reflux_system.capture(
+                        firm.capital_stock, str(firm.id), "liquidation_capital"
+                    )
 
             # SoC Refactor: use hr.employees
             for employee in firm.hr.employees:
@@ -129,35 +145,87 @@ class AgentLifecycleManager(AgentLifecycleManagerInterface):
             firm.hr.employees = []
             firm.inventory.clear()
             firm.capital_stock = 0.0
+
+            # WO-116: Zero-Sum Liquidation via SettlementSystem
             total_cash = firm.assets
             if total_cash > 0:
                 outstanding_shares = firm.total_shares - firm.treasury_shares
+
                 if outstanding_shares > 0:
                     for household in state.households:
                         if household.is_active and firm.id in household.shares_owned:
-                            share_ratio = household.shares_owned[firm.id] / outstanding_shares
+                            share_ratio = (
+                                household.shares_owned[firm.id] / outstanding_shares
+                            )
                             distribution = total_cash * share_ratio
-                            household._add_assets(distribution)
+
+                            if settlement:
+                                settlement.transfer(
+                                    firm,
+                                    household,
+                                    distribution,
+                                    "liquidation_distribution",
+                                )
+                            else:
+                                firm._sub_assets(distribution)
+                                household._add_assets(distribution)
+
                             self.logger.info(
                                 f"LIQUIDATION_DISTRIBUTION | Household {household.id} received "
                                 f"{distribution:.2f} from Firm {firm.id} liquidation",
-                                extra={"agent_id": household.id, "tags": ["liquidation"]}
+                                extra={
+                                    "agent_id": household.id,
+                                    "tags": ["liquidation"],
+                                },
                             )
-                else:
+
+                # Capture Remainder (Escheatment)
+                # If we used settlement, firm.assets is reduced. If not, it's manually reduced above.
+                remaining_cash = firm.assets
+                if remaining_cash > 0.01:
                     from simulation.agents.government import Government
+
                     if isinstance(state.government, Government):
-                        # Note: collect_tax no longer adds assets. We must transfer/add manually.
-                        state.government._add_assets(total_cash)
-                        state.government.collect_tax(total_cash, "liquidation_escheatment", firm.id, state.time)
+                        if settlement:
+                            settlement.transfer(
+                                firm,
+                                state.government,
+                                remaining_cash,
+                                "liquidation_escheatment",
+                            )
+                        else:
+                            firm._sub_assets(remaining_cash)
+                            state.government._add_assets(remaining_cash)
+
+                        # Use record_revenue if available (Step 3), else collect_tax (might fail double-charge but safe)
+                        if hasattr(state.government, "record_revenue"):
+                            state.government.record_revenue(
+                                remaining_cash,
+                                "liquidation_escheatment",
+                                firm.id,
+                                state.time,
+                            )
+                        else:
+                            state.government.collect_tax(
+                                remaining_cash,
+                                "liquidation_escheatment",
+                                firm.id,
+                                state.time,
+                            )
+
             for household in state.households:
                 if firm.id in household.shares_owned:
                     del household.shares_owned[firm.id]
                     if state.stock_market:
                         state.stock_market.update_shareholder(household.id, firm.id, 0)
-            firm._sub_assets(firm.assets)
+
+            # Final wipe of any epsilon dust
+            if firm.assets > 0:
+                firm._sub_assets(firm.assets)
+
             self.logger.info(
                 f"FIRM_LIQUIDATION_COMPLETE | Firm {firm.id} fully liquidated.",
-                extra={"agent_id": firm.id, "tags": ["liquidation"]}
+                extra={"agent_id": firm.id, "tags": ["liquidation"]},
             )
 
         inactive_households = [h for h in state.households if not h.is_active]
@@ -167,17 +235,21 @@ class AgentLifecycleManager(AgentLifecycleManagerInterface):
 
             # WO-106: Reflux Capture (Household Inventory)
             if state.reflux_system:
-                inv_value = self._calculate_inventory_value(household.inventory, state.markets)
+                inv_value = self._calculate_inventory_value(
+                    household.inventory, state.markets
+                )
                 if inv_value > 0:
-                    state.reflux_system.capture(inv_value, str(household.id), "liquidation_inventory")
+                    state.reflux_system.capture(
+                        inv_value, str(household.id), "liquidation_inventory"
+                    )
 
             household.inventory.clear()
             household.shares_owned.clear()
             if hasattr(household, "portfolio"):
-                 household.portfolio.holdings.clear()
+                household.portfolio.holdings.clear()
             if state.stock_market:
                 for firm_id in list(state.stock_market.shareholders.keys()):
-                     state.stock_market.update_shareholder(household.id, firm_id, 0)
+                    state.stock_market.update_shareholder(household.id, firm_id, 0)
 
         # In-place modification to ensure references in WorldState are updated
         state.households[:] = [h for h in state.households if h.is_active]
@@ -185,12 +257,16 @@ class AgentLifecycleManager(AgentLifecycleManagerInterface):
 
         # Rebuild agents dict
         state.agents.clear()
-        state.agents.update({agent.id: agent for agent in state.households + state.firms})
+        state.agents.update(
+            {agent.id: agent for agent in state.households + state.firms}
+        )
         if state.bank:
-             state.agents[state.bank.id] = state.bank
+            state.agents[state.bank.id] = state.bank
 
         for firm in state.firms:
             # SoC Refactor: use hr.employees
             firm.hr.employees = [
-                emp for emp in firm.hr.employees if emp.is_active and emp.id in state.agents
+                emp
+                for emp in firm.hr.employees
+                if emp.is_active and emp.id in state.agents
             ]
diff --git a/simulation/systems/ma_manager.py b/simulation/systems/ma_manager.py
index 165937f..7264d24 100644
--- a/simulation/systems/ma_manager.py
+++ b/simulation/systems/ma_manager.py
@@ -7,19 +7,23 @@ if TYPE_CHECKING:
     from simulation.db.repository import SimulationRepository
     from simulation.engine import Simulation
     from simulation.ai.firm_system2_planner import FirmSystem2Planner
-    
+
+
 class MAManager:
     """
     Manages Mergers, Acquisitions, and Bankruptcy (Liquidation).
     Runs periodically within the simulation engine.
     Phase 21: Added Hostile Takeover Logic.
     """
+
     def __init__(self, simulation: "Simulation", config_module: Any):
         self.simulation = simulation
         self.config = config_module
         self.logger = logging.getLogger("MAManager")
         self.ma_enabled = getattr(config_module, "MA_ENABLED", True)
-        self.bankruptcy_loss_threshold = getattr(config_module, "BANKRUPTCY_CONSECUTIVE_LOSS_TICKS", 20)
+        self.bankruptcy_loss_threshold = getattr(
+            config_module, "BANKRUPTCY_CONSECUTIVE_LOSS_TICKS", 20
+        )
 
     def process_market_exits_and_entries(self, current_tick: int):
         """
@@ -37,31 +41,33 @@ class MAManager:
 
         # Calculate stats for relative thresholds
         avg_assets = sum(f.assets for f in firms) / len(firms)
-        
+
         predators = []
         preys = []
-        hostile_targets = [] # Phase 21
+        hostile_targets = []  # Phase 21
         bankrupts = []
 
         for firm in firms:
             # Update Valuation first
             firm.calculate_valuation()
-            
+
             # Bankruptcy Criteria
             if firm.assets < 0:
                 bankrupts.append(firm)
                 continue
-            
+
             # Standard Distress (Friendly M&A)
             # SoC Refactor: use finance.consecutive_loss_turns
             if firm.finance.consecutive_loss_turns >= self.bankruptcy_loss_threshold:
-                 preys.append(firm)
+                preys.append(firm)
             elif firm.assets < avg_assets * 0.2:
                 preys.append(firm)
-            
+
             # Phase 21: Hostile Takeover Criteria
             # Target if Market Cap < Intrinsic Value * Threshold
-            intrinsic_value = firm.valuation # Based on calculate_valuation (Net Assets + Profit Premium)
+            intrinsic_value = (
+                firm.valuation
+            )  # Based on calculate_valuation (Net Assets + Profit Premium)
             # Spec says: Market Cap < Intrinsic * 0.7
             # Note: firm.valuation might ALREADY be intrinsic value.
             # Market Cap is different. Market Cap = Stock Price * Shares.
@@ -90,12 +96,12 @@ class MAManager:
 
         # 2. M&A Matching Loop
         random.shuffle(predators)
-        
+
         # Merge lists, prioritize Hostile Targets for Predators who are GROWTH_HACKERs?
         # Let's process Hostile first, then Friendly.
-        
+
         # --- Hostile Takeover Loop ---
-        for predator in list(predators): # Copy list to iterate
+        for predator in list(predators):  # Copy list to iterate
             # Check strategy
             expansion_mode = "ORGANIC"
             if hasattr(predator, "system2_planner") and predator.system2_planner:
@@ -107,18 +113,24 @@ class MAManager:
 
             target_found = False
             for target in hostile_targets:
-                if target.id == predator.id: continue
-                if target in bankrupts: continue # Don't hostile takeover a bankrupt firm (waste)
+                if target.id == predator.id:
+                    continue
+                if target in bankrupts:
+                    continue  # Don't hostile takeover a bankrupt firm (waste)
 
                 # Check Capacity
                 target_mcap = target.get_market_cap()
                 if predator.assets > target_mcap * 1.5:
                     # Attempt Hostile Takeover
-                    success = self._attempt_hostile_takeover(predator, target, target_mcap, current_tick)
+                    success = self._attempt_hostile_takeover(
+                        predator, target, target_mcap, current_tick
+                    )
                     if success:
                         target_found = True
-                        if target in preys: preys.remove(target)
-                        if target in hostile_targets: hostile_targets.remove(target)
+                        if target in preys:
+                            preys.remove(target)
+                        if target in hostile_targets:
+                            hostile_targets.remove(target)
                         break
 
             if target_found:
@@ -126,37 +138,43 @@ class MAManager:
 
         # --- Friendly M&A Loop (Existing Logic) ---
         active_preys = [p for p in preys if p not in bankrupts and p.is_active]
-        
+
         for prey in active_preys:
             acquired = False
             for predator in predators:
                 if predator.id == prey.id:
                     continue
-                
+
                 # Check if Predator can afford
                 target_valuation = prey.valuation
-                offer_price = target_valuation * 1.1 # 10% Premium
-                
+                offer_price = target_valuation * 1.1  # 10% Premium
+
                 # Check Cash Requirement
                 min_cash_ratio = getattr(self.config, "MIN_ACQUISITION_CASH_RATIO", 1.5)
                 if predator.assets >= offer_price * min_cash_ratio:
                     # Attempt Deal
-                    self._execute_merger(predator, prey, offer_price, current_tick, is_hostile=False)
+                    self._execute_merger(
+                        predator, prey, offer_price, current_tick, is_hostile=False
+                    )
                     acquired = True
                     predators.remove(predator)
                     break
-            
+
         # 3. Process Bankruptcies (Liquidation)
         for firm in bankrupts:
-            if firm.is_active: # Check if not acquired already (though unlikely in loop structure)
+            if (
+                firm.is_active
+            ):  # Check if not acquired already (though unlikely in loop structure)
                 self._execute_bankruptcy(firm, current_tick)
 
-    def _attempt_hostile_takeover(self, predator: "Firm", target: "Firm", market_cap: float, tick: int) -> bool:
+    def _attempt_hostile_takeover(
+        self, predator: "Firm", target: "Firm", market_cap: float, tick: int
+    ) -> bool:
         """
         Phase 21: Probabilistic Hostile Takeover.
         """
         # Offer Premium
-        offer_price = market_cap * 1.2 # 20% Premium over market price
+        offer_price = market_cap * 1.2  # 20% Premium over market price
 
         # Success Probability
         # Base 60%
@@ -164,18 +182,31 @@ class MAManager:
 
         # Roll
         if random.random() < success_prob:
-            self.logger.info(f"HOSTILE_TAKEOVER_SUCCESS | Predator {predator.id} seizes Target {target.id}. Offer: {offer_price:,.2f}")
+            self.logger.info(
+                f"HOSTILE_TAKEOVER_SUCCESS | Predator {predator.id} seizes Target {target.id}. Offer: {offer_price:,.2f}"
+            )
             self._execute_merger(predator, target, offer_price, tick, is_hostile=True)
             return True
         else:
-            self.logger.info(f"HOSTILE_TAKEOVER_FAIL | Target {target.id} fended off Predator {predator.id}.")
+            self.logger.info(
+                f"HOSTILE_TAKEOVER_FAIL | Target {target.id} fended off Predator {predator.id}."
+            )
             return False
 
-    def _execute_merger(self, predator: "Firm", prey: "Firm", price: float, tick: int, is_hostile: bool = False):
+    def _execute_merger(
+        self,
+        predator: "Firm",
+        prey: "Firm",
+        price: float,
+        tick: int,
+        is_hostile: bool = False,
+    ):
         tag = "HOSTILE_MERGER" if is_hostile else "FRIENDLY_MERGER"
 
-        self.logger.info(f"{tag}_EXECUTE | Predator {predator.id} acquires Prey {prey.id}. Price: {price:,.2f}.")
-        
+        self.logger.info(
+            f"{tag}_EXECUTE | Predator {predator.id} acquires Prey {prey.id}. Price: {price:,.2f}."
+        )
+
         # 1. Payment
         # predator.assets -= price
 
@@ -185,25 +216,38 @@ class MAManager:
         # For simplicity, pay founder or distribute generally?
         # Let's stick to paying founder as proxy for 'Shareholders'
         if prey.founder_id is not None and prey.founder_id in self.simulation.agents:
-             target_agent = self.simulation.agents[prey.founder_id]
-             if hasattr(self.simulation, 'settlement_system') and self.simulation.settlement_system:
-                 self.simulation.settlement_system.transfer(predator, target_agent, price, f"M&A Acquisition {prey.id}")
-             else:
-                 predator.withdraw(price)
-                 target_agent.deposit(price)
+            target_agent = self.simulation.agents[prey.founder_id]
+            if (
+                hasattr(self.simulation, "settlement_system")
+                and self.simulation.settlement_system
+            ):
+                self.simulation.settlement_system.transfer(
+                    predator, target_agent, price, f"M&A Acquisition {prey.id}"
+                )
+            else:
+                predator.withdraw(price)
+                target_agent.deposit(price)
         else:
-             # If no owner found, transfer to government (state capture)
-             # This policy (State Capture) ensures zero-sum integrity when owner is missing.
-             if hasattr(self.simulation, 'settlement_system') and self.simulation.settlement_system:
-                 self.simulation.settlement_system.transfer(predator, self.simulation.government, price, f"M&A Acquisition {prey.id} (State)")
-             else:
-                 predator.withdraw(price)
-                 self.simulation.government.deposit(price)
-        
+            # If no owner found, transfer to government (state capture)
+            # This policy (State Capture) ensures zero-sum integrity when owner is missing.
+            if (
+                hasattr(self.simulation, "settlement_system")
+                and self.simulation.settlement_system
+            ):
+                self.simulation.settlement_system.transfer(
+                    predator,
+                    self.simulation.government,
+                    price,
+                    f"M&A Acquisition {prey.id} (State)",
+                )
+            else:
+                predator.withdraw(price)
+                self.simulation.government.deposit(price)
+
         # 2. Asset Transfer
         # SoC Refactor: use production.add_capital
         predator.production.add_capital(prey.capital_stock)
-        
+
         # Phase 21: Transfer Automation Tech?
         # If prey has higher automation, predator learns?
         # Or just average?
@@ -216,7 +260,7 @@ class MAManager:
         # Inventory
         for item, qty in prey.inventory.items():
             predator.inventory[item] = predator.inventory.get(item, 0.0) + qty
-            
+
         # Employees
         retained_count = 0
         fired_count = 0
@@ -237,18 +281,22 @@ class MAManager:
                 predator.hr.hire(emp, wage)
                 emp.employer_id = predator.id
                 retained_count += 1
-                
-        self.logger.info(f"{tag}_RESULT | Retained {retained_count}, Fired {fired_count}.")
-        
+
+        self.logger.info(
+            f"{tag}_RESULT | Retained {retained_count}, Fired {fired_count}."
+        )
+
         # 3. Deactivate Prey
-        prey.is_active = False 
+        prey.is_active = False
 
     def _execute_bankruptcy(self, firm: "Firm", tick: int):
         recovered = firm.liquidate_assets()
-        self.logger.info(f"BANKRUPTCY | Firm {firm.id} liquidated. Recovered Cash: {recovered:,.2f}.")
-        
+        self.logger.info(
+            f"BANKRUPTCY | Firm {firm.id} liquidated. Recovered Cash: {recovered:,.2f}."
+        )
+
         # SoC Refactor: use hr.employees
         for emp in list(firm.hr.employees):
             emp.quit()
-            
+
         firm.is_active = False
diff --git a/simulation/systems/ministry_of_education.py b/simulation/systems/ministry_of_education.py
index d0085ee..b44ef4c 100644
--- a/simulation/systems/ministry_of_education.py
+++ b/simulation/systems/ministry_of_education.py
@@ -3,11 +3,18 @@ from typing import List, Any
 
 logger = logging.getLogger(__name__)
 
+
 class MinistryOfEducation:
     def __init__(self, config_module: Any):
         self.config_module = config_module
 
-    def run_public_education(self, households: List[Any], government: Any, current_tick: int, reflux_system: Any = None) -> None:
+    def run_public_education(
+        self,
+        households: List[Any],
+        government: Any,
+        current_tick: int,
+        reflux_system: Any = None,
+    ) -> None:
         """
         WO-054: Public Education System Implementation.
         1. Free Basic Education (Level 0 -> 1)
@@ -23,11 +30,16 @@ class MinistryOfEducation:
             return
 
         active_households.sort(key=lambda x: x.assets)
-        cutoff_idx = int(len(active_households) * getattr(self.config_module, "SCHOLARSHIP_WEALTH_PERCENTILE", 0.20))
+        cutoff_idx = int(
+            len(active_households)
+            * getattr(self.config_module, "SCHOLARSHIP_WEALTH_PERCENTILE", 0.20)
+        )
         poor_households = set(h.id for h in active_households[:cutoff_idx])
 
         costs = getattr(self.config_module, "EDUCATION_COST_PER_LEVEL", {1: 500})
-        scholarship_potential_threshold = getattr(self.config_module, "SCHOLARSHIP_POTENTIAL_THRESHOLD", 0.7)
+        scholarship_potential_threshold = getattr(
+            self.config_module, "SCHOLARSHIP_POTENTIAL_THRESHOLD", 0.7
+        )
 
         for agent in active_households:
             current_level = getattr(agent, "education_level", 0)
@@ -43,12 +55,18 @@ class MinistryOfEducation:
 
                     logger.debug(
                         f"EDU_BASIC_GRANT | Household {agent.id} promoted to Level 1. Cost: {cost}",
-                        extra={"tick": current_tick, "agent_id": government.id, "target_id": agent.id}
+                        extra={
+                            "tick": current_tick,
+                            "agent_id": government.id,
+                            "target_id": agent.id,
+                        },
                     )
 
             elif current_level >= 1:
                 is_poor = agent.id in poor_households
-                has_potential = getattr(agent, "aptitude", 0.0) >= scholarship_potential_threshold
+                has_potential = (
+                    getattr(agent, "aptitude", 0.0) >= scholarship_potential_threshold
+                )
 
                 if is_poor and has_potential:
                     subsidy = cost * 0.8
@@ -62,11 +80,20 @@ class MinistryOfEducation:
 
                         agent._sub_assets(student_share)
                         if reflux_system:
-                            reflux_system.capture(student_share, f"Household_{agent.id}", "education_tuition")
+                            reflux_system.capture(
+                                student_share,
+                                f"Household_{agent.id}",
+                                "education_tuition",
+                            )
 
                         logger.info(
                             f"EDU_SCHOLARSHIP | Household {agent.id} (Aptitude {agent.aptitude:.2f}) promoted to Level {next_level}. Subsidy: {subsidy:.2f}, Student Share: {student_share:.2f}",
-                            extra={"tick": current_tick, "agent_id": government.id, "target_id": agent.id, "aptitude": agent.aptitude}
+                            extra={
+                                "tick": current_tick,
+                                "agent_id": government.id,
+                                "target_id": agent.id,
+                                "aptitude": agent.aptitude,
+                            },
                         )
 
         government.expenditure_this_tick += spent_total
diff --git a/simulation/systems/persistence_manager.py b/simulation/systems/persistence_manager.py
index bc49495..97504cc 100644
--- a/simulation/systems/persistence_manager.py
+++ b/simulation/systems/persistence_manager.py
@@ -16,10 +16,11 @@ if TYPE_CHECKING:
 
 logger = logging.getLogger(__name__)
 
+
 class PersistenceManager:
     """
     Phase 22.5: Persistence Manager System
-    Handles DB state buffering, calculation of aggregate indicators for persistence, 
+    Handles DB state buffering, calculation of aggregate indicators for persistence,
     and batch flushing to simulation repository.
     """
 
@@ -27,19 +28,21 @@ class PersistenceManager:
         self.run_id = run_id
         self.config = config_module
         self.repository = repository
-        
+
         # Internal Buffers
         self.agent_state_buffer: List[AgentStateData] = []
         self.transaction_buffer: List[TransactionData] = []
         self.economic_indicator_buffer: List[EconomicIndicatorData] = []
         self.market_history_buffer: List[MarketHistoryData] = []
 
-    def buffer_tick_state(self, simulation: "Simulation", transactions: List["Transaction"]):
+    def buffer_tick_state(
+        self, simulation: "Simulation", transactions: List["Transaction"]
+    ):
         """
         Gathers and buffers agent states, transactions, and aggregate indicators for the current tick.
         """
         time = simulation.time
-        
+
         # 1. Buffer agent states
         for agent in simulation.agents.values():
             if not getattr(agent, "is_active", False):
@@ -69,7 +72,9 @@ class PersistenceManager:
                 hours_per_tick = getattr(self.config, "HOURS_PER_TICK", 24.0)
 
                 agent_dto.time_leisure = time_leisure
-                agent_dto.time_worked = max(0.0, hours_per_tick - time_leisure - shopping_hours)
+                agent_dto.time_worked = max(
+                    0.0, hours_per_tick - time_leisure - shopping_hours
+                )
 
             elif isinstance(agent, Firm):
                 agent_dto.agent_type = "firm"
@@ -98,14 +103,18 @@ class PersistenceManager:
 
         # 3. Buffer aggregate indicators
         tracker_indicators = simulation.tracker.get_latest_indicators()
-        
+
         # Income Aggregation (Phase 14-1)
-        total_labor_income = sum(getattr(h, "labor_income_this_tick", 0.0) for h in simulation.households)
-        total_capital_income = sum(getattr(h, "capital_income_this_tick", 0.0) for h in simulation.households)
+        total_labor_income = sum(
+            getattr(h, "labor_income_this_tick", 0.0) for h in simulation.households
+        )
+        total_capital_income = sum(
+            getattr(h, "capital_income_this_tick", 0.0) for h in simulation.households
+        )
 
         # Calculate Wealth Distribution (Snapshot)
         total_assets = sum(h.assets for h in simulation.households)
-        
+
         indicator_dto = EconomicIndicatorData(
             run_id=self.run_id,
             time=time,
@@ -116,7 +125,9 @@ class PersistenceManager:
             avg_goods_price=tracker_indicators.get("avg_goods_price"),
             total_production=tracker_indicators.get("total_production", 0.0),
             total_consumption=tracker_indicators.get("total_consumption", 0.0),
-            total_household_assets=tracker_indicators.get("total_household_assets", 0.0),
+            total_household_assets=tracker_indicators.get(
+                "total_household_assets", 0.0
+            ),
             total_firm_assets=tracker_indicators.get("total_firm_assets", 0.0),
             avg_survival_need=tracker_indicators.get("avg_survival_need", 0.0),
             total_labor_income=total_labor_income,
@@ -128,13 +139,17 @@ class PersistenceManager:
         """
         Periodically flushes buffered states to the database repository.
         """
-        if not (self.agent_state_buffer or self.transaction_buffer or 
-                self.economic_indicator_buffer or self.market_history_buffer):
+        if not (
+            self.agent_state_buffer
+            or self.transaction_buffer
+            or self.economic_indicator_buffer
+            or self.market_history_buffer
+        ):
             return
 
         logger.info(
             f"DB_FLUSH_START | Flushing buffers to DB at tick {current_tick}",
-            extra={"tick": current_tick, "tags": ["db_flush"]}
+            extra={"tick": current_tick, "tags": ["db_flush"]},
         )
 
         if self.agent_state_buffer:
@@ -146,7 +161,9 @@ class PersistenceManager:
             self.transaction_buffer.clear()
 
         if self.economic_indicator_buffer:
-            self.repository.save_economic_indicators_batch(self.economic_indicator_buffer)
+            self.repository.save_economic_indicators_batch(
+                self.economic_indicator_buffer
+            )
             self.economic_indicator_buffer.clear()
 
         if self.market_history_buffer:
@@ -155,5 +172,5 @@ class PersistenceManager:
 
         logger.info(
             f"DB_FLUSH_END | Finished flushing buffers to DB at tick {current_tick}",
-            extra={"tick": current_tick, "tags": ["db_flush"]}
+            extra={"tick": current_tick, "tags": ["db_flush"]},
         )
diff --git a/simulation/systems/reflux_system.py b/simulation/systems/reflux_system.py
index d468706..96f4ef2 100644
--- a/simulation/systems/reflux_system.py
+++ b/simulation/systems/reflux_system.py
@@ -4,9 +4,10 @@ from modules.finance.api import IFinancialEntity, InsufficientFundsError
 
 logger = logging.getLogger(__name__)
 
+
 class EconomicRefluxSystem(IFinancialEntity):
     def __init__(self):
-        self._id = 999999 # Special ID for Reflux
+        self._id = 999999  # Special ID for Reflux
         self.balance: float = 0.0
         # Optional: Transaction log for debugging
         # self.transaction_log: list = []
@@ -39,7 +40,9 @@ class EconomicRefluxSystem(IFinancialEntity):
         """
         if amount > 0:
             self.balance += amount
-            logger.debug(f"REFLUX_CAPTURE | Captured {amount:.2f} from {source} ({category})")
+            logger.debug(
+                f"REFLUX_CAPTURE | Captured {amount:.2f} from {source} ({category})"
+            )
 
     def distribute(self, households: list):
         """
@@ -72,12 +75,16 @@ class EconomicRefluxSystem(IFinancialEntity):
                 agent.labor_income_this_tick += amount_per_household
 
             # Legacy support if needed
-            if hasattr(agent, 'income_history') and isinstance(agent.income_history, dict):
-                 agent.income_history['service'] = agent.income_history.get('service', 0.0) + amount_per_household
+            if hasattr(agent, "income_history") and isinstance(
+                agent.income_history, dict
+            ):
+                agent.income_history["service"] = (
+                    agent.income_history.get("service", 0.0) + amount_per_household
+                )
 
         logger.info(
             f"REFLUX_DISTRIBUTE | Distributed {total_amount:.2f} to {len(active_households)} households. ({amount_per_household:.2f} each)",
-            extra={"tags": ["reflux", "distribution"], "total_amount": total_amount}
+            extra={"tags": ["reflux", "distribution"], "total_amount": total_amount},
         )
 
-        self.balance = 0.0 # Reset
+        self.balance = 0.0  # Reset
diff --git a/simulation/systems/sensory_system.py b/simulation/systems/sensory_system.py
index 93a2a0f..4138477 100644
--- a/simulation/systems/sensory_system.py
+++ b/simulation/systems/sensory_system.py
@@ -1,11 +1,13 @@
 """
 Implements the SensorySystem which processes raw economic indicators into smoothed data for the government.
 """
+
 from collections import deque
 from typing import Any, Deque
 from simulation.systems.api import ISensorySystem, SensoryContext
 from simulation.dtos import GovernmentStateDTO
 
+
 class SensorySystem(ISensorySystem):
     """
     Processes raw economic data into SMA buffers and produces Sensory DTOs.
@@ -25,7 +27,9 @@ class SensorySystem(ISensorySystem):
         self.last_avg_price_for_sma: float = 10.0
         self.last_gdp_for_sma: float = 0.0
 
-    def generate_government_sensory_dto(self, context: SensoryContext) -> GovernmentStateDTO:
+    def generate_government_sensory_dto(
+        self, context: SensoryContext
+    ) -> GovernmentStateDTO:
         """
         Calculates indicators, updates buffers, and returns the DTO.
         """
@@ -38,7 +42,9 @@ class SensorySystem(ISensorySystem):
         # 1. Inflation (Price Change)
         current_price = latest_indicators.get("avg_goods_price", 10.0)
         last_price = self.last_avg_price_for_sma
-        inflation_rate = (current_price - last_price) / last_price if last_price > 0 else 0.0
+        inflation_rate = (
+            (current_price - last_price) / last_price if last_price > 0 else 0.0
+        )
         self.last_avg_price_for_sma = current_price
 
         # 2. Unemployment
@@ -74,5 +80,5 @@ class SensorySystem(ISensorySystem):
             gdp_growth_sma=calculate_sma(self.gdp_growth_buffer),
             wage_sma=calculate_sma(self.wage_buffer),
             approval_sma=calculate_sma(self.approval_buffer),
-            current_gdp=current_gdp
+            current_gdp=current_gdp,
         )
diff --git a/simulation/systems/settlement_system.py b/simulation/systems/settlement_system.py
index 70f8c90..85f9a13 100644
--- a/simulation/systems/settlement_system.py
+++ b/simulation/systems/settlement_system.py
@@ -4,6 +4,7 @@ import logging
 from simulation.finance.api import ISettlementSystem
 from modules.finance.api import IFinancialEntity, InsufficientFundsError
 
+
 class SettlementSystem(ISettlementSystem):
     """
     Centralized system for handling all financial transfers between entities.
@@ -20,7 +21,7 @@ class SettlementSystem(ISettlementSystem):
         amount: float,
         memo: str,
         debit_context: Optional[Dict[str, Any]] = None,
-        credit_context: Optional[Dict[str, Any]] = None
+        credit_context: Optional[Dict[str, Any]] = None,
     ) -> bool:
         """
         Executes an atomic transfer from debit_agent to credit_agent.
@@ -29,14 +30,14 @@ class SettlementSystem(ISettlementSystem):
         if amount <= 0:
             self.logger.warning(
                 f"TRANSFER_INVALID_AMOUNT | Amount must be positive. Given: {amount} | Memo: {memo}",
-                extra={"tags": ["settlement", "error"]}
+                extra={"tags": ["settlement", "error"]},
             )
             return False
 
         if debit_agent.id == credit_agent.id:
             self.logger.warning(
                 f"TRANSFER_SELF | Agent {debit_agent.id} attempted self-transfer. | Memo: {memo}",
-                extra={"tags": ["settlement", "warning"]}
+                extra={"tags": ["settlement", "warning"]},
             )
             return False
 
@@ -53,23 +54,23 @@ class SettlementSystem(ISettlementSystem):
                     "debit_agent_id": debit_agent.id,
                     "credit_agent_id": credit_agent.id,
                     "amount": amount,
-                    "tags": ["settlement", "insolvency"]
-                }
+                    "tags": ["settlement", "insolvency"],
+                },
             )
             return False
         except Exception as e:
-             self.logger.critical(
+            self.logger.critical(
                 f"WITHDRAW_FAILURE | Agent {debit_agent.id} failed to withdraw {amount}. Error: {e}",
-                extra={"tags": ["settlement", "error"]}
+                extra={"tags": ["settlement", "error"]},
             )
-             return False
+            return False
 
         try:
             credit_agent.deposit(amount)
         except Exception as e:
             self.logger.critical(
                 f"DEPOSIT_FAILURE | Rolled back transfer of {amount} from {debit_agent.id} to {credit_agent.id}. Error: {e}",
-                extra={"tags": ["settlement", "critical"]}
+                extra={"tags": ["settlement", "critical"]},
             )
             # Rollback: Try to add back to debit_agent
             try:
@@ -77,11 +78,10 @@ class SettlementSystem(ISettlementSystem):
             except Exception as rollback_error:
                 self.logger.critical(
                     f"ROLLBACK_FAILED | SYSTEM CORRUPTED. Agent {debit_agent.id} lost {amount}. Error: {rollback_error}",
-                    extra={"tags": ["settlement", "fatal"]}
+                    extra={"tags": ["settlement", "fatal"]},
                 )
             return False
 
-
         # 4. Success Logging
         self.logger.info(
             f"TRANSFER | {debit_agent.id} -> {credit_agent.id} : {amount:.2f} | {memo}",
@@ -90,7 +90,7 @@ class SettlementSystem(ISettlementSystem):
                 "credit_agent_id": credit_agent.id,
                 "amount": amount,
                 "memo": memo,
-                "tags": ["settlement", "transfer"]
-            }
+                "tags": ["settlement", "transfer"],
+            },
         )
         return True
diff --git a/simulation/systems/social_system.py b/simulation/systems/social_system.py
index 890f44a..4da8c19 100644
--- a/simulation/systems/social_system.py
+++ b/simulation/systems/social_system.py
@@ -1,10 +1,12 @@
 """
 Implements the SocialSystem which handles social rank updates and reference standard calculation.
 """
+
 from typing import Dict, Any, List
 from simulation.systems.api import ISocialSystem, SocialMobilityContext
 from simulation.decisions.housing_manager import HousingManager
 
+
 class SocialSystem(ISocialSystem):
     """
     Manages social mobility, rank calculation, and reference standards for the simulation.
@@ -41,10 +43,11 @@ class SocialSystem(ISocialSystem):
 
         hm = context.get("housing_manager")
         if not hm:
-             hm = HousingManager(None, self.config)
+            hm = HousingManager(None, self.config)
 
         for h in households:
-            if not h.is_active: continue
+            if not h.is_active:
+                continue
 
             # Calculate Score
             consumption_score = h.current_consumption * 10.0
@@ -59,7 +62,8 @@ class SocialSystem(ISocialSystem):
         scores.sort(key=lambda x: x[1], reverse=True)
 
         n = len(scores)
-        if n == 0: return
+        if n == 0:
+            return
 
         for rank_idx, (agent, _) in enumerate(scores):
             # Rank 0 (Top) -> Percentile 1.0
@@ -67,7 +71,9 @@ class SocialSystem(ISocialSystem):
             percentile = 1.0 - (rank_idx / n)
             agent.social_rank = percentile
 
-    def calculate_reference_standard(self, context: SocialMobilityContext) -> Dict[str, float]:
+    def calculate_reference_standard(
+        self, context: SocialMobilityContext
+    ) -> Dict[str, float]:
         """
         Calculates the average consumption and housing tier of the top 20% households.
         """
@@ -78,19 +84,20 @@ class SocialSystem(ISocialSystem):
             return {"avg_consumption": 0.0, "avg_housing_tier": 0.0}
 
         # Sort by social rank
-        sorted_hh = sorted(active_households, key=lambda h: getattr(h, "social_rank", 0.0), reverse=True)
+        sorted_hh = sorted(
+            active_households,
+            key=lambda h: getattr(h, "social_rank", 0.0),
+            reverse=True,
+        )
 
         top_20_count = max(1, int(len(active_households) * 0.20))
         top_20 = sorted_hh[:top_20_count]
 
         hm = context.get("housing_manager")
         if not hm:
-             hm = HousingManager(None, self.config)
+            hm = HousingManager(None, self.config)
 
         avg_cons = sum(h.current_consumption for h in top_20) / len(top_20)
         avg_tier = sum(hm.get_housing_tier(h) for h in top_20) / len(top_20)
 
-        return {
-            "avg_consumption": avg_cons,
-            "avg_housing_tier": avg_tier
-        }
+        return {"avg_consumption": avg_cons, "avg_housing_tier": avg_tier}
diff --git a/simulation/systems/tax_agency.py b/simulation/systems/tax_agency.py
index cd5a719..66006fd 100644
--- a/simulation/systems/tax_agency.py
+++ b/simulation/systems/tax_agency.py
@@ -3,11 +3,18 @@ from typing import Any
 
 logger = logging.getLogger(__name__)
 
+
 class TaxAgency:
     def __init__(self, config_module):
         self.config_module = config_module
 
-    def calculate_income_tax(self, income: float, survival_cost: float, current_income_tax_rate: float, tax_mode: str = 'PROGRESSIVE') -> float:
+    def calculate_income_tax(
+        self,
+        income: float,
+        survival_cost: float,
+        current_income_tax_rate: float,
+        tax_mode: str = "PROGRESSIVE",
+    ) -> float:
         """
         Calculates income tax based on the current rate provided by the Government.
         """
@@ -44,11 +51,48 @@ class TaxAgency:
 
         return raw_tax
 
-    def calculate_corporate_tax(self, profit: float, current_corporate_tax_rate: float) -> float:
+    def calculate_corporate_tax(
+        self, profit: float, current_corporate_tax_rate: float
+    ) -> float:
         """Calculates corporate tax based on the current rate provided by the Government."""
         return profit * current_corporate_tax_rate if profit > 0 else 0.0
 
-    def collect_tax(self, government, amount: float, tax_type: str, payer: Any, current_tick: int) -> float:
+    def record_revenue(
+        self, government, amount: float, tax_type: str, payer_id: Any, current_tick: int
+    ):
+        """
+        Records revenue statistics WITHOUT attempting collection.
+        Used when funds are transferred via SettlementSystem manually.
+        """
+        if amount <= 0:
+            return
+
+        government.total_collected_tax += amount
+        government.revenue_this_tick += amount
+        government.total_money_destroyed += amount
+        government.tax_revenue[tax_type] = (
+            government.tax_revenue.get(tax_type, 0.0) + amount
+        )
+        government.current_tick_stats["tax_revenue"][tax_type] = (
+            government.current_tick_stats["tax_revenue"].get(tax_type, 0.0) + amount
+        )
+        government.current_tick_stats["total_collected"] += amount
+
+        logger.info(
+            f"TAX_RECORDED | Recorded {amount:.2f} as {tax_type} from {payer_id}",
+            extra={
+                "tick": current_tick,
+                "agent_id": government.id,
+                "amount": amount,
+                "tax_type": tax_type,
+                "source_id": payer_id,
+                "tags": ["tax", "revenue", "recorded"],
+            },
+        )
+
+    def collect_tax(
+        self, government, amount: float, tax_type: str, payer: Any, current_tick: int
+    ) -> float:
         """
         Executes tax collection via FinanceSystem and records statistics.
         payer: IFinancialEntity (Firm, Household, etc.)
@@ -56,27 +100,37 @@ class TaxAgency:
         if amount <= 0:
             return 0.0
 
-        payer_id = payer.id if hasattr(payer, 'id') else payer
+        payer_id = payer.id if hasattr(payer, "id") else payer
 
         # Delegate to FinanceSystem for atomic transfer
-        if hasattr(government, 'finance_system') and government.finance_system:
-            if hasattr(payer, 'id'):
-                 success = government.finance_system.collect_corporate_tax(payer, amount)
-                 if not success:
-                      logger.warning(f"TAX_COLLECTION_FAILED | Failed to collect {amount} from {payer_id}")
-                      return 0.0
+        if hasattr(government, "finance_system") and government.finance_system:
+            if hasattr(payer, "id"):
+                success = government.finance_system.collect_corporate_tax(payer, amount)
+                if not success:
+                    logger.warning(
+                        f"TAX_COLLECTION_FAILED | Failed to collect {amount} from {payer_id}"
+                    )
+                    return 0.0
             else:
-                 logger.error(f"TAX_COLLECTION_ERROR | Payer {payer} is not an object. Cannot use FinanceSystem.")
-                 return 0.0
+                logger.error(
+                    f"TAX_COLLECTION_ERROR | Payer {payer} is not an object. Cannot use FinanceSystem."
+                )
+                return 0.0
         else:
-            logger.error("TAX_COLLECTION_ERROR | No FinanceSystem linked to Government.")
+            logger.error(
+                "TAX_COLLECTION_ERROR | No FinanceSystem linked to Government."
+            )
             return 0.0
 
         government.total_collected_tax += amount
         government.revenue_this_tick += amount
         government.total_money_destroyed += amount
-        government.tax_revenue[tax_type] = government.tax_revenue.get(tax_type, 0.0) + amount
-        government.current_tick_stats["tax_revenue"][tax_type] = government.current_tick_stats["tax_revenue"].get(tax_type, 0.0) + amount
+        government.tax_revenue[tax_type] = (
+            government.tax_revenue.get(tax_type, 0.0) + amount
+        )
+        government.current_tick_stats["tax_revenue"][tax_type] = (
+            government.current_tick_stats["tax_revenue"].get(tax_type, 0.0) + amount
+        )
         government.current_tick_stats["total_collected"] += amount
 
         logger.info(
@@ -87,7 +141,7 @@ class TaxAgency:
                 "amount": amount,
                 "tax_type": tax_type,
                 "source_id": payer_id,
-                "tags": ["tax", "revenue"]
-            }
+                "tags": ["tax", "revenue"],
+            },
         )
         return amount
diff --git a/simulation/systems/tech/api.py b/simulation/systems/tech/api.py
index a9c8087..22773e6 100644
--- a/simulation/systems/tech/api.py
+++ b/simulation/systems/tech/api.py
@@ -6,19 +6,25 @@ from typing import List, Protocol, TypedDict, Set
 
 # --- Data Transfer Objects (DTOs) ---
 
+
 class FirmTechInfoDTO(TypedDict):
     """Minimal firm data required for technology diffusion."""
+
     id: int
     sector: str
     is_visionary: bool
 
+
 class HouseholdEducationDTO(TypedDict):
     """Minimal household data required for human capital calculation."""
+
     is_active: bool
     education_level: float
 
+
 # --- System Interface ---
 
+
 class TechnologySystemAPI(Protocol):
     """
     Defines the public contract for the TechnologyManager.
@@ -29,7 +35,7 @@ class TechnologySystemAPI(Protocol):
         self,
         current_tick: int,
         firms: List[FirmTechInfoDTO],
-        human_capital_index: float
+        human_capital_index: float,
     ) -> None:
         """
         Updates the state of technology diffusion.
diff --git a/simulation/systems/technology_manager.py b/simulation/systems/technology_manager.py
index 73deeef..e03d7be 100644
--- a/simulation/systems/technology_manager.py
+++ b/simulation/systems/technology_manager.py
@@ -8,6 +8,7 @@ from simulation.systems.tech.api import FirmTechInfoDTO
 
 logger = logging.getLogger(__name__)
 
+
 @dataclass
 class TechNode:
     id: str
@@ -18,6 +19,7 @@ class TechNode:
     diffusion_rate: float  # Probability of adoption per tick for non-visionaries
     is_unlocked: bool = False
 
+
 class TechnologyManager:
     """
     Phase 23: Technology Manager
@@ -27,15 +29,15 @@ class TechnologyManager:
     def __init__(self, config_module: Any, logger: logging.Logger):
         self.config = config_module
         self.logger = logger
-        
+
         # Tech Registry
         self.tech_tree: Dict[str, TechNode] = {}
-        self.active_techs: List[str] = [] # List of unlocked tech IDs
-        
+        self.active_techs: List[str] = []  # List of unlocked tech IDs
+
         # Adoption Registry: {FirmID: {TechID}}
         self.adoption_registry: Dict[int, Set[str]] = {}
-        
-        self.human_capital_index: float = 1.0 # WO-054
+
+        self.human_capital_index: float = 1.0  # WO-054
 
         self._initialize_tech_tree()
 
@@ -46,13 +48,20 @@ class TechnologyManager:
             id="TECH_AGRI_CHEM_01",
             name="Chemical Fertilizer (Haber-Bosch)",
             sector="FOOD",
-            multiplier=3.0, # 300% TFP
-            unlock_tick=getattr(self.config, "TECH_FERTILIZER_UNLOCK_TICK", 50), # Early unlock for test
-            diffusion_rate=getattr(self.config, "TECH_DIFFUSION_RATE", 0.05)
+            multiplier=3.0,  # 300% TFP
+            unlock_tick=getattr(
+                self.config, "TECH_FERTILIZER_UNLOCK_TICK", 50
+            ),  # Early unlock for test
+            diffusion_rate=getattr(self.config, "TECH_DIFFUSION_RATE", 0.05),
         )
         self.tech_tree[fertilizer.id] = fertilizer
 
-    def update(self, current_tick: int, firms: List[FirmTechInfoDTO], human_capital_index: float) -> None:
+    def update(
+        self,
+        current_tick: int,
+        firms: List[FirmTechInfoDTO],
+        human_capital_index: float,
+    ) -> None:
         """
         Called every tick.
         1. Check Unlocks.
@@ -69,11 +78,13 @@ class TechnologyManager:
         # 2. Diffusion Process (S-Curve)
         self._process_diffusion(firms, current_tick)
 
-    def _unlock_tech(self, tech: TechNode, firms: List[FirmTechInfoDTO], current_tick: int):
+    def _unlock_tech(
+        self, tech: TechNode, firms: List[FirmTechInfoDTO], current_tick: int
+    ):
         """Unlock technology and assign to Early Adopters (Visionaries)."""
         tech.is_unlocked = True
         self.active_techs.append(tech.id)
-        
+
         # Immediate Adoption by Visionaries
         early_adopters_count = 0
         for firm_dto in firms:
@@ -85,11 +96,11 @@ class TechnologyManager:
             if firm_dto["is_visionary"]:
                 self._adopt(firm_dto["id"], tech)
                 early_adopters_count += 1
-        
+
         self.logger.info(
             f"TECH_UNLOCK | Unlocked {tech.name} (ID: {tech.id}). "
             f"Early Adopters: {early_adopters_count} firms.",
-            extra={"tick": current_tick, "tech_id": tech.id}
+            extra={"tick": current_tick, "tech_id": tech.id},
         )
 
     def _get_effective_diffusion_rate(self, base_rate: float) -> float:
@@ -111,7 +122,7 @@ class TechnologyManager:
         """
         for tech_id in self.active_techs:
             tech = self.tech_tree[tech_id]
-            
+
             # WO-054: Calculate effective rate
             effective_rate = self._get_effective_diffusion_rate(tech.diffusion_rate)
 
@@ -124,13 +135,17 @@ class TechnologyManager:
                 # Check if already adopted
                 if self.has_adopted(firm_dto["id"], tech_id):
                     continue
-                
+
                 # Diffusion Chance
                 if random.random() < effective_rate:
                     self._adopt(firm_dto["id"], tech)
                     self.logger.info(
                         f"TECH_DIFFUSION | Firm {firm_dto['id']} adopted {tech.name}. Rate: {effective_rate:.4f} (Base: {tech.diffusion_rate})",
-                        extra={"tick": current_tick, "agent_id": firm_dto['id'], "tech_id": tech.id}
+                        extra={
+                            "tick": current_tick,
+                            "agent_id": firm_dto["id"],
+                            "tech_id": tech.id,
+                        },
                     )
 
     def _adopt(self, firm_id: int, tech: TechNode):
@@ -150,10 +165,10 @@ class TechnologyManager:
         """
         if firm_id not in self.adoption_registry:
             return 1.0
-        
+
         total_mult = 1.0
         adopted_techs = self.adoption_registry[firm_id]
-        
+
         for tech_id in adopted_techs:
             tech = self.tech_tree.get(tech_id)
             if tech:
@@ -161,5 +176,5 @@ class TechnologyManager:
                 # Spec says "Multiplies productivity_factor by 3.0".
                 # If multiple techs? Usually multiplicative for TFP.
                 total_mult *= tech.multiplier
-        
+
         return total_mult
diff --git a/simulation/systems/transaction_processor.py b/simulation/systems/transaction_processor.py
index 8c9610c..9e91dbe 100644
--- a/simulation/systems/transaction_processor.py
+++ b/simulation/systems/transaction_processor.py
@@ -13,6 +13,7 @@ if TYPE_CHECKING:
 
 logger = logging.getLogger(__name__)
 
+
 class TransactionProcessor(SystemInterface):
     """
     Simulation ì—”ì§„ì˜ ê±°ëŒ€í•œ ê±°ë˜ ì²˜ë¦¬ ë¡œì§ì„ ë‹´ë‹¹í•˜ëŠ” ì „ìš© í´ë˜ìŠ¤.
@@ -34,7 +35,9 @@ class TransactionProcessor(SystemInterface):
         current_time = state.time
 
         # market_data is now in state
-        goods_market_data = state.market_data.get("goods_market", {}) if state.market_data else {}
+        goods_market_data = (
+            state.market_data.get("goods_market", {}) if state.market_data else {}
+        )
 
         for tx in transactions:
             buyer = agents.get(tx.buyer_id)
@@ -45,41 +48,52 @@ class TransactionProcessor(SystemInterface):
 
             trade_value = tx.quantity * tx.price
             sales_tax_rate = getattr(self.config_module, "SALES_TAX_RATE", 0.05)
-            tax_amount = 0.0 # Initialize for scope
-            
+            tax_amount = 0.0  # Initialize for scope
+
             # ==================================================================
             # 1. Financial Settlement (Asset Transfer & Taxes)
             # ==================================================================
-            settlement = getattr(state, 'settlement_system', None)
+            settlement = getattr(state, "settlement_system", None)
 
             if tx.transaction_type == "goods":
                 # Goods: Apply Sales Tax
                 tax_amount = trade_value * sales_tax_rate
-                
+
                 # Solvency Check
-                if hasattr(buyer, 'check_solvency'):
+                if hasattr(buyer, "check_solvency"):
                     if buyer.assets < (trade_value + tax_amount):
                         buyer.check_solvency(government)
 
                 if settlement:
-                    settlement.transfer(buyer, seller, trade_value, f"goods_trade:{tx.item_id}")
+                    settlement.transfer(
+                        buyer, seller, trade_value, f"goods_trade:{tx.item_id}"
+                    )
                     if tax_amount > 0:
-                        settlement.transfer(buyer, government, tax_amount, f"sales_tax:{tx.item_id}")
+                        settlement.transfer(
+                            buyer, government, tax_amount, f"sales_tax:{tx.item_id}"
+                        )
                 else:
                     buyer.withdraw(trade_value + tax_amount)
                     seller.deposit(trade_value)
                     government.deposit(tax_amount)
 
-                government.collect_tax(tax_amount, f"sales_tax_{tx.transaction_type}", buyer.id, current_time)
+                government.collect_tax(
+                    tax_amount,
+                    f"sales_tax_{tx.transaction_type}",
+                    buyer.id,
+                    current_time,
+                )
 
             elif tx.transaction_type == "stock":
                 # Stock: NO Sales Tax
                 if settlement:
-                    settlement.transfer(buyer, seller, trade_value, f"stock_trade:{tx.item_id}")
+                    settlement.transfer(
+                        buyer, seller, trade_value, f"stock_trade:{tx.item_id}"
+                    )
                 else:
                     buyer.withdraw(trade_value)
                     seller.deposit(trade_value)
-            
+
             elif tx.transaction_type in ["labor", "research_labor"]:
                 # Labor: Apply Income Tax
                 tax_payer = getattr(self.config_module, "INCOME_TAX_PAYER", "HOUSEHOLD")
@@ -87,38 +101,68 @@ class TransactionProcessor(SystemInterface):
                 if "basic_food_current_sell_price" in goods_market_data:
                     avg_food_price = goods_market_data["basic_food_current_sell_price"]
                 else:
-                    avg_food_price = getattr(self.config_module, "GOODS_INITIAL_PRICE", {}).get("basic_food", 5.0)
-                
-                daily_food_need = getattr(self.config_module, "HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK", 1.0)
+                    avg_food_price = getattr(
+                        self.config_module, "GOODS_INITIAL_PRICE", {}
+                    ).get("basic_food", 5.0)
+
+                daily_food_need = getattr(
+                    self.config_module, "HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK", 1.0
+                )
                 survival_cost = max(avg_food_price * daily_food_need, 10.0)
 
                 tax_amount = government.calculate_income_tax(trade_value, survival_cost)
-                
+
                 if tax_payer == "FIRM":
                     if settlement:
-                        settlement.transfer(buyer, seller, trade_value, f"labor_wage:{tx.transaction_type}")
+                        settlement.transfer(
+                            buyer,
+                            seller,
+                            trade_value,
+                            f"labor_wage:{tx.transaction_type}",
+                        )
                         if tax_amount > 0:
-                            settlement.transfer(buyer, government, tax_amount, f"labor_tax_firm:{tx.transaction_type}")
+                            settlement.transfer(
+                                buyer,
+                                government,
+                                tax_amount,
+                                f"labor_tax_firm:{tx.transaction_type}",
+                            )
                     else:
                         buyer.withdraw(trade_value + tax_amount)
                         seller.deposit(trade_value)
                         government.deposit(tax_amount)
 
-                    government.collect_tax(tax_amount, "income_tax_firm", buyer.id, current_time)
+                    government.collect_tax(
+                        tax_amount, "income_tax_firm", buyer.id, current_time
+                    )
                 else:
                     # Household pays tax (Withholding model)
                     net_wage = trade_value - tax_amount
                     if settlement:
-                        settlement.transfer(buyer, seller, net_wage, f"labor_wage_net:{tx.transaction_type}")
+                        settlement.transfer(
+                            buyer,
+                            seller,
+                            net_wage,
+                            f"labor_wage_net:{tx.transaction_type}",
+                        )
                         if tax_amount > 0:
-                            settlement.transfer(buyer, government, tax_amount, f"labor_tax_withheld:{tx.transaction_type}")
+                            settlement.transfer(
+                                buyer,
+                                government,
+                                tax_amount,
+                                f"labor_tax_withheld:{tx.transaction_type}",
+                            )
                     else:
-                        buyer.withdraw(trade_value) # Buyer pays full (net + tax split dest)
+                        buyer.withdraw(
+                            trade_value
+                        )  # Buyer pays full (net + tax split dest)
                         seller.deposit(net_wage)
                         government.deposit(tax_amount)
 
-                    government.collect_tax(tax_amount, "income_tax_household", seller.id, current_time)
-            
+                    government.collect_tax(
+                        tax_amount, "income_tax_household", seller.id, current_time
+                    )
+
             elif tx.item_id == "interest_payment":
                 if settlement:
                     settlement.transfer(buyer, seller, trade_value, "interest_payment")
@@ -130,18 +174,23 @@ class TransactionProcessor(SystemInterface):
                     buyer.finance.record_expense(trade_value)
 
             elif tx.transaction_type == "dividend":
+                # WO-116: Fixed reversal. Buyer (Firm) pays Seller (Household).
                 if settlement:
-                    settlement.transfer(seller, buyer, trade_value, "dividend_payment")
+                    settlement.transfer(buyer, seller, trade_value, "dividend_payment")
                 else:
-                    seller.withdraw(trade_value)
-                    buyer.deposit(trade_value)
+                    buyer.withdraw(trade_value)
+                    seller.deposit(trade_value)
 
-                if isinstance(buyer, Household) and hasattr(buyer, "capital_income_this_tick"):
-                    buyer.capital_income_this_tick += trade_value
+                if isinstance(seller, Household) and hasattr(
+                    seller, "capital_income_this_tick"
+                ):
+                    seller.capital_income_this_tick += trade_value
             else:
                 # Default / Other
                 if settlement:
-                    settlement.transfer(buyer, seller, trade_value, f"generic:{tx.transaction_type}")
+                    settlement.transfer(
+                        buyer, seller, trade_value, f"generic:{tx.transaction_type}"
+                    )
                 else:
                     buyer.withdraw(trade_value)
                     seller.deposit(trade_value)
@@ -150,20 +199,40 @@ class TransactionProcessor(SystemInterface):
             # 2. Meta Logic (Inventory, Employment, Share Registry)
             # ==================================================================
             if tx.transaction_type in ["labor", "research_labor"]:
-                self._handle_labor_transaction(tx, buyer, seller, trade_value, tax_amount, agents)
+                self._handle_labor_transaction(
+                    tx, buyer, seller, trade_value, tax_amount, agents
+                )
 
             elif tx.transaction_type == "goods":
-                self._handle_goods_transaction(tx, buyer, seller, trade_value, current_time)
+                self._handle_goods_transaction(
+                    tx, buyer, seller, trade_value, current_time
+                )
 
             elif tx.transaction_type == "stock":
-                self._handle_stock_transaction(tx, buyer, seller, state.stock_market, state.logger, current_time)
+                self._handle_stock_transaction(
+                    tx, buyer, seller, state.stock_market, state.logger, current_time
+                )
 
-            elif tx.transaction_type == "housing" or (hasattr(tx, "market_id") and tx.market_id == "housing"):
+            elif tx.transaction_type == "housing" or (
+                hasattr(tx, "market_id") and tx.market_id == "housing"
+            ):
                 pass
 
-    def _handle_labor_transaction(self, tx: Transaction, buyer: Any, seller: Any, trade_value: float, tax_amount: float, agents: Dict[int, Any]):
+    def _handle_labor_transaction(
+        self,
+        tx: Transaction,
+        buyer: Any,
+        seller: Any,
+        trade_value: float,
+        tax_amount: float,
+        agents: Dict[int, Any],
+    ):
         if isinstance(seller, Household):
-            if seller.is_employed and seller.employer_id is not None and seller.employer_id != buyer.id:
+            if (
+                seller.is_employed
+                and seller.employer_id is not None
+                and seller.employer_id != buyer.id
+            ):
                 previous_employer = agents.get(seller.employer_id)
                 if isinstance(previous_employer, Firm):
                     # SoC Refactor: Use HRDepartment
@@ -174,22 +243,31 @@ class TransactionProcessor(SystemInterface):
             seller.current_wage = tx.price
             seller.needs["labor_need"] = 0.0
             if hasattr(seller, "labor_income_this_tick"):
-                seller.labor_income_this_tick += (trade_value - tax_amount)
+                seller.labor_income_this_tick += trade_value - tax_amount
 
         if isinstance(buyer, Firm):
             # SoC Refactor: Use HRDepartment and FinanceDepartment
             if seller not in buyer.hr.employees:
                 buyer.hr.hire(seller, tx.price)
             else:
-                 buyer.hr.employee_wages[seller.id] = tx.price
+                buyer.hr.employee_wages[seller.id] = tx.price
 
             buyer.finance.record_expense(trade_value)
 
             if tx.transaction_type == "research_labor":
                 research_skill = seller.skills.get("research", Skill("research")).value
-                buyer.productivity_factor += (research_skill * self.config_module.RND_PRODUCTIVITY_MULTIPLIER)
-
-    def _handle_goods_transaction(self, tx: Transaction, buyer: Any, seller: Any, trade_value: float, current_time: int):
+                buyer.productivity_factor += (
+                    research_skill * self.config_module.RND_PRODUCTIVITY_MULTIPLIER
+                )
+
+    def _handle_goods_transaction(
+        self,
+        tx: Transaction,
+        buyer: Any,
+        seller: Any,
+        trade_value: float,
+        current_time: int,
+    ):
         good_info = self.config_module.GOODS.get(tx.item_id, {})
         is_service = good_info.get("is_service", False)
 
@@ -197,18 +275,26 @@ class TransactionProcessor(SystemInterface):
             if isinstance(buyer, Household):
                 buyer.consume(tx.item_id, tx.quantity, current_time)
         else:
-            seller.inventory[tx.item_id] = max(0, seller.inventory.get(tx.item_id, 0) - tx.quantity)
-            is_raw_material = tx.item_id in getattr(self.config_module, "RAW_MATERIAL_SECTORS", [])
+            seller.inventory[tx.item_id] = max(
+                0, seller.inventory.get(tx.item_id, 0) - tx.quantity
+            )
+            is_raw_material = tx.item_id in getattr(
+                self.config_module, "RAW_MATERIAL_SECTORS", []
+            )
 
             if is_raw_material and isinstance(buyer, Firm):
-                buyer.input_inventory[tx.item_id] = buyer.input_inventory.get(tx.item_id, 0.0) + tx.quantity
+                buyer.input_inventory[tx.item_id] = (
+                    buyer.input_inventory.get(tx.item_id, 0.0) + tx.quantity
+                )
             else:
                 current_qty = buyer.inventory.get(tx.item_id, 0)
                 existing_quality = buyer.inventory_quality.get(tx.item_id, 1.0)
-                tx_quality = tx.quality if hasattr(tx, 'quality') else 1.0
+                tx_quality = tx.quality if hasattr(tx, "quality") else 1.0
                 total_new_qty = current_qty + tx.quantity
-                new_avg_quality = ((current_qty * existing_quality) + (tx.quantity * tx_quality)) / total_new_qty
-                
+                new_avg_quality = (
+                    (current_qty * existing_quality) + (tx.quantity * tx_quality)
+                ) / total_new_qty
+
                 buyer.inventory_quality[tx.item_id] = new_avg_quality
                 buyer.inventory[tx.item_id] = total_new_qty
 
@@ -216,16 +302,24 @@ class TransactionProcessor(SystemInterface):
             # SoC Refactor: Use FinanceDepartment
             seller.finance.record_revenue(trade_value)
             seller.finance.sales_volume_this_tick += tx.quantity
-        
+
         if isinstance(buyer, Household):
             if not is_service:
                 buyer.current_consumption += tx.quantity
                 if tx.item_id == "basic_food":
                     buyer.current_food_consumption += tx.quantity
 
-    def _handle_stock_transaction(self, tx: Transaction, buyer: Any, seller: Any, stock_market: Any, logger: Any, current_time: int):
+    def _handle_stock_transaction(
+        self,
+        tx: Transaction,
+        buyer: Any,
+        seller: Any,
+        stock_market: Any,
+        logger: Any,
+        current_time: int,
+    ):
         firm_id = int(tx.item_id.split("_")[1])
-        
+
         # 1. Update Holdings
         if isinstance(seller, Household):
             current_shares = seller.shares_owned.get(firm_id, 0)
@@ -239,9 +333,11 @@ class TransactionProcessor(SystemInterface):
         elif hasattr(seller, "portfolio"):
             # Secondary market trade for Firms/Institutions if they have portfolio
             seller.portfolio.remove(firm_id, tx.quantity)
-        
+
         if isinstance(buyer, Household):
-            buyer.shares_owned[firm_id] = buyer.shares_owned.get(firm_id, 0) + tx.quantity
+            buyer.shares_owned[firm_id] = (
+                buyer.shares_owned.get(firm_id, 0) + tx.quantity
+            )
             if hasattr(buyer, "portfolio"):
                 buyer.portfolio.add(firm_id, tx.quantity, tx.price)
                 # Sync legacy dict
@@ -254,16 +350,20 @@ class TransactionProcessor(SystemInterface):
         if stock_market:
             # Sync Buyer
             if hasattr(buyer, "portfolio") and firm_id in buyer.portfolio.holdings:
-                 stock_market.update_shareholder(buyer.id, firm_id, buyer.portfolio.holdings[firm_id].quantity)
+                stock_market.update_shareholder(
+                    buyer.id, firm_id, buyer.portfolio.holdings[firm_id].quantity
+                )
 
             # Sync Seller
             if hasattr(seller, "portfolio") and firm_id in seller.portfolio.holdings:
-                stock_market.update_shareholder(seller.id, firm_id, seller.portfolio.holdings[firm_id].quantity)
+                stock_market.update_shareholder(
+                    seller.id, firm_id, seller.portfolio.holdings[firm_id].quantity
+                )
             else:
                 stock_market.update_shareholder(seller.id, firm_id, 0.0)
 
         if logger:
             logger.info(
                 f"STOCK_TX | Buyer: {buyer.id}, Seller: {seller.id}, Firm: {firm_id}, Qty: {tx.quantity}, Price: {tx.price}",
-                extra={"tick": current_time, "tags": ["stock_market", "transaction"]}
+                extra={"tick": current_time, "tags": ["stock_market", "transaction"]},
             )
diff --git a/simulation/tick_scheduler.py b/simulation/tick_scheduler.py
index f7f01b0..27f603b 100644
--- a/simulation/tick_scheduler.py
+++ b/simulation/tick_scheduler.py
@@ -8,17 +8,13 @@ from simulation.systems.tech.api import FirmTechInfoDTO, HouseholdEducationDTO
 from simulation.firms import Firm
 from simulation.markets.order_book_market import OrderBookMarket
 from simulation.agents.government import Government
-from simulation.dtos import (
-    AIDecisionData,
-    GovernmentStateDTO,
-    MacroFinancialContext
-)
+from simulation.dtos import AIDecisionData, GovernmentStateDTO, MacroFinancialContext
 from simulation.systems.api import (
     EventContext,
     SocialMobilityContext,
     SensoryContext,
     CommerceContext,
-    LearningUpdateContext
+    LearningUpdateContext,
 )
 from simulation.dtos.api import SimulationState
 
@@ -41,7 +37,9 @@ class TickScheduler:
         self.world_state = world_state
         self.action_processor = action_processor
 
-    def run_tick(self, injectable_sensory_dto: Optional[GovernmentStateDTO] = None) -> None:
+    def run_tick(
+        self, injectable_sensory_dto: Optional[GovernmentStateDTO] = None
+    ) -> None:
         state = self.world_state
 
         # --- Gold Standard / Money Supply Verification (WO-016) ---
@@ -49,7 +47,7 @@ class TickScheduler:
             state.baseline_money_supply = state.calculate_total_money()
             state.logger.info(
                 f"MONEY_SUPPLY_BASELINE | Baseline Money Supply set to: {state.baseline_money_supply:.2f}",
-                extra={"tick": state.time, "money_supply": state.baseline_money_supply}
+                extra={"tick": state.time, "money_supply": state.baseline_money_supply},
             )
 
         state.time += 1
@@ -60,18 +58,22 @@ class TickScheduler:
 
         # ===== Chaos Injection Events (via EventSystem) =====
         if state.event_system:
-             context: EventContext = {
-                 "households": state.households,
-                 "firms": state.firms,
-                 "markets": state.markets,
-                 "government": state.government,
-                 "central_bank": state.central_bank,
-                 "bank": state.bank
-             }
-             state.event_system.execute_scheduled_events(state.time, context, state.stress_scenario_config)
+            context: EventContext = {
+                "households": state.households,
+                "firms": state.firms,
+                "markets": state.markets,
+                "government": state.government,
+                "central_bank": state.central_bank,
+                "bank": state.bank,
+            }
+            state.event_system.execute_scheduled_events(
+                state.time, context, state.stress_scenario_config
+            )
 
         # WO-054: Government Public Education Logic (START OF TICK)
-        state.government.run_public_education(state.households, state.config_module, state.time, state.reflux_system)
+        state.government.run_public_education(
+            state.households, state.config_module, state.time, state.reflux_system
+        )
 
         if (
             state.time > 0
@@ -86,46 +88,52 @@ class TickScheduler:
 
         # 0. Firm Production (State Update: Inventory)
         for firm in state.firms:
-             if firm.is_active:
-                 firm.produce(state.time, technology_manager=state.technology_manager)
+            if firm.is_active:
+                firm.produce(state.time, technology_manager=state.technology_manager)
 
         # 1. Bank Tick (Interest)
         if hasattr(state.bank, "run_tick"):
-             bank_txs = state.bank.run_tick(state.agents, state.time, reflux_system=state.reflux_system)
-             system_transactions.extend(bank_txs)
+            bank_txs = state.bank.run_tick(
+                state.agents, state.time, reflux_system=state.reflux_system
+            )
+            system_transactions.extend(bank_txs)
 
         # 2. Firm Financials (Wages, Taxes, Dividends) - Requires Market Data (T-1)
         market_data_prev = self.prepare_market_data(state.tracker)
         for firm in state.firms:
-             if firm.is_active:
-                 firm_txs = firm.generate_transactions(
-                     government=state.government,
-                     market_data=market_data_prev,
-                     all_households=state.households,
-                     current_time=state.time
-                 )
-                 system_transactions.extend(firm_txs)
+            if firm.is_active:
+                firm_txs = firm.generate_transactions(
+                    government=state.government,
+                    market_data=market_data_prev,
+                    all_households=state.households,
+                    current_time=state.time,
+                )
+                system_transactions.extend(firm_txs)
 
         # 3. Debt Service
         debt_txs = state.finance_system.service_debt(state.time)
         system_transactions.extend(debt_txs)
 
         # 4. Welfare & Taxes (Wealth)
-        welfare_txs = state.government.run_welfare_check(list(state.agents.values()), market_data_prev, state.time)
+        welfare_txs = state.government.run_welfare_check(
+            list(state.agents.values()), market_data_prev, state.time
+        )
         system_transactions.extend(welfare_txs)
 
         # 5. Infrastructure
-        infra_success, infra_txs = state.government.invest_infrastructure(state.time, state.reflux_system)
+        infra_success, infra_txs = state.government.invest_infrastructure(
+            state.time, state.reflux_system
+        )
         if infra_txs:
             system_transactions.extend(infra_txs)
 
         if infra_success:
             tfp_boost = getattr(state.config_module, "INFRASTRUCTURE_TFP_BOOST", 0.05)
             for firm in state.firms:
-                firm.productivity_factor *= (1.0 + tfp_boost)
+                firm.productivity_factor *= 1.0 + tfp_boost
             state.logger.info(
-                f"GLOBAL_TFP_BOOST | All firms productivity increased by {tfp_boost*100:.1f}%",
-                extra={"tick": state.time, "tags": ["government", "infrastructure"]}
+                f"GLOBAL_TFP_BOOST | All firms productivity increased by {tfp_boost * 100:.1f}%",
+                extra={"tick": state.time, "tags": ["government", "infrastructure"]},
             )
 
         # ----------------------------------------------------------------------------------
@@ -140,7 +148,13 @@ class TickScheduler:
 
         # WO-057-Fix: Update tracker with the latest data before government decisions
         money_supply = state.calculate_total_money()
-        state.tracker.track(state.time, state.households, state.firms, state.markets, money_supply=money_supply)
+        state.tracker.track(
+            state.time,
+            state.households,
+            state.firms,
+            state.markets,
+            money_supply=money_supply,
+        )
 
         # [WO-060] Update stock market reference prices at the start of the tick
         if state.stock_market is not None:
@@ -150,10 +164,11 @@ class TickScheduler:
         # Phase 17-4: Update Social Ranks & Calculate Reference Standard (via SocialSystem)
         market_data = self.prepare_market_data(state.tracker)
 
-        if getattr(state.config_module, "ENABLE_VANITY_SYSTEM", False) and state.social_system:
-            context: SocialMobilityContext = {
-                "households": state.households
-            }
+        if (
+            getattr(state.config_module, "ENABLE_VANITY_SYSTEM", False)
+            and state.social_system
+        ):
+            context: SocialMobilityContext = {"households": state.households}
             state.social_system.update_social_ranks(context)
             ref_std = state.social_system.calculate_reference_standard(context)
             market_data["reference_standard"] = ref_std
@@ -171,13 +186,17 @@ class TickScheduler:
         sensory_context: SensoryContext = {
             "tracker": state.tracker,
             "government": state.government,
-            "time": state.time
+            "time": state.time,
         }
 
         if state.sensory_system:
-            sensory_dto = state.sensory_system.generate_government_sensory_dto(sensory_context)
+            sensory_dto = state.sensory_system.generate_government_sensory_dto(
+                sensory_context
+            )
         else:
-            state.logger.error("SensorySystem not initialized! Check SimulationInitializer.")
+            state.logger.error(
+                "SensorySystem not initialized! Check SimulationInitializer."
+            )
             sensory_dto = GovernmentStateDTO(state.time, 0, 0, 0, 0, 0, 0)
 
         # Supply to Government
@@ -185,7 +204,7 @@ class TickScheduler:
             state.government.update_sensory_data(injectable_sensory_dto)
             state.logger.warning(
                 f"INJECTED_SENSORY_DATA | Overrode sensory data for tick {state.time} with custom DTO.",
-                extra={"tick": state.time, "tags": ["test_injection"]}
+                extra={"tick": state.time, "tags": ["test_injection"]},
             )
         else:
             state.government.update_sensory_data(sensory_dto)
@@ -196,13 +215,17 @@ class TickScheduler:
             interest_rate_trend = state.bank.base_rate - state.last_interest_rate
             state.last_interest_rate = state.bank.base_rate
 
-            market_volatility = state.stock_tracker.get_market_volatility() if state.stock_tracker else 0.0
+            market_volatility = (
+                state.stock_tracker.get_market_volatility()
+                if state.stock_tracker
+                else 0.0
+            )
 
             macro_financial_context = MacroFinancialContext(
                 inflation_rate=sensory_dto.inflation_sma,
                 gdp_growth_rate=sensory_dto.gdp_growth_sma,
                 market_volatility=market_volatility,
-                interest_rate_trend=interest_rate_trend
+                interest_rate_trend=interest_rate_trend,
             )
 
         # [DEBUG WO-057]
@@ -212,7 +235,9 @@ class TickScheduler:
         latest_gdp = state.tracker.get_latest_indicators().get("total_production", 0.0)
         market_data["total_production"] = latest_gdp
 
-        state.government.make_policy_decision(market_data, state.time, state.central_bank)
+        state.government.make_policy_decision(
+            market_data, state.time, state.central_bank
+        )
 
         # Monetary policy is updated AFTER the government's fiscal/AI decision
         state.central_bank.step(state.time)
@@ -236,9 +261,11 @@ class TickScheduler:
 
         # Snapshot agents for learning (Pre-state)
         for f in state.firms:
-            if f.is_active: f.pre_state_snapshot = f.get_agent_data()
+            if f.is_active:
+                f.pre_state_snapshot = f.get_agent_data()
         for h in state.households:
-            if h.is_active: h.pre_state_snapshot = h.get_agent_data()
+            if h.is_active:
+                h.pre_state_snapshot = h.get_agent_data()
 
         # ==================================================================================
         # THE SACRED SEQUENCE (WO-103)
@@ -264,14 +291,14 @@ class TickScheduler:
             ai_training_manager=getattr(state, "ai_training_manager", None),
             ai_trainer=getattr(state, "ai_trainer", None),
             next_agent_id=state.next_agent_id,
-            real_estate_units=state.real_estate_units
+            real_estate_units=state.real_estate_units,
         )
 
         # 1. Decisions
-        firm_pre_states, household_pre_states, household_time_allocation = self._phase_decisions(
-            sim_state, market_data, macro_financial_context
+        firm_pre_states, household_pre_states, household_time_allocation = (
+            self._phase_decisions(sim_state, market_data, macro_financial_context)
         )
-        state.household_time_allocation = household_time_allocation # Update state
+        state.household_time_allocation = household_time_allocation  # Update state
 
         # 2. Matching
         self._phase_matching(sim_state)
@@ -295,9 +322,9 @@ class TickScheduler:
         current_vacancies = 0
         labor_market = state.markets.get("labor")
         if labor_market and isinstance(labor_market, OrderBookMarket):
-             for item_orders in labor_market.buy_orders.values():
-                 for order in item_orders:
-                     current_vacancies += order.quantity
+            for item_orders in labor_market.buy_orders.values():
+                for order in item_orders:
+                    current_vacancies += order.quantity
 
         consumption_market_data = market_data.copy()
         consumption_market_data["job_vacancies"] = current_vacancies
@@ -310,52 +337,69 @@ class TickScheduler:
             "reflux_system": state.reflux_system,
             "market_data": consumption_market_data,
             "config": state.config_module,
-            "time": state.time
+            "time": state.time,
         }
 
         if state.commerce_system:
-            household_leisure_effects = state.commerce_system.execute_consumption_and_leisure(commerce_context, state.stress_scenario_config)
+            household_leisure_effects = (
+                state.commerce_system.execute_consumption_and_leisure(
+                    commerce_context, state.stress_scenario_config
+                )
+            )
         else:
-            state.logger.error("CommerceSystem not initialized! Skipping consumption cycle.")
+            state.logger.error(
+                "CommerceSystem not initialized! Skipping consumption cycle."
+            )
             household_leisure_effects = {}
 
         # --- Phase 23: Technology Manager Update ---
         # WO-053: Orchestrate Technology Update with DTOs
         # 1. Calculate Human Capital Index
         active_households_dto = [
-            HouseholdEducationDTO(is_active=h.is_active, education_level=getattr(h, 'education_level', 0))
+            HouseholdEducationDTO(
+                is_active=h.is_active, education_level=getattr(h, "education_level", 0)
+            )
             for h in state.households
         ]
-        total_edu = sum(h['education_level'] for h in active_households_dto if h['is_active'])
-        active_count = sum(1 for h in active_households_dto if h['is_active'])
+        total_edu = sum(
+            h["education_level"] for h in active_households_dto if h["is_active"]
+        )
+        active_count = sum(1 for h in active_households_dto if h["is_active"])
         human_capital_index = total_edu / active_count if active_count > 0 else 1.0
 
         # 2. Prepare Firm DTOs
         active_firms_dto = [
-            FirmTechInfoDTO(id=f.id, sector=f.sector, is_visionary=getattr(f, 'is_visionary', False))
-            for f in state.firms if f.is_active
+            FirmTechInfoDTO(
+                id=f.id, sector=f.sector, is_visionary=getattr(f, "is_visionary", False)
+            )
+            for f in state.firms
+            if f.is_active
         ]
 
-        state.technology_manager.update(state.time, active_firms_dto, human_capital_index)
+        state.technology_manager.update(
+            state.time, active_firms_dto, human_capital_index
+        )
 
         # Phase 17-3B: Process Housing (Logic that didn't fit in matching/lifecycle)
         # Housing matching happened in _phase_matching.
         # But apply_homeless_penalty needs to run.
-        state.housing_system.process_housing(state) # Update rent/maintenance
+        state.housing_system.process_housing(state)  # Update rent/maintenance
         state.housing_system.apply_homeless_penalty(state)
 
         # ---------------------------------------------------------
         # Activate Farm Logic (Production & Needs/Wages)
         # ---------------------------------------------------------
         for firm in state.firms:
-             if firm.is_active:
-                 # firm.produce -> Moved to Pre-Decision
-                 # firm.update_needs -> Refactored to only do Lifecycle state updates (not financial)
-                 firm.update_needs(state.time, state.government, market_data, state.reflux_system)
+            if firm.is_active:
+                # firm.produce -> Moved to Pre-Decision
+                # firm.update_needs -> Refactored to only do Lifecycle state updates (not financial)
+                firm.update_needs(
+                    state.time, state.government, market_data, state.reflux_system
+                )
 
-                 # Corporate Tax -> Removed (Handled in Transaction Generation)
+                # Corporate Tax -> Removed (Handled in Transaction Generation)
 
-                 # Gov Infra -> Removed (Handled in Pre-Decision)
+                # Gov Infra -> Removed (Handled in Pre-Decision)
 
         # --- AI Learning Update (Unified) ---
         market_data_for_learning = self.prepare_market_data(state.tracker)
@@ -372,7 +416,7 @@ class TickScheduler:
                 context: LearningUpdateContext = {
                     "reward": reward,
                     "next_agent_data": agent_data,
-                    "next_market_data": market_data_for_learning
+                    "next_market_data": market_data_for_learning,
                 }
                 firm.update_learning(context)
 
@@ -391,7 +435,10 @@ class TickScheduler:
         for household in state.households:
             if household.is_active and household.id in household_pre_states:
                 # Hybrid check: Only update learning if agent has AI engine
-                if hasattr(household.decision_engine, 'ai_engine') and household.decision_engine.ai_engine:
+                if (
+                    hasattr(household.decision_engine, "ai_engine")
+                    and household.decision_engine.ai_engine
+                ):
                     post_state_data = household.get_agent_data()
                     agent_data = household.get_agent_data()
 
@@ -408,7 +455,7 @@ class TickScheduler:
                     context: LearningUpdateContext = {
                         "reward": reward,
                         "next_agent_data": agent_data,
-                        "next_market_data": market_data_for_learning
+                        "next_market_data": market_data_for_learning,
                     }
                     household.update_learning(context)
 
@@ -431,7 +478,9 @@ class TickScheduler:
         state.firms = [f for f in state.firms if f.is_active]
 
         if len(state.firms) < active_firms_count_before:
-            state.logger.info(f"CLEANUP | Removed {active_firms_count_before - len(state.firms)} inactive firms from execution list.")
+            state.logger.info(
+                f"CLEANUP | Removed {active_firms_count_before - len(state.firms)} inactive firms from execution list."
+            )
 
         # Phase 5: Finalize Government Stats
         state.government.finalize_tick(state.time)
@@ -478,20 +527,28 @@ class TickScheduler:
             delta = current_money - expected_money
 
             msg = f"MONEY_SUPPLY_CHECK | Current: {current_money:.2f}, Expected: {expected_money:.2f}, Delta: {delta:.4f}"
-            extra_data = {"tick": state.time, "current": current_money, "expected": expected_money, "delta": delta, "tags": ["money_supply"]}
+            extra_data = {
+                "tick": state.time,
+                "current": current_money,
+                "expected": expected_money,
+                "delta": delta,
+                "tags": ["money_supply"],
+            }
 
             if abs(delta) > 1.0:
-                 state.logger.warning(msg, extra=extra_data)
+                state.logger.warning(msg, extra=extra_data)
             else:
-                 state.logger.info(msg, extra=extra_data)
+                state.logger.info(msg, extra=extra_data)
 
         # WO-058: Generational Wealth Audit
         if state.time % 100 == 0:
-             state.generational_wealth_audit.run_audit(state.households, state.time)
+            state.generational_wealth_audit.run_audit(state.households, state.time)
 
         # Phase 29: Crisis Monitor
         if state.crisis_monitor:
-            state.crisis_monitor.monitor(state.time, [f for f in state.firms if f.is_active])
+            state.crisis_monitor.monitor(
+                state.time, [f for f in state.firms if f.is_active]
+            )
 
         state.logger.info(
             f"--- Ending Tick {state.time} ---",
@@ -502,9 +559,16 @@ class TickScheduler:
             market.clear_orders()
 
         if state.stock_market is not None:
-            state.stock_tracker.track_all_firms([f for f in state.firms if f.is_active], state.stock_market)
+            state.stock_tracker.track_all_firms(
+                [f for f in state.firms if f.is_active], state.stock_market
+            )
 
-    def _phase_decisions(self, state: SimulationState, market_data: Dict[str, Any], macro_context: Optional[MacroFinancialContext]) -> Tuple[Dict, Dict, Dict]:
+    def _phase_decisions(
+        self,
+        state: SimulationState,
+        market_data: Dict[str, Any],
+        macro_context: Optional[MacroFinancialContext],
+    ) -> Tuple[Dict, Dict, Dict]:
         """Phase 1: Agents make decisions and place orders."""
         firm_pre_states = {}
         household_pre_states = {}
@@ -513,16 +577,21 @@ class TickScheduler:
         # 1. Firms
         for firm in state.firms:
             if firm.is_active:
-                if hasattr(firm.decision_engine, 'ai_engine') and firm.decision_engine.ai_engine:
+                if (
+                    hasattr(firm.decision_engine, "ai_engine")
+                    and firm.decision_engine.ai_engine
+                ):
                     pre_strategic_state = (
                         firm.decision_engine.ai_engine._get_strategic_state(
                             firm.get_agent_data(), market_data
                         )
                     )
-                    pre_tactical_state = firm.decision_engine.ai_engine._get_tactical_state(
-                        firm.decision_engine.ai_engine.chosen_intention,
-                        firm.get_agent_data(),
-                        market_data,
+                    pre_tactical_state = (
+                        firm.decision_engine.ai_engine._get_tactical_state(
+                            firm.decision_engine.ai_engine.chosen_intention,
+                            firm.get_agent_data(),
+                            market_data,
+                        )
                     )
                     firm_pre_states[firm.id] = {
                         "pre_strategic_state": pre_strategic_state,
@@ -534,8 +603,13 @@ class TickScheduler:
                 stress_config = self.world_state.stress_scenario_config
 
                 firm_orders, action_vector = firm.make_decision(
-                    state.markets, state.goods_data, market_data, state.time,
-                    state.government, state.reflux_system, stress_config
+                    state.markets,
+                    state.goods_data,
+                    market_data,
+                    state.time,
+                    state.government,
+                    state.reflux_system,
+                    stress_config,
                 )
 
                 for order in firm_orders:
@@ -543,12 +617,17 @@ class TickScheduler:
                     if target_market:
                         target_market.place_order(order, state.time)
 
-                state.logger.debug(f"TRACE_ENGINE | Firm {firm.id} submitted {len(firm_orders)} orders to markets.")
+                state.logger.debug(
+                    f"TRACE_ENGINE | Firm {firm.id} submitted {len(firm_orders)} orders to markets."
+                )
 
         # 2. Households
         for household in state.households:
             if household.is_active:
-                if hasattr(household.decision_engine, 'ai_engine') and household.decision_engine.ai_engine:
+                if (
+                    hasattr(household.decision_engine, "ai_engine")
+                    and household.decision_engine.ai_engine
+                ):
                     pre_strategic_state = (
                         household.decision_engine.ai_engine._get_strategic_state(
                             household.get_agent_data(), market_data
@@ -560,10 +639,16 @@ class TickScheduler:
 
                 stress_config = self.world_state.stress_scenario_config
                 household_orders, action_vector = household.make_decision(
-                    state.markets, state.goods_data, market_data, state.time, state.government, macro_context, stress_config
+                    state.markets,
+                    state.goods_data,
+                    market_data,
+                    state.time,
+                    state.government,
+                    macro_context,
+                    stress_config,
                 )
 
-                if hasattr(action_vector, 'work_aggressiveness'):
+                if hasattr(action_vector, "work_aggressiveness"):
                     work_aggressiveness = action_vector.work_aggressiveness
                 else:
                     work_aggressiveness = 0.5
@@ -578,13 +663,20 @@ class TickScheduler:
 
                 for order in household_orders:
                     if order.order_type == "INVEST" and order.market_id == "admin":
-                        state.logger.info(f"FOUND_INVEST_ORDER | Agent {household.id} attempting startup via admin market.")
+                        state.logger.info(
+                            f"FOUND_INVEST_ORDER | Agent {household.id} attempting startup via admin market."
+                        )
                         self.world_state.firm_system.spawn_firm(state, household)
                         continue
 
                     target_market_id = order.market_id
 
-                    if order.order_type in ["DEPOSIT", "WITHDRAW", "LOAN_REQUEST", "REPAYMENT"]:
+                    if order.order_type in [
+                        "DEPOSIT",
+                        "WITHDRAW",
+                        "LOAN_REQUEST",
+                        "REPAYMENT",
+                    ]:
                         target_market_id = "loan_market"
                     elif order.item_id in ["deposit", "currency"]:
                         target_market_id = "loan_market"
@@ -599,7 +691,9 @@ class TickScheduler:
                             extra={"tick": state.time},
                         )
 
-                state.logger.debug(f"TRACE_ENGINE | Household {household.id} submitted {len(household_orders)} orders back to engine.")
+                state.logger.debug(
+                    f"TRACE_ENGINE | Household {household.id} submitted {len(household_orders)} orders back to engine."
+                )
 
         return firm_pre_states, household_pre_states, household_time_allocation
 
@@ -622,12 +716,14 @@ class TickScheduler:
 
         # 3. Housing Market
         if "housing" in state.markets:
-             housing_transactions = state.markets["housing"].match_orders(state.time)
-             all_transactions.extend(housing_transactions)
+            housing_transactions = state.markets["housing"].match_orders(state.time)
+            all_transactions.extend(housing_transactions)
 
         state.transactions = all_transactions
 
-    def _phase_transactions(self, state: SimulationState, system_transactions: List[Transaction] = []) -> None:
+    def _phase_transactions(
+        self, state: SimulationState, system_transactions: List[Transaction] = []
+    ) -> None:
         """Phase 3: Execute transactions."""
         # Merge system transactions
         if system_transactions:
@@ -654,7 +750,9 @@ class TickScheduler:
         debt_data_map = {}
         deposit_data_map = {}
         for agent_id in state.agents:
-            if isinstance(state.agents[agent_id], Household) or isinstance(state.agents[agent_id], Firm):
+            if isinstance(state.agents[agent_id], Household) or isinstance(
+                state.agents[agent_id], Firm
+            ):
                 debt_data_map[agent_id] = state.bank.get_debt_summary(agent_id)
                 deposit_data_map[agent_id] = state.bank.get_deposit_balance(agent_id)
 
@@ -668,12 +766,16 @@ class TickScheduler:
                     latest = tracker.get_latest_indicators()
                     avg_price = latest.get(f"{good_name}_avg_price", 0)
                 if avg_price <= 0:
-                    avg_price = state.config_module.GOODS[good_name].get("initial_price", 10.0)
+                    avg_price = state.config_module.GOODS[good_name].get(
+                        "initial_price", 10.0
+                    )
 
                 goods_market_data[f"{good_name}_current_sell_price"] = avg_price
 
         latest_indicators = tracker.get_latest_indicators()
-        avg_wage = latest_indicators.get("labor_avg_price", state.config_module.LABOR_MARKET_MIN_WAGE)
+        avg_wage = latest_indicators.get(
+            "labor_avg_price", state.config_module.LABOR_MARKET_MIN_WAGE
+        )
 
         labor_market = state.markets.get("labor")
         best_wage_offer = 0.0
@@ -684,13 +786,13 @@ class TickScheduler:
 
         job_vacancies = 0
         if labor_market and isinstance(labor_market, OrderBookMarket):
-             for item_orders in labor_market.buy_orders.values():
-                 for order in item_orders:
-                     job_vacancies += order.quantity
+            for item_orders in labor_market.buy_orders.values():
+                for order in item_orders:
+                    job_vacancies += order.quantity
 
         goods_market_data["labor"] = {
             "avg_wage": avg_wage,
-            "best_wage_offer": best_wage_offer
+            "best_wage_offer": best_wage_offer,
         }
         goods_market_data["job_vacancies"] = job_vacancies
 
@@ -712,15 +814,23 @@ class TickScheduler:
                 if price <= 0:
                     price = state.stock_market.get_best_ask(firm.id) or 0
                 if price <= 0:
-                    price = firm.assets / firm.total_shares if firm.total_shares > 0 else 10.0
+                    price = (
+                        firm.assets / firm.total_shares
+                        if firm.total_shares > 0
+                        else 10.0
+                    )
                 stock_market_data[firm_item_id] = {"avg_price": price}
 
-        rent_prices = [u.rent_price for u in state.real_estate_units if u.owner_id is not None]
-        avg_rent = sum(rent_prices) / len(rent_prices) if rent_prices else state.config_module.INITIAL_RENT_PRICE
+        rent_prices = [
+            u.rent_price for u in state.real_estate_units if u.owner_id is not None
+        ]
+        avg_rent = (
+            sum(rent_prices) / len(rent_prices)
+            if rent_prices
+            else state.config_module.INITIAL_RENT_PRICE
+        )
 
-        housing_market_data = {
-            "avg_rent_price": avg_rent
-        }
+        housing_market_data = {"avg_rent_price": avg_rent}
 
         return {
             "time": state.time,
@@ -732,5 +842,7 @@ class TickScheduler:
             "avg_goods_price": avg_goods_price_for_market_data,
             "debt_data": debt_data_map,
             "deposit_data": deposit_data_map,
-            "inflation": latest_indicators.get("inflation_rate", state.config_module.DEFAULT_INFLATION_RATE)
+            "inflation": latest_indicators.get(
+                "inflation_rate", state.config_module.DEFAULT_INFLATION_RATE
+            ),
         }
diff --git a/simulation/utils/golden_loader.py b/simulation/utils/golden_loader.py
index c61a7a8..c76d2b9 100644
--- a/simulation/utils/golden_loader.py
+++ b/simulation/utils/golden_loader.py
@@ -3,6 +3,7 @@ from typing import Dict, Type, Any, Union, List
 import json
 import os
 
+
 class GoldenLoader:
     """
     Utility to load JSON fixtures and convert them to MagicMock objects.
@@ -25,7 +26,7 @@ class GoldenLoader:
         if not os.path.exists(path):
             raise FileNotFoundError(f"Golden fixture not found at: {path}")
 
-        with open(path, 'r', encoding='utf-8') as f:
+        with open(path, "r", encoding="utf-8") as f:
             return json.load(f)
 
     @staticmethod
diff --git a/simulation/utils/shadow_logger.py b/simulation/utils/shadow_logger.py
index b18650d..e63f532 100644
--- a/simulation/utils/shadow_logger.py
+++ b/simulation/utils/shadow_logger.py
@@ -5,6 +5,7 @@ from typing import Any, Optional
 
 logger = logging.getLogger(__name__)
 
+
 class ShadowLogger:
     """
     WO-056: Stage 1 Shadow Mode Logger.
@@ -13,7 +14,15 @@ class ShadowLogger:
 
     _instance = None
     LOG_FILE = "logs/shadow_hand_stage1.csv"
-    HEADERS = ["tick", "agent_id", "agent_type", "metric", "current_value", "shadow_value", "details"]
+    HEADERS = [
+        "tick",
+        "agent_id",
+        "agent_type",
+        "metric",
+        "current_value",
+        "shadow_value",
+        "details",
+    ]
 
     def __new__(cls):
         if cls._instance is None:
@@ -29,7 +38,7 @@ class ShadowLogger:
             os.makedirs(os.path.dirname(self.LOG_FILE), exist_ok=True)
 
             # Initialize file with headers
-            with open(self.LOG_FILE, mode='w', newline='', encoding='utf-8') as f:
+            with open(self.LOG_FILE, mode="w", newline="", encoding="utf-8") as f:
                 writer = csv.writer(f)
                 writer.writerow(self.HEADERS)
 
@@ -37,28 +46,48 @@ class ShadowLogger:
         except Exception as e:
             logger.error(f"Failed to initialize ShadowLogger: {e}")
 
-    def log(self, tick: int, agent_id: int, agent_type: str, metric: str,
-            current_value: float, shadow_value: float, details: Optional[str] = ""):
+    def log(
+        self,
+        tick: int,
+        agent_id: int,
+        agent_type: str,
+        metric: str,
+        current_value: float,
+        shadow_value: float,
+        details: Optional[str] = "",
+    ):
         """
         Logs a single shadow metric record.
         """
         try:
-            with open(self.LOG_FILE, mode='a', newline='', encoding='utf-8') as f:
+            with open(self.LOG_FILE, mode="a", newline="", encoding="utf-8") as f:
                 writer = csv.writer(f)
-                writer.writerow([
-                    tick,
-                    agent_id,
-                    agent_type,
-                    metric,
-                    f"{current_value:.4f}",
-                    f"{shadow_value:.4f}",
-                    details
-                ])
+                writer.writerow(
+                    [
+                        tick,
+                        agent_id,
+                        agent_type,
+                        metric,
+                        f"{current_value:.4f}",
+                        f"{shadow_value:.4f}",
+                        details,
+                    ]
+                )
         except Exception as e:
             # Suppress errors to prevent crashing the simulation, but log error
             logger.error(f"ShadowLogger write failed: {e}")
 
+
 # Global instance helper
-def log_shadow(tick: int, agent_id: int, agent_type: str, metric: str,
-               current_value: float, shadow_value: float, details: str = ""):
-    ShadowLogger().log(tick, agent_id, agent_type, metric, current_value, shadow_value, details)
+def log_shadow(
+    tick: int,
+    agent_id: int,
+    agent_type: str,
+    metric: str,
+    current_value: float,
+    shadow_value: float,
+    details: str = "",
+):
+    ShadowLogger().log(
+        tick, agent_id, agent_type, metric, current_value, shadow_value, details
+    )
diff --git a/simulation/viewmodels/economic_indicators_viewmodel.py b/simulation/viewmodels/economic_indicators_viewmodel.py
index 3e2b1be..3ae38e1 100644
--- a/simulation/viewmodels/economic_indicators_viewmodel.py
+++ b/simulation/viewmodels/economic_indicators_viewmodel.py
@@ -16,15 +16,22 @@ class EconomicIndicatorsViewModel:
         self.repository = repository if repository else SimulationRepository()
 
     def get_economic_indicators(
-        self, start_tick: Optional[int] = None, end_tick: Optional[int] = None, run_id: Optional[int] = None
+        self,
+        start_tick: Optional[int] = None,
+        end_tick: Optional[int] = None,
+        run_id: Optional[int] = None,
     ) -> List[Dict[str, Any]]:
         """
         Retrieves and returns economic indicator data.
         """
-        indicators = self.repository.get_economic_indicators(start_tick, end_tick, run_id=run_id)
+        indicators = self.repository.get_economic_indicators(
+            start_tick, end_tick, run_id=run_id
+        )
         return indicators
 
-    def get_wealth_distribution(self, households: List[Any], firms: List[Any]) -> Dict[str, Any]:
+    def get_wealth_distribution(
+        self, households: List[Any], firms: List[Any]
+    ) -> Dict[str, Any]:
         """
         Calculates the wealth distribution (histogram buckets).
         """
@@ -38,7 +45,7 @@ class EconomicIndicatorsViewModel:
         # Determine appropriate bucket size
         num_buckets = 10
         if max_asset == min_asset:
-             return {"labels": [f"{min_asset:.0f}"], "data": [len(all_assets)]}
+            return {"labels": [f"{min_asset:.0f}"], "data": [len(all_assets)]}
 
         bucket_size = (max_asset - min_asset) / num_buckets
 
@@ -56,12 +63,11 @@ class EconomicIndicatorsViewModel:
                 index = num_buckets - 1
             buckets[index] += 1
 
-        return {
-            "labels": labels,
-            "data": buckets
-        }
+        return {"labels": labels, "data": buckets}
 
-    def get_needs_distribution(self, households: List[Any], firms: List[Any]) -> Dict[str, Any]:
+    def get_needs_distribution(
+        self, households: List[Any], firms: List[Any]
+    ) -> Dict[str, Any]:
         """
         Calculates average needs for households and firms.
         """
@@ -87,13 +93,10 @@ class EconomicIndicatorsViewModel:
         firm_count = len(firms)
         if firm_count > 0:
             # Firm needs are stored in 'needs' dict just like households in BaseAgent
-            total_liquidity_need = sum(f.needs.get('liquidity_need', 0) for f in firms)
-            firm_needs['liquidity_need'] = total_liquidity_need / firm_count
+            total_liquidity_need = sum(f.needs.get("liquidity_need", 0) for f in firms)
+            firm_needs["liquidity_need"] = total_liquidity_need / firm_count
 
-        return {
-            "household": household_needs,
-            "firm": firm_needs
-        }
+        return {"household": household_needs, "firm": firm_needs}
 
     def get_sales_by_good(self, transactions: List[Dict[str, Any]]) -> Dict[str, float]:
         """
@@ -101,8 +104,8 @@ class EconomicIndicatorsViewModel:
         """
         sales: Dict[str, float] = {}
         for tx in transactions:
-            item = tx.get('item_id', 'unknown')
-            qty = tx.get('quantity', 0)
+            item = tx.get("item_id", "unknown")
+            qty = tx.get("quantity", 0)
             sales[item] = sales.get(item, 0) + qty
         return sales
 
@@ -119,26 +122,30 @@ class EconomicIndicatorsViewModel:
                 # Bids
                 for item_id, orders in market.buy_orders.items():
                     for order in orders:
-                        order_book.append({
-                            "type": "BID",
-                            "market_id": market_id,
-                            "item_id": item_id,
-                            "agent_id": order.agent_id,
-                            "price": order.price,
-                            "quantity": order.quantity
-                        })
+                        order_book.append(
+                            {
+                                "type": "BID",
+                                "market_id": market_id,
+                                "item_id": item_id,
+                                "agent_id": order.agent_id,
+                                "price": order.price,
+                                "quantity": order.quantity,
+                            }
+                        )
 
                 # Asks
                 for item_id, orders in market.sell_orders.items():
                     for order in orders:
-                        order_book.append({
-                            "type": "ASK",
-                            "market_id": market_id,
-                            "item_id": item_id,
-                            "agent_id": order.agent_id,
-                            "price": order.price,
-                            "quantity": order.quantity
-                        })
+                        order_book.append(
+                            {
+                                "type": "ASK",
+                                "market_id": market_id,
+                                "item_id": item_id,
+                                "agent_id": order.agent_id,
+                                "price": order.price,
+                                "quantity": order.quantity,
+                            }
+                        )
 
         # Sort by price descending for display? Or just return list.
         # Let's return list, frontend can sort.
diff --git a/simulation/viewmodels/snapshot_viewmodel.py b/simulation/viewmodels/snapshot_viewmodel.py
index 902f042..891e3c3 100644
--- a/simulation/viewmodels/snapshot_viewmodel.py
+++ b/simulation/viewmodels/snapshot_viewmodel.py
@@ -10,13 +10,14 @@ from simulation.dtos import (
     GovernmentTabDataDTO,
     MarketTabDataDTO,
     FinanceTabDataDTO,
-    GenerationStatDTO
+    GenerationStatDTO,
 )
 from simulation.core_agents import Household
 from simulation.metrics.inequality_tracker import InequalityTracker
 
 logger = logging.getLogger(__name__)
 
+
 class SnapshotViewModel:
     """
     Dashboard Snapshotì„ ìƒì„±í•˜ëŠ” ViewModelì…ë‹ˆë‹¤.
@@ -27,7 +28,9 @@ class SnapshotViewModel:
         self._cached_snapshot: Optional[DashboardSnapshotDTO] = None
         self._last_cached_tick: int = -1
 
-    def get_dashboard_snapshot(self, simulation: Simulation, current_tick: int) -> DashboardSnapshotDTO:
+    def get_dashboard_snapshot(
+        self, simulation: Simulation, current_tick: int
+    ) -> DashboardSnapshotDTO:
         """
         í˜„ì¬ ì‹œë®¬ë ˆì´ì…˜ ìƒíƒœì— ëŒ€í•œ DashboardSnapshotDTOë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
         ì„±ëŠ¥ ìµœì í™”:
@@ -62,20 +65,20 @@ class SnapshotViewModel:
             "society": society_data,
             "government": government_data,
             "market": market_data,
-            "finance": finance_data
+            "finance": finance_data,
         }
 
         # Create full snapshot for cache
         self._cached_snapshot = DashboardSnapshotDTO(
-            tick=current_tick,
-            global_indicators=global_indicators,
-            tabs=tabs
+            tick=current_tick, global_indicators=global_indicators, tabs=tabs
         )
         self._last_cached_tick = current_tick
 
         return self._cached_snapshot
 
-    def _get_global_indicators(self, simulation: Simulation, current_tick: int) -> DashboardGlobalIndicatorsDTO:
+    def _get_global_indicators(
+        self, simulation: Simulation, current_tick: int
+    ) -> DashboardGlobalIndicatorsDTO:
         latest_indicators = simulation.tracker.get_latest_indicators()
 
         # Basic Metrics
@@ -84,12 +87,16 @@ class SnapshotViewModel:
         employment_rate = 100 - latest_indicators.get("unemployment_rate", 0.0)
 
         # Inequality (Gini)
-        wealth_dist = simulation.inequality_tracker.calculate_wealth_distribution(simulation.households, simulation.stock_market)
+        wealth_dist = simulation.inequality_tracker.calculate_wealth_distribution(
+            simulation.households, simulation.stock_market
+        )
         gini = wealth_dist.get("gini_total_assets", 0.0)
 
         # Attrition Rates
         start_tick = max(0, current_tick - 5)
-        attrition_counts = self.repository.get_attrition_counts(start_tick, current_tick, run_id=simulation.run_id)
+        attrition_counts = self.repository.get_attrition_counts(
+            start_tick, current_tick, run_id=simulation.run_id
+        )
 
         bankruptcy_count = attrition_counts.get("bankruptcy_count", 0)
         death_count = attrition_counts.get("death_count", 0)
@@ -98,10 +105,18 @@ class SnapshotViewModel:
         current_households = len(simulation.households)
 
         total_firms_window = current_firms + bankruptcy_count
-        bankruptcy_rate = (bankruptcy_count / total_firms_window * 100.0) if total_firms_window > 0 else 0.0
+        bankruptcy_rate = (
+            (bankruptcy_count / total_firms_window * 100.0)
+            if total_firms_window > 0
+            else 0.0
+        )
 
         total_households_window = current_households + death_count
-        death_rate = (death_count / total_households_window * 100.0) if total_households_window > 0 else 0.0
+        death_rate = (
+            (death_count / total_households_window * 100.0)
+            if total_households_window > 0
+            else 0.0
+        )
 
         # --- Phase 5: New Metrics ---
         # 1. Avg Tax Rate
@@ -109,15 +124,17 @@ class SnapshotViewModel:
         # We need tick-level tax collected. Government now tracks this history.
         last_tick_tax = 0.0
         if simulation.government.tax_history:
-             last_tick_stats = simulation.government.tax_history[-1]
-             if last_tick_stats["tick"] == current_tick:
-                  last_tick_tax = last_tick_stats.get("total", 0.0)
-             else:
-                  # Maybe the government hasn't finalized this tick yet when this runs?
-                  # Or this runs after finalize?
-                  # If snapshot is called after run_tick, we should check the last entry.
-                  # If tick mismatch, maybe previous tick.
-                  last_tick_tax = last_tick_stats.get("total", 0.0) # Use latest available
+            last_tick_stats = simulation.government.tax_history[-1]
+            if last_tick_stats["tick"] == current_tick:
+                last_tick_tax = last_tick_stats.get("total", 0.0)
+            else:
+                # Maybe the government hasn't finalized this tick yet when this runs?
+                # Or this runs after finalize?
+                # If snapshot is called after run_tick, we should check the last entry.
+                # If tick mismatch, maybe previous tick.
+                last_tick_tax = last_tick_stats.get(
+                    "total", 0.0
+                )  # Use latest available
 
         avg_tax_rate = (last_tick_tax / gdp) if gdp > 0 else 0.0
 
@@ -127,15 +144,23 @@ class SnapshotViewModel:
         active_household_count = 0
 
         for h in simulation.households:
-             if h.is_active:
-                  leisure = simulation.household_time_allocation.get(h.id, 0.0)
-                  total_leisure_hours += leisure
-                  active_household_count += 1
-                  if h.last_leisure_type == "PARENTING":
-                       total_parenting_hours += leisure
-
-        avg_leisure_hours = (total_leisure_hours / active_household_count) if active_household_count > 0 else 0.0
-        parenting_rate = (total_parenting_hours / total_leisure_hours * 100.0) if total_leisure_hours > 0 else 0.0
+            if h.is_active:
+                leisure = simulation.household_time_allocation.get(h.id, 0.0)
+                total_leisure_hours += leisure
+                active_household_count += 1
+                if h.last_leisure_type == "PARENTING":
+                    total_parenting_hours += leisure
+
+        avg_leisure_hours = (
+            (total_leisure_hours / active_household_count)
+            if active_household_count > 0
+            else 0.0
+        )
+        parenting_rate = (
+            (total_parenting_hours / total_leisure_hours * 100.0)
+            if total_leisure_hours > 0
+            else 0.0
+        )
 
         return DashboardGlobalIndicatorsDTO(
             death_rate=death_rate,
@@ -146,18 +171,21 @@ class SnapshotViewModel:
             gini=gini,
             avg_tax_rate=avg_tax_rate,
             avg_leisure_hours=avg_leisure_hours,
-            parenting_rate=parenting_rate
+            parenting_rate=parenting_rate,
         )
 
-    def _get_society_data(self, simulation: Simulation, current_tick: int) -> SocietyTabDataDTO:
+    def _get_society_data(
+        self, simulation: Simulation, current_tick: int
+    ) -> SocietyTabDataDTO:
         # Generation Stats
-        gen_stats_raw = self.repository.get_generation_stats(current_tick, run_id=simulation.run_id)
+        gen_stats_raw = self.repository.get_generation_stats(
+            current_tick, run_id=simulation.run_id
+        )
         generations = [
             GenerationStatDTO(
-                gen=row["gen"],
-                count=row["count"],
-                avg_assets=row["avg_assets"]
-            ) for row in gen_stats_raw
+                gen=row["gen"], count=row["count"], avg_assets=row["avg_assets"]
+            )
+            for row in gen_stats_raw
         ]
 
         # Mitosis Cost
@@ -167,7 +195,7 @@ class SnapshotViewModel:
         sensitivity = simulation.config_module.MITOSIS_SENSITIVITY
 
         pop_ratio = current_pop / max(1, target_pop)
-        mitosis_cost = base_threshold * (pop_ratio ** sensitivity)
+        mitosis_cost = base_threshold * (pop_ratio**sensitivity)
 
         # Unemployment Pie & Time Allocation
         struggling = 0
@@ -175,11 +203,11 @@ class SnapshotViewModel:
 
         # Time Allocation Aggregation
         time_allocation = {
-             "WORK": 0.0,
-             "PARENTING": 0.0,
-             "SELF_DEV": 0.0,
-             "ENTERTAINMENT": 0.0,
-             "IDLE": 0.0
+            "WORK": 0.0,
+            "PARENTING": 0.0,
+            "SELF_DEV": 0.0,
+            "ENTERTAINMENT": 0.0,
+            "IDLE": 0.0,
         }
         total_leisure_sum = 0.0
         count_active = 0
@@ -197,24 +225,27 @@ class SnapshotViewModel:
 
                 # Time Allocation Logic
                 leisure_hours = simulation.household_time_allocation.get(h.id, 0.0)
-                work_hours = getattr(simulation.config_module, "HOURS_PER_TICK", 24.0) - getattr(simulation.config_module, "SHOPPING_HOURS", 2.0) - leisure_hours
+                work_hours = (
+                    getattr(simulation.config_module, "HOURS_PER_TICK", 24.0)
+                    - getattr(simulation.config_module, "SHOPPING_HOURS", 2.0)
+                    - leisure_hours
+                )
 
                 time_allocation["WORK"] += work_hours
 
                 l_type = h.last_leisure_type
                 if l_type in time_allocation:
-                     time_allocation[l_type] += leisure_hours
+                    time_allocation[l_type] += leisure_hours
                 else:
-                     time_allocation["IDLE"] += leisure_hours # Fallback
+                    time_allocation["IDLE"] += leisure_hours  # Fallback
 
                 total_leisure_sum += leisure_hours
 
-        unemployment_pie = {
-            "struggling": struggling,
-            "voluntary": voluntary
-        }
+        unemployment_pie = {"struggling": struggling, "voluntary": voluntary}
 
-        avg_leisure_hours = (total_leisure_sum / count_active) if count_active > 0 else 0.0
+        avg_leisure_hours = (
+            (total_leisure_sum / count_active) if count_active > 0 else 0.0
+        )
 
         return SocietyTabDataDTO(
             generations=generations,
@@ -222,17 +253,29 @@ class SnapshotViewModel:
             unemployment_pie=unemployment_pie,
             time_allocation=time_allocation,
             avg_leisure_hours=avg_leisure_hours,
-            avg_education_level=simulation.tracker.get_latest_indicators().get("avg_education_level", 0.0),
-            brain_waste_count=int(simulation.tracker.get_latest_indicators().get("brain_waste_count", 0))
+            avg_education_level=simulation.tracker.get_latest_indicators().get(
+                "avg_education_level", 0.0
+            ),
+            brain_waste_count=int(
+                simulation.tracker.get_latest_indicators().get("brain_waste_count", 0)
+            ),
         )
 
-    def _get_government_data(self, simulation: Simulation, current_tick: int) -> GovernmentTabDataDTO:
+    def _get_government_data(
+        self, simulation: Simulation, current_tick: int
+    ) -> GovernmentTabDataDTO:
         # Accumulated Stats
         tax_revenue = simulation.government.tax_revenue.copy()
         # Fiscal Balance
         fiscal_balance = {
             "revenue": simulation.government.total_collected_tax,
-            "expense": simulation.government.total_spent_subsidies + (simulation.government.infrastructure_level * getattr(simulation.config_module, "INFRASTRUCTURE_INVESTMENT_COST", 5000.0)) # Approx
+            "expense": simulation.government.total_spent_subsidies
+            + (
+                simulation.government.infrastructure_level
+                * getattr(
+                    simulation.config_module, "INFRASTRUCTURE_INVESTMENT_COST", 5000.0
+                )
+            ),  # Approx
         }
 
         # Phase 5: Historical Data
@@ -246,14 +289,16 @@ class SnapshotViewModel:
         current_avg_tax_rate = 0.0
 
         if tax_history:
-             last = tax_history[-1]
-             # Calculate rate relative to GDP
-             gdp = simulation.tracker.get_latest_indicators().get("total_consumption", 1.0)
-             current_avg_tax_rate = (last.get("total", 0.0) / gdp) if gdp > 0 else 0.0
+            last = tax_history[-1]
+            # Calculate rate relative to GDP
+            gdp = simulation.tracker.get_latest_indicators().get(
+                "total_consumption", 1.0
+            )
+            current_avg_tax_rate = (last.get("total", 0.0) / gdp) if gdp > 0 else 0.0
 
         if welfare_history:
-             last_w = welfare_history[-1]
-             current_welfare = last_w.get("welfare", 0.0) + last_w.get("stimulus", 0.0)
+            last_w = welfare_history[-1]
+            current_welfare = last_w.get("welfare", 0.0) + last_w.get("stimulus", 0.0)
 
         return GovernmentTabDataDTO(
             tax_revenue=tax_revenue,
@@ -262,29 +307,40 @@ class SnapshotViewModel:
             welfare_spending=current_welfare,
             current_avg_tax_rate=current_avg_tax_rate,
             welfare_history=welfare_history,
-            education_spending=simulation.government.current_tick_stats.get("education_spending", 0.0) if hasattr(simulation.government, "education_history") else 0.0,
-            education_history=getattr(simulation.government, "education_history", [])
+            education_spending=simulation.government.current_tick_stats.get(
+                "education_spending", 0.0
+            )
+            if hasattr(simulation.government, "education_history")
+            else 0.0,
+            education_history=getattr(simulation.government, "education_history", []),
         )
 
-    def _get_market_data(self, simulation: Simulation, current_tick: int) -> MarketTabDataDTO:
+    def _get_market_data(
+        self, simulation: Simulation, current_tick: int
+    ) -> MarketTabDataDTO:
         # Commodity Volumes (Current Tick)
         commodity_volumes = {}
         # Fetch from markets
         for name, market in simulation.markets.items():
-            if hasattr(market, 'get_daily_volume'):
-                 commodity_volumes[name] = market.get_daily_volume()
+            if hasattr(market, "get_daily_volume"):
+                commodity_volumes[name] = market.get_daily_volume()
 
         # History Window
         WINDOW_SIZE = 50
         start_tick = max(0, current_tick - WINDOW_SIZE)
 
-        history_data = self.repository.get_economic_indicators(start_tick, current_tick, run_id=simulation.run_id)
+        history_data = self.repository.get_economic_indicators(
+            start_tick, current_tick, run_id=simulation.run_id
+        )
 
         # CPI: Weighted Average of Goods Prices
         # In `EconomicIndicatorData`, we have `avg_goods_price` (which is weighted avg of goods).
         # We also have `food_avg_price`.
         # Let's use `avg_goods_price` as CPI proxy.
-        cpi = [row["avg_goods_price"] if row["avg_goods_price"] else 0.0 for row in history_data]
+        cpi = [
+            row["avg_goods_price"] if row["avg_goods_price"] else 0.0
+            for row in history_data
+        ]
 
         # Maslow Fulfillment: 100 - avg_survival_need
         # We need `avg_survival_need` from history.
@@ -296,16 +352,18 @@ class SnapshotViewModel:
         return MarketTabDataDTO(
             commodity_volumes=commodity_volumes,
             cpi=cpi,
-            maslow_fulfillment=maslow_fulfillment
+            maslow_fulfillment=maslow_fulfillment,
         )
 
-    def _get_finance_data(self, simulation: Simulation, current_tick: int) -> FinanceTabDataDTO:
+    def _get_finance_data(
+        self, simulation: Simulation, current_tick: int
+    ) -> FinanceTabDataDTO:
         stock_market = simulation.stock_market
 
         market_cap = 0.0
         volume = 0.0
         turnover = 0.0
-        dividend_yield = 0.0 # Placeholder
+        dividend_yield = 0.0  # Placeholder
 
         if stock_market:
             # Market Cap = Sum(Price * Total Shares)
@@ -313,12 +371,14 @@ class SnapshotViewModel:
             # StockMarket doesn't store total shares, Firms do.
             for firm in simulation.firms:
                 if firm.is_active:
-                    price = stock_market.get_stock_price(firm.id) or 0.0 # get_stock_price handles None? It returns Optional[float]
+                    price = (
+                        stock_market.get_stock_price(firm.id) or 0.0
+                    )  # get_stock_price handles None? It returns Optional[float]
                     # If None (no trade), use last trade or reference?
                     # StockMarket.get_stock_price returns last trade price or None.
                     if price == 0.0:
-                         # Fallback to daily avg or reference
-                         price = stock_market.get_daily_avg_price(firm.id)
+                        # Fallback to daily avg or reference
+                        price = stock_market.get_daily_avg_price(firm.id)
 
                     market_cap += price * firm.total_shares
 
@@ -343,18 +403,20 @@ class SnapshotViewModel:
             # But `market.get_daily_volume()` is abstract in `Market`.
 
             # Volume (Daily)
-            if hasattr(stock_market, 'get_daily_volume'):
-                 volume = stock_market.get_daily_volume()
+            if hasattr(stock_market, "get_daily_volume"):
+                volume = stock_market.get_daily_volume()
 
             # For Turnover: Volume / Total Outstanding Shares?
             # Total shares in market = Sum(firm.total_shares)
-            total_shares_market = sum(f.total_shares for f in simulation.firms if f.is_active)
+            total_shares_market = sum(
+                f.total_shares for f in simulation.firms if f.is_active
+            )
             if total_shares_market > 0:
-                 turnover = (volume / total_shares_market) * 100.0 # Percentage
+                turnover = (volume / total_shares_market) * 100.0  # Percentage
 
         return FinanceTabDataDTO(
             market_cap=market_cap,
             volume=volume,
             turnover=turnover,
-            dividend_yield=dividend_yield
+            dividend_yield=dividend_yield,
         )
diff --git a/simulation/world_state.py b/simulation/world_state.py
index bf3d5a1..0b150a0 100644
--- a/simulation/world_state.py
+++ b/simulation/world_state.py
@@ -14,7 +14,10 @@ if TYPE_CHECKING:
     from simulation.markets.stock_market import StockMarket
     from simulation.metrics.economic_tracker import EconomicIndicatorTracker
     from simulation.metrics.inequality_tracker import InequalityTracker
-    from simulation.metrics.stock_tracker import StockMarketTracker, PersonalityStatisticsTracker
+    from simulation.metrics.stock_tracker import (
+        StockMarketTracker,
+        PersonalityStatisticsTracker,
+    )
     from simulation.ai_model import AIEngineRegistry
     from simulation.ai.ai_training_manager import AITrainingManager
     from simulation.systems.ma_manager import MAManager
@@ -54,7 +57,7 @@ class WorldState:
         config_manager: ConfigManager,
         config_module: Any,
         logger: logging.Logger,
-        repository: SimulationRepository
+        repository: SimulationRepository,
     ) -> None:
         self.config_manager = config_manager
         self.config_module = config_module
@@ -90,7 +93,7 @@ class WorldState:
         self.generational_wealth_audit: Optional[GenerationalWealthAudit] = None
         self.breeding_planner: Optional[VectorizedHouseholdPlanner] = None
         self.transaction_processor: Optional[TransactionProcessor] = None
-        self.lifecycle_manager: Optional[Any] = None # To be AgentLifecycleManager
+        self.lifecycle_manager: Optional[Any] = None  # To be AgentLifecycleManager
         self.goods_data: List[Dict[str, Any]] = []
         self.real_estate_units: List[RealEstateUnit] = []
         self.finance_system: Optional[FinanceSystem] = None
diff --git a/temp_ap.py b/temp_ap.py
index 55c9c30..6e8d59f 100644
--- a/temp_ap.py
+++ b/temp_ap.py
@@ -11,6 +11,7 @@ if TYPE_CHECKING:
 
 logger = logging.getLogger(__name__)
 
+
 class ActionProcessor:
     """
     Processes actions and transactions in the simulation.
@@ -22,9 +23,7 @@ class ActionProcessor:
         self.world_state = world_state
 
     def process_transactions(
-        self,
-        transactions: List[Transaction],
-        market_data_callback: Callable[[], Any]
+        self, transactions: List[Transaction], market_data_callback: Callable[[], Any]
     ) -> None:
         """
         Delegates transaction processing to the TransactionProcessor system using SimulationState.
@@ -39,6 +38,7 @@ class ActionProcessor:
             market_data = {"goods_market": goods_market_data}
 
             from simulation.dtos.api import SimulationState
+
             state = SimulationState(
                 time=self.world_state.time,
                 households=self.world_state.households,
@@ -55,11 +55,13 @@ class ActionProcessor:
                 tracker=self.world_state.tracker,
                 logger=self.world_state.logger,
                 reflux_system=self.world_state.reflux_system,
-                ai_training_manager=getattr(self.world_state, "ai_training_manager", None),
+                ai_training_manager=getattr(
+                    self.world_state, "ai_training_manager", None
+                ),
                 ai_trainer=getattr(self.world_state, "ai_trainer", None),
                 next_agent_id=self.world_state.next_agent_id,
                 real_estate_units=self.world_state.real_estate_units,
-                transactions=transactions
+                transactions=transactions,
             )
             self.world_state.transaction_processor.execute(state)
         else:
diff --git a/temp_tp.py b/temp_tp.py
index 5f713b9..ed1f03d 100644
--- a/temp_tp.py
+++ b/temp_tp.py
@@ -13,6 +13,7 @@ if TYPE_CHECKING:
 
 logger = logging.getLogger(__name__)
 
+
 class TransactionProcessor(SystemInterface):
     """
     Simulation ì—”ì§„ì˜ ê±°ëŒ€í•œ ê±°ë˜ ì²˜ë¦¬ ë¡œì§ì„ ë‹´ë‹¹í•˜ëŠ” ì „ìš© í´ë˜ìŠ¤.
@@ -34,7 +35,9 @@ class TransactionProcessor(SystemInterface):
         current_time = state.time
 
         # market_data is now in state
-        goods_market_data = state.market_data.get("goods_market", {}) if state.market_data else {}
+        goods_market_data = (
+            state.market_data.get("goods_market", {}) if state.market_data else {}
+        )
 
         for tx in transactions:
             buyer = agents.get(tx.buyer_id)
@@ -45,29 +48,34 @@ class TransactionProcessor(SystemInterface):
 
             trade_value = tx.quantity * tx.price
             sales_tax_rate = getattr(self.config_module, "SALES_TAX_RATE", 0.05)
-            tax_amount = 0.0 # Initialize for scope
-            
+            tax_amount = 0.0  # Initialize for scope
+
             # ==================================================================
             # 1. Financial Settlement (Asset Transfer & Taxes)
             # ==================================================================
             if tx.transaction_type == "goods":
                 # Goods: Apply Sales Tax
                 tax_amount = trade_value * sales_tax_rate
-                
+
                 # Solvency Check
-                if hasattr(buyer, 'check_solvency'):
+                if hasattr(buyer, "check_solvency"):
                     if buyer.assets < (trade_value + tax_amount):
                         buyer.check_solvency(government)
 
-                buyer.assets -= (trade_value + tax_amount)
+                buyer.assets -= trade_value + tax_amount
                 seller.assets += trade_value
-                government.collect_tax(tax_amount, f"sales_tax_{tx.transaction_type}", buyer.id, current_time)
+                government.collect_tax(
+                    tax_amount,
+                    f"sales_tax_{tx.transaction_type}",
+                    buyer.id,
+                    current_time,
+                )
 
             elif tx.transaction_type == "stock":
                 # Stock: NO Sales Tax (Capital Gains Tax is handled elsewhere/later)
                 buyer.assets -= trade_value
                 seller.assets += trade_value
-            
+
             elif tx.transaction_type in ["labor", "research_labor"]:
                 # Labor: Apply Income Tax
                 tax_payer = getattr(self.config_module, "INCOME_TAX_PAYER", "HOUSEHOLD")
@@ -76,22 +84,30 @@ class TransactionProcessor(SystemInterface):
                 if "basic_food_current_sell_price" in goods_market_data:
                     avg_food_price = goods_market_data["basic_food_current_sell_price"]
                 else:
-                    avg_food_price = getattr(self.config_module, "GOODS_INITIAL_PRICE", {}).get("basic_food", 5.0)
-                
-                daily_food_need = getattr(self.config_module, "HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK", 1.0)
+                    avg_food_price = getattr(
+                        self.config_module, "GOODS_INITIAL_PRICE", {}
+                    ).get("basic_food", 5.0)
+
+                daily_food_need = getattr(
+                    self.config_module, "HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK", 1.0
+                )
                 survival_cost = max(avg_food_price * daily_food_need, 10.0)
 
                 tax_amount = government.calculate_income_tax(trade_value, survival_cost)
-                
+
                 if tax_payer == "FIRM":
-                    buyer.assets -= (trade_value + tax_amount)
+                    buyer.assets -= trade_value + tax_amount
                     seller.assets += trade_value
-                    government.collect_tax(tax_amount, "income_tax_firm", buyer.id, current_time)
+                    government.collect_tax(
+                        tax_amount, "income_tax_firm", buyer.id, current_time
+                    )
                 else:
                     buyer.assets -= trade_value
-                    seller.assets += (trade_value - tax_amount)
-                    government.collect_tax(tax_amount, "income_tax_household", seller.id, current_time)
-            
+                    seller.assets += trade_value - tax_amount
+                    government.collect_tax(
+                        tax_amount, "income_tax_household", seller.id, current_time
+                    )
+
             elif tx.item_id == "interest_payment":
                 # Interest Payment: Buyer (Borrower) pays Seller (Bank)
                 buyer.assets -= trade_value
@@ -103,7 +119,9 @@ class TransactionProcessor(SystemInterface):
                 # Dividend: Firm (Seller) pays Household (Buyer)
                 seller.assets -= trade_value
                 buyer.assets += trade_value
-                if isinstance(buyer, Household) and hasattr(buyer, "capital_income_this_tick"):
+                if isinstance(buyer, Household) and hasattr(
+                    buyer, "capital_income_this_tick"
+                ):
                     buyer.capital_income_this_tick += trade_value
             else:
                 # Default / Other (Loan principals, etc.)
@@ -114,20 +132,40 @@ class TransactionProcessor(SystemInterface):
             # 2. Meta Logic (Inventory, Employment, Share Registry)
             # ==================================================================
             if tx.transaction_type in ["labor", "research_labor"]:
-                self._handle_labor_transaction(tx, buyer, seller, trade_value, tax_amount, agents)
+                self._handle_labor_transaction(
+                    tx, buyer, seller, trade_value, tax_amount, agents
+                )
 
             elif tx.transaction_type == "goods":
-                self._handle_goods_transaction(tx, buyer, seller, trade_value, current_time)
+                self._handle_goods_transaction(
+                    tx, buyer, seller, trade_value, current_time
+                )
 
             elif tx.transaction_type == "stock":
-                self._handle_stock_transaction(tx, buyer, seller, state.stock_market, state.logger, current_time)
+                self._handle_stock_transaction(
+                    tx, buyer, seller, state.stock_market, state.logger, current_time
+                )
 
-            elif tx.transaction_type == "housing" or (hasattr(tx, "market_id") and tx.market_id == "housing"):
+            elif tx.transaction_type == "housing" or (
+                hasattr(tx, "market_id") and tx.market_id == "housing"
+            ):
                 pass
 
-    def _handle_labor_transaction(self, tx: Transaction, buyer: Any, seller: Any, trade_value: float, tax_amount: float, agents: Dict[int, Any]):
+    def _handle_labor_transaction(
+        self,
+        tx: Transaction,
+        buyer: Any,
+        seller: Any,
+        trade_value: float,
+        tax_amount: float,
+        agents: Dict[int, Any],
+    ):
         if isinstance(seller, Household):
-            if seller.is_employed and seller.employer_id is not None and seller.employer_id != buyer.id:
+            if (
+                seller.is_employed
+                and seller.employer_id is not None
+                and seller.employer_id != buyer.id
+            ):
                 previous_employer = agents.get(seller.employer_id)
                 if isinstance(previous_employer, Firm):
                     # SoC Refactor: Use HRDepartment
@@ -138,22 +176,31 @@ class TransactionProcessor(SystemInterface):
             seller.current_wage = tx.price
             seller.needs["labor_need"] = 0.0
             if hasattr(seller, "labor_income_this_tick"):
-                seller.labor_income_this_tick += (trade_value - tax_amount)
+                seller.labor_income_this_tick += trade_value - tax_amount
 
         if isinstance(buyer, Firm):
             # SoC Refactor: Use HRDepartment and FinanceDepartment
             if seller not in buyer.hr.employees:
                 buyer.hr.hire(seller, tx.price)
             else:
-                 buyer.hr.employee_wages[seller.id] = tx.price
+                buyer.hr.employee_wages[seller.id] = tx.price
 
             buyer.finance.record_expense(trade_value)
 
             if tx.transaction_type == "research_labor":
                 research_skill = seller.skills.get("research", Skill("research")).value
-                buyer.productivity_factor += (research_skill * self.config_module.RND_PRODUCTIVITY_MULTIPLIER)
-
-    def _handle_goods_transaction(self, tx: Transaction, buyer: Any, seller: Any, trade_value: float, current_time: int):
+                buyer.productivity_factor += (
+                    research_skill * self.config_module.RND_PRODUCTIVITY_MULTIPLIER
+                )
+
+    def _handle_goods_transaction(
+        self,
+        tx: Transaction,
+        buyer: Any,
+        seller: Any,
+        trade_value: float,
+        current_time: int,
+    ):
         good_info = self.config_module.GOODS.get(tx.item_id, {})
         is_service = good_info.get("is_service", False)
 
@@ -161,18 +208,26 @@ class TransactionProcessor(SystemInterface):
             if isinstance(buyer, Household):
                 buyer.consume(tx.item_id, tx.quantity, current_time)
         else:
-            seller.inventory[tx.item_id] = max(0, seller.inventory.get(tx.item_id, 0) - tx.quantity)
-            is_raw_material = tx.item_id in getattr(self.config_module, "RAW_MATERIAL_SECTORS", [])
+            seller.inventory[tx.item_id] = max(
+                0, seller.inventory.get(tx.item_id, 0) - tx.quantity
+            )
+            is_raw_material = tx.item_id in getattr(
+                self.config_module, "RAW_MATERIAL_SECTORS", []
+            )
 
             if is_raw_material and isinstance(buyer, Firm):
-                buyer.input_inventory[tx.item_id] = buyer.input_inventory.get(tx.item_id, 0.0) + tx.quantity
+                buyer.input_inventory[tx.item_id] = (
+                    buyer.input_inventory.get(tx.item_id, 0.0) + tx.quantity
+                )
             else:
                 current_qty = buyer.inventory.get(tx.item_id, 0)
                 existing_quality = buyer.inventory_quality.get(tx.item_id, 1.0)
-                tx_quality = tx.quality if hasattr(tx, 'quality') else 1.0
+                tx_quality = tx.quality if hasattr(tx, "quality") else 1.0
                 total_new_qty = current_qty + tx.quantity
-                new_avg_quality = ((current_qty * existing_quality) + (tx.quantity * tx_quality)) / total_new_qty
-                
+                new_avg_quality = (
+                    (current_qty * existing_quality) + (tx.quantity * tx_quality)
+                ) / total_new_qty
+
                 buyer.inventory_quality[tx.item_id] = new_avg_quality
                 buyer.inventory[tx.item_id] = total_new_qty
 
@@ -180,16 +235,24 @@ class TransactionProcessor(SystemInterface):
             # SoC Refactor: Use FinanceDepartment
             seller.finance.record_revenue(trade_value)
             seller.finance.sales_volume_this_tick += tx.quantity
-        
+
         if isinstance(buyer, Household):
             if not is_service:
                 buyer.current_consumption += tx.quantity
                 if tx.item_id == "basic_food":
                     buyer.current_food_consumption += tx.quantity
 
-    def _handle_stock_transaction(self, tx: Transaction, buyer: Any, seller: Any, stock_market: Any, logger: Any, current_time: int):
+    def _handle_stock_transaction(
+        self,
+        tx: Transaction,
+        buyer: Any,
+        seller: Any,
+        stock_market: Any,
+        logger: Any,
+        current_time: int,
+    ):
         firm_id = int(tx.item_id.split("_")[1])
-        
+
         # 1. Update Holdings
         if isinstance(seller, Household):
             current_shares = seller.shares_owned.get(firm_id, 0)
@@ -203,9 +266,11 @@ class TransactionProcessor(SystemInterface):
         elif hasattr(seller, "portfolio"):
             # Secondary market trade for Firms/Institutions if they have portfolio
             seller.portfolio.remove(firm_id, tx.quantity)
-        
+
         if isinstance(buyer, Household):
-            buyer.shares_owned[firm_id] = buyer.shares_owned.get(firm_id, 0) + tx.quantity
+            buyer.shares_owned[firm_id] = (
+                buyer.shares_owned.get(firm_id, 0) + tx.quantity
+            )
             if hasattr(buyer, "portfolio"):
                 buyer.portfolio.add(firm_id, tx.quantity, tx.price)
                 # Sync legacy dict
@@ -218,16 +283,20 @@ class TransactionProcessor(SystemInterface):
         if stock_market:
             # Sync Buyer
             if hasattr(buyer, "portfolio") and firm_id in buyer.portfolio.holdings:
-                 stock_market.update_shareholder(buyer.id, firm_id, buyer.portfolio.holdings[firm_id].quantity)
+                stock_market.update_shareholder(
+                    buyer.id, firm_id, buyer.portfolio.holdings[firm_id].quantity
+                )
 
             # Sync Seller
             if hasattr(seller, "portfolio") and firm_id in seller.portfolio.holdings:
-                stock_market.update_shareholder(seller.id, firm_id, seller.portfolio.holdings[firm_id].quantity)
+                stock_market.update_shareholder(
+                    seller.id, firm_id, seller.portfolio.holdings[firm_id].quantity
+                )
             else:
                 stock_market.update_shareholder(seller.id, firm_id, 0.0)
 
         if logger:
             logger.info(
                 f"STOCK_TX | Buyer: {buyer.id}, Seller: {seller.id}, Firm: {firm_id}, Qty: {tx.quantity}, Price: {tx.price}",
-                extra={"tick": current_time, "tags": ["stock_market", "transaction"]}
+                extra={"tick": current_time, "tags": ["stock_market", "transaction"]},
             )
diff --git a/temp_ts.py b/temp_ts.py
index a239b18..3e2c1de 100644
--- a/temp_ts.py
+++ b/temp_ts.py
@@ -8,17 +8,13 @@ from simulation.systems.tech.api import FirmTechInfoDTO, HouseholdEducationDTO
 from simulation.firms import Firm
 from simulation.markets.order_book_market import OrderBookMarket
 from simulation.agents.government import Government
-from simulation.dtos import (
-    AIDecisionData,
-    GovernmentStateDTO,
-    MacroFinancialContext
-)
+from simulation.dtos import AIDecisionData, GovernmentStateDTO, MacroFinancialContext
 from simulation.systems.api import (
     EventContext,
     SocialMobilityContext,
     SensoryContext,
     CommerceContext,
-    LearningUpdateContext
+    LearningUpdateContext,
 )
 from simulation.dtos.api import SimulationState
 
@@ -41,7 +37,9 @@ class TickScheduler:
         self.world_state = world_state
         self.action_processor = action_processor
 
-    def run_tick(self, injectable_sensory_dto: Optional[GovernmentStateDTO] = None) -> None:
+    def run_tick(
+        self, injectable_sensory_dto: Optional[GovernmentStateDTO] = None
+    ) -> None:
         state = self.world_state
 
         # --- Gold Standard / Money Supply Verification (WO-016) ---
@@ -49,7 +47,7 @@ class TickScheduler:
             state.baseline_money_supply = state.calculate_total_money()
             state.logger.info(
                 f"MONEY_SUPPLY_BASELINE | Baseline Money Supply set to: {state.baseline_money_supply:.2f}",
-                extra={"tick": state.time, "money_supply": state.baseline_money_supply}
+                extra={"tick": state.time, "money_supply": state.baseline_money_supply},
             )
 
         state.time += 1
@@ -60,18 +58,22 @@ class TickScheduler:
 
         # ===== Chaos Injection Events (via EventSystem) =====
         if state.event_system:
-             context: EventContext = {
-                 "households": state.households,
-                 "firms": state.firms,
-                 "markets": state.markets,
-                 "government": state.government,
-                 "central_bank": state.central_bank,
-                 "bank": state.bank
-             }
-             state.event_system.execute_scheduled_events(state.time, context, state.stress_scenario_config)
+            context: EventContext = {
+                "households": state.households,
+                "firms": state.firms,
+                "markets": state.markets,
+                "government": state.government,
+                "central_bank": state.central_bank,
+                "bank": state.bank,
+            }
+            state.event_system.execute_scheduled_events(
+                state.time, context, state.stress_scenario_config
+            )
 
         # WO-054: Government Public Education Logic (START OF TICK)
-        state.government.run_public_education(state.households, state.config_module, state.time, state.reflux_system)
+        state.government.run_public_education(
+            state.households, state.config_module, state.time, state.reflux_system
+        )
 
         if (
             state.time > 0
@@ -80,16 +82,24 @@ class TickScheduler:
             state.ai_training_manager.run_imitation_learning_cycle(state.time)
 
         # Update Bank Tick (Interest Processing)
-        if hasattr(state.bank, "run_tick") and "reflux_system" in state.bank.run_tick.__code__.co_varnames:
-             state.bank.run_tick(state.agents, state.time, reflux_system=state.reflux_system)
-        elif hasattr(state.bank, "run_tick") and "current_tick" in state.bank.run_tick.__code__.co_varnames:
-             state.bank.run_tick(state.agents, state.time)
+        if (
+            hasattr(state.bank, "run_tick")
+            and "reflux_system" in state.bank.run_tick.__code__.co_varnames
+        ):
+            state.bank.run_tick(
+                state.agents, state.time, reflux_system=state.reflux_system
+            )
+        elif (
+            hasattr(state.bank, "run_tick")
+            and "current_tick" in state.bank.run_tick.__code__.co_varnames
+        ):
+            state.bank.run_tick(state.agents, state.time)
         else:
-             state.bank.run_tick(state.agents)
+            state.bank.run_tick(state.agents)
 
         # Phase 14-1: Firm Profit Distribution (Operation Reflux)
         for firm in state.firms:
-             firm.distribute_profit(state.agents, state.time)
+            firm.distribute_profit(state.agents, state.time)
 
         for firm in state.firms:
             firm.hires_last_tick = 0
@@ -100,7 +110,13 @@ class TickScheduler:
 
         # WO-057-Fix: Update tracker with the latest data before government decisions
         money_supply = state.calculate_total_money()
-        state.tracker.track(state.time, state.households, state.firms, state.markets, money_supply=money_supply)
+        state.tracker.track(
+            state.time,
+            state.households,
+            state.firms,
+            state.markets,
+            money_supply=money_supply,
+        )
 
         # [WO-060] Update stock market reference prices at the start of the tick
         if state.stock_market is not None:
@@ -110,10 +126,11 @@ class TickScheduler:
         # Phase 17-4: Update Social Ranks & Calculate Reference Standard (via SocialSystem)
         market_data = self.prepare_market_data(state.tracker)
 
-        if getattr(state.config_module, "ENABLE_VANITY_SYSTEM", False) and state.social_system:
-            context: SocialMobilityContext = {
-                "households": state.households
-            }
+        if (
+            getattr(state.config_module, "ENABLE_VANITY_SYSTEM", False)
+            and state.social_system
+        ):
+            context: SocialMobilityContext = {"households": state.households}
             state.social_system.update_social_ranks(context)
             ref_std = state.social_system.calculate_reference_standard(context)
             market_data["reference_standard"] = ref_std
@@ -131,13 +148,17 @@ class TickScheduler:
         sensory_context: SensoryContext = {
             "tracker": state.tracker,
             "government": state.government,
-            "time": state.time
+            "time": state.time,
         }
 
         if state.sensory_system:
-            sensory_dto = state.sensory_system.generate_government_sensory_dto(sensory_context)
+            sensory_dto = state.sensory_system.generate_government_sensory_dto(
+                sensory_context
+            )
         else:
-            state.logger.error("SensorySystem not initialized! Check SimulationInitializer.")
+            state.logger.error(
+                "SensorySystem not initialized! Check SimulationInitializer."
+            )
             sensory_dto = GovernmentStateDTO(state.time, 0, 0, 0, 0, 0, 0)
 
         # Supply to Government
@@ -145,7 +166,7 @@ class TickScheduler:
             state.government.update_sensory_data(injectable_sensory_dto)
             state.logger.warning(
                 f"INJECTED_SENSORY_DATA | Overrode sensory data for tick {state.time} with custom DTO.",
-                extra={"tick": state.time, "tags": ["test_injection"]}
+                extra={"tick": state.time, "tags": ["test_injection"]},
             )
         else:
             state.government.update_sensory_data(sensory_dto)
@@ -156,25 +177,35 @@ class TickScheduler:
             interest_rate_trend = state.bank.base_rate - state.last_interest_rate
             state.last_interest_rate = state.bank.base_rate
 
-            market_volatility = state.stock_tracker.get_market_volatility() if state.stock_tracker else 0.0
+            market_volatility = (
+                state.stock_tracker.get_market_volatility()
+                if state.stock_tracker
+                else 0.0
+            )
 
             macro_financial_context = MacroFinancialContext(
                 inflation_rate=sensory_dto.inflation_sma,
                 gdp_growth_rate=sensory_dto.gdp_growth_sma,
                 market_volatility=market_volatility,
-                interest_rate_trend=interest_rate_trend
+                interest_rate_trend=interest_rate_trend,
             )
 
         # [DEBUG WO-057]
         latest_indicators = state.tracker.get_latest_indicators()
-        avg_price = latest_indicators.get('avg_goods_price', 'MISSING')
-        inf_sma = sensory_dto.inflation_sma if isinstance(sensory_dto.inflation_sma, (int, float)) else 0.0
+        avg_price = latest_indicators.get("avg_goods_price", "MISSING")
+        inf_sma = (
+            sensory_dto.inflation_sma
+            if isinstance(sensory_dto.inflation_sma, (int, float))
+            else 0.0
+        )
 
         # 3. Government Makes Policy Decision
         latest_gdp = state.tracker.get_latest_indicators().get("total_production", 0.0)
         market_data["total_production"] = latest_gdp
 
-        state.government.make_policy_decision(market_data, state.time, state.central_bank)
+        state.government.make_policy_decision(
+            market_data, state.time, state.central_bank
+        )
 
         # Monetary policy is updated AFTER the government's fiscal/AI decision
         state.central_bank.step(state.time)
@@ -192,13 +223,17 @@ class TickScheduler:
         state.finance_system.service_debt(state.time)
 
         # Phase 4: Welfare Check
-        state.government.run_welfare_check(list(state.agents.values()), market_data, state.time)
+        state.government.run_welfare_check(
+            list(state.agents.values()), market_data, state.time
+        )
 
         # Snapshot agents for learning (Pre-state)
         for f in state.firms:
-            if f.is_active: f.pre_state_snapshot = f.get_agent_data()
+            if f.is_active:
+                f.pre_state_snapshot = f.get_agent_data()
         for h in state.households:
-            if h.is_active: h.pre_state_snapshot = h.get_agent_data()
+            if h.is_active:
+                h.pre_state_snapshot = h.get_agent_data()
 
         # ==================================================================================
         # THE SACRED SEQUENCE (WO-103)
@@ -224,14 +259,14 @@ class TickScheduler:
             ai_training_manager=getattr(state, "ai_training_manager", None),
             ai_trainer=getattr(state, "ai_trainer", None),
             next_agent_id=state.next_agent_id,
-            real_estate_units=state.real_estate_units
+            real_estate_units=state.real_estate_units,
         )
 
         # 1. Decisions
-        firm_pre_states, household_pre_states, household_time_allocation = self._phase_decisions(
-            sim_state, market_data, macro_financial_context
+        firm_pre_states, household_pre_states, household_time_allocation = (
+            self._phase_decisions(sim_state, market_data, macro_financial_context)
         )
-        state.household_time_allocation = household_time_allocation # Update state
+        state.household_time_allocation = household_time_allocation  # Update state
 
         # 2. Matching
         self._phase_matching(sim_state)
@@ -255,9 +290,9 @@ class TickScheduler:
         current_vacancies = 0
         labor_market = state.markets.get("labor")
         if labor_market and isinstance(labor_market, OrderBookMarket):
-             for item_orders in labor_market.buy_orders.values():
-                 for order in item_orders:
-                     current_vacancies += order.quantity
+            for item_orders in labor_market.buy_orders.values():
+                for order in item_orders:
+                    current_vacancies += order.quantity
 
         consumption_market_data = market_data.copy()
         consumption_market_data["job_vacancies"] = current_vacancies
@@ -270,62 +305,83 @@ class TickScheduler:
             "reflux_system": state.reflux_system,
             "market_data": consumption_market_data,
             "config": state.config_module,
-            "time": state.time
+            "time": state.time,
         }
 
         if state.commerce_system:
-            household_leisure_effects = state.commerce_system.execute_consumption_and_leisure(commerce_context, state.stress_scenario_config)
+            household_leisure_effects = (
+                state.commerce_system.execute_consumption_and_leisure(
+                    commerce_context, state.stress_scenario_config
+                )
+            )
         else:
-            state.logger.error("CommerceSystem not initialized! Skipping consumption cycle.")
+            state.logger.error(
+                "CommerceSystem not initialized! Skipping consumption cycle."
+            )
             household_leisure_effects = {}
 
         # --- Phase 23: Technology Manager Update ---
         # WO-053: Orchestrate Technology Update with DTOs
         # 1. Calculate Human Capital Index
         active_households_dto = [
-            HouseholdEducationDTO(is_active=h.is_active, education_level=getattr(h, 'education_level', 0))
+            HouseholdEducationDTO(
+                is_active=h.is_active, education_level=getattr(h, "education_level", 0)
+            )
             for h in state.households
         ]
-        total_edu = sum(h['education_level'] for h in active_households_dto if h['is_active'])
-        active_count = sum(1 for h in active_households_dto if h['is_active'])
+        total_edu = sum(
+            h["education_level"] for h in active_households_dto if h["is_active"]
+        )
+        active_count = sum(1 for h in active_households_dto if h["is_active"])
         human_capital_index = total_edu / active_count if active_count > 0 else 1.0
 
         # 2. Prepare Firm DTOs
         active_firms_dto = [
-            FirmTechInfoDTO(id=f.id, sector=f.sector, is_visionary=getattr(f, 'is_visionary', False))
-            for f in state.firms if f.is_active
+            FirmTechInfoDTO(
+                id=f.id, sector=f.sector, is_visionary=getattr(f, "is_visionary", False)
+            )
+            for f in state.firms
+            if f.is_active
         ]
 
-        state.technology_manager.update(state.time, active_firms_dto, human_capital_index)
+        state.technology_manager.update(
+            state.time, active_firms_dto, human_capital_index
+        )
 
         # Phase 17-3B: Process Housing (Logic that didn't fit in matching/lifecycle)
         # Housing matching happened in _phase_matching.
         # But apply_homeless_penalty needs to run.
-        state.housing_system.process_housing(state) # Update rent/maintenance
+        state.housing_system.process_housing(state)  # Update rent/maintenance
         state.housing_system.apply_homeless_penalty(state)
 
         # ---------------------------------------------------------
         # Activate Farm Logic (Production & Needs/Wages)
         # ---------------------------------------------------------
         for firm in state.firms:
-             if firm.is_active:
-                 firm.produce(state.time, technology_manager=state.technology_manager)
-                 firm.update_needs(state.time, state.government, market_data, state.reflux_system)
+            if firm.is_active:
+                firm.produce(state.time, technology_manager=state.technology_manager)
+                firm.update_needs(
+                    state.time, state.government, market_data, state.reflux_system
+                )
 
-                 # 2a. Corporate Tax
-                 if firm.is_active and firm.current_profit > 0:
-                     tax_amount = state.government.calculate_corporate_tax(firm.current_profit)
-                     firm.assets -= tax_amount
-                     state.government.collect_tax(tax_amount, "corporate_tax", firm.id, state.time)
+                # 2a. Corporate Tax
+                if firm.is_active and firm.current_profit > 0:
+                    tax_amount = state.government.calculate_corporate_tax(
+                        firm.current_profit
+                    )
+                    firm.assets -= tax_amount
+                    state.government.collect_tax(
+                        tax_amount, "corporate_tax", firm.id, state.time
+                    )
 
         # 2b. Government Infra Investment
         if state.government.invest_infrastructure(state.time, state.reflux_system):
             tfp_boost = getattr(state.config_module, "INFRASTRUCTURE_TFP_BOOST", 0.05)
             for firm in state.firms:
-                firm.productivity_factor *= (1.0 + tfp_boost)
+                firm.productivity_factor *= 1.0 + tfp_boost
             state.logger.info(
-                f"GLOBAL_TFP_BOOST | All firms productivity increased by {tfp_boost*100:.1f}%",
-                extra={"tick": state.time, "tags": ["government", "infrastructure"]}
+                f"GLOBAL_TFP_BOOST | All firms productivity increased by {tfp_boost * 100:.1f}%",
+                extra={"tick": state.time, "tags": ["government", "infrastructure"]},
             )
 
         # --- AI Learning Update (Unified) ---
@@ -343,7 +399,7 @@ class TickScheduler:
                 context: LearningUpdateContext = {
                     "reward": reward,
                     "next_agent_data": agent_data,
-                    "next_market_data": market_data_for_learning
+                    "next_market_data": market_data_for_learning,
                 }
                 firm.update_learning(context)
 
@@ -377,7 +433,7 @@ class TickScheduler:
                 context: LearningUpdateContext = {
                     "reward": reward,
                     "next_agent_data": agent_data,
-                    "next_market_data": market_data_for_learning
+                    "next_market_data": market_data_for_learning,
                 }
                 household.update_learning(context)
 
@@ -400,7 +456,9 @@ class TickScheduler:
         state.firms = [f for f in state.firms if f.is_active]
 
         if len(state.firms) < active_firms_count_before:
-            state.logger.info(f"CLEANUP | Removed {active_firms_count_before - len(state.firms)} inactive firms from execution list.")
+            state.logger.info(
+                f"CLEANUP | Removed {active_firms_count_before - len(state.firms)} inactive firms from execution list."
+            )
 
         # Phase 5: Finalize Government Stats
         state.government.finalize_tick(state.time)
@@ -447,20 +505,28 @@ class TickScheduler:
             delta = current_money - expected_money
 
             msg = f"MONEY_SUPPLY_CHECK | Current: {current_money:.2f}, Expected: {expected_money:.2f}, Delta: {delta:.4f}"
-            extra_data = {"tick": state.time, "current": current_money, "expected": expected_money, "delta": delta, "tags": ["money_supply"]}
+            extra_data = {
+                "tick": state.time,
+                "current": current_money,
+                "expected": expected_money,
+                "delta": delta,
+                "tags": ["money_supply"],
+            }
 
             if abs(delta) > 1.0:
-                 state.logger.warning(msg, extra=extra_data)
+                state.logger.warning(msg, extra=extra_data)
             else:
-                 state.logger.info(msg, extra=extra_data)
+                state.logger.info(msg, extra=extra_data)
 
         # WO-058: Generational Wealth Audit
         if state.time % 100 == 0:
-             state.generational_wealth_audit.run_audit(state.households, state.time)
+            state.generational_wealth_audit.run_audit(state.households, state.time)
 
         # Phase 29: Crisis Monitor
         if state.crisis_monitor:
-            state.crisis_monitor.monitor(state.time, [f for f in state.firms if f.is_active])
+            state.crisis_monitor.monitor(
+                state.time, [f for f in state.firms if f.is_active]
+            )
 
         state.logger.info(
             f"--- Ending Tick {state.time} ---",
@@ -471,9 +537,16 @@ class TickScheduler:
             market.clear_orders()
 
         if state.stock_market is not None:
-            state.stock_tracker.track_all_firms([f for f in state.firms if f.is_active], state.stock_market)
+            state.stock_tracker.track_all_firms(
+                [f for f in state.firms if f.is_active], state.stock_market
+            )
 
-    def _phase_decisions(self, state: SimulationState, market_data: Dict[str, Any], macro_context: Optional[MacroFinancialContext]) -> Tuple[Dict, Dict, Dict]:
+    def _phase_decisions(
+        self,
+        state: SimulationState,
+        market_data: Dict[str, Any],
+        macro_context: Optional[MacroFinancialContext],
+    ) -> Tuple[Dict, Dict, Dict]:
         """Phase 1: Agents make decisions and place orders."""
         firm_pre_states = {}
         household_pre_states = {}
@@ -482,16 +555,21 @@ class TickScheduler:
         # 1. Firms
         for firm in state.firms:
             if firm.is_active:
-                if hasattr(firm.decision_engine, 'ai_engine') and firm.decision_engine.ai_engine:
+                if (
+                    hasattr(firm.decision_engine, "ai_engine")
+                    and firm.decision_engine.ai_engine
+                ):
                     pre_strategic_state = (
                         firm.decision_engine.ai_engine._get_strategic_state(
                             firm.get_agent_data(), market_data
                         )
                     )
-                    pre_tactical_state = firm.decision_engine.ai_engine._get_tactical_state(
-                        firm.decision_engine.ai_engine.chosen_intention,
-                        firm.get_agent_data(),
-                        market_data,
+                    pre_tactical_state = (
+                        firm.decision_engine.ai_engine._get_tactical_state(
+                            firm.decision_engine.ai_engine.chosen_intention,
+                            firm.get_agent_data(),
+                            market_data,
+                        )
                     )
                     firm_pre_states[firm.id] = {
                         "pre_strategic_state": pre_strategic_state,
@@ -503,8 +581,13 @@ class TickScheduler:
                 stress_config = self.world_state.stress_scenario_config
 
                 firm_orders, action_vector = firm.make_decision(
-                    state.markets, state.goods_data, market_data, state.time,
-                    state.government, state.reflux_system, stress_config
+                    state.markets,
+                    state.goods_data,
+                    market_data,
+                    state.time,
+                    state.government,
+                    state.reflux_system,
+                    stress_config,
                 )
 
                 for order in firm_orders:
@@ -512,12 +595,17 @@ class TickScheduler:
                     if target_market:
                         target_market.place_order(order, state.time)
 
-                state.logger.debug(f"TRACE_ENGINE | Firm {firm.id} submitted {len(firm_orders)} orders to markets.")
+                state.logger.debug(
+                    f"TRACE_ENGINE | Firm {firm.id} submitted {len(firm_orders)} orders to markets."
+                )
 
         # 2. Households
         for household in state.households:
             if household.is_active:
-                if hasattr(household.decision_engine, 'ai_engine') and household.decision_engine.ai_engine:
+                if (
+                    hasattr(household.decision_engine, "ai_engine")
+                    and household.decision_engine.ai_engine
+                ):
                     pre_strategic_state = (
                         household.decision_engine.ai_engine._get_strategic_state(
                             household.get_agent_data(), market_data
@@ -529,10 +617,16 @@ class TickScheduler:
 
                 stress_config = self.world_state.stress_scenario_config
                 household_orders, action_vector = household.make_decision(
-                    state.markets, state.goods_data, market_data, state.time, state.government, macro_context, stress_config
+                    state.markets,
+                    state.goods_data,
+                    market_data,
+                    state.time,
+                    state.government,
+                    macro_context,
+                    stress_config,
                 )
 
-                if hasattr(action_vector, 'work_aggressiveness'):
+                if hasattr(action_vector, "work_aggressiveness"):
                     work_aggressiveness = action_vector.work_aggressiveness
                 else:
                     work_aggressiveness = 0.5
@@ -547,13 +641,20 @@ class TickScheduler:
 
                 for order in household_orders:
                     if order.order_type == "INVEST" and order.market_id == "admin":
-                        state.logger.info(f"FOUND_INVEST_ORDER | Agent {household.id} attempting startup via admin market.")
+                        state.logger.info(
+                            f"FOUND_INVEST_ORDER | Agent {household.id} attempting startup via admin market."
+                        )
                         self.world_state.firm_system.spawn_firm(state, household)
                         continue
 
                     target_market_id = order.market_id
 
-                    if order.order_type in ["DEPOSIT", "WITHDRAW", "LOAN_REQUEST", "REPAYMENT"]:
+                    if order.order_type in [
+                        "DEPOSIT",
+                        "WITHDRAW",
+                        "LOAN_REQUEST",
+                        "REPAYMENT",
+                    ]:
                         target_market_id = "loan_market"
                     elif order.item_id in ["deposit", "currency"]:
                         target_market_id = "loan_market"
@@ -568,7 +669,9 @@ class TickScheduler:
                             extra={"tick": state.time},
                         )
 
-                state.logger.debug(f"TRACE_ENGINE | Household {household.id} submitted {len(household_orders)} orders back to engine.")
+                state.logger.debug(
+                    f"TRACE_ENGINE | Household {household.id} submitted {len(household_orders)} orders back to engine."
+                )
 
         return firm_pre_states, household_pre_states, household_time_allocation
 
@@ -591,8 +694,8 @@ class TickScheduler:
 
         # 3. Housing Market
         if "housing" in state.markets:
-             housing_transactions = state.markets["housing"].match_orders(state.time)
-             all_transactions.extend(housing_transactions)
+            housing_transactions = state.markets["housing"].match_orders(state.time)
+            all_transactions.extend(housing_transactions)
 
         state.transactions = all_transactions
 
@@ -619,7 +722,9 @@ class TickScheduler:
         debt_data_map = {}
         deposit_data_map = {}
         for agent_id in state.agents:
-            if isinstance(state.agents[agent_id], Household) or isinstance(state.agents[agent_id], Firm):
+            if isinstance(state.agents[agent_id], Household) or isinstance(
+                state.agents[agent_id], Firm
+            ):
                 debt_data_map[agent_id] = state.bank.get_debt_summary(agent_id)
                 deposit_data_map[agent_id] = state.bank.get_deposit_balance(agent_id)
 
@@ -633,12 +738,16 @@ class TickScheduler:
                     latest = tracker.get_latest_indicators()
                     avg_price = latest.get(f"{good_name}_avg_price", 0)
                 if avg_price <= 0:
-                    avg_price = state.config_module.GOODS[good_name].get("initial_price", 10.0)
+                    avg_price = state.config_module.GOODS[good_name].get(
+                        "initial_price", 10.0
+                    )
 
                 goods_market_data[f"{good_name}_current_sell_price"] = avg_price
 
         latest_indicators = tracker.get_latest_indicators()
-        avg_wage = latest_indicators.get("labor_avg_price", state.config_module.LABOR_MARKET_MIN_WAGE)
+        avg_wage = latest_indicators.get(
+            "labor_avg_price", state.config_module.LABOR_MARKET_MIN_WAGE
+        )
 
         labor_market = state.markets.get("labor")
         best_wage_offer = 0.0
@@ -649,13 +758,13 @@ class TickScheduler:
 
         job_vacancies = 0
         if labor_market and isinstance(labor_market, OrderBookMarket):
-             for item_orders in labor_market.buy_orders.values():
-                 for order in item_orders:
-                     job_vacancies += order.quantity
+            for item_orders in labor_market.buy_orders.values():
+                for order in item_orders:
+                    job_vacancies += order.quantity
 
         goods_market_data["labor"] = {
             "avg_wage": avg_wage,
-            "best_wage_offer": best_wage_offer
+            "best_wage_offer": best_wage_offer,
         }
         goods_market_data["job_vacancies"] = job_vacancies
 
@@ -677,15 +786,23 @@ class TickScheduler:
                 if price <= 0:
                     price = state.stock_market.get_best_ask(firm.id) or 0
                 if price <= 0:
-                    price = firm.assets / firm.total_shares if firm.total_shares > 0 else 10.0
+                    price = (
+                        firm.assets / firm.total_shares
+                        if firm.total_shares > 0
+                        else 10.0
+                    )
                 stock_market_data[firm_item_id] = {"avg_price": price}
 
-        rent_prices = [u.rent_price for u in state.real_estate_units if u.owner_id is not None]
-        avg_rent = sum(rent_prices) / len(rent_prices) if rent_prices else state.config_module.INITIAL_RENT_PRICE
+        rent_prices = [
+            u.rent_price for u in state.real_estate_units if u.owner_id is not None
+        ]
+        avg_rent = (
+            sum(rent_prices) / len(rent_prices)
+            if rent_prices
+            else state.config_module.INITIAL_RENT_PRICE
+        )
 
-        housing_market_data = {
-            "avg_rent_price": avg_rent
-        }
+        housing_market_data = {"avg_rent_price": avg_rent}
 
         return {
             "time": state.time,
@@ -697,5 +814,7 @@ class TickScheduler:
             "avg_goods_price": avg_goods_price_for_market_data,
             "debt_data": debt_data_map,
             "deposit_data": deposit_data_map,
-            "inflation": latest_indicators.get("inflation_rate", state.config_module.DEFAULT_INFLATION_RATE)
+            "inflation": latest_indicators.get(
+                "inflation_rate", state.config_module.DEFAULT_INFLATION_RATE
+            ),
         }
diff --git a/tests/agents/test_government.py b/tests/agents/test_government.py
index 93a1e15..a773b79 100644
--- a/tests/agents/test_government.py
+++ b/tests/agents/test_government.py
@@ -2,11 +2,14 @@ import pytest
 from unittest.mock import MagicMock, Mock
 from simulation.agents.government import Government
 
+
 @pytest.fixture
 def government_setup(mocker):
     # Mocking patches
-    mock_tax_agency_cls = mocker.patch('simulation.agents.government.TaxAgency')
-    mock_education_ministry_cls = mocker.patch('simulation.agents.government.MinistryOfEducation')
+    mock_tax_agency_cls = mocker.patch("simulation.agents.government.TaxAgency")
+    mock_education_ministry_cls = mocker.patch(
+        "simulation.agents.government.MinistryOfEducation"
+    )
 
     mock_tax_agency_instance = mock_tax_agency_cls.return_value
     mock_education_ministry_instance = mock_education_ministry_cls.return_value
@@ -14,7 +17,7 @@ def government_setup(mocker):
     mock_config = Mock()
     mock_config.GOVERNMENT_POLICY_MODE = "TAYLOR_RULE"
     mock_config.TICKS_PER_YEAR = 100
-    mock_config.INCOME_TAX_RATE = 0.1 # This is the initial rate
+    mock_config.INCOME_TAX_RATE = 0.1  # This is the initial rate
     mock_config.CORPORATE_TAX_RATE = 0.2
     mock_config.TAX_MODE = "PROGRESSIVE"
 
@@ -28,9 +31,10 @@ def government_setup(mocker):
         "government": government,
         "mock_tax_agency": mock_tax_agency_instance,
         "mock_education_ministry": mock_education_ministry_instance,
-        "mock_config": mock_config
+        "mock_config": mock_config,
     }
 
+
 def test_calculate_income_tax_delegation(government_setup):
     env = government_setup
     income = 50000
@@ -41,10 +45,11 @@ def test_calculate_income_tax_delegation(government_setup):
     env["mock_tax_agency"].calculate_income_tax.assert_called_once_with(
         income,
         survival_cost,
-        env["government"].income_tax_rate, # Should pass the current rate (0.15)
-        "PROGRESSIVE"
+        env["government"].income_tax_rate,  # Should pass the current rate (0.15)
+        "PROGRESSIVE",
     )
 
+
 def test_calculate_corporate_tax_delegation(government_setup):
     env = government_setup
     profit = 100000
@@ -53,14 +58,15 @@ def test_calculate_corporate_tax_delegation(government_setup):
 
     env["mock_tax_agency"].calculate_corporate_tax.assert_called_once_with(
         profit,
-        env["government"].corporate_tax_rate # Should pass the current rate (0.25)
+        env["government"].corporate_tax_rate,  # Should pass the current rate (0.25)
     )
 
+
 def test_collect_tax_delegation(government_setup):
     """Test if collect_tax delegates to TaxAgency."""
     env = government_setup
     amount = 1000
-    tax_type = 'income'
+    tax_type = "income"
     source_id = 101
     current_tick = 50
 
@@ -70,6 +76,7 @@ def test_collect_tax_delegation(government_setup):
         env["government"], amount, tax_type, source_id, current_tick
     )
 
+
 def test_run_public_education_delegation(government_setup):
     """Test if run_public_education delegates to MinistryOfEducation."""
     env = government_setup
@@ -99,11 +106,14 @@ def deficit_government_setup():
 
     # Mock FinanceSystem
     mock_finance = Mock()
-    mock_finance.issue_treasury_bonds.return_value = True # Simulate successful bond issuance
+    mock_finance.issue_treasury_bonds.return_value = (
+        True  # Simulate successful bond issuance
+    )
     government.finance_system = mock_finance
 
     return government
 
+
 def test_deficit_spending_allowed_within_limit(deficit_government_setup):
     """Test that the government can spend more than its assets, creating debt."""
     government = deficit_government_setup
@@ -113,7 +123,9 @@ def test_deficit_spending_allowed_within_limit(deficit_government_setup):
 
     # Debt limit = 10000 * 0.30 = 3000
     # Spending 500 will result in assets of -400, which is within the limit
-    amount_paid = government.provide_household_support(target_agent, 500, current_tick=1)
+    amount_paid = government.provide_household_support(
+        target_agent, 500, current_tick=1
+    )
 
     assert amount_paid == 500
     assert government.assets == -400
@@ -123,10 +135,11 @@ def test_deficit_spending_allowed_within_limit(deficit_government_setup):
     government.finalize_tick(1)
     assert government.total_debt == 400
 
+
 def test_deficit_spending_blocked_beyond_limit(deficit_government_setup):
     """Test that spending is blocked when it would exceed the debt/GDP limit."""
     government = deficit_government_setup
-    government._assets = -2900 # Already near the debt limit
+    government._assets = -2900  # Already near the debt limit
     target_agent = Mock()
     target_agent._assets = 0
 
@@ -134,11 +147,13 @@ def test_deficit_spending_blocked_beyond_limit(deficit_government_setup):
     # Current debt is 2900. Spending another 200 would make debt 3100, exceeding the limit.
     # Simulate FinanceSystem denying the bond issuance
     government.finance_system.issue_treasury_bonds.return_value = False
-    
-    amount_paid = government.provide_household_support(target_agent, 200, current_tick=1)
+
+    amount_paid = government.provide_household_support(
+        target_agent, 200, current_tick=1
+    )
 
     assert amount_paid == 0
-    assert government.assets == -2900 # Assets should not change
+    assert government.assets == -2900  # Assets should not change
     assert target_agent.assets == 0
 
     # Finalize tick to update debt
diff --git a/tests/api/test_dashboard_api.py b/tests/api/test_dashboard_api.py
index 96a218c..53a364f 100644
--- a/tests/api/test_dashboard_api.py
+++ b/tests/api/test_dashboard_api.py
@@ -12,7 +12,7 @@ from simulation.dtos import (
     SocietyTabDataDTO,
     GovernmentTabDataDTO,
     MarketTabDataDTO,
-    FinanceTabDataDTO
+    FinanceTabDataDTO,
 )
 from simulation.core_agents import Household
 from simulation.agents.government import Government
@@ -21,6 +21,7 @@ from simulation.metrics.inequality_tracker import InequalityTracker
 from simulation.markets.stock_market import StockMarket
 from dataclasses import asdict
 
+
 class TestDashboardAPI:
     def setup_method(self):
         self.mock_repo = MagicMock(spec=SimulationRepository)
@@ -51,7 +52,7 @@ class TestDashboardAPI:
             "education_spending": 0.0,
             "welfare_spending": 0.0,
             "stimulus_spending": 0.0,
-            "total_collected": 0.0
+            "total_collected": 0.0,
         }
 
         self.mock_simulation.markets = {}
@@ -81,7 +82,7 @@ class TestDashboardAPI:
         self.mock_tracker.get_latest_indicators.return_value = {
             "total_consumption": 50000.0,
             "avg_wage": 200.0,
-            "unemployment_rate": 5.0
+            "unemployment_rate": 5.0,
         }
 
         # Mock Inequality
@@ -92,13 +93,13 @@ class TestDashboardAPI:
         # Mock Attrition
         self.mock_repo.get_attrition_counts.return_value = {
             "bankruptcy_count": 2,
-            "death_count": 5
+            "death_count": 5,
         }
 
         # Mock Generation Stats
         self.mock_repo.get_generation_stats.return_value = [
             {"gen": 0, "count": 50, "avg_assets": 1000.0},
-            {"gen": 1, "count": 50, "avg_assets": 500.0}
+            {"gen": 1, "count": 50, "avg_assets": 500.0},
         ]
 
         # Mock Government
@@ -110,7 +111,7 @@ class TestDashboardAPI:
         # Mock Market History
         self.mock_repo.get_economic_indicators.return_value = [
             {"avg_goods_price": 10.0, "avg_survival_need": 20.0},
-            {"avg_goods_price": 11.0, "avg_survival_need": 21.0}
+            {"avg_goods_price": 11.0, "avg_survival_need": 21.0},
         ]
 
         # Mock Stock Market
@@ -137,25 +138,43 @@ class TestDashboardAPI:
         dto = DashboardSnapshotDTO(
             tick=100,
             global_indicators=DashboardGlobalIndicatorsDTO(
-                death_rate=0.0, bankruptcy_rate=0.0, employment_rate=100.0,
-                gdp=1000.0, avg_wage=10.0, gini=0.2, avg_tax_rate=0.0, avg_leisure_hours=0.0, parenting_rate=0.0
+                death_rate=0.0,
+                bankruptcy_rate=0.0,
+                employment_rate=100.0,
+                gdp=1000.0,
+                avg_wage=10.0,
+                gini=0.2,
+                avg_tax_rate=0.0,
+                avg_leisure_hours=0.0,
+                parenting_rate=0.0,
             ),
             tabs={
                 "society": SocietyTabDataDTO(
-                    generations=[], mitosis_cost=100.0, unemployment_pie={},
-                    time_allocation={}, avg_leisure_hours=0.0, avg_education_level=0.0, brain_waste_count=0
+                    generations=[],
+                    mitosis_cost=100.0,
+                    unemployment_pie={},
+                    time_allocation={},
+                    avg_leisure_hours=0.0,
+                    avg_education_level=0.0,
+                    brain_waste_count=0,
                 ),
                 "government": GovernmentTabDataDTO(
-                    tax_revenue={}, fiscal_balance={}, tax_revenue_history=[], welfare_spending=0.0,
-                    current_avg_tax_rate=0.0, welfare_history=[], education_spending=0.0, education_history=[]
+                    tax_revenue={},
+                    fiscal_balance={},
+                    tax_revenue_history=[],
+                    welfare_spending=0.0,
+                    current_avg_tax_rate=0.0,
+                    welfare_history=[],
+                    education_spending=0.0,
+                    education_history=[],
                 ),
                 "market": MarketTabDataDTO(
                     commodity_volumes={}, cpi=[], maslow_fulfillment=[]
                 ),
                 "finance": FinanceTabDataDTO(
                     market_cap=1000.0, volume=100.0, turnover=0.1, dividend_yield=0.0
-                )
-            }
+                ),
+            },
         )
 
         # Verify it can be converted to dict (simulating what happens before jsonify)
@@ -167,5 +186,6 @@ class TestDashboardAPI:
         assert "tabs" in result
         assert "society" in result["tabs"]
 
+
 if __name__ == "__main__":
     pytest.main([__file__])
diff --git a/tests/components/test_agent_lifecycle.py b/tests/components/test_agent_lifecycle.py
index c7bf726..b995a33 100644
--- a/tests/components/test_agent_lifecycle.py
+++ b/tests/components/test_agent_lifecycle.py
@@ -3,12 +3,14 @@ from unittest.mock import MagicMock
 from simulation.components.agent_lifecycle import AgentLifecycleComponent
 from simulation.systems.api import LifecycleContext
 
+
 @pytest.fixture
 def lifecycle_component():
     owner = MagicMock()
     config = MagicMock()
     return AgentLifecycleComponent(owner, config)
 
+
 def test_run_tick_execution_order(lifecycle_component):
     # Setup
     household = lifecycle_component.owner
@@ -18,11 +20,7 @@ def test_run_tick_execution_order(lifecycle_component):
     household.economy_manager = MagicMock()
     household.psychology = MagicMock()
 
-    context: LifecycleContext = {
-        "household": household,
-        "market_data": {},
-        "time": 1
-    }
+    context: LifecycleContext = {"household": household, "market_data": {}, "time": 1}
 
     # Execute
     lifecycle_component.run_tick(context)
@@ -32,6 +30,7 @@ def test_run_tick_execution_order(lifecycle_component):
     household.economy_manager.pay_taxes.assert_called_once()
     household.psychology.update_needs.assert_called_with(1, {})
 
+
 def test_run_tick_unemployed(lifecycle_component):
     household = lifecycle_component.owner
     household.is_employed = False
@@ -39,11 +38,7 @@ def test_run_tick_unemployed(lifecycle_component):
     household.economy_manager = MagicMock()
     household.psychology = MagicMock()
 
-    context: LifecycleContext = {
-        "household": household,
-        "market_data": {},
-        "time": 1
-    }
+    context: LifecycleContext = {"household": household, "market_data": {}, "time": 1}
 
     lifecycle_component.run_tick(context)
 
diff --git a/tests/components/test_demographics_component.py b/tests/components/test_demographics_component.py
index 02a0ac0..446143a 100644
--- a/tests/components/test_demographics_component.py
+++ b/tests/components/test_demographics_component.py
@@ -3,8 +3,8 @@ from unittest.mock import MagicMock, PropertyMock
 import pytest
 from simulation.components.demographics_component import DemographicsComponent
 
-class TestDemographicsComponent(unittest.TestCase):
 
+class TestDemographicsComponent(unittest.TestCase):
     def setUp(self):
         """Set up a mock owner and config for the component tests."""
         self.mock_owner = MagicMock()
@@ -22,7 +22,7 @@ class TestDemographicsComponent(unittest.TestCase):
             owner=self.mock_owner,
             initial_age=30.0,
             gender="F",
-            config_module=self.mock_config
+            config_module=self.mock_config,
         )
 
     def test_initialization(self):
@@ -43,7 +43,7 @@ class TestDemographicsComponent(unittest.TestCase):
 
     def test_handle_death_under_threshold(self):
         """Test that the agent does not die if below the age threshold."""
-        self.component._age = 50 # Below the first threshold of 60
+        self.component._age = 50  # Below the first threshold of 60
         self.assertFalse(self.component.handle_death(current_tick=1))
         self.assertTrue(self.mock_owner.is_active)
 
@@ -54,13 +54,13 @@ class TestDemographicsComponent(unittest.TestCase):
         # Since death is probabilistic, we can't guarantee it.
         # Instead, we check if the logic runs without error and returns a boolean.
         # To make it deterministic for a test, we could mock random.random
-        with unittest.mock.patch('random.random', return_value=0.0): # Force death
+        with unittest.mock.patch("random.random", return_value=0.0):  # Force death
             self.assertTrue(self.component.handle_death(current_tick=1))
             self.assertFalse(self.mock_owner.is_active)
 
         # Reset and test the case where it doesn't die
         self.mock_owner.is_active = True
-        with unittest.mock.patch('random.random', return_value=0.99): # Prevent death
+        with unittest.mock.patch("random.random", return_value=0.99):  # Prevent death
             self.assertFalse(self.component.handle_death(current_tick=1))
             self.assertTrue(self.mock_owner.is_active)
 
@@ -82,16 +82,19 @@ class TestDemographicsComponent(unittest.TestCase):
     def test_get_generational_similarity(self):
         """Test the calculation of generational similarity."""
         similarity = self.component.get_generational_similarity(0.5, 0.6)
-        self.assertAlmostEqual(similarity, 0.9) # 1.0 - abs(0.5 - 0.6)
+        self.assertAlmostEqual(similarity, 0.9)  # 1.0 - abs(0.5 - 0.6)
 
     def test_create_offspring_demographics(self):
         """Test the creation of demographic data for an offspring."""
-        offspring_data = self.component.create_offspring_demographics(new_id=10, current_tick=100)
+        offspring_data = self.component.create_offspring_demographics(
+            new_id=10, current_tick=100
+        )
 
         self.assertEqual(offspring_data["generation"], 1)
         self.assertEqual(offspring_data["parent_id"], self.mock_owner.id)
         self.assertEqual(offspring_data["initial_age"], 0.0)
         self.assertIn(offspring_data["gender"], ["M", "F"])
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     unittest.main()
diff --git a/tests/components/test_market_component.py b/tests/components/test_market_component.py
index 223f7f5..2d1220b 100644
--- a/tests/components/test_market_component.py
+++ b/tests/components/test_market_component.py
@@ -3,6 +3,7 @@ from unittest.mock import MagicMock
 from simulation.components.market_component import MarketComponent
 from simulation.systems.api import MarketInteractionContext
 
+
 @pytest.fixture
 def market_component():
     owner = MagicMock()
@@ -14,6 +15,7 @@ def market_component():
     config.BRAND_SENSITIVITY_BETA = 0.5
     return MarketComponent(owner, config)
 
+
 def test_choose_best_seller_utility(market_component):
     # Setup
     # Seller 1: Price 10, Quality 1.0, Awareness 0.0
@@ -32,9 +34,7 @@ def test_choose_best_seller_utility(market_component):
     market = MagicMock()
     market.get_all_asks.return_value = [ask1, ask2]
 
-    context: MarketInteractionContext = {
-        "markets": {"good_x": market}
-    }
+    context: MarketInteractionContext = {"markets": {"good_x": market}}
 
     # Execute
     best_seller, best_price = market_component.choose_best_seller("good_x", context)
@@ -47,6 +47,7 @@ def test_choose_best_seller_utility(market_component):
     assert best_seller == 2
     assert best_price == 12.0
 
+
 def test_choose_best_seller_no_market(market_component):
     context = {"markets": {}}
     best_seller, _ = market_component.choose_best_seller("missing_good", context)
diff --git a/tests/conftest.py b/tests/conftest.py
index f45757c..2a2fc5f 100644
--- a/tests/conftest.py
+++ b/tests/conftest.py
@@ -5,6 +5,7 @@ from modules.finance.system import FinanceSystem
 from simulation.agents.central_bank import CentralBank
 from simulation.bank import Bank
 
+
 @pytest.fixture
 def mock_config():
     """Provides a mock config object for testing."""
@@ -34,12 +35,14 @@ def mock_config():
 
     return config
 
+
 @pytest.fixture
 def mock_tracker():
     """Provides a mock economic tracker."""
     tracker = Mock()
     return tracker
 
+
 @pytest.fixture
 def mock_central_bank(mock_tracker, mock_config):
     """Provides a mock CentralBank."""
@@ -49,6 +52,7 @@ def mock_central_bank(mock_tracker, mock_config):
     cb.get_base_rate.return_value = 0.02
     return cb
 
+
 @pytest.fixture
 def mock_bank():
     """Provides a mock commercial Bank."""
@@ -56,6 +60,7 @@ def mock_bank():
     bank._assets = 5000000.0
     return bank
 
+
 @pytest.fixture
 def finance_system(mock_central_bank, mock_bank, mock_config):
     """Provides a mocked FinanceSystem attached to a mock government."""
@@ -68,6 +73,7 @@ def finance_system(mock_central_bank, mock_bank, mock_config):
     system.evaluate_solvency = MagicMock(wraps=system.evaluate_solvency)
     return system
 
+
 @pytest.fixture
 def government(mock_config, mock_tracker, finance_system):
     """
@@ -103,7 +109,7 @@ GOLDEN_FIXTURES_DIR = Path(__file__).parent / "goldens"
 def _get_golden_loader(fixture_name: str = "demo_fixture.json"):
     """Helper to load a golden fixture file."""
     from scripts.fixture_harvester import GoldenLoader
-    
+
     fixture_path = GOLDEN_FIXTURES_DIR / fixture_name
     if not fixture_path.exists():
         return None
@@ -115,7 +121,7 @@ def golden_households():
     """
     Provides household mocks loaded from golden fixture data.
     Falls back to empty list if no fixture exists.
-    
+
     Usage:
         def test_household_behavior(golden_households):
             assert len(golden_households) > 0
@@ -132,7 +138,7 @@ def golden_firms():
     """
     Provides firm mocks loaded from golden fixture data.
     Falls back to empty list if no fixture exists.
-    
+
     Usage:
         def test_firm_behavior(golden_firms):
             firm = golden_firms[0]
diff --git a/tests/diagnosis/conftest.py b/tests/diagnosis/conftest.py
index 5564409..3fa4671 100644
--- a/tests/diagnosis/conftest.py
+++ b/tests/diagnosis/conftest.py
@@ -1,4 +1,3 @@
-
 import pytest
 from unittest.mock import MagicMock
 import logging
@@ -7,12 +6,13 @@ from simulation.firms import Firm
 from simulation.markets.order_book_market import OrderBookMarket
 from simulation.core_markets import Market
 from simulation.decisions.base_decision_engine import BaseDecisionEngine
-from simulation.ai.api import Personality # Import Personality enum
+from simulation.ai.api import Personality  # Import Personality enum
 import config
 
 # Disable logging for cleaner test output
 logging.getLogger().setLevel(logging.CRITICAL)
 
+
 @pytest.fixture
 def mock_config_module():
     mock_config = MagicMock()
@@ -22,22 +22,24 @@ def mock_config_module():
             setattr(mock_config, key, getattr(config, key))
     return mock_config
 
+
 @pytest.fixture
 def simple_household(mock_config_module):
     mock_engine = MagicMock(spec=BaseDecisionEngine)
     household = Household(
         id=1,
         talent=Talent(1.0, {}),
-        goods_data=[], # Simplification
+        goods_data=[],  # Simplification
         initial_assets=100.0,
         initial_needs={"survival": 50.0},
         decision_engine=mock_engine,
-        value_orientation="wealth_and_needs", # Default
-        personality=Personality.MISER, # Default
-        config_module=mock_config_module
+        value_orientation="wealth_and_needs",  # Default
+        personality=Personality.MISER,  # Default
+        config_module=mock_config_module,
     )
     return household
 
+
 @pytest.fixture
 def simple_firm(mock_config_module):
     mock_engine = MagicMock(spec=BaseDecisionEngine)
@@ -48,11 +50,12 @@ def simple_firm(mock_config_module):
         specialization="basic_food",
         productivity_factor=1.0,
         decision_engine=mock_engine,
-        value_orientation="wealth_and_needs", # Default
-        config_module=mock_config_module
+        value_orientation="wealth_and_needs",  # Default
+        config_module=mock_config_module,
     )
     return firm
 
+
 @pytest.fixture
 def simple_market():
     return OrderBookMarket(market_id="basic_food")
diff --git a/tests/diagnosis/test_agent_decision.py b/tests/diagnosis/test_agent_decision.py
index 16d1c90..b81a7f8 100644
--- a/tests/diagnosis/test_agent_decision.py
+++ b/tests/diagnosis/test_agent_decision.py
@@ -1,10 +1,10 @@
-
 import pytest
 from unittest.mock import MagicMock
 from simulation.models import Order
 from simulation.core_agents import Household
 from simulation.firms import Firm
 
+
 def test_household_makes_decision(simple_household):
     """Spec 0: ì—ì´ì „íŠ¸ê°€ ì£¼ë¬¸ì„ ìƒì„±í•˜ëŠ”ì§€ ê²€ì¦ (Household)"""
     # Arrange
@@ -15,17 +15,16 @@ def test_household_makes_decision(simple_household):
         item_id="basic_food",
         quantity=1.0,
         price=10.0,
-        market_id="basic_food"
+        market_id="basic_food",
     )
     # make_decisions returns (orders, tactic)
-    simple_household.decision_engine.make_decisions = MagicMock(return_value=([expected_order], None))
+    simple_household.decision_engine.make_decisions = MagicMock(
+        return_value=([expected_order], None)
+    )
 
     # Act
     orders, tactic = simple_household.make_decision(
-        markets={},
-        goods_data=[],
-        market_data={},
-        current_time=1
+        markets={}, goods_data=[], market_data={}, current_time=1
     )
 
     # Assert
@@ -34,6 +33,7 @@ def test_household_makes_decision(simple_household):
     assert orders[0].item_id == "basic_food"
     assert orders[0].price == 10.0
 
+
 def test_firm_makes_decision(simple_firm):
     """Spec 0: ì—ì´ì „íŠ¸ê°€ ì£¼ë¬¸ì„ ìƒì„±í•˜ëŠ”ì§€ ê²€ì¦ (Firm)"""
     # Arrange
@@ -43,19 +43,18 @@ def test_firm_makes_decision(simple_firm):
         item_id="basic_food",
         quantity=5.0,
         price=12.0,
-        market_id="basic_food"
+        market_id="basic_food",
     )
     # make_decisions returns (orders, tactic)
-    simple_firm.decision_engine.make_decisions = MagicMock(return_value=([expected_order], None))
+    simple_firm.decision_engine.make_decisions = MagicMock(
+        return_value=([expected_order], None)
+    )
 
     # Act
     # Firm likely has make_decision too? Checking Firm class would be good,
     # but assuming consistency with BaseAgent.
     orders, tactic = simple_firm.make_decision(
-        markets={},
-        goods_data=[],
-        market_data={},
-        current_time=1
+        markets={}, goods_data=[], market_data={}, current_time=1
     )
 
     # Assert
diff --git a/tests/diagnosis/test_api_contract.py b/tests/diagnosis/test_api_contract.py
index 5c8a7fa..c9c481d 100644
--- a/tests/diagnosis/test_api_contract.py
+++ b/tests/diagnosis/test_api_contract.py
@@ -1,9 +1,9 @@
-
 import pytest
 from unittest.mock import MagicMock, patch
 from app import app, _build_simulation_update_payload
 from simulation.engine import Simulation
 
+
 @pytest.fixture
 def mock_sim_instance():
     sim = MagicMock(spec=Simulation)
@@ -13,6 +13,7 @@ def mock_sim_instance():
     sim.run_id = 1
     return sim
 
+
 def test_api_payload_structure_gdp(mock_sim_instance):
     """Spec 3: API Payload êµ¬ì¡° ë° GDP ë§¤í•‘ ê²€ì¦"""
     with app.app_context():
@@ -20,57 +21,91 @@ def test_api_payload_structure_gdp(mock_sim_instance):
         # but _build_simulation_update_payload instantiates EconomicIndicatorsViewModel(repo)
 
         # We patch EconomicIndicatorsViewModel in app.py module
-        with patch('app.EconomicIndicatorsViewModel') as MockVM:
+        with patch("app.EconomicIndicatorsViewModel") as MockVM:
             mock_vm_instance = MockVM.return_value
 
             # Setup expected return data
             # get_economic_indicators returns a list of dicts
             mock_vm_instance.get_economic_indicators.return_value = [
-                {"total_consumption": 1234.56, "population": 100, "unemployment_rate": 5.0}
+                {
+                    "total_consumption": 1234.56,
+                    "population": 100,
+                    "unemployment_rate": 5.0,
+                }
             ]
 
             # Setup other VM methods to avoid failures
-            mock_vm_instance.get_wealth_distribution.return_value = {"labels": [], "data": []}
-            mock_vm_instance.get_needs_distribution.return_value = {"household": {}, "firm": {}}
+            mock_vm_instance.get_wealth_distribution.return_value = {
+                "labels": [],
+                "data": [],
+            }
+            mock_vm_instance.get_needs_distribution.return_value = {
+                "household": {},
+                "firm": {},
+            }
             mock_vm_instance.get_sales_by_good.return_value = {}
             mock_vm_instance.get_market_order_book.return_value = []
 
             # Mock repository call inside helper
-            with patch('app.get_repository'):
+            with patch("app.get_repository"):
                 # Act
-                payload = _build_simulation_update_payload(current_tick=1, sim_instance=mock_sim_instance)
+                payload = _build_simulation_update_payload(
+                    current_tick=1, sim_instance=mock_sim_instance
+                )
 
                 # Assert
                 # 1. Check GDP mapping
                 assert "gdp" in payload, "Payload must contain 'gdp' field"
-                assert payload["gdp"] == 1234.56, f"Expected gdp 1234.56, got {payload['gdp']}"
+                assert payload["gdp"] == 1234.56, (
+                    f"Expected gdp 1234.56, got {payload['gdp']}"
+                )
 
                 # 2. Check structure
                 assert "market_update" in payload
                 assert "chart_update" in payload
 
+
 def test_api_payload_order_book_format(mock_sim_instance):
     """Spec 3: OrderBook ë°ì´í„° í˜•ì‹ ê²€ì¦"""
     with app.app_context():
-        with patch('app.EconomicIndicatorsViewModel') as MockVM:
+        with patch("app.EconomicIndicatorsViewModel") as MockVM:
             mock_vm_instance = MockVM.return_value
 
             # Basic indicators needed for payload construction
-            mock_vm_instance.get_economic_indicators.return_value = [{"total_consumption": 0}]
+            mock_vm_instance.get_economic_indicators.return_value = [
+                {"total_consumption": 0}
+            ]
             mock_vm_instance.get_wealth_distribution.return_value = {}
-            mock_vm_instance.get_needs_distribution.return_value = {"household": {}, "firm": {}}
+            mock_vm_instance.get_needs_distribution.return_value = {
+                "household": {},
+                "firm": {},
+            }
             mock_vm_instance.get_sales_by_good.return_value = {}
 
             # Setup Order Book
             expected_orders = [
-                {"type": "BID", "item_id": "food", "price": 10.0, "quantity": 5.0, "agent_id": 1},
-                {"type": "ASK", "item_id": "food", "price": 12.0, "quantity": 5.0, "agent_id": 101}
+                {
+                    "type": "BID",
+                    "item_id": "food",
+                    "price": 10.0,
+                    "quantity": 5.0,
+                    "agent_id": 1,
+                },
+                {
+                    "type": "ASK",
+                    "item_id": "food",
+                    "price": 12.0,
+                    "quantity": 5.0,
+                    "agent_id": 101,
+                },
             ]
             mock_vm_instance.get_market_order_book.return_value = expected_orders
 
-            with patch('app.get_repository'):
+            with patch("app.get_repository"):
                 # Act
-                payload = _build_simulation_update_payload(current_tick=1, sim_instance=mock_sim_instance)
+                payload = _build_simulation_update_payload(
+                    current_tick=1, sim_instance=mock_sim_instance
+                )
 
                 # Assert
                 assert "market_update" in payload
diff --git a/tests/diagnosis/test_dashboard_contract.py b/tests/diagnosis/test_dashboard_contract.py
index 59e1177..ce4e402 100644
--- a/tests/diagnosis/test_dashboard_contract.py
+++ b/tests/diagnosis/test_dashboard_contract.py
@@ -1,8 +1,12 @@
-
 import pytest
 from unittest.mock import MagicMock, patch
 from app import app
-from simulation.dtos import DashboardSnapshotDTO, DashboardGlobalIndicatorsDTO, SocietyTabDataDTO
+from simulation.dtos import (
+    DashboardSnapshotDTO,
+    DashboardGlobalIndicatorsDTO,
+    SocietyTabDataDTO,
+)
+
 
 @pytest.fixture
 def mock_sim_instance():
@@ -11,12 +15,13 @@ def mock_sim_instance():
     sim.run_id = 1
     return sim
 
+
 def test_dashboard_snapshot_endpoint_structure():
     """Phase 3-A: /api/simulation/dashboard ì—”ë“œí¬ì¸íŠ¸ì˜ DTO êµ¬ì¡° ë° í•„ë“œ ì •í•©ì„± ê²€ì¦"""
     with app.app_context():
-        with patch('app.SnapshotViewModel') as MockVM:
+        with patch("app.SnapshotViewModel") as MockVM:
             mock_vm_instance = MockVM.return_value
-            
+
             # Setup Mock Response according to DashboardSnapshotDTO
             global_indicators = DashboardGlobalIndicatorsDTO(
                 death_rate=0.1,
@@ -27,45 +32,52 @@ def test_dashboard_snapshot_endpoint_structure():
                 gini=0.35,
                 avg_tax_rate=0.25,
                 avg_leisure_hours=8.0,
-                parenting_rate=10.0
+                parenting_rate=10.0,
             )
-            
+
             society_tab = SocietyTabDataDTO(
                 generations=[],
                 mitosis_cost=100.0,
                 unemployment_pie={"struggling": 5, "voluntary": 10},
                 time_allocation={"WORK": 40.0, "PARENTING": 10.0},
-                avg_leisure_hours=8.0
+                avg_leisure_hours=8.0,
             )
-            
+
             snapshot = DashboardSnapshotDTO(
                 tick=42,
                 global_indicators=global_indicators,
-                tabs={"society": society_tab, "government": {}, "market": {}, "finance": {}}
+                tabs={
+                    "society": society_tab,
+                    "government": {},
+                    "market": {},
+                    "finance": {},
+                },
             )
-            
+
             mock_vm_instance.get_dashboard_snapshot.return_value = snapshot
 
-            with patch('app.get_or_create_simulation') as mock_get_sim:
+            with patch("app.get_or_create_simulation") as mock_get_sim:
                 mock_sim = MagicMock()
                 mock_sim.time = 42
                 mock_get_sim.return_value = mock_sim
-                
-                with patch('app.get_repository'):
+
+                with patch("app.get_repository"):
                     # Act
                     client = app.test_client()
-                    response = client.get('/api/simulation/dashboard')
-                    
+                    response = client.get("/api/simulation/dashboard")
+
                     # Assert
                     assert response.status_code == 200
                     data = response.get_json()
-                    
+
                     assert data["tick"] == 42
                     assert "global_indicators" in data
                     assert data["global_indicators"]["avg_tax_rate"] == 0.25
                     assert data["global_indicators"]["avg_leisure_hours"] == 8.0
-                    
+
                     assert "tabs" in data
                     assert "society" in data["tabs"]
-                    assert data["tabs"]["society"]["time_allocation"]["PARENTING"] == 10.0
+                    assert (
+                        data["tabs"]["society"]["time_allocation"]["PARENTING"] == 10.0
+                    )
                     assert "government" in data["tabs"]
diff --git a/tests/diagnosis/test_indicator_pipeline.py b/tests/diagnosis/test_indicator_pipeline.py
index b9d5ed8..dd32d4d 100644
--- a/tests/diagnosis/test_indicator_pipeline.py
+++ b/tests/diagnosis/test_indicator_pipeline.py
@@ -1,10 +1,10 @@
-
 import pytest
 from unittest.mock import MagicMock
 from simulation.metrics.economic_tracker import EconomicIndicatorTracker
 from simulation.models import Transaction
 from simulation.markets.order_book_market import OrderBookMarket
 
+
 def test_indicator_aggregation(simple_household, mock_config_module):
     """Spec 2: EconomicIndicatorTracker ì§€í‘œ ì§‘ê³„ ê²€ì¦"""
     # Arrange
@@ -18,12 +18,7 @@ def test_indicator_aggregation(simple_household, mock_config_module):
 
     # Act
     # track(self, time: int, households: List[Household], firms: List[Firm], markets: Dict[str, Market])
-    tracker.track(
-        time=1,
-        households=[simple_household],
-        firms=[],
-        markets={}
-    )
+    tracker.track(time=1, households=[simple_household], firms=[], markets={})
 
     # Assert
     # Check self.metrics for "total_consumption"
diff --git a/tests/diagnosis/test_market_mechanics.py b/tests/diagnosis/test_market_mechanics.py
index 6a2694e..20c268d 100644
--- a/tests/diagnosis/test_market_mechanics.py
+++ b/tests/diagnosis/test_market_mechanics.py
@@ -1,8 +1,8 @@
-
 import pytest
 from simulation.models import Order
 from simulation.markets.order_book_market import OrderBookMarket
 
+
 def test_order_book_matching(simple_market):
     """Spec 1: OrderBookMarket ë§¤ì¹­ ë¡œì§ ê²€ì¦"""
     # Arrange
@@ -14,15 +14,15 @@ def test_order_book_matching(simple_market):
         price=10.0,
         quantity=1.0,
         order_type="BUY",
-        market_id="basic_food"
+        market_id="basic_food",
     )
     sell_order = Order(
         agent_id=101,
         item_id="basic_food",
-        price=9.0, # Sell for less than buy -> Match expected
+        price=9.0,  # Sell for less than buy -> Match expected
         quantity=1.0,
         order_type="SELL",
-        market_id="basic_food"
+        market_id="basic_food",
     )
 
     # Act
diff --git a/tests/factories.py b/tests/factories.py
index 42b48ac..5cd1bff 100644
--- a/tests/factories.py
+++ b/tests/factories.py
@@ -1,9 +1,9 @@
-
 from typing import Dict, Any, Optional
 from simulation.ai.enums import Personality
 from modules.household.dtos import HouseholdStateDTO
 from simulation.dtos.firm_state_dto import FirmStateDTO
 
+
 def create_household_dto(
     id: int = 1,
     assets: float = 1000.0,
@@ -16,7 +16,7 @@ def create_household_dto(
     perceived_prices: Optional[Dict[str, float]] = None,
     agent_data: Optional[Dict[str, Any]] = None,
     personality: Personality = Personality.BALANCED,
-    **kwargs
+    **kwargs,
 ) -> HouseholdStateDTO:
     """Factory for HouseholdStateDTO with sensible defaults."""
     return HouseholdStateDTO(
@@ -42,9 +42,10 @@ def create_household_dto(
         perceived_prices=perceived_prices or {},
         conformity=kwargs.get("conformity", 0.5),
         social_rank=kwargs.get("social_rank", 0.5),
-        approval_rating=kwargs.get("approval_rating", 1)
+        approval_rating=kwargs.get("approval_rating", 1),
     )
 
+
 def create_firm_dto(
     id: int = 100,
     assets: float = 10000.0,
@@ -56,7 +57,7 @@ def create_firm_dto(
     capital_stock: float = 100.0,
     employees: Optional[list] = None,
     price_history: Optional[Dict[str, float]] = None,
-    **kwargs
+    **kwargs,
 ) -> FirmStateDTO:
     """Factory for FirmStateDTO with sensible defaults."""
     return FirmStateDTO(
@@ -90,5 +91,5 @@ def create_firm_dto(
         employees=employees or [],
         employees_data=kwargs.get("employees_data", {}),
         agent_data=kwargs.get("agent_data", {}),
-        system2_guidance=kwargs.get("system2_guidance", {})
+        system2_guidance=kwargs.get("system2_guidance", {}),
     )
diff --git a/tests/integration/test_phase23_production.py b/tests/integration/test_phase23_production.py
index 0e0860f..cf4141f 100644
--- a/tests/integration/test_phase23_production.py
+++ b/tests/integration/test_phase23_production.py
@@ -4,6 +4,7 @@ from simulation.components.production_department import ProductionDepartment
 from simulation.systems.technology_manager import TechnologyManager
 from simulation.firms import Firm
 
+
 class TestPhase23Production:
     @pytest.fixture
     def config(self):
@@ -33,7 +34,7 @@ class TestPhase23Production:
             firm.inventory = {}
             firm.input_inventory = {}
             firm.hr = MagicMock()
-            firm.hr.employees = [MagicMock()] # At least one employee
+            firm.hr.employees = [MagicMock()]  # At least one employee
             firm.hr.get_total_labor_skill.return_value = 100.0
             firm.hr.get_avg_skill.return_value = 1.0
 
@@ -46,6 +47,7 @@ class TestPhase23Production:
             firm.add_inventory = MagicMock()
 
             return firm, firm.production_department
+
         return _create_firm
 
     def test_production_boost_from_fertilizer_tech(self, config, firm_setup):
diff --git a/tests/integration/test_tick_normalization.py b/tests/integration/test_tick_normalization.py
index edae4a4..a87ffa9 100644
--- a/tests/integration/test_tick_normalization.py
+++ b/tests/integration/test_tick_normalization.py
@@ -5,6 +5,7 @@ from simulation.models import Transaction
 from simulation.world_state import WorldState
 from simulation.dtos.api import SimulationState
 
+
 class TestTickNormalization:
     @pytest.fixture
     def mock_world_state(self):
@@ -42,7 +43,9 @@ class TestTickNormalization:
         # Mocks needed for sim_state construction
         state.config_module = MagicMock()
         state.config_module.INFRASTRUCTURE_TFP_BOOST = 0.05
-        state.config_module.IMITATION_LEARNING_INTERVAL = 100 # Avoid modulo error if any
+        state.config_module.IMITATION_LEARNING_INTERVAL = (
+            100  # Avoid modulo error if any
+        )
 
         state.logger = MagicMock()
         state.reflux_system = MagicMock()
diff --git a/tests/modules/common/config_manager/test_config_manager.py b/tests/modules/common/config_manager/test_config_manager.py
index 4cc7f84..6d8a3be 100644
--- a/tests/modules/common/config_manager/test_config_manager.py
+++ b/tests/modules/common/config_manager/test_config_manager.py
@@ -3,13 +3,15 @@ from pathlib import Path
 from types import ModuleType
 from modules.common.config_manager.impl import ConfigManagerImpl
 
+
 @pytest.fixture
 def legacy_config():
-    config = ModuleType('legacy_config')
-    config.MY_LEGACY_VALUE = 'legacy'
+    config = ModuleType("legacy_config")
+    config.MY_LEGACY_VALUE = "legacy"
     config.ANOTHER_VALUE = 123
     return config
 
+
 @pytest.fixture
 def config_dir(tmp_path: Path):
     config_dir = tmp_path / "config"
@@ -26,27 +28,31 @@ def config_dir(tmp_path: Path):
     """)
     return config_dir
 
+
 def test_load_yaml(config_dir: Path):
     cm = ConfigManagerImpl(config_dir)
-    assert cm.get('test.a.b.c') == 1
-    assert cm.get('test.d') == 2
-    assert cm.get('other.x.y') == 'hello'
+    assert cm.get("test.a.b.c") == 1
+    assert cm.get("test.d") == 2
+    assert cm.get("other.x.y") == "hello"
+
 
 def test_get_with_default(config_dir: Path):
     cm = ConfigManagerImpl(config_dir)
-    assert cm.get('nonexistent.key', 'default_value') == 'default_value'
-    assert cm.get('test.a.nonexistent', 'another_default') == 'another_default'
+    assert cm.get("nonexistent.key", "default_value") == "default_value"
+    assert cm.get("test.a.nonexistent", "another_default") == "another_default"
+
 
 def test_hybrid_fallback(config_dir: Path, legacy_config: ModuleType):
     cm = ConfigManagerImpl(config_dir, legacy_config)
-    assert cm.get('test.a.b.c') == 1  # From YAML
-    assert cm.get('my.legacy.value') == 'legacy' # From legacy config
-    assert cm.get('another.value') == 123
+    assert cm.get("test.a.b.c") == 1  # From YAML
+    assert cm.get("my.legacy.value") == "legacy"  # From legacy config
+    assert cm.get("another.value") == 123
+
 
 def test_set_value_for_test(config_dir: Path):
     cm = ConfigManagerImpl(config_dir)
-    assert cm.get('test.a.b.c') == 1
-    cm.set_value_for_test('test.a.b.c', 99)
-    assert cm.get('test.a.b.c') == 99
-    cm.set_value_for_test('new.key.value', 'test_value')
-    assert cm.get('new.key.value') == 'test_value'
+    assert cm.get("test.a.b.c") == 1
+    cm.set_value_for_test("test.a.b.c", 99)
+    assert cm.get("test.a.b.c") == 99
+    cm.set_value_for_test("new.key.value", "test_value")
+    assert cm.get("new.key.value") == "test_value"
diff --git a/tests/modules/finance/test_corporate_finance.py b/tests/modules/finance/test_corporate_finance.py
index aa80aaa..e62276d 100644
--- a/tests/modules/finance/test_corporate_finance.py
+++ b/tests/modules/finance/test_corporate_finance.py
@@ -1,8 +1,8 @@
 import pytest
 from modules.finance.domain.corporate_finance import AltmanZScoreCalculator
 
-class TestAltmanZScoreCalculator:
 
+class TestAltmanZScoreCalculator:
     def test_calculate_safe_zone(self):
         """Test a scenario where the firm is clearly safe (Z > 3.0)."""
         # Example:
@@ -16,7 +16,7 @@ class TestAltmanZScoreCalculator:
             total_assets=1000.0,
             working_capital=400.0,
             retained_earnings=500.0,
-            average_profit=600.0
+            average_profit=600.0,
         )
         assert z == pytest.approx(3.16, abs=0.01)
 
@@ -33,7 +33,7 @@ class TestAltmanZScoreCalculator:
             total_assets=1000.0,
             working_capital=100.0,
             retained_earnings=0.0,
-            average_profit=100.0
+            average_profit=100.0,
         )
         assert z == pytest.approx(0.45, abs=0.01)
 
@@ -43,7 +43,7 @@ class TestAltmanZScoreCalculator:
             total_assets=0.0,
             working_capital=0.0,
             retained_earnings=0.0,
-            average_profit=0.0
+            average_profit=0.0,
         )
         assert z == 0.0
 
@@ -59,6 +59,6 @@ class TestAltmanZScoreCalculator:
             total_assets=1000.0,
             working_capital=-100.0,
             retained_earnings=-200.0,
-            average_profit=-100.0
+            average_profit=-100.0,
         )
         assert z == pytest.approx(-0.73, abs=0.01)
diff --git a/tests/modules/finance/test_double_entry.py b/tests/modules/finance/test_double_entry.py
index 84140da..d56c694 100644
--- a/tests/modules/finance/test_double_entry.py
+++ b/tests/modules/finance/test_double_entry.py
@@ -4,42 +4,67 @@ from modules.finance.system import FinanceSystem
 from modules.finance.api import InsufficientFundsError
 from simulation.models import Transaction
 
+
 # Mock objects that will be passed to FinanceSystem
 class MockGovernment:
     def __init__(self, initial_assets):
         self.id = 0
         self._assets = initial_assets
         self.sensory_data = None
+
     @property
-    def assets(self): return self._assets
+    def assets(self):
+        return self._assets
+
     def get_debt_to_gdp_ratio(self):
         return 0.5
+
     # Deprecated methods for Phase 3 but kept for interface compliance
-    def deposit(self, amount): self._assets += amount
-    def withdraw(self, amount): self._assets -= amount
+    def deposit(self, amount):
+        self._assets += amount
+
+    def withdraw(self, amount):
+        self._assets -= amount
+
 
 class MockCentralBank:
     def __init__(self, initial_cash):
         self.id = 999
         self._assets = {"cash": initial_cash, "bonds": []}
+
     @property
-    def assets(self): return self._assets
+    def assets(self):
+        return self._assets
+
     def get_base_rate(self):
         return 0.01
+
     def purchase_bonds(self, bond):
         self.assets["bonds"].append(bond)
+
     # Mocking IFinancialEntity behavior loosely
-    def deposit(self, amount): self.assets['cash'] += amount
-    def withdraw(self, amount): self.assets['cash'] -= amount
+    def deposit(self, amount):
+        self.assets["cash"] += amount
+
+    def withdraw(self, amount):
+        self.assets["cash"] -= amount
+
 
 class MockBank:
     def __init__(self, initial_assets):
         self.id = 1
         self._assets = initial_assets
+
     @property
-    def assets(self): return self._assets
-    def deposit(self, amount): self._assets += amount
-    def withdraw(self, amount): self._assets -= amount
+    def assets(self):
+        return self._assets
+
+    def deposit(self, amount):
+        self._assets += amount
+
+    def withdraw(self, amount):
+        self._assets -= amount
+
 
 class MockFirm:
     def __init__(self, id, initial_cash_reserve):
@@ -49,10 +74,17 @@ class MockFirm:
         self.finance = MagicMock()
         self.has_bailout_loan = False
         self.age = 100
+
     @property
-    def assets(self): return self.cash_reserve
-    def deposit(self, amount): self.cash_reserve += amount
-    def withdraw(self, amount): self.cash_reserve -= amount
+    def assets(self):
+        return self.cash_reserve
+
+    def deposit(self, amount):
+        self.cash_reserve += amount
+
+    def withdraw(self, amount):
+        self.cash_reserve -= amount
+
 
 class MockConfig:
     QE_INTERVENTION_YIELD_THRESHOLD = 0.05
@@ -82,7 +114,6 @@ class MockConfig:
 
 
 class TestDoubleEntry(unittest.TestCase):
-
     def setUp(self):
         self.mock_config = MockConfig()
         self.mock_gov = MockGovernment(initial_assets=10000)
@@ -94,12 +125,14 @@ class TestDoubleEntry(unittest.TestCase):
             government=self.mock_gov,
             central_bank=self.mock_cb,
             bank=self.mock_bank,
-            config_module=self.mock_config
+            config_module=self.mock_config,
         )
 
         # Mock FiscalMonitor to redirect to Gov mock method
         self.finance_system.fiscal_monitor = MagicMock()
-        self.finance_system.fiscal_monitor.get_debt_to_gdp_ratio.side_effect = lambda gov, dto: gov.get_debt_to_gdp_ratio()
+        self.finance_system.fiscal_monitor.get_debt_to_gdp_ratio.side_effect = (
+            lambda gov, dto: gov.get_debt_to_gdp_ratio()
+        )
 
     def test_bailout_loan_generates_transaction(self):
         """
@@ -110,7 +143,9 @@ class TestDoubleEntry(unittest.TestCase):
         initial_firm_cash = self.mock_firm.cash_reserve
         bailout_amount = 500
 
-        loan, txs = self.finance_system.grant_bailout_loan(self.mock_firm, bailout_amount, current_tick=1)
+        loan, txs = self.finance_system.grant_bailout_loan(
+            self.mock_firm, bailout_amount, current_tick=1
+        )
 
         # Assertions
         # Assets Unchanged
@@ -136,20 +171,22 @@ class TestDoubleEntry(unittest.TestCase):
         self.mock_gov.get_debt_to_gdp_ratio = lambda: 1.5
 
         initial_gov_assets = self.mock_gov.assets
-        initial_cb_cash = self.mock_cb.assets['cash']
+        initial_cb_cash = self.mock_cb.assets["cash"]
         bond_amount = 1000
 
-        bonds, txs = self.finance_system.issue_treasury_bonds(bond_amount, current_tick=1)
+        bonds, txs = self.finance_system.issue_treasury_bonds(
+            bond_amount, current_tick=1
+        )
 
         # Assertions
         # Assets Unchanged
         self.assertEqual(self.mock_gov.assets, initial_gov_assets)
-        self.assertEqual(self.mock_cb.assets['cash'], initial_cb_cash)
+        self.assertEqual(self.mock_cb.assets["cash"], initial_cb_cash)
 
         # Transaction Generated (Buyer -> Gov)
         self.assertEqual(len(txs), 1)
         tx = txs[0]
-        self.assertEqual(tx.buyer_id, self.mock_cb.id) # Central Bank buys
+        self.assertEqual(tx.buyer_id, self.mock_cb.id)  # Central Bank buys
         self.assertEqual(tx.seller_id, self.mock_gov.id)
         self.assertEqual(tx.price, bond_amount)
 
@@ -164,7 +201,9 @@ class TestDoubleEntry(unittest.TestCase):
         initial_bank_assets = self.mock_bank.assets
         bond_amount = 2000
 
-        bonds, txs = self.finance_system.issue_treasury_bonds(bond_amount, current_tick=1)
+        bonds, txs = self.finance_system.issue_treasury_bonds(
+            bond_amount, current_tick=1
+        )
 
         # Assertions
         self.assertEqual(self.mock_gov.assets, initial_gov_assets)
@@ -172,9 +211,10 @@ class TestDoubleEntry(unittest.TestCase):
 
         self.assertEqual(len(txs), 1)
         tx = txs[0]
-        self.assertEqual(tx.buyer_id, self.mock_bank.id) # Bank buys
+        self.assertEqual(tx.buyer_id, self.mock_bank.id)  # Bank buys
         self.assertEqual(tx.seller_id, self.mock_gov.id)
         self.assertEqual(tx.price, bond_amount)
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     unittest.main()
diff --git a/tests/modules/finance/test_sovereign_debt.py b/tests/modules/finance/test_sovereign_debt.py
index f84d933..c6a014c 100644
--- a/tests/modules/finance/test_sovereign_debt.py
+++ b/tests/modules/finance/test_sovereign_debt.py
@@ -6,6 +6,7 @@ from simulation.agents.government import Government
 from simulation.firms import Firm
 from modules.analysis.fiscal_monitor import FiscalMonitor
 
+
 class TestSovereignDebt:
     @pytest.fixture
     def setup_system(self):
@@ -19,11 +20,13 @@ class TestSovereignDebt:
         self.bank.withdraw = MagicMock()
 
         self.config = MagicMock()
+
         # Mock config.get properly
         def config_get(key, default=None):
             if "RISK_PREMIUM" in key:
-                 return {1.2: 0.05, 0.9: 0.02}
+                return {1.2: 0.05, 0.9: 0.02}
             return default
+
         self.config.get.side_effect = config_get
 
         self.settlement_system = MagicMock()
@@ -34,10 +37,12 @@ class TestSovereignDebt:
             central_bank=self.central_bank,
             bank=self.bank,
             config_module=self.config,
-            settlement_system=self.settlement_system
+            settlement_system=self.settlement_system,
         )
         self.finance_system.fiscal_monitor = MagicMock(spec=FiscalMonitor)
-        self.finance_system.fiscal_monitor.get_debt_to_gdp_ratio.return_value = 0.5 # Safe
+        self.finance_system.fiscal_monitor.get_debt_to_gdp_ratio.return_value = (
+            0.5  # Safe
+        )
 
         return self.finance_system
 
@@ -54,9 +59,9 @@ class TestSovereignDebt:
         # Should transfer from Bank to Govt
         fs.settlement_system.transfer.assert_called_once()
         args = fs.settlement_system.transfer.call_args
-        assert args[0][0] == fs.bank # Debtor
-        assert args[0][1] == fs.government # Creditor
-        assert args[0][2] == 100.0 # Amount
+        assert args[0][0] == fs.bank  # Debtor
+        assert args[0][1] == fs.government  # Creditor
+        assert args[0][2] == 100.0  # Amount
 
     def test_collect_corporate_tax_calls_settlement_system(self, setup_system):
         fs = setup_system
@@ -68,8 +73,8 @@ class TestSovereignDebt:
         assert success is True
         fs.settlement_system.transfer.assert_called_once()
         args = fs.settlement_system.transfer.call_args
-        assert args[0][0] == firm # Debtor
-        assert args[0][1] == fs.government # Creditor
+        assert args[0][0] == firm  # Debtor
+        assert args[0][1] == fs.government  # Creditor
         assert args[0][2] == 50.0
 
     def test_risk_premium_calculation(self, setup_system):
@@ -86,7 +91,7 @@ class TestSovereignDebt:
     def test_insufficient_funds_fails_issuance(self, setup_system):
         fs = setup_system
         fs.central_bank.get_base_rate.return_value = 0.05
-        fs.bank.assets = 0.0 # Bank has no money
+        fs.bank.assets = 0.0  # Bank has no money
 
         bonds = fs.issue_treasury_bonds(100.0, 1)
 
diff --git a/tests/modules/finance/test_system.py b/tests/modules/finance/test_system.py
index 58ffc5f..34d26f7 100644
--- a/tests/modules/finance/test_system.py
+++ b/tests/modules/finance/test_system.py
@@ -3,6 +3,7 @@ from unittest.mock import Mock, MagicMock
 from modules.finance.system import FinanceSystem
 from modules.finance.api import InsufficientFundsError
 
+
 @pytest.fixture
 def mock_config():
     config = Mock()
@@ -20,58 +21,78 @@ def mock_config():
     config.TICKS_PER_YEAR = 48
     return config
 
+
 # Define simple stub classes for entity behavior
 class StubGovernment:
     def __init__(self, assets=10000.0):
         self._assets = assets
         self.debt_to_gdp_ratio = 0.5
+
     def get_debt_to_gdp_ratio(self):
         return self.debt_to_gdp_ratio
-    def deposit(self, amount): self._assets += amount
+
+    def deposit(self, amount):
+        self._assets += amount
+
     def withdraw(self, amount):
         if self.assets < amount:
             raise InsufficientFundsError()
         self._assets -= amount
 
+
 class StubCentralBank:
     def __init__(self, cash=50000.0):
-        self._assets = {'cash': cash, 'bonds': []}
+        self._assets = {"cash": cash, "bonds": []}
         self.base_rate = 0.02
+
     def get_base_rate(self):
         return self.base_rate
+
     def purchase_bonds(self, bond):
-        self.assets['bonds'].append(bond)
-    def deposit(self, amount): self.assets['cash'] += amount
+        self.assets["bonds"].append(bond)
+
+    def deposit(self, amount):
+        self.assets["cash"] += amount
+
     def withdraw(self, amount):
-        if self.assets['cash'] < amount:
+        if self.assets["cash"] < amount:
             raise InsufficientFundsError()
-        self.assets['cash'] -= amount
+        self.assets["cash"] -= amount
+
 
 class StubBank:
     def __init__(self, assets=100000.0):
         self._assets = assets
-    def deposit(self, amount): self._assets += amount
+
+    def deposit(self, amount):
+        self._assets += amount
+
     def withdraw(self, amount):
         if self.assets < amount:
             raise InsufficientFundsError()
         self._assets -= amount
 
+
 @pytest.fixture
 def mock_government():
     return StubGovernment()
 
+
 @pytest.fixture
 def mock_central_bank():
     return StubCentralBank()
 
+
 @pytest.fixture
 def mock_bank():
     return StubBank()
 
+
 @pytest.fixture
 def finance_system(mock_government, mock_central_bank, mock_bank, mock_config):
     return FinanceSystem(mock_government, mock_central_bank, mock_bank, mock_config)
 
+
 class StubFirm:
     def __init__(self):
         self.id = 1
@@ -96,30 +117,37 @@ class StubFirm:
     def get_inventory_value(self):
         return 0.0
 
-    def deposit(self, amount): self.cash_reserve += amount
+    def deposit(self, amount):
+        self.cash_reserve += amount
+
     def withdraw(self, amount):
         if self.cash_reserve < amount:
             raise InsufficientFundsError()
         self.cash_reserve -= amount
 
+
 @pytest.fixture
 def mock_firm():
     return StubFirm()
 
+
 def test_evaluate_solvency_startup_pass(finance_system, mock_firm):
     mock_firm.age = 10
     # Fix: Required runway is 3 * (1000 * 4) = 12000. Set cash reserve to match.
     mock_firm.cash_reserve = 12000.0
     assert finance_system.evaluate_solvency(mock_firm, 100) is True
 
+
 def test_evaluate_solvency_startup_fail(finance_system, mock_firm):
     mock_firm.age = 10
     mock_firm.cash_reserve = 1000.0
     assert finance_system.evaluate_solvency(mock_firm, 100) is False
 
+
 def test_evaluate_solvency_established_pass(finance_system, mock_firm):
     assert finance_system.evaluate_solvency(mock_firm, 100) is True
 
+
 def test_evaluate_solvency_established_fail(finance_system, mock_firm):
     # Set values to produce a low Z-Score
     # WC = 10000 (X1=1.0) -> 1.2
@@ -130,6 +158,7 @@ def test_evaluate_solvency_established_fail(finance_system, mock_firm):
     mock_firm.finance.profit_history = []
     assert finance_system.evaluate_solvency(mock_firm, 100) is False
 
+
 def test_issue_treasury_bonds_market(finance_system, mock_government, mock_bank):
     amount = 1000.0
     initial_bank_assets = mock_bank.assets
@@ -139,6 +168,7 @@ def test_issue_treasury_bonds_market(finance_system, mock_government, mock_bank)
     assert mock_bank.assets == initial_bank_assets - amount
     assert mock_government.assets == initial_gov_assets + amount
 
+
 def test_issue_treasury_bonds_qe(finance_system, mock_government, mock_central_bank):
     mock_government.debt_to_gdp_ratio = 1.5
     # Fix: The yield rate (base + risk premium) must exceed the QE threshold.
@@ -147,19 +177,23 @@ def test_issue_treasury_bonds_qe(finance_system, mock_government, mock_central_b
     mock_central_bank.base_rate = 0.06
     amount = 1000.0
     initial_gov_assets = mock_government.assets
-    initial_cb_cash = mock_central_bank.assets['cash']
+    initial_cb_cash = mock_central_bank.assets["cash"]
     bonds = finance_system.issue_treasury_bonds(amount, 100)
     assert len(bonds) == 1
-    assert len(mock_central_bank.assets['bonds']) == 1
+    assert len(mock_central_bank.assets["bonds"]) == 1
     assert mock_government.assets == initial_gov_assets + amount
-    assert mock_central_bank.assets['cash'] == initial_cb_cash - amount
+    assert mock_central_bank.assets["cash"] == initial_cb_cash - amount
+
 
 def test_issue_treasury_bonds_fail(finance_system, mock_government, mock_bank):
-    amount = 200000.0 # More than the bank's assets
+    amount = 200000.0  # More than the bank's assets
     bonds = finance_system.issue_treasury_bonds(amount, 100)
     assert len(bonds) == 0
 
-def test_bailout_fails_with_insufficient_government_funds(finance_system, mock_government, mock_firm):
+
+def test_bailout_fails_with_insufficient_government_funds(
+    finance_system, mock_government, mock_firm
+):
     """Verify that a bailout loan is not granted if the government cannot afford it."""
     mock_government._assets = 100.0  # Not enough for the bailout
     amount = 500.0
@@ -174,6 +208,7 @@ def test_bailout_fails_with_insufficient_government_funds(finance_system, mock_g
     assert mock_firm.cash_reserve == initial_firm_cash
     assert not mock_firm.has_bailout_loan
 
+
 def test_grant_bailout_loan(finance_system, mock_government, mock_firm, mock_config):
     amount = 5000.0
     initial_gov_assets = mock_government.assets
@@ -186,7 +221,10 @@ def test_grant_bailout_loan(finance_system, mock_government, mock_firm, mock_con
     assert mock_firm.cash_reserve == initial_firm_cash + amount
     mock_firm.finance.add_liability.assert_called_once_with(amount, loan.interest_rate)
 
-def test_service_debt_central_bank_repayment(finance_system, mock_government, mock_central_bank, mock_config):
+
+def test_service_debt_central_bank_repayment(
+    finance_system, mock_government, mock_central_bank, mock_config
+):
     """
     Verify that when a bond held by the Central Bank matures, the repayment
     is correctly credited to the Central Bank's assets, preventing the
diff --git a/tests/modules/household/test_econ_component.py b/tests/modules/household/test_econ_component.py
index 7c70d54..f38a662 100644
--- a/tests/modules/household/test_econ_component.py
+++ b/tests/modules/household/test_econ_component.py
@@ -4,13 +4,14 @@ from collections import deque
 from modules.household.econ_component import EconComponent
 from simulation.ai.api import Personality
 
+
 class TestEconComponent:
     @pytest.fixture
     def mock_owner(self):
         owner = MagicMock()
         owner.goods_info_map = {
             "food": {"id": "food", "initial_price": 10.0},
-            "water": {"id": "water", "initial_price": 5.0}
+            "water": {"id": "water", "initial_price": 5.0},
         }
         owner.personality = Personality.CONSERVATIVE
         owner.logger = MagicMock()
@@ -33,11 +34,7 @@ class TestEconComponent:
         econ.expected_inflation["food"] = 0.0
         econ.perceived_avg_prices["food"] = 10.0
 
-        market_data = {
-            "goods_market": {
-                "food_avg_traded_price": 11.0
-            }
-        }
+        market_data = {"goods_market": {"food_avg_traded_price": 11.0}}
 
         econ.update_perceived_prices(market_data)
 
@@ -56,7 +53,9 @@ class TestEconComponent:
 
     def test_update_perceived_prices_hyperinflation(self, mock_owner, mock_config):
         econ = EconComponent(mock_owner, mock_config)
-        econ.adaptation_rate = 0.2 # Force a rate override just to be sure, or rely on init
+        econ.adaptation_rate = (
+            0.2  # Force a rate override just to be sure, or rely on init
+        )
 
         # Override adaptation rate logic for test isolation or rely on mock_owner having CONSERVATIVE (0.1)
         # But here let's assume we want to test the multiplier logic.
@@ -67,15 +66,11 @@ class TestEconComponent:
         econ.price_history["food"].append(100.0)
         econ.expected_inflation["food"] = 0.05
 
-        market_data = {
-            "goods_market": {
-                "food_avg_traded_price": 120.0
-            }
-        }
+        market_data = {"goods_market": {"food_avg_traded_price": 120.0}}
 
         stress_config = MagicMock()
         stress_config.is_active = True
-        stress_config.scenario_name = 'hyperinflation'
+        stress_config.scenario_name = "hyperinflation"
         stress_config.inflation_expectation_multiplier = 2.0
 
         econ.update_perceived_prices(market_data, stress_scenario_config=stress_config)
diff --git a/tests/phase21/test_automation.py b/tests/phase21/test_automation.py
index d970104..4563539 100644
--- a/tests/phase21/test_automation.py
+++ b/tests/phase21/test_automation.py
@@ -3,7 +3,8 @@ from unittest.mock import Mock, MagicMock
 from simulation.firms import Firm
 from simulation.ai.firm_system2_planner import FirmSystem2Planner
 from simulation.ai.enums import Personality
-import config # Import from root
+import config  # Import from root
+
 
 @pytest.fixture
 def firm_mock():
@@ -20,19 +21,21 @@ def firm_mock():
         productivity_factor=10.0,
         decision_engine=decision_engine,
         value_orientation="growth",
-        config_module=config
+        config_module=config,
     )
     return firm
 
+
 def test_firm_automation_init(firm_mock):
     """Test if automation_level initializes correctly."""
     assert firm_mock.automation_level == 0.0
     assert firm_mock.system2_planner is None
 
+
 def test_production_function_with_automation(firm_mock):
     """Test modified Cobb-Douglas production function."""
     # Setup
-    firm_mock.employees = [Mock(labor_skill=1.0)] # 1 Employee
+    firm_mock.employees = [Mock(labor_skill=1.0)]  # 1 Employee
     firm_mock.capital_stock = 100.0
     firm_mock.productivity_factor = 10.0
     firm_mock.config_module.LABOR_ALPHA = 0.5
@@ -58,20 +61,21 @@ def test_production_function_with_automation(firm_mock):
     firm_mock.produce(current_time=2)
     prod_full = firm_mock.current_production
 
-    assert prod_full > prod_zero # Automation helps when Capital is abundant
+    assert prod_full > prod_zero  # Automation helps when Capital is abundant
     assert prod_full > 310.0
 
+
 def test_system2_planner_guidance(firm_mock):
     """Test System 2 Planner logic."""
     # Override config for this test to make automation cheaper
-    firm_mock.config_module.AUTOMATION_COST_PER_PCT = 100.0 # Was 1000.0
+    firm_mock.config_module.AUTOMATION_COST_PER_PCT = 100.0  # Was 1000.0
 
     firm_mock.system2_planner = FirmSystem2Planner(firm_mock, firm_mock.config_module)
 
     # Mock Data
     market_data = {}
     firm_mock.revenue_this_turn = 5000.0
-    firm_mock._assets = 300000.0 # Rich firm (Needs to be > 50 * Revenue = 250k)
+    firm_mock._assets = 300000.0  # Rich firm (Needs to be > 50 * Revenue = 250k)
 
     # High wages to justify automation
     firm_mock.employee_wages = {1: 1000.0, 2: 1000.0}
diff --git a/tests/phase21/test_firm_system2.py b/tests/phase21/test_firm_system2.py
index b144074..985f046 100644
--- a/tests/phase21/test_firm_system2.py
+++ b/tests/phase21/test_firm_system2.py
@@ -3,7 +3,8 @@ from unittest.mock import Mock, MagicMock
 from simulation.firms import Firm
 from simulation.ai.firm_system2_planner import FirmSystem2Planner
 from simulation.ai.enums import Personality
-import config # Import from root
+import config  # Import from root
+
 
 @pytest.fixture
 def firm_mock():
@@ -20,10 +21,11 @@ def firm_mock():
         productivity_factor=10.0,
         decision_engine=decision_engine,
         value_orientation="growth",
-        config_module=config
+        config_module=config,
     )
     return firm
 
+
 def test_system2_planner_guidance_automation_preference(firm_mock):
     """Test that CASH_COW prefers automation when profitable."""
     # Setup cheap automation scenario
@@ -38,6 +40,7 @@ def test_system2_planner_guidance_automation_preference(firm_mock):
     guidance = firm_mock.system2_planner.project_future(1, {})
     assert guidance["target_automation"] > 0.0
 
+
 def test_system2_planner_guidance_ma_preference(firm_mock):
     """Test that GROWTH_HACKER prefers M&A when rich."""
     firm_mock._assets = 1000000.0
diff --git a/tests/phase28/test_stress_scenarios.py b/tests/phase28/test_stress_scenarios.py
index af004bc..309a585 100644
--- a/tests/phase28/test_stress_scenarios.py
+++ b/tests/phase28/test_stress_scenarios.py
@@ -1,4 +1,3 @@
-
 import pytest
 from unittest.mock import MagicMock, patch
 from simulation.systems.event_system import EventSystem
@@ -7,8 +6,8 @@ from simulation.dtos.scenario import StressScenarioConfig
 from simulation.core_agents import Household, Personality
 from simulation.systems.api import EventContext, CommerceContext
 
-class TestPhase28StressScenarios:
 
+class TestPhase28StressScenarios:
     @pytest.fixture
     def mock_households(self):
         h1 = MagicMock(spec=Household)
@@ -25,7 +24,7 @@ class TestPhase28StressScenarios:
 
         h2 = MagicMock(spec=Household)
         h2.id = 2
-        h2._assets = 5000.0 # Wealthy
+        h2._assets = 5000.0  # Wealthy
         h2.is_active = True
 
         return [h1, h2]
@@ -56,15 +55,15 @@ class TestPhase28StressScenarios:
         """Verify Cash Injection Trigger"""
         config = StressScenarioConfig(
             is_active=True,
-            scenario_name='hyperinflation',
+            scenario_name="hyperinflation",
             start_tick=10,
-            demand_shock_cash_injection=0.5
+            demand_shock_cash_injection=0.5,
         )
 
         context: EventContext = {
             "households": mock_households,
             "firms": mock_firms,
-            "markets": {}
+            "markets": {},
         }
 
         # Trigger event
@@ -97,15 +96,15 @@ class TestPhase28StressScenarios:
         """Verify Asset Reduction Trigger"""
         config = StressScenarioConfig(
             is_active=True,
-            scenario_name='deflation',
+            scenario_name="deflation",
             start_tick=20,
-            asset_shock_reduction=0.2
+            asset_shock_reduction=0.2,
         )
 
         context: EventContext = {
             "households": mock_households,
             "firms": mock_firms,
-            "markets": {}
+            "markets": {},
         }
 
         event_system.execute_scheduled_events(20, context, config)
@@ -119,17 +118,17 @@ class TestPhase28StressScenarios:
         """Verify Consumption Collapse for Unemployed"""
         config = StressScenarioConfig(
             is_active=True,
-            scenario_name='deflation',
-            consumption_pessimism_factor=0.3 # 30% reduction
+            scenario_name="deflation",
+            consumption_pessimism_factor=0.3,  # 30% reduction
         )
 
         # Setup Breeding Planner Mock to return consumption decisions
         planner = MagicMock()
         # Returns dict with lists matching household indices
         planner.decide_consumption_batch.return_value = {
-            'consume': [10.0, 10.0],
-            'buy': [0.0, 0.0],
-            'price': 1.0
+            "consume": [10.0, 10.0],
+            "buy": [0.0, 0.0],
+            "price": 1.0,
         }
 
         # Household 1: Unemployed -> Should be reduced
@@ -145,7 +144,7 @@ class TestPhase28StressScenarios:
             "reflux_system": MagicMock(),
             "market_data": {},
             "config": MagicMock(),
-            "time": 100
+            "time": 100,
         }
 
         commerce_system.execute_consumption_and_leisure(context, config)
@@ -161,16 +160,12 @@ class TestPhase28StressScenarios:
     def test_supply_shock(self, event_system, mock_firms):
         config = StressScenarioConfig(
             is_active=True,
-            scenario_name='supply_shock',
+            scenario_name="supply_shock",
             start_tick=30,
-            exogenous_productivity_shock={"Farm": 0.5}
+            exogenous_productivity_shock={"Farm": 0.5},
         )
 
-        context: EventContext = {
-            "households": [],
-            "firms": mock_firms,
-            "markets": {}
-        }
+        context: EventContext = {"households": [], "firms": mock_firms, "markets": {}}
 
         event_system.execute_scheduled_events(30, context, config)
 
@@ -190,20 +185,18 @@ class TestPhase28StressScenarios:
             id=1,
             talent=MagicMock(),
             goods_data=[],
-            initial_assets=400.0, # Below threshold
+            initial_assets=400.0,  # Below threshold
             initial_needs={},
             decision_engine=MagicMock(),
             value_orientation="wealth_and_needs",
             personality=Personality.CONSERVATIVE,
-            config_module=config_module
+            config_module=config_module,
         )
         household.portfolio = MagicMock()
-        household.portfolio.holdings = {101: 10.0} # Owns 10 shares of firm 101
+        household.portfolio.holdings = {101: 10.0}  # Owns 10 shares of firm 101
 
         stress_config = StressScenarioConfig(
-            is_active=True,
-            scenario_name='deflation',
-            panic_selling_enabled=True
+            is_active=True, scenario_name="deflation", panic_selling_enabled=True
         )
 
         # Act
@@ -211,9 +204,14 @@ class TestPhase28StressScenarios:
         markets = {}
         # We don't need detailed markets as we are testing order generation logic in Household.make_decision wrapper
         # Household.make_decision calls decision_engine.make_decisions first.
-        household.decision_engine.make_decisions.return_value = ([], None) # Normal engine returns nothing
+        household.decision_engine.make_decisions.return_value = (
+            [],
+            None,
+        )  # Normal engine returns nothing
 
-        orders, _ = household.make_decision(markets, [], {}, 100, stress_scenario_config=stress_config)
+        orders, _ = household.make_decision(
+            markets, [], {}, 100, stress_scenario_config=stress_config
+        )
 
         # Assert
         assert len(orders) == 1
@@ -221,7 +219,7 @@ class TestPhase28StressScenarios:
         assert order.order_type == "SELL"
         assert order.item_id == "stock_101"
         assert order.quantity == 10.0
-        assert order.price == 0.0 # Market sell
+        assert order.price == 0.0  # Market sell
 
     def test_hoarding_amplification(self):
         """Verify Hoarding amplifies buy quantity."""
@@ -230,7 +228,7 @@ class TestPhase28StressScenarios:
         config_module.GOODS = {"basic_food": {"utility_effects": {"survival": 10}}}
         config_module.HOUSEHOLD_CONSUMABLE_GOODS = ["basic_food"]
         config_module.HOUSEHOLD_MAX_PURCHASE_QUANTITY = 5.0
-        config_module.BULK_BUY_NEED_THRESHOLD = 1000.0 # Don't trigger normal bulk buy
+        config_module.BULK_BUY_NEED_THRESHOLD = 1000.0  # Don't trigger normal bulk buy
         config_module.BULK_BUY_AGG_THRESHOLD = 1.0
         config_module.MIN_PURCHASE_QUANTITY = 0.1
         config_module.BUDGET_LIMIT_NORMAL_RATIO = 1.0
@@ -249,12 +247,15 @@ class TestPhase28StressScenarios:
         config_module.WAGE_RECOVERY_RATE = 0.01
 
         # Import real engine for logic test
-        from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
+        from simulation.decisions.ai_driven_household_engine import (
+            AIDrivenHouseholdDecisionEngine,
+        )
         from simulation.dtos import DecisionContext
 
         ai_engine = MagicMock()
         # Return aggressive consumption
         from simulation.schemas import HouseholdActionVector
+
         vector = HouseholdActionVector()
         vector.consumption_aggressiveness = {"basic_food": 0.5}
         ai_engine.decide_action_vector.return_value = vector
@@ -267,12 +268,12 @@ class TestPhase28StressScenarios:
         household.inventory = {}
         household.needs = {"survival": 50.0}
         household.get_agent_data.return_value = {}
-        household.expected_inflation = {} # Empty dict
+        household.expected_inflation = {}  # Empty dict
         household.preference_asset = 1.0
         household.preference_social = 1.0
         household.preference_growth = 1.0
         household.current_wage = 10.0
-        household.wage_modifier = 1.0 # Fix TypeError in min() comparison
+        household.wage_modifier = 1.0  # Fix TypeError in min() comparison
         # Fix ZeroDivisionError in _calculate_savings_roi
         # Mocks can be truthy but empty. Explicitly set to empty dict which is falsy in bool context?
         # No, Mock objects are truthy.
@@ -282,8 +283,8 @@ class TestPhase28StressScenarios:
 
         stress_config = StressScenarioConfig(
             is_active=True,
-            scenario_name='hyperinflation',
-            hoarding_propensity_factor=0.5 # 50% more
+            scenario_name="hyperinflation",
+            hoarding_propensity_factor=0.5,  # 50% more
         )
 
         context = DecisionContext(
@@ -292,7 +293,7 @@ class TestPhase28StressScenarios:
             goods_data=[],
             market_data={"goods_market": {"basic_food_current_sell_price": 5.0}},
             current_time=100,
-            stress_scenario_config=stress_config
+            stress_scenario_config=stress_config,
         )
 
         # Act
@@ -320,7 +321,9 @@ class TestPhase28StressScenarios:
         config_module.DEBT_LIQUIDITY_RATIO = 0.9
         config_module.DSR_CRITICAL_THRESHOLD = 1.0
 
-        from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
+        from simulation.decisions.ai_driven_household_engine import (
+            AIDrivenHouseholdDecisionEngine,
+        )
         from simulation.dtos import DecisionContext
         from simulation.schemas import HouseholdActionVector
 
@@ -335,24 +338,22 @@ class TestPhase28StressScenarios:
         household = MagicMock()
         household.id = 1
         household._assets = 1000.0
-        household.current_wage = 10.0 # Fix TypeError
-        household.preference_asset = 1.0 # Fix
-        household.expected_inflation = {} # Avoid ZeroDivisionError
-        household.wage_modifier = 1.0 # Fix TypeError
-        household.wage_modifier = 1.0 # Fix TypeError
+        household.current_wage = 10.0  # Fix TypeError
+        household.preference_asset = 1.0  # Fix
+        household.expected_inflation = {}  # Avoid ZeroDivisionError
+        household.wage_modifier = 1.0  # Fix TypeError
+        household.wage_modifier = 1.0  # Fix TypeError
 
         stress_config = StressScenarioConfig(
             is_active=True,
-            scenario_name='deflation',
-            debt_aversion_multiplier=2.0 # Double priority
+            scenario_name="deflation",
+            debt_aversion_multiplier=2.0,  # Double priority
         )
 
         # Market data with debt
         market_data = {
-            "debt_data": {
-                1: {"total_principal": 500.0}
-            },
-            "loan_market": {"interest_rate": 0.05}
+            "debt_data": {1: {"total_principal": 500.0}},
+            "loan_market": {"interest_rate": 0.05},
         }
 
         context = DecisionContext(
@@ -361,7 +362,7 @@ class TestPhase28StressScenarios:
             goods_data=[],
             market_data=market_data,
             current_time=100,
-            stress_scenario_config=stress_config
+            stress_scenario_config=stress_config,
         )
 
         # Act
diff --git a/tests/systems/test_commerce_system.py b/tests/systems/test_commerce_system.py
index 971704d..2b0e6a8 100644
--- a/tests/systems/test_commerce_system.py
+++ b/tests/systems/test_commerce_system.py
@@ -3,6 +3,7 @@ from unittest.mock import MagicMock
 from simulation.systems.commerce_system import CommerceSystem
 from simulation.systems.api import CommerceContext
 
+
 @pytest.fixture
 def commerce_system():
     config = MagicMock()
@@ -11,6 +12,7 @@ def commerce_system():
     reflux_system = MagicMock()
     return CommerceSystem(config, reflux_system)
 
+
 def test_execute_consumption_and_leisure(commerce_system):
     # Setup Households
     h1 = MagicMock()
@@ -32,7 +34,7 @@ def test_execute_consumption_and_leisure(commerce_system):
     planner.decide_consumption_batch.return_value = {
         "consume": [1.0],
         "buy": [2.0],
-        "price": 10.0
+        "price": 10.0,
     }
 
     # Mock Context
@@ -43,7 +45,7 @@ def test_execute_consumption_and_leisure(commerce_system):
         "reflux_system": commerce_system.reflux_system,
         "market_data": {},
         "config": commerce_system.config,
-        "time": 1
+        "time": 1,
     }
 
     # Execute
@@ -51,14 +53,14 @@ def test_execute_consumption_and_leisure(commerce_system):
 
     # Verify
     # 1. Purchase: Buy 2.0 @ 10.0 = 20.0 cost
-    assert h1.assets == 80.0 # 100 - 20
+    assert h1.assets == 80.0  # 100 - 20
     assert h1.inventory["basic_food"] == 2.0
 
     # 2. Consumption: Consume 1.0 (Fast Consumption)
     h1.consume.assert_called_with("basic_food", 1.0, 1)
 
     # 3. Leisure
-    h1.apply_leisure_effect.assert_called_with(8.0, {'basic_food': 1.0})
+    h1.apply_leisure_effect.assert_called_with(8.0, {"basic_food": 1.0})
 
     # 4. Return Value
     assert leisure_effects[1] == 5.0
@@ -67,7 +69,10 @@ def test_execute_consumption_and_leisure(commerce_system):
     h1.update_needs.assert_called_once()
 
     # 6. Reflux Capture
-    commerce_system.reflux_system.capture.assert_called_with(20.0, source="Household_1", category="emergency_food")
+    commerce_system.reflux_system.capture.assert_called_with(
+        20.0, source="Household_1", category="emergency_food"
+    )
+
 
 def test_fast_track_consumption_if_needed(commerce_system):
     # Case: Inventory 0, Consumes 0 (in vector), Buys 2.
@@ -85,9 +90,9 @@ def test_fast_track_consumption_if_needed(commerce_system):
 
     planner = MagicMock()
     planner.decide_consumption_batch.return_value = {
-        "consume": [0.0], # Planner says consume 0 because inventory was 0
+        "consume": [0.0],  # Planner says consume 0 because inventory was 0
         "buy": [2.0],
-        "price": 10.0
+        "price": 10.0,
     }
 
     context: CommerceContext = {
@@ -97,7 +102,7 @@ def test_fast_track_consumption_if_needed(commerce_system):
         "reflux_system": commerce_system.reflux_system,
         "market_data": {},
         "config": commerce_system.config,
-        "time": 1
+        "time": 1,
     }
 
     commerce_system.execute_consumption_and_leisure(context)
diff --git a/tests/systems/test_event_system.py b/tests/systems/test_event_system.py
index 574c8e0..1c294e8 100644
--- a/tests/systems/test_event_system.py
+++ b/tests/systems/test_event_system.py
@@ -3,11 +3,13 @@ from unittest.mock import MagicMock
 from simulation.systems.event_system import EventSystem
 from simulation.systems.api import EventContext
 
+
 @pytest.fixture
 def event_system():
     config = MagicMock()
     return EventSystem(config)
 
+
 def test_inflation_shock(event_system):
     # Setup
     market = MagicMock()
@@ -15,11 +17,7 @@ def test_inflation_shock(event_system):
     market.avg_price = 100.0
     markets = {"goods": market}
 
-    context: EventContext = {
-        "markets": markets,
-        "households": [],
-        "firms": []
-    }
+    context: EventContext = {"markets": markets, "households": [], "firms": []}
 
     # Execute Tick 200
     event_system.execute_scheduled_events(200, context)
@@ -28,17 +26,14 @@ def test_inflation_shock(event_system):
     assert market.current_price == 150.0
     assert market.avg_price == 150.0
 
+
 def test_recession_shock(event_system):
     # Setup
     h1 = MagicMock()
     h1._assets = 1000.0
     households = [h1]
 
-    context: EventContext = {
-        "markets": {},
-        "households": households,
-        "firms": []
-    }
+    context: EventContext = {"markets": {}, "households": households, "firms": []}
 
     # Execute Tick 600
     event_system.execute_scheduled_events(600, context)
@@ -46,6 +41,7 @@ def test_recession_shock(event_system):
     # Verify
     assert h1.assets == 500.0
 
+
 def test_no_event(event_system):
     # Setup
     h1 = MagicMock()
@@ -56,7 +52,7 @@ def test_no_event(event_system):
     context: EventContext = {
         "markets": {"goods": market},
         "households": [h1],
-        "firms": []
+        "firms": [],
     }
 
     # Execute Tick 100 (No event)
diff --git a/tests/systems/test_labor_market_analyzer.py b/tests/systems/test_labor_market_analyzer.py
index e98cc0a..a2158a2 100644
--- a/tests/systems/test_labor_market_analyzer.py
+++ b/tests/systems/test_labor_market_analyzer.py
@@ -2,19 +2,20 @@ import pytest
 from unittest.mock import MagicMock
 from simulation.systems.labor_market_analyzer import LaborMarketAnalyzer
 
+
 @pytest.fixture
 def analyzer():
     config = MagicMock()
     config.HOUSEHOLD_MIN_WAGE_DEMAND = 6.0
     return LaborMarketAnalyzer(config)
 
+
 def test_update_market_history(analyzer):
-    market_data = {
-        "labor": {"avg_wage": 15.0}
-    }
+    market_data = {"labor": {"avg_wage": 15.0}}
     analyzer.update_market_history(market_data)
     assert analyzer.market_wage_history[-1] == 15.0
 
+
 def test_calculate_shadow_reservation_wage_increase(analyzer):
     # Employed agent, Wage < Shadow? No, usually Wage > Shadow pulls it up.
     # Logic: new = old * 0.95 + target * 0.05
@@ -31,6 +32,7 @@ def test_calculate_shadow_reservation_wage_increase(analyzer):
     new_wage = analyzer.calculate_shadow_reservation_wage(agent, {})
     assert abs(new_wage - 10.5) < 0.001
 
+
 def test_calculate_shadow_reservation_wage_decay(analyzer):
     # Unemployed agent
     # Logic: new = old * 0.98
@@ -44,6 +46,7 @@ def test_calculate_shadow_reservation_wage_decay(analyzer):
     # 10 * 0.98 = 9.8
     assert abs(new_wage - 9.8) < 0.001
 
+
 def test_calculate_shadow_reservation_wage_floor(analyzer):
     agent = MagicMock()
     agent.is_employed = False
diff --git a/tests/systems/test_ministry_of_education.py b/tests/systems/test_ministry_of_education.py
index 99238e9..b007d96 100644
--- a/tests/systems/test_ministry_of_education.py
+++ b/tests/systems/test_ministry_of_education.py
@@ -2,8 +2,8 @@ import unittest
 from unittest.mock import Mock, MagicMock
 from simulation.systems.ministry_of_education import MinistryOfEducation
 
-class TestMinistryOfEducation(unittest.TestCase):
 
+class TestMinistryOfEducation(unittest.TestCase):
     def setUp(self):
         self.mock_config = Mock()
         self.mock_config.PUBLIC_EDU_BUDGET_RATIO = 0.10
@@ -15,7 +15,9 @@ class TestMinistryOfEducation(unittest.TestCase):
 
         self.mock_government = MagicMock()
         self.mock_government._assets = 10000
-        self.mock_government.revenue_this_tick = 10000  # Simulate 10k revenue for budget calcs
+        self.mock_government.revenue_this_tick = (
+            10000  # Simulate 10k revenue for budget calcs
+        )
         self.mock_government.id = 1
         self.mock_government.expenditure_this_tick = 0
         self.mock_government.total_money_issued = 0
@@ -33,34 +35,40 @@ class TestMinistryOfEducation(unittest.TestCase):
 
     def test_run_public_education_basic_grant(self):
         households = [
-            self._create_household(101, 500, 0, 0.5), # Eligible for basic
-            self._create_household(102, 1000, 1, 0.6) # Already has basic
+            self._create_household(101, 500, 0, 0.5),  # Eligible for basic
+            self._create_household(102, 1000, 1, 0.6),  # Already has basic
         ]
 
         initial_gov_assets = self.mock_government.assets
-        cost = self.mock_config.EDUCATION_COST_PER_LEVEL[1] # 100
+        cost = self.mock_config.EDUCATION_COST_PER_LEVEL[1]  # 100
 
         self.ministry.run_public_education(households, self.mock_government, 1)
 
         self.assertEqual(households[0].education_level, 1)
-        self.assertEqual(households[1].education_level, 1) # Unchanged
+        self.assertEqual(households[1].education_level, 1)  # Unchanged
         self.assertEqual(self.mock_government.assets, initial_gov_assets - cost)
         self.assertEqual(self.mock_government.expenditure_this_tick, cost)
-        self.assertEqual(self.mock_government.current_tick_stats["education_spending"], cost)
+        self.assertEqual(
+            self.mock_government.current_tick_stats["education_spending"], cost
+        )
 
     def test_run_public_education_scholarship(self):
         # With 5 active households, the bottom 20% is the single poorest one.
         households = [
-            self._create_household(101, 150, 1, 0.9),   # Poorest, high potential -> Eligible
-            self._create_household(102, 200, 1, 0.7),   # 2nd poorest
-            self._create_household(103, 300, 1, 0.6),   # Middle class
-            self._create_household(104, 400, 1, 0.5),   # Middle class
-            self._create_household(105, 10000, 1, 0.9), # Rich, high potential
-            self._create_household(106, 80, 1, 0.85, is_active=False), # Inactive -> Ignored
+            self._create_household(
+                101, 150, 1, 0.9
+            ),  # Poorest, high potential -> Eligible
+            self._create_household(102, 200, 1, 0.7),  # 2nd poorest
+            self._create_household(103, 300, 1, 0.6),  # Middle class
+            self._create_household(104, 400, 1, 0.5),  # Middle class
+            self._create_household(105, 10000, 1, 0.9),  # Rich, high potential
+            self._create_household(
+                106, 80, 1, 0.85, is_active=False
+            ),  # Inactive -> Ignored
         ]
 
         initial_gov_assets = self.mock_government.assets
-        cost = self.mock_config.EDUCATION_COST_PER_LEVEL[2] # 500
+        cost = self.mock_config.EDUCATION_COST_PER_LEVEL[2]  # 500
         subsidy = cost * 0.8
         student_share = cost * 0.2
 
@@ -79,7 +87,6 @@ class TestMinistryOfEducation(unittest.TestCase):
         self.assertEqual(households[1].education_level, 1)
         self.assertEqual(households[4].education_level, 1)
 
-
     def test_budget_constraints(self):
         # Government has 10k assets, budget is 10% = 1k
         # Basic edu costs 100 each. 11 households want it. Only 10 should get it.
@@ -91,5 +98,6 @@ class TestMinistryOfEducation(unittest.TestCase):
         self.assertEqual(promoted_count, 10)
         self.assertEqual(self.mock_government.assets, 10000 - (10 * 100))
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     unittest.main()
diff --git a/tests/systems/test_sensory_system.py b/tests/systems/test_sensory_system.py
index 911d961..5261065 100644
--- a/tests/systems/test_sensory_system.py
+++ b/tests/systems/test_sensory_system.py
@@ -4,20 +4,22 @@ from unittest.mock import MagicMock
 from simulation.systems.sensory_system import SensorySystem
 from simulation.systems.api import SensoryContext
 
+
 @pytest.fixture
 def sensory_system():
     config = MagicMock()
     return SensorySystem(config)
 
+
 def test_generate_government_sensory_dto(sensory_system):
     # Setup
     tracker = MagicMock()
     # Mock return of get_latest_indicators
     tracker.get_latest_indicators.return_value = {
-        "avg_goods_price": 11.0, # Last was 10.0 -> 10% inflation
+        "avg_goods_price": 11.0,  # Last was 10.0 -> 10% inflation
         "unemployment_rate": 0.05,
-        "total_production": 110.0, # Last was 0.0 -> ? (Assume 100 base)
-        "avg_wage": 20.0
+        "total_production": 110.0,  # Last was 0.0 -> ? (Assume 100 base)
+        "avg_wage": 20.0,
     }
     # Initial state of system
     sensory_system.last_avg_price_for_sma = 10.0
@@ -26,11 +28,7 @@ def test_generate_government_sensory_dto(sensory_system):
     government = MagicMock()
     government.approval_rating = 0.8
 
-    context: SensoryContext = {
-        "tracker": tracker,
-        "government": government,
-        "time": 10
-    }
+    context: SensoryContext = {"tracker": tracker, "government": government, "time": 10}
 
     # Execute
     dto = sensory_system.generate_government_sensory_dto(context)
@@ -40,7 +38,7 @@ def test_generate_government_sensory_dto(sensory_system):
 
     # Inflation: (11 - 10) / 10 = 0.1
     assert sensory_system.inflation_buffer[-1] == 0.1
-    assert dto.inflation_sma == 0.1 # Single value average
+    assert dto.inflation_sma == 0.1  # Single value average
 
     # GDP Growth: (110 - 100) / 100 = 0.1
     assert sensory_system.gdp_growth_buffer[-1] == 0.1
@@ -51,6 +49,7 @@ def test_generate_government_sensory_dto(sensory_system):
     assert dto.approval_sma == 0.8
     assert dto.current_gdp == 110.0
 
+
 def test_buffer_smoothing(sensory_system):
     # Add some history
     sensory_system.inflation_buffer.append(0.0)
@@ -60,18 +59,14 @@ def test_buffer_smoothing(sensory_system):
 
     tracker = MagicMock()
     tracker.get_latest_indicators.return_value = {
-        "avg_goods_price": 10.0, # No change from last
+        "avg_goods_price": 10.0,  # No change from last
     }
     sensory_system.last_avg_price_for_sma = 10.0
 
     government = MagicMock()
     government.approval_rating = 0.5
 
-    context: SensoryContext = {
-        "tracker": tracker,
-        "government": government,
-        "time": 2
-    }
+    context: SensoryContext = {"tracker": tracker, "government": government, "time": 2}
 
     dto = sensory_system.generate_government_sensory_dto(context)
 
diff --git a/tests/systems/test_social_system.py b/tests/systems/test_social_system.py
index ba27200..172bca9 100644
--- a/tests/systems/test_social_system.py
+++ b/tests/systems/test_social_system.py
@@ -3,35 +3,46 @@ from unittest.mock import MagicMock
 from simulation.systems.social_system import SocialSystem
 from simulation.systems.api import SocialMobilityContext
 
+
 class MockHousehold:
     def __init__(self, id, consumption, housing_tier, is_active=True):
         self.id = id
         self.current_consumption = consumption
-        self.housing_tier = housing_tier # Helper for mocking HousingManager
+        self.housing_tier = housing_tier  # Helper for mocking HousingManager
         self.is_active = is_active
         self.social_rank = 0.0
 
+
 class MockHousingManager:
     def __init__(self, agent, config):
         pass
+
     def get_housing_tier(self, agent):
         return agent.housing_tier
 
+
 @pytest.fixture
 def social_system():
     config = MagicMock()
     return SocialSystem(config)
 
+
 def test_update_social_ranks(social_system):
     # Setup
-    h1 = MockHousehold(1, consumption=100, housing_tier=1.0) # Score = 1000 + 1000 = 2000
-    h2 = MockHousehold(2, consumption=200, housing_tier=3.0) # Score = 2000 + 3000 = 5000 (Top)
-    h3 = MockHousehold(3, consumption=50, housing_tier=1.0)  # Score = 500 + 1000 = 1500 (Bottom)
+    h1 = MockHousehold(
+        1, consumption=100, housing_tier=1.0
+    )  # Score = 1000 + 1000 = 2000
+    h2 = MockHousehold(
+        2, consumption=200, housing_tier=3.0
+    )  # Score = 2000 + 3000 = 5000 (Top)
+    h3 = MockHousehold(
+        3, consumption=50, housing_tier=1.0
+    )  # Score = 500 + 1000 = 1500 (Bottom)
 
     households = [h1, h2, h3]
     context: SocialMobilityContext = {
         "households": households,
-        "housing_manager": MockHousingManager(None, None)
+        "housing_manager": MockHousingManager(None, None),
     }
 
     # Execute
@@ -43,13 +54,14 @@ def test_update_social_ranks(social_system):
     # h3 should be Rank 2 -> Percentile 1 - 2/3 = 0.33
 
     assert h2.social_rank == 1.0
-    assert abs(h1.social_rank - (1.0 - 1/3)) < 0.01
-    assert abs(h3.social_rank - (1.0 - 2/3)) < 0.01
+    assert abs(h1.social_rank - (1.0 - 1 / 3)) < 0.01
+    assert abs(h3.social_rank - (1.0 - 2 / 3)) < 0.01
+
 
 def test_calculate_reference_standard(social_system):
     # Setup
     # Top 20% of 5 agents = 1 agent
-    h1 = MockHousehold(1, consumption=100, housing_tier=1.0) # Rank 1.0 (Assume sorted)
+    h1 = MockHousehold(1, consumption=100, housing_tier=1.0)  # Rank 1.0 (Assume sorted)
     h1.social_rank = 1.0
     h2 = MockHousehold(2, consumption=50, housing_tier=1.0)
     h2.social_rank = 0.8
@@ -63,7 +75,7 @@ def test_calculate_reference_standard(social_system):
     households = [h1, h2, h3, h4, h5]
     context: SocialMobilityContext = {
         "households": households,
-        "housing_manager": MockHousingManager(None, None)
+        "housing_manager": MockHousingManager(None, None),
     }
 
     # Execute
diff --git a/tests/systems/test_tax_agency.py b/tests/systems/test_tax_agency.py
index 1e15921..1e1d223 100644
--- a/tests/systems/test_tax_agency.py
+++ b/tests/systems/test_tax_agency.py
@@ -2,24 +2,22 @@ import unittest
 from unittest.mock import Mock, MagicMock
 from simulation.systems.tax_agency import TaxAgency
 
-class TestTaxAgency(unittest.TestCase):
 
+class TestTaxAgency(unittest.TestCase):
     def setUp(self):
         self.mock_config = Mock()
-        self.mock_config.TAX_BRACKETS = [
-            (1.0, 0.10),
-            (3.0, 0.20),
-            (float('inf'), 0.30)
-        ]
+        self.mock_config.TAX_BRACKETS = [(1.0, 0.10), (3.0, 0.20), (float("inf"), 0.30)]
         self.mock_config.TAX_RATE_BASE = 0.20
         self.tax_agency = TaxAgency(self.mock_config)
 
     def test_calculate_income_tax_flat(self):
-        self.assertAlmostEqual(self.tax_agency.calculate_income_tax(1000, 200, 0.25, 'FLAT'), 250)
+        self.assertAlmostEqual(
+            self.tax_agency.calculate_income_tax(1000, 200, 0.25, "FLAT"), 250
+        )
 
     def test_calculate_income_tax_progressive_with_brackets(self):
         survival_cost = 1000
-        current_tax_rate = 0.20 # Policy rate
+        current_tax_rate = 0.20  # Policy rate
 
         income = 2500
         tax_bracket1 = 1000 * 0.10
@@ -29,22 +27,37 @@ class TestTaxAgency(unittest.TestCase):
         # With policy rate = base rate, adjustment_factor = 1.0
         expected_tax = raw_tax * (current_tax_rate / self.mock_config.TAX_RATE_BASE)
 
-        self.assertAlmostEqual(self.tax_agency.calculate_income_tax(income, survival_cost, current_tax_rate, 'PROGRESSIVE'), expected_tax)
+        self.assertAlmostEqual(
+            self.tax_agency.calculate_income_tax(
+                income, survival_cost, current_tax_rate, "PROGRESSIVE"
+            ),
+            expected_tax,
+        )
 
     def test_calculate_income_tax_progressive_scaling(self):
         survival_cost = 1000
         income = 2500
-        raw_tax = (1000 * 0.10) + (1500 * 0.20) # 400
+        raw_tax = (1000 * 0.10) + (1500 * 0.20)  # 400
 
         # Policy rate is a tax cut (0.10) vs base (0.20), so factor is 0.5
         cut_rate = 0.10
         expected_tax_cut = raw_tax * (cut_rate / self.mock_config.TAX_RATE_BASE)
-        self.assertAlmostEqual(self.tax_agency.calculate_income_tax(income, survival_cost, cut_rate, 'PROGRESSIVE'), expected_tax_cut)
+        self.assertAlmostEqual(
+            self.tax_agency.calculate_income_tax(
+                income, survival_cost, cut_rate, "PROGRESSIVE"
+            ),
+            expected_tax_cut,
+        )
 
         # Policy rate is a tax hike (0.30) vs base (0.20), so factor is 1.5
         hike_rate = 0.30
         expected_tax_hike = raw_tax * (hike_rate / self.mock_config.TAX_RATE_BASE)
-        self.assertAlmostEqual(self.tax_agency.calculate_income_tax(income, survival_cost, hike_rate, 'PROGRESSIVE'), expected_tax_hike)
+        self.assertAlmostEqual(
+            self.tax_agency.calculate_income_tax(
+                income, survival_cost, hike_rate, "PROGRESSIVE"
+            ),
+            expected_tax_hike,
+        )
 
     def test_calculate_corporate_tax(self):
         self.assertAlmostEqual(self.tax_agency.calculate_corporate_tax(1000, 0.35), 350)
@@ -60,5 +73,6 @@ class TestTaxAgency(unittest.TestCase):
         self.tax_agency.collect_tax(mock_gov, 100, "income", 1, 1)
         self.assertEqual(mock_gov.assets, 10100)
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     unittest.main()
diff --git a/tests/systems/test_technology_manager.py b/tests/systems/test_technology_manager.py
index 385524d..2504c03 100644
--- a/tests/systems/test_technology_manager.py
+++ b/tests/systems/test_technology_manager.py
@@ -3,12 +3,13 @@ from unittest.mock import MagicMock
 from simulation.systems.technology_manager import TechnologyManager, TechNode
 from simulation.systems.tech.api import FirmTechInfoDTO
 
+
 class TestTechnologyManager:
     @pytest.fixture
     def config(self):
         mock_config = MagicMock()
-        mock_config.TECH_FERTILIZER_UNLOCK_TICK = 30 # Updated default
-        mock_config.TECH_DIFFUSION_RATE = 0.10       # Updated default
+        mock_config.TECH_FERTILIZER_UNLOCK_TICK = 30  # Updated default
+        mock_config.TECH_DIFFUSION_RATE = 0.10  # Updated default
         return mock_config
 
     @pytest.fixture
@@ -33,7 +34,7 @@ class TestTechnologyManager:
         # Setup Tech
         tech_id = "TECH_AGRI_CHEM_01"
         tech = manager.tech_tree[tech_id]
-        tech.unlock_tick = 30 # Updated check
+        tech.unlock_tick = 30  # Updated check
         tech.sector = "FOOD"
 
         # Setup Firms DTO
@@ -65,7 +66,7 @@ class TestTechnologyManager:
         tech_id = "TECH_AGRI_CHEM_01"
         tech = manager.tech_tree[tech_id]
         tech.unlock_tick = 30
-        tech.diffusion_rate = 0.0 # No diffusion initially
+        tech.diffusion_rate = 0.0  # No diffusion initially
 
         firms = [
             FirmTechInfoDTO(id=1, sector="FOOD", is_visionary=False),
@@ -74,7 +75,7 @@ class TestTechnologyManager:
         # Unlock it first (needs unlock call)
         # Note: _unlock_tech also iterates firms, but firm 1 is not visionary, so it won't adopt there.
         manager.update(30, firms, 1.0)
-        assert not manager.has_adopted(1, tech_id) # Not visionary, and diffusion 0%
+        assert not manager.has_adopted(1, tech_id)  # Not visionary, and diffusion 0%
 
         # Now enable diffusion
         tech.diffusion_rate = 1.0
@@ -83,7 +84,7 @@ class TestTechnologyManager:
         assert manager.has_adopted(1, tech_id)
 
     def test_productivity_multiplier(self, manager):
-         # Setup Tech
+        # Setup Tech
         tech_id = "TECH_AGRI_CHEM_01"
         tech = manager.tech_tree[tech_id]
         tech.multiplier = 3.0
diff --git a/tests/test_ai_driven_firm_engine.py b/tests/test_ai_driven_firm_engine.py
index b837a96..4e8fd62 100644
--- a/tests/test_ai_driven_firm_engine.py
+++ b/tests/test_ai_driven_firm_engine.py
@@ -48,8 +48,8 @@ def mock_firm(mock_config):
     firm.employees = []
     firm.profit_history = []
     firm.productivity_factor = 1.0
-    firm.age = 25 # Add age for solvency checks
-    firm.finance = Mock() # Mock the finance department
+    firm.age = 25  # Add age for solvency checks
+    firm.finance = Mock()  # Mock the finance department
     return firm
 
 
@@ -60,7 +60,8 @@ def test_adjust_price_tactic(firm_decision_engine_instance, mock_firm):
     mock_firm.inventory["food"] = 200
     mock_firm.production_target = 100
     firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
-        (Tactic.ADJUST_PRICE, 1.0)
+        Tactic.ADJUST_PRICE,
+        1.0,
     )
 
     context = DecisionContext(
diff --git a/tests/test_ai_training_manager.py b/tests/test_ai_training_manager.py
index 46ba7e7..95e5b62 100644
--- a/tests/test_ai_training_manager.py
+++ b/tests/test_ai_training_manager.py
@@ -15,7 +15,7 @@ def mock_config(golden_config):
     config.IMITATION_LEARNING_INTERVAL = 100
     config.IMITATION_MUTATION_RATE = 0.1
     config.IMITATION_MUTATION_MAGNITUDE = 0.05
-    config.MITOSIS_Q_TABLE_MUTATION_RATE = None # Ensure explicit None
+    config.MITOSIS_Q_TABLE_MUTATION_RATE = None  # Ensure explicit None
     config.TOP_PERFORMING_PERCENTILE = 0.1
     config.UNDER_PERFORMING_PERCENTILE = 0.5
     return config
diff --git a/tests/test_ai_training_manager_new.py b/tests/test_ai_training_manager_new.py
index 7d98605..4bc907c 100644
--- a/tests/test_ai_training_manager_new.py
+++ b/tests/test_ai_training_manager_new.py
@@ -3,6 +3,7 @@ from unittest.mock import Mock, MagicMock
 from simulation.ai.ai_training_manager import AITrainingManager
 from simulation.core_agents import Household
 
+
 @pytest.fixture
 def mock_config():
     config = Mock()
@@ -10,46 +11,49 @@ def mock_config():
     config.IMITATION_MUTATION_MAGNITUDE = 0.05
     return config
 
+
 @pytest.fixture
 def mock_agents():
     agents = []
     for i in range(10):
         agent = Mock(spec=Household)
         agent.id = i
-        agent._assets = float(i * 100) # 0, 100, ..., 900
-        
+        agent._assets = float(i * 100)  # 0, 100, ..., 900
+
         # Mock Decision Engine and AI Engine
         agent.decision_engine = Mock()
         agent.decision_engine.ai_engine = Mock()
-        
+
         # Mock Q-Table Managers
         agent.decision_engine.ai_engine.q_table_manager_strategy = Mock()
         agent.decision_engine.ai_engine.q_table_manager_strategy.q_table = {
             "state1": {"action1": 1.0}
         }
-        
+
         agent.decision_engine.ai_engine.q_table_manager_tactic = Mock()
         agent.decision_engine.ai_engine.q_table_manager_tactic.q_table = {
             "stateA": {"actionA": 0.5}
         }
-        
+
         agents.append(agent)
     return agents
 
+
 def test_get_top_performing_agents(mock_agents, mock_config):
     manager = AITrainingManager(mock_agents, mock_config)
     top_agents = manager._get_top_performing_agents(percentile=0.2)
-    
+
     # Top 20% of 10 agents = 2 agents
     assert len(top_agents) == 2
     # Should be agent 9 (900) and agent 8 (800)
     assert top_agents[0].id == 9
     assert top_agents[1].id == 8
 
+
 def test_get_under_performing_agents(mock_agents, mock_config):
     manager = AITrainingManager(mock_agents, mock_config)
     under_agents = manager._get_under_performing_agents(percentile=0.3)
-    
+
     # Bottom 30% of 10 agents = 3 agents
     assert len(under_agents) == 3
     # Should be agent 0 (0), agent 1 (100), agent 2 (200) - sorted ascending
@@ -57,11 +61,12 @@ def test_get_under_performing_agents(mock_agents, mock_config):
     assert under_agents[1].id == 1
     assert under_agents[2].id == 2
 
+
 def test_clone_and_mutate_q_table(mock_agents, mock_config):
     manager = AITrainingManager(mock_agents, mock_config)
-    source = mock_agents[9] # Rich
-    target = mock_agents[0] # Poor
-    
+    source = mock_agents[9]  # Rich
+    target = mock_agents[0]  # Poor
+
     # Set distinct values for source
     source.decision_engine.ai_engine.q_table_manager_strategy.q_table = {
         "s1": {"a1": 10.0}
@@ -69,43 +74,51 @@ def test_clone_and_mutate_q_table(mock_agents, mock_config):
     source.decision_engine.ai_engine.q_table_manager_tactic.q_table = {
         "t1": {"ta1": 5.0}
     }
-    
+
     manager._clone_and_mutate_q_table(source, target)
-    
+
     # Verify Strategy Table Cloned
-    target_strategy_table = target.decision_engine.ai_engine.q_table_manager_strategy.q_table
+    target_strategy_table = (
+        target.decision_engine.ai_engine.q_table_manager_strategy.q_table
+    )
     assert "s1" in target_strategy_table
     # Value should be close to 10.0 but potentially mutated
     assert 9.9 <= target_strategy_table["s1"]["a1"] <= 10.1
-    
+
     # Verify Tactic Table Cloned
-    target_tactic_table = target.decision_engine.ai_engine.q_table_manager_tactic.q_table
+    target_tactic_table = (
+        target.decision_engine.ai_engine.q_table_manager_tactic.q_table
+    )
     assert "t1" in target_tactic_table
     # Value should be close to 5.0 but potentially mutated
     assert 4.9 <= target_tactic_table["t1"]["ta1"] <= 5.1
 
+
 def test_clone_from_fittest_agent(mock_agents, mock_config):
     manager = AITrainingManager(mock_agents, mock_config)
     target = mock_agents[0]
-    
+
     # Agent 9 is fittest (900 assets)
     fittest = mock_agents[9]
-    fittest.decision_engine.ai_engine.q_table_manager_strategy.q_table = {"fit": {"win": 100.0}}
-    
+    fittest.decision_engine.ai_engine.q_table_manager_strategy.q_table = {
+        "fit": {"win": 100.0}
+    }
+
     manager.clone_from_fittest_agent(target)
-    
+
     target_table = target.decision_engine.ai_engine.q_table_manager_strategy.q_table
     assert "fit" in target_table
     assert 99.0 <= target_table["fit"]["win"] <= 101.0
 
+
 def test_run_imitation_learning_cycle(mock_agents, mock_config):
     manager = AITrainingManager(mock_agents, mock_config)
-    
+
     # Mock _clone_and_mutate_q_table to verify calls
     manager._clone_and_mutate_q_table = Mock()
-    
+
     manager.run_imitation_learning_cycle(current_tick=1000)
-    
+
     # Should identify top and bottom agents and call clone
     # Top 10% (1 agent), Bottom 50% (5 agents)
     # Should call clone 5 times
diff --git a/tests/test_api_extensions.py b/tests/test_api_extensions.py
index d2c71ec..ba32243 100644
--- a/tests/test_api_extensions.py
+++ b/tests/test_api_extensions.py
@@ -1,25 +1,35 @@
 import pytest
 from unittest.mock import MagicMock
-from simulation.viewmodels.economic_indicators_viewmodel import EconomicIndicatorsViewModel
+from simulation.viewmodels.economic_indicators_viewmodel import (
+    EconomicIndicatorsViewModel,
+)
 from simulation.core_markets import Market
 from simulation.markets.order_book_market import OrderBookMarket
 from simulation.models import Order
 
+
 @pytest.fixture
 def vm():
     repo = MagicMock()
     return EconomicIndicatorsViewModel(repo)
 
+
 class TestEconomicIndicatorsViewModel:
     def test_get_wealth_distribution(self, vm, golden_households, golden_firms):
         # State Override Pattern: Use golden fixtures but override state
         # We need 3 households and 2 firms to match original test expectations
 
         # Ensure we have enough mocks. If not, create them (defensive).
-        households = (golden_households[:3] if len(golden_households) >= 3
-                      else [MagicMock() for _ in range(3)])
-        firms = (golden_firms[:2] if len(golden_firms) >= 2
-                 else [MagicMock() for _ in range(2)])
+        households = (
+            golden_households[:3]
+            if len(golden_households) >= 3
+            else [MagicMock() for _ in range(3)]
+        )
+        firms = (
+            golden_firms[:2]
+            if len(golden_firms) >= 2
+            else [MagicMock() for _ in range(2)]
+        )
 
         # Override assets
         households[0]._assets = 10
@@ -37,7 +47,7 @@ class TestEconomicIndicatorsViewModel:
         assert "labels" in dist
         assert "data" in dist
         assert len(dist["data"]) == 10
-        assert sum(dist["data"]) == 5 # 5 agents
+        assert sum(dist["data"]) == 5  # 5 agents
 
     def test_get_needs_distribution(self, vm, golden_households, golden_firms):
         # Need 2 households and 1 firm
@@ -54,15 +64,15 @@ class TestEconomicIndicatorsViewModel:
         firms = [f1]
 
         dist = vm.get_needs_distribution(households, firms)
-        assert dist["household"]["food"] == 15.0 # (10+20)/2
-        assert dist["household"]["shelter"] == 10.0 # (5+15)/2
+        assert dist["household"]["food"] == 15.0  # (10+20)/2
+        assert dist["household"]["shelter"] == 10.0  # (5+15)/2
         assert dist["firm"]["liquidity_need"] == 100.0
 
     def test_get_sales_by_good(self, vm):
         txs = [
             {"item_id": "apple", "quantity": 10},
             {"item_id": "banana", "quantity": 5},
-            {"item_id": "apple", "quantity": 5}
+            {"item_id": "apple", "quantity": 5},
         ]
         sales = vm.get_sales_by_good(txs)
         assert sales["apple"] == 15
@@ -72,10 +82,28 @@ class TestEconomicIndicatorsViewModel:
         market = OrderBookMarket("test_market")
         # Manually inject orders for testing
         market.buy_orders = {
-            "apple": [Order(agent_id=1, order_type="BUY", market_id="test_market", item_id="apple", quantity=10, price=5)]
+            "apple": [
+                Order(
+                    agent_id=1,
+                    order_type="BUY",
+                    market_id="test_market",
+                    item_id="apple",
+                    quantity=10,
+                    price=5,
+                )
+            ]
         }
         market.sell_orders = {
-            "apple": [Order(agent_id=2, order_type="SELL", market_id="test_market", item_id="apple", quantity=5, price=6)]
+            "apple": [
+                Order(
+                    agent_id=2,
+                    order_type="SELL",
+                    market_id="test_market",
+                    item_id="apple",
+                    quantity=5,
+                    price=6,
+                )
+            ]
         }
 
         markets = {"test_market": market}
diff --git a/tests/test_api_history.py b/tests/test_api_history.py
index 930d8b9..cc05704 100644
--- a/tests/test_api_history.py
+++ b/tests/test_api_history.py
@@ -1,9 +1,9 @@
-
 import unittest
 import json
 import logging
 import app as app_module
 
+
 class TestHistoryAPI(unittest.TestCase):
     def setUp(self):
         self.app = app_module.app.test_client()
@@ -13,7 +13,7 @@ class TestHistoryAPI(unittest.TestCase):
         with app_module.app.app_context():
             app_module.create_simulation()
             # Suppress logging for cleaner test output
-            logging.getLogger('app').setLevel(logging.WARNING)
+            logging.getLogger("app").setLevel(logging.WARNING)
 
     def test_gdp_history_on_refresh(self):
         """
@@ -33,14 +33,14 @@ class TestHistoryAPI(unittest.TestCase):
                 print(f"Ran tick {sim.time}")
 
         # 2. Call the update endpoint with since=0
-        response = self.app.get('/api/simulation/update?since=0')
+        response = self.app.get("/api/simulation/update?since=0")
         self.assertEqual(response.status_code, 200)
 
         data = json.loads(response.data)
 
         # 3. Analyze the response
-        gdp_history = data.get('chart_update', {}).get('new_gdp_history', [])
-        current_tick = data.get('tick')
+        gdp_history = data.get("chart_update", {}).get("new_gdp_history", [])
+        current_tick = data.get("tick")
 
         print(f"Current Tick: {current_tick}")
         print(f"Received GDP History Length: {len(gdp_history)}")
@@ -48,11 +48,16 @@ class TestHistoryAPI(unittest.TestCase):
 
         # 4. Assertions
         # We expect at least 5 data points
-        self.assertGreaterEqual(len(gdp_history), 5, f"Expected at least 5 GDP data points, but got {len(gdp_history)}")
+        self.assertGreaterEqual(
+            len(gdp_history),
+            5,
+            f"Expected at least 5 GDP data points, but got {len(gdp_history)}",
+        )
 
         # Check if values are numeric
         for val in gdp_history:
             self.assertIsInstance(val, (int, float))
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     unittest.main()
diff --git a/tests/test_app.py b/tests/test_app.py
index 8fca3bf..c18a7bc 100644
--- a/tests/test_app.py
+++ b/tests/test_app.py
@@ -12,6 +12,7 @@ def client():
     with app.test_client() as client:
         yield client
 
+
 @pytest.fixture
 def auth_headers():
     return {"Authorization": f"Bearer {config.SECRET_TOKEN}"}
@@ -141,4 +142,4 @@ def test_get_transactions_api(mock_get_repository, client):
     assert rv.status_code == 200
     data = json.loads(rv.data)
     assert len(data) == 1
-    assert data[0]["price"] == 10
\ No newline at end of file
+    assert data[0]["price"] == 10
diff --git a/tests/test_bank.py b/tests/test_bank.py
index f8bdb2e..fd2875a 100644
--- a/tests/test_bank.py
+++ b/tests/test_bank.py
@@ -3,6 +3,7 @@ from unittest.mock import MagicMock, patch
 from simulation.bank import Bank, Loan
 from modules.finance.api import InsufficientFundsError
 
+
 @pytest.fixture(autouse=True)
 def mock_logger():
     with patch("simulation.bank.logging.getLogger") as mock_get_logger:
@@ -10,20 +11,24 @@ def mock_logger():
         mock_get_logger.return_value = mock_logger_instance
         yield mock_logger_instance
 
+
 from modules.common.config_manager.impl import ConfigManagerImpl
 from pathlib import Path
 
+
 @pytest.fixture
 def config_manager(tmp_path: Path):
     config_dir = tmp_path / "config"
     config_dir.mkdir()
     return ConfigManagerImpl(config_dir)
 
+
 @pytest.fixture
 def bank_instance(config_manager: ConfigManagerImpl):
     # Initialize with enough assets for tests
     return Bank(id=1, initial_assets=10000.0, config_manager=config_manager)
 
+
 class TestBank:
     def test_initialization(self, bank_instance: Bank):
         assert bank_instance.id == 1
@@ -34,8 +39,12 @@ class TestBank:
         assert bank_instance.needs == {}
 
     def test_grant_loan_successful(self, bank_instance: Bank):
-        bank_instance.config_manager.set_value_for_test("bank_defaults.initial_base_annual_rate", 0.05)
-        bank_instance.config_manager.set_value_for_test("bank_defaults.credit_spread_base", 0.02)
+        bank_instance.config_manager.set_value_for_test(
+            "bank_defaults.initial_base_annual_rate", 0.05
+        )
+        bank_instance.config_manager.set_value_for_test(
+            "bank_defaults.credit_spread_base", 0.02
+        )
         initial_assets = bank_instance.assets
         # Mock a borrower agent
         borrower_id = 101
@@ -178,7 +187,7 @@ class TestBank:
         # Mock Agents
         mock_borrower = MagicMock()
         mock_borrower.id = borrower_id
-        mock_borrower.assets = 100.0 # Enough to pay interest
+        mock_borrower.assets = 100.0  # Enough to pay interest
         mock_borrower.is_active = True
 
         mock_depositor = MagicMock()
@@ -191,7 +200,9 @@ class TestBank:
         transactions = bank_instance.run_tick(agents, current_tick=1)
 
         # Assert
-        assert len(transactions) >= 2 # Interest Payment (Loan) + Interest Payment (Deposit)
+        assert (
+            len(transactions) >= 2
+        )  # Interest Payment (Loan) + Interest Payment (Deposit)
 
         # Check types
         tx_types = [tx.transaction_type for tx in transactions]
diff --git a/tests/test_base_agent.py b/tests/test_base_agent.py
index 9a92ca7..b4ddb94 100644
--- a/tests/test_base_agent.py
+++ b/tests/test_base_agent.py
@@ -53,10 +53,18 @@ def test_base_agent_abstract_methods():
         def update_needs(self, current_tick: int):
             pass
 
-        def make_decision(self, markets: Dict[str, Any], goods_data: list[Dict[str, Any]], market_data: Dict[str, Any], current_time: int) -> tuple[list[Any], Any]:
+        def make_decision(
+            self,
+            markets: Dict[str, Any],
+            goods_data: list[Dict[str, Any]],
+            market_data: Dict[str, Any],
+            current_time: int,
+        ) -> tuple[list[Any], Any]:
             return [], None
 
-        def clone(self, new_id: int, initial_assets_from_parent: float, current_tick: int) -> "BaseAgent":
+        def clone(
+            self, new_id: int, initial_assets_from_parent: float, current_tick: int
+        ) -> "BaseAgent":
             pass
 
     agent = ConcreteAgent(
diff --git a/tests/test_corporate_manager.py b/tests/test_corporate_manager.py
index c621220..f7b0e01 100644
--- a/tests/test_corporate_manager.py
+++ b/tests/test_corporate_manager.py
@@ -1,4 +1,3 @@
-
 import pytest
 from unittest.mock import MagicMock
 from simulation.decisions.corporate_manager import CorporateManager
@@ -7,6 +6,7 @@ from simulation.schemas import FirmActionVector
 from simulation.models import Order
 from simulation.ai.enums import Personality
 
+
 class MockConfig:
     CAPITAL_TO_OUTPUT_RATIO = 2.0
     DIVIDEND_RATE_MIN = 0.1
@@ -27,6 +27,7 @@ class MockConfig:
     SEO_MAX_SELL_RATIO = 0.1
     STARTUP_COST = 30000.0
 
+
 @pytest.fixture
 def firm_dto():
     return FirmStateDTO(
@@ -61,30 +62,32 @@ def firm_dto():
         employees_data={},
         agent_data={"personality": "BALANCED"},
         system2_guidance={},
-        sentiment_index=1.0
+        sentiment_index=1.0,
     )
 
+
 @pytest.fixture
 def context_mock(firm_dto):
     context = MagicMock(spec=DecisionContext)
-    context.state = firm_dto # Use state
+    context.state = firm_dto  # Use state
     context.current_time = 1
     context.market_data = {
         "goods_market": {
             "food_avg_traded_price": 10.0,
-            "food_current_sell_price": 10.0
+            "food_current_sell_price": 10.0,
         },
-        "debt_data": {1: {"total_principal": 0.0}}
+        "debt_data": {1: {"total_principal": 0.0}},
     }
     context.markets = {
         "food": MagicMock(),
         "labor": MagicMock(),
-        "stock_market": MagicMock()
+        "stock_market": MagicMock(),
     }
     context.reflux_system = MagicMock()
     context.government = MagicMock()
     return context
 
+
 def test_rd_logic(firm_dto, context_mock):
     manager = CorporateManager(MockConfig())
     # Aggressiveness 1.0 -> 20% of Revenue
@@ -94,12 +97,12 @@ def test_rd_logic(firm_dto, context_mock):
         dividend_aggressiveness=0.0,
         debt_aggressiveness=0.0,
         hiring_aggressiveness=0.0,
-        sales_aggressiveness=0.0
+        sales_aggressiveness=0.0,
     )
 
     firm_dto.assets = 10000.0
     firm_dto.revenue_this_turn = 1000.0
-    expected_budget = 1000.0 * 0.2 # 200
+    expected_budget = 1000.0 * 0.2  # 200
 
     orders = manager.realize_ceo_actions(firm_dto, context_mock, vector)
 
@@ -108,9 +111,10 @@ def test_rd_logic(firm_dto, context_mock):
     assert rd_orders[0].quantity == expected_budget
     assert rd_orders[0].market_id == "internal"
 
+
 def test_dividend_logic(firm_dto, context_mock):
     manager = CorporateManager(MockConfig())
-    vector = FirmActionVector(dividend_aggressiveness=1.0) # Max rate 0.5
+    vector = FirmActionVector(dividend_aggressiveness=1.0)  # Max rate 0.5
 
     orders = manager.realize_ceo_actions(firm_dto, context_mock, vector)
 
@@ -118,11 +122,12 @@ def test_dividend_logic(firm_dto, context_mock):
     assert len(div_orders) == 1
     assert div_orders[0].quantity == 0.5
 
+
 def test_hiring_logic(firm_dto, context_mock):
     manager = CorporateManager(MockConfig())
     firm_dto.production_target = 100
-    firm_dto.inventory["food"] = 80 # Gap 20
-    firm_dto.productivity_factor = 10.0 # Need 2 workers (approx)
+    firm_dto.inventory["food"] = 80  # Gap 20
+    firm_dto.productivity_factor = 10.0  # Need 2 workers (approx)
 
     # Adjust mock to return empty list of employees so we hire
     firm_dto.employees = []
@@ -131,10 +136,13 @@ def test_hiring_logic(firm_dto, context_mock):
 
     orders = manager.realize_ceo_actions(firm_dto, context_mock, vector)
 
-    hiring_orders = [o for o in orders if o.order_type == "BUY" and o.item_id == "labor"]
+    hiring_orders = [
+        o for o in orders if o.order_type == "BUY" and o.item_id == "labor"
+    ]
     assert len(hiring_orders) > 0
     assert hiring_orders[0].price >= 10.0
 
+
 def test_debt_logic_borrow(firm_dto, context_mock):
     manager = CorporateManager(MockConfig())
     firm_dto.assets = 1000.0
@@ -150,9 +158,10 @@ def test_debt_logic_borrow(firm_dto, context_mock):
     assert len(loan_reqs) > 0
     assert loan_reqs[0].quantity > 0
 
+
 def test_automation_investment(firm_dto, context_mock):
     config = MockConfig()
-    config.AUTOMATION_COST_PER_PCT = 10.0 # Make it cheap
+    config.AUTOMATION_COST_PER_PCT = 10.0  # Make it cheap
     manager = CorporateManager(config)
     # Ensure automation is profitable so System 2 recommends it
     # High wages so automation saves money
@@ -161,7 +170,7 @@ def test_automation_investment(firm_dto, context_mock):
     }
     firm_dto.revenue_this_turn = 5000.0
 
-    firm_dto.assets = 50000.0 # Plenty of cash
+    firm_dto.assets = 50000.0  # Plenty of cash
 
     vector = FirmActionVector(capital_aggressiveness=1.0)
 
diff --git a/tests/test_decision_engine_integration.py b/tests/test_decision_engine_integration.py
index 54c9ef3..337115b 100644
--- a/tests/test_decision_engine_integration.py
+++ b/tests/test_decision_engine_integration.py
@@ -13,8 +13,8 @@ from simulation.decisions.ai_driven_household_engine import (
 )
 from simulation.decisions.ai_driven_firm_engine import AIDrivenFirmDecisionEngine
 import config
-from simulation.ai.api import Tactic, Aggressiveness # Import Tactic and Aggressiveness
-from simulation.core_markets import Market # Import Market
+from simulation.ai.api import Tactic, Aggressiveness  # Import Tactic and Aggressiveness
+from simulation.core_markets import Market  # Import Market
 
 # Add project root to sys.path
 current_dir = os.path.dirname(os.path.abspath(__file__))
@@ -145,12 +145,12 @@ def set_config_for_tests():
 
 
 class TestDecisionEngineIntegration:
-    @patch.object(Firm, 'make_decision')
+    @patch.object(Firm, "make_decision")
     def test_firm_places_sell_order_for_food(
         self, mock_make_decision: MagicMock, firm: Firm, goods_market: OrderBookMarket
     ):
         """ê¸°ì—…ì´ ì‹ëŸ‰ íŒë§¤ ì£¼ë¬¸ì„ ì˜¬ë°”ë¥´ê²Œ ì œì¶œí•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
-        mock_make_decision.return_value = ( # Corrected mock assignment
+        mock_make_decision.return_value = (  # Corrected mock assignment
             [
                 Order(
                     agent_id=firm.id,
@@ -161,14 +161,17 @@ class TestDecisionEngineIntegration:
                     market_id="goods_market",
                 )
             ],
-            (Tactic.ADJUST_PRICE, Aggressiveness.NORMAL) # Firm's make_decision also returns a tactic tuple
+            (
+                Tactic.ADJUST_PRICE,
+                Aggressiveness.NORMAL,
+            ),  # Firm's make_decision also returns a tactic tuple
         )
         markets = {"goods_market": goods_market}
         orders, _ = firm.make_decision(
             markets=markets,
             goods_data=GOODS_DATA,
             market_data={"all_households": [], "goods_data": GOODS_DATA},
-            current_time=1
+            current_time=1,
         )
 
         for order in orders:
@@ -177,15 +180,18 @@ class TestDecisionEngineIntegration:
         assert len(goods_market.sell_orders["food"]) == 1
         assert goods_market.sell_orders["food"][0].agent_id == firm.id
 
-    @patch.object(Household, 'make_decision')
+    @patch.object(Household, "make_decision")
     def test_household_places_buy_order_for_food(
-        self, mock_make_decision: MagicMock, household: Household, goods_market: OrderBookMarket
+        self,
+        mock_make_decision: MagicMock,
+        household: Household,
+        goods_market: OrderBookMarket,
     ):
         """ê°€ê³„ê°€ ì‹ëŸ‰ êµ¬ë§¤ ì£¼ë¬¸ì„ ì˜¬ë°”ë¥´ê²Œ ì œì¶œí•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
         household.needs["survival_need"] = 80.0
         household.inventory["food"] = 0.0
 
-        mock_make_decision.return_value = ( # Corrected mock assignment
+        mock_make_decision.return_value = (  # Corrected mock assignment
             [
                 Order(
                     agent_id=household.id,
@@ -196,7 +202,7 @@ class TestDecisionEngineIntegration:
                     market_id="goods_market",
                 )
             ],
-            (Tactic.EVALUATE_CONSUMPTION_OPTIONS, Aggressiveness.NORMAL)
+            (Tactic.EVALUATE_CONSUMPTION_OPTIONS, Aggressiveness.NORMAL),
         )
 
         markets = {"goods_market": goods_market}
@@ -204,7 +210,7 @@ class TestDecisionEngineIntegration:
             markets=cast(Dict[str, Market], markets),
             goods_data=GOODS_DATA,
             market_data={"all_households": [], "goods_data": GOODS_DATA},
-            current_time=1
+            current_time=1,
         )
 
         for order in orders:
@@ -214,16 +220,19 @@ class TestDecisionEngineIntegration:
         assert len(goods_market.buy_orders["food"]) == 1
         assert goods_market.buy_orders["food"][0].agent_id == household.id
 
-    @patch.object(Household, 'make_decision')
+    @patch.object(Household, "make_decision")
     def test_household_sells_labor(
-        self, mock_make_decision: MagicMock, household: Household, labor_market: OrderBookMarket
+        self,
+        mock_make_decision: MagicMock,
+        household: Household,
+        labor_market: OrderBookMarket,
     ):
         """ê°€ê³„ê°€ ë…¸ë™ íŒë§¤ ì£¼ë¬¸ì„ ì˜¬ë°”ë¥´ê²Œ ì œì¶œí•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
         household.is_employed = False
         household.needs["labor_need"] = 50
         household.needs["survival_need"] = 10.0
 
-        mock_make_decision.return_value = ( # Corrected mock assignment
+        mock_make_decision.return_value = (  # Corrected mock assignment
             [
                 Order(
                     agent_id=household.id,
@@ -234,7 +243,7 @@ class TestDecisionEngineIntegration:
                     market_id="labor_market",
                 )
             ],
-            (Tactic.PARTICIPATE_LABOR_MARKET, Aggressiveness.NORMAL)
+            (Tactic.PARTICIPATE_LABOR_MARKET, Aggressiveness.NORMAL),
         )
         markets = {"labor_market": labor_market}
         orders, _ = household.make_decision(
@@ -250,13 +259,13 @@ class TestDecisionEngineIntegration:
         assert len(labor_market.sell_orders["labor"]) == 1
         assert labor_market.sell_orders["labor"][0].agent_id == household.id
 
-    @patch.object(Firm, 'make_decision')
+    @patch.object(Firm, "make_decision")
     def test_firm_buys_labor(
         self, mock_make_decision: MagicMock, firm: Firm, labor_market: OrderBookMarket
     ):
         """ê¸°ì—…ì´ ë…¸ë™ êµ¬ë§¤ ì£¼ë¬¸ì„ ì˜¬ë°”ë¥´ê²Œ ì œì¶œí•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
         firm.employees = []
-        mock_make_decision.return_value = ( # Corrected mock assignment
+        mock_make_decision.return_value = (  # Corrected mock assignment
             [
                 Order(
                     agent_id=firm.id,
@@ -267,14 +276,17 @@ class TestDecisionEngineIntegration:
                     market_id="labor_market",
                 )
             ],
-            (Tactic.ADJUST_WAGES, Aggressiveness.NORMAL) # Firm's make_decision also returns a tactic tuple
+            (
+                Tactic.ADJUST_WAGES,
+                Aggressiveness.NORMAL,
+            ),  # Firm's make_decision also returns a tactic tuple
         )
         markets = {"labor_market": labor_market}
         orders, _ = firm.make_decision(
             markets=markets,
             goods_data=GOODS_DATA,
             market_data={"all_households": [], "goods_data": GOODS_DATA},
-            current_time=1
+            current_time=1,
         )
 
         for order in orders:
@@ -362,4 +374,4 @@ class TestDecisionEngineIntegration:
         assert tx.buyer_id == firm.id
         assert tx.seller_id == household.id
         assert not labor_market.sell_orders.get("labor")
-        assert not labor_market.buy_orders.get("labor")
\ No newline at end of file
+        assert not labor_market.buy_orders.get("labor")
diff --git a/tests/test_e2e_playwright.py b/tests/test_e2e_playwright.py
index d4fcb48..3f4acd1 100644
--- a/tests/test_e2e_playwright.py
+++ b/tests/test_e2e_playwright.py
@@ -9,12 +9,14 @@ import config
 # Note: This script assumes the app is running on localhost:5001 or starts it.
 # To keep it simple and autonomous, I will try to start the app in a thread.
 
+
 def run_app():
     # Use a different port for testing to avoid conflict if already running
     # But for E2E we usually want to test the configuration
     app.config["TESTING"] = True
     app.run(port=5005, debug=False, use_reloader=False)
 
+
 def wait_for_server(url, timeout=10):
     start = time.time()
     while time.time() - start < timeout:
@@ -25,6 +27,7 @@ def wait_for_server(url, timeout=10):
             time.sleep(0.5)
     return False
 
+
 def test_frontend_flow():
     # Start server in thread
     server_thread = threading.Thread(target=run_app, daemon=True)
@@ -49,7 +52,7 @@ def test_frontend_flow():
         print("Injecting Auth Token...")
         # config.SECRET_TOKEN should be available
         page.evaluate(f"localStorage.setItem('secretToken', '{config.SECRET_TOKEN}')")
-        page.reload() # Reload to apply token if needed by init scripts
+        page.reload()  # Reload to apply token if needed by init scripts
 
         # 3. Check for Start Button and Click
         print("Starting Simulation...")
@@ -83,5 +86,6 @@ def test_frontend_flow():
         browser.close()
         print("E2E Test Completed Successfully")
 
+
 if __name__ == "__main__":
     test_frontend_flow()
diff --git a/tests/test_engine.py b/tests/test_engine.py
index 201cfce..b32722e 100644
--- a/tests/test_engine.py
+++ b/tests/test_engine.py
@@ -15,6 +15,7 @@ from simulation.decisions.ai_driven_firm_engine import AIDrivenFirmDecisionEngin
 import config
 from simulation.dtos.api import SimulationState
 
+
 # Mock Logger to prevent actual file writes during tests
 @pytest.fixture(autouse=True)
 def mock_logger():
@@ -23,6 +24,7 @@ def mock_logger():
         mock_get_logger.return_value = mock_logger_instance
         yield mock_logger_instance
 
+
 # Mock Config Module with full attributes from actual config.py
 @pytest.fixture
 def mock_config_module():
@@ -68,7 +70,7 @@ def mock_config_module():
     mock_config.HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK = 2.0
     mock_config.SURVIVAL_NEED_DEATH_THRESHOLD = 100.0
     mock_config.TAX_RATE_BASE = 0.1
-    mock_config.TAX_MODE = "FLAT" # Simplified for test
+    mock_config.TAX_MODE = "FLAT"  # Simplified for test
     mock_config.ASSETS_DEATH_THRESHOLD = 0.0
     mock_config.HOUSEHOLD_DEATH_TURNS_THRESHOLD = 4
 
@@ -98,10 +100,10 @@ def mock_config_module():
     }
 
     mock_config.TAX_BRACKETS = [
-        (0.5, 0.0),   # Tax Free
+        (0.5, 0.0),  # Tax Free
         (1.0, 0.05),  # Working Class: 5%
         (3.0, 0.10),  # Middle Class: 10%
-        (float('inf'), 0.20) # Wealthy: 20%
+        (float("inf"), 0.20),  # Wealthy: 20%
     ]
 
     # Value Orientation Mapping (Crucial for Household.__init__)
@@ -117,10 +119,10 @@ def mock_config_module():
             "preference_growth": 1.5,
         },
         "test": {
-             "preference_asset": 1.0,
-             "preference_social": 1.0,
-             "preference_growth": 1.0,
-        }
+            "preference_asset": 1.0,
+            "preference_social": 1.0,
+            "preference_growth": 1.0,
+        },
     }
 
     mock_config.EDUCATION_WEALTH_THRESHOLDS = {0: 0, 1: 1000}
@@ -130,15 +132,17 @@ def mock_config_module():
 
     return mock_config
 
+
 # Fixtures for common dependencies
 @pytest.fixture
 def mock_households(mock_config_module):
     # Setup initial needs with 'survival' and other keys to avoid KeyError in update_needs
     initial_needs = {
-        "survival": 50.0, "survival_need": 50.0,
+        "survival": 50.0,
+        "survival_need": 50.0,
         "asset": 10.0,
         "social": 10.0,
-        "improvement": 10.0
+        "improvement": 10.0,
     }
 
     hh1 = Mock(spec=Household)
@@ -156,7 +160,7 @@ def mock_households(mock_config_module):
     hh1.is_employed = False
     hh1.employer_id = None
     hh1.skills = {}
-    hh1.config_module = mock_config_module # Attach config
+    hh1.config_module = mock_config_module  # Attach config
     # Mock update_needs to avoid key error if called during simulation init
     hh1.update_needs = Mock()
     hh1.talent = Mock(spec=Talent)
@@ -201,7 +205,7 @@ def mock_firms(mock_config_module):
     f1.is_active = True
     f1.total_shares = 1000.0
     f1.treasury_shares = 0.0
-    f1.age = 25 # Set age for testing
+    f1.age = 25  # Set age for testing
 
     f2 = Firm(
         id=102,
@@ -217,7 +221,7 @@ def mock_firms(mock_config_module):
     f2.is_active = False  # Inactive firm
     f2.total_shares = 1000.0
     f2.treasury_shares = 0.0
-    f2.age = 25 # Set age for testing
+    f2.age = 25  # Set age for testing
     return [f1, f2]
 
 
@@ -255,6 +259,7 @@ def mock_repository():
     repo.get_latest_economic_indicator = MagicMock(return_value=None)
     return repo
 
+
 @pytest.fixture
 def mock_tracker(mock_repository):
     mock_config = Mock()
@@ -387,7 +392,6 @@ class TestSimulation:
         assert market_data["goods_market"]["basic_food_current_sell_price"] == 12.0
         assert market_data["avg_goods_price"] == pytest.approx((10.0 + 30.0 + 12.0) / 3)
 
-
     def test_process_transactions_goods_trade(
         self, simulation_instance, mock_households, mock_firms
     ):
@@ -404,7 +408,7 @@ class TestSimulation:
         tx.item_id = "basic_food"
         tx.quantity = 5.0
         tx.price = 10.0
-        tx.quality = 1.0 # Ensure quality is a float
+        tx.quality = 1.0  # Ensure quality is a float
         tx.transaction_type = "goods"
 
         simulation_instance._process_transactions([tx])
@@ -452,7 +456,9 @@ class TestSimulation:
         tax = trade_value * simulation_instance.config_module.INCOME_TAX_RATE
 
         assert buyer_firm.assets == initial_buyer_assets - trade_value
-        assert seller_hh.assets == pytest.approx(initial_seller_assets + (trade_value - tax))
+        assert seller_hh.assets == pytest.approx(
+            initial_seller_assets + (trade_value - tax)
+        )
         assert seller_hh.is_employed is True
         assert seller_hh.employer_id == buyer_firm.id
         assert seller_hh.needs["labor_need"] == 0.0
@@ -551,10 +557,11 @@ def setup_simulation_for_lifecycle(
 ):
     # Prepare initial needs with 'survival' and other keys to avoid KeyError in update_needs
     initial_needs = {
-        "survival": 50.0, "survival_need": 50.0,
+        "survival": 50.0,
+        "survival_need": 50.0,
         "asset": 10.0,
         "social": 10.0,
-        "improvement": 10.0
+        "improvement": 10.0,
     }
 
     household_active = Household(
@@ -708,18 +715,18 @@ def test_handle_agent_lifecycle_removes_inactive_agents(setup_simulation_for_lif
         markets=sim.markets,
         government=sim.government,
         bank=sim.bank,
-        central_bank=sim.central_bank if hasattr(sim, 'central_bank') else None,
-        stock_market=sim.stock_market if hasattr(sim, 'stock_market') else None,
+        central_bank=sim.central_bank if hasattr(sim, "central_bank") else None,
+        stock_market=sim.stock_market if hasattr(sim, "stock_market") else None,
         goods_data=sim.goods_data,
         market_data={},
         config_module=sim.config_module,
         tracker=sim.tracker,
         logger=sim.logger,
-        reflux_system=getattr(sim, 'reflux_system', None),
-        ai_training_manager=getattr(sim, 'ai_training_manager', None),
-        ai_trainer=getattr(sim, 'ai_trainer', None),
-        next_agent_id=getattr(sim, 'next_agent_id', 0),
-        real_estate_units=getattr(sim, 'real_estate_units', [])
+        reflux_system=getattr(sim, "reflux_system", None),
+        ai_training_manager=getattr(sim, "ai_training_manager", None),
+        ai_trainer=getattr(sim, "ai_trainer", None),
+        next_agent_id=getattr(sim, "next_agent_id", 0),
+        real_estate_units=getattr(sim, "real_estate_units", []),
     )
 
     sim.lifecycle_manager._handle_agent_liquidation(state)
diff --git a/tests/test_finance_bailout.py b/tests/test_finance_bailout.py
index 8e8a35e..316a5b6 100644
--- a/tests/test_finance_bailout.py
+++ b/tests/test_finance_bailout.py
@@ -4,25 +4,35 @@ from unittest.mock import Mock, MagicMock
 from modules.finance.api import BailoutCovenant, BailoutLoanDTO, InsufficientFundsError
 from modules.finance.system import FinanceSystem
 
+
 # A simple stub class for config attributes
 class MockConfig:
     BAILOUT_PENALTY_PREMIUM = 0.05
     BAILOUT_REPAYMENT_RATIO = 0.5
 
+    def get(self, key, default=None):
+        if key == "economy_params.BAILOUT_PENALTY_PREMIUM":
+            return self.BAILOUT_PENALTY_PREMIUM
+        if key == "economy_params.BAILOUT_COVENANT_RATIO":
+            return self.BAILOUT_REPAYMENT_RATIO
+        return default
+
+
 @pytest.fixture
 def finance_test_environment():
     """Sets up a test environment with mocked financial entities."""
     mock_government = Mock()
-    mock_government._assets = 1_000_000  # Starting with 1M in assets
+    mock_government.assets = 1_000_000  # Set attribute directly
 
     # We need to mock the withdraw/deposit methods to simulate transactions
     def withdraw(amount):
         if mock_government.assets >= amount:
-            mock_government._assets -= amount
+            mock_government.assets -= amount
         else:
             raise InsufficientFundsError("Not enough assets.")
+
     def deposit(amount):
-        mock_government._assets += amount
+        mock_government.assets += amount
 
     mock_government.withdraw.side_effect = withdraw
     mock_government.deposit.side_effect = deposit
@@ -35,7 +45,7 @@ def finance_test_environment():
     # Mock the Firm and its departments
     mock_firm = Mock()
     mock_firm.id = 1
-    mock_firm._assets = 100_000
+    mock_firm.assets = 100_000  # Set attribute directly
     mock_firm.total_debt = 0.0
     mock_firm.has_bailout_loan = False
 
@@ -44,7 +54,7 @@ def finance_test_environment():
 
     def add_liability_side_effect(amount, interest_rate):
         # Simulate the firm receiving cash and taking on debt
-        mock_firm._assets += amount
+        mock_firm.assets += amount
         mock_firm.total_debt += amount
 
     mock_firm.finance.add_liability.side_effect = add_liability_side_effect
@@ -53,19 +63,21 @@ def finance_test_environment():
     def firm_deposit(amount):
         # This is separate from add_liability; it just handles the cash transfer part.
         # The liability logic is handled in the mocked add_liability.
-        pass # In the real code, add_liability handles the asset increase.
-             # In our mock, the side_effect for add_liability handles it, so we do nothing here.
+        pass  # In the real code, add_liability handles the asset increase.
+        # In our mock, the side_effect for add_liability handles it, so we do nothing here.
 
     mock_firm.deposit.side_effect = firm_deposit
 
-
     config = MockConfig()
 
     # Instantiate the system with mocks
-    finance_system = FinanceSystem(mock_government, mock_central_bank, mock_bank, config)
+    finance_system = FinanceSystem(
+        mock_government, mock_central_bank, mock_bank, config
+    )
 
     return finance_system, mock_government, mock_firm
 
+
 def test_grant_bailout_loan_success_and_covenant_type(finance_test_environment):
     """
     Tests that a bailout loan is granted successfully, all money flows are correct,
@@ -78,7 +90,10 @@ def test_grant_bailout_loan_success_and_covenant_type(finance_test_environment):
     loan_amount = 50_000
 
     # Act
-    loan_dto = finance_system.grant_bailout_loan(mock_firm, loan_amount)
+    # Updated for Transaction-based logic (WO-116/Phase 3)
+    loan_dto, transactions = finance_system.grant_bailout_loan(
+        mock_firm, loan_amount, current_tick=0
+    )
 
     # Assert - DTO and Covenant Type
     assert loan_dto is not None
@@ -87,53 +102,61 @@ def test_grant_bailout_loan_success_and_covenant_type(finance_test_environment):
     assert loan_dto.covenants.dividends_allowed is False
     assert loan_dto.covenants.mandatory_repayment == 0.5
 
+    # Assert - Transactions
+    assert len(transactions) == 1
+    assert transactions[0].transaction_type == "bailout_loan"
+    assert transactions[0].price == loan_amount
+    assert transactions[0].buyer_id == mock_government.id
+    assert transactions[0].seller_id == mock_firm.id
+
     # Assert - Money Flow Verification
-    # 1. Government assets should decrease
-    assert mock_government.assets == initial_govt_assets - loan_amount
-    # 2. Firm should have received the funds and taken on the liability
-    mock_firm.finance.add_liability.assert_called_once()
+    # 1. Government assets should NOT decrease yet (Transaction not executed)
+    assert mock_government.assets == initial_govt_assets
+
+    # 2. Firm should have taken on the liability (Optimistic Update)
+    # WO-116: add_liability is NO LONGER called to avoid double cash addition.
+    # Check that debt was updated directly on the firm object.
+    # mock_firm.finance.add_liability.assert_called_once()
+
     # 3. Verify firm's final state
-    assert mock_firm.assets == initial_firm_assets + loan_amount
+    # Assets should NOT change yet (Transaction pending)
+    assert mock_firm.assets == initial_firm_assets
+    # Debt should be updated immediately
     assert mock_firm.total_debt == initial_firm_debt + loan_amount
+
     # 4. Firm should be marked as having a bailout loan
     assert mock_firm.has_bailout_loan is True
 
-    # Assert - Regression check for money creation/destruction
-    final_total_assets = mock_government.assets + mock_firm.assets
-    initial_total_assets = initial_govt_assets + initial_firm_assets
-    assert final_total_assets == initial_total_assets
-
 
 def test_grant_bailout_loan_insufficient_government_funds(finance_test_environment):
     """
-    Tests that the bailout loan is not granted if the government has insufficient funds.
+    Tests that the bailout loan IS granted (as Transaction) even if funds insufficient
+    (TransactionProcessor handles failure, or Gov goes into debt).
+    FinanceSystem no longer enforces immediate solvency check on Gov.
     """
     finance_system, mock_government, mock_firm = finance_test_environment
 
     # Arrange: Government has less money than the loan amount
     loan_amount = 2_000_000
-    mock_government._assets = 1_000_000 # Government has 1M, loan is 2M
+    mock_government.assets = 1_000_000  # Government has 1M, loan is 2M
 
     initial_govt_assets = mock_government.assets
     initial_firm_assets = mock_firm.assets
     initial_firm_debt = mock_firm.total_debt
 
-    # Redefine the side effect for this specific test case to raise the error
-    def limited_withdraw(amount):
-        if mock_government.assets < amount:
-            raise InsufficientFundsError("Test: Not enough funds")
-        mock_government._assets -= amount
-    mock_government.withdraw.side_effect = limited_withdraw
-
     # Act
-    loan_dto = finance_system.grant_bailout_loan(mock_firm, loan_amount)
+    # Updated for Transaction-based logic
+    loan_dto, transactions = finance_system.grant_bailout_loan(
+        mock_firm, loan_amount, current_tick=0
+    )
 
     # Assert
-    # 1. No loan DTO should be returned
-    assert loan_dto is None
-    # 2. No money should have moved
+    # 1. Loan DTO should be returned (Optimistic creation)
+    assert loan_dto is not None
+    assert len(transactions) == 1
+
+    # 2. Money should NOT have moved from Gov (Transaction pending)
     assert mock_government.assets == initial_govt_assets
-    assert mock_firm.assets == initial_firm_assets
-    assert mock_firm.total_debt == initial_firm_debt
-    # 3. Firm should not be marked as having a loan
-    assert mock_firm.has_bailout_loan is False
+
+    # 3. Firm Optimistic Update should have happened
+    assert mock_firm.has_bailout_loan is True
diff --git a/tests/test_firm_decision_engine.py b/tests/test_firm_decision_engine.py
index fdf999b..b40dbec 100644
--- a/tests/test_firm_decision_engine.py
+++ b/tests/test_firm_decision_engine.py
@@ -73,7 +73,8 @@ def test_firm_production_decision_with_employees(sample_firm, sample_market_data
     employee2 = MockHousehold(id=102, labor_skill=0.8)
     sample_firm.employees = [employee1, employee2]
     sample_firm.decision_engine.ai_engine.decide_action_vector.return_value = (
-        Tactic.ADJUST_WAGES, Aggressiveness.NORMAL
+        Tactic.ADJUST_WAGES,
+        Aggressiveness.NORMAL,
     )
 
     # Call make_decisions
@@ -115,7 +116,8 @@ def test_firm_no_production_if_target_met(sample_firm, sample_market_data):
     sample_firm.inventory[sample_firm.specialization] = 150.0  # Above target of 100
     sample_firm.employees = []  # Ensure no employees are present to focus on inventory decision
     sample_firm.decision_engine.ai_engine.decide_action_vector.return_value = (
-        Tactic.ADJUST_PRICE, Aggressiveness.NORMAL
+        Tactic.ADJUST_PRICE,
+        Aggressiveness.NORMAL,
     )
 
     context = DecisionContext(
@@ -156,7 +158,8 @@ def test_firm_hiring_decision_no_inventory(sample_firm, sample_market_data):
     sample_firm.inventory[sample_firm.specialization] = 0.0
     sample_firm.employees = []  # No employees
     sample_firm.decision_engine.ai_engine.decide_action_vector.return_value = (
-        Tactic.ADJUST_WAGES, Aggressiveness.NORMAL
+        Tactic.ADJUST_WAGES,
+        Aggressiveness.NORMAL,
     )
 
     context = DecisionContext(
@@ -188,4 +191,4 @@ def test_firm_hiring_decision_no_inventory(sample_firm, sample_market_data):
         for order in orders
         if order.order_type == "SELL" and order.market_id == "goods_market"
     ]
-    assert len(sell_orders) == 0, "Expected no SELL orders when inventory is 0"
\ No newline at end of file
+    assert len(sell_orders) == 0, "Expected no SELL orders when inventory is 0"
diff --git a/tests/test_firm_decision_engine_new.py b/tests/test_firm_decision_engine_new.py
index 530eb63..32f7e5a 100644
--- a/tests/test_firm_decision_engine_new.py
+++ b/tests/test_firm_decision_engine_new.py
@@ -31,9 +31,7 @@ def mock_config():
     mock_cfg.FIRM_MIN_EMPLOYEES = 1
     mock_cfg.FIRM_MAX_EMPLOYEES = 50
     mock_cfg.BASE_WAGE = 10.0
-    mock_cfg.GOODS = {
-        "food": {"production_cost": 5.0}
-    }
+    mock_cfg.GOODS = {"food": {"production_cost": 5.0}}
     mock_cfg.GOODS_MARKET_SELL_PRICE = 5.0
     mock_cfg.MIN_SELL_PRICE = 1.0
     mock_cfg.MAX_SELL_PRICE = 100.0
@@ -95,16 +93,20 @@ def mock_firm(mock_config):
     firm.hr.employees = []
     firm.hr.employee_wages = {}
     firm.treasury_shares = 1000.0
-    firm.research_history = {"total_spent": 0.0, "success_count": 0, "last_success_tick": 0}
+    firm.research_history = {
+        "total_spent": 0.0,
+        "success_count": 0,
+        "last_success_tick": 0,
+    }
     firm.base_quality = 1.0
     firm.sales = Mock()
-    firm.production = Mock() # Add production mock
+    firm.production = Mock()  # Add production mock
     firm.production.set_automation_level = Mock()
     firm.production.add_capital = Mock()
     firm.automation_level = 0.0
     firm.capital_stock = 100.0
     firm.system2_planner = Mock()
-    firm.system2_planner.project_future.return_value = {} # Default guidance
+    firm.system2_planner.project_future.return_value = {}  # Default guidance
 
     # Mock get_agent_data for AI
     firm.get_agent_data.return_value = {}
@@ -122,7 +124,7 @@ def mock_ai_engine():
         rd_aggressiveness=0.5,
         capital_aggressiveness=0.5,
         dividend_aggressiveness=0.5,
-        debt_aggressiveness=0.5
+        debt_aggressiveness=0.5,
     )
     return ai
 
@@ -147,7 +149,7 @@ class TestFirmDecisionEngine:
     def test_make_decisions_overstock_reduces_target(
         self, firm_decision_engine_instance, mock_firm, mock_config
     ):
-        mock_firm.inventory["food"] = 150.0 # Force overstock (150 > 100 * 1.2)
+        mock_firm.inventory["food"] = 150.0  # Force overstock (150 > 100 * 1.2)
         initial_target = mock_firm.production_target
 
         context = DecisionContext(
@@ -267,9 +269,15 @@ class TestFirmDecisionEngine:
         # If inventory is low, decay is closer to 1.0 or 1.0.
         # But if aggressiveness is low (0.0 -> High Margin), price goes UP.
         # Let's set aggressiveness to 0.0 (High Margin Strategy)
-        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = FirmActionVector(
-            sales_aggressiveness=0.0, # High Margin -> High Price
-            hiring_aggressiveness=0.5,rd_aggressiveness=0.5,capital_aggressiveness=0.5,dividend_aggressiveness=0.5,debt_aggressiveness=0.5
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
+            FirmActionVector(
+                sales_aggressiveness=0.0,  # High Margin -> High Price
+                hiring_aggressiveness=0.5,
+                rd_aggressiveness=0.5,
+                capital_aggressiveness=0.5,
+                dividend_aggressiveness=0.5,
+                debt_aggressiveness=0.5,
+            )
         )
 
         context = DecisionContext(
@@ -295,7 +303,7 @@ class TestFirmDecisionEngine:
 
         context = DecisionContext(
             firm=mock_firm,
-            markets={"food": Mock()}, # Market must exist
+            markets={"food": Mock()},  # Market must exist
             goods_data=[],
             market_data={},
             current_time=1,
@@ -320,12 +328,18 @@ class TestFirmDecisionEngine:
         # Assume high gap to force hiring.
         mock_firm.production_target = 100.0
         mock_firm.inventory["food"] = 0.0
-        mock_firm.hr.employees = [] # 0 Employees
+        mock_firm.hr.employees = []  # 0 Employees
 
         # 2. Aggressiveness for Hiring = 0.8 (High)
-        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = FirmActionVector(
-            hiring_aggressiveness=0.8,
-            sales_aggressiveness=0.5, rd_aggressiveness=0.5, capital_aggressiveness=0.5, dividend_aggressiveness=0.5, debt_aggressiveness=0.5
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
+            FirmActionVector(
+                hiring_aggressiveness=0.8,
+                sales_aggressiveness=0.5,
+                rd_aggressiveness=0.5,
+                capital_aggressiveness=0.5,
+                dividend_aggressiveness=0.5,
+                debt_aggressiveness=0.5,
+            )
         )
 
         context = DecisionContext(
@@ -341,9 +355,11 @@ class TestFirmDecisionEngine:
         orders, _ = firm_decision_engine_instance.make_decisions(context)
 
         # 4. Verification
-        labor_orders = [o for o in orders if o.item_id == "labor" and o.order_type == "BUY"]
+        labor_orders = [
+            o for o in orders if o.item_id == "labor" and o.order_type == "BUY"
+        ]
         assert len(labor_orders) > 0
-        assert labor_orders[0].price > 10.0 # High aggressiveness bids up wage
+        assert labor_orders[0].price > 10.0  # High aggressiveness bids up wage
         assert labor_orders[0].quantity > 0
 
     def test_make_decisions_does_not_hire_when_full(
@@ -356,9 +372,15 @@ class TestFirmDecisionEngine:
         # Assume 10 employees is enough for target 10
         mock_firm.hr.employees = [Mock(id=i, labor_skill=1.0) for i in range(100)]
 
-        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = FirmActionVector(
-            hiring_aggressiveness=0.5,
-            sales_aggressiveness=0.5, rd_aggressiveness=0.5, capital_aggressiveness=0.5, dividend_aggressiveness=0.5, debt_aggressiveness=0.5
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
+            FirmActionVector(
+                hiring_aggressiveness=0.5,
+                sales_aggressiveness=0.5,
+                rd_aggressiveness=0.5,
+                capital_aggressiveness=0.5,
+                dividend_aggressiveness=0.5,
+                debt_aggressiveness=0.5,
+            )
         )
 
         context = DecisionContext(
@@ -372,7 +394,9 @@ class TestFirmDecisionEngine:
 
         orders, _ = firm_decision_engine_instance.make_decisions(context)
 
-        labor_orders = [o for o in orders if o.item_id == "labor" and o.order_type == "BUY"]
+        labor_orders = [
+            o for o in orders if o.item_id == "labor" and o.order_type == "BUY"
+        ]
         assert len(labor_orders) == 0
 
     def test_make_decisions_fires_excess_labor(
@@ -380,8 +404,8 @@ class TestFirmDecisionEngine:
     ):
         """Verify emp.quit() is called via finance.pay_severance when overstaffed."""
         # 1. Setup Overstaffed Firm
-        mock_firm.production_target = 0.0 # No production needed
-        mock_firm.inventory["food"] = 100.0 # Full inventory
+        mock_firm.production_target = 0.0  # No production needed
+        mock_firm.inventory["food"] = 100.0  # Full inventory
         # 2 Employees, 1 Needed (Skeleton Crew)
         employee1 = Mock(id=1, labor_skill=1.0)
         employee1.quit = Mock()
@@ -394,9 +418,15 @@ class TestFirmDecisionEngine:
         # Mock Finance to allow severance
         mock_firm.finance.pay_severance.return_value = True
 
-        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = FirmActionVector(
-            hiring_aggressiveness=0.5,
-            sales_aggressiveness=0.5, rd_aggressiveness=0.5, capital_aggressiveness=0.5, dividend_aggressiveness=0.5, debt_aggressiveness=0.5
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
+            FirmActionVector(
+                hiring_aggressiveness=0.5,
+                sales_aggressiveness=0.5,
+                rd_aggressiveness=0.5,
+                capital_aggressiveness=0.5,
+                dividend_aggressiveness=0.5,
+                debt_aggressiveness=0.5,
+            )
         )
 
         context = DecisionContext(
@@ -433,28 +463,50 @@ class TestFirmDecisionEngine:
         )
 
         # 1. Low Aggressiveness (0.1) -> High Margin -> Higher Price
-        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = FirmActionVector(sales_aggressiveness=0.1, hiring_aggressiveness=0.5, rd_aggressiveness=0.5, capital_aggressiveness=0.5, dividend_aggressiveness=0.5, debt_aggressiveness=0.5)
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
+            FirmActionVector(
+                sales_aggressiveness=0.1,
+                hiring_aggressiveness=0.5,
+                rd_aggressiveness=0.5,
+                capital_aggressiveness=0.5,
+                dividend_aggressiveness=0.5,
+                debt_aggressiveness=0.5,
+            )
+        )
         firm_decision_engine_instance.make_decisions(context)
         args_low_agg, _ = mock_firm.sales.post_ask.call_args
         price_low_agg = args_low_agg[1]
 
         # 2. High Aggressiveness (0.9) -> High Volume -> Lower Price
-        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = FirmActionVector(sales_aggressiveness=0.9, hiring_aggressiveness=0.5, rd_aggressiveness=0.5, capital_aggressiveness=0.5, dividend_aggressiveness=0.5, debt_aggressiveness=0.5)
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
+            FirmActionVector(
+                sales_aggressiveness=0.9,
+                hiring_aggressiveness=0.5,
+                rd_aggressiveness=0.5,
+                capital_aggressiveness=0.5,
+                dividend_aggressiveness=0.5,
+                debt_aggressiveness=0.5,
+            )
+        )
         firm_decision_engine_instance.make_decisions(context)
         args_high_agg, _ = mock_firm.sales.post_ask.call_args
         price_high_agg = args_high_agg[1]
 
         assert price_low_agg > price_high_agg
 
-    def test_rd_investment(
-        self, firm_decision_engine_instance, mock_firm, mock_config
-    ):
+    def test_rd_investment(self, firm_decision_engine_instance, mock_firm, mock_config):
         """Verify R&D investment when aggressiveness is high."""
         # Setup High Cash
         mock_firm._assets = 100000.0
-        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = FirmActionVector(
-            rd_aggressiveness=0.9,
-            sales_aggressiveness=0.5, hiring_aggressiveness=0.5, capital_aggressiveness=0.5, dividend_aggressiveness=0.5, debt_aggressiveness=0.5
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
+            FirmActionVector(
+                rd_aggressiveness=0.9,
+                sales_aggressiveness=0.5,
+                hiring_aggressiveness=0.5,
+                capital_aggressiveness=0.5,
+                dividend_aggressiveness=0.5,
+                debt_aggressiveness=0.5,
+            )
         )
 
         context = DecisionContext(
@@ -476,9 +528,15 @@ class TestFirmDecisionEngine:
         """Verify Capex investment when aggressiveness is high."""
         # Setup High Cash
         mock_firm._assets = 100000.0
-        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = FirmActionVector(
-            capital_aggressiveness=0.9,
-            sales_aggressiveness=0.5, hiring_aggressiveness=0.5, rd_aggressiveness=0.5, dividend_aggressiveness=0.5, debt_aggressiveness=0.5
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
+            FirmActionVector(
+                capital_aggressiveness=0.9,
+                sales_aggressiveness=0.5,
+                hiring_aggressiveness=0.5,
+                rd_aggressiveness=0.5,
+                dividend_aggressiveness=0.5,
+                debt_aggressiveness=0.5,
+            )
         )
 
         context = DecisionContext(
@@ -488,7 +546,7 @@ class TestFirmDecisionEngine:
             market_data={},
             current_time=1,
             government=None,
-            reflux_system=Mock() # Reflux system needed for capex
+            reflux_system=Mock(),  # Reflux system needed for capex
         )
 
         firm_decision_engine_instance.make_decisions(context)
@@ -500,12 +558,18 @@ class TestFirmDecisionEngine:
     ):
         """Verify dividend rate setting based on aggressiveness."""
         # Setup Healthy Firm
-        mock_firm.finance.calculate_altman_z_score.return_value = 5.0 # Healthy
+        mock_firm.finance.calculate_altman_z_score.return_value = 5.0  # Healthy
         mock_firm.finance.consecutive_loss_turns = 0
 
-        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = FirmActionVector(
-            dividend_aggressiveness=0.9, # High Payout
-            sales_aggressiveness=0.5, hiring_aggressiveness=0.5, rd_aggressiveness=0.5, capital_aggressiveness=0.5, debt_aggressiveness=0.5
+        firm_decision_engine_instance.ai_engine.decide_action_vector.return_value = (
+            FirmActionVector(
+                dividend_aggressiveness=0.9,  # High Payout
+                sales_aggressiveness=0.5,
+                hiring_aggressiveness=0.5,
+                rd_aggressiveness=0.5,
+                capital_aggressiveness=0.5,
+                debt_aggressiveness=0.5,
+            )
         )
 
         context = DecisionContext(
@@ -523,4 +587,4 @@ class TestFirmDecisionEngine:
         # Verify rate is high
         args, _ = mock_firm.finance.set_dividend_rate.call_args
         rate = args[0]
-        assert rate > 0.1 # Should be significantly higher than min
+        assert rate > 0.1  # Should be significantly higher than min
diff --git a/tests/test_firms.py b/tests/test_firms.py
index 743866f..292a19c 100644
--- a/tests/test_firms.py
+++ b/tests/test_firms.py
@@ -1,4 +1,3 @@
-
 import pytest
 from unittest.mock import Mock, MagicMock
 import math
@@ -6,6 +5,7 @@ from simulation.firms import Firm
 from simulation.components.production_department import ProductionDepartment
 from simulation.components.sales_department import SalesDepartment
 
+
 class TestFirmBookValue:
     @pytest.fixture
     def mock_decision_engine(self):
@@ -33,7 +33,7 @@ class TestFirmBookValue:
             productivity_factor=1.0,
             decision_engine=mock_decision_engine,
             value_orientation="PROFIT",
-            config_module=mock_config
+            config_module=mock_config,
         )
 
     def test_book_value_no_liabilities(self, firm):
@@ -61,7 +61,7 @@ class TestFirmBookValue:
         assert firm.finance.get_book_value_per_share() == 12.5
 
     def test_book_value_negative_net_assets(self, firm, mock_decision_engine):
-         # Setup Huge Liabilities
+        # Setup Huge Liabilities
         mock_loan_market = Mock()
         mock_bank = Mock()
         mock_decision_engine.loan_market = mock_loan_market
@@ -79,6 +79,7 @@ class TestFirmBookValue:
         firm.treasury_shares = 0.0
         assert firm.finance.get_book_value_per_share() == 0.0
 
+
 class TestProductionDepartment:
     @pytest.fixture
     def mock_config(self):
@@ -118,9 +119,14 @@ class TestProductionDepartment:
         # Replicate the quality calculation to get the expected value
         avg_skill = firm.hr.get_avg_skill.return_value
         quality_sensitivity = mock_config.GOODS["test"]["quality_sensitivity"]
-        expected_quality = firm.base_quality + (math.log1p(avg_skill) * quality_sensitivity)
+        expected_quality = firm.base_quality + (
+            math.log1p(avg_skill) * quality_sensitivity
+        )
+
+        firm.add_inventory.assert_called_once_with(
+            "test", produced_quantity, expected_quality
+        )
 
-        firm.add_inventory.assert_called_once_with("test", produced_quantity, expected_quality)
 
 class TestSalesDepartment:
     @pytest.fixture
@@ -142,7 +148,7 @@ class TestSalesDepartment:
         firm.brand_manager.brand_awareness = 0.5
         firm.inventory_quality = {}
         firm.marketing_budget = 100.0
-        firm.finance.last_marketing_spend = 50.0 # Lower spend last tick
+        firm.finance.last_marketing_spend = 50.0  # Lower spend last tick
         firm.finance.revenue_this_turn = 200.0
         firm.finance.last_revenue = 100.0
         firm.marketing_budget_rate = 0.1
@@ -172,8 +178,8 @@ class TestSalesDepartment:
 
     def test_adjust_marketing_budget_decrease(self, firm, mock_config):
         # Low ROI should decrease the budget rate
-        firm.finance.last_marketing_spend = 200.0 # High spend
-        firm.finance.revenue_this_turn = 110.0 # Low return
+        firm.finance.last_marketing_spend = 200.0  # High spend
+        firm.finance.revenue_this_turn = 110.0  # Low return
         firm.finance.last_revenue = 100.0
 
         sales_dept = SalesDepartment(firm, mock_config)
diff --git a/tests/test_fiscal_policy.py b/tests/test_fiscal_policy.py
index cc94e64..1d932e1 100644
--- a/tests/test_fiscal_policy.py
+++ b/tests/test_fiscal_policy.py
@@ -4,9 +4,18 @@ from simulation.dtos import GovernmentStateDTO
 
 # Note: The 'government', 'mock_config', 'mock_central_bank' fixtures are provided by tests/conftest.py
 
+
 def test_potential_gdp_ema_convergence(government, mock_central_bank):
     """Test that potential GDP converges using EMA."""
-    dto = GovernmentStateDTO(tick=1, current_gdp=1000.0, inflation_sma=0.02, unemployment_sma=0.05, gdp_growth_sma=0.01, wage_sma=100, approval_sma=0.5)
+    dto = GovernmentStateDTO(
+        tick=1,
+        current_gdp=1000.0,
+        inflation_sma=0.02,
+        unemployment_sma=0.05,
+        gdp_growth_sma=0.01,
+        wage_sma=100,
+        approval_sma=0.5,
+    )
     government.update_sensory_data(dto)
 
     # Initial GDP: The old test was wrong. The EMA calculation runs on the first step.
@@ -25,42 +34,72 @@ def test_potential_gdp_ema_convergence(government, mock_central_bank):
     # new = (0.01 * 2000) + (0.99 * 980.2) = 20 + 970.398 = 990.398
     assert abs(government.potential_gdp - 980.5) < 0.01
 
-def test_counter_cyclical_tax_adjustment_recession(government, mock_config, mock_central_bank):
+
+def test_counter_cyclical_tax_adjustment_recession(
+    government, mock_config, mock_central_bank
+):
     """Test Fiscal Expansion during Recession (GDP < Potential)."""
     mock_config.AUTO_COUNTER_CYCLICAL_ENABLED = True
     government.potential_gdp = 1000.0
     initial_tax_rate = government.income_tax_rate
-    dto = GovernmentStateDTO(tick=1, current_gdp=800.0, inflation_sma=0.02, unemployment_sma=0.05, gdp_growth_sma=0.01, wage_sma=100, approval_sma=0.5)
+    dto = GovernmentStateDTO(
+        tick=1,
+        current_gdp=800.0,
+        inflation_sma=0.02,
+        unemployment_sma=0.05,
+        gdp_growth_sma=0.01,
+        wage_sma=100,
+        approval_sma=0.5,
+    )
     government.update_sensory_data(dto)
 
     # Sudden drop in current GDP (Recession)
     government.make_policy_decision({}, 1, mock_central_bank)
 
-    assert government.fiscal_stance > 0 # Expansionary
+    assert government.fiscal_stance > 0  # Expansionary
     assert government.income_tax_rate < initial_tax_rate
 
-def test_counter_cyclical_tax_adjustment_boom(government, mock_config, mock_central_bank):
+
+def test_counter_cyclical_tax_adjustment_boom(
+    government, mock_config, mock_central_bank
+):
     """Test Fiscal Contraction during Boom (GDP > Potential)."""
     mock_config.AUTO_COUNTER_CYCLICAL_ENABLED = True
     government.potential_gdp = 1000.0
     initial_tax_rate = government.income_tax_rate
-    dto = GovernmentStateDTO(tick=1, current_gdp=1200.0, inflation_sma=0.02, unemployment_sma=0.05, gdp_growth_sma=0.01, wage_sma=100, approval_sma=0.5)
+    dto = GovernmentStateDTO(
+        tick=1,
+        current_gdp=1200.0,
+        inflation_sma=0.02,
+        unemployment_sma=0.05,
+        gdp_growth_sma=0.01,
+        wage_sma=100,
+        approval_sma=0.5,
+    )
     government.update_sensory_data(dto)
 
     # Sudden rise in current GDP (Boom)
     government.make_policy_decision({}, 1, mock_central_bank)
 
-    assert government.fiscal_stance < 0 # Contractionary
+    assert government.fiscal_stance < 0  # Contractionary
     assert government.income_tax_rate > initial_tax_rate
 
+
 def test_debt_ceiling_enforcement(government):
     """Test that spending is blocked when Debt Ceiling is hit."""
     government._assets = 0.0
     government.total_debt = 0.0
     government.potential_gdp = 1000.0
     # From config, Debt Ceiling Ratio is 2.0, so ceiling is 2000.0
-    government.sensory_data = GovernmentStateDTO(tick=0, current_gdp=1000.0, inflation_sma=0.02, unemployment_sma=0.05, gdp_growth_sma=0.01, wage_sma=100, approval_sma=0.5)
-
+    government.sensory_data = GovernmentStateDTO(
+        tick=0,
+        current_gdp=1000.0,
+        inflation_sma=0.02,
+        unemployment_sma=0.05,
+        gdp_growth_sma=0.01,
+        wage_sma=100,
+        approval_sma=0.5,
+    )
 
     agent = Mock()
     agent.id = 123
@@ -71,9 +110,11 @@ def test_debt_ceiling_enforcement(government):
     # by the amount of the bond. A simple mock doesn't do this.
     def issue_bonds_side_effect(amount, tick):
         government._assets += amount
-        return [Mock()] # Return a successful bond issuance
+        return [Mock()]  # Return a successful bond issuance
 
-    government.finance_system.issue_treasury_bonds = Mock(side_effect=issue_bonds_side_effect)
+    government.finance_system.issue_treasury_bonds = Mock(
+        side_effect=issue_bonds_side_effect
+    )
 
     # 1. Spend within limit
     amount = 500.0
@@ -90,17 +131,20 @@ def test_debt_ceiling_enforcement(government):
     assert government.assets == 0.0
 
     # 3. Try to spend when bond issuance fails
-    government.finance_system.issue_treasury_bonds.side_effect = None # Disable the side effect
+    government.finance_system.issue_treasury_bonds.side_effect = (
+        None  # Disable the side effect
+    )
     government.finance_system.issue_treasury_bonds.return_value = []
     amount = 100.0
     paid = government.provide_household_support(agent, amount, current_tick=3)
     assert paid == 0.0
 
+
 def test_calculate_income_tax_uses_current_rate(government, mock_config):
     """Verify income tax calculation uses the current government rate."""
     government.income_tax_rate = 0.05  # Set a specific rate
     mock_config.TAX_MODE = "FLAT"
-    mock_config.INCOME_TAX_RATE = 0.20 # Make sure the gov't's own rate is used
+    mock_config.INCOME_TAX_RATE = 0.20  # Make sure the gov't's own rate is used
 
     income = 100.0
     tax = government.calculate_income_tax(income, survival_cost=10.0)
diff --git a/tests/test_generational_wealth_audit.py b/tests/test_generational_wealth_audit.py
index c61a9d5..ebbd909 100644
--- a/tests/test_generational_wealth_audit.py
+++ b/tests/test_generational_wealth_audit.py
@@ -3,6 +3,7 @@ from unittest.mock import MagicMock, patch
 from simulation.systems.generational_wealth_audit import GenerationalWealthAudit
 from simulation.core_agents import Household
 
+
 class TestGenerationalWealthAudit(unittest.TestCase):
     def setUp(self):
         self.config_module = MagicMock()
@@ -16,7 +17,7 @@ class TestGenerationalWealthAudit(unittest.TestCase):
         mock_household.is_active = True
         return mock_household
 
-    @patch('logging.Logger.info')
+    @patch("logging.Logger.info")
     def test_run_audit(self, mock_log_info):
         # Create mock agents
         agent1 = self.create_mock_household(1, 1000, 1)
@@ -33,19 +34,23 @@ class TestGenerationalWealthAudit(unittest.TestCase):
 
         # Check the log message
         expected_log_message = "GENERATIONAL_WEALTH_AUDIT | Tick: 100 | Total Wealth: 6000.00 | Total Agents: 3\n"
-        expected_log_message += "  - Gen 1: 2 agents, Total Wealth: 4000.00 (66.67%), Avg Wealth: 2000.00\n"
-        expected_log_message += "  - Gen 2: 1 agents, Total Wealth: 2000.00 (33.33%), Avg Wealth: 2000.00"
+        expected_log_message += (
+            "  - Gen 1: 2 agents, Total Wealth: 4000.00 (66.67%), Avg Wealth: 2000.00\n"
+        )
+        expected_log_message += (
+            "  - Gen 2: 1 agents, Total Wealth: 2000.00 (33.33%), Avg Wealth: 2000.00"
+        )
 
         # Get the actual log message
         actual_log_message = mock_log_info.call_args[0][0]
 
         # Normalize the log messages for comparison
-        normalized_expected = ' '.join(expected_log_message.split())
-        normalized_actual = ' '.join(actual_log_message.split())
+        normalized_expected = " ".join(expected_log_message.split())
+        normalized_actual = " ".join(actual_log_message.split())
 
         self.assertEqual(normalized_expected, normalized_actual)
 
-    @patch('logging.Logger.info')
+    @patch("logging.Logger.info")
     def test_run_audit_no_agents(self, mock_log_info):
         # Run the audit with no agents
         self.audit.run_audit([], 100)
@@ -62,5 +67,5 @@ class TestGenerationalWealthAudit(unittest.TestCase):
         self.assertEqual(expected_log_message, actual_log_message)
 
 
-if __name__ == '__main__':
+if __name__ == "__main__":
     unittest.main()
diff --git a/tests/test_government_ai_logic.py b/tests/test_government_ai_logic.py
index 57fc8a6..4effb0b 100644
--- a/tests/test_government_ai_logic.py
+++ b/tests/test_government_ai_logic.py
@@ -1,8 +1,8 @@
-
 import unittest
 from unittest.mock import MagicMock
 from simulation.ai.government_ai import GovernmentAI
 
+
 class TestGovernmentAILogic(unittest.TestCase):
     def setUp(self):
         self.mock_agent = MagicMock()
@@ -18,7 +18,7 @@ class TestGovernmentAILogic(unittest.TestCase):
 
         # Configure Agent defaults
         self.mock_agent.id = "gov_test"
-        self.mock_agent._assets = -600.0 # Debt Ratio 0.6 (Ideal)
+        self.mock_agent._assets = -600.0  # Debt Ratio 0.6 (Ideal)
 
         self.ai = GovernmentAI(self.mock_agent, self.mock_config)
 
@@ -65,7 +65,7 @@ class TestGovernmentAILogic(unittest.TestCase):
         self.mock_agent.sensory_data.unemployment_sma = 0.04
         self.mock_agent.sensory_data.gdp_growth_sma = 0.0
         self.mock_agent.sensory_data.current_gdp = 1000.0
-        self.mock_agent._assets = -1000.0 # Debt 1000
+        self.mock_agent._assets = -1000.0  # Debt 1000
 
         # Debt Ratio: 1000/1000 = 1.0 -> Gap 0.4 > 0.05 -> High (2)
 
@@ -112,7 +112,7 @@ class TestGovernmentAILogic(unittest.TestCase):
 
         # Step 2: Update Learning (simulate outcome)
         # Under ideal conditions, reward should be 0.
-        dummy_reward = -999.0 # This should be ignored by the learning function
+        dummy_reward = -999.0  # This should be ignored by the learning function
         self.ai.update_learning_with_state(dummy_reward, current_tick=2)
 
         # Q-Value should not change as reward is 0
@@ -129,5 +129,6 @@ class TestGovernmentAILogic(unittest.TestCase):
         updated_q_2 = self.ai.q_table.get_q_value(previous_state, previous_action)
         self.assertAlmostEqual(updated_q_2, -0.0045, places=6)
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     unittest.main()
diff --git a/tests/test_government_fiscal_policy.py b/tests/test_government_fiscal_policy.py
index 817e5eb..3fe30fa 100644
--- a/tests/test_government_fiscal_policy.py
+++ b/tests/test_government_fiscal_policy.py
@@ -3,6 +3,7 @@ from unittest.mock import Mock
 from simulation.models import Transaction
 from simulation.agents.government import Government
 
+
 def test_tax_collection_and_bailouts(government):
     """
     Tests that the government can collect taxes and provide bailouts,
@@ -42,7 +43,7 @@ def test_infrastructure_investment():
     """
     config_mock = Mock()
     config_mock.INFRASTRUCTURE_INVESTMENT_COST = 5000.0
-    config_mock.TICKS_PER_YEAR = 100 # Required for TaylorRulePolicy init
+    config_mock.TICKS_PER_YEAR = 100  # Required for TaylorRulePolicy init
 
     gov = Government(id=1, initial_assets=6000.0, config_module=config_mock)
 
diff --git a/tests/test_household_ai.py b/tests/test_household_ai.py
index 6eecb05..23995cd 100644
--- a/tests/test_household_ai.py
+++ b/tests/test_household_ai.py
@@ -17,10 +17,13 @@ from simulation.models import Order
 from simulation.markets.order_book_market import OrderBookMarket
 from simulation.decisions.action_proposal import ActionProposalEngine
 from simulation.ai.state_builder import StateBuilder
-from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
+from simulation.decisions.ai_driven_household_engine import (
+    AIDrivenHouseholdDecisionEngine,
+)
 from simulation.ai.household_ai import HouseholdAI
 from simulation.ai.enums import Tactic
 
+
 @pytest.fixture
 def setup_test_environment():
     """Fixture to set up the test environment."""
@@ -36,32 +39,58 @@ def setup_test_environment():
         "labor_market": OrderBookMarket("labor_market"),
         "loan_market": Mock(spec=Market),
     }
-    
+
     # Pre-populate goods market with some offers for testing
     goods_market = markets["goods_market"]
-    goods_market.place_order(Order(agent_id=99, order_type="SELL", item_id="basic_food", quantity=100, price=10.0, market_id="goods_market"), 0)
-    goods_market.place_order(Order(agent_id=98, order_type="SELL", item_id="luxury_food", quantity=50, price=50.0, market_id="goods_market"), 0)
-    
+    goods_market.place_order(
+        Order(
+            agent_id=99,
+            order_type="SELL",
+            item_id="basic_food",
+            quantity=100,
+            price=10.0,
+            market_id="goods_market",
+        ),
+        0,
+    )
+    goods_market.place_order(
+        Order(
+            agent_id=98,
+            order_type="SELL",
+            item_id="luxury_food",
+            quantity=50,
+            price=50.0,
+            market_id="goods_market",
+        ),
+        0,
+    )
+
     return goods_data, markets
 
+
 @pytest.fixture
 def ai_engine_setup():
     """Fixture for setting up AI engine components."""
     value_orientation = config.VALUE_ORIENTATION_WEALTH_AND_NEEDS
-    action_proposal_engine = ActionProposalEngine(config_module=config, n_action_samples=10)
+    action_proposal_engine = ActionProposalEngine(
+        config_module=config, n_action_samples=10
+    )
     state_builder = StateBuilder()
     ai_engine_registry = AIEngineRegistry(
         action_proposal_engine=action_proposal_engine, state_builder=state_builder
     )
     return ai_engine_registry, value_orientation
 
+
 def test_ai_creates_purchase_order(setup_test_environment, ai_engine_setup):
     """AIê°€ ìƒì¡´ ìš•êµ¬ê°€ ë†’ì„ ë•Œ 'food' êµ¬ë§¤ ì£¼ë¬¸ì„ ìƒì„±í•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
     goods_data, markets = setup_test_environment
     ai_engine_registry, value_orientation = ai_engine_setup
 
     ai_decision_engine_instance = ai_engine_registry.get_engine(value_orientation)
-    household_ai_instance = HouseholdAI(agent_id=str(2), ai_decision_engine=ai_decision_engine_instance)
+    household_ai_instance = HouseholdAI(
+        agent_id=str(2), ai_decision_engine=ai_decision_engine_instance
+    )
     household_ai_instance.set_ai_decision_engine(ai_decision_engine_instance)
     household_decision_engine = AIDrivenHouseholdDecisionEngine(
         ai_engine=household_ai_instance, config_module=config
@@ -73,7 +102,12 @@ def test_ai_creates_purchase_order(setup_test_environment, ai_engine_setup):
         talent=talent,
         goods_data=goods_data,
         initial_assets=100.0,
-        initial_needs={"survival": 80.0, "social": 20.0, "improvement": 10.0, "asset": 10.0},
+        initial_needs={
+            "survival": 80.0,
+            "social": 20.0,
+            "improvement": 10.0,
+            "asset": 10.0,
+        },
         value_orientation=value_orientation,
         decision_engine=household_decision_engine,
         personality=Personality.MISER,
@@ -84,25 +118,26 @@ def test_ai_creates_purchase_order(setup_test_environment, ai_engine_setup):
         "time": 1,
         "goods_data": goods_data,
         "goods_market": {
-             "food_current_sell_price": 10.0,
-             "basic_food_current_sell_price": 10.0,
-             "luxury_food_current_sell_price": 50.0,
-        }
+            "food_current_sell_price": 10.0,
+            "basic_food_current_sell_price": 10.0,
+            "luxury_food_current_sell_price": 50.0,
+        },
     }
     orders, _ = household.make_decision(markets, goods_data, market_data, 1)
 
     assert orders is not None
     assert len(orders) == 1
-    
+
     purchase_order = orders[0]
     assert purchase_order.order_type == "BUY"
     # The logic might choose EVALUATE_CONSUMPTION_OPTIONS which then chooses a food.
     # We should check if the item is a food item.
     assert "food" in purchase_order.item_id
     assert purchase_order.quantity > 0
-    
+
     print("OK: AI successfully generated a purchase order for food.")
 
+
 def test_ai_evaluates_consumption_options(setup_test_environment, ai_engine_setup):
     """
     AIê°€ ì—¬ëŸ¬ ì†Œë¹„ ì˜µì…˜ ì¤‘ì—ì„œ ìš•êµ¬ë¥¼ ê°€ì¥ ì˜ ì¶©ì¡±ì‹œí‚¤ëŠ”(íš¨ìš© ëŒ€ë¹„ ê°€ê²©ì´ ë†’ì€) ì¬í™”ë¥¼ ì„ íƒí•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤.
@@ -112,9 +147,11 @@ def test_ai_evaluates_consumption_options(setup_test_environment, ai_engine_setu
     ai_engine_registry, base_value_orientation = ai_engine_setup
 
     value_orientation = config.VALUE_ORIENTATION_NEEDS_AND_SOCIAL_STATUS
-    
+
     ai_decision_engine_instance = ai_engine_registry.get_engine(value_orientation)
-    household_ai_instance = HouseholdAI(agent_id=str(3), ai_decision_engine=ai_decision_engine_instance)
+    household_ai_instance = HouseholdAI(
+        agent_id=str(3), ai_decision_engine=ai_decision_engine_instance
+    )
     household_ai_instance.set_ai_decision_engine(ai_decision_engine_instance)
     household_decision_engine = AIDrivenHouseholdDecisionEngine(
         ai_engine=household_ai_instance, config_module=config
@@ -126,7 +163,12 @@ def test_ai_evaluates_consumption_options(setup_test_environment, ai_engine_setu
         talent=talent,
         goods_data=goods_data,
         initial_assets=1000.0,
-        initial_needs={"survival": 10.0, "social": 80.0, "improvement": 10.0, "asset": 10.0},
+        initial_needs={
+            "survival": 10.0,
+            "social": 80.0,
+            "improvement": 10.0,
+            "asset": 10.0,
+        },
         value_orientation=value_orientation,
         decision_engine=household_decision_engine,
         personality=Personality.STATUS_SEEKER,
@@ -137,22 +179,26 @@ def test_ai_evaluates_consumption_options(setup_test_environment, ai_engine_setu
         "time": 1,
         "goods_data": goods_data,
         "goods_market": {
-             "luxury_food_current_sell_price": 50.0,
-             "basic_food_current_sell_price": 10.0,
-             "food_current_sell_price": 10.0,
-        }
+            "luxury_food_current_sell_price": 50.0,
+            "basic_food_current_sell_price": 10.0,
+            "food_current_sell_price": 10.0,
+        },
     }
-    orders, chosen_tactic_tuple = household.make_decision(markets, goods_data, market_data, 1)
+    orders, chosen_tactic_tuple = household.make_decision(
+        markets, goods_data, market_data, 1
+    )
     chosen_tactic, _ = chosen_tactic_tuple
 
     assert orders is not None
     assert len(orders) > 0
-    
-    assert chosen_tactic == Tactic.EVALUATE_CONSUMPTION_OPTIONS, f"Expected Tactic EVALUATE_CONSUMPTION_OPTIONS, got {chosen_tactic.name}"
+
+    assert chosen_tactic == Tactic.EVALUATE_CONSUMPTION_OPTIONS, (
+        f"Expected Tactic EVALUATE_CONSUMPTION_OPTIONS, got {chosen_tactic.name}"
+    )
 
     purchase_order = orders[0]
     assert purchase_order.order_type == "BUY"
     assert purchase_order.item_id == "luxury_food"
     assert purchase_order.quantity > 0
-    
+
     print("OK: AI successfully evaluated consumption options and chose 'luxury_food'.")
diff --git a/tests/test_household_ai_consumption.py b/tests/test_household_ai_consumption.py
index fb66b4a..e42c026 100644
--- a/tests/test_household_ai_consumption.py
+++ b/tests/test_household_ai_consumption.py
@@ -1,57 +1,65 @@
 import pytest
 from unittest.mock import MagicMock
 from simulation.core_agents import Household
-from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
+from simulation.decisions.ai_driven_household_engine import (
+    AIDrivenHouseholdDecisionEngine,
+)
 from simulation.ai.household_ai import HouseholdAI
 from simulation.ai.enums import Tactic, Aggressiveness
 from simulation.dtos import DecisionContext
 from simulation.models import Order
 import config
 
+
 class TestHouseholdAIConsumption:
     @pytest.fixture
     def setup_household(self):
         # Create mocks
         mock_config = MagicMock()
         mock_config.SURVIVAL_NEED_THRESHOLD = 20.0
-        mock_config.SURVIVAL_NEED_CONSUMPTION_THRESHOLD = 50.0 # High threshold
+        mock_config.SURVIVAL_NEED_CONSUMPTION_THRESHOLD = 50.0  # High threshold
         mock_config.HOUSEHOLD_MIN_FOOD_INVENTORY = 2.0
         mock_config.PERCEIVED_FAIR_PRICE_THRESHOLD_FACTOR = 0.9
         mock_config.FOOD_PURCHASE_MAX_PER_TICK = 5.0
         mock_config.GOODS = {"food": {"utility_effects": {"survival": 10}}}
-        
+
         mock_logger = MagicMock()
-        
+
         # Mock HouseholdAI
         mock_household_ai = MagicMock(spec=HouseholdAI)
         # Mock decide_and_learn to return the tuple directly
         # Using Aggressiveness.PASSIVE as a placeholder if NEUTRAL doesn't exist
-        mock_household_ai.decide_and_learn.return_value = (Tactic.EVALUATE_CONSUMPTION_OPTIONS, Aggressiveness.PASSIVE)
-        
-        engine = AIDrivenHouseholdDecisionEngine(mock_household_ai, mock_config, mock_logger)
-        
+        mock_household_ai.decide_and_learn.return_value = (
+            Tactic.EVALUATE_CONSUMPTION_OPTIONS,
+            Aggressiveness.PASSIVE,
+        )
+
+        engine = AIDrivenHouseholdDecisionEngine(
+            mock_household_ai, mock_config, mock_logger
+        )
+
         household = MagicMock(spec=Household)
         household.id = 1
-        household.needs = {"survival": 80.0} # High survival need
+        household.needs = {"survival": 80.0}  # High survival need
         household.inventory = {"food": 0.0}
         household._assets = 100.0
         household.get_agent_data.return_value = {}
         household.get_pre_state_data.return_value = {}
         household.perceived_avg_prices = {"food": 10.0}
-        
+
         return engine, household, mock_household_ai
 
     def test_ai_chooses_consumption_tactic(self, setup_household):
         engine, household, mock_household_ai = setup_household
-        
+
         markets = {"goods_market": MagicMock()}
         # Mock get_best_ask for food
         markets["goods_market"].get_best_ask.return_value = 10.0
-        
+
         goods_data = [{"id": "food", "name": "Food"}]
         market_data = {}
         current_time = 1
-        
+
         # Run make_decisions
         context = DecisionContext(
             household=household,
@@ -61,17 +69,17 @@ class TestHouseholdAIConsumption:
             current_time=current_time,
         )
         orders, (tactic, aggressiveness) = engine.make_decisions(context)
-        
+
         # Verify Tactic
         assert tactic == Tactic.EVALUATE_CONSUMPTION_OPTIONS
-        
+
         # Verify AI decide_and_learn was called
         mock_household_ai.decide_and_learn.assert_called()
-        
+
         # Verify Order Generation (EVALUATE_CONSUMPTION_OPTIONS logic)
         # The logic iterates GOODS, so we need config.GOODS to be set (which we did in setup)
         # And it checks markets["goods_market"].get_best_ask(item_id)
-        
+
         # Check if any order was created
         assert len(orders) > 0
         assert orders[0].order_type == "BUY"
diff --git a/tests/test_household_decision_engine_multi_good.py b/tests/test_household_decision_engine_multi_good.py
index 8d02abf..21fa2db 100644
--- a/tests/test_household_decision_engine_multi_good.py
+++ b/tests/test_household_decision_engine_multi_good.py
@@ -124,37 +124,49 @@ def mock_markets():
 
 
 class TestHouseholdDecisionEngineMultiGood:
-    @pytest.mark.skip(reason="Refactoring needed: tests private method on non-existent rule_based_engine")
+    @pytest.mark.skip(
+        reason="Refactoring needed: tests private method on non-existent rule_based_engine"
+    )
     def test_get_consumption_candidates(
         self, household_decision_engine, mock_markets, mock_household
     ):
         pass
 
-    @pytest.mark.skip(reason="Refactoring needed: tests private method on non-existent rule_based_engine")
+    @pytest.mark.skip(
+        reason="Refactoring needed: tests private method on non-existent rule_based_engine"
+    )
     def test_calculate_utility_gain_basic_food(
         self, household_decision_engine, mock_household
     ):
         pass
 
-    @pytest.mark.skip(reason="Refactoring needed: tests private method on non-existent rule_based_engine")
+    @pytest.mark.skip(
+        reason="Refactoring needed: tests private method on non-existent rule_based_engine"
+    )
     def test_calculate_utility_gain_luxury_food(
         self, household_decision_engine, mock_household
     ):
         pass
-    
-    @pytest.mark.skip(reason="Refactoring needed: tests private method on non-existent rule_based_engine")
+
+    @pytest.mark.skip(
+        reason="Refactoring needed: tests private method on non-existent rule_based_engine"
+    )
     def test_find_optimal_consumption_bundle_prioritize_cheaper(
         self, household_decision_engine, mock_household, mock_markets
     ):
         pass
 
-    @pytest.mark.skip(reason="Refactoring needed: tests private method on non-existent rule_based_engine")
+    @pytest.mark.skip(
+        reason="Refactoring needed: tests private method on non-existent rule_based_engine"
+    )
     def test_find_optimal_consumption_bundle_insufficient_funds(
         self, household_decision_engine, mock_household, mock_markets
     ):
         pass
 
-    @pytest.mark.skip(reason="Refactoring needed: tests private method on non-existent rule_based_engine")
+    @pytest.mark.skip(
+        reason="Refactoring needed: tests private method on non-existent rule_based_engine"
+    )
     def test_find_optimal_consumption_bundle_no_candidates(
         self, household_decision_engine, mock_household, mock_markets
     ):
@@ -166,7 +178,8 @@ class TestHouseholdDecisionEngineMultiGood:
         engine, mock_ai_engine = household_decision_engine
         # Mock AI to return EVALUATE_CONSUMPTION_OPTIONS
         mock_ai_engine.decide_and_learn.return_value = (
-            Tactic.EVALUATE_CONSUMPTION_OPTIONS, Aggressiveness.NORMAL
+            Tactic.EVALUATE_CONSUMPTION_OPTIONS,
+            Aggressiveness.NORMAL,
         )
 
         # Household has 100 assets, will buy basic_food
@@ -192,7 +205,8 @@ class TestHouseholdDecisionEngineMultiGood:
         engine, mock_ai_engine = household_decision_engine
         # Mock AI to return PARTICIPATE_LABOR_MARKET
         mock_ai_engine.decide_and_learn.return_value = (
-            Tactic.PARTICIPATE_LABOR_MARKET, Aggressiveness.NORMAL
+            Tactic.PARTICIPATE_LABOR_MARKET,
+            Aggressiveness.NORMAL,
         )
         mock_household.get_desired_wage.return_value = 12.0
         mock_household.is_employed = False
@@ -214,8 +228,10 @@ class TestHouseholdDecisionEngineMultiGood:
         assert orders[0].price == 12.0
         assert orders[0].market_id == "labor_market"
 
-    @pytest.mark.skip(reason="Refactoring needed: tests private method on non-existent rule_based_engine")
+    @pytest.mark.skip(
+        reason="Refactoring needed: tests private method on non-existent rule_based_engine"
+    )
     def test_find_optimal_consumption_bundle_mix_goods_sufficient_budget(
         self, household_decision_engine, mock_household, mock_markets
     ):
-        pass
\ No newline at end of file
+        pass
diff --git a/tests/test_household_decision_engine_new.py b/tests/test_household_decision_engine_new.py
index 5b6cae7..52d0afc 100644
--- a/tests/test_household_decision_engine_new.py
+++ b/tests/test_household_decision_engine_new.py
@@ -12,6 +12,7 @@ from simulation.schemas import HouseholdActionVector
 from simulation.ai.api import Personality
 from tests.factories import create_household_dto
 
+
 # Mock Logger
 @pytest.fixture(autouse=True)
 def mock_logger_fixture():
@@ -91,7 +92,7 @@ def mock_household_dto():
         is_employed=False,
         current_wage=0.0,
         wage_modifier=1.0,
-        personality=Personality.BALANCED
+        personality=Personality.BALANCED,
     )
 
 
@@ -104,7 +105,7 @@ def mock_ai_engine():
         work_aggressiveness=0.5,
         job_mobility_aggressiveness=0.5,
         investment_aggressiveness=0.0,
-        learning_aggressiveness=0.0
+        learning_aggressiveness=0.0,
     )
     ai.decide_action_vector.return_value = default_vector
     return ai
@@ -136,7 +137,7 @@ class TestAIDrivenHouseholdDecisionEngine:
     ):
         # Action Vector with 0 aggressiveness implies "Do Nothing" or buy minimum
         mock_ai_engine.decide_action_vector.return_value = HouseholdActionVector(
-             consumption_aggressiveness={"basic_food": 0.0, "luxury_food": 0.0}
+            consumption_aggressiveness={"basic_food": 0.0, "luxury_food": 0.0}
         )
 
         context = DecisionContext(
@@ -156,10 +157,10 @@ class TestAIDrivenHouseholdDecisionEngine:
         mock_goods_market = Mock(spec=OrderBookMarket, id="goods_market")
         mock_goods_market.get_best_ask.return_value = 10.0
         mock_markets = {"goods_market": mock_goods_market}
-        
+
         # High Aggressiveness for basic_food
         mock_ai_engine.decide_action_vector.return_value = HouseholdActionVector(
-             consumption_aggressiveness={"basic_food": 0.8}
+            consumption_aggressiveness={"basic_food": 0.8}
         )
 
         context = DecisionContext(
@@ -180,18 +181,18 @@ class TestAIDrivenHouseholdDecisionEngine:
         mock_goods_market = Mock(spec=OrderBookMarket, id="goods_market")
         mock_goods_market.get_best_ask.return_value = 1000.0
         mock_markets = {"goods_market": mock_goods_market}
-        
-        mock_household_dto._assets = 100.0 # DTO assets
+
+        mock_household_dto._assets = 100.0  # DTO assets
 
         mock_ai_engine.decide_action_vector.return_value = HouseholdActionVector(
-             consumption_aggressiveness={"luxury_food": 0.9}
+            consumption_aggressiveness={"luxury_food": 0.9}
         )
 
         # Populate market_data with high price so engine sees it
         market_data = {
             "goods_market": {
                 "luxury_food_current_sell_price": 1000.0,
-                "luxury_food_avg_traded_price": 1000.0
+                "luxury_food_avg_traded_price": 1000.0,
             }
         }
 
@@ -212,13 +213,17 @@ class TestAIDrivenHouseholdDecisionEngine:
         self, decision_engine, mock_household_dto, mock_ai_engine, mock_config
     ):
         mock_goods_market = Mock(spec=OrderBookMarket, id="goods_market")
-        mock_goods_market.get_best_ask.side_effect = lambda item_id: 10.0 if item_id == "basic_food" else (20.0 if item_id == "luxury_food" else None)
-        
+        mock_goods_market.get_best_ask.side_effect = (
+            lambda item_id: 10.0
+            if item_id == "basic_food"
+            else (20.0 if item_id == "luxury_food" else None)
+        )
+
         mock_markets = {"goods_market": mock_goods_market}
-        
+
         # Equal aggressiveness
         mock_ai_engine.decide_action_vector.return_value = HouseholdActionVector(
-             consumption_aggressiveness={"basic_food": 0.5, "luxury_food": 0.5}
+            consumption_aggressiveness={"basic_food": 0.5, "luxury_food": 0.5}
         )
 
         context = DecisionContext(
@@ -242,21 +247,18 @@ class TestAIDrivenHouseholdDecisionEngine:
         mock_markets = {"labor": mock_labor_market}
 
         mock_ai_engine.decide_action_vector.return_value = HouseholdActionVector(
-             work_aggressiveness=0.9
+            work_aggressiveness=0.9
         )
 
         # Set DTO wage
         mock_household_dto.current_wage = 0.0
-        mock_household_dto.wage_modifier = 0.9 # Lower than 1.0 to trigger participation
+        mock_household_dto.wage_modifier = (
+            0.9  # Lower than 1.0 to trigger participation
+        )
 
         # Inject market data for avg wage
         market_data = {
-            "goods_market": {
-                "labor": {
-                    "avg_wage": 50.0,
-                    "best_wage_offer": 49.5
-                }
-            }
+            "goods_market": {"labor": {"avg_wage": 50.0, "best_wage_offer": 49.5}}
         }
 
         context = DecisionContext(
@@ -287,7 +289,7 @@ class TestAIDrivenHouseholdDecisionEngine:
 
         # Passive = Low Work Agg
         mock_ai_engine.decide_action_vector.return_value = HouseholdActionVector(
-             work_aggressiveness=0.1
+            work_aggressiveness=0.1
         )
 
         mock_household_dto.current_wage = 0.0
@@ -295,12 +297,7 @@ class TestAIDrivenHouseholdDecisionEngine:
 
         # Inject high avg wage so reservation wage calc results in high value
         market_data = {
-            "goods_market": {
-                "labor": {
-                    "avg_wage": 50.0,
-                    "best_wage_offer": 55.0
-                }
-            }
+            "goods_market": {"labor": {"avg_wage": 50.0, "best_wage_offer": 55.0}}
         }
 
         context = DecisionContext(
diff --git a/tests/test_household_marginal_utility.py b/tests/test_household_marginal_utility.py
index c815112..2817741 100644
--- a/tests/test_household_marginal_utility.py
+++ b/tests/test_household_marginal_utility.py
@@ -1,19 +1,21 @@
-
 import unittest
 from unittest.mock import MagicMock, patch
-from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
+from simulation.decisions.ai_driven_household_engine import (
+    AIDrivenHouseholdDecisionEngine,
+)
 from simulation.core_agents import Household, Talent
 from simulation.ai.household_ai import HouseholdAI
 from simulation.ai.enums import Tactic, Aggressiveness, Personality
 from simulation.ai_model import AIDecisionEngine
 from simulation.models import Order
 
+
 class MockConfig:
     GOODS = {
         "food": {
             "id": "food",
-            "utility_effects": {"survival": 10.0}, # Base Utility = 10
-            "production_cost": 5.0
+            "utility_effects": {"survival": 10.0},  # Base Utility = 10
+            "production_cost": 5.0,
         }
     }
     TARGET_FOOD_BUFFER_QUANTITY = 10
@@ -46,11 +48,11 @@ class MockConfig:
 class TestHouseholdMarginalUtility(unittest.TestCase):
     def setUp(self):
         self.config = MockConfig()
-        
+
         # Mock AI components
         self.mock_ai_decision_engine = MagicMock(spec=AIDecisionEngine)
         self.ai_engine = HouseholdAI("agent_1", self.mock_ai_decision_engine)
-        
+
         # Create Household
         talent = Talent(base_learning_rate=0.1, max_potential={})
         self.household = Household(
@@ -59,15 +61,17 @@ class TestHouseholdMarginalUtility(unittest.TestCase):
             goods_data=[self.config.GOODS["food"]],
             initial_assets=1000.0,
             initial_needs={"survival": 1.0},
-            decision_engine=AIDrivenHouseholdDecisionEngine(self.ai_engine, self.config),
+            decision_engine=AIDrivenHouseholdDecisionEngine(
+                self.ai_engine, self.config
+            ),
             value_orientation="N/A",
             personality=Personality.GROWTH_ORIENTED,
-            config_module=self.config
+            config_module=self.config,
         )
         # Give infinite money
         self.household._assets = 1_000_000_000
         self.household.inventory = {"food": 0}
-        self.household.needs = {"survival": 1.0} # Needs > 0 to have utility
+        self.household.needs = {"survival": 1.0}  # Needs > 0 to have utility
 
         self.engine = AIDrivenHouseholdDecisionEngine(self.ai_engine, self.config)
 
@@ -76,7 +80,7 @@ class TestHouseholdMarginalUtility(unittest.TestCase):
         Test that purchasing stops when Marginal Utility < Price.
         Base Utility = 10 * 1 = 10.
         MU = 10 / (1 + Inventory)
-        
+
         Scenario 1: Price = 2.0
         MU > 2.0 when Inventory < 4. (10/1=10, 10/2=5, 10/3=3.3, 10/4=2.5, 10/5=2.0)
         So it should buy exactly 4 or 5 units depending on <= or < logic.
@@ -88,29 +92,23 @@ class TestHouseholdMarginalUtility(unittest.TestCase):
         10/5 > 2 ? No (2 > 2 is False).
         So expected quantity = 4.
         """
-        
-        market_data = {
-            "goods_market": MagicMock()
-        }
-        market_data["goods_market"].get_best_ask.return_value = 2.0 # Price = 2.0
-        
-        tactic = Tactic.BUY_BASIC_FOOD # Logic is shared in _handle_specific_purchase
-        aggressiveness = Aggressiveness.NORMAL # Factor = 1.0
+
+        market_data = {"goods_market": MagicMock()}
+        market_data["goods_market"].get_best_ask.return_value = 2.0  # Price = 2.0
+
+        tactic = Tactic.BUY_BASIC_FOOD  # Logic is shared in _handle_specific_purchase
+        aggressiveness = Aggressiveness.NORMAL  # Factor = 1.0
 
         # We need to call _handle_specific_purchase directly or simulate _execute_tactic
         # Let's call _handle_specific_purchase directly for unit testing logic
-        
+
         orders = self.engine._handle_specific_purchase(
-            self.household,
-            "food",
-            aggressiveness,
-            current_tick=1,
-            markets=market_data
+            self.household, "food", aggressiveness, current_tick=1, markets=market_data
         )
-        
+
         self.assertTrue(len(orders) > 0)
         self.assertEqual(orders[0].quantity, 4)
-        
+
     def test_high_price_prevents_buying(self):
         """
         Scenario 2: Price = 11.0
@@ -119,20 +117,19 @@ class TestHouseholdMarginalUtility(unittest.TestCase):
         10 > 11 ? No.
         Should buy 0 units.
         """
-        market_data = {
-            "goods_market": MagicMock()
-        }
-        market_data["goods_market"].get_best_ask.return_value = 11.0 # Price = 11.0
-        
+        market_data = {"goods_market": MagicMock()}
+        market_data["goods_market"].get_best_ask.return_value = 11.0  # Price = 11.0
+
         orders = self.engine._handle_specific_purchase(
             self.household,
             "food",
             Aggressiveness.NORMAL,
             current_tick=1,
-            markets=market_data
+            markets=market_data,
         )
-        
+
         self.assertEqual(len(orders), 0)
 
+
 if __name__ == "__main__":
     unittest.main()
diff --git a/tests/test_household_system2.py b/tests/test_household_system2.py
index c63524a..a34cf51 100644
--- a/tests/test_household_system2.py
+++ b/tests/test_household_system2.py
@@ -1,10 +1,14 @@
 import unittest
 from unittest.mock import MagicMock
-from simulation.ai.household_system2 import HouseholdSystem2Planner, HousingDecisionInputs
+from simulation.ai.household_system2 import (
+    HouseholdSystem2Planner,
+    HousingDecisionInputs,
+)
 from simulation.core_agents import Household
 from simulation.ai.api import Personality
 from collections import deque
 
+
 class TestHouseholdSystem2(unittest.TestCase):
     def setUp(self):
         self.mock_agent = MagicMock()
@@ -22,7 +26,7 @@ class TestHouseholdSystem2(unittest.TestCase):
             market_rent_monthly=1000.0,
             market_price=200000.0,
             risk_free_rate=0.03,
-            price_growth_expectation=0.04
+            price_growth_expectation=0.04,
         )
 
         result = self.planner.calculate_housing_npv(inputs)
@@ -37,11 +41,11 @@ class TestHouseholdSystem2(unittest.TestCase):
         # Scenario: Income too low for price
         inputs = HousingDecisionInputs(
             current_wealth=100000.0,
-            annual_income=10000.0, # Very low income
+            annual_income=10000.0,  # Very low income
             market_rent_monthly=500.0,
-            market_price=500000.0, # Very high price
+            market_price=500000.0,  # Very high price
             risk_free_rate=0.05,
-            price_growth_expectation=0.04
+            price_growth_expectation=0.04,
         )
 
         # Should return RENT
@@ -49,27 +53,31 @@ class TestHouseholdSystem2(unittest.TestCase):
         self.assertEqual(decision, "RENT")
 
     def test_rational_choice_buy(self):
-         # Scenario: Buy is clearly better (Low Interest, High Growth)
-         inputs = HousingDecisionInputs(
+        # Scenario: Buy is clearly better (Low Interest, High Growth)
+        inputs = HousingDecisionInputs(
             current_wealth=500000.0,
             annual_income=100000.0,
-            market_rent_monthly=2000.0, # High rent makes renting expensive
-            market_price=300000.0, # Cheap house
-            risk_free_rate=0.02, # Low interest
-            price_growth_expectation=0.05 # High growth cap
+            market_rent_monthly=2000.0,  # High rent makes renting expensive
+            market_price=300000.0,  # Cheap house
+            risk_free_rate=0.02,  # Low interest
+            price_growth_expectation=0.05,  # High growth cap
         )
-         decision = self.planner.decide(inputs)
-         self.assertEqual(decision, "BUY")
+        decision = self.planner.decide(inputs)
+        self.assertEqual(decision, "BUY")
 
     def test_household_integration(self):
         # Create real household (mocked config/decision engine)
         mock_decision_engine = MagicMock()
-        mock_decision_engine.ai_engine = MagicMock() # Mock nested ai_engine
+        mock_decision_engine.ai_engine = MagicMock()  # Mock nested ai_engine
 
         # Configure Config Mock for Household Init
         self.mock_config.EDUCATION_LEVEL_DISTRIBUTION = [1.0]
         self.mock_config.VALUE_ORIENTATION_MAPPING = {
-            "wealth_and_needs": {"preference_asset": 1.0, "preference_social": 1.0, "preference_growth": 1.0}
+            "wealth_and_needs": {
+                "preference_asset": 1.0,
+                "preference_social": 1.0,
+                "preference_growth": 1.0,
+            }
         }
         self.mock_config.CONFORMITY_RANGES = {}
         self.mock_config.INFLATION_MEMORY_WINDOW = 10
@@ -85,17 +93,17 @@ class TestHouseholdSystem2(unittest.TestCase):
             decision_engine=mock_decision_engine,
             value_orientation="wealth_and_needs",
             personality=Personality.CONSERVATIVE,
-            config_module=self.mock_config
+            config_module=self.mock_config,
         )
 
         # Override planner with mock to verify call
         household.housing_planner = MagicMock()
-        household.housing_planner.decide.return_value = "BUY" # Force BUY decision
+        household.housing_planner.decide.return_value = "BUY"  # Force BUY decision
 
         # Trigger Condition: tick 30
         market_data = {
             "housing_market": {"avg_rent_price": 100.0, "avg_sale_price": 20000.0},
-            "loan_market": {"interest_rate": 0.05}
+            "loan_market": {"interest_rate": 0.05},
         }
 
         # 1. Verify Trigger
@@ -106,7 +114,10 @@ class TestHouseholdSystem2(unittest.TestCase):
 
         # 2. Verify Execution (BUY -> Order)
         # Mock decision engine to return empty list
-        mock_decision_engine.make_decisions.return_value = ([], (MagicMock(), MagicMock()))
+        mock_decision_engine.make_decisions.return_value = (
+            [],
+            (MagicMock(), MagicMock()),
+        )
 
         # Set up a fake housing market with a sell order
         mock_market = MagicMock()
@@ -115,12 +126,19 @@ class TestHouseholdSystem2(unittest.TestCase):
         mock_market.sell_orders = {"unit_1": [mock_order]}
         markets = {"housing": mock_market}
 
-        household.is_homeless = True # Trigger Execution logic
+        household.is_homeless = True  # Trigger Execution logic
         orders, _ = household.make_decision(markets, [], market_data, 30, None)
 
         # Check if BUY order was appended
-        found_housing_buy = any(o.market_id == "housing" and o.order_type == "BUY" and o.item_id == "unit_1" for o in orders)
-        self.assertTrue(found_housing_buy, "Should generate BUY order for housing when mode is BUY and homeless")
+        found_housing_buy = any(
+            o.market_id == "housing" and o.order_type == "BUY" and o.item_id == "unit_1"
+            for o in orders
+        )
+        self.assertTrue(
+            found_housing_buy,
+            "Should generate BUY order for housing when mode is BUY and homeless",
+        )
+
 
-if __name__ == '__main__':
+if __name__ == "__main__":
     unittest.main()
diff --git a/tests/test_interest_sensitivity.py b/tests/test_interest_sensitivity.py
index 7d26e46..17a04ea 100644
--- a/tests/test_interest_sensitivity.py
+++ b/tests/test_interest_sensitivity.py
@@ -1,4 +1,5 @@
 """Unit test for Interest Sensitivity logic in AIDrivenHouseholdDecisionEngine."""
+
 import pytest
 from unittest.mock import MagicMock, patch
 
diff --git a/tests/test_learning_tracker.py b/tests/test_learning_tracker.py
index 02a1d0c..0784a25 100644
--- a/tests/test_learning_tracker.py
+++ b/tests/test_learning_tracker.py
@@ -1,6 +1,7 @@
 import unittest
 from simulation.ai.learning_tracker import LearningTracker
 
+
 class TestLearningTracker(unittest.TestCase):
     def setUp(self):
         self.tracker = LearningTracker()
@@ -13,8 +14,12 @@ class TestLearningTracker(unittest.TestCase):
 
     def test_get_summary_single_agent(self):
         """Test summary with one agent and multiple records."""
-        self.tracker.track_learning_progress(tick=1, agent_id="agent_1", q_table_change=0.1, reward=10)
-        self.tracker.track_learning_progress(tick=2, agent_id="agent_1", q_table_change=0.05, reward=5)
+        self.tracker.track_learning_progress(
+            tick=1, agent_id="agent_1", q_table_change=0.1, reward=10
+        )
+        self.tracker.track_learning_progress(
+            tick=2, agent_id="agent_1", q_table_change=0.05, reward=5
+        )
 
         summary = self.tracker.get_summary()
 
@@ -41,12 +46,20 @@ class TestLearningTracker(unittest.TestCase):
     def test_get_summary_multiple_agents(self):
         """Test summary with multiple agents across multiple ticks."""
         # Tick 1
-        self.tracker.track_learning_progress(tick=1, agent_id="agent_1", q_table_change=0.1, reward=10)
-        self.tracker.track_learning_progress(tick=1, agent_id="agent_2", q_table_change=0.2, reward=20)
+        self.tracker.track_learning_progress(
+            tick=1, agent_id="agent_1", q_table_change=0.1, reward=10
+        )
+        self.tracker.track_learning_progress(
+            tick=1, agent_id="agent_2", q_table_change=0.2, reward=20
+        )
 
         # Tick 2
-        self.tracker.track_learning_progress(tick=2, agent_id="agent_1", q_table_change=0.05, reward=5)
-        self.tracker.track_learning_progress(tick=2, agent_id="agent_2", q_table_change=0.15, reward=15)
+        self.tracker.track_learning_progress(
+            tick=2, agent_id="agent_1", q_table_change=0.05, reward=5
+        )
+        self.tracker.track_learning_progress(
+            tick=2, agent_id="agent_2", q_table_change=0.15, reward=15
+        )
 
         summary = self.tracker.get_summary()
 
@@ -56,7 +69,9 @@ class TestLearningTracker(unittest.TestCase):
         overall = summary["overall"]
         self.assertEqual(overall["record_count"], 4)
         self.assertAlmostEqual(overall["total_q_table_change"], 0.1 + 0.2 + 0.05 + 0.15)
-        self.assertAlmostEqual(overall["average_q_table_change"], (0.1 + 0.2 + 0.05 + 0.15) / 4)
+        self.assertAlmostEqual(
+            overall["average_q_table_change"], (0.1 + 0.2 + 0.05 + 0.15) / 4
+        )
         self.assertAlmostEqual(overall["total_reward"], 10 + 20 + 5 + 15)
         self.assertAlmostEqual(overall["average_reward"], (10 + 20 + 5 + 15) / 4)
 
@@ -68,5 +83,6 @@ class TestLearningTracker(unittest.TestCase):
         self.assertAlmostEqual(agent_2_stats["total_reward"], 20 + 15)
         self.assertAlmostEqual(agent_2_stats["avg_reward"], (20 + 15) / 2)
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     unittest.main()
diff --git a/tests/test_loan_market.py b/tests/test_loan_market.py
index 31bb1eb..4d564d3 100644
--- a/tests/test_loan_market.py
+++ b/tests/test_loan_market.py
@@ -53,7 +53,7 @@ class TestLoanMarket:
         )
         transactions = loan_market_instance.place_order(order, 1)
 
-    # Update expectation to match new API (keyword args, no interest_rate passed)
+        # Update expectation to match new API (keyword args, no interest_rate passed)
         mock_bank.grant_loan.assert_called_once_with(
             borrower_id=1, amount=100, term_ticks=config.DEFAULT_LOAN_DURATION
         )
diff --git a/tests/test_marketing_roi.py b/tests/test_marketing_roi.py
index 88e5f19..a7d75fb 100644
--- a/tests/test_marketing_roi.py
+++ b/tests/test_marketing_roi.py
@@ -3,6 +3,7 @@ from unittest.mock import Mock, MagicMock
 import config
 from simulation.firms import Firm
 
+
 class TestMarketingROI(unittest.TestCase):
     def setUp(self):
         # Setup common mocks
@@ -22,7 +23,7 @@ class TestMarketingROI(unittest.TestCase):
             decision_engine=self.mock_decision_engine,
             value_orientation="profit_maximizer",
             config_module=self.config_module,
-            logger=self.mock_logger
+            logger=self.mock_logger,
         )
 
         # Reset initial tracking variables for predictable testing
@@ -66,7 +67,7 @@ class TestMarketingROI(unittest.TestCase):
         # Step 2: Current tick - Low Revenue Increase
         # Target Efficiency: delta_revenue / last_spend < 0.8
         # 0.5 = (Current_Rev - 1000) / 100 => Current_Rev = 1050
-        self.firm.revenue_this_turn = 1050.0 # Delta = 50, Eff = 0.5
+        self.firm.revenue_this_turn = 1050.0  # Delta = 50, Eff = 0.5
 
         # Run adjustment
         self.firm._adjust_marketing_budget()
@@ -83,14 +84,14 @@ class TestMarketingROI(unittest.TestCase):
         self.firm.last_revenue = 1000.0
 
         # High Efficiency scenario, but saturated
-        self.firm.revenue_this_turn = 1500.0 # Delta = 500, Eff = 5.0 (Very High)
-        self.firm.brand_manager.brand_awareness = 0.95 # Saturated (> 0.9)
+        self.firm.revenue_this_turn = 1500.0  # Delta = 500, Eff = 5.0 (Very High)
+        self.firm.brand_manager.brand_awareness = 0.95  # Saturated (> 0.9)
 
         # Run adjustment
         self.firm._adjust_marketing_budget()
 
         # Verify
-        self.assertEqual(self.firm.marketing_budget_rate, 0.05) # Unchanged
+        self.assertEqual(self.firm.marketing_budget_rate, 0.05)  # Unchanged
 
     def test_first_tick_skip(self):
         """Test that adjustment is skipped on first tick (no previous spend)."""
@@ -105,5 +106,6 @@ class TestMarketingROI(unittest.TestCase):
         self.assertEqual(self.firm.last_marketing_spend, 50.0)
         self.assertEqual(self.firm.last_revenue, 100.0)
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     unittest.main()
diff --git a/tests/test_markets_v2.py b/tests/test_markets_v2.py
index 98eb5cd..21a4035 100644
--- a/tests/test_markets_v2.py
+++ b/tests/test_markets_v2.py
@@ -337,28 +337,30 @@ class TestMarketAPI:
 
     def test_get_last_traded_price(self, market: OrderBookMarket):
         """ê±°ë˜ ë°œìƒ í›„ get_last_traded_priceê°€ ì˜¬ë°”ë¥¸ ê°€ê²©ì„ ë°˜í™˜í•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
-        market.place_order(Order(1, 'SELL', 'food', 10, 100, 'test'), 1)
-        market.place_order(Order(2, 'BUY', 'food', 10, 105, 'test'), 2)
+        market.place_order(Order(1, "SELL", "food", 10, 100, "test"), 1)
+        market.place_order(Order(2, "BUY", "food", 10, 105, "test"), 2)
         market.match_orders(2)
-        assert market.get_last_traded_price('food') == 102.5
+        assert market.get_last_traded_price("food") == 102.5
 
     def test_get_spread(self, market: OrderBookMarket):
         """ìŠ¤í”„ë ˆë“œ ê³„ì‚°ì´ ì˜¬ë°”ë¥¸ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
-        market.place_order(Order(1, 'BUY', 'food', 10, 100, 'test'), 1)
-        market.place_order(Order(2, 'SELL', 'food', 10, 105, 'test'), 2)
-        assert market.get_spread('food') == 5
+        market.place_order(Order(1, "BUY", "food", 10, 100, "test"), 1)
+        market.place_order(Order(2, "SELL", "food", 10, 105, "test"), 2)
+        assert market.get_spread("food") == 5
 
     def test_get_spread_no_bid_or_ask(self, market: OrderBookMarket):
         """ë§¤ìˆ˜/ë§¤ë„ í˜¸ê°€ê°€ ì—†ì„ ë•Œ get_spreadê°€ Noneì„ ë°˜í™˜í•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
-        market.place_order(Order(1, 'BUY', 'food', 10, 100, 'test'), 1)
-        assert market.get_spread('food') is None
-        market = OrderBookMarket(market_id="test_goods_market", logger=Logger()) # Reset market
-        market.place_order(Order(2, 'SELL', 'food', 10, 105, 'test'), 2)
-        assert market.get_spread('food') is None
+        market.place_order(Order(1, "BUY", "food", 10, 100, "test"), 1)
+        assert market.get_spread("food") is None
+        market = OrderBookMarket(
+            market_id="test_goods_market", logger=Logger()
+        )  # Reset market
+        market.place_order(Order(2, "SELL", "food", 10, 105, "test"), 2)
+        assert market.get_spread("food") is None
 
     def test_get_market_depth(self, market: OrderBookMarket):
         """ì‹œì¥ ê¹Šì´(ì£¼ë¬¸ ìˆ˜) ê³„ì‚°ì´ ì˜¬ë°”ë¥¸ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
-        market.place_order(Order(1, 'BUY', 'food', 10, 100, 'test'), 1)
-        market.place_order(Order(2, 'BUY', 'food', 5, 90, 'test'), 2)
-        market.place_order(Order(3, 'SELL', 'food', 10, 105, 'test'), 3)
-        assert market.get_market_depth('food') == {'buy_orders': 2, 'sell_orders': 1}
+        market.place_order(Order(1, "BUY", "food", 10, 100, "test"), 1)
+        market.place_order(Order(2, "BUY", "food", 5, 90, "test"), 2)
+        market.place_order(Order(3, "SELL", "food", 10, 105, "test"), 3)
+        assert market.get_market_depth("food") == {"buy_orders": 2, "sell_orders": 1}
diff --git a/tests/test_order_book_market.py b/tests/test_order_book_market.py
index af6d421..42335d6 100644
--- a/tests/test_order_book_market.py
+++ b/tests/test_order_book_market.py
@@ -441,4 +441,4 @@ class TestOrderBookMarket:
         assert len(status["buy_orders"]) == 1
         assert status["buy_orders"][0]["price"] == 90
         assert len(status["sell_orders"]) == 1
-        assert status["sell_orders"][0]["price"] == 100
\ No newline at end of file
+        assert status["sell_orders"][0]["price"] == 100
diff --git a/tests/test_phase20_integration.py b/tests/test_phase20_integration.py
index 1214e96..66b3212 100644
--- a/tests/test_phase20_integration.py
+++ b/tests/test_phase20_integration.py
@@ -1,4 +1,3 @@
-
 import pytest
 from unittest.mock import Mock, MagicMock
 from simulation.engine import Simulation
@@ -7,8 +6,8 @@ from simulation.systems.immigration_manager import ImmigrationManager
 from simulation.ai.system2_planner import System2Planner
 import config
 
-class TestPhase20Integration:
 
+class TestPhase20Integration:
     @pytest.fixture
     def mock_config(self):
         conf = MagicMock()
@@ -30,7 +29,7 @@ class TestPhase20Integration:
             "CONSERVATIVE": (0.5, 0.7),
             "MISER": (0.1, 0.3),
             "IMPULSIVE": (0.4, 0.6),
-            None: (0.3, 0.7)
+            None: (0.3, 0.7),
         }
 
         # Add INITIAL_HOUSEHOLD_ASSETS_MEAN as float, not mock
@@ -51,19 +50,19 @@ class TestPhase20Integration:
         engine.households = []
         for i in range(50):
             h = MagicMock()
-            h.is_active = True # Boolean, not Mock
+            h.is_active = True  # Boolean, not Mock
             engine.households.append(h)
         engine.goods_data = []
         engine.ai_trainer = MagicMock()
 
         # Mock Tracker Indicators
         engine.tracker.get_latest_indicators.return_value = {
-            "unemployment_rate": 0.01 # < 0.05 (Labor Shortage)
+            "unemployment_rate": 0.01  # < 0.05 (Labor Shortage)
         }
 
         # Mock Market Data (Vacancies)
         engine._prepare_market_data.return_value = {
-            "job_vacancies": 10 # > 0
+            "job_vacancies": 10  # > 0
         }
 
         # Execute
@@ -77,7 +76,8 @@ class TestPhase20Integration:
         manager = ImmigrationManager(mock_config)
         engine = MagicMock()
         engine.households = [MagicMock() for _ in range(50)]
-        for h in engine.households: h.is_active = True
+        for h in engine.households:
+            h.is_active = True
 
         # Case 1: High Unemployment
         engine.tracker.get_latest_indicators.return_value = {"unemployment_rate": 0.10}
@@ -97,8 +97,8 @@ class TestPhase20Integration:
         """Test System2Planner deducting rent for non-owners."""
         agent = MagicMock()
         agent._assets = 1000.0
-        agent.expected_wage = 10.0 # Make sure this is float
-        agent.residing_property_id = None # Homeless/Renter
+        agent.expected_wage = 10.0  # Make sure this is float
+        agent.residing_property_id = None  # Homeless/Renter
         agent.owned_properties = []
         agent.spouse_id = None
         agent.children_ids = []
@@ -108,11 +108,13 @@ class TestPhase20Integration:
         market_data = {
             "goods_market": {"basic_food_current_sell_price": 5.0},
             "housing_market": {"avg_rent_price": 50.0},
-            "debt_data": {}
+            "debt_data": {},
         }
 
         # Mock time allocation
-        agent.decision_engine.ai_engine.decide_time_allocation.return_value = {"total_obligated": 0.0}
+        agent.decision_engine.ai_engine.decide_time_allocation.return_value = {
+            "total_obligated": 0.0
+        }
 
         result = planner.project_future(1, market_data)
 
@@ -128,7 +130,7 @@ class TestPhase20Integration:
         # Compare with High Rent
         market_data_high = market_data.copy()
         market_data_high["housing_market"] = {"avg_rent_price": 200.0}
-        planner.cached_projection = {} # Clear cache
+        planner.cached_projection = {}  # Clear cache
 
         result_high = planner.project_future(2, market_data_high)
         # Flow = 80 - 10 - 200 = -130
@@ -139,7 +141,7 @@ class TestPhase20Integration:
         """Test System2Planner deducting mortgage interest for owners."""
         agent = MagicMock()
         agent._assets = 1000.0
-        agent.expected_wage = 10.0 # Make sure this is float
+        agent.expected_wage = 10.0  # Make sure this is float
         agent.residing_property_id = 1
         agent.owned_properties = [1]
         agent.id = 1
@@ -151,12 +153,12 @@ class TestPhase20Integration:
         market_data = {
             "goods_market": {"basic_food_current_sell_price": 5.0},
             "housing_market": {"avg_rent_price": 50.0},
-            "debt_data": {
-                1: {"daily_interest_burden": 30.0}
-            }
+            "debt_data": {1: {"daily_interest_burden": 30.0}},
         }
 
-        agent.decision_engine.ai_engine.decide_time_allocation.return_value = {"total_obligated": 0.0}
+        agent.decision_engine.ai_engine.decide_time_allocation.return_value = {
+            "total_obligated": 0.0
+        }
 
         result = planner.project_future(1, market_data)
 
diff --git a/tests/test_phase20_scaffolding.py b/tests/test_phase20_scaffolding.py
index 2dc1727..21391f5 100644
--- a/tests/test_phase20_scaffolding.py
+++ b/tests/test_phase20_scaffolding.py
@@ -6,6 +6,7 @@ from simulation.ai.system2_planner import System2Planner
 from simulation.ai.api import Personality
 import config
 
+
 class TestPhase20Scaffolding(unittest.TestCase):
     def setUp(self):
         self.logger = logging.getLogger("test")
@@ -27,7 +28,7 @@ class TestPhase20Scaffolding(unittest.TestCase):
             "personality": Personality.CONSERVATIVE,
             "config_module": config,
             "loan_market": self.mock_loan_market,
-            "logger": self.logger
+            "logger": self.logger,
         }
 
     def test_household_attributes_initialization(self):
@@ -75,15 +76,15 @@ class TestPhase20Scaffolding(unittest.TestCase):
         mock_agent.spouse_id = None
         mock_agent.decision_engine = MagicMock()
         mock_agent.decision_engine.ai_engine = None
-        mock_agent.get_agent_data.return_value = {"assets": 1000.0, "gender": "M", "children_count": 0}
+        mock_agent.get_agent_data.return_value = {
+            "assets": 1000.0,
+            "gender": "M",
+            "children_count": 0,
+        }
 
         planner = System2Planner(mock_agent, config)
 
-        market_data = {
-            "goods_market": {
-                "basic_food_current_sell_price": 5.0
-            }
-        }
+        market_data = {"goods_market": {"basic_food_current_sell_price": 5.0}}
 
         # Config check
         # HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK = 2.0 (from config)
@@ -96,27 +97,29 @@ class TestPhase20Scaffolding(unittest.TestCase):
         bankruptcy_tick = result["bankruptcy_tick"]
 
         self.assertIsNone(bankruptcy_tick, "Should not go bankrupt with positive flow")
-        self.assertGreater(npv, 1000.0, "NPV should be greater than initial assets with positive flow")
+        self.assertGreater(
+            npv, 1000.0, "NPV should be greater than initial assets with positive flow"
+        )
 
     def test_system2_planner_projection_bankruptcy(self):
         """Verify System2Planner bankruptcy detection."""
         # Create a mock agent for the planner
         mock_agent = MagicMock()
         mock_agent._assets = 100.0
-        mock_agent.expected_wage = 0.0 # No income
+        mock_agent.expected_wage = 0.0  # No income
         mock_agent.children_ids = []
         mock_agent.spouse_id = None
         mock_agent.decision_engine = MagicMock()
         mock_agent.decision_engine.ai_engine = None
-        mock_agent.get_agent_data.return_value = {"assets": 100.0, "gender": "M", "children_count": 0}
+        mock_agent.get_agent_data.return_value = {
+            "assets": 100.0,
+            "gender": "M",
+            "children_count": 0,
+        }
 
         planner = System2Planner(mock_agent, config)
 
-        market_data = {
-            "goods_market": {
-                "basic_food_current_sell_price": 10.0
-            }
-        }
+        market_data = {"goods_market": {"basic_food_current_sell_price": 10.0}}
 
         # Expense = 10.0 * 2.0 = 20.0 per tick
         # Assets = 100.0
@@ -133,5 +136,6 @@ class TestPhase20Scaffolding(unittest.TestCase):
 
         self.assertEqual(bankruptcy_tick, 6)
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     unittest.main()
diff --git a/tests/test_phase29_depression.py b/tests/test_phase29_depression.py
index 3978b0e..ac09860 100644
--- a/tests/test_phase29_depression.py
+++ b/tests/test_phase29_depression.py
@@ -1,4 +1,3 @@
-
 import unittest
 import os
 import shutil
@@ -12,6 +11,7 @@ from simulation.db.repository import SimulationRepository
 from simulation.ai_model import AIEngineRegistry
 import logging
 
+
 class TestPhase29Depression(unittest.TestCase):
     def setUp(self):
         # Setup Logger
@@ -20,6 +20,7 @@ class TestPhase29Depression(unittest.TestCase):
 
         # Setup ConfigManager with Mock Config
         self.config_manager = MagicMock(spec=ConfigManager)
+
         # Mocking get method to return appropriate values
         def config_get_side_effect(key, default=None):
             if key == "bank_defaults.initial_base_annual_rate":
@@ -27,6 +28,7 @@ class TestPhase29Depression(unittest.TestCase):
             if key == "simulation.household_consumable_goods":
                 return ["food", "electronics"]
             return default
+
         self.config_manager.get.side_effect = config_get_side_effect
 
         self.config_module = MagicMock()
@@ -88,7 +90,7 @@ class TestPhase29Depression(unittest.TestCase):
             BIOLOGICAL_FERTILITY_RATE=0.15,
             POPULATION_IMMIGRATION_THRESHOLD=80,
             INFRASTRUCTURE_INVESTMENT_COST=5000.0,
-            REPRODUCTION_AGE_START=200, # Prevent births
+            REPRODUCTION_AGE_START=200,  # Prevent births
             REPRODUCTION_AGE_END=45,
             BANKRUPTCY_LOSS_THRESHOLD=10,
             MA_ENABLED=True,
@@ -100,7 +102,7 @@ class TestPhase29Depression(unittest.TestCase):
             INITIAL_HOUSEHOLD_ASSETS_MEAN=1000.0,
             EDUCATION_COST_PER_LEVEL={1: 500},
             SCHOLARSHIP_WEALTH_PERCENTILE=0.20,
-            SCHOLARSHIP_POTENTIAL_THRESHOLD=0.7
+            SCHOLARSHIP_POTENTIAL_THRESHOLD=0.7,
         )
 
         # Create dummy agents
@@ -172,7 +174,7 @@ class TestPhase29Depression(unittest.TestCase):
                 "working_capital": 5500.0,
                 "retained_earnings": 1000.0,
                 "average_profit": 100.0,
-                "total_debt": 0.0
+                "total_debt": 0.0,
             }
 
         self.repository = MagicMock(spec=SimulationRepository)
@@ -183,12 +185,15 @@ class TestPhase29Depression(unittest.TestCase):
         self.initializer = SimulationInitializer(
             config_manager=self.config_manager,
             config_module=self.config_module,
-            goods_data=[{"id": "food", "name": "food"}, {"id": "electronics", "name": "electronics"}],
+            goods_data=[
+                {"id": "food", "name": "food"},
+                {"id": "electronics", "name": "electronics"},
+            ],
             repository=self.repository,
             logger=self.logger,
             households=self.households,
             firms=self.firms,
-            ai_trainer=self.ai_trainer
+            ai_trainer=self.ai_trainer,
         )
 
         # Build Simulation
@@ -212,16 +217,18 @@ class TestPhase29Depression(unittest.TestCase):
 
         # Ensure Phase 29 Scenario is Active and Configured
         if not self.sim.stress_scenario_config.is_active:
-             print("WARNING: Scenario not loaded from file during test setup. Manually enabling.")
-             self.sim.stress_scenario_config.is_active = True
-             self.sim.stress_scenario_config.scenario_name = "phase29_depression"
-             self.sim.stress_scenario_config.start_tick = 50
-             self.sim.stress_scenario_config.monetary_shock_target_rate = 0.08
-             self.sim.stress_scenario_config.fiscal_shock_tax_rate = 0.30
+            print(
+                "WARNING: Scenario not loaded from file during test setup. Manually enabling."
+            )
+            self.sim.stress_scenario_config.is_active = True
+            self.sim.stress_scenario_config.scenario_name = "phase29_depression"
+            self.sim.stress_scenario_config.start_tick = 50
+            self.sim.stress_scenario_config.monetary_shock_target_rate = 0.08
+            self.sim.stress_scenario_config.fiscal_shock_tax_rate = 0.30
 
     def tearDown(self):
         # Cleanup reports
-        if hasattr(self.sim, 'run_id'):
+        if hasattr(self.sim, "run_id"):
             report_file = f"reports/crisis_monitor_{self.sim.run_id}.csv"
             if os.path.exists(report_file):
                 os.remove(report_file)
@@ -232,7 +239,9 @@ class TestPhase29Depression(unittest.TestCase):
         # Verify initial state
         initial_base_rate = self.sim.bank.base_rate
         initial_tax_rate = self.sim.government.corporate_tax_rate
-        print(f"Initial State: Base Rate={initial_base_rate}, Tax Rate={initial_tax_rate}")
+        print(
+            f"Initial State: Base Rate={initial_base_rate}, Tax Rate={initial_tax_rate}"
+        )
 
         # Run until before shock
         start_tick = self.sim.stress_scenario_config.start_tick
@@ -245,27 +254,38 @@ class TestPhase29Depression(unittest.TestCase):
         current_base_rate = self.sim.bank.base_rate
         current_tax_rate = self.sim.government.corporate_tax_rate
 
-        print(f"Tick {self.sim.time} State: Base Rate={current_base_rate}, Tax Rate={current_tax_rate}")
+        print(
+            f"Tick {self.sim.time} State: Base Rate={current_base_rate}, Tax Rate={current_tax_rate}"
+        )
 
-        self.assertAlmostEqual(current_base_rate, 0.08, delta=0.005, msg="Monetary Shock failed")
-        self.assertAlmostEqual(current_tax_rate, 0.30, delta=0.001, msg="Fiscal Shock failed")
+        self.assertAlmostEqual(
+            current_base_rate, 0.08, delta=0.005, msg="Monetary Shock failed"
+        )
+        self.assertAlmostEqual(
+            current_tax_rate, 0.30, delta=0.001, msg="Fiscal Shock failed"
+        )
 
     def test_crisis_monitor_logging(self):
         """Test that crisis monitor logs data."""
-        self.sim.run_tick() # Tick 1
-        self.sim.run_tick() # Tick 2
+        self.sim.run_tick()  # Tick 1
+        self.sim.run_tick()  # Tick 2
 
         report_file = f"reports/crisis_monitor_{self.sim.run_id}.csv"
-        self.assertTrue(os.path.exists(report_file), "Crisis Monitor report file not created.")
+        self.assertTrue(
+            os.path.exists(report_file), "Crisis Monitor report file not created."
+        )
 
-        with open(report_file, 'r') as f:
+        with open(report_file, "r") as f:
             reader = csv.reader(f)
             rows = list(reader)
-            self.assertGreater(len(rows), 2, "Report should have header and at least 2 ticks of data.")
+            self.assertGreater(
+                len(rows), 2, "Report should have header and at least 2 ticks of data."
+            )
 
             last_row = rows[-1]
             print(f"Monitor Log Entry: {last_row}")
             self.assertEqual(int(last_row[4]), 5)
 
+
 if __name__ == "__main__":
     unittest.main()
diff --git a/tests/test_portfolio_integration.py b/tests/test_portfolio_integration.py
index 36a0e54..5929462 100644
--- a/tests/test_portfolio_integration.py
+++ b/tests/test_portfolio_integration.py
@@ -4,6 +4,7 @@ from simulation.decisions.portfolio_manager import PortfolioManager
 from simulation.core_agents import Household
 from simulation.bank import Bank
 
+
 class TestPortfolioIntegration(unittest.TestCase):
     def test_portfolio_manager_logic(self):
         # Case 1: Normal
@@ -25,7 +26,7 @@ class TestPortfolioIntegration(unittest.TestCase):
             risk_free_rate=0.05,
             equity_return_proxy=0.15,
             survival_cost=1000.0,
-            inflation_expectation=0.0
+            inflation_expectation=0.0,
         )
 
         self.assertEqual(cash, 1000.0)
@@ -44,11 +45,11 @@ class TestPortfolioIntegration(unittest.TestCase):
             risk_free_rate=0.05,
             equity_return_proxy=0.15,
             survival_cost=1000.0,
-            inflation_expectation=0.0
+            inflation_expectation=0.0,
         )
 
         self.assertEqual(cash, 1000.0)
-        self.assertEqual(deposit, 9000.0) # All surplus to deposit
+        self.assertEqual(deposit, 9000.0)  # All surplus to deposit
         self.assertEqual(equity, 0.0)
 
     def test_bank_deposit_balance(self):
@@ -56,7 +57,7 @@ class TestPortfolioIntegration(unittest.TestCase):
         bank.deposits = {
             "d1": MagicMock(depositor_id=1, amount=100.0),
             "d2": MagicMock(depositor_id=2, amount=200.0),
-            "d3": MagicMock(depositor_id=1, amount=50.0)
+            "d3": MagicMock(depositor_id=1, amount=50.0),
         }
 
         balance = bank.get_deposit_balance(1)
@@ -68,5 +69,6 @@ class TestPortfolioIntegration(unittest.TestCase):
         balance_3 = bank.get_deposit_balance(3)
         self.assertEqual(balance_3, 0.0)
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     unittest.main()
diff --git a/tests/test_portfolio_macro.py b/tests/test_portfolio_macro.py
index 86d15ac..26ba177 100644
--- a/tests/test_portfolio_macro.py
+++ b/tests/test_portfolio_macro.py
@@ -1,7 +1,7 @@
-
 from simulation.dtos import MacroFinancialContext
 from simulation.decisions.portfolio_manager import PortfolioManager
 
+
 def test_portfolio_optimization_under_stagflation():
     """
     Integration test to verify that a household reduces equity allocation
@@ -20,17 +20,19 @@ def test_portfolio_optimization_under_stagflation():
         inflation_rate=0.02,
         gdp_growth_rate=0.03,
         market_volatility=0.1,
-        interest_rate_trend=0.0
+        interest_rate_trend=0.0,
     )
 
-    target_cash_normal, target_deposit_normal, target_equity_normal = PortfolioManager.optimize_portfolio(
-        total_liquid_assets=total_assets,
-        risk_aversion=risk_aversion,
-        risk_free_rate=risk_free_rate,
-        equity_return_proxy=equity_return_proxy,
-        survival_cost=survival_cost,
-        inflation_expectation=inflation_expectation,
-        macro_context=normal_context
+    target_cash_normal, target_deposit_normal, target_equity_normal = (
+        PortfolioManager.optimize_portfolio(
+            total_liquid_assets=total_assets,
+            risk_aversion=risk_aversion,
+            risk_free_rate=risk_free_rate,
+            equity_return_proxy=equity_return_proxy,
+            survival_cost=survival_cost,
+            inflation_expectation=inflation_expectation,
+            macro_context=normal_context,
+        )
     )
 
     # 3. Optimize under stagflation conditions
@@ -38,17 +40,19 @@ def test_portfolio_optimization_under_stagflation():
         inflation_rate=0.10,
         gdp_growth_rate=-0.02,
         market_volatility=0.3,
-        interest_rate_trend=0.01
+        interest_rate_trend=0.01,
     )
 
-    target_cash_stag, target_deposit_stag, target_equity_stag = PortfolioManager.optimize_portfolio(
-        total_liquid_assets=total_assets,
-        risk_aversion=risk_aversion,
-        risk_free_rate=risk_free_rate,
-        equity_return_proxy=equity_return_proxy,
-        survival_cost=survival_cost,
-        inflation_expectation=inflation_expectation,
-        macro_context=stagflation_context
+    target_cash_stag, target_deposit_stag, target_equity_stag = (
+        PortfolioManager.optimize_portfolio(
+            total_liquid_assets=total_assets,
+            risk_aversion=risk_aversion,
+            risk_free_rate=risk_free_rate,
+            equity_return_proxy=equity_return_proxy,
+            survival_cost=survival_cost,
+            inflation_expectation=inflation_expectation,
+            macro_context=stagflation_context,
+        )
     )
 
     # 4. Assert that equity allocation is lower under stagflation
diff --git a/tests/test_purity_gate.py b/tests/test_purity_gate.py
index 3d586a2..8aa5cd3 100644
--- a/tests/test_purity_gate.py
+++ b/tests/test_purity_gate.py
@@ -1,16 +1,20 @@
-
 import pytest
 from unittest.mock import MagicMock
 from simulation.dtos import DecisionContext, FirmStateDTO
 from modules.household.dtos import HouseholdStateDTO
-from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
-from simulation.decisions.standalone_rule_based_firm_engine import StandaloneRuleBasedFirmDecisionEngine
+from simulation.decisions.ai_driven_household_engine import (
+    AIDrivenHouseholdDecisionEngine,
+)
+from simulation.decisions.standalone_rule_based_firm_engine import (
+    StandaloneRuleBasedFirmDecisionEngine,
+)
 from simulation.decisions.ai_driven_firm_engine import AIDrivenFirmDecisionEngine
 
+
 def test_decision_context_purity():
     """Verify DecisionContext does not expose raw agents."""
-    assert not hasattr(DecisionContext, 'household')
-    assert not hasattr(DecisionContext, 'firm')
+    assert not hasattr(DecisionContext, "household")
+    assert not hasattr(DecisionContext, "firm")
 
     # Try to instantiate with deprecated fields (should fail type check or init if slots used,
     # but since it's a dataclass, it might accept kwargs if we are not careful,
@@ -18,14 +22,19 @@ def test_decision_context_purity():
 
     try:
         DecisionContext(
-            markets={}, goods_data=[], market_data={}, current_time=0,
-            state=MagicMock(), config=MagicMock(),
-            household=MagicMock() # Should fail
+            markets={},
+            goods_data=[],
+            market_data={},
+            current_time=0,
+            state=MagicMock(),
+            config=MagicMock(),
+            household=MagicMock(),  # Should fail
         )
         pytest.fail("DecisionContext accepted 'household' argument.")
     except TypeError:
         pass
 
+
 def test_standalone_firm_engine_uses_dto():
     """Verify StandaloneRuleBasedFirmDecisionEngine accepts FirmStateDTO."""
     config_mock = MagicMock()
@@ -41,7 +50,7 @@ def test_standalone_firm_engine_uses_dto():
     config_mock.MIN_SELL_PRICE = 1.0
     config_mock.MAX_SELL_PRICE = 100.0
     config_mock.MAX_SELL_QUANTITY = 100.0
-    config_mock.BASE_WAGE = 10.0 # Float, not Mock
+    config_mock.BASE_WAGE = 10.0  # Float, not Mock
     # Fix getattr(mock) returning Mock instead of default
     config_mock.GENESIS_PRICE_ADJUSTMENT_MULTIPLIER = 1.0
     config_mock.PRICE_ADJUSTMENT_EXPONENT = 1.0
@@ -50,12 +59,38 @@ def test_standalone_firm_engine_uses_dto():
     engine = StandaloneRuleBasedFirmDecisionEngine(config_mock)
 
     firm_dto = FirmStateDTO(
-        id=1, assets=1000.0, is_active=True, inventory={"wood": 50.0}, inventory_quality={}, input_inventory={},
-        current_production=0.0, productivity_factor=1.0, production_target=50.0, capital_stock=10.0, base_quality=1.0,
-        automation_level=0.0, specialization="wood", total_shares=100, treasury_shares=0, dividend_rate=0.0,
-        is_publicly_traded=False, valuation=0.0, revenue_this_turn=0.0, expenses_this_tick=0.0, consecutive_loss_turns=0,
-        altman_z_score=0.0, price_history={"wood": 10.0}, profit_history=[], brand_awareness=0.0, perceived_quality=0.0,
-        marketing_budget=0.0, employees=[], employees_data={}, agent_data={}, system2_guidance={}, sentiment_index=0.5
+        id=1,
+        assets=1000.0,
+        is_active=True,
+        inventory={"wood": 50.0},
+        inventory_quality={},
+        input_inventory={},
+        current_production=0.0,
+        productivity_factor=1.0,
+        production_target=50.0,
+        capital_stock=10.0,
+        base_quality=1.0,
+        automation_level=0.0,
+        specialization="wood",
+        total_shares=100,
+        treasury_shares=0,
+        dividend_rate=0.0,
+        is_publicly_traded=False,
+        valuation=0.0,
+        revenue_this_turn=0.0,
+        expenses_this_tick=0.0,
+        consecutive_loss_turns=0,
+        altman_z_score=0.0,
+        price_history={"wood": 10.0},
+        profit_history=[],
+        brand_awareness=0.0,
+        perceived_quality=0.0,
+        marketing_budget=0.0,
+        employees=[],
+        employees_data={},
+        agent_data={},
+        system2_guidance={},
+        sentiment_index=0.5,
     )
 
     context = MagicMock(spec=DecisionContext)
@@ -70,19 +105,19 @@ def test_standalone_firm_engine_uses_dto():
     assert isinstance(orders, list)
     # Check that it didn't crash
 
+
 def test_household_engine_uses_dto():
     """Verify AIDrivenHouseholdDecisionEngine accepts HouseholdStateDTO."""
     ai_engine_mock = MagicMock()
     ai_engine_mock.decide_action_vector.return_value = MagicMock(
-        consumption_aggressiveness={},
-        job_mobility_aggressiveness=0.0
+        consumption_aggressiveness={}, job_mobility_aggressiveness=0.0
     )
 
     config_mock = MagicMock()
     config_mock.GOODS = {"food": {}}
     config_mock.HOUSEHOLD_MAX_PURCHASE_QUANTITY = 10
     config_mock.DSR_CRITICAL_THRESHOLD = 0.5
-    config_mock.MARKET_PRICE_FALLBACK = 10.0 # Float
+    config_mock.MARKET_PRICE_FALLBACK = 10.0  # Float
     config_mock.BULK_BUY_NEED_THRESHOLD = 100.0
     config_mock.BULK_BUY_AGG_THRESHOLD = 0.8
     config_mock.PANIC_BUYING_THRESHOLD = 0.05
@@ -95,7 +130,9 @@ def test_household_engine_uses_dto():
 
     engine = AIDrivenHouseholdDecisionEngine(ai_engine_mock, config_mock)
 
-    household_dto = MagicMock(spec=HouseholdStateDTO) # Using Mock of DTO for simplicity
+    household_dto = MagicMock(
+        spec=HouseholdStateDTO
+    )  # Using Mock of DTO for simplicity
     household_dto.id = 1
     household_dto.agent_data = {}
     household_dto.inventory = {"basic_food": 10.0}
@@ -103,7 +140,7 @@ def test_household_engine_uses_dto():
     household_dto.assets = 1000.0
     household_dto.current_wage = 10.0
     household_dto.expected_inflation = {}
-    household_dto.personality = "BALANCED" # Enum mock
+    household_dto.personality = "BALANCED"  # Enum mock
     household_dto.preference_asset = 1.0
     household_dto.preference_social = 1.0
     household_dto.preference_growth = 1.0
diff --git a/tests/test_repository.py b/tests/test_repository.py
index 2cd2f81..8bf3ab9 100644
--- a/tests/test_repository.py
+++ b/tests/test_repository.py
@@ -83,7 +83,9 @@ def test_save_and_get_agent_state(test_repo: SimulationRepository):
 
     retrieved_state = retrieved_states[0]
     assert retrieved_state["agent_id"] == 101
-    assert retrieved_state["assets"] == 100.0 # Changed from 1000.0 to 100.0 to match DTO
+    assert (
+        retrieved_state["assets"] == 100.0
+    )  # Changed from 1000.0 to 100.0 to match DTO
     assert retrieved_state["inventory_food"] == 10.0
 
 
diff --git a/tests/test_socio_tech.py b/tests/test_socio_tech.py
index 62d0914..d23ba31 100644
--- a/tests/test_socio_tech.py
+++ b/tests/test_socio_tech.py
@@ -5,6 +5,7 @@ from simulation.ai.api import Personality
 from simulation.ai.household_ai import HouseholdAI
 import config
 
+
 class TestSocioTechDynamics(unittest.TestCase):
     def setUp(self):
         # Override Config
@@ -38,7 +39,7 @@ class TestSocioTechDynamics(unittest.TestCase):
             decision_engine=MagicMock(),
             value_orientation="wealth_and_needs",
             personality=Personality.CONSERVATIVE,
-            config_module=config
+            config_module=config,
         )
         agent.decision_engine.ai_engine = ai
         agent.decision_engine.config_module = config
@@ -52,7 +53,7 @@ class TestSocioTechDynamics(unittest.TestCase):
         Verify Female Labor Drop.
         """
         config.FORMULA_TECH_LEVEL = 0.0
-        children_data = [{"age": 1}] # Infant
+        children_data = [{"age": 1}]  # Infant
         spouse_data_m = {"id": self.female.id}
         spouse_data_f = {"id": self.male.id}
 
@@ -67,27 +68,37 @@ class TestSocioTechDynamics(unittest.TestCase):
         )
 
         print("\n[Scenario A: Dark Ages]")
-        print(f"Male Obligations: {alloc_m['total_obligated']} (HW: {alloc_m['housework']}, CC: {alloc_m['childcare']})")
-        print(f"Female Obligations: {alloc_f['total_obligated']} (HW: {alloc_f['housework']}, CC: {alloc_f['childcare']})")
+        print(
+            f"Male Obligations: {alloc_m['total_obligated']} (HW: {alloc_m['housework']}, CC: {alloc_m['childcare']})"
+        )
+        print(
+            f"Female Obligations: {alloc_f['total_obligated']} (HW: {alloc_f['housework']}, CC: {alloc_f['childcare']})"
+        )
 
         # Assertions
         # Housework split 50/50 (6.0 / 2 = 3.0)
-        self.assertEqual(alloc_m['housework'], 3.0)
-        self.assertEqual(alloc_f['housework'], 3.0)
+        self.assertEqual(alloc_m["housework"], 3.0)
+        self.assertEqual(alloc_f["housework"], 3.0)
 
         # Childcare: Female takes all (8.0)
-        self.assertEqual(alloc_f['childcare'], 8.0)
-        self.assertEqual(alloc_m['childcare'], 0.0)
+        self.assertEqual(alloc_f["childcare"], 8.0)
+        self.assertEqual(alloc_m["childcare"], 0.0)
 
         # Labor Capacity (Max 14)
-        labor_cap_m = max(0, 14 - alloc_m['total_obligated'])
-        labor_cap_f = max(0, 14 - alloc_f['total_obligated'])
+        labor_cap_m = max(0, 14 - alloc_m["total_obligated"])
+        labor_cap_f = max(0, 14 - alloc_f["total_obligated"])
 
         print(f"Male Labor Cap: {labor_cap_m}h")
         print(f"Female Labor Cap: {labor_cap_f}h")
 
-        self.assertLess(labor_cap_f, labor_cap_m, "Female should have significantly less labor capacity")
-        self.assertLessEqual(labor_cap_f, 4.0, "Female labor capacity should be critically low (<= 4h)")
+        self.assertLess(
+            labor_cap_f,
+            labor_cap_m,
+            "Female should have significantly less labor capacity",
+        )
+        self.assertLessEqual(
+            labor_cap_f, 4.0, "Female labor capacity should be critically low (<= 4h)"
+        )
 
     def test_scenario_b_techno_optimism(self):
         """
@@ -111,14 +122,16 @@ class TestSocioTechDynamics(unittest.TestCase):
         print(f"Female Obligations: {alloc_f['total_obligated']}")
 
         # Childcare Shared (4.0 each)
-        self.assertEqual(alloc_f['childcare'], 4.0)
-        self.assertEqual(alloc_m['childcare'], 4.0)
+        self.assertEqual(alloc_f["childcare"], 4.0)
+        self.assertEqual(alloc_m["childcare"], 4.0)
 
         # Labor Capacity
-        labor_cap_f = max(0, 14 - alloc_f['total_obligated'])
+        labor_cap_f = max(0, 14 - alloc_f["total_obligated"])
         print(f"Female Labor Cap: {labor_cap_f}h")
 
-        self.assertEqual(labor_cap_f, 7.0, "Female labor capacity should recover to 7h (14 - 3 - 4)")
+        self.assertEqual(
+            labor_cap_f, 7.0, "Female labor capacity should recover to 7h (14 - 3 - 4)"
+        )
 
     def test_appliance_effect(self):
         """
@@ -128,12 +141,15 @@ class TestSocioTechDynamics(unittest.TestCase):
         self.female.home_quality_score = 1.5
 
         alloc_m = self.male.decision_engine.ai_engine.decide_time_allocation(
-            self.male.get_agent_data(), {"id":2}, [], config
+            self.male.get_agent_data(), {"id": 2}, [], config
         )
 
         # Base 6.0 -> Reduced to 3.0 total -> Shared 1.5 each
-        self.assertEqual(alloc_m['housework'], 1.5)
-        print(f"\n[Appliance Effect] Housework per person: {alloc_m['housework']}h (Reduced from 3.0h)")
+        self.assertEqual(alloc_m["housework"], 1.5)
+        print(
+            f"\n[Appliance Effect] Housework per person: {alloc_m['housework']}h (Reduced from 3.0h)"
+        )
+
 
 if __name__ == "__main__":
     unittest.main()
diff --git a/tests/test_stock_market.py b/tests/test_stock_market.py
index a6bca52..96649aa 100644
--- a/tests/test_stock_market.py
+++ b/tests/test_stock_market.py
@@ -82,13 +82,13 @@ class TestStockMarketInitialization:
         mock_firm = golden_firms[0]
         mock_firm.id = 100
         mock_firm.is_active = True
-        
+
         # Since logic is delegated to firm.get_book_value_per_share, we just mock that return value
         mock_firm.get_book_value_per_share.return_value = 80.0
 
         firms = {100: mock_firm}
         stock_market.update_reference_prices(firms)
-        
+
         assert 100 in stock_market.reference_prices
         assert stock_market.reference_prices[100] == 80.0
 
@@ -97,33 +97,39 @@ class TestStockOrderPlacement:
     def test_place_buy_order(self, stock_market, sample_buy_order):
         # ê¸°ì¤€ê°€ ì„¤ì • (ê°€ê²© ì œí•œ ì²´í¬ë¥¼ ìœ„í•´)
         stock_market.reference_prices[100] = 50.0
-        
+
         stock_market.place_order(sample_buy_order, tick=1)
-        
+
         assert 100 in stock_market.buy_orders
         assert len(stock_market.buy_orders[100]) == 1
         assert stock_market.buy_orders[100][0].price == 50.0
 
     def test_place_sell_order(self, stock_market, sample_sell_order):
         stock_market.reference_prices[100] = 50.0
-        
+
         stock_market.place_order(sample_sell_order, tick=1)
-        
+
         assert 100 in stock_market.sell_orders
         assert len(stock_market.sell_orders[100]) == 1
         assert stock_market.sell_orders[100][0].price == 45.0
 
     def test_buy_orders_sorted_by_price_descending(self, stock_market):
         stock_market.reference_prices[100] = 50.0
-        
-        order1 = StockOrder(agent_id=1, order_type="BUY", firm_id=100, quantity=5.0, price=45.0)
-        order2 = StockOrder(agent_id=2, order_type="BUY", firm_id=100, quantity=5.0, price=55.0)
-        order3 = StockOrder(agent_id=3, order_type="BUY", firm_id=100, quantity=5.0, price=50.0)
-        
+
+        order1 = StockOrder(
+            agent_id=1, order_type="BUY", firm_id=100, quantity=5.0, price=45.0
+        )
+        order2 = StockOrder(
+            agent_id=2, order_type="BUY", firm_id=100, quantity=5.0, price=55.0
+        )
+        order3 = StockOrder(
+            agent_id=3, order_type="BUY", firm_id=100, quantity=5.0, price=50.0
+        )
+
         stock_market.place_order(order1, tick=1)
         stock_market.place_order(order2, tick=1)
         stock_market.place_order(order3, tick=1)
-        
+
         # ë†’ì€ ê°€ê²©ìˆœìœ¼ë¡œ ì •ë ¬ë˜ì–´ì•¼ í•¨
         assert stock_market.buy_orders[100][0].price == 55.0
         assert stock_market.buy_orders[100][1].price == 50.0
@@ -131,15 +137,21 @@ class TestStockOrderPlacement:
 
     def test_sell_orders_sorted_by_price_ascending(self, stock_market):
         stock_market.reference_prices[100] = 50.0
-        
-        order1 = StockOrder(agent_id=1, order_type="SELL", firm_id=100, quantity=5.0, price=55.0)
-        order2 = StockOrder(agent_id=2, order_type="SELL", firm_id=100, quantity=5.0, price=45.0)
-        order3 = StockOrder(agent_id=3, order_type="SELL", firm_id=100, quantity=5.0, price=50.0)
-        
+
+        order1 = StockOrder(
+            agent_id=1, order_type="SELL", firm_id=100, quantity=5.0, price=55.0
+        )
+        order2 = StockOrder(
+            agent_id=2, order_type="SELL", firm_id=100, quantity=5.0, price=45.0
+        )
+        order3 = StockOrder(
+            agent_id=3, order_type="SELL", firm_id=100, quantity=5.0, price=50.0
+        )
+
         stock_market.place_order(order1, tick=1)
         stock_market.place_order(order2, tick=1)
         stock_market.place_order(order3, tick=1)
-        
+
         # ë‚®ì€ ê°€ê²©ìˆœìœ¼ë¡œ ì •ë ¬ë˜ì–´ì•¼ í•¨
         assert stock_market.sell_orders[100][0].price == 45.0
         assert stock_market.sell_orders[100][1].price == 50.0
@@ -149,12 +161,12 @@ class TestStockOrderPlacement:
 class TestStockOrderMatching:
     def test_full_match(self, stock_market, sample_buy_order, sample_sell_order):
         stock_market.reference_prices[100] = 50.0
-        
+
         stock_market.place_order(sample_buy_order, tick=1)
         stock_market.place_order(sample_sell_order, tick=1)
-        
+
         transactions = stock_market.match_orders(tick=1)
-        
+
         assert len(transactions) == 1
         tx = transactions[0]
         assert tx.buyer_id == 1
@@ -166,36 +178,44 @@ class TestStockOrderMatching:
 
     def test_partial_match_buy_order_larger(self, stock_market):
         stock_market.reference_prices[100] = 50.0
-        
-        buy_order = StockOrder(agent_id=1, order_type="BUY", firm_id=100, quantity=15.0, price=50.0)
-        sell_order = StockOrder(agent_id=2, order_type="SELL", firm_id=100, quantity=10.0, price=45.0)
-        
+
+        buy_order = StockOrder(
+            agent_id=1, order_type="BUY", firm_id=100, quantity=15.0, price=50.0
+        )
+        sell_order = StockOrder(
+            agent_id=2, order_type="SELL", firm_id=100, quantity=10.0, price=45.0
+        )
+
         stock_market.place_order(buy_order, tick=1)
         stock_market.place_order(sell_order, tick=1)
-        
+
         transactions = stock_market.match_orders(tick=1)
-        
+
         assert len(transactions) == 1
         assert transactions[0].quantity == 10.0
-        
+
         # ë§¤ìˆ˜ ì£¼ë¬¸ ì”ëŸ‰ í™•ì¸
         assert len(stock_market.buy_orders[100]) == 1
         assert stock_market.buy_orders[100][0].quantity == 5.0
-        
+
         # ë§¤ë„ ì£¼ë¬¸ì€ ì™„ë£Œë˜ì–´ ì œê±°ë¨
         assert len(stock_market.sell_orders[100]) == 0
 
     def test_no_match_price_gap(self, stock_market):
         stock_market.reference_prices[100] = 50.0
-        
-        buy_order = StockOrder(agent_id=1, order_type="BUY", firm_id=100, quantity=10.0, price=40.0)
-        sell_order = StockOrder(agent_id=2, order_type="SELL", firm_id=100, quantity=10.0, price=55.0)
-        
+
+        buy_order = StockOrder(
+            agent_id=1, order_type="BUY", firm_id=100, quantity=10.0, price=40.0
+        )
+        sell_order = StockOrder(
+            agent_id=2, order_type="SELL", firm_id=100, quantity=10.0, price=55.0
+        )
+
         stock_market.place_order(buy_order, tick=1)
         stock_market.place_order(sell_order, tick=1)
-        
+
         transactions = stock_market.match_orders(tick=1)
-        
+
         assert len(transactions) == 0
         assert len(stock_market.buy_orders[100]) == 1
         assert len(stock_market.sell_orders[100]) == 1
@@ -205,36 +225,44 @@ class TestStockPriceQueries:
     def test_get_stock_price_with_last_price(self, stock_market):
         stock_market.last_prices[100] = 52.0
         stock_market.reference_prices[100] = 50.0
-        
+
         price = stock_market.get_stock_price(100)
         assert price == 52.0  # ìµœê·¼ ê±°ë˜ê°€ ìš°ì„ 
 
     def test_get_stock_price_fallback_to_reference(self, stock_market):
         stock_market.reference_prices[100] = 50.0
-        
+
         price = stock_market.get_stock_price(100)
         assert price == 50.0
 
     def test_get_best_bid(self, stock_market):
         stock_market.reference_prices[100] = 50.0
-        
-        order1 = StockOrder(agent_id=1, order_type="BUY", firm_id=100, quantity=5.0, price=48.0)
-        order2 = StockOrder(agent_id=2, order_type="BUY", firm_id=100, quantity=5.0, price=52.0)
-        
+
+        order1 = StockOrder(
+            agent_id=1, order_type="BUY", firm_id=100, quantity=5.0, price=48.0
+        )
+        order2 = StockOrder(
+            agent_id=2, order_type="BUY", firm_id=100, quantity=5.0, price=52.0
+        )
+
         stock_market.place_order(order1, tick=1)
         stock_market.place_order(order2, tick=1)
-        
+
         assert stock_market.get_best_bid(100) == 52.0
 
     def test_get_best_ask(self, stock_market):
         stock_market.reference_prices[100] = 50.0
-        
-        order1 = StockOrder(agent_id=1, order_type="SELL", firm_id=100, quantity=5.0, price=48.0)
-        order2 = StockOrder(agent_id=2, order_type="SELL", firm_id=100, quantity=5.0, price=52.0)
-        
+
+        order1 = StockOrder(
+            agent_id=1, order_type="SELL", firm_id=100, quantity=5.0, price=48.0
+        )
+        order2 = StockOrder(
+            agent_id=2, order_type="SELL", firm_id=100, quantity=5.0, price=52.0
+        )
+
         stock_market.place_order(order1, tick=1)
         stock_market.place_order(order2, tick=1)
-        
+
         assert stock_market.get_best_ask(100) == 48.0
 
 
@@ -242,20 +270,24 @@ class TestOrderExpiry:
     def test_clear_expired_orders(self, stock_market, mock_config):
         mock_config.STOCK_ORDER_EXPIRY_TICKS = 3
         stock_market.reference_prices[100] = 50.0
-        
+
         # í‹± 1ì— ì£¼ë¬¸ ìƒì„±
-        order1 = StockOrder(agent_id=1, order_type="BUY", firm_id=100, quantity=5.0, price=50.0)
+        order1 = StockOrder(
+            agent_id=1, order_type="BUY", firm_id=100, quantity=5.0, price=50.0
+        )
         stock_market.place_order(order1, tick=1)
-        
+
         # í‹± 2ì— ì£¼ë¬¸ ìƒì„±
-        order2 = StockOrder(agent_id=2, order_type="BUY", firm_id=100, quantity=5.0, price=49.0)
+        order2 = StockOrder(
+            agent_id=2, order_type="BUY", firm_id=100, quantity=5.0, price=49.0
+        )
         stock_market.place_order(order2, tick=2)
-        
+
         # í‹± 5ì—ì„œ ë§Œë£Œ ì²´í¬ (expiry = 3í‹±)
         # order1ì€ í‹± 1ì— ìƒì„± -> 5 - 1 = 4 >= 3 -> ë§Œë£Œ
         # order2ëŠ” í‹± 2ì— ìƒì„± -> 5 - 2 = 3 >= 3 -> ë§Œë£Œ
         removed = stock_market.clear_expired_orders(current_tick=5)
-        
+
         assert removed == 2
         assert len(stock_market.buy_orders[100]) == 0
 
@@ -267,9 +299,9 @@ class TestMarketSummary:
         stock_market.daily_volumes[100] = 100.0
         stock_market.daily_high[100] = 55.0
         stock_market.daily_low[100] = 48.0
-        
+
         summary = stock_market.get_market_summary(100)
-        
+
         assert summary["firm_id"] == 100
         assert summary["last_price"] == 52.0
         assert summary["reference_price"] == 50.0
@@ -277,13 +309,22 @@ class TestMarketSummary:
         assert summary["daily_high"] == 55.0
         assert summary["daily_low"] == 48.0
 
+
 def test_ipo_share_count(stock_market, mock_config):
     from simulation.firms import Firm
+
     mock_config.PROFIT_HISTORY_TICKS = 10
     firm_decision_engine = MagicMock()
-    firm = Firm(id=1, initial_capital=10000, initial_liquidity_need=100, specialization="food",
-                productivity_factor=1, decision_engine=firm_decision_engine, value_orientation="v",
-                config_module=mock_config)
+    firm = Firm(
+        id=1,
+        initial_capital=10000,
+        initial_liquidity_need=100,
+        specialization="food",
+        productivity_factor=1,
+        decision_engine=firm_decision_engine,
+        value_orientation="v",
+        config_module=mock_config,
+    )
 
     firm.init_ipo(stock_market)
 
@@ -291,10 +332,14 @@ def test_ipo_share_count(stock_market, mock_config):
     assert firm.treasury_shares == 1000.0
     assert stock_market.shareholders[firm.id][firm.id] == 1000.0
 
+
 def test_seo_triggers(stock_market, mock_config, golden_firms):
     from simulation.decisions.ai_driven_firm_engine import AIDrivenFirmDecisionEngine
+
     mock_config.PROFIT_HISTORY_TICKS = 10
-    firm_decision_engine = AIDrivenFirmDecisionEngine(ai_engine=MagicMock(), config_module=mock_config)
+    firm_decision_engine = AIDrivenFirmDecisionEngine(
+        ai_engine=MagicMock(), config_module=mock_config
+    )
 
     # Use golden_firms[0] but override state
     firm = golden_firms[0]
@@ -313,17 +358,22 @@ def test_seo_triggers(stock_market, mock_config, golden_firms):
     context.markets = {"stock_market": stock_market}
     context.current_time = 1
 
-    with patch.object(stock_market, 'get_stock_price', return_value=10.0):
-        order = firm_decision_engine.corporate_manager._attempt_secondary_offering(firm, context)
+    with patch.object(stock_market, "get_stock_price", return_value=10.0):
+        order = firm_decision_engine.corporate_manager._attempt_secondary_offering(
+            firm, context
+        )
 
     assert order is not None
     assert order.agent_id == firm.id
     assert order.firm_id == firm.id
     assert order.order_type == "SELL"
-    assert order.quantity == 50.0 # 10% of 500
+    assert order.quantity == 50.0  # 10% of 500
+
 
 def test_household_investment(stock_market, mock_config, golden_households):
-    from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
+    from simulation.decisions.ai_driven_household_engine import (
+        AIDrivenHouseholdDecisionEngine,
+    )
     from simulation.ai.api import Personality
 
     mock_config.PROFIT_HISTORY_TICKS = 10
@@ -332,13 +382,15 @@ def test_household_investment(stock_market, mock_config, golden_households):
         "CONSERVATIVE": (0.5, 0.7),
         "MISER": (0.1, 0.3),
         "IMPULSIVE": (0.4, 0.6),
-        None: (0.3, 0.7)
+        None: (0.3, 0.7),
     }
     mock_config.INITIAL_HOUSEHOLD_ASSETS_MEAN = 1000.0
     mock_config.HOUSEHOLD_FOOD_CONSUMPTION_PER_TICK = 2.0
     mock_config.GOODS = {"basic_food": {"initial_price": 5.0}}
 
-    household_decision_engine = AIDrivenHouseholdDecisionEngine(ai_engine=MagicMock(), config_module=mock_config)
+    household_decision_engine = AIDrivenHouseholdDecisionEngine(
+        ai_engine=MagicMock(), config_module=mock_config
+    )
 
     # Use golden_households[0] but override state
     household = golden_households[0]
@@ -361,34 +413,43 @@ def test_household_investment(stock_market, mock_config, golden_households):
 
     stock_market.reference_prices = {1: 10.0, 2: 20.0, 3: 30.0, 4: 40.0}
 
-    with patch('simulation.decisions.portfolio_manager.PortfolioManager.optimize_portfolio', return_value=(100, 400, 500)) as mock_optimize:
-
+    with patch(
+        "simulation.decisions.portfolio_manager.PortfolioManager.optimize_portfolio",
+        return_value=(100, 400, 500),
+    ) as mock_optimize:
         # We need a market_data structure for the test
         market_data = {
             "loan_market": {"interest_rate": 0.03},
             "avg_dividend_yield": 0.05,
             "inflation": 0.02,
-            "goods_market": {"basic_food_current_sell_price": 5.0}
+            "goods_market": {"basic_food_current_sell_price": 5.0},
         }
 
         # Directly test the order creation logic
-        orders = household_decision_engine._place_buy_orders(household, 500, stock_market, 1)
+        orders = household_decision_engine._place_buy_orders(
+            household, 500, stock_market, 1
+        )
 
         assert len(orders) > 0
         assert isinstance(orders[0], StockOrder)
         assert orders[0].order_type == "BUY"
         assert orders[0].agent_id == household.id
 
+
 def test_price_limit(stock_market):
     firm_id = 1
     stock_market.reference_prices[firm_id] = 100.0
 
     # Test upper limit
-    order = StockOrder(agent_id=1, firm_id=firm_id, order_type="BUY", quantity=1, price=120.0)
+    order = StockOrder(
+        agent_id=1, firm_id=firm_id, order_type="BUY", quantity=1, price=120.0
+    )
     stock_market.place_order(order, 1)
     assert order.price == pytest.approx(115.0)
 
     # Test lower limit
-    order = StockOrder(agent_id=1, firm_id=firm_id, order_type="BUY", quantity=1, price=80.0)
+    order = StockOrder(
+        agent_id=1, firm_id=firm_id, order_type="BUY", quantity=1, price=80.0
+    )
     stock_market.place_order(order, 1)
     assert order.price == pytest.approx(85.0)
diff --git a/tests/test_tax_incidence.py b/tests/test_tax_incidence.py
index e6315bb..f28a6ac 100644
--- a/tests/test_tax_incidence.py
+++ b/tests/test_tax_incidence.py
@@ -14,7 +14,9 @@ from simulation.ai_model import AIEngineRegistry
 from simulation.ai.state_builder import StateBuilder
 from simulation.decisions.action_proposal import ActionProposalEngine
 from simulation.decisions.ai_driven_firm_engine import AIDrivenFirmDecisionEngine
-from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
+from simulation.decisions.ai_driven_household_engine import (
+    AIDrivenHouseholdDecisionEngine,
+)
 from simulation.ai.api import Personality
 from simulation.ai.household_ai import HouseholdAI
 from simulation.ai.firm_ai import FirmAI
@@ -26,6 +28,7 @@ import config as cfg
 logging.basicConfig(level=logging.ERROR)
 logger = logging.getLogger("TestTaxIncidence")
 
+
 class TestTaxIncidence(unittest.TestCase):
     def setUp(self):
         self.repository = SimulationRepository()
@@ -33,7 +36,7 @@ class TestTaxIncidence(unittest.TestCase):
         self.action_proposal_engine = ActionProposalEngine(config_module=cfg)
         self.ai_trainer = AIEngineRegistry(
             action_proposal_engine=self.action_proposal_engine,
-            state_builder=self.state_builder
+            state_builder=self.state_builder,
         )
 
     def tearDown(self):
@@ -74,12 +77,22 @@ class TestTaxIncidence(unittest.TestCase):
         h = self._create_household(1, 1000.0)
         f = self._create_firm(101, 5000.0)
         sim = Simulation([h], [f], self.ai_trainer, self.repository, cfg, [])
-        
+
         # 100ì› ë§¤ì¹­ (ë…¸ë™ ê±°ë˜)
         from simulation.models import Transaction
-        tx = Transaction(buyer_id=101, seller_id=1, item_id="labor", quantity=1.0, price=100.0, market_id="labor", transaction_type="labor", time=1)
+
+        tx = Transaction(
+            buyer_id=101,
+            seller_id=1,
+            item_id="labor",
+            quantity=1.0,
+            price=100.0,
+            market_id="labor",
+            transaction_type="labor",
+            time=1,
+        )
         sim._process_transactions([tx])
-        
+
         # ê°€ê³„: 1000 + (100 - 10) = 1090
         # ê¸°ì—…: 5000 - 100 = 4900
         self.assertEqual(h.assets, 1090.0)
@@ -93,12 +106,22 @@ class TestTaxIncidence(unittest.TestCase):
         h = self._create_household(1, 1000.0)
         f = self._create_firm(101, 5000.0)
         sim = Simulation([h], [f], self.ai_trainer, self.repository, cfg, [])
-        
+
         # 100ì› ë§¤ì¹­ (ë…¸ë™ ê±°ë˜)
         from simulation.models import Transaction
-        tx = Transaction(buyer_id=101, seller_id=1, item_id="labor", quantity=1.0, price=100.0, market_id="labor", transaction_type="labor", time=1)
+
+        tx = Transaction(
+            buyer_id=101,
+            seller_id=1,
+            item_id="labor",
+            quantity=1.0,
+            price=100.0,
+            market_id="labor",
+            transaction_type="labor",
+            time=1,
+        )
         sim._process_transactions([tx])
-        
+
         # ê°€ê³„: 1000 + 100 = 1100
         # ê¸°ì—…: 5000 - (100 + 10) = 4890
         self.assertEqual(h.assets, 1100.0)
@@ -106,5 +129,6 @@ class TestTaxIncidence(unittest.TestCase):
         self.assertEqual(sim.government.assets, 10.0)
         print("âœ“ Firm Payer (Extra Tax): Agent Assets Correct")
 
+
 if __name__ == "__main__":
     unittest.main()
diff --git a/tests/test_wo048_breeding.py b/tests/test_wo048_breeding.py
index 57d51cf..200453b 100644
--- a/tests/test_wo048_breeding.py
+++ b/tests/test_wo048_breeding.py
@@ -1,10 +1,10 @@
-
 import unittest
 from unittest.mock import MagicMock, patch
 import random
 import config
 from simulation.ai.household_ai import HouseholdAI
 
+
 class TestWO048Breeding(unittest.TestCase):
     def setUp(self):
         # Create a mock engine with config module
@@ -13,8 +13,7 @@ class TestWO048Breeding(unittest.TestCase):
 
         # Instantiate HouseholdAI
         self.ai = HouseholdAI(
-            agent_id="test_agent",
-            ai_decision_engine=self.mock_engine
+            agent_id="test_agent", ai_decision_engine=self.mock_engine
         )
 
         # Base agent data (valid age)
@@ -34,17 +33,25 @@ class TestWO048Breeding(unittest.TestCase):
         Set: TECH_CONTRACEPTION_ENABLED = False
         Expectation: Returns True approx 15% of the time (Biological Fertility).
         """
-        with patch.object(config, 'TECH_CONTRACEPTION_ENABLED', False):
+        with patch.object(config, "TECH_CONTRACEPTION_ENABLED", False):
             # We fix random seed or patch random to verify behavior
             # Let's patch random.random
 
             # Case 1: Random < 0.15 -> True
-            with patch('random.random', return_value=0.1):
-                self.assertTrue(self.ai.decide_reproduction(self.agent_data, self.market_data, self.current_time))
+            with patch("random.random", return_value=0.1):
+                self.assertTrue(
+                    self.ai.decide_reproduction(
+                        self.agent_data, self.market_data, self.current_time
+                    )
+                )
 
             # Case 2: Random > 0.15 -> False
-            with patch('random.random', return_value=0.2):
-                self.assertFalse(self.ai.decide_reproduction(self.agent_data, self.market_data, self.current_time))
+            with patch("random.random", return_value=0.2):
+                self.assertFalse(
+                    self.ai.decide_reproduction(
+                        self.agent_data, self.market_data, self.current_time
+                    )
+                )
 
     def test_scenario_b_high_income(self):
         """
@@ -56,9 +63,14 @@ class TestWO048Breeding(unittest.TestCase):
         # Monthly 10,000 -> Hourly = 10000 / (8 * 20) = 62.5
         self.agent_data["current_wage"] = 62.5
 
-        with patch.object(config, 'TECH_CONTRACEPTION_ENABLED', True):
-            decision = self.ai.decide_reproduction(self.agent_data, self.market_data, self.current_time)
-            self.assertFalse(decision, "High income agent should reject reproduction due to opportunity cost.")
+        with patch.object(config, "TECH_CONTRACEPTION_ENABLED", True):
+            decision = self.ai.decide_reproduction(
+                self.agent_data, self.market_data, self.current_time
+            )
+            self.assertFalse(
+                decision,
+                "High income agent should reject reproduction due to opportunity cost.",
+            )
 
     def test_scenario_c_low_income(self):
         """
@@ -70,9 +82,14 @@ class TestWO048Breeding(unittest.TestCase):
         # Monthly 1,000 -> Hourly = 1000 / (8 * 20) = 6.25
         self.agent_data["current_wage"] = 6.25
 
-        with patch.object(config, 'TECH_CONTRACEPTION_ENABLED', True):
-            decision = self.ai.decide_reproduction(self.agent_data, self.market_data, self.current_time)
-            self.assertFalse(decision, "Low income agent should reject reproduction due to direct cost burden.")
+        with patch.object(config, "TECH_CONTRACEPTION_ENABLED", True):
+            decision = self.ai.decide_reproduction(
+                self.agent_data, self.market_data, self.current_time
+            )
+            self.assertFalse(
+                decision,
+                "Low income agent should reject reproduction due to direct cost burden.",
+            )
 
     def test_scenario_d_middle_income(self):
         """
@@ -84,25 +101,30 @@ class TestWO048Breeding(unittest.TestCase):
         # Testing Monthly 4,000 -> Hourly = 4000 / (8 * 20) = 25.0
         self.agent_data["current_wage"] = 25.0
 
-        with patch.object(config, 'TECH_CONTRACEPTION_ENABLED', True):
-            decision = self.ai.decide_reproduction(self.agent_data, self.market_data, self.current_time)
+        with patch.object(config, "TECH_CONTRACEPTION_ENABLED", True):
+            decision = self.ai.decide_reproduction(
+                self.agent_data, self.market_data, self.current_time
+            )
 
             # Debugging info if failed
             if not decision:
                 # Calculate manually to see why
                 monthly = 4000.0
-                c_direct = 500.0 * 12 * 20 # 120,000
-                c_opp = monthly * 0.5 * 12 * 20 # 4000 * 0.5 * 240 = 480,000
-                total_cost = 120000 + 480000 # 600,000
+                c_direct = 500.0 * 12 * 20  # 120,000
+                c_opp = monthly * 0.5 * 12 * 20  # 4000 * 0.5 * 240 = 480,000
+                total_cost = 120000 + 480000  # 600,000
 
-                u_emo = 200000.0 / 1 # 200,000
-                u_supp = monthly * 0.1 * 12 * 20 # 4000 * 24 = 96,000
-                total_ben = 200000 + 96000 # 296,000
+                u_emo = 200000.0 / 1  # 200,000
+                u_supp = monthly * 0.1 * 12 * 20  # 4000 * 24 = 96,000
+                total_ben = 200000 + 96000  # 296,000
 
                 # NPV = 296,000 - 600,000 = -304,000
-                print(f"DEBUG Scenario D: Cost={total_cost}, Benefit={total_ben}, NPV={total_ben-total_cost}")
+                print(
+                    f"DEBUG Scenario D: Cost={total_cost}, Benefit={total_ben}, NPV={total_ben - total_cost}"
+                )
 
             self.assertTrue(decision, "Middle income agent should accept reproduction.")
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     unittest.main()
diff --git a/tests/test_wo058_production.py b/tests/test_wo058_production.py
index d554d40..7e48d25 100644
--- a/tests/test_wo058_production.py
+++ b/tests/test_wo058_production.py
@@ -4,11 +4,14 @@ from simulation.engine import Simulation
 from simulation.systems.bootstrapper import Bootstrapper
 from simulation.core_agents import Household, Talent
 from simulation.firms import Firm
-from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
+from simulation.decisions.ai_driven_household_engine import (
+    AIDrivenHouseholdDecisionEngine,
+)
 from simulation.decisions.ai_driven_firm_engine import AIDrivenFirmDecisionEngine
 from simulation.ai.api import Personality
 from simulation.metrics.economic_tracker import EconomicIndicatorTracker
 
+
 @pytest.fixture
 def mock_config():
     """Provides a mock config object with necessary definitions."""
@@ -40,10 +43,7 @@ def mock_config():
     config.EDUCATION_LEVEL_DISTRIBUTION = [1.0]
     config.INITIAL_WAGE = 10.0
     config.EDUCATION_COST_MULTIPLIERS = {}
-    config.CONFORMITY_RANGES = {
-        "MISER": (0.1, 0.3),
-        None: (0.3, 0.7)
-    }
+    config.CONFORMITY_RANGES = {"MISER": (0.1, 0.3), None: (0.3, 0.7)}
     config.INITIAL_HOUSEHOLD_ASSETS_MEAN = 5000.0
     config.QUALITY_PREF_MISER_MAX = 0.3
     config.PROFIT_HISTORY_TICKS = 10
@@ -69,6 +69,7 @@ def mock_config():
     config.LABOR_ELASTICITY_MIN = 0.1
     return config
 
+
 @pytest.fixture
 def mock_repo():
     """Provides a mock repository object."""
@@ -76,22 +77,60 @@ def mock_repo():
     repo.save_simulation_run.return_value = 1
     return repo
 
+
 @pytest.fixture
 def mock_ai_trainer():
     """Provides a mock AI trainer."""
     return Mock()
 
+
 def test_bootstrapper_injection(mock_config, mock_repo, mock_ai_trainer):
     """Tests that the bootstrapper correctly injects capital and inputs."""
     talent = Talent(base_learning_rate=0.1, max_potential={})
-    households = [Household(id=i, talent=talent, goods_data=[], initial_assets=1000, initial_needs={'survival': 0}, decision_engine=Mock(spec=AIDrivenHouseholdDecisionEngine), value_orientation="test", personality=Personality.MISER, config_module=mock_config) for i in range(1)]
+    households = [
+        Household(
+            id=i,
+            talent=talent,
+            goods_data=[],
+            initial_assets=1000,
+            initial_needs={"survival": 0},
+            decision_engine=Mock(spec=AIDrivenHouseholdDecisionEngine),
+            value_orientation="test",
+            personality=Personality.MISER,
+            config_module=mock_config,
+        )
+        for i in range(1)
+    ]
     firms = [
-        Firm(id=100, initial_capital=500, specialization="tools", decision_engine=Mock(spec=AIDrivenFirmDecisionEngine), config_module=mock_config, value_orientation="Profit", initial_liquidity_need=100, productivity_factor=1),
-        Firm(id=101, initial_capital=2500, specialization="food", decision_engine=Mock(spec=AIDrivenFirmDecisionEngine), config_module=mock_config, value_orientation="Profit", initial_liquidity_need=100, productivity_factor=1)
+        Firm(
+            id=100,
+            initial_capital=500,
+            specialization="tools",
+            decision_engine=Mock(spec=AIDrivenFirmDecisionEngine),
+            config_module=mock_config,
+            value_orientation="Profit",
+            initial_liquidity_need=100,
+            productivity_factor=1,
+        ),
+        Firm(
+            id=101,
+            initial_capital=2500,
+            specialization="food",
+            decision_engine=Mock(spec=AIDrivenFirmDecisionEngine),
+            config_module=mock_config,
+            value_orientation="Profit",
+            initial_liquidity_need=100,
+            productivity_factor=1,
+        ),
     ]
 
     # The bootstrapper is called during the Simulation initialization
-    sim = Simulation(config_manager=Mock(), config_module=mock_config, logger=Mock(), repository=mock_repo)
+    sim = Simulation(
+        config_manager=Mock(),
+        config_module=mock_config,
+        logger=Mock(),
+        repository=mock_repo,
+    )
     sim.world_state.households = households
     sim.world_state.firms = firms
     sim.world_state.ai_trainer = mock_ai_trainer
@@ -109,18 +148,48 @@ def test_bootstrapper_injection(mock_config, mock_repo, mock_ai_trainer):
         if "inputs" in mock_config.GOODS[firm.specialization]:
             inputs = mock_config.GOODS[firm.specialization]["inputs"]
             for mat in inputs:
-                assert firm.input_inventory.get(mat, 0) > 0, f"Firm {firm.id} missing input {mat}"
+                assert firm.input_inventory.get(mat, 0) > 0, (
+                    f"Firm {firm.id} missing input {mat}"
+                )
+
 
 def test_production_kickstart(mock_config, mock_repo, mock_ai_trainer):
     """Tests that the economy starts and production is non-zero after bootstrapping."""
     talent = Talent(base_learning_rate=0.1, max_potential={})
-    households = [Household(id=i, talent=talent, goods_data=[], initial_assets=1000, initial_needs={'survival': 0}, decision_engine=Mock(spec=AIDrivenHouseholdDecisionEngine), value_orientation="test", personality=Personality.MISER, config_module=mock_config) for i in range(1)]
+    households = [
+        Household(
+            id=i,
+            talent=talent,
+            goods_data=[],
+            initial_assets=1000,
+            initial_needs={"survival": 0},
+            decision_engine=Mock(spec=AIDrivenHouseholdDecisionEngine),
+            value_orientation="test",
+            personality=Personality.MISER,
+            config_module=mock_config,
+        )
+        for i in range(1)
+    ]
     firms = [
-        Firm(id=100, initial_capital=3000, specialization="tools", decision_engine=Mock(spec=AIDrivenFirmDecisionEngine), config_module=mock_config, value_orientation="Profit", initial_liquidity_need=100, productivity_factor=1),
+        Firm(
+            id=100,
+            initial_capital=3000,
+            specialization="tools",
+            decision_engine=Mock(spec=AIDrivenFirmDecisionEngine),
+            config_module=mock_config,
+            value_orientation="Profit",
+            initial_liquidity_need=100,
+            productivity_factor=1,
+        ),
     ]
 
     # This is a simplified simulation setup; a real test would need more comprehensive mocks
-    sim = Simulation(config_manager=Mock(), config_module=mock_config, logger=Mock(), repository=mock_repo)
+    sim = Simulation(
+        config_manager=Mock(),
+        config_module=mock_config,
+        logger=Mock(),
+        repository=mock_repo,
+    )
     sim.world_state.households = households
     sim.world_state.firms = firms
     sim.world_state.ai_trainer = mock_ai_trainer
@@ -136,13 +205,13 @@ def test_production_kickstart(mock_config, mock_repo, mock_ai_trainer):
     mock_employee = households[0]
     firm.employees = [mock_employee]
     firm.hr.employees = [mock_employee]
-    firm.input_inventory['wood'] = 100.0
+    firm.input_inventory["wood"] = 100.0
     firm.productivity_factor = 1.0
 
-    firm.produce(0) # Tick 0
+    firm.produce(0)  # Tick 0
 
     sim.tracker.track(1, sim.households, sim.firms, sim.markets, 0)
 
     # Assert Total Production > 0
     metrics = sim.tracker.get_latest_indicators()
-    assert metrics['total_production'] > 0, "Economy is deadlocked!"
+    assert metrics["total_production"] > 0, "Economy is deadlocked!"
diff --git a/tests/test_wo065_minimal.py b/tests/test_wo065_minimal.py
index 8510c77..86d9db9 100644
--- a/tests/test_wo065_minimal.py
+++ b/tests/test_wo065_minimal.py
@@ -1,7 +1,8 @@
 import math
 import sys
 import os
-sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
+
+sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
 from simulation.agents.government import Government
 import config
 from unittest.mock import Mock
@@ -11,4 +12,4 @@ gov.finance_system = Mock()
 gov.sensory_data = Mock()
 gov.total_money_destroyed += 1000.0
 assert math.isclose(gov.total_money_destroyed, 1000.0)
-print('PASS')
+print("PASS")
diff --git a/tests/utils/test_golden_loader.py b/tests/utils/test_golden_loader.py
index 09f30a5..209c908 100644
--- a/tests/utils/test_golden_loader.py
+++ b/tests/utils/test_golden_loader.py
@@ -4,21 +4,19 @@ import json
 from unittest.mock import MagicMock
 from simulation.utils.golden_loader import GoldenLoader
 
+
 class TestGoldenLoader(unittest.TestCase):
     def setUp(self):
         self.test_file = "test_fixture.json"
         self.data = {
             "name": "Test Agent",
-            "attributes": {
-                "age": 30,
-                "skills": ["coding", "testing"]
-            },
+            "attributes": {"age": 30, "skills": ["coding", "testing"]},
             "history": [
                 {"year": 2020, "event": "hired"},
-                {"year": 2021, "event": "promoted"}
-            ]
+                {"year": 2021, "event": "promoted"},
+            ],
         }
-        with open(self.test_file, 'w') as f:
+        with open(self.test_file, "w") as f:
             json.dump(self.data, f)
 
     def tearDown(self):
diff --git a/tests/verification/verify_inheritance.py b/tests/verification/verify_inheritance.py
index a6f5da6..e2e306c 100644
--- a/tests/verification/verify_inheritance.py
+++ b/tests/verification/verify_inheritance.py
@@ -6,6 +6,7 @@ from simulation.systems.inheritance_manager import InheritanceManager
 from simulation.models import RealEstateUnit
 from simulation.portfolio import Portfolio
 
+
 @pytest.mark.usefixtures("golden_households")
 class TestInheritance:
     @pytest.fixture(autouse=True)
@@ -27,7 +28,9 @@ class TestInheritance:
         # Pre-test validation
         # Assert that selected households have sufficient and diverse assets
         assert self.deceased.assets > 0, "Deceased must have assets"
-        assert hasattr(self.deceased, 'shares_owned'), "Deceased must have shares_owned attribute"
+        assert hasattr(self.deceased, "shares_owned"), (
+            "Deceased must have shares_owned attribute"
+        )
 
         # Force real Portfolio objects for testing logic.
         # MagicMocks have attributes by default, so hasattr returns True, but they are Mocks.
@@ -35,7 +38,7 @@ class TestInheritance:
         self.deceased.portfolio = Portfolio(self.deceased.id)
         self.heir.portfolio = Portfolio(self.heir.id)
 
-        assert hasattr(self.deceased, 'portfolio'), "Deceased must have portfolio"
+        assert hasattr(self.deceased, "portfolio"), "Deceased must have portfolio"
 
         # Setup Deceased State
         self.deceased.id = 1
@@ -43,7 +46,7 @@ class TestInheritance:
         self.deceased._assets = 50000.0
         self.deceased.shares_owned = {}
         self.deceased.owned_properties = []
-        self.deceased.children_ids = [self.heir.id] # Use dynamic ID from heir
+        self.deceased.children_ids = [self.heir.id]  # Use dynamic ID from heir
 
         # Setup Heir State
         self.heir._assets = 0.0
@@ -71,8 +74,8 @@ class TestInheritance:
 
     def test_liquidation_stocks(self):
         """Cash poor, Stock rich. Stocks sold to pay tax."""
-        self.deceased._assets = 1000.0 # Low cash
-        self.deceased.portfolio.add(99, 100, 100.0) # 100 shares of Firm 99 @ 100.0
+        self.deceased._assets = 1000.0  # Low cash
+        self.deceased.portfolio.add(99, 100, 100.0)  # 100 shares of Firm 99 @ 100.0
         # Value = 10000.0
         # Total Wealth = 11000.0
         # Taxable = 11000 - 10000 = 1000
@@ -95,11 +98,11 @@ class TestInheritance:
         # Remaining 6600.
 
         assert self.heir.assets == pytest.approx(6600.0)
-        assert len(self.heir.portfolio.holdings) == 0 # No stocks inherited (Sold)
+        assert len(self.heir.portfolio.holdings) == 0  # No stocks inherited (Sold)
 
     def test_portfolio_merge(self):
         """Heir inherits stocks with Cost Basis calculation."""
-        self.config.INHERITANCE_TAX_RATE = 0.0 # No tax for simplicity
+        self.config.INHERITANCE_TAX_RATE = 0.0  # No tax for simplicity
 
         # Deceased: 100 shares @ 100.0
         self.deceased.portfolio.add(99, 100, 100.0)
diff --git a/tests/verification/verify_mitosis.py b/tests/verification/verify_mitosis.py
index 8436608..bc01ce6 100644
--- a/tests/verification/verify_mitosis.py
+++ b/tests/verification/verify_mitosis.py
@@ -1,7 +1,9 @@
 import pytest
 import random
 from unittest.mock import MagicMock
-from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
+from simulation.decisions.ai_driven_household_engine import (
+    AIDrivenHouseholdDecisionEngine,
+)
 from simulation.core_agents import Household
 from simulation.models import Talent
 from simulation.ai.api import Personality
@@ -9,34 +11,41 @@ from simulation.ai.household_ai import HouseholdAI
 from simulation.ai.ai_training_manager import AITrainingManager
 from simulation.ai.q_table_manager import QTableManager
 
+
 # Helper to force set primitive config
 def ensure_config(golden_config, key, value):
-    if not hasattr(golden_config, key) or isinstance(getattr(golden_config, key), MagicMock):
+    if not hasattr(golden_config, key) or isinstance(
+        getattr(golden_config, key), MagicMock
+    ):
         setattr(golden_config, key, value)
 
+
 def setup_golden_config(golden_config):
-    ensure_config(golden_config, 'INFLATION_MEMORY_WINDOW', 10)
-    ensure_config(golden_config, 'TICKS_PER_YEAR', 100)
-    ensure_config(golden_config, 'VALUE_ORIENTATION_MAPPING', {})
-    ensure_config(golden_config, 'ADAPTATION_RATE_IMPULSIVE', 0.5)
-    ensure_config(golden_config, 'ADAPTATION_RATE_CONSERVATIVE', 0.1)
-    ensure_config(golden_config, 'ADAPTATION_RATE_NORMAL', 0.2)
-    ensure_config(golden_config, 'PERCEIVED_PRICE_UPDATE_FACTOR', 0.1)
-    ensure_config(golden_config, 'INITIAL_HOUSEHOLD_ASSETS_MEAN', 1000.0)
-    ensure_config(golden_config, 'CONFORMITY_RANGES', {})
-    ensure_config(golden_config, 'EDUCATION_WEALTH_THRESHOLDS', {0: 0, 1: 1000, 2: 5000})
-    ensure_config(golden_config, 'EDUCATION_COST_MULTIPLIERS', {0: 1.0, 1: 1.2, 2: 1.5})
-    ensure_config(golden_config, 'INITIAL_WAGE', 10.0)
-    ensure_config(golden_config, 'QUALITY_PREF_SNOB_MIN', 0.7)
-    ensure_config(golden_config, 'QUALITY_PREF_MISER_MAX', 0.3)
-    ensure_config(golden_config, 'HOUSEHOLD_MIN_WAGE_DEMAND', 6.0)
-    ensure_config(golden_config, 'MITOSIS_Q_TABLE_MUTATION_RATE', 0.05)
-    ensure_config(golden_config, 'IMITATION_MUTATION_RATE', 0.1)
-    ensure_config(golden_config, 'IMITATION_MUTATION_MAGNITUDE', 0.05)
-    ensure_config(golden_config, 'MITOSIS_MUTATION_PROBABILITY', 0.2)
-    ensure_config(golden_config, 'EDUCATION_SENSITIVITY', 0.1)
-    ensure_config(golden_config, 'BASE_LEARNING_RATE', 0.1)
-    ensure_config(golden_config, 'MAX_LEARNING_RATE', 0.5)
+    ensure_config(golden_config, "INFLATION_MEMORY_WINDOW", 10)
+    ensure_config(golden_config, "TICKS_PER_YEAR", 100)
+    ensure_config(golden_config, "VALUE_ORIENTATION_MAPPING", {})
+    ensure_config(golden_config, "ADAPTATION_RATE_IMPULSIVE", 0.5)
+    ensure_config(golden_config, "ADAPTATION_RATE_CONSERVATIVE", 0.1)
+    ensure_config(golden_config, "ADAPTATION_RATE_NORMAL", 0.2)
+    ensure_config(golden_config, "PERCEIVED_PRICE_UPDATE_FACTOR", 0.1)
+    ensure_config(golden_config, "INITIAL_HOUSEHOLD_ASSETS_MEAN", 1000.0)
+    ensure_config(golden_config, "CONFORMITY_RANGES", {})
+    ensure_config(
+        golden_config, "EDUCATION_WEALTH_THRESHOLDS", {0: 0, 1: 1000, 2: 5000}
+    )
+    ensure_config(golden_config, "EDUCATION_COST_MULTIPLIERS", {0: 1.0, 1: 1.2, 2: 1.5})
+    ensure_config(golden_config, "INITIAL_WAGE", 10.0)
+    ensure_config(golden_config, "QUALITY_PREF_SNOB_MIN", 0.7)
+    ensure_config(golden_config, "QUALITY_PREF_MISER_MAX", 0.3)
+    ensure_config(golden_config, "HOUSEHOLD_MIN_WAGE_DEMAND", 6.0)
+    ensure_config(golden_config, "MITOSIS_Q_TABLE_MUTATION_RATE", 0.05)
+    ensure_config(golden_config, "IMITATION_MUTATION_RATE", 0.1)
+    ensure_config(golden_config, "IMITATION_MUTATION_MAGNITUDE", 0.05)
+    ensure_config(golden_config, "MITOSIS_MUTATION_PROBABILITY", 0.2)
+    ensure_config(golden_config, "EDUCATION_SENSITIVITY", 0.1)
+    ensure_config(golden_config, "BASE_LEARNING_RATE", 0.1)
+    ensure_config(golden_config, "MAX_LEARNING_RATE", 0.5)
+
 
 def create_real_household_from_golden(mock_h, golden_config):
     # Use Talent from models, default if necessary
@@ -46,18 +55,26 @@ def create_real_household_from_golden(mock_h, golden_config):
     goods_data = [{"id": "food"}, {"id": "housing"}]
 
     # Default personality/orientation if not on mock
-    personality = getattr(mock_h, 'personality', Personality.MISER)
+    personality = getattr(mock_h, "personality", Personality.MISER)
     if isinstance(personality, MagicMock):
-         personality = Personality.MISER
+        personality = Personality.MISER
 
-    value_orientation = getattr(mock_h, 'value_orientation', "wealth")
+    value_orientation = getattr(mock_h, "value_orientation", "wealth")
     if isinstance(value_orientation, MagicMock):
         value_orientation = "wealth"
 
     # Handle numeric/primitive fields safely from MagicMock
-    initial_assets = mock_h.assets if not isinstance(mock_h.assets, MagicMock) else 1000.0
-    initial_needs = mock_h.needs if not isinstance(mock_h.needs, MagicMock) else {"survival": 0.5}
-    initial_age = mock_h.age if hasattr(mock_h, 'age') and not isinstance(mock_h.age, MagicMock) else 25
+    initial_assets = (
+        mock_h.assets if not isinstance(mock_h.assets, MagicMock) else 1000.0
+    )
+    initial_needs = (
+        mock_h.needs if not isinstance(mock_h.needs, MagicMock) else {"survival": 0.5}
+    )
+    initial_age = (
+        mock_h.age
+        if hasattr(mock_h, "age") and not isinstance(mock_h.age, MagicMock)
+        else 25
+    )
 
     # Pre-configure Mock Engine
     mock_engine = MagicMock(spec=AIDrivenHouseholdDecisionEngine)
@@ -82,7 +99,9 @@ def create_real_household_from_golden(mock_h, golden_config):
         talent=talent,
         goods_data=goods_data,
         initial_assets=float(initial_assets),
-        initial_needs=dict(initial_needs) if isinstance(initial_needs, dict) else {"survival": 0.5},
+        initial_needs=dict(initial_needs)
+        if isinstance(initial_needs, dict)
+        else {"survival": 0.5},
         decision_engine=mock_engine,
         value_orientation=value_orientation,
         personality=personality,
@@ -91,11 +110,12 @@ def create_real_household_from_golden(mock_h, golden_config):
         gender="M",
     )
 
-    if hasattr(mock_h, 'inventory') and not isinstance(mock_h.inventory, MagicMock):
+    if hasattr(mock_h, "inventory") and not isinstance(mock_h.inventory, MagicMock):
         real_household.inventory = dict(mock_h.inventory)
 
     return real_household
 
+
 def test_mitosis_zero_sum_logic(golden_config, golden_households):
     """
     CRITICAL: Verify Zero-Sum Asset Logic.
@@ -117,7 +137,9 @@ def test_mitosis_zero_sum_logic(golden_config, golden_households):
     parent._assets -= split_amount
 
     # 3. Create child with deducted amount
-    child = parent.clone(new_id=999, initial_assets_from_parent=split_amount, current_tick=100)
+    child = parent.clone(
+        new_id=999, initial_assets_from_parent=split_amount, current_tick=100
+    )
 
     # Assertions
     assert child.assets == split_amount
@@ -125,6 +147,7 @@ def test_mitosis_zero_sum_logic(golden_config, golden_households):
     assert parent.assets + child.assets == initial_total_assets
     assert child.id == 999
 
+
 def test_mitosis_stock_inheritance(golden_config, golden_households):
     """
     CRITICAL: Verify Stock Inheritance Logic.
@@ -168,6 +191,7 @@ def test_mitosis_stock_inheritance(golden_config, golden_households):
     # Verify Total Shares Conserved
     assert parent.shares_owned[firm_1_id] + child.shares_owned[firm_1_id] == 10
 
+
 def test_mitosis_brain_inheritance(golden_config, golden_households):
     """
     CRITICAL: Verify Q-Table and Brain Inheritance.
@@ -180,9 +204,7 @@ def test_mitosis_brain_inheritance(golden_config, golden_households):
     # Setup Parent AI with specific knowledge
     mock_shared_ai = MagicMock()
     parent_ai = HouseholdAI(
-        agent_id=str(parent.id),
-        ai_decision_engine=mock_shared_ai,
-        gamma=0.9
+        agent_id=str(parent.id), ai_decision_engine=mock_shared_ai, gamma=0.9
     )
     # Populate Q-Table
     parent_ai.q_consumption["food"] = QTableManager()
@@ -204,7 +226,9 @@ def test_mitosis_brain_inheritance(golden_config, golden_households):
     # Clone logic calls _create_new_decision_engine which creates a fresh AI.
     # We rely on AITrainingManager to transfer knowledge.
 
-    training_manager = AITrainingManager(agents=[parent, child], config_module=golden_config)
+    training_manager = AITrainingManager(
+        agents=[parent, child], config_module=golden_config
+    )
     training_manager.inherit_brain(parent, child)
 
     child_ai = child.decision_engine.ai_engine
@@ -224,7 +248,9 @@ def test_mitosis_brain_inheritance(golden_config, golden_households):
     for k in test_values:
         p_val = test_values[k]
         c_val = child_values[k]
-        assert abs(p_val - c_val) <= 0.1 # Allow small margin for mutation + float error
+        assert (
+            abs(p_val - c_val) <= 0.1
+        )  # Allow small margin for mutation + float error
 
     # Verify Personality (Inheritance or Mutation)
     assert isinstance(child.personality, Personality)
diff --git a/tests/verification/verify_phase29_depression.py b/tests/verification/verify_phase29_depression.py
index f115706..dd710d7 100644
--- a/tests/verification/verify_phase29_depression.py
+++ b/tests/verification/verify_phase29_depression.py
@@ -17,6 +17,7 @@ import config
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger("Phase29Verifier")
 
+
 def verify_phase29():
     print(">>> Setting up Phase 29 Depression Verification...")
 
@@ -24,9 +25,9 @@ def verify_phase29():
     overrides = {
         "SIMULATION_TICKS": 25,
         "INITIAL_FIRM_CAPITAL_MEAN": 50000.0,
-        "FIRM_MAINTENANCE_FEE": 0.0, # Disable maintenance to isolate interest expense
+        "FIRM_MAINTENANCE_FEE": 0.0,  # Disable maintenance to isolate interest expense
         "TICKS_PER_YEAR": 100.0,
-        "CORPORATE_TAX_RATE": 0.0, # Disable tax to simplify expense check
+        "CORPORATE_TAX_RATE": 0.0,  # Disable tax to simplify expense check
     }
 
     sim = create_simulation(overrides=overrides)
@@ -62,8 +63,10 @@ def verify_phase29():
     # create_simulation hires people. We need to fire them.)
     test_firm.hr.employees = []
     test_firm.hr.employee_wages = {}
-    test_firm.inventory = {} # Clear inventory to avoid holding costs
-    test_firm.productivity_factor = 0.0 # Disable production to minimize inventory noise
+    test_firm.inventory = {}  # Clear inventory to avoid holding costs
+    test_firm.productivity_factor = (
+        0.0  # Disable production to minimize inventory noise
+    )
 
     # 5. Run for 20 ticks
     print(">>> Running Simulation for 20 ticks...")
@@ -83,9 +86,9 @@ def verify_phase29():
 
         # Check Interest Rate Change
         if sim.bank.base_rate > max_rate:
-             max_rate = sim.bank.base_rate
-             interest_rate_increased = True
-             print(f"Tick {current_tick}: Interest Rate Increased to {max_rate}")
+            max_rate = sim.bank.base_rate
+            interest_rate_increased = True
+            print(f"Tick {current_tick}: Interest Rate Increased to {max_rate}")
 
         # Verify Interest Expense on Test Firm
         # Interest = Principal * Rate / Ticks_Per_Year
@@ -93,31 +96,40 @@ def verify_phase29():
         # Rate changes from 0.05 to 0.15
 
         # After shock (Tick 5+), Rate should be ~0.15
-        if current_tick > scenario_active_tick + 2: # Give it a moment to stabilize
-            expected_rate = initial_interest_rate * 3.0 # 0.15
-            expected_interest = loan_amount * expected_rate / 100.0 # 20000 * 0.15 / 100 = 30.0
+        if current_tick > scenario_active_tick + 2:  # Give it a moment to stabilize
+            expected_rate = initial_interest_rate * 3.0  # 0.15
+            expected_interest = (
+                loan_amount * expected_rate / 100.0
+            )  # 20000 * 0.15 / 100 = 30.0
 
             actual_expenses = test_firm.finance.expenses_this_tick
 
             # Check if Interest is accounted for (Expenses >= Interest)
             # We allow a small margin for float error
             if actual_expenses >= expected_interest - 0.1:
-                 if not interest_expense_verified:
-                     print(f"âœ… Verified Interest Expense Accounting: Actual {actual_expenses:.2f} >= Expected Interest {expected_interest:.2f}")
-                     interest_expense_verified = True
+                if not interest_expense_verified:
+                    print(
+                        f"âœ… Verified Interest Expense Accounting: Actual {actual_expenses:.2f} >= Expected Interest {expected_interest:.2f}"
+                    )
+                    interest_expense_verified = True
             else:
                 if not interest_expense_verified:
-                    print(f"Tick {current_tick}: Expense Missing? Actual: {actual_expenses}, Expected Interest: {expected_interest}")
-
+                    print(
+                        f"Tick {current_tick}: Expense Missing? Actual: {actual_expenses}, Expected Interest: {expected_interest}"
+                    )
 
     # 6. Verification Report
     print("\n>>> Final Verification Report")
 
     # 1. Verify Interest Rate
     if interest_rate_increased and max_rate >= initial_interest_rate * 2.9:
-        print(f"âœ… Interest Rate Multiplier Applied: {max_rate} (Initial: {initial_interest_rate})")
+        print(
+            f"âœ… Interest Rate Multiplier Applied: {max_rate} (Initial: {initial_interest_rate})"
+        )
     else:
-        print(f"âŒ Interest Rate Check Failed: Max {max_rate}, Initial {initial_interest_rate}")
+        print(
+            f"âŒ Interest Rate Check Failed: Max {max_rate}, Initial {initial_interest_rate}"
+        )
 
     # 2. Verify Interest Expense Accounting
     if interest_expense_verified:
@@ -149,26 +161,33 @@ def verify_phase29():
 
     if distressed_firms > 0:
         if suspended_dividends == distressed_firms:
-             print("âœ… All distressed firms suspended dividends.")
+            print("âœ… All distressed firms suspended dividends.")
         else:
-             print("âŒ Not all distressed firms suspended dividends.")
+            print("âŒ Not all distressed firms suspended dividends.")
     else:
-        print("âš ï¸ No firms became distressed naturally. Forcing distress to test logic...")
+        print(
+            "âš ï¸ No firms became distressed naturally. Forcing distress to test logic..."
+        )
         # Force a firm to be distressed
         firm = sim.firms[1]
         firm.finance.consecutive_loss_turns = 10
-        firm.dividend_rate = 0.1 # Reset
+        firm.dividend_rate = 0.1  # Reset
 
         # Run one tick to let Manager react
         sim.run_tick()
 
         if firm.dividend_rate == 0.0:
-            print("âœ… CorporateManager correctly suspended dividends for artificially distressed firm.")
+            print(
+                "âœ… CorporateManager correctly suspended dividends for artificially distressed firm."
+            )
         else:
-            print(f"âŒ CorporateManager FAILED to suspend dividends. Rate: {firm.dividend_rate}")
+            print(
+                f"âŒ CorporateManager FAILED to suspend dividends. Rate: {firm.dividend_rate}"
+            )
 
     sim.finalize_simulation()
     print(">>> Verification Complete.")
 
+
 if __name__ == "__main__":
     verify_phase29()
diff --git a/tests/verify_ai_v2_architecture.py b/tests/verify_ai_v2_architecture.py
index c5078f4..0d7e032 100644
--- a/tests/verify_ai_v2_architecture.py
+++ b/tests/verify_ai_v2_architecture.py
@@ -1,4 +1,3 @@
-
 import logging
 import sys
 import os
@@ -15,58 +14,82 @@ import config
 from simulation.ai.firm_ai import FirmAI
 from simulation.ai.household_ai import HouseholdAI
 from simulation.decisions.ai_driven_firm_engine import AIDrivenFirmDecisionEngine
-from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
+from simulation.decisions.ai_driven_household_engine import (
+    AIDrivenHouseholdDecisionEngine,
+)
+
 
 # Mock Repository
 class MockRepository(SimulationRepository):
     def __init__(self):
         self.decisions = []
-    def save_simulation_run(self, config_hash, description): return 1
-    def update_simulation_run_end_time(self, run_id): pass
-    def save_agent_states_batch(self, data): pass
-    def save_transactions_batch(self, data): pass
-    def save_economic_indicators_batch(self, data): pass
+
+    def save_simulation_run(self, config_hash, description):
+        return 1
+
+    def update_simulation_run_end_time(self, run_id):
+        pass
+
+    def save_agent_states_batch(self, data):
+        pass
+
+    def save_transactions_batch(self, data):
+        pass
+
+    def save_economic_indicators_batch(self, data):
+        pass
+
     def save_ai_decision(self, decision_data):
         self.decisions.append(decision_data)
-        print(f"Recorded Decision: {decision_data.agent_id} | Type: {decision_data.decision_type} | Reward: {decision_data.actual_reward}")
-    def close(self): pass
+        print(
+            f"Recorded Decision: {decision_data.agent_id} | Type: {decision_data.decision_type} | Reward: {decision_data.actual_reward}"
+        )
+
+    def close(self):
+        pass
+
 
 # Mock AIEngineRegistry
 class MockAIRegistry:
-    def __init__(self): pass
-    def end_episode(self, all_agents): pass
+    def __init__(self):
+        pass
+
+    def end_episode(self, all_agents):
+        pass
+
 
 def run_verification():
     logging.basicConfig(level=logging.INFO)
-    
+
     # 1. Setup
     repo = MockRepository()
     ai_registry = MockAIRegistry()
-    
+
     # 1. Setup Firm
     firm_ai = FirmAI("firm_1", None)
     firm_engine = AIDrivenFirmDecisionEngine(firm_ai, config)
     firm = Firm(
-        id=1, 
-        initial_capital=1000.0, 
+        id=1,
+        initial_capital=1000.0,
         initial_liquidity_need=10.0,
-        specialization="basic_food", 
+        specialization="basic_food",
         productivity_factor=1.0,
-        decision_engine=firm_engine, 
+        decision_engine=firm_engine,
         value_orientation="wealth",
-        config_module=config
+        config_module=config,
     )
     firm_ai.set_ai_decision_engine(firm.decision_engine)
-    firm.inventory["basic_food"] = 10 
+    firm.inventory["basic_food"] = 10
     firm.production_target = 20
-    
+
     # 2. Setup Household
     from simulation.core_agents import Talent
     from simulation.ai.api import Personality
+
     talent = Talent(base_learning_rate=0.1, max_potential={})
     household_ai = HouseholdAI("household_2", None)
     household_engine = AIDrivenHouseholdDecisionEngine(household_ai, config)
-    
+
     household = Household(
         id=2,
         talent=talent,
@@ -76,60 +99,65 @@ def run_verification():
             "survival": 50.0,
             "asset": 50.0,
             "social": 50.0,
-            "improvement": 50.0
+            "improvement": 50.0,
         },
         decision_engine=household_engine,
         value_orientation="wealth",
         personality=Personality.MISER,
-        config_module=config
+        config_module=config,
     )
     household_ai.set_ai_decision_engine(household.decision_engine)
-    
+
     simulation = Simulation(
         households=[household],
         firms=[firm],
         ai_trainer=ai_registry,
         repository=repo,
         config_module=config,
-        goods_data=[], # Dummy
-        logger=logging.getLogger("test")
+        goods_data=[],  # Dummy
+        logger=logging.getLogger("test"),
     )
-    
+
     # Ensure markets are aligned
     simulation.markets["labor"] = simulation.markets["labor_market"]
-    
+
     # 2. Run Tick 1 (Initial)
     print("\n--- Running Tick 1 ---")
     simulation.run_tick()
-    
+
     # 3. Verify Orders
     print("\n--- Verification: Orders ---")
     market = simulation.markets["basic_food"]
     labor_market = simulation.markets["labor_market"]
-    
+
     sell_orders = market.get_all_asks("basic_food")
     print(f"Firm Sell Orders: {len(sell_orders)}")
     if sell_orders:
         print(f"First Sell Order: Price={sell_orders[0].price}")
-        
-    buy_orders = labor_market.get_all_bids("labor") # Firms BUY labor
+
+    buy_orders = labor_market.get_all_bids("labor")  # Firms BUY labor
     print(f"Firm Labor Buy Orders (Job Offers): {len(buy_orders)}")
-    
-    labor_asks = labor_market.get_all_asks("labor") # Households SELL labor
+
+    labor_asks = labor_market.get_all_asks("labor")  # Households SELL labor
     print(f"Household Labor Sell Orders: {len(labor_asks)}")
-    
+
     # 4. Verify Learning Update
     print("\n--- Verification: Learning ---")
     # Simulation calls update_learning at end of tick
     # Check if decisions were recorded in MockRepository
     decisions = repo.decisions
     print(f"Total Recorded AI Decisions: {len(decisions)}")
-    
-    assert len(sell_orders) > 0, "Firm should have placed a SELL order (Continuous Action)"
+
+    assert len(sell_orders) > 0, (
+        "Firm should have placed a SELL order (Continuous Action)"
+    )
     assert len(decisions) >= 2, "Both firm and household should have learned"
-    assert decisions[0].decision_type == "VECTOR_V2", "Decision type should be VECTOR_V2"
+    assert decisions[0].decision_type == "VECTOR_V2", (
+        "Decision type should be VECTOR_V2"
+    )
 
     print("\nSUCCESS: AI Architecture V2 verified!")
 
+
 if __name__ == "__main__":
     run_verification()
diff --git a/tests/verify_automation_tax.py b/tests/verify_automation_tax.py
index 61bd695..5fc7bf6 100644
--- a/tests/verify_automation_tax.py
+++ b/tests/verify_automation_tax.py
@@ -1,8 +1,8 @@
-
 import unittest
 from unittest.mock import Mock, MagicMock
 from simulation.decisions.corporate_manager import CorporateManager
 
+
 class TestAutomationTax(unittest.TestCase):
     def setUp(self):
         self.mock_config = Mock()
@@ -19,7 +19,7 @@ class TestAutomationTax(unittest.TestCase):
         self.mock_firm.revenue_this_turn = 5000.0
 
         # Setup guidance mock
-        self.mock_guidance = {"target_automation": 0.6} # Target 0.6 (Gap 0.1)
+        self.mock_guidance = {"target_automation": 0.6}  # Target 0.6 (Gap 0.1)
 
         self.mock_government = Mock()
 
@@ -40,7 +40,7 @@ class TestAutomationTax(unittest.TestCase):
             aggressiveness,
             self.mock_guidance,
             current_time,
-            government=self.mock_government
+            government=self.mock_government,
         )
 
         # Verify Logic
@@ -53,8 +53,11 @@ class TestAutomationTax(unittest.TestCase):
         # unless the implementation does `firm._assets = firm.assets - x`.
 
         # Better verification: Check if government.collect_tax was called with expected amount.
-        expected_tax = 4000.0 * 0.05 # 200.0
-        self.mock_government.collect_tax.assert_called_with(expected_tax, "automation_tax", 1, current_time)
+        expected_tax = 4000.0 * 0.05  # 200.0
+        self.mock_government.collect_tax.assert_called_with(
+            expected_tax, "automation_tax", 1, current_time
+        )
+
 
-if __name__ == '__main__':
+if __name__ == "__main__":
     unittest.main()
diff --git a/tests/verify_capital_labor_dynamics.py b/tests/verify_capital_labor_dynamics.py
index ca78a5b..a858b38 100644
--- a/tests/verify_capital_labor_dynamics.py
+++ b/tests/verify_capital_labor_dynamics.py
@@ -14,14 +14,16 @@ from simulation.ai_model import AIEngineRegistry
 from simulation.ai.state_builder import StateBuilder
 from simulation.decisions.action_proposal import ActionProposalEngine
 from simulation.decisions.ai_driven_firm_engine import AIDrivenFirmDecisionEngine
-from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
+from simulation.decisions.ai_driven_household_engine import (
+    AIDrivenHouseholdDecisionEngine,
+)
 from simulation.ai.api import Personality
 from simulation.ai.household_ai import HouseholdAI
 from simulation.ai.firm_ai import FirmAI
 from simulation.db.repository import SimulationRepository
 
 # Setup logging
-logging.basicConfig(level=logging.INFO, format='%(name)s:%(message)s')
+logging.basicConfig(level=logging.INFO, format="%(name)s:%(message)s")
 logger = logging.getLogger("TestCapital")
 
 
@@ -34,7 +36,7 @@ class TestCapitalLaborDynamics(unittest.TestCase):
         self.action_proposal_engine = ActionProposalEngine(config_module=config)
         self.ai_trainer = AIEngineRegistry(
             action_proposal_engine=self.action_proposal_engine,
-            state_builder=self.state_builder
+            state_builder=self.state_builder,
         )
 
     def tearDown(self):
@@ -52,7 +54,12 @@ class TestCapitalLaborDynamics(unittest.TestCase):
             talent=Talent(1.0, {}),
             goods_data=[{"id": "basic_food", "utility_effects": {"survival": 10.0}}],
             initial_assets=assets,
-            initial_needs={"survival": 30.0, "social": 20.0, "improvement": 10.0, "asset": 10.0},
+            initial_needs={
+                "survival": 30.0,
+                "social": 20.0,
+                "improvement": 10.0,
+                "asset": 10.0,
+            },
             decision_engine=decision_engine,
             value_orientation=value_orientation,
             personality=Personality.MISER,
@@ -86,26 +93,26 @@ class TestCapitalLaborDynamics(unittest.TestCase):
     def test_cobb_douglas_production(self):
         """Cobb-Douglas ìƒì‚° í•¨ìˆ˜ ê²€ì¦"""
         firm = self._create_firm(10, 10000.0)
-        
+
         # ë…¸ë™ë ¥ ë¶€ì—¬
         h1 = self._create_household(1, 500)
         h1.labor_skill = 5.0
         h2 = self._create_household(2, 500)
         h2.labor_skill = 5.0
         firm.employees = [h1, h2]
-        
+
         initial_capital = firm.capital_stock
         logger.info(f"Initial Capital: {initial_capital:.2f}")
 
         # ìƒì‚° ì‹¤í–‰
         firm.produce(1)
-        
+
         # ìƒì‚°ëŸ‰ í™•ì¸ (Y = A * L^0.7 * K^0.3)
         # A=10, L=10, K=100*(1-0.05)=95
         # Y = 10 * 10^0.7 * 95^0.3 â‰ˆ 10 * 5.01 * 4.0 â‰ˆ 200.4
         self.assertGreater(firm.current_production, 0)
         logger.info(f"âœ“ Produced: {firm.current_production:.2f}")
-        
+
         # ê°ê°€ìƒê° í™•ì¸
         expected_capital = initial_capital * (1 - config.CAPITAL_DEPRECIATION_RATE)
         self.assertAlmostEqual(firm.capital_stock, expected_capital, places=2)
@@ -116,23 +123,23 @@ class TestCapitalLaborDynamics(unittest.TestCase):
         firm = self._create_firm(10, 10000.0)
         initial_capital = firm.capital_stock
         initial_assets = firm.assets
-        
+
         # ë†’ì€ ìë³¸ ê³µê²©ì„±ìœ¼ë¡œ íˆ¬ì ì‹œë®¬ë ˆì´ì…˜
         from simulation.schemas import FirmActionVector
         from simulation.dtos import DecisionContext
-        
+
         action_vector = FirmActionVector(
             sales_aggressiveness=0.5,
             hiring_aggressiveness=0.5,
             production_aggressiveness=0.5,
             dividend_aggressiveness=0.0,
             equity_aggressiveness=0.5,
-            capital_aggressiveness=1.0  # ìµœëŒ€ íˆ¬ì
+            capital_aggressiveness=1.0,  # ìµœëŒ€ íˆ¬ì
         )
-        
+
         households = [self._create_household(i, 500) for i in range(3)]
         firms = [firm]
-        
+
         sim = Simulation(
             households=households,
             firms=firms,
@@ -142,7 +149,7 @@ class TestCapitalLaborDynamics(unittest.TestCase):
             goods_data=[{"id": "basic_food", "utility_effects": {"survival": 10.0}}],
             logger=logger,
         )
-        
+
         context = DecisionContext(
             current_time=1,
             markets={},
@@ -150,7 +157,7 @@ class TestCapitalLaborDynamics(unittest.TestCase):
             market_data=sim._prepare_market_data(sim.tracker),
             firm=firm,
         )
-        
+
         # Make decisions should trigger capital investment via high AI capital_aggressiveness
         # But since that is internal AI decision, we force the investment manually
         # Capital investment happens when cap_aggressiveness > 0.6 and assets > 1000
@@ -160,8 +167,10 @@ class TestCapitalLaborDynamics(unittest.TestCase):
         added_capital = inv_budget * efficiency
         firm._assets -= inv_budget
         firm.capital_stock += added_capital
-        
-        logger.info(f"After Investment - Capital: {firm.capital_stock:.2f}, Assets: {firm.assets:.2f}")
+
+        logger.info(
+            f"After Investment - Capital: {firm.capital_stock:.2f}, Assets: {firm.assets:.2f}"
+        )
         self.assertGreater(firm.capital_stock, initial_capital)
         self.assertLess(firm.assets, initial_assets)
         logger.info("âœ“ Capital investment successful")
@@ -169,25 +178,25 @@ class TestCapitalLaborDynamics(unittest.TestCase):
     def test_wage_downward_rigidity(self):
         """ì„ê¸ˆ í•˜ë°© ê²½ì§ì„± ê²€ì¦"""
         firm = self._create_firm(10, 10000.0)
-        
+
         # ì´ì „ ì„ê¸ˆ ê¸°ë¡ ì„¤ì •
         firm.employee_wages = {1: 100.0, 2: 120.0}  # í‰ê·  110.0
-        
+
         from simulation.schemas import FirmActionVector
         from simulation.dtos import DecisionContext
-        
+
         action_vector = FirmActionVector(
             sales_aggressiveness=0.5,
             hiring_aggressiveness=0.0,
             production_aggressiveness=0.5,
             dividend_aggressiveness=0.0,
             equity_aggressiveness=0.5,
-            capital_aggressiveness=0.5
+            capital_aggressiveness=0.5,
         )
-        
+
         households = [self._create_household(i, 500) for i in range(3)]
         firms = [firm]
-        
+
         sim = Simulation(
             households=households,
             firms=firms,
@@ -197,10 +206,10 @@ class TestCapitalLaborDynamics(unittest.TestCase):
             goods_data=[{"id": "basic_food", "utility_effects": {"survival": 10.0}}],
             logger=logger,
         )
-        
+
         market_data = sim._prepare_market_data(sim.tracker)
         market_data["goods_market"]["labor"] = {"avg_wage": 50.0}
-        
+
         context = DecisionContext(
             current_time=1,
             markets={},
@@ -208,17 +217,19 @@ class TestCapitalLaborDynamics(unittest.TestCase):
             market_data=market_data,
             firm=firm,
         )
-        
+
         firm.inventory[firm.specialization] = 0
         firm.production_target = 100
-        
+
         orders, _ = firm.decision_engine.make_decisions(context)
-        
+
         labor_buy_orders = [o for o in orders if o.item_id == "labor"]
         if labor_buy_orders:
             offer_wage = labor_buy_orders[0].price
             min_allowed_wage = 110.0 * config.WAGE_RIGIDITY_COEFFICIENT
-            logger.info(f"Offer Wage: {offer_wage:.2f}, Rigidity Threshold: {min_allowed_wage:.2f}")
+            logger.info(
+                f"Offer Wage: {offer_wage:.2f}, Rigidity Threshold: {min_allowed_wage:.2f}"
+            )
             self.assertGreaterEqual(offer_wage, min_allowed_wage - 0.01)
             logger.info("âœ“ Wage rigidity verified")
 
@@ -226,4 +237,3 @@ class TestCapitalLaborDynamics(unittest.TestCase):
 if __name__ == "__main__":
     print("\n=== Capital & Labor Dynamics Test ===\n")
     unittest.main(verbosity=2)
-
diff --git a/tests/verify_corporate_tax.py b/tests/verify_corporate_tax.py
index 3e928ea..6acd6ba 100644
--- a/tests/verify_corporate_tax.py
+++ b/tests/verify_corporate_tax.py
@@ -1,4 +1,3 @@
-
 import unittest
 from unittest.mock import MagicMock
 import logging
@@ -8,6 +7,7 @@ from simulation.agents.government import Government
 from simulation.decisions.base_decision_engine import BaseDecisionEngine
 import config
 
+
 class TestCorporateTax(unittest.TestCase):
     def setUp(self):
         self.mock_config = MagicMock()
@@ -16,17 +16,15 @@ class TestCorporateTax(unittest.TestCase):
         self.mock_config.LIQUIDATION_DISCOUNT_RATE = 0.5
         self.mock_config.FIRM_DEFAULT_TOTAL_SHARES = 100.0
         self.mock_config.PROFIT_HISTORY_TICKS = 10
-        
+
         self.mock_logger = logging.getLogger("Test")
         self.mock_decision_engine = MagicMock(spec=BaseDecisionEngine)
-        
+
         # Setup Government
         self.government = Government(
-            id=0,
-            initial_assets=0.0,
-            config_module=self.mock_config
+            id=0, initial_assets=0.0, config_module=self.mock_config
         )
-        
+
         # Setup Firm
         self.firm = Firm(
             id=1,
@@ -37,20 +35,20 @@ class TestCorporateTax(unittest.TestCase):
             decision_engine=self.mock_decision_engine,
             value_orientation="neutral",
             config_module=self.mock_config,
-            logger=self.mock_logger
+            logger=self.mock_logger,
         )
-        self.firm.employees = [] # Start with no employees
+        self.firm.employees = []  # Start with no employees
 
     def test_pay_maintenance(self):
         """Test if maintenance fee is deducted and tax is collected."""
         initial_assets = self.firm.assets
         initial_gov_assets = self.government.assets
-        
+
         # Execute private method via name mangling or just mocking context?
         # Since I added it as _pay_maintenance, I should test it directly or via update_needs
         # Let's test via direct call for unit test
         self.firm._pay_maintenance(self.government, None, current_time=1)
-        
+
         expected_fee = 50.0
         self.assertEqual(self.firm.assets, initial_assets - expected_fee)
         self.assertEqual(self.government.assets, initial_gov_assets + expected_fee)
@@ -59,16 +57,16 @@ class TestCorporateTax(unittest.TestCase):
     def test_pay_corporate_tax(self):
         """Test if corporate tax is paid on profit."""
         self.firm.revenue_this_turn = 1000.0
-        self.firm.cost_this_turn = 500.0 # Expenses
-        
+        self.firm.cost_this_turn = 500.0  # Expenses
+
         # Expected Net Profit = 1000 - 500 = 500
         # Expected Tax = 500 * 0.2 = 100.0
-        
+
         initial_assets = self.firm.assets
         initial_gov_assets = self.government.assets
-        
+
         self.firm._pay_taxes(self.government, current_time=1)
-        
+
         expected_tax = 100.0
         self.assertEqual(self.firm.assets, initial_assets - expected_tax)
         self.assertEqual(self.government.assets, initial_gov_assets + expected_tax)
@@ -76,26 +74,27 @@ class TestCorporateTax(unittest.TestCase):
 
     def test_liquidation_money_conservation(self):
         """Test critical fix: Liquidation should not create money."""
-        self.firm.inventory = {"goods": 100.0} # Value shouldn't matter
-        self.firm.capital_stock = 50.0 # Value shouldn't matter
-        self.firm._assets = 500.0 # Only this should be returned
-        
+        self.firm.inventory = {"goods": 100.0}  # Value shouldn't matter
+        self.firm.capital_stock = 50.0  # Value shouldn't matter
+        self.firm._assets = 500.0  # Only this should be returned
+
         initial_total_money = self.firm.assets
-        
+
         # Execute liquidation
         recovered_cash = self.firm.liquidate_assets()
-        
+
         # Assertions
-        self.assertEqual(recovered_cash, 500.0) # Should be equal to assets
+        self.assertEqual(recovered_cash, 500.0)  # Should be equal to assets
         self.assertEqual(self.firm.assets, 500.0)
         self.assertEqual(len(self.firm.inventory), 0)
         self.assertEqual(self.firm.capital_stock, 0.0)
         self.assertTrue(self.firm.is_bankrupt)
-        
+
         # Conservation Check
         # Money inside Firm should not change (just assets returned)
         # Inventory and Capital disappeared (Real Assets lost), but Money (Financial Asset) conserved.
         self.assertEqual(self.firm.assets, initial_total_money)
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     unittest.main()
diff --git a/tests/verify_economic_equilibrium.py b/tests/verify_economic_equilibrium.py
index 7c88939..9bb5741 100644
--- a/tests/verify_economic_equilibrium.py
+++ b/tests/verify_economic_equilibrium.py
@@ -1,4 +1,3 @@
-
 import logging
 import sys
 import os
@@ -18,16 +17,17 @@ from app import create_simulation, simulation_instance, get_or_create_simulation
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger("EconomyCheck")
 
+
 class TestEconomicConservation(unittest.TestCase):
     def setUp(self):
         self.original_config = {}
-        
+
     def test_conservation_of_money(self):
         print("\n>>> Initializing Simulation for Conservation Check...")
-        
+
         create_simulation()
         from app import simulation_instance as sim
-        
+
         if not sim:
             self.fail("Failed to create simulation.")
 
@@ -41,10 +41,10 @@ class TestEconomicConservation(unittest.TestCase):
 
         initial_money = calculate_total_money(sim)
         print(f"Initial Money Supply: {initial_money:,.2f}")
-        
+
         ticks_to_run = 100
         prev_money = initial_money
-        
+
         print(f"{'Tick':<5} | {'Total Money':<15} | {'Diff':<10}")
         print("-" * 35)
 
@@ -53,7 +53,7 @@ class TestEconomicConservation(unittest.TestCase):
 
             current_money = calculate_total_money(sim)
             diff = current_money - prev_money
-            
+
             # Print periodically or on error
             if i % 10 == 0 or diff < -0.01:
                 print(f"{i:<5} | {current_money:<15,.2f} | {diff:<10.4f}")
@@ -62,7 +62,7 @@ class TestEconomicConservation(unittest.TestCase):
             # Fail only if money decreases significantly (Leak)
             # Increases are allowed (Central Bank injection, Deficit Spending)
             if diff < -1.0:
-                 self.fail(f"Money Leakage Detected at Tick {i}. Diff: {diff}")
+                self.fail(f"Money Leakage Detected at Tick {i}. Diff: {diff}")
 
             prev_money = current_money
 
@@ -70,5 +70,6 @@ class TestEconomicConservation(unittest.TestCase):
         print(f"Final Money: {prev_money:,.2f}")
         print(f"Net Change: {prev_money - initial_money:,.2f}")
 
+
 if __name__ == "__main__":
     unittest.main()
diff --git a/tests/verify_gold_standard.py b/tests/verify_gold_standard.py
index 2a84145..81af8a5 100644
--- a/tests/verify_gold_standard.py
+++ b/tests/verify_gold_standard.py
@@ -17,28 +17,45 @@ from simulation.ai.api import Personality
 import config
 
 # Set up logging to capture output
-logging.basicConfig(level=logging.INFO, format='%(message)s')
+logging.basicConfig(level=logging.INFO, format="%(message)s")
 logger = logging.getLogger("VERIFY_GOLD")
 
+
 class MockRepository:
-    def save_simulation_run(self, **kwargs): return "mock_run_id"
-    def update_simulation_run_end_time(self, run_id): pass
-    def save_agent_states_batch(self, batch): pass
-    def save_transactions_batch(self, batch): pass
-    def save_economic_indicators_batch(self, batch): pass
-    def save_market_history_batch(self, batch): pass
-    def save_ai_decision(self, decision): pass
-    def close(self): pass
+    def save_simulation_run(self, **kwargs):
+        return "mock_run_id"
+
+    def update_simulation_run_end_time(self, run_id):
+        pass
+
+    def save_agent_states_batch(self, batch):
+        pass
+
+    def save_transactions_batch(self, batch):
+        pass
+
+    def save_economic_indicators_batch(self, batch):
+        pass
+
+    def save_market_history_batch(self, batch):
+        pass
+
+    def save_ai_decision(self, decision):
+        pass
+
+    def close(self):
+        pass
+
 
 class VerifyGoldStandard(unittest.TestCase):
     def setUp(self):
         # Override Config for Gold Standard
         self.config = config
         self.config.GOLD_STANDARD_MODE = True
-        self.config.INITIAL_MONEY_SUPPLY = 100000.0 # Just a reference
+        self.config.INITIAL_MONEY_SUPPLY = 100000.0  # Just a reference
         self.config.NUM_HOUSEHOLDS = 10
         self.config.NUM_FIRMS = 2
-        self.config.BATCH_SAVE_INTERVAL = 100 # Disable freq saving
+        self.config.BATCH_SAVE_INTERVAL = 100  # Disable freq saving
 
     def test_gold_standard_conservation(self):
         # 1. Initialize Objects
@@ -57,12 +74,17 @@ class VerifyGoldStandard(unittest.TestCase):
                 talent=Talent(base_learning_rate=0.1, max_potential={}),
                 goods_data=[],
                 initial_assets=5000.0,
-                initial_needs={"survival": 0.0, "asset": 0.0, "social": 0.0, "improvement": 0.0},
+                initial_needs={
+                    "survival": 0.0,
+                    "asset": 0.0,
+                    "social": 0.0,
+                    "improvement": 0.0,
+                },
                 decision_engine=decision_engine,
                 value_orientation="wealth_and_needs",
                 personality=Personality.GROWTH_ORIENTED,
                 config_module=self.config,
-                logger=logger
+                logger=logger,
             )
             # Add mock return values for decision
             mock_vector = MagicMock()
@@ -97,7 +119,7 @@ class VerifyGoldStandard(unittest.TestCase):
                 decision_engine=decision_engine,
                 value_orientation="wealth_and_needs",
                 config_module=self.config,
-                logger=logger
+                logger=logger,
             )
             # Add mocks to bypass logic errors in test
             mock_firm_vector = MagicMock()
@@ -108,7 +130,9 @@ class VerifyGoldStandard(unittest.TestCase):
             mock_firm_vector.investment_aggressiveness = 0.5
 
             f.make_decision = MagicMock(return_value=([], mock_firm_vector))
-            f.decision_engine.make_decision = MagicMock(return_value=([], mock_firm_vector))
+            f.decision_engine.make_decision = MagicMock(
+                return_value=([], mock_firm_vector)
+            )
 
             firms.append(f)
 
@@ -126,7 +150,7 @@ class VerifyGoldStandard(unittest.TestCase):
             repository=repo,
             config_module=self.config,
             goods_data=[],
-            logger=logger
+            logger=logger,
         )
 
         # 2. Run Ticks
@@ -141,15 +165,19 @@ class VerifyGoldStandard(unittest.TestCase):
 
                 # Check Conservation
                 current_money = sim._calculate_total_money()
-                expected_money = sim.baseline_money_supply + sim.government.get_monetary_delta()
+                expected_money = (
+                    sim.baseline_money_supply + sim.government.get_monetary_delta()
+                )
                 delta = current_money - expected_money
                 deltas.append(delta)
 
-                print(f"Tick {i+1}: Current={current_money:.2f}, Expected={expected_money:.2f}, Delta={delta:.4f}")
+                print(
+                    f"Tick {i + 1}: Current={current_money:.2f}, Expected={expected_money:.2f}, Delta={delta:.4f}"
+                )
 
                 # Assertion
                 if abs(delta) > 1.0:
-                     self.fail(f"Conservation broken at tick {i+1}. Delta: {delta}")
+                    self.fail(f"Conservation broken at tick {i + 1}. Delta: {delta}")
 
         except Exception as e:
             logger.error(f"Simulation crashed: {e}")
@@ -167,7 +195,7 @@ class VerifyGoldStandard(unittest.TestCase):
 ## Summary
 - **Mode**: Gold Standard (Full Reserve)
 - **Ticks Simulated**: 50
-- **Verification Status**: {'PASSED' if max_delta < 1.0 else 'FAILED'}
+- **Verification Status**: {"PASSED" if max_delta < 1.0 else "FAILED"}
 - **Max Delta**: {max_delta:.4f}
 - **Avg Delta**: {avg_delta:.4f}
 
@@ -188,5 +216,6 @@ Bank reserves were strictly enforced, preventing unauthorized credit creation.
             f.write(report_content)
         print("\nReport generated at reports/GOLD_STANDARD_REPORT.md")
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     unittest.main()
diff --git a/tests/verify_industrial_revolution.py b/tests/verify_industrial_revolution.py
index 4312b96..bbf1114 100644
--- a/tests/verify_industrial_revolution.py
+++ b/tests/verify_industrial_revolution.py
@@ -10,6 +10,7 @@ from simulation.core_agents import Household
 from simulation.firms import Firm
 import config as Config
 import simulation.db.database
+
 simulation.db.database.DATABASE_NAME = ":memory:"
 from simulation.db.repository import SimulationRepository
 from simulation.ai_model import AIEngineRegistry
@@ -17,16 +18,17 @@ from simulation.ai_model import AIEngineRegistry
 # --- Configuration for Verification ---
 Config.NUM_HOUSEHOLDS = 50
 Config.NUM_FIRMS = 5
-Config.SIMULATION_TICKS = 150 # Run enough to see adoption
-Config.TECH_FERTILIZER_UNLOCK_TICK = 10 # Early unlock
-Config.TECH_DIFFUSION_RATE = 0.2 # Fast diffusion for test
+Config.SIMULATION_TICKS = 150  # Run enough to see adoption
+Config.TECH_FERTILIZER_UNLOCK_TICK = 10  # Early unlock
+Config.TECH_DIFFUSION_RATE = 0.2  # Fast diffusion for test
 Config.FIRM_MIN_PRODUCTION_TARGET = 10.0
-Config.ENABLE_VANITY_SYSTEM = False # Disable for simpler test
-Config.STOCK_MARKET_ENABLED = False # Disable for simpler test
+Config.ENABLE_VANITY_SYSTEM = False  # Disable for simpler test
+Config.STOCK_MARKET_ENABLED = False  # Disable for simpler test
 
 from simulation.ai.state_builder import StateBuilder
 from simulation.decisions.action_proposal import ActionProposalEngine
 
+
 def verify_industrial_revolution():
     logging.basicConfig(level=logging.INFO)
     logger = logging.getLogger("IndustrialRevVerify")
@@ -35,100 +37,120 @@ def verify_industrial_revolution():
 
     # 1. Setup Simulation
     repo = SimulationRepository()
-    
+
     # Initialize AI dependencies
     state_builder = StateBuilder()
     action_proposal = ActionProposalEngine(config_module=Config)
-    ai_registry = AIEngineRegistry(action_proposal_engine=action_proposal, state_builder=state_builder)
-    
+    ai_registry = AIEngineRegistry(
+        action_proposal_engine=action_proposal, state_builder=state_builder
+    )
+
     # Create agents
     from simulation.core_agents import Talent
     from simulation.ai.api import Personality
-    from simulation.decisions.rule_based_household_engine import RuleBasedHouseholdDecisionEngine
-    from simulation.decisions.standalone_rule_based_firm_engine import StandaloneRuleBasedFirmDecisionEngine
+    from simulation.decisions.rule_based_household_engine import (
+        RuleBasedHouseholdDecisionEngine,
+    )
+    from simulation.decisions.standalone_rule_based_firm_engine import (
+        StandaloneRuleBasedFirmDecisionEngine,
+    )
     import random
-    
+
     dummy_goods = [{"id": "basic_food", "sector": "FOOD"}]
-    initial_needs = {"survival": 50, "social": 10, "growth": 10, "survival_need": 50, "imitation_need": 0, "recognition_need": 0, "wealth_need": 0}
-    
+    initial_needs = {
+        "survival": 50,
+        "social": 10,
+        "growth": 10,
+        "survival_need": 50,
+        "imitation_need": 0,
+        "recognition_need": 0,
+        "wealth_need": 0,
+    }
+
     households = [
         Household(
-            id=i, 
-            initial_assets=1000, 
-            decision_engine=RuleBasedHouseholdDecisionEngine(Config, logger), 
+            id=i,
+            initial_assets=1000,
+            decision_engine=RuleBasedHouseholdDecisionEngine(Config, logger),
             config_module=Config,
             talent=Talent(1.0, {}),
             goods_data=dummy_goods,
             initial_needs=initial_needs,
             value_orientation="wealth_and_needs",
-            personality=Personality.CONSERVATIVE
+            personality=Personality.CONSERVATIVE,
         )
         for i in range(Config.NUM_HOUSEHOLDS)
     ]
     firms = [
         Firm(
-            id=i + 1000, 
-            initial_capital=50000, 
-            initial_liquidity_need=1000, 
-            specialization="basic_food", 
-            productivity_factor=10.0, 
-            decision_engine=StandaloneRuleBasedFirmDecisionEngine(Config, logger), 
-            value_orientation="PROFIT", 
-            config_module=Config, 
-            sector="FOOD", 
-            is_visionary=(i==0),
-            personality=Personality.BALANCED
-        ) # Firm 0 is Visionary
+            id=i + 1000,
+            initial_capital=50000,
+            initial_liquidity_need=1000,
+            specialization="basic_food",
+            productivity_factor=10.0,
+            decision_engine=StandaloneRuleBasedFirmDecisionEngine(Config, logger),
+            value_orientation="PROFIT",
+            config_module=Config,
+            sector="FOOD",
+            is_visionary=(i == 0),
+            personality=Personality.BALANCED,
+        )  # Firm 0 is Visionary
         for i in range(Config.NUM_FIRMS)
     ]
-    
+
     sim = Simulation(households, firms, ai_registry, repo, Config, goods_data=[])
-    
+
     # 2. Run Pre-Unlock Phase (Tick 0-9)
     logger.info("Running Pre-Unlock Phase...")
     for _ in range(9):
         sim.run_tick()
-        
+
     # Check TFP before unlock
     firm_0_tfp_before = sim.firms[0].productivity_factor
     logger.info(f"Firm 0 TFP Before: {firm_0_tfp_before}")
 
     # 3. Run Unlock & Diffusion Phase (Tick 10-50)
     logger.info("Running Unlock & Diffusion Phase...")
-    
+
     tech_unlocked = False
     adopted_count = 0
-    
-    for _ in range(41): # Tick 9 -> 50
+
+    for _ in range(41):  # Tick 9 -> 50
         sim.run_tick()
-        
+
         # Check Tech Manager State
         if "TECH_AGRI_CHEM_01" in sim.technology_manager.active_techs:
             if not tech_unlocked:
                 logger.info(f"âœ… Tech Unlocked at Tick {sim.time}!")
                 tech_unlocked = True
-        
+
         # Check Adoption
-        current_adopted = sum(1 for f in sim.firms if sim.technology_manager.has_adopted(f.id, "TECH_AGRI_CHEM_01"))
+        current_adopted = sum(
+            1
+            for f in sim.firms
+            if sim.technology_manager.has_adopted(f.id, "TECH_AGRI_CHEM_01")
+        )
         if current_adopted > adopted_count:
-            logger.info(f"ğŸ“ˆ Adoption increased: {adopted_count} -> {current_adopted} firms.")
+            logger.info(
+                f"ğŸ“ˆ Adoption increased: {adopted_count} -> {current_adopted} firms."
+            )
             adopted_count = current_adopted
 
     # 4. Verification Assertions
     logger.info("--- Verification Results ---")
-    
+
     # A. Tech Unlock
     if tech_unlocked:
         logger.info("âœ… Tech Unlock Verified.")
     else:
         logger.error("âŒ Tech Unlock Failed.")
-        
+
     # B. Visionary Adoption
     if sim.technology_manager.has_adopted(firms[0].id, "TECH_AGRI_CHEM_01"):
-         logger.info("âœ… Visionary Firm Adoption Verified.")
+        logger.info("âœ… Visionary Firm Adoption Verified.")
     else:
-         logger.error("âŒ Visionary Firm Adoption Failed.")
-         
+        logger.error("âŒ Visionary Firm Adoption Failed.")
+
     # C. Productivity Boost
     # Firm 0's actual output or effective TFP should be 3x base
     mult = sim.technology_manager.get_productivity_multiplier(firms[0].id, "FOOD")
@@ -136,14 +158,19 @@ def verify_industrial_revolution():
         logger.info(f"âœ… Productivity Multiplier Verified: {mult}")
     else:
         logger.error(f"âŒ Productivity Multiplier Mismatch: {mult} (Expected 3.0)")
-        
+
     # D. Diffusion
     if adopted_count > 1:
-        logger.info(f"âœ… Diffusion Verified (Total Adopted: {adopted_count}/{len(firms)})")
+        logger.info(
+            f"âœ… Diffusion Verified (Total Adopted: {adopted_count}/{len(firms)})"
+        )
     else:
-        logger.warning(f"âš ï¸ Diffusion Slow/Failed (Total Adopted: {adopted_count}). Check rate.")
+        logger.warning(
+            f"âš ï¸ Diffusion Slow/Failed (Total Adopted: {adopted_count}). Check rate."
+        )
 
     logger.info("--- Verification Complete ---")
 
+
 if __name__ == "__main__":
     verify_industrial_revolution()
diff --git a/tests/verify_labor_dynamics.py b/tests/verify_labor_dynamics.py
index fd7a7c0..0b51892 100644
--- a/tests/verify_labor_dynamics.py
+++ b/tests/verify_labor_dynamics.py
@@ -1,4 +1,3 @@
-
 import unittest
 import logging
 import random
@@ -11,13 +10,16 @@ from simulation.db.repository import SimulationRepository
 from simulation.ai_model import AIEngineRegistry
 from simulation.core_agents import Household, Talent
 from simulation.firms import Firm
-from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
+from simulation.decisions.ai_driven_household_engine import (
+    AIDrivenHouseholdDecisionEngine,
+)
 from simulation.decisions.ai_driven_firm_engine import AIDrivenFirmDecisionEngine
 from simulation.schemas import FirmActionVector, HouseholdActionVector
 from simulation.ai.firm_ai import FirmAI
 from simulation.ai.household_ai import HouseholdAI
 from simulation.ai.enums import Personality
 
+
 class TestLaborDynamics(unittest.TestCase):
     def setUp(self):
         self.db_path = "simulation_data.db"
@@ -26,23 +28,23 @@ class TestLaborDynamics(unittest.TestCase):
                 os.remove(self.db_path)
             except:
                 pass
-            
+
         self.repository = SimulationRepository()
         self.repository.clear_all_data()
 
     def test_job_hopping_and_wages(self):
         print("\n=== Labor Market Test: Job Hopping & Recurring Wages ===")
-        
+
         logging.basicConfig(level=logging.INFO)
         logger = logging.getLogger("TestLabor")
-        
+
         mock_action_proposal = MagicMock()
         mock_state_builder = MagicMock()
         ai_manager = AIEngineRegistry(
             action_proposal_engine=mock_action_proposal,
-            state_builder=mock_state_builder
+            state_builder=mock_state_builder,
         )
-        
+
         goods_list = []
         for id, info in config.GOODS.items():
             info["id"] = id
@@ -50,28 +52,30 @@ class TestLaborDynamics(unittest.TestCase):
 
         # 1. Create Agents
         households = []
-        for i in range(10): # 10 Households
+        for i in range(10):  # 10 Households
             talent = Talent(base_learning_rate=0.1, max_potential={})
-            ai_engine = ai_manager.get_engine("needs_and_growth") 
+            ai_engine = ai_manager.get_engine("needs_and_growth")
             household_ai = HouseholdAI(agent_id=f"H{i}", ai_decision_engine=ai_engine)
-            decision_engine = AIDrivenHouseholdDecisionEngine(household_ai, config, logger)
-            
+            decision_engine = AIDrivenHouseholdDecisionEngine(
+                household_ai, config, logger
+            )
+
             h = Household(
                 id=i,
                 talent=talent,
                 goods_data=goods_list,
-                initial_assets=100.0, # Low initial assets
+                initial_assets=100.0,  # Low initial assets
                 initial_needs={
                     "survival": 50.0,
                     "social": 10.0,
                     "asset": 10.0,
-                    "improvement": 10.0
+                    "improvement": 10.0,
                 },
                 decision_engine=decision_engine,
                 value_orientation="needs_and_growth",
                 personality=Personality.GROWTH_ORIENTED,
                 config_module=config,
-                logger=logger
+                logger=logger,
             )
             households.append(h)
 
@@ -80,10 +84,15 @@ class TestLaborDynamics(unittest.TestCase):
         ai_engine_10 = ai_manager.get_engine("profit_maximizer")
         firm_ai_10 = FirmAI(agent_id="20", ai_decision_engine=ai_engine_10)
         f10 = Firm(
-            id=20, initial_capital=50000.0, initial_liquidity_need=100.0,
-            specialization="basic_food", productivity_factor=10.0,
+            id=20,
+            initial_capital=50000.0,
+            initial_liquidity_need=100.0,
+            specialization="basic_food",
+            productivity_factor=10.0,
             decision_engine=AIDrivenFirmDecisionEngine(firm_ai_10, config, logger),
-            value_orientation="profit_maximizer", config_module=config, logger=logger
+            value_orientation="profit_maximizer",
+            config_module=config,
+            logger=logger,
         )
         firms.append(f10)
 
@@ -91,18 +100,28 @@ class TestLaborDynamics(unittest.TestCase):
         ai_engine_11 = ai_manager.get_engine("profit_maximizer")
         firm_ai_11 = FirmAI(agent_id="21", ai_decision_engine=ai_engine_11)
         f11 = Firm(
-            id=21, initial_capital=50000.0, initial_liquidity_need=100.0,
-            specialization="basic_food", productivity_factor=10.0,
+            id=21,
+            initial_capital=50000.0,
+            initial_liquidity_need=100.0,
+            specialization="basic_food",
+            productivity_factor=10.0,
             decision_engine=AIDrivenFirmDecisionEngine(firm_ai_11, config, logger),
-            value_orientation="profit_maximizer", config_module=config, logger=logger
+            value_orientation="profit_maximizer",
+            config_module=config,
+            logger=logger,
         )
         firms.append(f11)
 
         sim = Simulation(
-            households=households, firms=firms, ai_trainer=ai_manager,
-            repository=self.repository, config_module=config, goods_data=goods_list, logger=logger
+            households=households,
+            firms=firms,
+            ai_trainer=ai_manager,
+            repository=self.repository,
+            config_module=config,
+            goods_data=goods_list,
+            logger=logger,
         )
-        
+
         # Increase targets to ensure they keep hiring
         f10.production_target = 100.0
         f11.production_target = 100.0
@@ -114,27 +133,35 @@ class TestLaborDynamics(unittest.TestCase):
         # Helper Vectors
         # f10: Low Aggressiveness for wages (initially)
         # f11: High Aggressiveness for wages (initially)
-        
+
         # Run Phase 1: Firm 10 hires first (Tick 1-5)
         print("Phase 1: Firm 20 (Low Wage) Hires (Tick 1-5)")
-        f11.is_active = False # Temporarily disable f11 to let f10 hire everyone
-        
+        f11.is_active = False  # Temporarily disable f11 to let f10 hire everyone
+
         for t in range(1, 6):
             # Firm 20 offers min wage
-            f10.decision_engine.ai_engine.decide_action_vector = MagicMock(return_value=FirmActionVector(0.5, 0.0, 0.5))
+            f10.decision_engine.ai_engine.decide_action_vector = MagicMock(
+                return_value=FirmActionVector(0.5, 0.0, 0.5)
+            )
             for h in sim.households:
                 h.needs["survival"] = 0.0  # Prevent death
                 h.needs["social"] = 0.0
                 h.needs["asset"] = 0.0
                 h.needs["improvement"] = 0.0
-                h.decision_engine.ai_engine.decide_action_vector = MagicMock(return_value=HouseholdActionVector({"basic_food": 0.5}, 1.0, 0.9, 0.0, 0.0))
-            
+                h.decision_engine.ai_engine.decide_action_vector = MagicMock(
+                    return_value=HouseholdActionVector(
+                        {"basic_food": 0.5}, 1.0, 0.9, 0.0, 0.0
+                    )
+                )
+
             sim.run_tick()
 
         f10_hired = len(f10.employees)
         print(f"Firm 20 Employees after Phase 1: {f10_hired}")
         h0 = sim.households[0]
-        print(f"H0 Assets: {h0.assets:.2f}, Wage: {h0.current_wage:.2f}, Employer: {h0.employer_id}")
+        print(
+            f"H0 Assets: {h0.assets:.2f}, Wage: {h0.current_wage:.2f}, Employer: {h0.employer_id}"
+        )
 
         # Run Phase 2: Firm 21 (High Wage) Enters (Tick 6-31)
         print("\nPhase 2: Firm 21 (High Wage) Enters (Tick 6-31)")
@@ -142,45 +169,63 @@ class TestLaborDynamics(unittest.TestCase):
         if f11 not in sim.firms:
             sim.firms.append(f11)
             sim.agents[f11.id] = f11
-        
+
         hops = 0
-        ever_at_20 = {h.id for h in sim.households if h.employer_id == 20} # Everyone starts at 20 (roughly)
+        ever_at_20 = {
+            h.id for h in sim.households if h.employer_id == 20
+        }  # Everyone starts at 20 (roughly)
         hopped_agents = set()
 
         for t in range(6, 41):
             # f10 stays low, f11 goes high
-            f10.decision_engine.ai_engine.decide_action_vector = MagicMock(return_value=FirmActionVector(0.5, 0.0, 0.5))
-            f11.decision_engine.ai_engine.decide_action_vector = MagicMock(return_value=FirmActionVector(0.5, 1.0, 0.5))
-            
+            f10.decision_engine.ai_engine.decide_action_vector = MagicMock(
+                return_value=FirmActionVector(0.5, 0.0, 0.5)
+            )
+            f11.decision_engine.ai_engine.decide_action_vector = MagicMock(
+                return_value=FirmActionVector(0.5, 1.0, 0.5)
+            )
+
             old_employers = {h.id: h.employer_id for h in sim.households}
-            
+
             for h in sim.households:
-                h.needs["survival"] = 0.0 # Keep them alive and happy
+                h.needs["survival"] = 0.0  # Keep them alive and happy
                 h.needs["social"] = 0.0
                 h.needs["asset"] = 0.0
                 h.needs["improvement"] = 0.0
-                h.decision_engine.ai_engine.decide_action_vector = MagicMock(return_value=HouseholdActionVector({"basic_food": 0.5}, 1.0, 0.9, 0.0, 0.0))
-            
+                h.decision_engine.ai_engine.decide_action_vector = MagicMock(
+                    return_value=HouseholdActionVector(
+                        {"basic_food": 0.5}, 1.0, 0.9, 0.0, 0.0
+                    )
+                )
+
             sim.run_tick()
-            
+
             for h in sim.households:
-                if h.id in ever_at_20 and h.employer_id == 21 and h.id not in hopped_agents:
+                if (
+                    h.id in ever_at_20
+                    and h.employer_id == 21
+                    and h.id not in hopped_agents
+                ):
                     hops += 1
                     hopped_agents.add(h.id)
-            
+
             if t % 5 == 0:
                 market_data = sim._prepare_market_data(sim.tracker)
                 # avg_wage might be in trackers or prepare_market_data?
                 # Actually, f21's buying price is what matters
-                print(f"Tick {t} | F20 Emp: {len([e for e in f10.employees if e.is_active])} | F21 Emp: {len([e for e in f11.employees if e.is_active])} | Hops: {hops}")
+                print(
+                    f"Tick {t} | F20 Emp: {len([e for e in f10.employees if e.is_active])} | F21 Emp: {len([e for e in f11.employees if e.is_active])} | Hops: {hops}"
+                )
 
         print(f"\nFinal Statistics:")
         print(f"Firm 20 Employees: {len(f10.employees)}")
         print(f"Firm 21 Employees: {len(f11.employees)}")
         print(f"Total Successful Job Hops: {hops}")
-        
+
         h0 = sim.households[0]
-        print(f"H0 Final State: Employed={h0.is_employed}, Employer={h0.employer_id}, Wage={h0.current_wage:.2f}, Assets={h0.assets:.2f}")
+        print(
+            f"H0 Final State: Employed={h0.is_employed}, Employer={h0.employer_id}, Wage={h0.current_wage:.2f}, Assets={h0.assets:.2f}"
+        )
 
         # Assertions
         self.assertTrue(hops >= 0, "Hops should be non-negative (logic check)")
@@ -189,10 +234,14 @@ class TestLaborDynamics(unittest.TestCase):
             print("SUCCESS: Job hopping behavior detected!")
         else:
             print("NOTICE: No job hops detected. Check stickiness or wage gaps.")
-            
+
         # Check recurring wages: H0 assets should be much higher than initial 100
-        self.assertTrue(h0.assets > 100.0, "Households should accumulate assets from recurring wages.")
+        self.assertTrue(
+            h0.assets > 100.0,
+            "Households should accumulate assets from recurring wages.",
+        )
         print("SUCCESS: Recurring wage payments verified.")
 
+
 if __name__ == "__main__":
     unittest.main()
diff --git a/tests/verify_leviathan.py b/tests/verify_leviathan.py
index de68627..6940c4e 100644
--- a/tests/verify_leviathan.py
+++ b/tests/verify_leviathan.py
@@ -8,6 +8,7 @@ from simulation.core_agents import Household
 
 # Convert to pytest to use golden fixtures
 
+
 @pytest.fixture
 def government(golden_config):
     if golden_config:
@@ -32,6 +33,7 @@ def government(golden_config):
 
     return gov
 
+
 @pytest.fixture
 def mock_households(golden_households):
     # Use golden fixture if available
@@ -41,12 +43,12 @@ def mock_households(golden_households):
     if golden_households:
         base_h = golden_households[0]
         for i in range(10):
-             h = MagicMock(spec=Household)
-             h.id = i
-             h.is_active = True
-             h.approval_rating = 1 # Start happy
-             h.needs = {"survival": 20.0}
-             households.append(h)
+            h = MagicMock(spec=Household)
+            h.id = i
+            h.is_active = True
+            h.approval_rating = 1  # Start happy
+            h.needs = {"survival": 20.0}
+            households.append(h)
     else:
         # Fallback
         for i in range(10):
@@ -59,6 +61,7 @@ def mock_households(golden_households):
 
     return households
 
+
 def test_opinion_aggregation(government, mock_households):
     """Test if Government aggregates household approval correctly."""
     # 5 Happy, 5 Unhappy
@@ -73,33 +76,37 @@ def test_opinion_aggregation(government, mock_households):
     assert len(government.public_opinion_queue) == 1
     assert government.perceived_public_opinion == 0.5
 
+
 def test_opinion_lag(government, mock_households):
     """Test if Perceived Public Opinion lags by 4 ticks (or queue size)."""
     # Tick 1: 1.0
-    for h in mock_households: h.approval_rating = 1
-    government.update_public_opinion(mock_households) # Q: [1.0]
+    for h in mock_households:
+        h.approval_rating = 1
+    government.update_public_opinion(mock_households)  # Q: [1.0]
     assert government.perceived_public_opinion == 1.0
 
     # Tick 2: 0.0
-    for h in mock_households: h.approval_rating = 0
-    government.update_public_opinion(mock_households) # Q: [1.0, 0.0]
-    assert government.perceived_public_opinion == 1.0 # Still sees old
+    for h in mock_households:
+        h.approval_rating = 0
+    government.update_public_opinion(mock_households)  # Q: [1.0, 0.0]
+    assert government.perceived_public_opinion == 1.0  # Still sees old
 
     # Tick 3: 0.0
-    government.update_public_opinion(mock_households) # Q: [1.0, 0.0, 0.0]
+    government.update_public_opinion(mock_households)  # Q: [1.0, 0.0, 0.0]
     assert government.perceived_public_opinion == 1.0
 
     # Tick 4: 0.0
-    government.update_public_opinion(mock_households) # Q: [1.0, 0.0, 0.0, 0.0]
+    government.update_public_opinion(mock_households)  # Q: [1.0, 0.0, 0.0, 0.0]
     assert government.perceived_public_opinion == 1.0
 
     # Tick 5: 0.0 -> Queue pops
-    government.update_public_opinion(mock_households) # Q: [0.0, 0.0, 0.0, 0.0]
-    assert government.perceived_public_opinion == 0.0 # Finally sees drop
+    government.update_public_opinion(mock_households)  # Q: [0.0, 0.0, 0.0, 0.0]
+    assert government.perceived_public_opinion == 0.0  # Finally sees drop
+
 
 def test_election_flip(government):
     """Test if Government flips party on low approval at election tick."""
-    government.perceived_public_opinion = 0.4 # Below 0.5
+    government.perceived_public_opinion = 0.4  # Below 0.5
     government.ruling_party = PoliticalParty.BLUE
 
     government.check_election(100)
@@ -111,6 +118,7 @@ def test_election_flip(government):
     government.check_election(200)
     assert government.ruling_party == PoliticalParty.BLUE
 
+
 def test_ai_policy_execution(government):
     """Test if AI actions translate to policy changes based on Party."""
     market_data = {"total_production": 100.0}
@@ -123,14 +131,17 @@ def test_ai_policy_execution(government):
 
     # Force AI to choose EXPAND (Action 0)
     mock_central_bank = MagicMock()
-    mock_central_bank.base_rate = 0.05 # Ensure base_rate is float for comparison
+    mock_central_bank.base_rate = 0.05  # Ensure base_rate is float for comparison
 
     # Try explicitly setting policy engine to AI if it's not.
     from simulation.policies.smart_leviathan_policy import SmartLeviathanPolicy
+
     if not isinstance(government.policy_engine, SmartLeviathanPolicy):
-        government.policy_engine = SmartLeviathanPolicy(government, government.config_module)
+        government.policy_engine = SmartLeviathanPolicy(
+            government, government.config_module
+        )
 
-    with patch.object(government.ai, 'decide_policy', return_value=0) as mock_decide:
+    with patch.object(government.ai, "decide_policy", return_value=0) as mock_decide:
         government.make_policy_decision(market_data, 30, mock_central_bank)
 
     # Expect Corp Tax Cut, Subsidy Increase
@@ -197,7 +208,7 @@ def test_ai_policy_execution(government):
     # Let's set `GOVERNMENT_POLICY_MODE` to "AI_ADAPTIVE".
 
     government.config_module.GOVERNMENT_POLICY_MODE = "AI_ADAPTIVE"
-    government.config_module.GOV_ACTION_INTERVAL = 30 # Ensure this is int, not Mock
+    government.config_module.GOV_ACTION_INTERVAL = 30  # Ensure this is int, not Mock
 
     # Ensure other config values are floats to prevent TypeErrors in min/max comparisons
     government.config_module.BUDGET_ALLOCATION_MIN = 0.1
@@ -205,10 +216,13 @@ def test_ai_policy_execution(government):
 
     # Re-init policy engine to pick up new config
     from simulation.policies.smart_leviathan_policy import SmartLeviathanPolicy
-    government.policy_engine = SmartLeviathanPolicy(government, government.config_module)
+
+    government.policy_engine = SmartLeviathanPolicy(
+        government, government.config_module
+    )
     government.ai = government.policy_engine.ai
 
-    with patch.object(government.ai, 'decide_policy', return_value=0) as mock_decide:
+    with patch.object(government.ai, "decide_policy", return_value=0) as mock_decide:
         government.make_policy_decision(market_data, 30, mock_central_bank)
 
     # Expect Corp Tax Cut, Subsidy Increase
@@ -261,7 +275,9 @@ def test_ai_policy_execution(government):
 
     action_fiscal_ease = getattr(government.ai, "ACTION_FISCAL_EASE", 3)
 
-    with patch.object(government.ai, 'decide_policy', return_value=action_fiscal_ease) as mock_decide:
+    with patch.object(
+        government.ai, "decide_policy", return_value=action_fiscal_ease
+    ) as mock_decide:
         government.make_policy_decision(market_data, 30, mock_central_bank)
 
     assert government.corporate_tax_rate < 0.2
@@ -272,7 +288,7 @@ def test_ai_policy_execution(government):
     government.income_tax_rate = 0.1
     government.welfare_budget_multiplier = 0.9
 
-    with patch.object(government.ai, 'decide_policy', return_value=action_fiscal_ease):
+    with patch.object(government.ai, "decide_policy", return_value=action_fiscal_ease):
         government.make_policy_decision(market_data, 30, mock_central_bank)
 
     # Expect Income Tax Cut, Welfare Increase
diff --git a/tests/verify_maslow_education.py b/tests/verify_maslow_education.py
index 68fe7b9..2e97247 100644
--- a/tests/verify_maslow_education.py
+++ b/tests/verify_maslow_education.py
@@ -3,9 +3,12 @@ import math
 from unittest.mock import MagicMock
 from simulation.core_agents import Household, Talent
 from simulation.ai.household_ai import HouseholdAI
-from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
+from simulation.decisions.ai_driven_household_engine import (
+    AIDrivenHouseholdDecisionEngine,
+)
 import config
 
+
 class MockConfig:
     MASLOW_SURVIVAL_THRESHOLD = 50.0
     EDUCATION_SENSITIVITY = 0.1
@@ -14,7 +17,10 @@ class MockConfig:
     LEARNING_EFFICIENCY = 1.0
     GOODS = {
         "basic_food": {"utility_effects": {"survival": 10}, "is_service": False},
-        "education_service": {"utility_effects": {"improvement": 15}, "is_service": True}
+        "education_service": {
+            "utility_effects": {"improvement": 15},
+            "is_service": True,
+        },
     }
     NEED_FACTOR_BASE = 0.5
     NEED_FACTOR_SCALE = 100.0
@@ -48,79 +54,94 @@ class MockConfig:
     HOUSEHOLD_LOW_ASSET_WAGE = 8.0
     HOUSEHOLD_DEFAULT_WAGE = 10.0
 
+
 @pytest.fixture
 def mock_household():
     talent = Talent(base_learning_rate=0.1, max_potential={})
     goods_data = [
         {"id": "basic_food", "utility_effects": {"survival": 10}, "is_service": False},
-        {"id": "education_service", "utility_effects": {"improvement": 15}, "is_service": True}
+        {
+            "id": "education_service",
+            "utility_effects": {"improvement": 15},
+            "is_service": True,
+        },
     ]
-    
+
     # Use real AI Engine for logic verification
     real_ai = HouseholdAI(agent_id="h1", ai_decision_engine=MagicMock())
     real_ai.ai_decision_engine.config_module = MockConfig
-    
-    decision_engine = AIDrivenHouseholdDecisionEngine(ai_engine=real_ai, config_module=MockConfig)
-    
+
+    decision_engine = AIDrivenHouseholdDecisionEngine(
+        ai_engine=real_ai, config_module=MockConfig
+    )
+
     h = Household(
         id=1,
         talent=talent,
         goods_data=goods_data,
         initial_assets=1000.0,
-        initial_needs={"survival": 10.0, "improvement": 0.0, "asset": 0.0, "social": 0.0},
+        initial_needs={
+            "survival": 10.0,
+            "improvement": 0.0,
+            "asset": 0.0,
+            "social": 0.0,
+        },
         decision_engine=decision_engine,
         value_orientation="wealth_and_needs",
         personality=MagicMock(),
-        config_module=MockConfig
+        config_module=MockConfig,
     )
     return h
 
+
 def test_maslow_gating_logic(mock_household):
     """Verify that high survival need masks non-essential actions."""
-    mock_household.needs["survival"] = 60.0 # Starving
-    
+    mock_household.needs["survival"] = 60.0  # Starving
+
     agent_data = mock_household.get_agent_data()
     market_data = {"goods_market": {}}
     goods_list = ["basic_food", "education_service"]
-    
+
     # Calling the real AI logic
     action_vector = mock_household.decision_engine.ai_engine.decide_action_vector(
         agent_data, market_data, goods_list
     )
-    
+
     print(f"DEBUG: Action Vector: {action_vector}")
-    
+
     # education_service should be 0.0 because it's non-survival
     assert action_vector.consumption_aggressiveness["education_service"] == 0.0
     # basic_food should NOT be forced to 0.0 (it might be 0.0 by chance, but let's check it's not strictly masked if we can)
     # Actually, we just need to ensure the masking logic for non-essentials works.
     assert action_vector.investment_aggressiveness == 0.0
 
+
 def test_education_xp_accumulation(mock_household):
     """Verify that consuming education_service increases education_xp."""
     initial_xp = getattr(mock_household, "education_xp", 0.0)
     mock_household.consume("education_service", 2.0, current_time=1)
-    
+
     new_xp = getattr(mock_household, "education_xp", 0.0)
     assert new_xp == initial_xp + (2.0 * MockConfig.LEARNING_EFFICIENCY)
 
+
 def test_inheritance_bonus():
     """Verify that child inherits learning rate bonus from parent education_xp."""
     parent = MagicMock()
     parent.education_xp = 10.0
-    
+
     child_ai = HouseholdAI(agent_id="c1", ai_decision_engine=MagicMock())
-    
+
     import math
     from simulation.ai.ai_training_manager import AITrainingManager
-    
+
     # We can test the logic directly or via a mock manager
     sensitivity = MockConfig.EDUCATION_SENSITIVITY
     base_rate = MockConfig.BASE_LEARNING_RATE
     max_rate = MockConfig.MAX_LEARNING_RATE
-    
+
     xp_bonus = math.log1p(parent.education_xp) * sensitivity
     child_ai.base_alpha = min(max_rate, base_rate + xp_bonus)
-    
+
     expected_alpha = min(max_rate, base_rate + xp_bonus)
     assert child_ai.base_alpha == expected_alpha
diff --git a/tests/verify_monetary_integrity.py b/tests/verify_monetary_integrity.py
index 65388d8..7a7727b 100644
--- a/tests/verify_monetary_integrity.py
+++ b/tests/verify_monetary_integrity.py
@@ -1,6 +1,7 @@
 import sys
 import os
-sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
+
+sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
 
 import unittest
 from simulation.engine import Simulation
@@ -8,19 +9,24 @@ from simulation.core_agents import Household
 from simulation.models import RealEstateUnit, Transaction
 from simulation.systems.housing_system import HousingSystem
 import config
-from simulation.decisions.rule_based_household_engine import RuleBasedHouseholdDecisionEngine
+from simulation.decisions.rule_based_household_engine import (
+    RuleBasedHouseholdDecisionEngine,
+)
 from simulation.ai.enums import Personality
 
+
 class MockRepository:
     def save_simulation_run(self, *args, **kwargs):
         return 1
+
     def close(self):
         pass
+
     def update_simulation_run_end_time(self, run_id):
         pass
 
-class TestMonetaryIntegrity(unittest.TestCase):
 
+class TestMonetaryIntegrity(unittest.TestCase):
     def test_government_asset_sale(self):
         # 1. Setup
         buyer = Household(
@@ -32,7 +38,7 @@ class TestMonetaryIntegrity(unittest.TestCase):
             initial_needs={},
             decision_engine=RuleBasedHouseholdDecisionEngine(config, None),
             value_orientation="MAINSTREAM",
-            personality=Personality.BALANCED
+            personality=Personality.BALANCED,
         )
 
         sim = Simulation(
@@ -41,7 +47,7 @@ class TestMonetaryIntegrity(unittest.TestCase):
             ai_trainer=None,
             repository=MockRepository(),
             config_module=config,
-            goods_data=[]
+            goods_data=[],
         )
 
         gov = sim.government
@@ -62,7 +68,7 @@ class TestMonetaryIntegrity(unittest.TestCase):
             quantity=1.0,
             market_id="housing",
             transaction_type="housing",
-            time=sim.time
+            time=sim.time,
         )
 
         initial_money_destroyed = gov.total_money_destroyed
@@ -71,14 +77,29 @@ class TestMonetaryIntegrity(unittest.TestCase):
         housing_system.process_transaction(tx, sim)
 
         # 4. Assertions
-        self.assertEqual(buyer.assets, 200000 - sale_price, "Buyer's assets were not correctly deducted.")
+        self.assertEqual(
+            buyer.assets,
+            200000 - sale_price,
+            "Buyer's assets were not correctly deducted.",
+        )
 
         expected_money_destroyed = initial_money_destroyed + sale_price
-        self.assertEqual(gov.total_money_destroyed, expected_money_destroyed, "Government's total_money_destroyed was not updated correctly.")
+        self.assertEqual(
+            gov.total_money_destroyed,
+            expected_money_destroyed,
+            "Government's total_money_destroyed was not updated correctly.",
+        )
 
-        self.assertEqual(gov.assets, 0, "Government's assets should not increase from asset sales that destroy money.")
+        self.assertEqual(
+            gov.assets,
+            0,
+            "Government's assets should not increase from asset sales that destroy money.",
+        )
+
+        self.assertEqual(
+            property_unit.owner_id, buyer.id, "Property ownership was not transferred."
+        )
 
-        self.assertEqual(property_unit.owner_id, buyer.id, "Property ownership was not transferred.")
 
-if __name__ == '__main__':
+if __name__ == "__main__":
     unittest.main()
diff --git a/tests/verify_monetary_transmission.py b/tests/verify_monetary_transmission.py
index cac48e0..19d23c1 100644
--- a/tests/verify_monetary_transmission.py
+++ b/tests/verify_monetary_transmission.py
@@ -1,4 +1,3 @@
-
 import sys
 import os
 import random
@@ -20,18 +19,19 @@ CONSUMPTION_RECORD = {
     "ant": 0.0,
     "grasshopper": 0.0,
     "ant_count": 0,
-    "grasshopper_count": 0
+    "grasshopper_count": 0,
 }
 
 # Original consume method
 original_consume = Household.consume
 
+
 def patched_consume(self, item_id: str, quantity: float, current_time: int) -> None:
     # Call original
     original_consume(self, item_id, quantity, current_time)
 
     # Record
-    is_ant = (self.value_orientation == config.VALUE_ORIENTATION_WEALTH_AND_NEEDS)
+    is_ant = self.value_orientation == config.VALUE_ORIENTATION_WEALTH_AND_NEEDS
     if is_ant:
         CONSUMPTION_RECORD["ant"] += quantity
         CONSUMPTION_RECORD["ant_count"] += 1
@@ -39,9 +39,11 @@ def patched_consume(self, item_id: str, quantity: float, current_time: int) -> N
         CONSUMPTION_RECORD["grasshopper"] += quantity
         CONSUMPTION_RECORD["grasshopper_count"] += 1
 
+
 # Apply Patch
 Household.consume = patched_consume
 
+
 def run_scenario(interest_rate_override: float, label: str):
     print(f"\n--- Running Scenario: {label} (Rate: {interest_rate_override:.1%}) ---")
 
@@ -59,7 +61,7 @@ def run_scenario(interest_rate_override: float, label: str):
     overrides = {
         "INITIAL_BASE_ANNUAL_RATE": interest_rate_override,
         "TICKS_PER_YEAR": 100,
-        "BATCH_SAVE_INTERVAL": 1000, # Disable frequent DB saves for speed
+        "BATCH_SAVE_INTERVAL": 1000,  # Disable frequent DB saves for speed
         "STOCK_MARKET_ENABLED": False,
         "NUM_HOUSEHOLDS": 20,
         "NEUTRAL_REAL_RATE": 0.02,
@@ -79,7 +81,9 @@ def run_scenario(interest_rate_override: float, label: str):
     for h in sim.households:
         h.expected_inflation = {k: 0.0 for k in h.expected_inflation}
         h._assets = 10000.0
-        h.needs["survival"] = 20.0  # Force low survival need to enable interest sensitivity
+        h.needs["survival"] = (
+            20.0  # Force low survival need to enable interest sensitivity
+        )
 
     # Run for 50 ticks
     # We ignore the first few ticks to let market stabilize (production start)
@@ -91,7 +95,13 @@ def run_scenario(interest_rate_override: float, label: str):
     # We want Avg Consumption Per Agent Per Tick.
 
     # Count agents
-    ant_agents = len([h for h in sim.households if h.value_orientation == config.VALUE_ORIENTATION_WEALTH_AND_NEEDS])
+    ant_agents = len(
+        [
+            h
+            for h in sim.households
+            if h.value_orientation == config.VALUE_ORIENTATION_WEALTH_AND_NEEDS
+        ]
+    )
     gh_agents = len(sim.households) - ant_agents
 
     total_ant_consumption = CONSUMPTION_RECORD["ant"]
@@ -100,11 +110,14 @@ def run_scenario(interest_rate_override: float, label: str):
     avg_ant = (total_ant_consumption / ant_agents) / 50 if ant_agents > 0 else 0
     avg_gh = (total_gh_consumption / gh_agents) / 50 if gh_agents > 0 else 0
 
-    print(f"[{label}] Total Cons - Ant: {total_ant_consumption:.1f}, GH: {total_gh_consumption:.1f}")
+    print(
+        f"[{label}] Total Cons - Ant: {total_ant_consumption:.1f}, GH: {total_gh_consumption:.1f}"
+    )
     print(f"[{label}] Avg/Tick - Ant: {avg_ant:.4f}, GH: {avg_gh:.4f}")
 
     return avg_ant, avg_gh
 
+
 def main():
     # 1. Baseline: 2% (Neutral)
     ant_base, gh_base = run_scenario(0.02, "BASELINE")
@@ -139,7 +152,9 @@ def main():
     print(f"GH Reduction: {gh_reduction:.1%}")
 
     if ant_reduction > gh_reduction:
-        print("PASS: Ants (Wealth-Oriented) reduced consumption more than Grasshoppers.")
+        print(
+            "PASS: Ants (Wealth-Oriented) reduced consumption more than Grasshoppers."
+        )
     else:
         print("WARNING: Ants did not reduce more. Check if GH hit Debt Penalty?")
 
@@ -151,5 +166,6 @@ def main():
         print("FAILURE: Verification criteria not met.")
         sys.exit(1)
 
+
 if __name__ == "__main__":
     main()
diff --git a/tests/verify_multi_good_market.py b/tests/verify_multi_good_market.py
index 0fe04e8..02fb0ba 100644
--- a/tests/verify_multi_good_market.py
+++ b/tests/verify_multi_good_market.py
@@ -1,4 +1,3 @@
-
 import unittest
 import logging
 import random
@@ -11,13 +10,16 @@ from simulation.db.repository import SimulationRepository
 from simulation.ai_model import AIEngineRegistry
 from simulation.core_agents import Household, Talent
 from simulation.firms import Firm
-from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
+from simulation.decisions.ai_driven_household_engine import (
+    AIDrivenHouseholdDecisionEngine,
+)
 from simulation.decisions.ai_driven_firm_engine import AIDrivenFirmDecisionEngine
 from simulation.schemas import FirmActionVector, HouseholdActionVector
 from simulation.ai.firm_ai import FirmAI
 from simulation.ai.household_ai import HouseholdAI
 from simulation.ai.enums import Personality
 
+
 class TestMultiGoodMarket(unittest.TestCase):
     def setUp(self):
         self.db_path = "simulation_data.db"
@@ -26,7 +28,7 @@ class TestMultiGoodMarket(unittest.TestCase):
                 os.remove(self.db_path)
             except:
                 pass
-            
+
         self.repository = SimulationRepository()
         self.repository.clear_all_data()
 
@@ -52,17 +54,17 @@ class TestMultiGoodMarket(unittest.TestCase):
 
     def test_multi_good_dynamics(self):
         print("\n=== Market Test: Multi-good (Food & Clothing) ===")
-        
+
         logging.basicConfig(level=logging.ERROR)
         logger = logging.getLogger("TestMultiGood")
-        
+
         mock_action_proposal = MagicMock()
         mock_state_builder = MagicMock()
         ai_manager = AIEngineRegistry(
             action_proposal_engine=mock_action_proposal,
-            state_builder=mock_state_builder
+            state_builder=mock_state_builder,
         )
-        
+
         goods_list = []
         for id, info in config.GOODS.items():
             info["id"] = id
@@ -72,26 +74,28 @@ class TestMultiGoodMarket(unittest.TestCase):
         households = []
         for i in range(20):
             talent = Talent(base_learning_rate=0.1, max_potential={})
-            ai_engine = ai_manager.get_engine("needs_and_growth") 
+            ai_engine = ai_manager.get_engine("needs_and_growth")
             household_ai = HouseholdAI(agent_id=f"H{i}", ai_decision_engine=ai_engine)
-            decision_engine = AIDrivenHouseholdDecisionEngine(household_ai, config, logger)
-            
+            decision_engine = AIDrivenHouseholdDecisionEngine(
+                household_ai, config, logger
+            )
+
             h = Household(
                 id=i,
                 talent=talent,
                 goods_data=goods_list,
-                initial_assets=random.uniform(2000.0, 3000.0), 
+                initial_assets=random.uniform(2000.0, 3000.0),
                 initial_needs={
-                    "survival": random.uniform(10.0, 30.0), # Food need
-                    "social": random.uniform(5.0, 20.0), # Clothing need
+                    "survival": random.uniform(10.0, 30.0),  # Food need
+                    "social": random.uniform(5.0, 20.0),  # Clothing need
                     "asset": 10.0,
-                    "improvement": 10.0
+                    "improvement": 10.0,
                 },
                 decision_engine=decision_engine,
                 value_orientation="needs_and_growth",
                 personality=Personality.GROWTH_ORIENTED,
                 config_module=config,
-                logger=logger
+                logger=logger,
             )
             households.append(h)
 
@@ -102,40 +106,42 @@ class TestMultiGoodMarket(unittest.TestCase):
             ai_engine = ai_manager.get_engine("profit_maximizer")
             firm_ai = FirmAI(agent_id=str(firm_id), ai_decision_engine=ai_engine)
             decision_engine = AIDrivenFirmDecisionEngine(firm_ai, config, logger)
-            
+
             f = Firm(
                 id=firm_id,
                 initial_capital=random.uniform(10000.0, 15000.0),
                 initial_liquidity_need=100.0,
-                specialization="basic_food", 
+                specialization="basic_food",
                 productivity_factor=random.uniform(10.0, 15.0),
                 decision_engine=decision_engine,
                 value_orientation="profit_maximizer",
                 config_module=config,
-                logger=logger
+                logger=logger,
             )
-            f.inventory["basic_food"] = 50.0 
+            f.inventory["basic_food"] = 50.0
             firms.append(f)
-            
+
         # 2 Clothing Firms
         for i in range(2):
             firm_id = i + 23
             ai_engine = ai_manager.get_engine("profit_maximizer")
             firm_ai = FirmAI(agent_id=str(firm_id), ai_decision_engine=ai_engine)
             decision_engine = AIDrivenFirmDecisionEngine(firm_ai, config, logger)
-            
+
             f = Firm(
                 id=firm_id,
                 initial_capital=random.uniform(10000.0, 15000.0),
                 initial_liquidity_need=100.0,
-                specialization="clothing", 
-                productivity_factor=random.uniform(5.0, 8.0), # Lower productivity for clothing
+                specialization="clothing",
+                productivity_factor=random.uniform(
+                    5.0, 8.0
+                ),  # Lower productivity for clothing
                 decision_engine=decision_engine,
                 value_orientation="profit_maximizer",
                 config_module=config,
-                logger=logger
+                logger=logger,
             )
-            f.inventory["clothing"] = 20.0 
+            f.inventory["clothing"] = 20.0
             firms.append(f)
 
         sim = Simulation(
@@ -145,7 +151,7 @@ class TestMultiGoodMarket(unittest.TestCase):
             repository=self.repository,
             config_module=config,
             goods_data=goods_list,
-            logger=logger
+            logger=logger,
         )
 
         def noisy_firm_vector():
@@ -153,17 +159,23 @@ class TestMultiGoodMarket(unittest.TestCase):
             return FirmActionVector(0.5 + noise, 0.5 + noise, 0.5)
 
         def noisy_hh_vector(item_list):
-            consump_agg = {item: 0.5 + (random.random() - 0.5) * 0.1 for item in item_list}
+            consump_agg = {
+                item: 0.5 + (random.random() - 0.5) * 0.1 for item in item_list
+            }
             return HouseholdActionVector(consump_agg, 0.5, 0.0, 0.0)
 
         # Run Simulation Phase 1: Normal (1-15)
         print("Phase 1: Normal Operation (Tick 1-15)")
         for t in range(1, 16):
             for f in sim.firms:
-                f.decision_engine.ai_engine.decide_action_vector = MagicMock(return_value=noisy_firm_vector())
+                f.decision_engine.ai_engine.decide_action_vector = MagicMock(
+                    return_value=noisy_firm_vector()
+                )
             for h in sim.households:
-                h.decision_engine.ai_engine.decide_action_vector = MagicMock(side_effect=lambda *args, **kwargs: noisy_hh_vector(goods_list_ids))
-            
+                h.decision_engine.ai_engine.decide_action_vector = MagicMock(
+                    side_effect=lambda *args, **kwargs: noisy_hh_vector(goods_list_ids)
+                )
+
             goods_list_ids = [g["id"] for g in goods_list]
             sim.run_tick()
 
@@ -172,50 +184,72 @@ class TestMultiGoodMarket(unittest.TestCase):
         for t in range(16, 31):
             for f in sim.firms:
                 # Firms push prices up slightly as demand grows
-                f.decision_engine.ai_engine.decide_action_vector = MagicMock(return_value=FirmActionVector(0.2, 0.4, 0.5)) 
+                f.decision_engine.ai_engine.decide_action_vector = MagicMock(
+                    return_value=FirmActionVector(0.2, 0.4, 0.5)
+                )
             for h in sim.households:
                 # Force hunger and social need
-                h.needs["survival"] = min(100.0, h.needs.get("survival", 0.0) + 10.0 * (t - 15))
-                h.needs["social"] = min(100.0, h.needs.get("social", 0.0) + 5.0 * (t - 15))
-                
+                h.needs["survival"] = min(
+                    100.0, h.needs.get("survival", 0.0) + 10.0 * (t - 15)
+                )
+                h.needs["social"] = min(
+                    100.0, h.needs.get("social", 0.0) + 5.0 * (t - 15)
+                )
+
                 # High aggressiveness
-                h.decision_engine.ai_engine.decide_action_vector = MagicMock(side_effect=lambda *args, **kwargs: noisy_hh_vector(goods_list_ids))
-            
+                h.decision_engine.ai_engine.decide_action_vector = MagicMock(
+                    side_effect=lambda *args, **kwargs: noisy_hh_vector(goods_list_ids)
+                )
+
             sim.run_tick()
 
         # Analysis
         print("\n=== Market History Analysis ===")
         for item in ["basic_food", "clothing"]:
             print(f"\nItem: {item}")
-            self.repository.cursor.execute("""
+            self.repository.cursor.execute(
+                """
                 SELECT time, avg_price, trade_volume, avg_ask, avg_bid
                 FROM market_history 
                 WHERE item_id = ?
                 ORDER BY time ASC
-            """, (item,))
+            """,
+                (item,),
+            )
             rows = self.repository.cursor.fetchall()
-            
-            print(f"{'Tick':<4} | {'Price':<6} | {'Vol':<5} | {'AvgAsk':<6} | {'AvgBid':<6}")
+
+            print(
+                f"{'Tick':<4} | {'Price':<6} | {'Vol':<5} | {'AvgAsk':<6} | {'AvgBid':<6}"
+            )
             print("-" * 40)
-            for r in rows[:10]: # Show first 10
-                print(f"{r[0]:<4} | {r[1]:<6.2f} | {r[2]:<5.1f} | {r[3]:<6.1f} | {r[4]:<6.1f}")
+            for r in rows[:10]:  # Show first 10
+                print(
+                    f"{r[0]:<4} | {r[1]:<6.2f} | {r[2]:<5.1f} | {r[3]:<6.1f} | {r[4]:<6.1f}"
+                )
             print("...")
-            for r in rows[-5:]: # Show last 5
-                print(f"{r[0]:<4} | {r[1]:<6.2f} | {r[2]:<5.1f} | {r[3]:<6.1f} | {r[4]:<6.1f}")
+            for r in rows[-5:]:  # Show last 5
+                print(
+                    f"{r[0]:<4} | {r[1]:<6.2f} | {r[2]:<5.1f} | {r[3]:<6.1f} | {r[4]:<6.1f}"
+                )
 
         # Check Bulk Buying (Quantity > 1)
-        self.repository.cursor.execute("SELECT COUNT(*) FROM transactions WHERE quantity > 1")
+        self.repository.cursor.execute(
+            "SELECT COUNT(*) FROM transactions WHERE quantity > 1"
+        )
         bulk_count = self.repository.cursor.fetchone()[0]
         print(f"\nTransactions with Bulk Buying (>1 unit): {bulk_count}")
-        
+
         # Verify Indifference Curves: Check if households hold both items
         sample_h = sim.households[0]
         print(f"\nSample Household Inventory (H0): {sample_h.inventory}")
-        
+
         if len(sample_h.inventory) >= 2:
             print("SUCCESS: Households are consuming multiple goods.")
         else:
-            print("NOTICE: Household only has one type of good. Adjusting needs/prices might be needed.")
+            print(
+                "NOTICE: Household only has one type of good. Adjusting needs/prices might be needed."
+            )
+
 
 if __name__ == "__main__":
     unittest.main()
diff --git a/tests/verify_needs_fluctuation.py b/tests/verify_needs_fluctuation.py
index 407173e..1506569 100644
--- a/tests/verify_needs_fluctuation.py
+++ b/tests/verify_needs_fluctuation.py
@@ -10,6 +10,7 @@ from app import app, create_simulation
 from simulation.ai.api import Personality
 import config
 
+
 class TestNeedsFluctuation(unittest.TestCase):
     def setUp(self):
         # Configure logging
@@ -23,58 +24,67 @@ class TestNeedsFluctuation(unittest.TestCase):
         # Initialize simulation
         create_simulation()
         from app import simulation_instance
+
         self.simulation = simulation_instance
 
         # Force a household to have specific personality and state
         self.household = self.simulation.households[0]
         # Use a valid personality
         self.household.personality = Personality.MISER
-        self.household.needs['survival'] = 50.0
-        self.household.inventory['basic_food'] = 5.0 # Give food so they can consume
+        self.household.needs["survival"] = 50.0
+        self.household.inventory["basic_food"] = 5.0  # Give food so they can consume
 
         # Ensure utility effects are loaded (relying on my app.py fix)
         # We can check this
-        if 'utility_effects' not in self.household.goods_info_map.get('basic_food', {}):
-             print("WARNING: utility_effects missing in goods_info_map!")
+        if "utility_effects" not in self.household.goods_info_map.get("basic_food", {}):
+            print("WARNING: utility_effects missing in goods_info_map!")
 
     def tearDown(self):
         self.ctx.pop()
 
     def test_needs_increase_over_time(self):
         """Verify that needs increase over time (base growth) when not consuming."""
-        initial_survival = self.household.needs['survival']
+        initial_survival = self.household.needs["survival"]
 
         # Run 1 tick without consumption (force empty inventory to test growth only?
         # But I gave inventory above. Let's remove it for this test)
-        self.household.inventory['basic_food'] = 0.0
+        self.household.inventory["basic_food"] = 0.0
 
         self.simulation.run_tick()
 
-        new_survival = self.household.needs['survival']
+        new_survival = self.household.needs["survival"]
         # Expect increase: base_growth (1.0)
         expected_increase = config.BASE_DESIRE_GROWTH
 
         print(f"Initial Survival: {initial_survival}, New Survival: {new_survival}")
-        self.assertTrue(new_survival > initial_survival, "Survival need should increase")
-        self.assertAlmostEqual(new_survival, initial_survival + expected_increase, delta=0.1)
+        self.assertTrue(
+            new_survival > initial_survival, "Survival need should increase"
+        )
+        self.assertAlmostEqual(
+            new_survival, initial_survival + expected_increase, delta=0.1
+        )
 
     def test_consumption_reduces_needs(self):
         """Verify that consumption reduces needs."""
         # Set high need to trigger consumption
-        self.household.needs['survival'] = 80.0
-        self.household.inventory['basic_food'] = 5.0
+        self.household.needs["survival"] = 80.0
+        self.household.inventory["basic_food"] = 5.0
 
-        initial_survival = self.household.needs['survival']
+        initial_survival = self.household.needs["survival"]
 
         self.simulation.run_tick()
 
-        new_survival = self.household.needs['survival']
+        new_survival = self.household.needs["survival"]
         print(f"Initial Survival: {initial_survival}, New Survival: {new_survival}")
 
         # Utility of basic_food is 10 (survival). Base growth is 1.
         # Expected: 80 - 10 + 1 = 71.
         # Check if it decreased
-        self.assertTrue(new_survival < initial_survival, "Survival need should decrease after consumption")
+        self.assertTrue(
+            new_survival < initial_survival,
+            "Survival need should decrease after consumption",
+        )
+
 
-if __name__ == '__main__':
+if __name__ == "__main__":
     unittest.main()
diff --git a/tests/verify_population_dynamics.py b/tests/verify_population_dynamics.py
index 5247bb5..7d0aa5d 100644
--- a/tests/verify_population_dynamics.py
+++ b/tests/verify_population_dynamics.py
@@ -1,15 +1,17 @@
-
 import unittest
 from unittest.mock import MagicMock
 import logging
 from simulation.core_agents import Household
 from simulation.ai.household_ai import HouseholdAI
-from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
+from simulation.decisions.ai_driven_household_engine import (
+    AIDrivenHouseholdDecisionEngine,
+)
 from simulation.dtos import DecisionContext
 
 # Configure logging
 logging.basicConfig(level=logging.INFO)
 
+
 class TestPopulationDynamics(unittest.TestCase):
     def setUp(self):
         # Mock Config
@@ -19,10 +21,15 @@ class TestPopulationDynamics(unittest.TestCase):
         self.config_module.CHILDCARE_TIME_REQUIRED = 8.0
         self.config_module.HOUSEWORK_BASE_HOURS = 2.0
         self.config_module.EDUCATION_COST_MULTIPLIERS = {
-            0: 1.0, 1: 1.5, 2: 2.2, 3: 3.5, 4: 5.0, 5: 8.0
+            0: 1.0,
+            1: 1.5,
+            2: 2.2,
+            3: 3.5,
+            4: 5.0,
+            5: 8.0,
         }
         self.config_module.MASLOW_SURVIVAL_THRESHOLD = 50.0
-        self.config_module.GOODS = {} # Minimal goods
+        self.config_module.GOODS = {}  # Minimal goods
 
         # Setup AI Decision Engine Mock
         self.ai_decision_engine = MagicMock()
@@ -30,8 +37,7 @@ class TestPopulationDynamics(unittest.TestCase):
 
         # Setup AI Engine
         self.ai_engine = HouseholdAI(
-            agent_id="test_hh",
-            ai_decision_engine=self.ai_decision_engine
+            agent_id="test_hh", ai_decision_engine=self.ai_decision_engine
         )
 
     def test_time_constraint(self):
@@ -59,6 +65,7 @@ class TestPopulationDynamics(unittest.TestCase):
 
         # Force random to 0 for deterministic acceptance if probability > 0
         import random
+
         random.seed(42)
 
         # However, logic uses estimated work hours = 8.0 if employed.
@@ -84,7 +91,7 @@ class TestPopulationDynamics(unittest.TestCase):
         """
         Test that high education agent with low income rejects reproduction.
         """
-        self.config_module.CHILDCARE_TIME_REQUIRED = 8.0 # Reset
+        self.config_module.CHILDCARE_TIME_REQUIRED = 8.0  # Reset
 
         # Case: High Education (Level 5 -> Mult 8.0 -> Exp Wage 80.0)
         # Current Wage: 10.0 (Low)
@@ -98,16 +105,18 @@ class TestPopulationDynamics(unittest.TestCase):
             "is_employed": True,
             "current_wage": 10.0,
             "assets": 1000.0,
-            "education_level": 5, # High Expectation
-            "expected_wage": 80.0, # 10 * 8
+            "education_level": 5,  # High Expectation
+            "expected_wage": 80.0,  # 10 * 8
             "children_count": 0,
-            "social_rank": 0.8, # High Rank
+            "social_rank": 0.8,  # High Rank
             "needs": {"survival": 0.0},
         }
 
         # Mock random to ensure we capture the logic branch
         decision = self.ai_engine.decide_reproduction(agent_data, {}, 0)
-        self.assertFalse(decision, "Should reject due to expectation mismatch (High Edu, Low Wage)")
+        self.assertFalse(
+            decision, "Should reject due to expectation mismatch (High Edu, Low Wage)"
+        )
 
         # Contrast: Low Education (Level 0 -> Mult 1.0 -> Exp Wage 10.0)
         # Current Wage: 10.0
@@ -134,5 +143,6 @@ class TestPopulationDynamics(unittest.TestCase):
                 break
         self.assertTrue(success, "Should eventually reproduce if satisfied")
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     unittest.main()
diff --git a/tests/verify_real_estate_sales.py b/tests/verify_real_estate_sales.py
index a27a40a..13c3030 100644
--- a/tests/verify_real_estate_sales.py
+++ b/tests/verify_real_estate_sales.py
@@ -1,4 +1,3 @@
-
 import unittest
 from unittest.mock import MagicMock
 from simulation.core_agents import Household
@@ -11,11 +10,12 @@ from simulation.models import RealEstateUnit
 from simulation.ai.api import Personality
 import config
 
+
 class MockConfig:
     INITIAL_PROPERTY_VALUE = 10000.0
     INITIAL_RENT_PRICE = 50.0
     MAINTENANCE_RATE_PER_TICK = 0.001
-    MORTGAGE_INTEREST_RATE = 0.05 / 12 # Monthly
+    MORTGAGE_INTEREST_RATE = 0.05 / 12  # Monthly
     GOODS = {}
     SERVICE_SECTORS = []
     ADAPTATION_RATE_NORMAL = 0.05
@@ -37,22 +37,23 @@ class MockConfig:
     START_AGE = 20
     MAX_AGE = 100
     AGING_ENABLED = False
-    
+
+
 class TestRealEstateSales(unittest.TestCase):
     def setUp(self):
         self.config = MockConfig()
         mock_decision_engine = MagicMock()
-        
+
         self.agent = Household(
-            id=1, 
-            config_module=self.config, 
-            talent=0.5, 
+            id=1,
+            config_module=self.config,
+            talent=0.5,
             goods_data=[],
             initial_assets=1000.0,
             initial_needs={},
             decision_engine=mock_decision_engine,
             value_orientation="WEALTH",
-            personality=Personality.STATUS_SEEKER
+            personality=Personality.STATUS_SEEKER,
         )
         self.housing_manager = HousingManager(self.agent, self.config)
 
@@ -60,115 +61,159 @@ class TestRealEstateSales(unittest.TestCase):
         # Scenario: NPV is slightly negative for neutral agent, but Optimist sees as Positive
         # Prop Value = 10000, Appr = 0.2%
         # Rent = 40 (Cheap rent makes Buying less attractive)
-        
+
         prop_val = 10000
-        rent = 40 
-        
+        rent = 40
+
         # 1. Neutral (Optimism 0.0 -> 0.5 effectively in formula)
-        self.agent.optimism = 0.0 # Normalized range 0.0-1.0? 
-        # In code: base * (0.5 + optimism). 
+        self.agent.optimism = 0.0  # Normalized range 0.0-1.0?
+        # In code: base * (0.5 + optimism).
         # Wait, core_agents init: 0.5 + uniform.
         # Let's set explicit values.
-        self.agent.optimism = 0.0 # Very Pessimistic: multiplier 0.5
+        self.agent.optimism = 0.0  # Very Pessimistic: multiplier 0.5
         self.agent.ambition = 0.0
-        
+
         should_buy_pessimist = self.housing_manager.should_buy(prop_val, rent)
-        
+
         # 2. Maximum Optimist (Optimism 1.0 -> multiplier 1.5)
         self.agent.optimism = 1.0
         should_buy_optimist = self.housing_manager.should_buy(prop_val, rent)
-        
-        print(f"Pessimist Buy? {should_buy_pessimist} | Optimist Buy? {should_buy_optimist}")
-        
+
+        print(
+            f"Pessimist Buy? {should_buy_pessimist} | Optimist Buy? {should_buy_optimist}"
+        )
+
         # We expect Optimist to be MORE likely to buy.
         # If Pessimist False and Optimist True => Success logic test
         # If both False, rent is too cheap. If both True, rent is too high.
         # Adjusted Rent to find the sweet spot if needed, but relative comparison is key.
         if should_buy_pessimist == should_buy_optimist:
-             # Just verify that Net Buy Cost is lower for Optimist (Higher Future Value)
-             pass
+            # Just verify that Net Buy Cost is lower for Optimist (Higher Future Value)
+            pass
         else:
-             self.assertTrue(should_buy_optimist and not should_buy_pessimist, "Optimist should buy while Pessimist rents in marginal case")
+            self.assertTrue(
+                should_buy_optimist and not should_buy_pessimist,
+                "Optimist should buy while Pessimist rents in marginal case",
+            )
 
     def test_personality_bias_ambition(self):
         # Ambition adds Prestige Bonus (Negative Cost)
         prop_val = 10000
         rent = 40
-        
-        self.agent.optimism = 0.5 # Neutral
-        self.agent.ambition = 0.0 # No pride
+
+        self.agent.optimism = 0.5  # Neutral
+        self.agent.ambition = 0.0  # No pride
         decision_modest = self.housing_manager.should_buy(prop_val, rent)
-        
-        self.agent.ambition = 1.0 # High pride -> Big Prestige Bonus
+
+        self.agent.ambition = 1.0  # High pride -> Big Prestige Bonus
         decision_proud = self.housing_manager.should_buy(prop_val, rent)
-        
+
         print(f"Modest Buy? {decision_modest} | Proud Buy? {decision_proud}")
         # Proud agent subtracts (Val * 0.1) from Cost. Should be much more likely to buy.
-        
+
     def test_engine_transaction_execution(self):
         # 1. Setup Engine
         # Mocking arguments for Simulation
         mock_ai_trainer = MagicMock()
         mock_repo = MagicMock()
-        
+
         # Need real households to test interaction? Or mocks?
         # Real household needed for attributes like assets/id in transaction
         mock_talent = MagicMock()
         mock_talent.base_learning_rate = 0.5
         mock_talent.max_potential = {}
-        hh1 = Household(id=100, config_module=self.config, talent=mock_talent, goods_data={}, initial_assets=10000.0, initial_needs={"survival": 50.0, "asset": 50.0, "social": 50.0, "growth": 50.0, "leisure": 50.0, "self_actualization": 50.0, "improvement": 50.0}, decision_engine=MagicMock(), value_orientation="WEALTH", personality=Personality.STATUS_SEEKER)
-        
+        hh1 = Household(
+            id=100,
+            config_module=self.config,
+            talent=mock_talent,
+            goods_data={},
+            initial_assets=10000.0,
+            initial_needs={
+                "survival": 50.0,
+                "asset": 50.0,
+                "social": 50.0,
+                "growth": 50.0,
+                "leisure": 50.0,
+                "self_actualization": 50.0,
+                "improvement": 50.0,
+            },
+            decision_engine=MagicMock(),
+            value_orientation="WEALTH",
+            personality=Personality.STATUS_SEEKER,
+        )
+
         # Need at least one household
         households = [hh1]
         firms = []
-        
-        engine = Engine(households=households, firms=firms, ai_trainer=mock_ai_trainer, repository=mock_repo, config_module=config, goods_data={})
-        
+
+        engine = Engine(
+            households=households,
+            firms=firms,
+            ai_trainer=mock_ai_trainer,
+            repository=mock_repo,
+            config_module=config,
+            goods_data={},
+        )
+
         # 2. Setup Market and Orders
         engine.markets["housing"] = OrderBookMarket("housing")
-        
-        # Manually init real_estate_units as Engine.__init__ might do it if I passed config, 
+
+        # Manually init real_estate_units as Engine.__init__ might do it if I passed config,
         # But Engine.__init__ uses self.config_module.NUM_HOUSING_UNITS.
         # My MockConfig has it? No, need to check.
         # Let's manually inject units to be sure.
         unit0 = RealEstateUnit(id=0, estimated_value=10000.0, rent_price=50.0)
         engine.real_estate_units = [unit0]
-        
+
         # Seller: Government (Agent -1) selling Unit 0
         unit = engine.real_estate_units[0]
-        unit.owner_id = None # Gov owned
+        unit.owner_id = None  # Gov owned
         unit.estimated_value = 10000.0
-        
+
         # Mock Government ID in Engine
         # Engine initializes Government agent inside __init__.
         # We need to ensure engine.government exists and get its ID.
         # Since we initialized Engine with mock config, it creates a government agent.
         gov_id = engine.government.id
 
-        buy_order = Order(agent_id=engine.households[0].id, item_id="unit_0", price=10000.0, quantity=1, order_type="BUY", market_id="housing")
+        buy_order = Order(
+            agent_id=engine.households[0].id,
+            item_id="unit_0",
+            price=10000.0,
+            quantity=1,
+            order_type="BUY",
+            market_id="housing",
+        )
         # Use valid government ID for Sell Order
-        sell_order = Order(agent_id=gov_id, item_id="unit_0", price=10000.0, quantity=1, order_type="SELL", market_id="housing")
-        
+        sell_order = Order(
+            agent_id=gov_id,
+            item_id="unit_0",
+            price=10000.0,
+            quantity=1,
+            order_type="SELL",
+            market_id="housing",
+        )
+
         # Inject orders directly for matching simulation
         engine.markets["housing"].place_order(buy_order, 0)
         engine.markets["housing"].place_order(sell_order, 0)
-        
+
         # 3. Match Orders (returns Transaction DTOs)
         txs = engine.markets["housing"].match_orders(0)
         print(f"DEBUG: Transactions generated: {txs}")
-        
+
         # 4. Process Transactions (Logic we implemented)
         # Give buyer some assets but less than price to trigger Mortgage
         buyer = engine.households[0]
-        buyer._assets = 3000.0 # Needs 7000 Loan (LTV 70%)
+        buyer._assets = 3000.0  # Needs 7000 Loan (LTV 70%)
         # Note: Logic grants LTV 80% (8000). Max Loan.
         # Downpayment = 2000. Buyer has 3000. OK.
-        
+
         print(f"DEBUG: Bank Assets: {engine.bank.assets}")
         print(f"DEBUG: Config Bank Assets: {config.INITIAL_BANK_ASSETS}")
 
         engine._process_transactions(txs)
-        
+
         # 5. Assertions
         # Title Transfer
         self.assertEqual(unit.owner_id, buyer.id)
@@ -177,9 +222,10 @@ class TestRealEstateSales(unittest.TestCase):
         # Loan Check
         loan = engine.bank.loans[unit.mortgage_id]
         self.assertEqual(loan.borrower_id, buyer.id)
-        self.assertEqual(loan.principal, 8000.0) # 80% of 10000
-        
+        self.assertEqual(loan.principal, 8000.0)  # 80% of 10000
+
         print("Transaction & Mortgage Test Passed")
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     unittest.main()
diff --git a/tests/verify_service_market.py b/tests/verify_service_market.py
index f1ff0a3..82dac92 100644
--- a/tests/verify_service_market.py
+++ b/tests/verify_service_market.py
@@ -1,4 +1,3 @@
-
 import unittest
 from unittest.mock import MagicMock
 import logging
@@ -14,6 +13,7 @@ from simulation.schemas import FirmActionVector
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger("TestServiceMarket")
 
+
 class TestServiceMarket(unittest.TestCase):
     def setUp(self):
         self.config = config
@@ -24,13 +24,14 @@ class TestServiceMarket(unittest.TestCase):
         self.ai_engine = MagicMock(spec=AIDecisionEngine)
         self.ai_engine.config_module = self.config
         self.ai_engine.action_selector = MagicMock()
-        self.ai_engine.action_selector.choose_action.return_value = 2 # Neutral action
+        self.ai_engine.action_selector.choose_action.return_value = 2  # Neutral action
 
         self.service_ai = ServiceFirmAI(
-            agent_id="firm_1",
-            ai_decision_engine=self.ai_engine
+            agent_id="firm_1", ai_decision_engine=self.ai_engine
+        )
+        self.decision_engine = AIDrivenFirmDecisionEngine(
+            self.service_ai, self.config, logger
         )
-        self.decision_engine = AIDrivenFirmDecisionEngine(self.service_ai, self.config, logger)
         self.decision_engine.loan_market = MagicMock()
 
         self.firm = ServiceFirm(
@@ -42,7 +43,7 @@ class TestServiceMarket(unittest.TestCase):
             decision_engine=self.decision_engine,
             value_orientation="growth",
             config_module=self.config,
-            logger=logger
+            logger=logger,
         )
 
     def test_perishability(self):
@@ -70,14 +71,16 @@ class TestServiceMarket(unittest.TestCase):
         self.assertNotEqual(initial_capacity, new_capacity)
         self.assertEqual(self.firm.inventory["service.education"], new_capacity)
 
-        logger.info(f"Perishability Test Passed: Waste={self.firm.waste_this_tick}, New Cap={new_capacity}")
+        logger.info(
+            f"Perishability Test Passed: Waste={self.firm.waste_this_tick}, New Cap={new_capacity}"
+        )
 
     def test_ai_utilization_state(self):
         """Verify AI receives utilization-based state."""
         # Setup state
         self.firm.capacity_this_tick = 100.0
-        self.firm.sales_volume_this_tick = 80.0 # 80% Utilization -> Healthy (Idx 1)
-        self.firm.expenses_this_tick = 50.0 # Cost
+        self.firm.sales_volume_this_tick = 80.0  # 80% Utilization -> Healthy (Idx 1)
+        self.firm.expenses_this_tick = 50.0  # Cost
         self.firm._assets = 1000.0
 
         # Create dummy market data
@@ -103,14 +106,14 @@ class TestServiceMarket(unittest.TestCase):
         self.assertEqual(util_idx, 1)
 
         # Test Low Utilization
-        agent_data["sales_volume_this_tick"] = 10.0 # 10%
+        agent_data["sales_volume_this_tick"] = 10.0  # 10%
         state_low = self.service_ai._get_common_state(agent_data, market_data)
-        self.assertEqual(state_low[0], 0) # Idx 0 (< 0.5)
+        self.assertEqual(state_low[0], 0)  # Idx 0 (< 0.5)
 
         # Test High Utilization
-        agent_data["sales_volume_this_tick"] = 95.0 # 95%
+        agent_data["sales_volume_this_tick"] = 95.0  # 95%
         state_high = self.service_ai._get_common_state(agent_data, market_data)
-        self.assertEqual(state_high[0], 2) # Idx 2 (>= 0.9)
+        self.assertEqual(state_high[0], 2)  # Idx 2 (>= 0.9)
 
         logger.info("AI Utilization State Test Passed")
 
@@ -118,10 +121,10 @@ class TestServiceMarket(unittest.TestCase):
         """Verify waste penalty is applied to reward."""
         # Setup
         self.firm.capacity_this_tick = 100.0
-        self.firm.waste_this_tick = 20.0 # 20% Waste
-        self.firm.expenses_this_tick = 100.0 # Unit Cost = 1.0
-        self.firm.revenue_this_turn = 80.0 # Sold 80 @ 1.0 (Profit -20)
-        self.firm._assets = 1000.0 # Dummy
+        self.firm.waste_this_tick = 20.0  # 20% Waste
+        self.firm.expenses_this_tick = 100.0  # Unit Cost = 1.0
+        self.firm.revenue_this_turn = 80.0  # Sold 80 @ 1.0 (Profit -20)
+        self.firm._assets = 1000.0  # Dummy
 
         # Unit Cost = 100 / 100 = 1.0
         # Waste Penalty = 20 * 1.0 * 0.5 = 10.0
@@ -131,8 +134,12 @@ class TestServiceMarket(unittest.TestCase):
         # Base Reward ~ -20.
         # Total Reward = -20 - 10 = -30.
 
-        prev_state = {"assets": 1020.0} # Started with 1020, lost 20 -> 1000
-        curr_state = {"assets": 1000.0, "revenue_this_turn": 80.0, "capacity_this_tick": 100.0}
+        prev_state = {"assets": 1020.0}  # Started with 1020, lost 20 -> 1000
+        curr_state = {
+            "assets": 1000.0,
+            "revenue_this_turn": 80.0,
+            "capacity_this_tick": 100.0,
+        }
 
         reward = self.service_ai.calculate_reward(self.firm, prev_state, curr_state)
 
@@ -154,19 +161,25 @@ class TestServiceMarket(unittest.TestCase):
 
         # 1. Force High Utilization State
         self.firm.capacity_this_tick = 100.0
-        self.firm.sales_volume_this_tick = 95.0 # 95% -> Over-utilized
+        self.firm.sales_volume_this_tick = 95.0  # 95% -> Over-utilized
 
         # 2. Mock Action Selector to choose 'High Aggressiveness' (Index 4 -> 1.0)
         # q_hiring uses action_selector
-        self.ai_engine.action_selector.choose_action.return_value = 4 # 1.0 Aggressiveness
+        self.ai_engine.action_selector.choose_action.return_value = (
+            4  # 1.0 Aggressiveness
+        )
 
         # 3. Call make_decision
         market_data = {
-            "debt_data": {"firm_1": {"total_principal": 0.0, "daily_interest_burden": 0.0}},
-            "goods_market": {}
+            "debt_data": {
+                "firm_1": {"total_principal": 0.0, "daily_interest_burden": 0.0}
+            },
+            "goods_market": {},
         }
 
-        vector = self.service_ai.decide_action_vector(self.firm.get_agent_data(), market_data)
+        vector = self.service_ai.decide_action_vector(
+            self.firm.get_agent_data(), market_data
+        )
 
         # Check Hiring Aggressiveness
         self.assertEqual(vector.hiring_aggressiveness, 1.0)
@@ -177,28 +190,37 @@ class TestServiceMarket(unittest.TestCase):
         # The prompt asks: "Verify AI Adaptation".
         # If AI outputs "Hire Aggressiveness 1.0" when "Over-utilized", it IS adapting.
 
-        logger.info(f"Adaptation Test 1 (Over-utilization): Hiring Aggressiveness = {vector.hiring_aggressiveness} (Expected 1.0)")
+        logger.info(
+            f"Adaptation Test 1 (Over-utilization): Hiring Aggressiveness = {vector.hiring_aggressiveness} (Expected 1.0)"
+        )
 
         # Scenario 2: Under-utilization (Idx 0) -> Should CONTRACT (Low Hiring/Capital Aggressiveness)
 
         # 1. Force Low Utilization State
         self.firm.capacity_this_tick = 100.0
-        self.firm.sales_volume_this_tick = 10.0 # 10% -> Under-utilized
+        self.firm.sales_volume_this_tick = 10.0  # 10% -> Under-utilized
 
         # 2. Mock Action Selector to choose 'Low Aggressiveness' (Index 0 -> 0.0)
-        self.ai_engine.action_selector.choose_action.return_value = 0 # 0.0 Aggressiveness
+        self.ai_engine.action_selector.choose_action.return_value = (
+            0  # 0.0 Aggressiveness
+        )
 
         # 3. Call make_decision
-        vector_low = self.service_ai.decide_action_vector(self.firm.get_agent_data(), market_data)
+        vector_low = self.service_ai.decide_action_vector(
+            self.firm.get_agent_data(), market_data
+        )
 
         # Check Hiring Aggressiveness
         self.assertEqual(vector_low.hiring_aggressiveness, 0.0)
 
-        logger.info(f"Adaptation Test 2 (Under-utilization): Hiring Aggressiveness = {vector_low.hiring_aggressiveness} (Expected 0.0)")
+        logger.info(
+            f"Adaptation Test 2 (Under-utilization): Hiring Aggressiveness = {vector_low.hiring_aggressiveness} (Expected 0.0)"
+        )
 
         # Verify CorporateManager interprets 0.0 as "Fire" or "Do Nothing"?
         # CorporateManager logic: if aggressiveness < 0.2 -> Fire?
         # Let's assume standard behavior. The verification is that AI outputs correct signal.
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     unittest.main()
diff --git a/tests/verify_socio_tech_logic.py b/tests/verify_socio_tech_logic.py
index d1c6c49..888c172 100644
--- a/tests/verify_socio_tech_logic.py
+++ b/tests/verify_socio_tech_logic.py
@@ -3,11 +3,13 @@ from unittest.mock import MagicMock
 from simulation.ai.household_ai import HouseholdAI
 from simulation.ai.api import BaseAIEngine
 
+
 # Mock Config
 class MockConfig:
     HOUSEWORK_BASE_HOURS = 6.0
     FORMULA_TECH_LEVEL = 0.0
 
+
 class TestHouseholdAI_TimeAllocation(unittest.TestCase):
     def setUp(self):
         self.ai = HouseholdAI("test_agent", None)
@@ -17,7 +19,9 @@ class TestHouseholdAI_TimeAllocation(unittest.TestCase):
 
     def test_single_male_no_infant(self):
         agent_data = {"gender": "M", "home_quality_score": 1.0}
-        allocation = self.ai.decide_time_allocation(agent_data, config_module=MockConfig())
+        allocation = self.ai.decide_time_allocation(
+            agent_data, config_module=MockConfig()
+        )
 
         # Expect full housework (6.0), no childcare
         self.assertEqual(allocation["housework"], 6.0)
@@ -27,7 +31,7 @@ class TestHouseholdAI_TimeAllocation(unittest.TestCase):
         MockConfig.FORMULA_TECH_LEVEL = 0.0
         agent_data = {"gender": "F", "home_quality_score": 1.0}
         spouse_data = {"id": "spouse"}
-        children_data = [{"age": 1}] # Infant
+        children_data = [{"age": 1}]  # Infant
 
         allocation = self.ai.decide_time_allocation(
             agent_data, spouse_data, children_data, config_module=MockConfig()
@@ -66,12 +70,18 @@ class TestHouseholdAI_TimeAllocation(unittest.TestCase):
         self.assertEqual(allocation["childcare"], 4.0)
 
     def test_appliance_benefit(self):
-        agent_data = {"gender": "F", "home_quality_score": 1.5} # High Quality -> Appliances
+        agent_data = {
+            "gender": "F",
+            "home_quality_score": 1.5,
+        }  # High Quality -> Appliances
 
-        allocation = self.ai.decide_time_allocation(agent_data, config_module=MockConfig())
+        allocation = self.ai.decide_time_allocation(
+            agent_data, config_module=MockConfig()
+        )
 
         # Base 6.0 * 0.5 = 3.0
         self.assertEqual(allocation["housework"], 3.0)
 
+
 if __name__ == "__main__":
     unittest.main()
diff --git a/tests/verify_step1.py b/tests/verify_step1.py
index f0dce29..e477aae 100644
--- a/tests/verify_step1.py
+++ b/tests/verify_step1.py
@@ -5,6 +5,7 @@ from simulation.ai.api import Personality
 from simulation.decisions.base_decision_engine import BaseDecisionEngine
 import config
 
+
 class TestStep1Foundation(unittest.TestCase):
     def setUp(self):
         self.mock_decision_engine = MagicMock(spec=BaseDecisionEngine)
@@ -20,7 +21,7 @@ class TestStep1Foundation(unittest.TestCase):
             decision_engine=self.mock_decision_engine,
             value_orientation="wealth_and_needs",
             personality=Personality.CONSERVATIVE,
-            config_module=config
+            config_module=config,
         )
 
     def test_household_attributes(self):
@@ -29,7 +30,7 @@ class TestStep1Foundation(unittest.TestCase):
         self.assertIn(self.agent.gender, ["M", "F"])
 
         print(f"Spouse ID: {self.agent.spouse_id}")
-        self.assertIsNone(self.agent.spouse_id) # Should be None initially
+        self.assertIsNone(self.agent.spouse_id)  # Should be None initially
 
         print(f"Home Quality Score: {self.agent.home_quality_score}")
         self.assertEqual(self.agent.home_quality_score, 1.0)
@@ -39,11 +40,7 @@ class TestStep1Foundation(unittest.TestCase):
 
     def test_system2_planner_execution(self):
         print("Testing System2 Planner Execution...")
-        market_data = {
-            "goods_market": {
-                "basic_food_current_sell_price": 5.0
-            }
-        }
+        market_data = {"goods_market": {"basic_food_current_sell_price": 5.0}}
         # Run projection
         result = self.agent.system2_planner.project_future(100, market_data)
 
@@ -57,5 +54,6 @@ class TestStep1Foundation(unittest.TestCase):
         # NPV should be > 1000.
         self.assertGreater(result["npv_wealth"], 1000.0)
 
+
 if __name__ == "__main__":
     unittest.main()
diff --git a/tests/verify_stock_trading.py b/tests/verify_stock_trading.py
index a7e6a8e..970b6ab 100644
--- a/tests/verify_stock_trading.py
+++ b/tests/verify_stock_trading.py
@@ -20,7 +20,9 @@ from simulation.ai_model import AIEngineRegistry
 from simulation.ai.state_builder import StateBuilder
 from simulation.decisions.action_proposal import ActionProposalEngine
 from simulation.decisions.ai_driven_firm_engine import AIDrivenFirmDecisionEngine
-from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
+from simulation.decisions.ai_driven_household_engine import (
+    AIDrivenHouseholdDecisionEngine,
+)
 from simulation.ai.api import Personality
 from simulation.ai.household_ai import HouseholdAI
 from simulation.ai.firm_ai import FirmAI
@@ -28,13 +30,13 @@ from simulation.db.repository import SimulationRepository
 from simulation.models import StockOrder
 
 # Setup logging
-logging.basicConfig(level=logging.INFO, format='%(name)s:%(message)s')
+logging.basicConfig(level=logging.INFO, format="%(name)s:%(message)s")
 logger = logging.getLogger("TestStock")
 
 
 class TestStockTradingIntegration(unittest.TestCase):
     """ì£¼ì‹ ê±°ë˜ í†µí•© í…ŒìŠ¤íŠ¸"""
-    
+
     def setUp(self):
         """í…ŒìŠ¤íŠ¸ í™˜ê²½ ì„¤ì •"""
         self.repository = SimulationRepository()
@@ -42,19 +44,19 @@ class TestStockTradingIntegration(unittest.TestCase):
         self.action_proposal_engine = ActionProposalEngine(config_module=config)
         self.ai_trainer = AIEngineRegistry(
             action_proposal_engine=self.action_proposal_engine,
-            state_builder=self.state_builder
+            state_builder=self.state_builder,
         )
-        
+
         # ì£¼ì‹ ì‹œì¥ í™œì„±í™” í™•ì¸
         self.assertTrue(
             getattr(config, "STOCK_MARKET_ENABLED", False),
-            "STOCK_MARKET_ENABLED must be True for this test"
+            "STOCK_MARKET_ENABLED must be True for this test",
         )
-    
+
     def tearDown(self):
         """í…ŒìŠ¤íŠ¸ ì •ë¦¬"""
         self.repository.close()
-    
+
     def _create_household(self, id: int, assets: float):
         """í…ŒìŠ¤íŠ¸ìš© ê°€ê³„ ìƒì„±"""
         value_orientation = "wealth_and_needs"
@@ -63,13 +65,18 @@ class TestStockTradingIntegration(unittest.TestCase):
         decision_engine = AIDrivenHouseholdDecisionEngine(
             ai_engine=household_ai, config_module=config
         )
-        
+
         household = Household(
             id=id,
             talent=Talent(1.0, {}),
             goods_data=[{"id": "basic_food", "utility_effects": {"survival": 10.0}}],
             initial_assets=assets,
-            initial_needs={"survival": 30.0, "social": 20.0, "improvement": 10.0, "asset": 10.0},
+            initial_needs={
+                "survival": 30.0,
+                "social": 20.0,
+                "improvement": 10.0,
+                "asset": 10.0,
+            },
             decision_engine=decision_engine,
             value_orientation=value_orientation,
             personality=Personality.MISER,
@@ -78,7 +85,7 @@ class TestStockTradingIntegration(unittest.TestCase):
         )
         household.inventory["basic_food"] = 10.0
         return household
-    
+
     def _create_firm(self, id: int, assets: float):
         """í…ŒìŠ¤íŠ¸ìš© ê¸°ì—… ìƒì„±"""
         value_orientation = "profit_maximizer"
@@ -87,7 +94,7 @@ class TestStockTradingIntegration(unittest.TestCase):
         decision_engine = AIDrivenFirmDecisionEngine(
             ai_engine=firm_ai, config_module=config
         )
-        
+
         firm = Firm(
             id=id,
             initial_capital=assets,
@@ -101,18 +108,18 @@ class TestStockTradingIntegration(unittest.TestCase):
         )
         firm.inventory["basic_food"] = 100.0
         return firm
-    
+
     def test_stock_market_initialized(self):
         """ì£¼ì‹ ì‹œì¥ì´ ì´ˆê¸°í™”ë˜ëŠ”ì§€ í™•ì¸"""
         households = [self._create_household(i, 1000.0) for i in range(5)]
         firms = [self._create_firm(10 + i, 10000.0) for i in range(2)]
-        
+
         # ì´ˆê¸° ì£¼ì‹ ë¶„ë°°
         for firm in firms:
             shares_per_household = firm.total_shares / len(households)
             for household in households:
                 household.shares_owned[firm.id] = shares_per_household
-        
+
         sim = Simulation(
             households=households,
             firms=firms,
@@ -122,18 +129,20 @@ class TestStockTradingIntegration(unittest.TestCase):
             goods_data=[{"id": "basic_food", "utility_effects": {"survival": 10.0}}],
             logger=logger,
         )
-        
+
         # ì£¼ì‹ ì‹œì¥ ì¡´ì¬ í™•ì¸
         self.assertIsNotNone(sim.stock_market, "Stock market should be initialized")
-        self.assertIn("stock_market", sim.markets, "Stock market should be in markets dict")
-        
+        self.assertIn(
+            "stock_market", sim.markets, "Stock market should be in markets dict"
+        )
+
         logger.info("âœ“ Stock market initialized successfully")
-    
+
     def test_stock_reference_prices_updated(self):
         """ê¸°ì—… ê¸°ì¤€ê°€ê°€ ì—…ë°ì´íŠ¸ë˜ëŠ”ì§€ í™•ì¸"""
         households = [self._create_household(i, 1000.0) for i in range(3)]
         firms = [self._create_firm(10, 10000.0)]
-        
+
         sim = Simulation(
             households=households,
             firms=firms,
@@ -143,27 +152,27 @@ class TestStockTradingIntegration(unittest.TestCase):
             goods_data=[{"id": "basic_food", "utility_effects": {"survival": 10.0}}],
             logger=logger,
         )
-        
+
         # 1í‹± ì‹¤í–‰
         sim.run_tick()
-        
+
         # ê¸°ì¤€ê°€ í™•ì¸
         self.assertIn(10, sim.stock_market.reference_prices)
         ref_price = sim.stock_market.reference_prices[10]
         self.assertGreater(ref_price, 0, "Reference price should be positive")
-        
+
         logger.info(f"âœ“ Reference price for firm 10: {ref_price:.2f}")
-    
+
     def test_stock_order_placement(self):
         """ì£¼ì‹ ì£¼ë¬¸ì´ ì œì¶œë˜ëŠ”ì§€ í™•ì¸"""
         # ìì‚°ì´ ì¶©ë¶„í•œ ê°€ê³„ ìƒì„±
         households = [self._create_household(i, 2000.0) for i in range(5)]
         firms = [self._create_firm(10, 10000.0)]
-        
+
         # ì´ˆê¸° ì£¼ì‹ ë¶„ë°°
         for household in households:
             household.shares_owned[10] = 20.0
-        
+
         sim = Simulation(
             households=households,
             firms=firms,
@@ -173,56 +182,62 @@ class TestStockTradingIntegration(unittest.TestCase):
             goods_data=[{"id": "basic_food", "utility_effects": {"survival": 10.0}}],
             logger=logger,
         )
-        
+
         # ì—¬ëŸ¬ í‹± ì‹¤í–‰í•˜ì—¬ ì£¼ì‹ ì£¼ë¬¸ ë°œìƒ í™•ì¸
         stock_orders_placed = False
         for _ in range(10):
             sim.run_tick()
-            
+
             # ì²´ê²°ë˜ì§€ ì•Šì€ ì£¼ë¬¸ í™•ì¸
-            total_orders = sum(len(orders) for orders in sim.stock_market.buy_orders.values())
-            total_orders += sum(len(orders) for orders in sim.stock_market.sell_orders.values())
-            
+            total_orders = sum(
+                len(orders) for orders in sim.stock_market.buy_orders.values()
+            )
+            total_orders += sum(
+                len(orders) for orders in sim.stock_market.sell_orders.values()
+            )
+
             if total_orders > 0:
                 stock_orders_placed = True
                 break
-        
+
         # ì£¼ì‹ ê±°ë˜ê°€ ë°œìƒí–ˆëŠ”ì§€ í™•ì¸ (ê±°ë˜ëŸ‰ìœ¼ë¡œ ì²´í¬)
         total_volume = sum(sim.stock_market.daily_volumes.values())
-        
+
         logger.info(f"Total stock orders: {total_orders}, Total volume: {total_volume}")
-        
+
         # ì°¸ê³ : ì£¼ì‹ ê±°ë˜ëŠ” í™•ë¥ ì ì´ë¯€ë¡œ í•­ìƒ ë°œìƒí•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŒ
         # ëŒ€ì‹  ì‹œìŠ¤í…œì´ ì—ëŸ¬ ì—†ì´ ë™ì‘í•˜ëŠ”ì§€ í™•ì¸
         logger.info("âœ“ Stock trading system operational (no errors)")
-    
+
     def test_firm_book_value_calculation(self):
         """ê¸°ì—… ì£¼ë‹¹ ìˆœìì‚°ê°€ì¹˜ ê³„ì‚° í™•ì¸"""
         firm = self._create_firm(10, 10000.0)
-        
+
         # ê¸°ë³¸ê°’: total_shares = 100, assets = 10000
         bps = firm.get_book_value_per_share()
         expected_bps = 10000.0 / 100.0  # = 100.0
-        
+
         self.assertAlmostEqual(bps, expected_bps, places=2)
         logger.info(f"âœ“ Book value per share: {bps:.2f}")
-    
+
     def test_firm_market_cap_calculation(self):
         """ê¸°ì—… ì‹œê°€ì´ì•¡ ê³„ì‚° í™•ì¸"""
         firm = self._create_firm(10, 10000.0)
-        
+
         # ì£¼ê°€ ì—†ì´ ê³„ì‚° (BPS ì‚¬ìš©)
         market_cap = firm.get_market_cap()
         expected = 100.0 * 100.0  # total_shares * BPS = 10000
-        
+
         self.assertAlmostEqual(market_cap, expected, places=2)
-        
+
         # ì£¼ê°€ë¡œ ê³„ì‚°
         market_cap_with_price = firm.get_market_cap(stock_price=150.0)
         expected_with_price = 100.0 * 150.0  # = 15000
-        
+
         self.assertAlmostEqual(market_cap_with_price, expected_with_price, places=2)
-        logger.info(f"âœ“ Market cap: {market_cap:.2f}, with price 150: {market_cap_with_price:.2f}")
+        logger.info(
+            f"âœ“ Market cap: {market_cap:.2f}, with price 150: {market_cap_with_price:.2f}"
+        )
 
 
 if __name__ == "__main__":
diff --git a/tests/verify_supply_shock.py b/tests/verify_supply_shock.py
index 8ccdfca..5985074 100644
--- a/tests/verify_supply_shock.py
+++ b/tests/verify_supply_shock.py
@@ -1,4 +1,3 @@
-
 import unittest
 import logging
 import random
@@ -11,23 +10,26 @@ from simulation.db.repository import SimulationRepository
 from simulation.ai_model import AIEngineRegistry
 from simulation.core_agents import Household, Talent
 from simulation.firms import Firm
-from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
+from simulation.decisions.ai_driven_household_engine import (
+    AIDrivenHouseholdDecisionEngine,
+)
 from simulation.decisions.ai_driven_firm_engine import AIDrivenFirmDecisionEngine
 from simulation.schemas import FirmActionVector, HouseholdActionVector
 from simulation.ai.firm_ai import FirmAI
 from simulation.ai.household_ai import HouseholdAI
 from simulation.ai.enums import Personality
 
+
 class TestSupplyShock(unittest.TestCase):
     def setUp(self):
         # Use a real file for the test DB
-        self.db_path = "simulation_data.db" # Default name used by DatabaseManager
+        self.db_path = "simulation_data.db"  # Default name used by DatabaseManager
         if os.path.exists(self.db_path):
             try:
                 os.remove(self.db_path)
             except:
                 pass
-            
+
         self.repository = SimulationRepository()
         self.repository.clear_all_data()
 
@@ -57,22 +59,24 @@ class TestSupplyShock(unittest.TestCase):
 
     def test_supply_shock_response(self):
         print("\n=== Market Shock Test: Supply Collapse ===")
-        
-        logging.basicConfig(level=logging.ERROR) # Only Errors for console to keep it clean
+
+        logging.basicConfig(
+            level=logging.ERROR
+        )  # Only Errors for console to keep it clean
         logger = logging.getLogger("TestSupplyShock")
-        
+
         # Repository is already initialized in setUp
-        
+
         # Mocks for AI Registry dependencies
         mock_action_proposal = MagicMock()
         mock_state_builder = MagicMock()
-        
+
         # AI Registry
         ai_manager = AIEngineRegistry(
             action_proposal_engine=mock_action_proposal,
-            state_builder=mock_state_builder
+            state_builder=mock_state_builder,
         )
-        
+
         # Goods Data
         goods_list = []
         for id, info in config.GOODS.items():
@@ -81,51 +85,53 @@ class TestSupplyShock(unittest.TestCase):
 
         # 1. Create Agents with Diversity
         households = []
-        for i in range(20): # 20 Households
+        for i in range(20):  # 20 Households
             talent = Talent(base_learning_rate=0.1, max_potential={})
-            ai_engine = ai_manager.get_engine("needs_and_growth") 
+            ai_engine = ai_manager.get_engine("needs_and_growth")
             household_ai = HouseholdAI(agent_id=f"H{i}", ai_decision_engine=ai_engine)
-            decision_engine = AIDrivenHouseholdDecisionEngine(household_ai, config, logger)
-            
+            decision_engine = AIDrivenHouseholdDecisionEngine(
+                household_ai, config, logger
+            )
+
             # Diverse initial states
             h = Household(
                 id=i,
                 talent=talent,
                 goods_data=goods_list,
-                initial_assets=random.uniform(800.0, 1200.0), 
+                initial_assets=random.uniform(800.0, 1200.0),
                 initial_needs={
                     "survival": random.uniform(40.0, 60.0),
                     "asset": 10.0,
                     "social": 10.0,
-                    "improvement": 10.0
+                    "improvement": 10.0,
                 },
                 decision_engine=decision_engine,
                 value_orientation="needs_and_growth",
                 personality=Personality.GROWTH_ORIENTED,
                 config_module=config,
-                logger=logger
+                logger=logger,
             )
             households.append(h)
 
         firms = []
-        for i in range(5): # 5 Firms
+        for i in range(5):  # 5 Firms
             ai_engine = ai_manager.get_engine("profit_maximizer")
             firm_ai = FirmAI(agent_id=str(i + 20), ai_decision_engine=ai_engine)
             decision_engine = AIDrivenFirmDecisionEngine(firm_ai, config, logger)
-            
+
             f = Firm(
                 id=i + 20,
                 initial_capital=random.uniform(8000.0, 12000.0),
                 initial_liquidity_need=100.0,
-                specialization="basic_food", 
+                specialization="basic_food",
                 productivity_factor=random.uniform(8.0, 12.0),
                 decision_engine=decision_engine,
                 value_orientation="profit_maximizer",
                 config_module=config,
-                logger=logger
+                logger=logger,
             )
-            f.inventory["basic_food"] = random.uniform(10.0, 20.0) 
-            f.production_target = 100.0 
+            f.inventory["basic_food"] = random.uniform(10.0, 20.0)
+            f.production_target = 100.0
             firms.append(f)
 
         # 2. Initialize Simulation
@@ -136,54 +142,70 @@ class TestSupplyShock(unittest.TestCase):
             repository=self.repository,
             config_module=config,
             goods_data=goods_list,
-            logger=logger
+            logger=logger,
         )
 
         # Helper: Create noisy action vectors
         def noisy_firm_vector(base_agg_sell, base_agg_hire):
-            noise = (random.random() - 0.5) * 0.1 # +/- 0.05 noise
-            return FirmActionVector(max(0, min(1, base_agg_sell + noise)), max(0, min(1, base_agg_hire + noise)), 0.5)
+            noise = (random.random() - 0.5) * 0.1  # +/- 0.05 noise
+            return FirmActionVector(
+                max(0, min(1, base_agg_sell + noise)),
+                max(0, min(1, base_agg_hire + noise)),
+                0.5,
+            )
 
         def noisy_hh_vector(base_consumption_agg, item_id="basic_food"):
             noise = (random.random() - 0.5) * 0.1
-            return HouseholdActionVector({item_id: max(0, min(1, base_consumption_agg + noise))}, 0.5, 0.0, 0.0)
+            return HouseholdActionVector(
+                {item_id: max(0, min(1, base_consumption_agg + noise))}, 0.5, 0.0, 0.0
+            )
 
         # 3. Run Phase 1: Normal Operation (Tick 1-15)
         print("Phase 1: Normal Operation (Tick 1-15)")
         for _ in range(15):
             for f in sim.firms:
                 # Capture f in closure or use individual lambda
-                f.decision_engine.ai_engine.decide_action_vector = MagicMock(side_effect=lambda *args, **kwargs: noisy_firm_vector(0.5, 0.5))
+                f.decision_engine.ai_engine.decide_action_vector = MagicMock(
+                    side_effect=lambda *args, **kwargs: noisy_firm_vector(0.5, 0.5)
+                )
             for h in sim.households:
-                h.decision_engine.ai_engine.decide_action_vector = MagicMock(side_effect=lambda *args, **kwargs: noisy_hh_vector(0.5))
-            
+                h.decision_engine.ai_engine.decide_action_vector = MagicMock(
+                    side_effect=lambda *args, **kwargs: noisy_hh_vector(0.5)
+                )
+
             sim.run_tick()
 
         # 4. Apply Shock: Production Stops (Tick 16-40)
         print("\n!!! SHOCK: FACTORY SHUTDOWN !!!")
         for firm in sim.firms:
-            firm.productivity_factor = 0.0 
+            firm.productivity_factor = 0.0
 
         print("Phase 2: Scarcity & Panic Buying (Tick 16-40)")
         for _ in range(25):
             for f in sim.firms:
                 f.productivity_factor = 0.0
-                f.decision_engine.ai_engine.decide_action_vector = MagicMock(side_effect=lambda *args, **kwargs: noisy_firm_vector(0.1, 0.0))
-            
+                f.decision_engine.ai_engine.decide_action_vector = MagicMock(
+                    side_effect=lambda *args, **kwargs: noisy_firm_vector(0.1, 0.0)
+                )
+
             for h in sim.households:
                 # Calculate urgency based on individual needs
                 current_survival = h.needs.get("survival", 0)
                 base_agg = 0.5
-                if current_survival > 60: base_agg = 0.9 # Panic buy
-                elif current_survival < 30: base_agg = 0.3 # Relaxed
-                
-                h.decision_engine.ai_engine.decide_action_vector = MagicMock(side_effect=lambda *args, **kwargs: noisy_hh_vector(base_agg))
+                if current_survival > 60:
+                    base_agg = 0.9  # Panic buy
+                elif current_survival < 30:
+                    base_agg = 0.3  # Relaxed
+
+                h.decision_engine.ai_engine.decide_action_vector = MagicMock(
+                    side_effect=lambda *args, **kwargs: noisy_hh_vector(base_agg)
+                )
 
             sim.run_tick()
 
         # 5. DB Verification using DAO (Repository)
         print("\n=== DAO Data Analysis ===")
-        
+
         # Query Market History
         # We'll use raw SQL through repository's cursor for flexibility
         self.repository.cursor.execute("""
@@ -193,33 +215,35 @@ class TestSupplyShock(unittest.TestCase):
             ORDER BY time ASC
         """)
         rows = self.repository.cursor.fetchall()
-        
+
         if not rows:
             print("ERROR: No market history recorded in DB!")
             self.fail("No market history found")
 
         print(f"{'Tick':<4} | {'Price':<6} | {'Ask(B/W/A)':<22} | {'Bid(B/W/A)':<22}")
         print("-" * 65)
-        
+
         price_pre = []
         price_post = []
-        
+
         for r in rows:
             tick, price, b_ask, w_ask, b_bid, w_bid, a_ask, a_bid = r
             ask_str = f"{b_ask:>5.1f}/{w_ask:>5.1f}/{a_ask:>5.1f}"
             bid_str = f"{b_bid:>5.1f}/{w_bid:>5.1f}/{a_bid:>5.1f}"
             print(f"{tick:<4} | {price:<6.2f} | {ask_str:<22} | {bid_str:<22}")
-            
+
             if tick <= 15:
-                if price > 0: price_pre.append(price)
+                if price > 0:
+                    price_pre.append(price)
             else:
-                if price > 0: price_post.append(price)
+                if price > 0:
+                    price_post.append(price)
 
         # AI Decisions Check
         self.repository.cursor.execute("SELECT COUNT(*) FROM ai_decisions_history")
         count = self.repository.cursor.fetchone()[0]
         print(f"\nTotal AI Decisions recorded in DB: {count}")
-        
+
         if count > 0:
             print("SUCCESS: AI decisions and rewards are being saved.")
         else:
@@ -229,16 +253,17 @@ class TestSupplyShock(unittest.TestCase):
         avg_pre = sum(price_pre) / len(price_pre) if price_pre else 0
         avg_post = sum(price_post) / len(price_post) if price_post else 0
         max_post = max(price_post) if price_post else 0
-        
+
         print(f"\nSummary Analysis:")
         print(f"Avg Price (Pre-Shock): {avg_pre:.2f}")
         print(f"Avg Price (Post-Shock): {avg_post:.2f}")
         print(f"Max Price (Post-Shock): {max_post:.2f}")
-        
+
         if max_post > avg_pre * 1.5:
             print("RESULT: PASS - Scarcity correctly drove prices up in DB records.")
         else:
             print("RESULT: FAIL - Prices remained stagnant despite scarcity.")
 
+
 if __name__ == "__main__":
     unittest.main()
diff --git a/tests/verify_system2_integration.py b/tests/verify_system2_integration.py
index 4241194..adc4ae7 100644
--- a/tests/verify_system2_integration.py
+++ b/tests/verify_system2_integration.py
@@ -6,6 +6,7 @@ from simulation.decisions.base_decision_engine import BaseDecisionEngine
 from simulation.ai.household_ai import HouseholdAI
 import config
 
+
 class TestSystem2Integration(unittest.TestCase):
     def setUp(self):
         # Mock Engine & AI
@@ -13,7 +14,7 @@ class TestSystem2Integration(unittest.TestCase):
         self.mock_ai = HouseholdAI("test_agent", self.mock_decision_engine)
         self.mock_decision_engine.ai_engine = self.mock_ai
         self.mock_decision_engine.config_module = config
-        self.mock_ai.ai_decision_engine = self.mock_decision_engine # Circular ref
+        self.mock_ai.ai_decision_engine = self.mock_decision_engine  # Circular ref
 
         self.agent = Household(
             id=1,
@@ -24,9 +25,9 @@ class TestSystem2Integration(unittest.TestCase):
             decision_engine=self.mock_decision_engine,
             value_orientation="wealth_and_needs",
             personality=Personality.CONSERVATIVE,
-            config_module=config
+            config_module=config,
         )
-        self.agent.expected_wage = 10.0 # $10/hr
+        self.agent.expected_wage = 10.0  # $10/hr
 
         # Override config constants for deterministic testing
         config.HOUSEWORK_BASE_HOURS = 4.0
@@ -39,7 +40,7 @@ class TestSystem2Integration(unittest.TestCase):
         under 'Dark Ages' conditions (No Tech).
         """
         # Common setup: 1 child, Spouse exists
-        self.agent.children_ids = [100] # 1 child
+        self.agent.children_ids = [100]  # 1 child
         self.agent.spouse_id = 99
         market_data = {"goods_market": {"basic_food_current_sell_price": 5.0}}
 
@@ -68,7 +69,11 @@ class TestSystem2Integration(unittest.TestCase):
         # Female: Housework(2.0 shared) + Childcare(8.0) = 10.0 Obligation
         #         Work Cap = 14 - 10 = 4h. Half Income.
 
-        self.assertGreater(npv_m, npv_f * 1.5, "Male NPV should be significantly higher due to Lactation Lock")
+        self.assertGreater(
+            npv_m,
+            npv_f * 1.5,
+            "Male NPV should be significantly higher due to Lactation Lock",
+        )
 
     def test_tech_liberation(self):
         """
@@ -96,7 +101,12 @@ class TestSystem2Integration(unittest.TestCase):
         print(f"NPV Dark Ages: {res_dark['npv_wealth']:.2f}")
         print(f"NPV Revolution: {res_light['npv_wealth']:.2f}")
 
-        self.assertGreater(res_light['npv_wealth'], res_dark['npv_wealth'], "Tech should improve Female NPV")
+        self.assertGreater(
+            res_light["npv_wealth"],
+            res_dark["npv_wealth"],
+            "Tech should improve Female NPV",
+        )
+
 
 if __name__ == "__main__":
     unittest.main()
diff --git a/tests/verify_vanity_society.py b/tests/verify_vanity_society.py
index 9021fcc..40ee8fa 100644
--- a/tests/verify_vanity_society.py
+++ b/tests/verify_vanity_society.py
@@ -4,7 +4,7 @@ import sys
 import os
 
 # Adjust path to include the root directory
-sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
+sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
 
 from simulation.core_agents import Household
 from simulation.ai.enums import Personality
@@ -12,6 +12,7 @@ from simulation.decisions.housing_manager import HousingManager
 from simulation.ai.household_ai import HouseholdAI
 import config
 
+
 @pytest.fixture
 def vanity_config():
     config_module = Mock(spec=config)
@@ -19,13 +20,8 @@ def vanity_config():
     config_module.ENABLE_VANITY_SYSTEM = True
     config_module.VANITY_WEIGHT = 1.0
     config_module.REFERENCE_GROUP_PERCENTILE = 0.2
-    config_module.CONFORMITY_RANGES = {
-        "STATUS_SEEKER": (0.8, 0.9),
-        "MISER": (0.1, 0.2)
-    }
-    config_module.GOODS = {
-        "luxury_bag": {"is_veblen": True}
-    }
+    config_module.CONFORMITY_RANGES = {"STATUS_SEEKER": (0.8, 0.9), "MISER": (0.1, 0.2)}
+    config_module.GOODS = {"luxury_bag": {"is_veblen": True}}
     config_module.MIMICRY_FACTOR = 0.5
     config_module.INITIAL_RENT_PRICE = 100.0
     config_module.MAINTENANCE_RATE_PER_TICK = 0.001
@@ -67,6 +63,7 @@ def vanity_config():
 
     return config_module
 
+
 def test_social_rank_calculation(vanity_config):
     """Verify sorting and percentile assignment"""
     households = []
@@ -74,13 +71,13 @@ def test_social_rank_calculation(vanity_config):
         h = Mock(spec=Household)
         h.id = i
         h.is_active = True
-        h.current_consumption = float(i * 10) # 0, 10, 20, 30, 40
+        h.current_consumption = float(i * 10)  # 0, 10, 20, 30, 40
         h.residing_property_id = None
-        h.is_homeless = True # Tier 0
+        h.is_homeless = True  # Tier 0
         households.append(h)
 
     # Give top agent a house
-    households[4].is_homeless = False # Tier 1
+    households[4].is_homeless = False  # Tier 1
 
     # Inject the logic here to test correctness
     scores = []
@@ -99,13 +96,16 @@ def test_social_rank_calculation(vanity_config):
         percentile = 1.0 - (rank_idx / n)
         ranks[hid] = percentile
 
-    assert ranks[4] == 1.0 # Top
-    assert ranks[0] == 1.0 - (4/5) # 0.2 (Bottom)
+    assert ranks[4] == 1.0  # Top
+    assert ranks[0] == 1.0 - (4 / 5)  # 0.2 (Bottom)
     assert ranks[3] > ranks[2]
 
+
 def test_veblen_demand(vanity_config):
     """Verify higher price -> higher WTP logic"""
-    from simulation.decisions.ai_driven_household_engine import AIDrivenHouseholdDecisionEngine
+    from simulation.decisions.ai_driven_household_engine import (
+        AIDrivenHouseholdDecisionEngine,
+    )
     from simulation.dtos import DecisionContext
 
     household = Mock(spec=Household)
@@ -113,21 +113,26 @@ def test_veblen_demand(vanity_config):
     household.is_employed = True
     household.current_wage = 100.0
     household.shares_owned = {}
-    household.conformity = 1.0 # Max conformity
+    household.conformity = 1.0  # Max conformity
     household.inventory = {}
     household.needs = {"social": 10.0}
     household._assets = 10000.0
-    household.expected_inflation = {} # Fix attribute error
-    household.personality = Personality.STATUS_SEEKER # Fix attribute error
+    household.expected_inflation = {}  # Fix attribute error
+    household.personality = Personality.STATUS_SEEKER  # Fix attribute error
     household.preference_asset = 1.0
     household.preference_social = 1.0
     household.preference_growth = 1.0
-    household.wage_modifier = 1.0 # Added to fix AttributeError
-    household.get_agent_data.return_value = {"assets": 10000.0, "needs": {"social": 10.0}, "inventory": {}}
+    household.wage_modifier = 1.0  # Added to fix AttributeError
+    household.get_agent_data.return_value = {
+        "assets": 10000.0,
+        "needs": {"social": 10.0},
+        "inventory": {},
+    }
 
     ai_engine = Mock()
     # Mock action vector
     from simulation.schemas import HouseholdActionVector
+
     ai_engine.decide_action_vector.return_value = HouseholdActionVector(
         consumption_aggressiveness={"luxury_bag": 0.5}
     )
@@ -141,7 +146,7 @@ def test_veblen_demand(vanity_config):
         goods_data=[],
         market_data=market_data_low,
         current_time=0,
-        household=household
+        household=household,
     )
     orders_low, _ = engine.make_decisions(context)
     wtp_low = orders_low[0].price if orders_low else 0
@@ -153,7 +158,7 @@ def test_veblen_demand(vanity_config):
         goods_data=[],
         market_data=market_data_high,
         current_time=0,
-        household=household
+        household=household,
     )
     orders_high, _ = engine.make_decisions(context)
     wtp_high = orders_high[0].price if orders_high else 0
@@ -162,11 +167,12 @@ def test_veblen_demand(vanity_config):
     assert len(orders_high) > 0
     assert wtp_high > wtp_low
 
+
 def test_mimicry_trigger(vanity_config):
     """Verify panic buy trigger"""
     agent = Mock(spec=Household)
     agent.conformity = 1.0
-    agent.is_homeless = True # Tier 0
+    agent.is_homeless = True  # Tier 0
     agent.residing_property_id = None
 
     config = vanity_config
@@ -189,18 +195,19 @@ def test_mimicry_trigger(vanity_config):
     assert intent.priority == "URGENT"
     assert intent.max_ltv == 0.95
 
+
 def test_vanity_switch_ab(vanity_config):
     """Integration: test_vanity_switch_ab (VANITY_WEIGHT=0 vs 1.5 ë¹„êµ)"""
     # Setup common agent data
     agent_data = {
         "assets": 5000.0,
-        "social_rank": 0.5, # Below reference (0.8)
+        "social_rank": 0.5,  # Below reference (0.8)
         "conformity": 1.0,
         "needs": {"survival": 0.0},
-        "inventory": {}
+        "inventory": {},
     }
     pre_state = agent_data.copy()
-    post_state = agent_data.copy() # No change in assets/needs for isolation
+    post_state = agent_data.copy()  # No change in assets/needs for isolation
     market_data = {}
 
     # Scenario A: Vanity Disabled (WEIGHT = 0.0 or ENABLE = False)
diff --git a/tests/verify_wo103_phase1.py b/tests/verify_wo103_phase1.py
index 67272f5..e9bf239 100644
--- a/tests/verify_wo103_phase1.py
+++ b/tests/verify_wo103_phase1.py
@@ -10,6 +10,7 @@ from simulation.firms import Firm
 from simulation.components.finance_department import FinanceDepartment
 from simulation.components.hr_department import HRDepartment
 
+
 class TestWO103Phase1(unittest.TestCase):
     def setUp(self):
         self.mock_config = MagicMock()
@@ -24,8 +25,8 @@ class TestWO103Phase1(unittest.TestCase):
         self.mock_config.FIRM_CLOSURE_TURNS_THRESHOLD = 10
         self.mock_config.PROFIT_HISTORY_TICKS = 10
         self.mock_config.GOODS = {"food": {"initial_price": 10.0}}
-        self.mock_config.FIRM_MAINTENANCE_FEE = 0.0 # Simplify
-        self.mock_config.CORPORATE_TAX_RATE = 0.0 # Simplify
+        self.mock_config.FIRM_MAINTENANCE_FEE = 0.0  # Simplify
+        self.mock_config.CORPORATE_TAX_RATE = 0.0  # Simplify
         self.mock_config.RAW_MATERIAL_SECTORS = []
         # Add BrandManager specific configs just in case, though we mock it
         self.mock_config.BRAND_DECAY = 0.95
@@ -42,7 +43,7 @@ class TestWO103Phase1(unittest.TestCase):
             productivity_factor=1.0,
             decision_engine=self.mock_decision_engine,
             value_orientation="PROFIT",
-            config_module=self.mock_config
+            config_module=self.mock_config,
         )
 
         # Mock HR process_payroll returns 0.0
@@ -88,7 +89,7 @@ class TestWO103Phase1(unittest.TestCase):
 
         # Setup inventory
         self.firm.inventory = {"food": 10.0}
-        self.firm.last_prices = {"food": 10.0} # Value = 100.0
+        self.firm.last_prices = {"food": 10.0}  # Value = 100.0
         # Cost rate 0.1 -> Cost = 10.0
 
         # Marketing Logic:
@@ -100,12 +101,15 @@ class TestWO103Phase1(unittest.TestCase):
 
         self.firm.update_needs(current_time=1)
 
-        expected_deduction = 10.0 + 10.0 # Holding + Marketing
-        self.assertAlmostEqual(self.firm.assets, initial_assets - expected_deduction, delta=0.1)
+        expected_deduction = 10.0 + 10.0  # Holding + Marketing
+        self.assertAlmostEqual(
+            self.firm.assets, initial_assets - expected_deduction, delta=0.1
+        )
 
         # Verify finance recorded expenses
         self.assertGreater(self.firm.finance.expenses_this_tick, 0)
         print("Holding Costs Passed.")
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     unittest.main()
