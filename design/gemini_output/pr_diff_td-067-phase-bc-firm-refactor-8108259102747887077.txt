diff --git a/communications/team_assignments.json b/communications/team_assignments.json
index cf6a391..934b6b8 100644
--- a/communications/team_assignments.json
+++ b/communications/team_assignments.json
@@ -5,18 +5,6 @@
       "5549135717124718802": {
         "title": "TD-067 Phase B/C: Firm Facade Deconstruction",
         "initial_mission": "Refactor Firm class to remove 20+ wrapper properties and encapsulate CorporateManager interactions."
-      },
-      "8108259102747887077": {
-        "title": "TD-067 Phase B/C: Firm Facade Deconstruction",
-        "initial_mission": "# TD-067 Phase B/C: Firm Facade Deconstruction\n\n## Context\nYou are continuing the TD-067 refactoring work. **Phase A (FinanceDepartment Extraction) has been successfully merged**. Your task is to complete **Phase B (Remove Wrapper Properties)** and **Phase C (Reduce CorporateManager Coupling)**.\n\n## Critical Instructions\n\n### âš ï¸ SoC Preservation (MANDATORY)\n**DO NOT regress to God Class pattern.** The codebase has undergone extensive SoC refactoring:\n- `Simulation` â†’ `WorldState`, `TickScheduler`, `ActionProcessor` (TD-066)\n- `Household` â†’ `BioComponent`, `EconComponent`, `SocialComponent` (TD-065)\n- `Firm` â†’ `HRDepartment`, `FinanceDepartment`, `ProductionDepartment`, `SalesDepartment` (TD-067 Phase A)\n\n**You MUST maintain this architecture.** Do not create wrapper properties or consolidate logic back into `Firm`.\n\n### ğŸ“‹ Pre-Merge Checklist (You MUST confirm in PR description)\n- [ ] Zero `@property` wrappers in `Firm` class\n- [ ] All `CorporateManager` methods use encapsulation APIs\n- [ ] `tests/test_corporate_manager.py` passes\n- [ ] `tests/verification/verify_mitosis.py` passes (Golden Fixture compatibility)\n- [ ] No direct `firm.assets` access outside `FinanceDepartment`\n\n---\n\n## Task Specification\n\nRead the full specification at: `design/specs/TD-067_Phase_BC_Firm_Refactor_Spec.md`\n\n### Summary of Work\n\n#### Track B: Eliminate Wrapper Properties\n1. Remove **all 20+ `@property` wrappers** from `simulation/firms.py` (lines 181-299)\n2. Move logic to components:\n   - `calculate_valuation()` â†’ `FinanceDepartment`\n   - `get_book_value_per_share()` â†’ `FinanceDepartment`\n   - `get_financial_snapshot()` â†’ `FinanceDepartment`\n\n#### Track C: Reduce CorporateManager Coupling\n1. Add encapsulation methods to `FinanceDepartment`:\n   - `invest_in_automation(amount: float) -> bool`\n   - `invest_in_rd(amount: float) -> bool`\n   - `invest_in_capex(amount: float) -> bool`\n   - `set_dividend_rate(rate: float) -> None`\n\n2. Refactor `simulation/decisions/corporate_manager.py`:\n   - Replace `firm.assets -= budget` â†’ `firm.finance.invest_in_automation(budget)`\n   - Replace `firm.dividend_rate = x` â†’ `firm.finance.set_dividend_rate(x)`\n   - Update methods: `_manage_automation`, `_manage_r_and_d`, `_manage_capex`, `_manage_dividends`, `_manage_hiring`\n\n#### Track D: Refactor All Call Sites\n1. Update `tests/test_corporate_manager.py`:\n   - Mock sub-components: `firm_mock.finance.assets = 10000.0`\n   - Update assertions: `assert firm_mock.finance.assets == expected`\n\n2. Update `tests/test_firms.py`:\n   - Call `firm.finance.get_book_value_per_share()` instead of `firm.get_book_value_per_share()`\n\n3. Update `Firm` internal methods:\n   - `make_decision()`, `get_agent_data()`, `update_needs()` â†’ access sub-components directly\n\n---\n\n## Verification Requirements\n\n### Must Pass\n- `pytest tests/test_corporate_manager.py` âœ…\n- `pytest tests/test_firms.py` âœ…\n- `pytest tests/verification/verify_mitosis.py` âœ… (Golden Fixture gate check)\n- `ruff check simulation/` (no unused imports)\n\n### Manual Checks\n- Grep for `firm.assets` outside `FinanceDepartment` â†’ should return 0 results (except in tests)\n- Grep for `@property` in `Firm` class â†’ should return 0 results\n\n---\n\n## Reference Documents\n- **Spec**: `design/specs/TD-067_Phase_BC_Firm_Refactor_Spec.md` (FULL DETAILS)\n- **Template**: `design/specs/TD-065_Household_Refactor_Spec.md` (Similar refactoring pattern)\n- **Handover Warning**: `design/handovers/HANDOVER_2026-01-20.md` (Jules regression alert)\n- **Tech Debt**: `design/TECH_DEBT_LEDGER.md` (TD-067 entry)\n\n---\n\n## Success Criteria\nâœ… All wrapper properties removed\nâœ… `CorporateManager` uses encapsulation methods only\nâœ… All tests pass (including Golden Fixtures)\nâœ… No God Class regression (verified by code review)\nâœ… Pre-merge checklist confirmed in PR description\n"
-      },
-      "1168830734155576498": {
-        "title": "Infra-Cleanup: TD-050, TD-063, TD-051 Stabilization",
-        "initial_mission": "# Mission: Infrastructure & Script Maintenance (TD-050, TD-063, TD-051)\n\n## Context\nAs the project grows, our utility scripts and documentation need stabilization. You are assigned to clean up import logic, exclude noise from health reports, and finalize documentation IDs.\n\n## Task Details\n\n### 1. Stable Import Logic (TD-063)\n- **Problem**: Many scripts in `scripts/` use `sys.path.append(os.path.join(os.path.dirname(__file__), '..'))` which is brittle and can fail depending on execution context.\n- **Action**: Refactor all scripts in `scripts/` to use `pathlib` for project root detection.\n- **Goal**: Ensure consistent behavior when run from any directory.\n\n### 2. Cleanup Health Reports (TD-050)\n- **Problem**: `scripts/scan_codebase.py` (or similar audit scripts) scans `scripts/observer/`, leading to false positive complexity alerts in third-party or observer-only code.\n- **Action**: Update the scanning logic to exclude the `scripts/observer/` and `design/` (artifacts) directories from the complexity/SoC analysis.\n\n### 3. Documentation Sanitization (TD-051)\n- **Problem**: Some manuals or specs still contain `WO-XXX` placeholders instead of concrete task IDs.\n- **Action**: Grep for any remaining `WO-XXX` in the `design/` folder and replace them with the actual Work Order IDs (e.g., `WO-083C`) based on the contents of the file or `TECH_DEBT_LEDGER.md`.\n\n## Verification Requirements\n- All refactored scripts must still run correctly (e.g., `python scripts/launcher.py --help`).\n- Run the health scan script and verify `scripts/observer` is no longer in the report.\n- `grep -r \"WO-XXX\" design/` should return zero results.\n\n## Success Criteria\n- âœ… Import logic homogenized using `pathlib`.\n- âœ… Health reports are noise-free.\n- âœ… Documentation is free of placeholders.\n"
-      },
-      "7846289173909215125": {
-        "title": "Finance Config Migration: TD-034, TD-041",
-        "initial_mission": "# Mission: Finance Parameter Migration (TD-034, TD-041)\n\n## Context\nWe are moving away from hardcoded economic constants to a fully configurable simulation. Your task is to extract hidden financial parameters into the `config/` system.\n\n## Task Details\n\n### 1. Hardcoded Debt Parameters (TD-034)\n- **Problem**: Bond maturity lengths, risk premia, and debt ceilings are hardcoded in `simulation/agents/government.py` or finance modules.\n- **Action**: \n    - Identify these constants.\n    - Add them to the global config (e.g., `config/economy_params.yaml`).\n    - Update the code to read these via `ConfigManager`.\n\n### 2. Bailout Covenant Ratio (TD-041)\n- **Problem**: The repayment ratio of 0.5 for corporate bailouts is hardcoded.\n- **Action**: \n    - Move `BAILOUT_COVENANT_RATIO` to the configuration system.\n    - Default remains `0.5`, but it must be adjustable without code changes.\n\n## Verification Requirements\n- The simulation must run (`python main.py --ticks 10`) without any change in behavior using default config values.\n- Verify that changing these values in the config file actually affects the simulation (e.g., shorter bond maturity).\n\n## Success Criteria\n- âœ… No hardcoded debt constants in logic files.\n- âœ… Corporate bailout terms are fully configurable.\n"
       }
     },
     "completed_sessions": {
diff --git a/design/command_registry.json b/design/command_registry.json
index d2c2c92..eb5ac2c 100644
--- a/design/command_registry.json
+++ b/design/command_registry.json
@@ -1,20 +1,21 @@
 {
   "gemini": {
     "command": "analyze",
-    "title": "Domain Logic Refactor: TD-059",
-    "instruction": "Analyze simulation/components/finance_department.py and simulation/ai/altman_z_score.py. Identify duplicate valuation/solvency logic in FinanceDepartment that should be replaced by AltmanZScoreCalculator. Generate a mission brief for Jules at 'design/drafts/jules_missions/Domain_Logic_Refactor_Mission.md' that details the refactoring steps, preserving SSOT (Single Source of Truth).",
+    "title": "TD-067 Phase B/C Analysis",
+    "instruction": "Analyze the Firm class for TD-067 Phase B/C refactoring. Generate a comprehensive report with two sections:\n\n1. **Wrapper Properties Inventory**: List all @property getters/setters in simulation/firms.py that simply delegate to internal components (e.g., hr, finance). For each wrapper, identify:\n   - Property name\n   - Target component and attribute\n   - Number of external usages (grep count)\n   - Breaking change risk (LOW/MEDIUM/HIGH)\n\n2. **CorporateManager Coupling Analysis**: Analyze simulation/decisions/corporate_manager.py to identify all direct state manipulations of Firm objects. For each coupling point:\n   - Method name in CorporateManager\n   - Direct attribute access pattern (e.g., 'firm.assets -= budget')\n   - Proposed encapsulation method (e.g., 'firm.invest_in_automation(amount)')\n   - Impact on existing tests\n\nReference TD-065_Household_Refactor_Spec.md as a template for the refactoring approach. Output should be a detailed spec document ready for Jules implementation.",
     "context": [
-      "simulation/components/finance_department.py",
-      "simulation/ai/altman_z_score.py",
-      "design/TECH_DEBT_LEDGER.md"
-    ],
-    "output": "design/drafts/jules_missions/Domain_Logic_Refactor_Mission.md"
+      "simulation/firms.py",
+      "simulation/decisions/corporate_manager.py",
+      "design/specs/TD-065_Household_Refactor_Spec.md",
+      "design/TECH_DEBT_LEDGER.md",
+      "design/handovers/HANDOVER_2026-01-20.md"
+    ]
   },
   "jules": {
     "command": "create",
-    "title": "Domain-Logic-Refactor: TD-059 Solvency Delegation",
-    "instruction": "Refactor FinanceDepartment to delegate solvency calculations to AltmanZScoreCalculator.",
-    "file": "design/drafts/jules_missions/Domain_Logic_Refactor_Mission.md",
+    "title": "TD-067 Phase B/C: Firm Facade Deconstruction",
+    "instruction": "Refactor Firm class to remove 20+ wrapper properties and encapsulate CorporateManager interactions.",
+    "file": "design/drafts/jules_missions/TD-067_Phase_BC_Mission.md",
     "session_id": null
   },
   "git": {
diff --git a/design/drafts/jules_missions/Domain_Logic_Refactor_Mission.md b/design/drafts/jules_missions/Domain_Logic_Refactor_Mission.md
deleted file mode 100644
index 70e972c..0000000
--- a/design/drafts/jules_missions/Domain_Logic_Refactor_Mission.md
+++ /dev/null
@@ -1,135 +0,0 @@
-# Mission Brief: Domain Logic Refactor (Solvency Calculation)
-
-**TO:** Jules
-**FROM:** Antigravity (via Gemini Scribe)
-**SUBJECT:** Refactor `FinanceDepartment` to Delegate Solvency Logic
-**TRACKING ID:** `WO-084` (Work Order)
-**RELATED DEBT:** `TD-059`, `TD-058`
-
----
-
-## 1. Objective
-
-Refactor the `FinanceDepartment` component to eliminate its internal `calculate_altman_z_score` method. All solvency calculations must be delegated to a dedicated, pure `AltmanZScoreCalculator` component, adhering to our established DTO-based communication protocol. This action will resolve technical debt `TD-059` and enforce the Single Source of Truth (SSOT) principle for financial analytics.
-
-## 2. Context & Architectural Mandate
-
-The recent pre-flight audit confirmed that `FinanceDepartment` violates the Single Responsibility Principle (SRP) by containing complex solvency calculation logic. This is a direct contravention of our architectural goals, as documented in `TD-059`.
-
-Furthermore, architectural mandate `TD-058` requires that communication between major components must be done via Data Transfer Objects (DTOs), not by passing entire agent objects. This refactor must strictly adhere to this principle.
-
-**Reference:** `[AUTO-AUDIT FINDINGS] Pre-flight Audit: Domain Logic Refactor`
-
-## 3. Execution Plan
-
-### Step 1: Define the Data Contract (`FinancialStatementDTO`)
-
-In a suitable DTOs file (e.g., `simulation/dtos/financial_dtos.py`), define a new `TypedDict` or `Dataclass` named `FinancialStatementDTO`.
-
-This DTO will serve as the standardized data contract for passing financial state. Its structure should be based on the return value of the existing `get_financial_snapshot` method in `FinanceDepartment`.
-
-```python
-# simulation/dtos/financial_dtos.py (Example)
-from typing import TypedDict
-
-class FinancialStatementDTO(TypedDict):
-    total_assets: float
-    working_capital: float
-    retained_earnings: float
-    average_profit: float
-    total_debt: float
-```
-
-### Step 2: Implement the Pure Calculator (`AltmanZScoreCalculator`)
-
-Create or modify the `simulation/ai/altman_z_score.py` file to contain the `AltmanZScoreCalculator`. This class must be "pure" â€” it should have no knowledge of the `Firm` or `FinanceDepartment` objects.
-
-Its sole public method, `calculate`, will accept the `FinancialStatementDTO` as input and return the Z-score as a float. The logic currently inside `FinanceDepartment.calculate_altman_z_score` should be moved here and adapted to read from the DTO.
-
-```python
-# simulation/ai/altman_z_score.py (Example)
-from simulation.dtos.financial_dtos import FinancialStatementDTO
-
-class AltmanZScoreCalculator:
-    """Calculates the Altman Z-Score based on a standardized financial snapshot."""
-
-    def calculate(self, statement: FinancialStatementDTO) -> float:
-        """
-        Calculates the Z-Score using a modified formula for service companies.
-        Z = 1.2*X1 + 1.4*X2 + 3.3*X3
-        """
-        if statement["total_assets"] == 0:
-            return 0.0
-
-        # X1: Working Capital / Total Assets
-        x1 = statement["working_capital"] / statement["total_assets"]
-
-        # X2: Retained Earnings / Total Assets
-        x2 = statement["retained_earnings"] / statement["total_assets"]
-
-        # X3: Average Profit / Total Assets
-        x3 = statement["average_profit"] / statement["total_assets"]
-
-        z_score = 1.2 * x1 + 1.4 * x2 + 3.3 * x3
-        return z_score
-```
-
-### Step 3: Refactor `FinanceDepartment`
-
-1.  **Remove Legacy Logic:** Delete the entire `calculate_altman_z_score` method from `simulation/components/finance_department.py`.
-2.  **Implement Delegator Method:** Create a new public method that orchestrates the calculation. This method will construct and pass the DTO to the new calculator.
-
-```python
-# In simulation/components/finance_department.py
-
-from simulation.ai.altman_z_score import AltmanZScoreCalculator
-from simulation.dtos.financial_dtos import FinancialStatementDTO
-
-class FinanceDepartment:
-    # ... existing methods ...
-
-    def __init__(self, firm: Firm, config_module: Any):
-        # ...
-        self.solvency_calculator = AltmanZScoreCalculator() # Instantiate the calculator
-
-    # DELETE THE ENTIRE `calculate_altman_z_score` METHOD
-
-    def get_altman_z_score(self) -> float:
-        """
-        Calculates the firm's solvency by assembling a financial snapshot
-        and delegating the calculation to the dedicated solvency calculator.
-        """
-        # 1. Get the raw financial data.
-        snapshot_data = self.get_financial_snapshot()
-
-        # 2. Assemble the DTO.
-        financial_statement = FinancialStatementDTO(
-            total_assets=snapshot_data["total_assets"],
-            working_capital=snapshot_data["working_capital"],
-            retained_earnings=snapshot_data["retained_earnings"],
-            average_profit=snapshot_data["average_profit"],
-            total_debt=snapshot_data["total_debt"]
-        )
-
-        # 3. Delegate calculation and return the result.
-        return self.solvency_calculator.calculate(financial_statement)
-
-    # ... other methods ...
-```
-
-### Step 4: Update Call Sites
-
-Search the codebase for any direct calls to `finance_department.calculate_altman_z_score()` and update them to call the new `finance_department.get_altman_z_score()` method.
-
-### Step 5: Refactor Tests
-
-1.  **Test `AltmanZScoreCalculator`:** Create a new test file, `tests/ai/test_altman_z_score.py`. Write focused unit tests that provide various `FinancialStatementDTO` inputs to the calculator and assert that the returned Z-score is correct.
-2.  **Test `FinanceDepartment`:** Modify existing tests for `FinanceDepartment`. Instead of testing the calculation itself, mock the `AltmanZScoreCalculator` and verify that the `get_altman_z_score` method correctly assembles the `FinancialStatementDTO` from the `Firm`'s state and passes it to the mocked calculator.
-
-## 4. Verification (Definition of Done)
-
-- The `calculate_altman_z_score` method has been completely removed from `FinanceDepartment`.
-- The `AltmanZScoreCalculator` class exists, is pure, and performs the Z-score calculation using a `FinancialStatementDTO`.
-- `FinanceDepartment` now uses an instance of `AltmanZScoreCalculator` to perform the solvency check.
-- All pre-existing and new unit tests pass successfully.
-- Technical debt `TD-059` is resolved and can be marked as such in `design/TECH_DEBT_LEDGER.md`.
diff --git a/design/drafts/jules_missions/Finance_Config_Migration_Mission.md b/design/drafts/jules_missions/Finance_Config_Migration_Mission.md
deleted file mode 100644
index 486a606..0000000
--- a/design/drafts/jules_missions/Finance_Config_Migration_Mission.md
+++ /dev/null
@@ -1,27 +0,0 @@
-# Mission: Finance Parameter Migration (TD-034, TD-041)
-
-## Context
-We are moving away from hardcoded economic constants to a fully configurable simulation. Your task is to extract hidden financial parameters into the `config/` system.
-
-## Task Details
-
-### 1. Hardcoded Debt Parameters (TD-034)
-- **Problem**: Bond maturity lengths, risk premia, and debt ceilings are hardcoded in `simulation/agents/government.py` or finance modules.
-- **Action**: 
-    - Identify these constants.
-    - Add them to the global config (e.g., `config/economy_params.yaml`).
-    - Update the code to read these via `ConfigManager`.
-
-### 2. Bailout Covenant Ratio (TD-041)
-- **Problem**: The repayment ratio of 0.5 for corporate bailouts is hardcoded.
-- **Action**: 
-    - Move `BAILOUT_COVENANT_RATIO` to the configuration system.
-    - Default remains `0.5`, but it must be adjustable without code changes.
-
-## Verification Requirements
-- The simulation must run (`python main.py --ticks 10`) without any change in behavior using default config values.
-- Verify that changing these values in the config file actually affects the simulation (e.g., shorter bond maturity).
-
-## Success Criteria
-- âœ… No hardcoded debt constants in logic files.
-- âœ… Corporate bailout terms are fully configurable.
diff --git a/design/drafts/jules_missions/Infrastructure_Cleanup_Mission.md b/design/drafts/jules_missions/Infrastructure_Cleanup_Mission.md
deleted file mode 100644
index ca105c3..0000000
--- a/design/drafts/jules_missions/Infrastructure_Cleanup_Mission.md
+++ /dev/null
@@ -1,29 +0,0 @@
-# Mission: Infrastructure & Script Maintenance (TD-050, TD-063, TD-051)
-
-## Context
-As the project grows, our utility scripts and documentation need stabilization. You are assigned to clean up import logic, exclude noise from health reports, and finalize documentation IDs.
-
-## Task Details
-
-### 1. Stable Import Logic (TD-063)
-- **Problem**: Many scripts in `scripts/` use `sys.path.append(os.path.join(os.path.dirname(__file__), '..'))` which is brittle and can fail depending on execution context.
-- **Action**: Refactor all scripts in `scripts/` to use `pathlib` for project root detection.
-- **Goal**: Ensure consistent behavior when run from any directory.
-
-### 2. Cleanup Health Reports (TD-050)
-- **Problem**: `scripts/scan_codebase.py` (or similar audit scripts) scans `scripts/observer/`, leading to false positive complexity alerts in third-party or observer-only code.
-- **Action**: Update the scanning logic to exclude the `scripts/observer/` and `design/` (artifacts) directories from the complexity/SoC analysis.
-
-### 3. Documentation Sanitization (TD-051)
-- **Problem**: Some manuals or specs still contain `WO-XXX` placeholders instead of concrete task IDs.
-- **Action**: Grep for any remaining `WO-XXX` in the `design/` folder and replace them with the actual Work Order IDs (e.g., `WO-083C`) based on the contents of the file or `TECH_DEBT_LEDGER.md`.
-
-## Verification Requirements
-- All refactored scripts must still run correctly (e.g., `python scripts/launcher.py --help`).
-- Run the health scan script and verify `scripts/observer` is no longer in the report.
-- `grep -r "WO-XXX" design/` should return zero results.
-
-## Success Criteria
-- âœ… Import logic homogenized using `pathlib`.
-- âœ… Health reports are noise-free.
-- âœ… Documentation is free of placeholders.
diff --git a/design/handovers/SESSION_REPORT_2026-01-20_TD-067_COMPLETE.md b/design/handovers/SESSION_REPORT_2026-01-20_TD-067_COMPLETE.md
deleted file mode 100644
index 3a5d0fd..0000000
--- a/design/handovers/SESSION_REPORT_2026-01-20_TD-067_COMPLETE.md
+++ /dev/null
@@ -1,36 +0,0 @@
-# Architecture Completion Report: TD-067 Phase B/C
-**Date:** 2026-01-20
-**Task:** Deconstruction of `Firm` God Class Facade
-**Status:** IMPLEMENTED (Assumed Completion)
-
-## 1. ê°œìš” (Executive Summary)
-ë³¸ ë³´ê³ ì„œëŠ” `Firm` í´ë˜ìŠ¤ì˜ ì•„í‚¤í…ì²˜ ì •ì œ ì‘ì—…(TD-067 Phase B/C) ê²°ê³¼ë¥¼ ìš”ì•½í•©ë‹ˆë‹¤. ì´ë²ˆ ì‘ì—…ì„ í†µí•´ `Firm` í´ë˜ìŠ¤ëŠ” 700ë¼ì¸ ì´ìƒì˜ God Classì—ì„œ ëª…í™•í•œ ì—­í•  ë¶„ë‹´ì„ ê°€ì§„ ê²½ëŸ‰ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°ë¡œ ê±°ë“­ë‚¬ìŠµë‹ˆë‹¤.
-
-## 2. ì£¼ìš” ì•„í‚¤í…ì²˜ ê°œì„  ì‚¬í•­
-
-### 2.1. Wrapper ë° Facade ì œê±° (Track B)
-- **ì œê±° ë‚´ì—­**: `employees`, `assets`, `current_profit`, `revenue_this_turn` ë“± 20ì—¬ ê°œì˜ ëŒ€ë¦¬ ì†ì„±(Proxy Properties)ì„ ì™„ì „ ì‚­ì œ.
-- **íš¨ê³¼**: ë°ì´í„° ì†Œìœ ê¶Œ ë¶„ë³„ë ¥ ê°•í™” ë° `simulation/firms.py` ì½”ë“œ ë³µì¡ë„ ì•½ 30% ê°ì†Œ.
-
-### 2.2. ê²°í•©ë„ í•´ì œ ë° ìº¡ìŠí™” (Track C)
-- **CorporateManager ë¦¬íŒ©í† ë§**: `Firm`ì˜ ë‚´ë¶€ ìƒíƒœë¥¼ ì§ì ‘ ìˆ˜ì •í•˜ë˜ ë¡œì§ì„ `FinanceDepartment` ë° `HRDepartment`ì˜ ë„ë©”ì¸ ë©”ì„œë“œ í˜¸ì¶œ ë°©ì‹ìœ¼ë¡œ ë³€ê²½.
-- **ë„ë©”ì¸ ë©”ì„œë“œ ì¶”ê°€**:
-    - `invest_in_automation(amount)`
-    - `invest_in_rd(amount)`
-    - `pay_dividend_payout(rate)`
-- **íš¨ê³¼**: `CorporateManager`ì˜ ë¡œì§ì´ `Firm`ì˜ ë‚´ë¶€ êµ¬ì¡° ë³€í™”ì— ì˜í–¥ì„ ë°›ì§€ ì•ŠëŠ” 'Robust Architecture' ë‹¬ì„±.
-
-### 2.3. í…ŒìŠ¤íŠ¸ ë° ê²€ì¦ (Track D)
-- **Test Sync**: `tests/test_corporate_manager.py`ì˜ ë ˆê±°ì‹œ Mock êµ¬ì¡°ë¥¼ SoC ê¸°ë°˜ìœ¼ë¡œ ì—…ë°ì´íŠ¸.
-- **Stability Check**: Golden Fixture(`verify_mitosis.py`)ë¥¼ í†µí•´ ë¦¬íŒ©í† ë§ í›„ì—ë„ ë§ˆì´ê·¸ë ˆì´ì…˜ ê²°ê³¼ê°€ ì´ì „ê³¼ ë™ì¼í•¨ì„ ê²€ì¦.
-
-## 3. ë¦¬ìŠ¤í¬ í‰ê°€ (Risk Audit)
-- **God Class Regression**: Jules ë° ì‹ ê·œ ê¸°ì—¬ìê°€ í¸ì˜ë¥¼ ìœ„í•´ ë‹¤ì‹œ `Firm`ì— ë¡œì§ì„ ì¶”ê°€í•˜ì§€ ì•Šë„ë¡ `SoC Preservation Guidelines`ë¥¼ ë°°í¬í•¨.
-- **Breaking Changes**: ëŒ€ë¶€ë¶„ì˜ ë³€ê²½ì‚¬í•­ì€ ë‚´ë¶€ APIì— êµ­í•œë˜ë‚˜, `firm.assets`ë¥¼ ì§ì ‘ ì‚¬ìš©í•˜ëŠ” ì™¸ë¶€ ëª¨ë“ˆ(Dashboards ë“±)ì€ `firm.finance.assets`ë¥¼ ì‚¬ìš©í•˜ë„ë¡ ì—…ë°ì´íŠ¸ ì™„ë£Œ.
-
-## 4. ìµœì¢… ê²°ë¡ 
-`Firm` í´ë˜ìŠ¤ì˜ God Class í•´ì²´ëŠ” ì´ë²ˆ Phase B/Cë¥¼ ëìœ¼ë¡œ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ì‹œë®¬ë ˆì´ì…˜ ì—”ì§„ì˜ í•µì‹¬ ì£¼ì²´ë“¤ì´ ëª¨ë‘ SoC(Household, Simulation, Firm)ë¥¼ ë‹¬ì„±í•¨ì— ë”°ë¼, í–¥í›„ ìƒˆë¡œìš´ ê²½ì œ ì •ì±…ì´ë‚˜ ê³ ë„í™”ëœ AI ì „ëµì„ ë„ì…í•  ìˆ˜ ìˆëŠ” í™•ì¥ ê°€ëŠ¥í•œ ê¸°ìˆ ì  í† ëŒ€ê°€ ë§ˆë ¨ë˜ì—ˆìŠµë‹ˆë‹¤.
-
----
-**Prepared by:** Antigravity (AI Architect)
-**Reviewed by:** Senior Developer (User Request)
diff --git a/simulation/ai/firm_system2_planner.py b/simulation/ai/firm_system2_planner.py
index 41658b5..700697e 100644
--- a/simulation/ai/firm_system2_planner.py
+++ b/simulation/ai/firm_system2_planner.py
@@ -40,10 +40,10 @@ class FirmSystem2Planner:
 
         # 1. Forecast Revenue
         # Base revenue on recent history or current tick
-        base_revenue = max(self.firm.revenue_this_turn, self.firm.last_revenue, 10.0)
+        base_revenue = max(self.firm.finance.revenue_this_turn, self.firm.finance.last_revenue, 10.0)
 
         # 2. Forecast Costs (Status Quo)
-        current_wages = sum(self.firm.employee_wages.values())
+        current_wages = sum(self.firm.hr.employee_wages.values())
         current_maintenance = getattr(self.config, "FIRM_MAINTENANCE_FEE", 50.0)
 
         # 3. Scenario Analysis: Automation Investment
@@ -101,7 +101,7 @@ class FirmSystem2Planner:
         # 7. M&A Strategy
         expansion_mode = "ORGANIC"
         if personality == Personality.GROWTH_HACKER or personality == Personality.BALANCED:
-            if self.firm.assets > self.firm.revenue_this_turn * 50:
+            if self.firm.assets > self.firm.finance.revenue_this_turn * 50:
                 expansion_mode = "MA"
 
         guidance = {
diff --git a/simulation/components/finance_department.py b/simulation/components/finance_department.py
index f3800dd..347fb5c 100644
--- a/simulation/components/finance_department.py
+++ b/simulation/components/finance_department.py
@@ -384,3 +384,70 @@ class FinanceDepartment:
 
         outstanding_shares = self.firm.total_shares - self.firm.treasury_shares
         return outstanding_shares * stock_price
+
+    def get_assets(self) -> float:
+        """Returns the current assets (cash) of the firm."""
+        return self.firm.assets
+
+    def invest_in_automation(self, amount: float) -> bool:
+        """
+        Deduct investment from assets for automation.
+        Returns success status.
+        """
+        if self.firm.assets >= amount:
+            self.firm.assets -= amount
+            # Track expense if needed, or just capital outlay?
+            # Capital outlay is not strictly an expense in P&L usually, but reduces cash.
+            return True
+        return False
+
+    def invest_in_rd(self, amount: float) -> bool:
+        """
+        Deduct R&D budget from assets.
+        Returns success status.
+        """
+        if self.firm.assets >= amount:
+            self.firm.assets -= amount
+            # R&D is often treated as expense
+            self.record_expense(amount)
+            return True
+        return False
+
+    def invest_in_capex(self, amount: float) -> bool:
+        """
+        Deduct CAPEX from assets.
+        Returns success status.
+        """
+        if self.firm.assets >= amount:
+            self.firm.assets -= amount
+            # CAPEX is asset conversion (Cash -> Capital), not expense.
+            return True
+        return False
+
+    def set_dividend_rate(self, rate: float) -> None:
+        """Set dividend payout rate."""
+        self.firm.dividend_rate = rate
+
+    def pay_severance(self, employee: Household, amount: float) -> bool:
+        """
+        Pay severance to an employee.
+        """
+        if self.firm.assets >= amount:
+            self.firm.assets -= amount
+            employee.assets += amount
+            # Severance is an expense
+            self.record_expense(amount)
+            return True
+        return False
+
+    def pay_ad_hoc_tax(self, amount: float, tax_type: str, government: Any, current_time: int) -> bool:
+        """
+        Pay an ad-hoc tax (like automation tax).
+        """
+        if self.firm.assets >= amount:
+            self.firm.assets -= amount
+            government.collect_tax(amount, tax_type, self.firm.id, current_time)
+            # Taxes are expenses
+            self.record_expense(amount)
+            return True
+        return False
diff --git a/simulation/components/production_department.py b/simulation/components/production_department.py
index 9fbce19..372105e 100644
--- a/simulation/components/production_department.py
+++ b/simulation/components/production_department.py
@@ -105,3 +105,11 @@ class ProductionDepartment:
             logger.error(f'FIRM_CRASH_PREVENTED | Firm {self.firm.id}: {e}')
             logger.debug(traceback.format_exc())
             return 0.0
+
+    def add_capital(self, amount: float) -> None:
+        """Increases the firm's capital stock."""
+        self.firm.capital_stock += amount
+
+    def set_automation_level(self, level: float) -> None:
+        """Sets the firm's automation level (0.0 to 1.0)."""
+        self.firm.automation_level = max(0.0, min(1.0, level))
diff --git a/simulation/components/sales_department.py b/simulation/components/sales_department.py
index 8fe51fe..cf032d1 100644
--- a/simulation/components/sales_department.py
+++ b/simulation/components/sales_department.py
@@ -79,3 +79,7 @@ class SalesDepartment:
         # Update tracking
         self.firm.finance.last_revenue = self.firm.finance.revenue_this_turn
         self.firm.finance.last_marketing_spend = self.firm.marketing_budget
+
+    def set_price(self, item_id: str, price: float) -> None:
+        """Sets the price for a specific item."""
+        self.firm.last_prices[item_id] = price
diff --git a/simulation/decisions/corporate_manager.py b/simulation/decisions/corporate_manager.py
index 97b317f..76f73f2 100644
--- a/simulation/decisions/corporate_manager.py
+++ b/simulation/decisions/corporate_manager.py
@@ -130,7 +130,8 @@ class CorporateManager:
 
         price = stock_market.get_stock_price(firm.id)
         if price is None or price <= 0:
-            price = firm.get_book_value_per_share()
+            # SoC Refactor: Use FinanceDepartment
+            price = firm.finance.get_book_value_per_share()
 
         if price <= 0:
             return None
@@ -223,8 +224,9 @@ class CorporateManager:
         if actual_spend < 100.0:
             return
 
-        # Execute
-        firm.assets -= actual_spend
+        # Execute: SoC Refactor
+        if not firm.finance.invest_in_automation(actual_spend):
+             return
 
         # WO-044-Track-B: Automation Tax
         # Logic: actual_spend * AUTOMATION_TAX_RATE
@@ -232,10 +234,8 @@ class CorporateManager:
         tax_amount = actual_spend * automation_tax_rate
 
         if tax_amount > 0 and government:
-            if firm.assets >= tax_amount:
-                firm.assets -= tax_amount
-                government.collect_tax(tax_amount, "automation_tax", firm.id, current_time)
-
+            success = firm.finance.pay_ad_hoc_tax(tax_amount, "automation_tax", government, current_time)
+            if success:
                 self.logger.info(
                     f"AUTOMATION_TAX | Firm {firm.id} paid {tax_amount:.2f} tax on {actual_spend:.2f} investment.",
                     extra={"agent_id": firm.id, "tick": current_time, "tags": ["tax", "automation"]}
@@ -246,7 +246,8 @@ class CorporateManager:
         gained_pct = actual_spend / cost_per_pct
         gained_a = gained_pct / 100.0
 
-        firm.automation_level = min(1.0, firm.automation_level + gained_a)
+        # SoC Refactor
+        firm.production.set_automation_level(firm.automation_level + gained_a)
 
         self.logger.info(
             f"AUTOMATION | Firm {firm.id} invested {actual_spend:.1f}, level {current_a:.3f} -> {firm.automation_level:.3f}",
@@ -260,7 +261,8 @@ class CorporateManager:
         if aggressiveness <= 0.1:
             return
 
-        revenue_base = max(firm.revenue_this_turn, firm.assets * 0.05)
+        # SoC Refactor: use finance.revenue_this_turn
+        revenue_base = max(firm.finance.revenue_this_turn, firm.assets * 0.05)
         rd_budget_rate = aggressiveness * 0.20
         budget = revenue_base * rd_budget_rate
 
@@ -274,15 +276,20 @@ class CorporateManager:
         if budget < 10.0:
             return
 
-        firm.assets -= budget
+        # SoC Refactor
+        if not firm.finance.invest_in_rd(budget):
+            return
+
         firm.research_history["total_spent"] += budget
 
-        denominator = max(firm.revenue_this_turn * 0.2, 100.0)
+        # SoC Refactor: use finance.revenue_this_turn
+        denominator = max(firm.finance.revenue_this_turn * 0.2, 100.0)
         base_chance = min(1.0, budget / denominator)
 
         avg_skill = 1.0
-        if firm.employees:
-            avg_skill = sum(getattr(e, 'labor_skill', 1.0) for e in firm.employees) / len(firm.employees)
+        # SoC Refactor: use hr.employees
+        if firm.hr.employees:
+            avg_skill = sum(getattr(e, 'labor_skill', 1.0) for e in firm.hr.employees) / len(firm.hr.employees)
 
         success_chance = base_chance * avg_skill
 
@@ -318,14 +325,17 @@ class CorporateManager:
         if budget < 100.0:
             return
 
-        firm.assets -= budget
+        # SoC Refactor
+        if not firm.finance.invest_in_capex(budget):
+            return
 
         if reflux_system:
              reflux_system.capture(budget, str(firm.id), "capex")
 
         efficiency = 1.0 / getattr(self.config_module, "CAPITAL_TO_OUTPUT_RATIO", 2.0)
         added_capital = budget * efficiency
-        firm.capital_stock += added_capital
+        # SoC Refactor
+        firm.production.add_capital(added_capital)
 
         self.logger.info(
             f"CAPEX | Firm {firm.id} invested {budget:.1f}, added {added_capital:.1f} capital.",
@@ -338,7 +348,8 @@ class CorporateManager:
         """
         base_rate = getattr(self.config_module, "DIVIDEND_RATE_MIN", 0.1)
         max_rate = getattr(self.config_module, "DIVIDEND_RATE_MAX", 0.5)
-        firm.dividend_rate = base_rate + (aggressiveness * (max_rate - base_rate))
+        # SoC Refactor
+        firm.finance.set_dividend_rate(base_rate + (aggressiveness * (max_rate - base_rate)))
 
     def _manage_debt(self, firm: Firm, aggressiveness: float, market_data: Dict) -> List[Order]:
         """
@@ -397,20 +408,35 @@ class CorporateManager:
         adjustment = (0.5 - aggressiveness) * 0.4
         target_price = market_price * (1.0 + adjustment)
 
-        sales_vol = getattr(firm, 'last_sales_volume', 1.0)
+        # SoC Refactor: use finance.last_sales_volume
+        sales_vol = getattr(firm.finance, 'last_sales_volume', 1.0)
         if sales_vol <= 0: sales_vol = 1.0
         days_on_hand = current_inventory / sales_vol
         decay = max(0.5, 1.0 - (days_on_hand * 0.005))
         target_price *= decay
 
         target_price = max(target_price, 0.1)
-        firm.last_prices[item_id] = target_price
+        # SoC Refactor
+        firm.sales.set_price(item_id, target_price)
 
         qty = min(current_inventory, self.config_module.MAX_SELL_QUANTITY)
 
         target_market = markets.get(item_id)
         if target_market:
-            firm.post_ask(item_id, target_price, qty, target_market, current_time)
+            # firm.post_ask is a method on Firm, but it delegates to Sales.
+            # CorporateManager calls firm.post_ask. Spec says "Update Firm Internal Methods... make_decision... access sub-components".
+            # CorporateManager is calling firm.post_ask. Should it call firm.sales.post_ask?
+            # Spec says "External modules ... directly manipulate internal state".
+            # `post_ask` on `Firm` is a method, not a property.
+            # Spec mainly targets wrapper properties.
+            # However, for consistency, I can use `firm.sales.post_ask` IF `Firm`'s `post_ask` is just a wrapper.
+            # Let's check `Firm.post_ask` again.
+            # Yes: return self.sales.post_ask(item_id, price, quantity, market, current_tick)
+            # So I should use firm.sales.post_ask directly to be "Pure Orchestrator".
+            # But the orchestrator (Firm) might want to log or do things?
+            # Actually, `Firm.post_ask` IS the wrapper.
+            # So I will use `firm.sales.post_ask`.
+            firm.sales.post_ask(item_id, target_price, qty, target_market, current_time)
 
         return None
 
@@ -454,7 +480,8 @@ class CorporateManager:
         # Soft limit removed to allow full employment
         needed_labor = int(needed_labor_calc) + 1
 
-        current_employees = len(firm.employees)
+        # SoC Refactor: use hr.employees
+        current_employees = len(firm.hr.employees)
 
         # A. Firing Logic (Layoffs)
         if current_employees > needed_labor:
@@ -475,24 +502,23 @@ class CorporateManager:
                 # Actually we should iterate copy to modify list safely?
                 # No, we just call employee.quit().
                 # We need to pick employees.
-                candidates = firm.employees[:fire_count] # FIFO firing
+                candidates = firm.hr.employees[:fire_count] # FIFO firing
 
                 # WO-044-Track-C: Strategic Firing Severance Check
                 severance_weeks = getattr(self.config_module, "SEVERANCE_PAY_WEEKS", 4)
 
                 for emp in candidates:
                     # Estimate wage (Strategic firing happens before update_needs, so check current wage)
-                    wage = firm.employee_wages.get(emp.id, self.config_module.LABOR_MARKET_MIN_WAGE)
+                    # SoC Refactor: use hr.employee_wages
+                    wage = firm.hr.employee_wages.get(emp.id, self.config_module.LABOR_MARKET_MIN_WAGE)
                     # Correct for skill
                     skill = getattr(emp, 'labor_skill', 1.0)
                     wage *= skill
 
                     severance_pay = wage * severance_weeks
 
-                    if firm.assets >= severance_pay:
-                        firm.assets -= severance_pay
-                        emp.assets += severance_pay
-
+                    # SoC Refactor: use finance.pay_severance
+                    if firm.finance.pay_severance(emp, severance_pay):
                         emp.quit()
                         self.logger.info(
                             f"LAYOFF | Firm {firm.id} laid off Household {emp.id} with Severance {severance_pay:.2f}. Excess labor.",
@@ -545,7 +571,8 @@ class CorporateManager:
         WO-047-B: Competitive Bidding Logic.
         If firm has vacancies and is solvent, bid up the wage.
         """
-        current_employees = len(firm.employees)
+        # SoC Refactor
+        current_employees = len(firm.hr.employees)
         vacancies = max(0, needed_labor - current_employees)
         
         if vacancies <= 0:
@@ -562,7 +589,8 @@ class CorporateManager:
         # 2. Wage Bill Cap Check (Fallback for 0 liabilities)
         # Check if we have enough cash runway (e.g., 2 ticks)
         # Using current wage bill as proxy
-        wage_bill = sum(firm.employee_wages.values()) if firm.employee_wages else 0.0
+        # SoC Refactor: use hr.employee_wages
+        wage_bill = sum(firm.hr.employee_wages.values()) if firm.hr.employee_wages else 0.0
         if wage_bill > 0 and firm.assets < wage_bill * 2: 
              return base_offer_wage
 
diff --git a/simulation/decisions/rule_based_firm_engine.py b/simulation/decisions/rule_based_firm_engine.py
index 622d02e..7e69c89 100644
--- a/simulation/decisions/rule_based_firm_engine.py
+++ b/simulation/decisions/rule_based_firm_engine.py
@@ -109,7 +109,8 @@ class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
         needed_labor = self._calculate_needed_labor(firm)
         offered_wage = self._calculate_dynamic_wage_offer(firm)
 
-        if len(firm.employees) < self.config_module.FIRM_MIN_EMPLOYEES:
+        # SoC Refactor: use hr.employees
+        if len(firm.hr.employees) < self.config_module.FIRM_MIN_EMPLOYEES:
             order = Order(firm.id, "BUY", "labor", 1.0, offered_wage, "labor_market")
             orders.append(order)
             self.logger.info(
@@ -121,8 +122,8 @@ class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
                 },
             )
         elif (
-            needed_labor > len(firm.employees)
-            and len(firm.employees) < self.config_module.FIRM_MAX_EMPLOYEES
+            needed_labor > len(firm.hr.employees)
+            and len(firm.hr.employees) < self.config_module.FIRM_MAX_EMPLOYEES
         ):
             order = Order(firm.id, "BUY", "labor", 1.0, offered_wage, "labor_market")
             orders.append(order)
@@ -153,10 +154,11 @@ class RuleBasedFirmDecisionEngine(BaseDecisionEngine):
 
     def _calculate_dynamic_wage_offer(self, firm: Firm) -> float:
         """ê¸°ì—…ì˜ ìˆ˜ìµì„± ì´ë ¥ì„ ë°”íƒ•ìœ¼ë¡œ ë™ì ì¸ ì„ê¸ˆ ì œì‹œì•¡ì„ ê³„ì‚°í•©ë‹ˆë‹¤."""
-        if not firm.profit_history:
+        # SoC Refactor: use finance.profit_history
+        if not firm.finance.profit_history:
             return self.config_module.BASE_WAGE
 
-        avg_profit = sum(firm.profit_history) / len(firm.profit_history)
+        avg_profit = sum(firm.finance.profit_history) / len(firm.finance.profit_history)
         profit_based_premium = avg_profit / (self.config_module.BASE_WAGE * 10.0)
         wage_premium = max(
             0,
diff --git a/simulation/decisions/standalone_rule_based_firm_engine.py b/simulation/decisions/standalone_rule_based_firm_engine.py
index 7513f90..b7276af 100644
--- a/simulation/decisions/standalone_rule_based_firm_engine.py
+++ b/simulation/decisions/standalone_rule_based_firm_engine.py
@@ -78,8 +78,9 @@ class StandaloneRuleBasedFirmDecisionEngine(BaseDecisionEngine):
         # í˜„ì¬ ìƒì‚° ëª©í‘œì™€ ì‹¤ì œ ìƒì‚°ëŸ‰, ê³ ìš© ì¸ì› ë“±ì„ ê³ ë ¤í•˜ì—¬ ì„ê¸ˆ ë° ê³ ìš© ê²°ì • ë¡œì§ ì¶”ê°€
         if chosen_tactic != Tactic.ADJUST_PRODUCTION: # ì´ë¯¸ ìƒì‚° ì¡°ì • ê²°ì •ì„ í–ˆìœ¼ë©´ ì´ë²ˆ í„´ì— ì„ê¸ˆ ì¡°ì •ì€ ê±´ë„ˆë›´ë‹¤ (ê°„ë‹¨í™”ë¥¼ ìœ„í•´)
             needed_labor_for_production = self.rule_based_executor._calculate_needed_labor(firm)
-            if len(firm.employees) < needed_labor_for_production * self.config_module.FIRM_LABOR_REQUIREMENT_RATIO or \
-               len(firm.employees) < self.config_module.FIRM_MIN_EMPLOYEES:
+            # SoC Refactor: use hr.employees
+            if len(firm.hr.employees) < needed_labor_for_production * self.config_module.FIRM_LABOR_REQUIREMENT_RATIO or \
+               len(firm.hr.employees) < self.config_module.FIRM_MIN_EMPLOYEES:
                 chosen_tactic = Tactic.ADJUST_WAGES # ADJUST_WAGES ì „ìˆ ì— ê³ ìš© ë¡œì§ë„ í¬í•¨ë˜ì–´ ìˆìŒ
                 orders.extend(self.rule_based_executor._adjust_wages(firm, current_time, market_data))
                 self.logger.info(
@@ -172,7 +173,8 @@ class StandaloneRuleBasedFirmDecisionEngine(BaseDecisionEngine):
                 0.1, # Absolute hard floor to prevent zero/negative
                 min(self.config_module.MAX_SELL_PRICE, adjusted_price),
             )
-            firm.last_prices[item_id] = final_price
+            # SoC Refactor: use sales.set_price
+            firm.sales.set_price(item_id, final_price)
 
             quantity_to_sell = min(
                 current_inventory, self.config_module.MAX_SELL_QUANTITY
diff --git a/simulation/firms.py b/simulation/firms.py
index 61ba8ce..ea6d6cf 100644
--- a/simulation/firms.py
+++ b/simulation/firms.py
@@ -101,10 +101,6 @@ class Firm(BaseAgent, ILearningAgent):
             config_module.FIRM_MIN_PRODUCTION_TARGET
         )  # Initialize production target
 
-        # Property redirections for compatibility
-        # self.employees -> self.hr.employees
-        # self.employee_wages -> self.hr.employee_wages
-
         self.current_production: float = 0.0
         self.productivity_factor: float = productivity_factor
         self.total_shares: float = getattr(config_module, "IPO_INITIAL_SHARES", 1000.0)
@@ -155,163 +151,6 @@ class Firm(BaseAgent, ILearningAgent):
             extra={"agent_id": self.id, "tags": ["ipo", "stock_market"]}
         )
 
-    # --- Properties to maintain Interface Compatibility ---
-    @property
-    def employees(self) -> List[Household]:
-        return self.hr.employees
-
-    @employees.setter
-    def employees(self, value):
-        self.hr.employees = value
-
-    @property
-    def employee_wages(self) -> Dict[int, float]:
-        return self.hr.employee_wages
-
-    @employee_wages.setter
-    def employee_wages(self, value):
-        self.hr.employee_wages = value
-
-    @property
-    def retained_earnings(self) -> float:
-        return self.finance.retained_earnings
-
-    @retained_earnings.setter
-    def retained_earnings(self, value):
-        self.finance.retained_earnings = value
-
-    @property
-    def dividends_paid_last_tick(self) -> float:
-        return self.finance.dividends_paid_last_tick
-
-    @dividends_paid_last_tick.setter
-    def dividends_paid_last_tick(self, value):
-        self.finance.dividends_paid_last_tick = value
-
-    @property
-    def consecutive_loss_turns(self) -> int:
-        return self.finance.consecutive_loss_turns
-
-    @consecutive_loss_turns.setter
-    def consecutive_loss_turns(self, value):
-        self.finance.consecutive_loss_turns = value
-
-    @property
-    def current_profit(self) -> float:
-        return self.finance.current_profit
-
-    @current_profit.setter
-    def current_profit(self, value):
-        self.finance.current_profit = value
-
-    @property
-    def revenue_this_turn(self) -> float:
-        return self.finance.revenue_this_turn
-
-    @revenue_this_turn.setter
-    def revenue_this_turn(self, value):
-        self.finance.revenue_this_turn = value
-
-    @property
-    def cost_this_turn(self) -> float:
-        return self.finance.cost_this_turn
-
-    @cost_this_turn.setter
-    def cost_this_turn(self, value):
-        self.finance.cost_this_turn = value
-
-    @property
-    def revenue_this_tick(self) -> float:
-        return self.finance.revenue_this_tick
-
-    @revenue_this_tick.setter
-    def revenue_this_tick(self, value):
-        self.finance.revenue_this_tick = value
-
-    @property
-    def expenses_this_tick(self) -> float:
-        return self.finance.expenses_this_tick
-
-    @expenses_this_tick.setter
-    def expenses_this_tick(self, value):
-        self.finance.expenses_this_tick = value
-
-    @property
-    def profit_history(self) -> deque[float]:
-        return self.finance.profit_history
-
-    @profit_history.setter
-    def profit_history(self, value):
-        self.finance.profit_history = value
-
-    @property
-    def last_revenue(self) -> float:
-        return self.finance.last_revenue
-
-    @last_revenue.setter
-    def last_revenue(self, value):
-        self.finance.last_revenue = value
-
-    @property
-    def last_marketing_spend(self) -> float:
-        return self.finance.last_marketing_spend
-
-    @last_marketing_spend.setter
-    def last_marketing_spend(self, value):
-        self.finance.last_marketing_spend = value
-
-    @property
-    def last_daily_expenses(self) -> float:
-        return self.finance.last_daily_expenses
-
-    @last_daily_expenses.setter
-    def last_daily_expenses(self, value):
-        self.finance.last_daily_expenses = value
-
-    @property
-    def last_sales_volume(self) -> float:
-        return self.finance.last_sales_volume
-
-    @last_sales_volume.setter
-    def last_sales_volume(self, value):
-        self.finance.last_sales_volume = value
-
-    @property
-    def sales_volume_this_tick(self) -> float:
-        return self.finance.sales_volume_this_tick
-
-    @sales_volume_this_tick.setter
-    def sales_volume_this_tick(self, value):
-        self.finance.sales_volume_this_tick = value
-
-
-    def calculate_valuation(self) -> float:
-        """
-        Calculate Firm Valuation based on Net Assets + Profit Potential.
-        Formula: Net Assets + (Max(0, Avg_Profit_Last_10) * PER Multiplier)
-        """
-        return self.finance.calculate_valuation()
-
-    @property
-    def price(self) -> float:
-        """Helper property to get the price of the specialized good."""
-        return self.last_prices.get(self.specialization, 0.0)
-
-    @price.setter
-    def price(self, value: float) -> None:
-        self.last_prices[self.specialization] = value
-
-    def get_inventory_value(self) -> float:
-        """Calculate market value of current inventory."""
-        return self.finance.get_inventory_value()
-
-    def get_financial_snapshot(self) -> Dict[str, float]:
-        """
-        Returns a standardized dictionary of financial metrics for monitoring and analysis.
-        This provides a stable interface for CrisisMonitor and FinanceSystem.
-        """
-        return self.finance.get_financial_snapshot()
-
     def liquidate_assets(self) -> float:
         """
         Liquidate assets.
@@ -371,36 +210,6 @@ class Firm(BaseAgent, ILearningAgent):
     def produce(self, current_time: int, technology_manager: Optional[Any] = None) -> None:
         self.current_production = self.production.produce(current_time, technology_manager)
 
-    def issue_shares(self, quantity: float, price: float) -> float:
-        """
-        ì‹ ê·œ ì£¼ì‹ì„ ë°œí–‰í•©ë‹ˆë‹¤ (ìœ ìƒì¦ì).
-        
-        Args:
-            quantity: ë°œí–‰í•  ì£¼ì‹ ìˆ˜ëŸ‰
-            price: ì£¼ë‹¹ ë°œí–‰ ê°€ê²©
-            
-        Returns:
-            ì¡°ë‹¬ëœ ìë³¸ê¸ˆ
-        """
-        return self.finance.issue_shares(quantity, price)
-
-    def get_book_value_per_share(self) -> float:
-        """ì£¼ë‹¹ ìˆœìì‚°ê°€ì¹˜(BPS)ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤. (ìœ í†µì£¼ì‹ìˆ˜ ê¸°ì¤€)"""
-        return self.finance.get_book_value_per_share()
-
-    def get_market_cap(self, stock_price: Optional[float] = None) -> float:
-        """
-        ì‹œê°€ì´ì•¡ì„ ê³„ì‚°í•©ë‹ˆë‹¤.
-        
-        Args:
-            stock_price: ì£¼ê°€ (Noneì´ë©´ ìˆœìì‚°ê°€ì¹˜ ê¸°ë°˜ ê³„ì‚°)
-            
-        Returns:
-            ì‹œê°€ì´ì•¡
-        """
-        return self.finance.get_market_cap(stock_price)
-
-
     @override
     def clone(self, new_id: int, initial_assets_from_parent: float, current_tick: int) -> "Firm":
         """
@@ -433,10 +242,6 @@ class Firm(BaseAgent, ILearningAgent):
         )
         return new_firm
 
-    def distribute_dividends(self, households: List[Household], government: "Government", current_time: int) -> List[Transaction]:
-        # SoC Refactor
-        return self.finance.process_profit_distribution(households, government, current_time)
-
     @override
     def get_agent_data(self) -> Dict[str, Any]:
         """AI ì˜ì‚¬ê²°ì •ì— í•„ìš”í•œ ì—ì´ì „íŠ¸ì˜ í˜„ì¬ ìƒíƒœ ë°ì´í„°ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."""
@@ -445,14 +250,16 @@ class Firm(BaseAgent, ILearningAgent):
             "needs": self.needs.copy(),
             "inventory": self.inventory.copy(),
             "input_inventory": self.input_inventory.copy(), # WO-030
-            "employees": [emp.id for emp in self.employees],  # Only pass employee IDs
+            # SoC Refactor
+            "employees": [emp.id for emp in self.hr.employees],  # Only pass employee IDs
             "is_active": self.is_active,
             "current_production": self.current_production,
             "productivity_factor": self.productivity_factor,
             "production_target": self.production_target,
-            "revenue_this_turn": self.revenue_this_turn,
-            "expenses_this_tick": self.expenses_this_tick,
-            "consecutive_loss_turns": self.consecutive_loss_turns,
+            # SoC Refactor
+            "revenue_this_turn": self.finance.revenue_this_turn,
+            "expenses_this_tick": self.finance.expenses_this_tick,
+            "consecutive_loss_turns": self.finance.consecutive_loss_turns,
             "total_shares": self.total_shares,
             "treasury_shares": self.treasury_shares,
             "dividend_rate": self.dividend_rate,
@@ -472,12 +279,13 @@ class Firm(BaseAgent, ILearningAgent):
         self, markets: Dict[str, Any], goods_data: list[Dict[str, Any]], market_data: Dict[str, Any], current_time: int, government: Optional[Any] = None, reflux_system: Optional[Any] = None, stress_scenario_config: Optional["StressScenarioConfig"] = None
     ) -> tuple[list[Order], Any]:
         log_extra = {"tick": current_time, "agent_id": self.id, "tags": ["firm_action"]}
+        # SoC Refactor
         self.logger.debug(
-            f"FIRM_DECISION_START | Firm {self.id} before decision: Assets={self.assets:.2f}, Employees={len(self.employees)}, is_active={self.is_active}",
+            f"FIRM_DECISION_START | Firm {self.id} before decision: Assets={self.assets:.2f}, Employees={len(self.hr.employees)}, is_active={self.is_active}",
             extra={
                 **log_extra,
                 "assets_before": self.assets,
-                "num_employees_before": len(self.employees),
+                "num_employees_before": len(self.hr.employees),
                 "is_active_before": self.is_active,
             },
         )
@@ -496,12 +304,13 @@ class Firm(BaseAgent, ILearningAgent):
         # WO-056: Shadow Mode Calculation
         self._calculate_invisible_hand_price(markets, current_time)
 
+        # SoC Refactor
         self.logger.debug(
-            f"FIRM_DECISION_END | Firm {self.id} after decision: Assets={self.assets:.2f}, Employees={len(self.employees)}, is_active={self.is_active}, Decisions={len(decisions)}",
+            f"FIRM_DECISION_END | Firm {self.id} after decision: Assets={self.assets:.2f}, Employees={len(self.hr.employees)}, is_active={self.is_active}, Decisions={len(decisions)}",
             extra={
                 **log_extra,
                 "assets_after": self.assets,
-                "num_employees_after": len(self.employees),
+                "num_employees_after": len(self.hr.employees),
                 "is_active_after": self.is_active,
                 "num_decisions": len(decisions),
             },
@@ -560,13 +369,14 @@ class Firm(BaseAgent, ILearningAgent):
     @override
     def update_needs(self, current_time: int, government: Optional[Any] = None, market_data: Optional[Dict[str, Any]] = None, reflux_system: Optional[Any] = None, technology_manager: Optional[Any] = None) -> None:
         log_extra = {"tick": current_time, "agent_id": self.id, "tags": ["firm_needs"]}
+        # SoC Refactor
         self.logger.debug(
-            f"FIRM_NEEDS_UPDATE_START | Firm {self.id} needs before update: Liquidity={self.needs['liquidity_need']:.1f}, Assets={self.assets:.2f}, Employees={len(self.employees)}",
+            f"FIRM_NEEDS_UPDATE_START | Firm {self.id} needs before update: Liquidity={self.needs['liquidity_need']:.1f}, Assets={self.assets:.2f}, Employees={len(self.hr.employees)}",
             extra={
                 **log_extra,
                 "needs_before": self.needs,
                 "assets_before": self.assets,
-                "num_employees_before": len(self.employees),
+                "num_employees_before": len(self.hr.employees),
             },
         )
 
@@ -592,12 +402,13 @@ class Firm(BaseAgent, ILearningAgent):
         if total_wages > 0:
             self.finance.record_expense(total_wages)
             self.logger.info(
-                f"Paid total wages: {total_wages:.2f} to {len(self.employees)} employees.",
+                f"Paid total wages: {total_wages:.2f} to {len(self.hr.employees)} employees.",
                 extra={**log_extra, "total_wages": total_wages},
             )
 
         # 3. Marketing & Brand Update
         marketing_spend = 0.0
+        # SoC Refactor
         if self.assets > 100.0:
             marketing_spend = max(10.0, self.finance.revenue_this_turn * self.marketing_budget_rate)
         
@@ -635,25 +446,26 @@ class Firm(BaseAgent, ILearningAgent):
         self.needs["liquidity_need"] = min(100.0, self.needs["liquidity_need"] + self.config_module.LIQUIDITY_NEED_INCREASE_RATE)
         self.finance.check_bankruptcy()
 
-        if self.assets <= self.config_module.ASSETS_CLOSURE_THRESHOLD or self.consecutive_loss_turns >= self.config_module.FIRM_CLOSURE_TURNS_THRESHOLD:
+        # SoC Refactor
+        if self.assets <= self.config_module.ASSETS_CLOSURE_THRESHOLD or self.finance.consecutive_loss_turns >= self.config_module.FIRM_CLOSURE_TURNS_THRESHOLD:
             self.is_active = False
             self.logger.warning(
-                f"FIRM_INACTIVE | Firm {self.id} closed down. Assets: {self.assets:.2f}, Consecutive Loss Turns: {self.consecutive_loss_turns}",
+                f"FIRM_INACTIVE | Firm {self.id} closed down. Assets: {self.assets:.2f}, Consecutive Loss Turns: {self.finance.consecutive_loss_turns}",
                 extra={
                     **log_extra,
                     "assets": self.assets,
-                    "consecutive_loss_turns": self.consecutive_loss_turns,
+                    "consecutive_loss_turns": self.finance.consecutive_loss_turns,
                     "tags": ["firm_closure"],
                 },
             )
 
         self.logger.debug(
-            f"FIRM_NEEDS_UPDATE_END | Firm {self.id} needs after update: Liquidity={self.needs['liquidity_need']:.1f}, Assets={self.assets:.2f}, Employees={len(self.employees)}, is_active={self.is_active}",
+            f"FIRM_NEEDS_UPDATE_END | Firm {self.id} needs after update: Liquidity={self.needs['liquidity_need']:.1f}, Assets={self.assets:.2f}, Employees={len(self.hr.employees)}, is_active={self.is_active}",
             extra={
                 **log_extra,
                 "needs_after": self.needs,
                 "assets_after": self.assets,
-                "num_employees_after": len(self.employees),
+                "num_employees_after": len(self.hr.employees),
                 "is_active_after": self.is_active,
                 "brand_awareness": self.brand_manager.brand_awareness,
                 "perceived_quality": self.brand_manager.perceived_quality
diff --git a/simulation/systems/lifecycle_manager.py b/simulation/systems/lifecycle_manager.py
index eb76be4..ea7438a 100644
--- a/simulation/systems/lifecycle_manager.py
+++ b/simulation/systems/lifecycle_manager.py
@@ -88,11 +88,12 @@ class AgentLifecycleManager(AgentLifecycleManagerInterface):
                 f"Assets: {firm.assets:.2f}, Inventory: {sum(firm.inventory.values()):.2f}",
                 extra={"agent_id": firm.id, "tags": ["liquidation"]}
             )
-            for employee in firm.employees:
+            # SoC Refactor: use hr.employees
+            for employee in firm.hr.employees:
                 if employee.is_active:
                     employee.is_employed = False
                     employee.employer_id = None
-            firm.employees = []
+            firm.hr.employees = []
             firm.inventory.clear()
             firm.capital_stock = 0.0
             total_cash = firm.assets
@@ -142,6 +143,7 @@ class AgentLifecycleManager(AgentLifecycleManagerInterface):
         sim.agents[sim.bank.id] = sim.bank
 
         for firm in sim.firms:
-            firm.employees = [
-                emp for emp in firm.employees if emp.is_active and emp.id in sim.agents
+            # SoC Refactor: use hr.employees
+            firm.hr.employees = [
+                emp for emp in firm.hr.employees if emp.is_active and emp.id in sim.agents
             ]
diff --git a/simulation/systems/ma_manager.py b/simulation/systems/ma_manager.py
index 45cbe2d..8764567 100644
--- a/simulation/systems/ma_manager.py
+++ b/simulation/systems/ma_manager.py
@@ -53,7 +53,8 @@ class MAManager:
                 continue
             
             # Standard Distress (Friendly M&A)
-            if firm.consecutive_loss_turns >= self.bankruptcy_loss_threshold:
+            # SoC Refactor: use finance.consecutive_loss_turns
+            if firm.finance.consecutive_loss_turns >= self.bankruptcy_loss_threshold:
                  preys.append(firm)
             elif firm.assets < avg_assets * 0.2:
                 preys.append(firm)
@@ -83,7 +84,8 @@ class MAManager:
             # Or just be rich.
             # Phase 21 Spec: Predator Assets > Target Market Cap * 1.5.
             # Let's filter later. Just identify rich firms.
-            if firm.assets > avg_assets * 1.5 and firm.current_profit > 0:
+            # SoC Refactor: use finance.current_profit
+            if firm.assets > avg_assets * 1.5 and firm.finance.current_profit > 0:
                 predators.append(firm)
 
         # 2. M&A Matching Loop
@@ -186,7 +188,8 @@ class MAManager:
              self.simulation.households_dict[prey.founder_id].assets += price
         
         # 2. Asset Transfer
-        predator.capital_stock += prey.capital_stock
+        # SoC Refactor: use production.add_capital
+        predator.production.add_capital(prey.capital_stock)
         
         # Phase 21: Transfer Automation Tech?
         # If prey has higher automation, predator learns?
@@ -194,7 +197,8 @@ class MAManager:
         # Let's say Predator keeps their own logic, maybe slight boost if Prey was advanced.
         if hasattr(prey, "automation_level") and hasattr(predator, "automation_level"):
             if prey.automation_level > predator.automation_level:
-                predator.automation_level = (predator.automation_level + prey.automation_level) / 2.0
+                new_level = (predator.automation_level + prey.automation_level) / 2.0
+                predator.production.set_automation_level(new_level)
 
         # Inventory
         for item, qty in prey.inventory.items():
@@ -207,16 +211,17 @@ class MAManager:
         # Hostile Takeovers often have deeper cuts
         retention_rate = 0.3 if is_hostile else 0.5
 
-        for emp in list(prey.employees):
+        # SoC Refactor: use hr.employees and hr.hire
+        for emp in list(prey.hr.employees):
             if random.random() > retention_rate:
                 # Fire
                 emp.quit()
                 fired_count += 1
             else:
                 # Retain
-                prey.employees.remove(emp)
-                predator.employees.append(emp)
-                predator.employee_wages[emp.id] = prey.employee_wages.get(emp.id, 10.0)
+                prey.hr.remove_employee(emp)
+                wage = prey.hr.employee_wages.get(emp.id, 10.0)
+                predator.hr.hire(emp, wage)
                 emp.employer_id = predator.id
                 retained_count += 1
                 
@@ -229,7 +234,8 @@ class MAManager:
         recovered = firm.liquidate_assets()
         self.logger.info(f"BANKRUPTCY | Firm {firm.id} liquidated. Recovered Cash: {recovered:,.2f}.")
         
-        for emp in list(firm.employees):
+        # SoC Refactor: use hr.employees
+        for emp in list(firm.hr.employees):
             emp.quit()
             
         firm.is_active = False
diff --git a/simulation/systems/transaction_processor.py b/simulation/systems/transaction_processor.py
index a4d7830..e078897 100644
--- a/simulation/systems/transaction_processor.py
+++ b/simulation/systems/transaction_processor.py
@@ -110,8 +110,9 @@ class TransactionProcessor:
         if isinstance(seller, Household):
             if seller.is_employed and seller.employer_id is not None and seller.employer_id != buyer.id:
                 previous_employer = agents.get(seller.employer_id)
-                if isinstance(previous_employer, Firm) and seller in previous_employer.employees:
-                    previous_employer.employees.remove(seller)
+                if isinstance(previous_employer, Firm):
+                    # SoC Refactor: Use HRDepartment
+                    previous_employer.hr.remove_employee(seller)
 
             seller.is_employed = True
             seller.employer_id = buyer.id
@@ -121,10 +122,13 @@ class TransactionProcessor:
                 seller.labor_income_this_tick += (trade_value - tax_amount)
 
         if isinstance(buyer, Firm):
-            if seller not in buyer.employees:
-                buyer.employees.append(seller)
-            buyer.employee_wages[seller.id] = tx.price
-            buyer.cost_this_turn += trade_value
+            # SoC Refactor: Use HRDepartment and FinanceDepartment
+            if seller not in buyer.hr.employees:
+                buyer.hr.hire(seller, tx.price)
+            else:
+                 buyer.hr.employee_wages[seller.id] = tx.price
+
+            buyer.finance.record_expense(trade_value)
 
             if tx.transaction_type == "research_labor":
                 research_skill = seller.skills.get("research", Skill("research")).value
@@ -154,8 +158,9 @@ class TransactionProcessor:
                 buyer.inventory[tx.item_id] = total_new_qty
 
         if isinstance(seller, Firm):
-            seller.revenue_this_turn += trade_value
-            seller.sales_volume_this_tick += tx.quantity
+            # SoC Refactor: Use FinanceDepartment
+            seller.finance.record_revenue(trade_value)
+            seller.finance.sales_volume_this_tick += tx.quantity
         
         if isinstance(buyer, Household):
             if not is_service:
diff --git a/tests/test_corporate_manager.py b/tests/test_corporate_manager.py
index 876dc8c..3fb5018 100644
--- a/tests/test_corporate_manager.py
+++ b/tests/test_corporate_manager.py
@@ -15,6 +15,11 @@ class MockConfig:
     MAX_SELL_QUANTITY = 100
     LABOR_MARKET_MIN_WAGE = 10.0
     GOODS = {"food": {"production_cost": 10.0}}
+    # Added for automation
+    AUTOMATION_COST_PER_PCT = 1000.0
+    FIRM_SAFETY_MARGIN = 2000.0
+    AUTOMATION_TAX_RATE = 0.05
+    SEVERANCE_PAY_WEEKS = 4
 
 @pytest.fixture
 def firm_mock(golden_firms):
@@ -22,16 +27,57 @@ def firm_mock(golden_firms):
         pytest.skip("Golden firms fixture is empty or failed to load.")
     firm = golden_firms[0]
 
-    # Customize the golden firm for specific tests if needed,
-    # but the goal is to rely on realistic data.
-    # Resetting some values to ensure consistent test state regardless of fixture content
-    # is still reasonable, but we should avoid full mock reconstruction.
-
-    firm.revenue_this_turn = 200.0
+    # Initialize BaseAgent fields
+    firm.assets = 10000.0 # Default assets
+
+    # --- SoC Components Mocking ---
+    firm.finance = MagicMock()
+    firm.finance.revenue_this_turn = 200.0
+    firm.finance.last_sales_volume = 1.0
+    firm.finance.last_revenue = 200.0
+
+    # Side effects to simulate real behavior on mock firm assets
+    def invest_side_effect(amount):
+        firm.assets -= amount
+        return True
+
+    def pay_tax_side_effect(amount, *args, **kwargs):
+        firm.assets -= amount
+        return True
+
+    def pay_severance_side_effect(emp, amount):
+        firm.assets -= amount
+        # emp is a mock, so emp.assets update is mocked
+        if hasattr(emp, 'assets'):
+             emp.assets += amount
+        return True
+
+    def set_dividend_rate_side_effect(rate):
+        firm.dividend_rate = rate
+
+    firm.finance.invest_in_automation.side_effect = invest_side_effect
+    firm.finance.invest_in_rd.side_effect = invest_side_effect
+    firm.finance.invest_in_capex.side_effect = invest_side_effect
+    firm.finance.pay_severance.side_effect = pay_severance_side_effect
+    firm.finance.pay_ad_hoc_tax.side_effect = pay_tax_side_effect
+    firm.finance.set_dividend_rate.side_effect = set_dividend_rate_side_effect
+    firm.finance.get_book_value_per_share.return_value = 10.0 # Default BPS
+
+    firm.hr = MagicMock()
+    firm.hr.employees = []
+    firm.hr.employee_wages = {}
+
+    firm.production = MagicMock()
+    firm.production.set_automation_level.side_effect = lambda x: setattr(firm, 'automation_level', x)
+    firm.production.add_capital.side_effect = lambda x: setattr(firm, 'capital_stock', firm.capital_stock + x)
+
+    firm.sales = MagicMock()
+    firm.sales.set_price.side_effect = lambda item, price: firm.last_prices.update({item: price})
+
+    # --- Firm Attributes ---
     firm.production_target = 100
     firm.productivity_factor = 1.0
     firm.specialization = "food"
-    # Ensure inventory is dictionary as expected by tests
     if not isinstance(firm.inventory, dict):
         firm.inventory = {"food": 50}
     else:
@@ -44,27 +90,14 @@ def firm_mock(golden_firms):
     firm.total_shares = 100
     firm.treasury_shares = 0
     firm.last_prices = {"food": 10.0}
-    firm.employees = []
-    # firm.personality is likely already set in golden fixture, but ensuring it matches test expectation if crucial
     firm.personality = Personality.BALANCED
 
-    # Ensuring attributes that might be missing in older fixtures or dynamic properties
-    firm.system2_planner = None # Force to None to avoid unconfigured mock issues in guidance
-    firm.revenue_this_turn = 200.0 # explicit float
-    firm.last_revenue = 200.0
-    if not hasattr(firm, 'last_revenue'):
-        firm.last_revenue = 200.0
-    firm.expenses_this_tick = 50.0
-    firm.retained_earnings = 1000.0
-    # firm.profit_history = [] # Let's keep history if it exists
-    firm.employee_wages = {}
+    firm.system2_planner = None
     firm.consecutive_loss_ticks_for_bankruptcy_threshold = 5
     firm.automation_level = 0.0
-    firm.last_sales_volume = 1.0 # Fix for the TypeError seen in previous run
-    firm.total_debt = 0.0 # Ensure total_debt is float
-    firm.bond_obligations = [] # Add bond obligations
+    firm.total_debt = 0.0
+    firm.bond_obligations = []
 
-    # Ensure decision_engine chain works for _get_total_liabilities
     if not hasattr(firm, 'decision_engine'):
         firm.decision_engine = MagicMock()
 
@@ -106,7 +139,7 @@ def test_rd_logic(firm_mock, context_mock, monkeypatch):
 
     # Need enough assets to pass safety margin (default 2000)
     firm_mock.assets = 10000.0
-    firm_mock.revenue_this_turn = 1000.0
+    firm_mock.finance.revenue_this_turn = 1000.0 # Set on finance
     expected_budget = 1000.0 * 0.2 # 200
 
     # Force success
@@ -146,11 +179,6 @@ def test_hiring_logic(firm_mock, context_mock):
 
 def test_debt_logic_borrow(firm_mock, context_mock):
     manager = CorporateManager(MockConfig())
-    # Assets 1000 (from setup), Debt 0 (assumed default in mock). Leverage 0.
-    # Aggressiveness 0.5 -> Target 1.0 Leverage (1000 Debt)
-    # Ensure total_assets and total_debt are set if computed properties are used
-    # But since it is a mock, we might need to set them if logic depends on them.
-    # The original test manually set assets=1000.
     firm_mock.assets = 1000.0
     firm_mock.total_debt = 0.0
 
diff --git a/tests/test_firms.py b/tests/test_firms.py
index 47eeb69..743866f 100644
--- a/tests/test_firms.py
+++ b/tests/test_firms.py
@@ -39,7 +39,7 @@ class TestFirmBookValue:
     def test_book_value_no_liabilities(self, firm):
         # Assets 1000, Shares 100, Treasury 100
         firm.treasury_shares = 0
-        assert firm.get_book_value_per_share() == 10.0
+        assert firm.finance.get_book_value_per_share() == 10.0
 
     def test_book_value_with_liabilities(self, firm, mock_decision_engine):
         # Setup Liabilities
@@ -53,12 +53,12 @@ class TestFirmBookValue:
         mock_bank.get_debt_summary.return_value = {"total_principal": 200.0}
 
         # Net Assets = 1000 - 200 = 800. Shares 100.
-        assert firm.get_book_value_per_share() == 8.0
+        assert firm.finance.get_book_value_per_share() == 8.0
 
     def test_book_value_with_treasury_shares(self, firm):
         firm.treasury_shares = 20.0
         # Assets 1000. Outstanding Shares 80.
-        assert firm.get_book_value_per_share() == 12.5
+        assert firm.finance.get_book_value_per_share() == 12.5
 
     def test_book_value_negative_net_assets(self, firm, mock_decision_engine):
          # Setup Huge Liabilities
@@ -72,12 +72,12 @@ class TestFirmBookValue:
 
         # Net Assets = 1000 - 2000 = -1000.
         # Should return 0.0
-        assert firm.get_book_value_per_share() == 0.0
+        assert firm.finance.get_book_value_per_share() == 0.0
 
     def test_book_value_zero_shares(self, firm):
         firm.total_shares = 0.0
         firm.treasury_shares = 0.0
-        assert firm.get_book_value_per_share() == 0.0
+        assert firm.finance.get_book_value_per_share() == 0.0
 
 class TestProductionDepartment:
     @pytest.fixture
