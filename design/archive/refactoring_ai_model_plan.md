# AI 모델 리팩토링 계획

**문서 목적**: `simulation/ai_model.py`의 구조적 문제와 시뮬레이션의 비현실적인 결과(가계 소비량 1 고정)를 해결하기 위한 리팩토링 계획을 수립하고 공유합니다.

---

## 1. 문제 분석

1.  **하드코딩된 구매 수량**: `_generate_random_orders` 함수가 가계의 상품 구매 주문 생성 시, 수량을 항상 `1`로 고정하고 있습니다.
2.  **잘못된 의존성**: AI의 의사결정 로직(`make_decisions`) 전체가 후보 행동을 생성하기 위해 위 함수에 의존합니다. 이로 인해 AI는 '수량 1 이외의 구매'라는 선택지를 원천적으로 제안받지 못하여, 현실적인 소비 패턴 학습이 불가능합니다.

---

## 2. 리팩토링 목표

-   AI가 에이전트의 상태(자산 등)에 기반하여 **다양하고 현실적인 수량의 주문을 생성**하도록 개선합니다.
-   '행동 제안'과 '최적 행동 선택'의 책임을 명확히 분리하여 코드의 **모듈성, 가독성, 확장성**을 높입니다.
-   불필요한 객체 복사(`copy.deepcopy`)를 제거하여 **성능을 개선**합니다.

---

## 3. 실행 계획

### 1단계: `ActionProposalEngine` 클래스 신설

-   **목표**: '후보 행동 생성' 로직을 분리합니다.
-   **작업**:
    -   `simulation/decisions/action_proposal.py` 파일을 새로 생성합니다.
    -   `ActionProposalEngine` 클래스를 정의합니다.
    -   이 클래스는 에이전트의 유형과 상태에 따라 현실적인 후보 행동(주문) 목록을 생성하는 `propose_actions` 메서드를 가집니다.

### 2단계: 구매 수량 로직 개선

-   **목표**: 행동 제안의 현실성을 높입니다.
-   **작업**:
    -   `ActionProposalEngine`의 `propose_actions` 메서드 내에서, 구매 주문 생성 시 고정값 `1` 대신 다음 로직을 적용합니다.
        1.  에이전트 자산의 일정 비율(예: 10% ~ 50%)을 지출할 예산으로 랜덤하게 설정합니다.
        2.  상품의 인지된 평균 가격(`perceived_avg_prices`)을 바탕으로 구매 가능한 최대 수량을 계산합니다.
        3.  `1`과 계산된 최대 수량 사이에서 랜덤한 수량을 선택하여 주문을 생성합니다.

### 3단계: `AIDecisionEngine` 리팩토링

-   **목표**: '최적 행동 선택' 책임에 집중하도록 구조를 단순화합니다.
-   **작업**:
    -   `_generate_random_orders` 메서드를 완전히 제거합니다.
    -   `__init__`에서 `ActionProposalEngine` 인스턴스를 주입받도록 수정합니다.
    -   `make_decisions` 메서드를 다음과 같이 수정합니다.
        -   `ActionProposalEngine.propose_actions()`를 호출하여 후보 행동 목록을 받습니다.
        -   **탐색(Exploration)**: 후보 행동 중 하나를 랜덤하게 선택합니다.
        -   **활용(Exploitation)**: 모든 후보 행동에 대해 보상을 예측하고 최적 행동을 선택합니다.
        -   보상 예측 시 `copy.deepcopy(agent)` 대신, 현재 상태 `dict`를 기반으로 자산 변화만 계산하여 가상 상태를 만들어냄으로써 성능을 최적화합니다.

### 4단계: `AITrainingManager` 수정

-   **목표**: 변경된 `AIDecisionEngine` 생성 방식에 맞춰 수정합니다.
-   **작업**:
    -   `get_engine` 메서드에서 `AIDecisionEngine`을 생성할 때, `ActionProposalEngine` 인스턴스도 함께 생성하여 주입해줍니다.

---

## 4. 기대 효과

-   AI가 다양한 소비량을 학습하여 시뮬레이션의 경제가 현실적으로 동작합니다.
-   코드의 역할 분리가 명확해져 유지보수 및 기능 확장이 용이해집니다.
-   의사결정 과정의 성능이 향상됩니다.
