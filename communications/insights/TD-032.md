# Technical Insight Report: TD-032 Multi-Currency Operational Awareness

## 1. Problem Phenomenon
In a multi-currency simulation environment, agents (specifically Firms) fail to accurately assess their financial health and operational metrics because their internal departments (Finance, HR, Sales) rely on hardcoded "primary currency" (e.g., USD/`DEFAULT_CURRENCY`) values or naive aggregations.

**Symptoms:**
*   **Finance**: `finalize_tick` sums expenses across all currencies without conversion (`sum(expenses.values())`). If a firm spends 100 USD and 100 KRW, it records 200 "units" of expense, treating 1 KRW as equal to 1 USD, leading to massively inflated expense tracking and incorrect solvency metrics.
*   **Sales**: Marketing budget ROI calculation (`adjust_marketing_budget`) only looks at `revenue_this_turn` in `DEFAULT_CURRENCY`. Revenue generated in other currencies is ignored, causing the firm to undervalue marketing effectiveness in foreign markets and potentially cut budgets incorrectly.
*   **HR**: Payroll logic (`process_payroll`) checks `DEFAULT_CURRENCY` balance for affordability. A firm with 0 USD but 1,000,000 EUR in assets might fire employees due to "insolvency" because it fails to consider its total liquid assets across currencies.

## 2. Root Cause Analysis
*   **Legacy Assumptions**: The codebase evolved from a single-currency model. Many methods were refactored to accept `Dict[CurrencyCode, float]` but implementation details often defaulted to `.get(DEFAULT_CURRENCY)` or simple sums.
*   **Lack of Context Propagation**: `exchange_rates` are not consistently available to all operational methods. While `Firm.generate_transactions` receives them, it does not propagate them to `HRDepartment` or `SalesDepartment`. `FinanceDepartment.finalize_tick` is called in a separate phase (`PostSequence`) which historically did not fetch or pass exchange rates.
*   **Encapsulation Barriers**: Currency conversion logic was hidden in `FinanceDepartment._convert_to_primary` (protected method), making it difficult for sibling departments (HR, Sales) to perform consistent valuations without code duplication or violation of access modifiers.

## 3. Solution Implementation Details
To resolve TD-032, we implemented "Multi-Currency Operational Awareness" by injecting `exchange_rates` into key operational lifecycle methods and exposing conversion logic:

1.  **FinanceDepartment**:
    *   Exposed `convert_to_primary(amount, currency, exchange_rates)` as a public method to serve as the single source of truth for currency valuation within the Firm.
    *   Updated `finalize_tick(exchange_rates)` to convert all expenses to the primary currency before aggregation.
    *   Verified `calculate_altman_z_score` and `calculate_valuation` use exchange rates correctly.

2.  **SalesDepartment**:
    *   Updated `adjust_marketing_budget(exchange_rates)` to sum revenue across all currencies (converted to primary via `finance.convert_to_primary`) when calculating ROI.

3.  **HRDepartment**:
    *   Updated `process_payroll(..., exchange_rates)` to use Total Liquid Assets (converted) for the "insolvency firing" check, ensuring firms don't fire employees just because they hold the wrong currency denomination (operational awareness).

4.  **Orchestration**:
    *   Updated `Phase5_PostSequence` to fetch market context (exchange rates) and pass them to `finalize_tick`.
    *   Updated `Firm.generate_transactions` to propagate rates to HR and Sales.

## 4. Lessons Learned & Technical Debt
*   **Context Objects**: Passing `exchange_rates` as an argument is a temporary fix. A better approach (TD-Future) would be to inject a scoped `MarketContext` or `PricingService` into the departments upon initialization or method call, reducing signature bloat.
*   **Currency Agnosticism**: Logic should ideally work on `Money` objects that handle conversion internally, rather than raw floats and explicit conversion loops in business logic.
*   **Testing Gaps**: The lack of multi-currency integration tests (scenarios where firms earn in EUR and pay in USD) allowed these naive implementations to persist.
