# Insight Report: TD-176 Taxation Mechanism Decoupling & Atomic Settlement

## 1. Phenomenon
The `TransactionProcessor` was tightly coupled with `Government` and `TaxAgency` logic, directly invoking tax calculations and collection methods. Furthermore, the settlement process for transactions involving taxes (Trade + Tax) was non-atomic; if the tax collection failed after the trade transfer, the trade remained valid, leading to inconsistencies and potential "free lunch" scenarios.

## 2. Cause
The initial implementation prioritized getting features working over strict Separation of Concerns (SoC). `TransactionProcessor` handled too much business logic regarding tax policies. `SettlementSystem` lacked a batch/atomic transfer mechanism.

## 3. Solution
We implemented a Saga-like pattern with Atomic Settlement:
1.  **TaxationSystem**: A new pure-logic module (`modules.government.taxation.system`) responsible for calculating `TaxIntent` (who pays, how much, why).
2.  **Atomic Settlement**: `SettlementSystem.settle_atomic` now accepts a batch of credits. It sums the total debit, withdraws once, and distributes credits. If any credit fails, it rolls back all previous credits in the batch and refunds the debit agent.
3.  **Refactoring**: `TransactionProcessor` now consults `TaxationSystem` for intents, bundles them with the main trade, and executes a single `settle_atomic` call.

## 4. Impact
- **Decoupling**: `TransactionProcessor` no longer needs to know tax rates or formulas. It just executes intents.
- **Data Integrity**: Trades and Taxes are now all-or-nothing. No partial failures.
- **Extensibility**: New tax types can be added to `TaxationSystem` without modifying `TransactionProcessor`'s core loop, provided they fit the "intent" model.

## 5. Lessons Learned
- **Legacy Deprecation**: Transitioning from `government.collect_tax` (which did transfer + recording) to `settle_atomic` (transfer) + `government.record_revenue` (recording) required careful manual construction of result objects to maintain compatible logging/stats.
- **Rollback Complexity**: Implementing rollback logic requires ensuring that the reversal operations (withdrawals) don't fail. In our case, since we just deposited, immediate withdrawal is safe unless concurrent processes interfere (which is not the case in this sequential tick model).
- **Testing**: Mocking agents and simulating failures (e.g., Frozen Bank) was crucial to verify the rollback mechanism.
