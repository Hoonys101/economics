# Insight Report: 부동 소수점 오류로 인한 제로섬 훼손 문제 해결

## 1. 현상 (Phenomenon)
- 세금 계산, 상속, 자산 평가 등 다수의 금융 트랜잭션 과정에서 총자산이 미세하게 변경되는 현상(e.g., `1e-14` 단위의 자산 누수 또는 생성)이 발생하여 제로섬(Zero-Sum) 검증에 실패함.
- 특히, 상속 과정에서 재산을 분배한 후 사망한 에이전트에게 미세한 자산(dust)이 남아있는 경우가 관찰됨.

## 2. 원인 (Cause)
- Python의 표준 부동 소수점(float) 타입은 이진(binary) 방식으로 소수를 표현하므로, 십진수 기반의 금융 값(예: 0.1)을 정확하게 표현하지 못함.
- 이러한 미세한 표현 오차가 곱셈, 덧셈 등 여러 계산을 거치며 누적되어 의미 있는 차이를 만들어냈고, 이는 시스템의 회계 무결성을 훼손하는 직접적인 원인이 됨.

## 3. 해결 (Solution)
- **일관된 반올림 정책 도입**: 시스템 내 모든 금융 계산(자산 평가, 세금 계산, 거래 가치 산정, 분배 등)의 최종 결과 값에 `round(value, 2)`를 적용하여 소수점 2자리로 정밀도를 통일함.
- **중앙화된 반올림 함수**: `TaxationSystem`에 `_round_currency` 헬퍼 함수를 도입하여 세금 계산 로직 내에서 일관성을 유지함.
- **핸들러 레벨 검증**: 각 트랜잭션 핸들러(`GoodsTransactionHandler`, `InheritanceHandler`)에서도 계산 과정과 최종 결과에 반올림을 적용하여 제로섬을 이중으로 보장함.

## 4. 교훈 (Lesson Learned)
- **부동 소수점 타입(float)을 금융 계산에 직접 사용하는 것은 절대적으로 지양해야 한다.** 미세한 오차도 시스템 전체의 무결성을 파괴할 수 있다.
- 모든 금융 계산 단계에서는 반드시 명시적인 정밀도 관리(반올림 또는 `Decimal` 타입 사용)가 필요하다. "이 정도는 괜찮겠지"라는 가정은 반드시 버그로 이어진다.
- 자산이 생성되거나 소멸되는 것처럼 보이는 회계 버그가 발생하면, 가장 먼저 부동 소수점 연산을 의심해야 한다.
